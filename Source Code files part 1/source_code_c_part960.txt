R;
            break;
        }

        //
        // Get the screen dc to do the palette mapping with
        //

        hdc = GetDC(NULL);

        if (!hdc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Create a palette that can be used on this computer's display and
        // which will represent the DIB's colors as accurately as possible.
        //

        int iNumColors;
        *phPalette =  CreateDIBPalette((LPBITMAPINFO)pbih, &iNumColors);

        if (!*phPalette)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        VERIFY(SelectPalette(hdc, *phPalette, FALSE));
        UINT uiMapped = RealizePalette(hdc);

        DEBUG_OUT((DEB_ITRACE,
                  "Mapped %u logical palette entries to system palette entries\n",
                  uiMapped));

        if (uiMapped == GDI_ERROR)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        hBitmapFinal = CreateDIBitmap(hdc,
                                      pbih,
                                      CBM_INIT,
                                      (PBYTE) pbih + pbih->biSize + iNumColors *
                                        sizeof(RGBQUAD),
                                      (LPBITMAPINFO) pbih,
                                      DIB_RGB_COLORS);

        if (!hBitmapFinal)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // If we got here, everything succeeded
        //

        hr = S_OK;
    } while (0);

    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    if (FAILED(hr) && *phPalette)
    {
        DeleteObject(*phPalette);
        *phPalette = NULL;
    }
    return hBitmapFinal;
}

#endif // WIZARD95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\walklink.h ===
/*
 *	History
 *	Date		email id	comment
 *	26 Dec 96	neerajm		Changed the INPTYPE #DEFINEs
 *
 *
 *
 *
 *
 *
 *
 *
 */


#ifndef WALK_H
#define WALK_H

#ifdef __cplusplus
extern "C" {
#endif


/* definitions */
#define MAX_DESC					500
#define MAX_PRODNAME				500
#define MAX_COMPNAME				500
#define RESOLVEWAIT					500   //msec

#define INPTYPE_STARTMENU			0x0001		
#define INPTYPE_DESKTOP				0x0002
#define	INPTYPE_ANYFOLDER			0x0004
#define INPTYPE_WININIRUN			0x0008
//#define	INPTYPE_SYSINIRUN			0x0010
//#define INPTYPE_ANYINIRUN			0x0020
#define INPTYPE_REGRUN				0x0040
#define INPTYPE_REGRUNSERVICES		0x0080
#define INPTYPE_REGRUNONCE			0x0100
#define INPTYPE_REGRUNSERVICESONCE	0x0200
#define INPFLAG_SKIPFILES			0x80000000
#define INPFLAG_AGGRESSION			0x40000000

#define APPCOMPATIBLE				1
#define APPINCOMPATIBLE				0
#define	APPCOMPATUNKNOWN			-1

/* ERRORS */
#define ERR_WINPATH					-1
#define ERR_SETCURRENTDIR			-2
#define ERR_NOMEMORY				-6
#define ERR_UNKNOWN					-999
#define ERR_NOTANEXE				-11
#define	ERR_SUCCESS					0
#define ERR_RESOLVEFAIL				-7
#define ERR_FILEVERSIONFAIL			-12
#define ERR_LADSETFAILED			-13
#define ERR_CURRDIR					-3
#define	ERR_MOREFILESTOCOME			1
#define	ERR_NOSTARTMENU				-14
#define	ERR_NODESKTOP				-15
#define	ERR_NOSHELLFOLDERS			-16
#define	ERR_NOCURRENTVERSION		-17
#define	ERR_BADFLAG					-18
#define	ERR_FILENOTFOUND			-19

typedef struct 
{
		TCHAR		szLnkName[MAX_PATH];
		TCHAR		szLnkPath[MAX_PATH];
		TCHAR		szExeName[MAX_PATH];
		TCHAR		szExePath[MAX_PATH];
        TCHAR       tszArguments[MAX_PATH];
		FILETIME	ftExeLAD;
		TCHAR		szExeVersionInfo[MAX_PATH];
		DWORD		dwExeVerMS;
		DWORD		dwExeVerLS;
		TCHAR		szExeDesc[MAX_DESC];
		TCHAR		szExeProdName[MAX_PRODNAME];
		TCHAR		szExeCompName[MAX_COMPNAME];
		TCHAR		szFlags[4];
		DWORD		dwHelpId;
		INT			iAppCompat;
}	LINKINFO, *LPLINKINFO;

typedef HANDLE HWALK;

typedef INT ERR;

/* procedure definitions */

HWALK	GetFirstFileLnkInfo(LPLINKINFO lpLnkInfo, DWORD dwWalkFlags, 
							LPTSTR lpszFolder, ERR *RetErr);
ERR		GetNextFileLnkInfo(HWALK hWalk, LPLINKINFO lpLnkInfo);
void	CloseWalk(HWALK hWalk);
ERR     GetExeVersion(LPLINKINFO lpLnkInfo);
BOOL    GetFileLAD(LPLINKINFO lpLnkInfo);


#ifdef __cplusplus
}
#endif

#endif  /* !WALK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\walklib.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"
#include <shlobjp.h>    // IShellLinkDataList
#include <shlguidp.h>   // IID_IShellLinkDataList
#include <msi.h>        // MsiQueryProductState

#include <stdlib.h>
#include <process.h>
#include <winver.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include "walklib.h"
#include "..\inc\misc.hxx"


typedef INSTALLSTATE (WINAPI* PFN_MsiQueryProductState) (LPCTSTR tszProduct);

BOOL
IsMsiApp(
    IShellLink *    psl
    );


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



HWALK GetFirstFileLnkInfo(LPLINKINFO lpLnkInfo, DWORD dwFlags,
						  LPTSTR lpszFolder, ERR *pErrRet)
{
	BOOL				bRC=TRUE;
	ERR					errVal;
	LPWALKHEADER		lpWalk;
	LPTSTR				lpszSubStr;
	TCHAR				szFullPath[MAX_PATH];

#ifdef _DEBUG
	lpWalk = (LPWALKHEADER) MyGlobalAlloc(FAILMEMA, sizeof(WALKHEADER));
#else
	lpWalk = (LPWALKHEADER) GlobalAlloc(GPTR, sizeof(WALKHEADER));
#endif

	if (lpWalk == NULL)
	{
		*pErrRet = ERR_NOMEMORY ;//ERR_NOMEMORY -6;
		return  NULL; // Global Alloc failed
	}

	lpWalk->lpSrchDirListHead = NULL;
	lpWalk->lpSrchDirListTail = NULL;
	lpWalk->lpszIniString = NULL;
	lpWalk->lpszNextFile = NULL;
	lpWalk->dwCurrentFlag = RESET_FLAG;
	lpWalk->dwWalkFlags = dwFlags;
	if (lpWalk->dwWalkFlags & INPTYPE_ANYFOLDER)
	{
		if (IsBadStringPtr(lpszFolder, MAX_PATH))
			lpWalk->lpszFolder = NULL;
		else		
			lpWalk->lpszFolder = lpszFolder;
	}
	else
		lpWalk->lpszFolder = NULL;


	SetLnkInfo(lpLnkInfo);
	errVal = GetFileHandle(lpLnkInfo, lpWalk, szFullPath);
	if (errVal == 0)
	{
		*pErrRet = ERR_SUCCESS;//ERR_NOMOREFILES 0;
		CloseWalk(lpWalk);
		return  NULL; /* No more files: Done */
	}
	else if (errVal < 0)
	{
		*pErrRet = errVal;
		CloseWalk(lpWalk);
		return NULL;
	}

	lpszSubStr = _tcsrchr(lpLnkInfo->szLnkName, TEXT('.'));
	
	if (lpszSubStr)
	{
		if ((_tcsicmp(lpszSubStr, TEXT(".LNK")) == 0) ||
			(_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0))
		{
			if (!(errVal = GetLnkInfo(lpWalk, lpLnkInfo, szFullPath)))
			{
				lpszSubStr = _tcsrchr(lpLnkInfo->szExeName, TEXT('.'));
				if (lpszSubStr)
				{
					if (_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0 ||
                        _tcsicmp(lpszSubStr, TEXT(".LNK")) == 0)
					{
                        *pErrRet = ERR_MOREFILESTOCOME;// ERR_SUCCESS but there are more files;
                        return  lpWalk;
					}
				}
			}
		}
	}
	if ((errVal == ERR_NOTANEXE) || errVal > 0)
	{
		*pErrRet = GetNextFileLnkInfo(lpWalk, lpLnkInfo);
		if ((*pErrRet != ERR_SUCCESS) && (*pErrRet != ERR_MOREFILESTOCOME))
		{
			CloseWalk(lpWalk);
			return NULL;
		}
		else
			return  lpWalk;
	}
	else
	{
		*pErrRet = errVal;	
		CloseWalk(lpWalk);
		return NULL;
	}
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetNextFileLnkInfo(HWALK hWalk, LPLINKINFO lpLnkInfo)
{	
	BOOL				bRC=TRUE;
	INT					retVal;
	LPTSTR				lpszSubStr;
	TCHAR				szFullPath[MAX_PATH];

	LPWALKHEADER lpWalk = (LPWALKHEADER) hWalk;

	while (1)
	{
		retVal = GetFileHandle(lpLnkInfo, lpWalk, szFullPath);
		if (retVal < 0)
			return retVal; /* Couldn't find next file */
		else if (retVal == 0 )  /* Done : No more files */
			return ERR_SUCCESS;

		lpszSubStr = _tcsrchr(lpLnkInfo->szLnkName, TEXT('.'));

		if (lpszSubStr)
		{
			if ((_tcsicmp(lpszSubStr, TEXT(".LNK")) == 0) ||
				(_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0))
			{
				if (!(retVal = GetLnkInfo(lpWalk, lpLnkInfo, szFullPath)))
				{
					lpszSubStr = _tcsrchr(lpLnkInfo->szExeName, TEXT('.'));
					if (lpszSubStr)
					{
						if (_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0 ||
                            _tcsicmp(lpszSubStr, TEXT(".LNK")) == 0)
						{
						    break;
						}
					}
				}
				else if (retVal != ERR_NOTANEXE)
					return retVal;
			}
		}
		continue; /* Not a Link File */
	}
	return ERR_MOREFILESTOCOME;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



BOOL InSkipList(LPTSTR lpszFileName)
{
	INT i;
	LPTSTR	lplpszToSkipFiles[] =
			{
				TEXT("write.exe"),
				TEXT("winhelp.exe"),
				TEXT("winhlp32.exe"),
				TEXT("notepad.exe"),
				TEXT("wordpad.exe"),
				TEXT("rundll32.exe"),
                TEXT("explorer.exe"),
                TEXT("control.exe")
			};

	for (i = 0; i < ARRAYLEN(lplpszToSkipFiles); i++)
	{
		if (_tcsicmp(lpszFileName, lplpszToSkipFiles[i]) == 0)
			return TRUE;
	}
	return FALSE;
}



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



INT GetFileHandle(LPLINKINFO lpLnkInfo, LPWALKHEADER lpWalk, LPTSTR lpszPath)
{	
	DWORD				dwAttrs;
	BOOL				bRC;
	HANDLE				hSearch;
	INT					retVal;
	TCHAR				szFolderPath[MAX_PATH];
	WIN32_FIND_DATA		wfdFileData;
	
	DEBUG_ASSERT(lpWalk != NULL);

	while (GetInputType(lpWalk) == FOLDER)
	{
		SetLnkInfo(lpLnkInfo);
		if (lpWalk->lpSrchDirListHead == NULL)
		{
			if (retVal = GetFolder(szFolderPath, lpWalk))
				return retVal;

			if (!SetCurrentDirectory(szFolderPath))
			{
				lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
				goto LoopBack;
//				return ERR_SETCURRENTDIR;
			}

			hSearch = FindFirstFile(TEXT("*"), &wfdFileData);
			if (hSearch == INVALID_HANDLE_VALUE)
			{
				lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
				goto LoopBack;
			}
			else
			{
				retVal = AddToList(hSearch, lpWalk);
				if (retVal == ERR_NOMEMORY)
					return ERR_NOMEMORY; // GlobalAlloc failed
			}
		}
		else
		{
			while (!(bRC = FindNextFile(lpWalk->lpSrchDirListTail->hDirHandle, &wfdFileData)))
			{
				if (GetLastError() == ERROR_NO_MORE_FILES)
				{
					FindClose(lpWalk->lpSrchDirListTail->hDirHandle);
					RemoveFromList(lpWalk);
					if (lpWalk->lpSrchDirListHead == NULL)
					{
						lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
						goto LoopBack;
					}
					SetCurrentDirectory(TEXT(".."));
				}
				else
					return ERR_UNKNOWN ; // should never come here
			}
		}
			
		dwAttrs = GetFileAttributes(wfdFileData.cFileName);
		while (dwAttrs & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (_tcsicmp(wfdFileData.cFileName, TEXT(".")) &&
				_tcsicmp(wfdFileData.cFileName, TEXT("..")))
			{		
				SetCurrentDirectory(wfdFileData.cFileName);			
				hSearch = FindFirstFile(TEXT("*"), &wfdFileData);
				if (hSearch == INVALID_HANDLE_VALUE)
				{
					if (lpWalk->lpSrchDirListHead == NULL)
					{
						lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
						goto LoopBack;
					}
					else
						return ERR_UNKNOWN; // Never comes here for all dirs have . and ..
				}
				retVal = AddToList(hSearch, lpWalk);
				if (retVal == ERR_NOMEMORY)
					return ERR_NOMEMORY; // GlobalAlloc failed
				dwAttrs = GetFileAttributes(wfdFileData.cFileName);
			}
			else
			{
				while (!(bRC = FindNextFile(lpWalk->lpSrchDirListTail->hDirHandle, &wfdFileData)))
				{
					if ((GetLastError() == ERROR_NO_MORE_FILES))
					{
						FindClose(lpWalk->lpSrchDirListTail->hDirHandle);
						RemoveFromList(lpWalk);
						if (lpWalk->lpSrchDirListHead == NULL)
						{
							lpWalk->dwWalkFlags = lpWalk->dwWalkFlags & (~lpWalk->dwCurrentFlag);
							goto LoopBack;
						}
						SetCurrentDirectory(TEXT(".."));
					}
					else
						return ERR_UNKNOWN ; //should never come here			
				}
				dwAttrs = GetFileAttributes(wfdFileData.cFileName);
			}
		}
		lstrcpy(lpLnkInfo->szLnkName, wfdFileData.cFileName);
		GetCurrentDirectory(MAX_PATH, lpLnkInfo->szLnkPath);  //BUG
		lstrcpy(lpLnkInfo->szExeName, lpLnkInfo->szLnkName);
		lstrcpy(lpLnkInfo->szExePath, lpLnkInfo->szLnkPath);
		wsprintf(lpszPath, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);


		return ERR_MOREFILESTOCOME;
LoopBack:
		lpWalk->dwCurrentFlag = RESET_FLAG;
		continue;
	}

	DEBUG_ASSERT(GetInputType(lpWalk) != INIFILE);
	DEBUG_ASSERT(GetInputType(lpWalk) != REGISTRY);

	return ERR_SUCCESS; //This means we are done with all of them.
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetNextFileFromString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



BOOL GetFileLAD(LPLINKINFO lpLnkInfo)
{
	WIN32_FIND_DATA		wfdFileData;
	HANDLE				hSearch;
	TCHAR				szTempStr[MAX_PATH];
	
	lstrcpy(szTempStr, lpLnkInfo->szExePath);
	lstrcat(szTempStr, TEXT("\\"));
	lstrcat(szTempStr, lpLnkInfo->szExeName);

	if (!_tcschr(szTempStr, '.'))
		lstrcat(szTempStr, TEXT(".exe"));

	if ( NULL == szTempStr && _tcsicmp(_tcschr(szTempStr, '.'), TEXT(".exe")) != 0)
		return FALSE;
	//bugbug performance hit

	hSearch = FindFirstFile( szTempStr, &wfdFileData);
	if (hSearch == INVALID_HANDLE_VALUE)
		return FALSE;	
	else
	{
		lpLnkInfo->ftExeLAD = wfdFileData.ftLastAccessTime;
		FindClose(hSearch);
		return TRUE;
	}
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetRegistryString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR GetIniString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



INT GetInputType(LPWALKHEADER lpWalk)
{
	if (lpWalk->dwWalkFlags & INPTYPE_FOLDER)
	{
		return FOLDER;
	}
	if (lpWalk->dwWalkFlags & INPTYPE_INIFILE)
	{
		return INIFILE;
	}
	if (lpWalk->dwWalkFlags & INPTYPE_REGISTRY)
	{
		return REGISTRY;
	}
	return ERR_UNKNOWN; // should never come here
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR GetFolder(LPTSTR lpszFolder, LPWALKHEADER lpWalk)
{
	HKEY			hKey;
	UINT			cchFolder = MAX_PATH;
	TCHAR			szRegVal[MAX_PATH];
	DWORD			dwType;

	if (!(lpWalk->dwWalkFlags & INPTYPE_ANYFOLDER))
	{
		if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SHELLFOLDERS, 0, KEY_READ, &hKey)
						== ERROR_SUCCESS)
		{
			if (lpWalk->dwWalkFlags & INPTYPE_STARTMENU)
			{
				lstrcpy(szRegVal, TEXT("Start Menu"));
				lpWalk->dwCurrentFlag = INPTYPE_STARTMENU;
			}
			else if (lpWalk->dwWalkFlags & INPTYPE_DESKTOP)
			{
				lstrcpy(szRegVal, TEXT("Desktop"));
				lpWalk->dwCurrentFlag = INPTYPE_DESKTOP;
			}

			cchFolder = ARRAYLEN(szRegVal);
            LONG lr = RegQueryValueEx(hKey,
                                      szRegVal,
                                      NULL,
                                      &dwType,
                                      (LPBYTE)lpszFolder,
                                      (ULONG *)&cchFolder);


            if (dwType == REG_EXPAND_SZ)
            {
                TCHAR tszTemp[MAX_PATH];
                ExpandEnvironmentStrings(lpszFolder,
                                        tszTemp,
                                        ARRAYLEN(tszTemp));
                lstrcpy(lpszFolder, tszTemp);
            }

			if (lr != ERROR_SUCCESS)
			{
                RegCloseKey(hKey);

				if (lpWalk->dwWalkFlags & INPTYPE_STARTMENU)
				{
					return ERR_NOSTARTMENU;
				}
				else
				{
					return ERR_NODESKTOP;
				}
			}
			RegCloseKey(hKey);
		}
		else
			return ERR_NOSHELLFOLDERS;
	}
	else
	{
		lstrcpy(lpszFolder, (LPTSTR) lpWalk->lpszFolder);
		lpWalk->dwCurrentFlag = INPTYPE_ANYFOLDER;
	}
	return ERR_SUCCESS;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



ERR GetLnkInfo(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo, LPTSTR lpszPath)
{
	WIN32_FIND_DATA wfdExeData;
	ERR				errVal = ERR_NOTANEXE;
	UINT			uiDType;
	TCHAR			szExepath[MAX_PATH];
	TCHAR			szDrivePath[MAX_PATH];
	LPTSTR			lpszSubStr;
	INT				iLen1, iLen2;
	BOOL			bExists;

//BUGBUG THe if thens should be such that there is repetition of code
	szExepath[0] = '\0';
    LPTSTR ptszExt = PathFindExtension(lpLnkInfo->szLnkName);

	if (ptszExt && !_tcsicmp(ptszExt, TEXT(".LNK")))
	{
 		if (!(errVal = ResolveLnk(lpszPath, szExepath, &wfdExeData, (LPTSTR)lpLnkInfo->tszArguments)))
		{
			if (lpszSubStr = _tcsrchr(szExepath, TEXT('.')))
			{
				if (_tcsicmp(lpszSubStr, TEXT(".EXE")) == 0 ||
                    _tcsicmp(lpszSubStr, TEXT(".LNK")) == 0)
				{
					if (lpszSubStr = _tcsrchr(szExepath, '\\'))
						lpszSubStr++;
					else
						lpszSubStr = szExepath;
					lstrcpy(lpLnkInfo->szExeName, lpszSubStr);
					iLen1 = lstrlen(szExepath);
					iLen2 = lstrlen(lpLnkInfo->szExeName);
					*(szExepath + iLen1 - iLen2 - 1) = TEXT('\0');
					lstrcpy(lpLnkInfo->szExePath, szExepath);
					GetFileLAD(lpLnkInfo);

					wsprintf(szExepath, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);

					GetDrivePath(szExepath, szDrivePath);
					uiDType = GetDriveType(szDrivePath);

					if ((lpWalk->dwWalkFlags & INPFLAG_SKIPFILES ) && (InSkipList(lpLnkInfo->szExeName)))
                    {
						errVal = ERR_NOTANEXE;
                    }
					else if (!(lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
						 (uiDType != DRIVE_FIXED))
						errVal = ERR_NOTANEXE;
					else if ((lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
						 (uiDType != DRIVE_FIXED) && (uiDType != DRIVE_REMOTE) && (uiDType != DRIVE_CDROM))
						errVal = ERR_NOTANEXE;
					else if (!(bExists = CheckFileExists(szExepath, &(lpLnkInfo->ftExeLAD))) && (uiDType == DRIVE_FIXED))
						errVal = ERR_NOTANEXE;
					else if (!(errVal = GetExeVersion(lpLnkInfo)))
					{
								errVal = ERR_SUCCESS;
					}
				}
				else
					errVal = ERR_NOTANEXE;
			}
			else
				errVal = ERR_NOTANEXE; // link resolved to a non exe

			if (errVal == ERR_SUCCESS)
				*(_tcsrchr(lpLnkInfo->szLnkName, TEXT('.'))) = '\0';
		}
		else
			errVal = ERR_NOTANEXE;
	}
	else if (ptszExt && !_tcsicmp(ptszExt, TEXT(".EXE")))
	{
		lstrcpy(lpLnkInfo->szExeName, lpLnkInfo->szLnkName);
		wsprintf(szExepath, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);

		GetDrivePath(szExepath, szDrivePath);
		uiDType = GetDriveType(szDrivePath);
		GetFileLAD(lpLnkInfo);
		
		if ((lpWalk->dwWalkFlags & INPFLAG_SKIPFILES) && (InSkipList(lpLnkInfo->szExeName)))
			errVal = ERR_NOTANEXE;
		else if (!(lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
			 (uiDType != DRIVE_FIXED))
			errVal = ERR_NOTANEXE;
		else if ((lpWalk->dwWalkFlags & INPFLAG_AGGRESSION) &&
			 (uiDType != DRIVE_FIXED) && (uiDType != DRIVE_REMOTE) && (uiDType != DRIVE_CDROM))
			errVal = ERR_NOTANEXE;
		else if (!(bExists = CheckFileExists(szExepath, &(lpLnkInfo->ftExeLAD))) && (uiDType == DRIVE_FIXED))
			errVal = ERR_NOTANEXE;
		else if (!(errVal = GetExeVersion(lpLnkInfo)))
					errVal = ERR_SUCCESS;
	}
	return errVal;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

void GetDrivePath(LPTSTR lpszExePath, LPTSTR lpszDrPath)
{
	LPTSTR lpszSubStr;
	if (s_isDriveLetter(lpszExePath[0]) && lpszExePath[1] == TEXT(':'))
	{
		lstrcpyn(lpszDrPath, lpszExePath, 3);
		lstrcat(lpszDrPath, TEXT("\\"));
	}
	else if (!_tcsncmp(lpszExePath, TEXT("\\\\"), 2))
	{
		if (lpszSubStr = _tcschr(&lpszExePath[2], TEXT('\\')))
		{
			if (lpszSubStr = _tcschr(lpszSubStr+1, TEXT('\\')))
			{
				lstrcpyn(lpszDrPath, lpszExePath, (size_t)(lpszSubStr - lpszExePath + 1));
				lpszDrPath[lpszSubStr - lpszExePath + 1] = TEXT('\0');
			}
		}
	}
	else
		lpszDrPath[0] = '\0';
}

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR ResolveLnk(LPCTSTR pszShortcutFile, LPTSTR lpszLnkPath,
				   LPWIN32_FIND_DATA lpwfdExeData, LPTSTR tszArgs)
{
	HRESULT		hres;
	IShellLink	*psl;
	TCHAR		szGotPath[MAX_PATH];
	HWND		hwnd = NULL;
	ERR			errVal = ERR_RESOLVEFAIL;

    *tszArgs = TEXT('\0');
	// Get a pointer to the IShellLink interface.
	hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
					IID_IShellLink, (void **)&psl);
	if (SUCCEEDED(hres))
	{
		IPersistFile* ppf;

		// Get a pointer to the IPersistFile interface.
		hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
		if (SUCCEEDED(hres))
		{
			WCHAR wsz[MAX_PATH];

#ifndef UNICODE
			// Ensure string is Unicode.
			MultiByteToWideChar(CP_ACP, 0, pszShortcutFile, -1, wsz, MAX_PATH);
#else
            lstrcpyn(wsz, pszShortcutFile, ARRAYLEN(wsz));
#endif
			// Load the shell link.
			hres = ppf->Load(wsz, STGM_READ);
			if (SUCCEEDED(hres))
			{
                DEBUG_OUT((DEB_ITRACE, "Link: %ws\n", wsz));
                //
                // If the link is to an MSI app, don't get the path to the
                // link target - use the path to the link itself instead.
                //
                if (IsMsiApp(psl))
                {
                    errVal = ERR_SUCCESS;
                    lstrcpy(lpszLnkPath, pszShortcutFile);
                }
                else
                {
                    lstrcpyn(szGotPath, pszShortcutFile, MAX_PATH);

                    // Get the path to the link target.
                    hres = psl->GetPath(szGotPath, MAX_PATH, (LPWIN32_FIND_DATA)lpwfdExeData,
                                        SLGP_SHORTPATH );
                    if (!SUCCEEDED(hres))
                    {
                        DEBUG_OUT((DEB_ITRACE, "  GetPath failed %#x\n", hres));
                        errVal = ERR_RESOLVEFAIL; /* get path failed : Link not resolved */
                    }
                    else
                    {
                        DEBUG_OUT((DEB_ITRACE, "  Path: %ws\n", szGotPath));
                        if (lstrlen(szGotPath) > 0)
                        {
                            errVal = ERR_SUCCESS;
                            lstrcpy(lpszLnkPath, szGotPath);
                        }
                        else
                        {
                            errVal = ERR_RESOLVEFAIL;
                        }
                    }

                    hres = psl->GetArguments(tszArgs, MAX_PATH);
                    CHECK_HRESULT(hres);
                }
			}
			// Release pointer to IPersistFile interface.
			ppf->Release();
		}
		// Release pointer to IShellLink interface.
		psl->Release();
	}
	return errVal;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR AddToList(HANDLE hDir, LPWALKHEADER lpWalk)
{
	LPHSEARCHDIR lpSrchDirNode;

#ifdef _DEBUG
	lpSrchDirNode = (LPHSEARCHDIR) MyGlobalAlloc(FAILMEMA, sizeof(HSEARCHDIR));
#else
	lpSrchDirNode = (LPHSEARCHDIR) GlobalAlloc(GPTR, sizeof(HSEARCHDIR));
#endif

	if (lpSrchDirNode == NULL)
	  return ERR_NOMEMORY; /* Global Alloc failed */
	
	lpSrchDirNode->hDirHandle = hDir;
	lpSrchDirNode->lpSrchDirNext = NULL;
	
	if (lpWalk->lpSrchDirListHead == NULL)
	  lpWalk->lpSrchDirListHead = lpSrchDirNode;
	else
	  lpWalk->lpSrchDirListTail->lpSrchDirNext = lpSrchDirNode;

	lpWalk->lpSrchDirListTail = lpSrchDirNode;
	return ERR_SUCCESS;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR RemoveFromList(LPWALKHEADER lpWalk)
{
	LPHSEARCHDIR lpSrchDirNode;

	if (lpWalk->lpSrchDirListHead == NULL)
		return ERR_SUCCESS;

	lpSrchDirNode = lpWalk->lpSrchDirListHead;
	while (	(lpSrchDirNode->lpSrchDirNext != lpWalk->lpSrchDirListTail) &&
			(lpSrchDirNode != lpWalk->lpSrchDirListTail))
	{
		lpSrchDirNode = lpSrchDirNode->lpSrchDirNext;
	}

	if (lpSrchDirNode != lpWalk->lpSrchDirListTail)
	{
#ifdef _DEBUG
		MyGlobalFree(lpWalk->lpSrchDirListTail, FAILMEMF);
#else
		GlobalFree(lpWalk->lpSrchDirListTail);
#endif
		lpSrchDirNode->lpSrchDirNext = NULL;
		lpWalk->lpSrchDirListTail = lpSrchDirNode;
	}
	else
	{
#ifdef _DEBUG
		MyGlobalFree(lpWalk->lpSrchDirListTail, FAILMEMF);
#else
		GlobalFree(lpWalk->lpSrchDirListTail);
#endif
		lpWalk->lpSrchDirListHead = NULL;
		lpWalk->lpSrchDirListTail = NULL;
	}
		
	return ERR_SUCCESS;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


ERR GetExeVersion(LPLINKINFO lpLnkInfo)
{
	LPTSTR  lpVersion;
	DWORD   dwVerInfoSize;
	DWORD   dwVerHnd;
	WORD    wVersionLen;
	WORD    wRootLen;
	BOOL    bRetCode;
	TCHAR	szGetName[100];
	TCHAR	szFullName[MAX_PATH];
	ERR		errVal;
	LPTSTR  lpstrVffInfo;


	// Get the file version info size
	wsprintf(szFullName, TEXT("%s\\%s"), lpLnkInfo->szExePath, lpLnkInfo->szExeName);
	dwVerInfoSize = GetFileVersionInfoSize(szFullName, &dwVerHnd);

	if (dwVerInfoSize)
	{
		// allocate memory to hold the verinfo block

#ifdef _DEBUG
		lpstrVffInfo = (LPTSTR) MyGlobalAlloc(FAILMEMA, dwVerInfoSize);
#else
		lpstrVffInfo = (LPTSTR) GlobalAlloc(GPTR, dwVerInfoSize);
#endif
		if (lpstrVffInfo == NULL)
		{
			errVal = ERR_NOMEMORY; //Global Alloc failed
			goto Exit;
		}

		bRetCode = GetFileVersionInfo(szFullName, dwVerHnd, dwVerInfoSize, lpstrVffInfo);
		if (!bRetCode)
		{
			errVal = ERR_SUCCESS; //ERR_FILEVERSIONFAIL;
			goto Exit;
		}
		//GetFileVersionInfo failed
		// Do this the American english translation be default.
		// Keep track of the string length for easy updating.
		// 040904E4 represents the language ID and the four
		// least significant digits represent the codepage for
		// which the data is formatted.  The language ID is
		// composed of two parts: the low ten bits represent
		// the major language and the high six bits represent
		// the sub language.

		bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
						TEXT("\\"),
						(void FAR* FAR*) &lpVersion,
						(UINT FAR*)&wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			lpLnkInfo->dwExeVerMS =
				((VS_FIXEDFILEINFO *)lpVersion)->dwProductVersionMS;
			lpLnkInfo->dwExeVerLS =
				((VS_FIXEDFILEINFO *)lpVersion)->dwProductVersionLS;
		}
		else
		{
			lpLnkInfo->dwExeVerMS = 0;
			lpLnkInfo->dwExeVerLS = 0;
		}
		
		bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
						TEXT("\\VarFileInfo\\Translation"),
						(void FAR* FAR*) &lpVersion,
						(UINT FAR*)&wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			DWORD	dwLangCharSet;
			WORD	wTemp1, wTemp2;
			CopyMemory(&dwLangCharSet, lpVersion, 4);
			if (!dwLangCharSet)
				dwLangCharSet = 0x04E40409; // the Words have been switched

			// Need to switch the words back since lpbuffer has them reversed
			wTemp1 = LOWORD(dwLangCharSet);
			wTemp2 = HIWORD(dwLangCharSet);
			wsprintf(szGetName, TEXT("\\StringFileInfo\\%04lx%04lx\\"), wTemp1, wTemp2);
		}
		else
		{
			errVal = ERR_SUCCESS;
			goto Exit;
		}

		wRootLen = (WORD)lstrlen(szGetName);

		// "Illegal string"  "CompanyName"   "FileDescription",
		// "FileVersion"     "InternalName"  "LegalCopyright"
		// "LegalTrademarks" "ProductName"   "ProductVersion

		lstrcat(szGetName, TEXT("FileVersion"));
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			lstrcpy(lpLnkInfo->szExeVersionInfo, lpVersion);
		}
		// Now let's get FileDescription

		szGetName[wRootLen] = NULL;
		lstrcat(szGetName, TEXT("FileDescription"));
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			lstrcpy(lpLnkInfo->szExeDesc, lpVersion);
		}

		szGetName[wRootLen] = NULL;
		lstrcat(szGetName, TEXT("CompanyName"));
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			lstrcpy(lpLnkInfo->szExeCompName, lpVersion);
		}
		
		szGetName[wRootLen] = NULL;
		lstrcat(szGetName, TEXT("ProductName"));
		wVersionLen   = 0;
		lpVersion     = NULL;

		// Look for the corresponding string.
		bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
							szGetName,
							(void FAR* FAR*)&lpVersion,
							(UINT FAR *) &wVersionLen);

		if ( bRetCode && wVersionLen && lpVersion)
		{
			lstrcpy(lpLnkInfo->szExeProdName, lpVersion);
		}
   		
		/*   else if (i == 1)
			{
			// This is an attempt to special case the multimedia
			// extensions.  I think they paid attention to the
			// original docs which suggested that they use the
			// 0409 language ID and 0 codepage which indicates
			// 7 bit ASCII.

			lstrcpy(szGetName, TEXT("\\StringFileInfo\\04090000\\"));
			i = 0;                    // be sure to reset the counter
			}*/

		// Be sure to reset to NULL so that we can concat
		errVal = ERR_SUCCESS;
		goto Exit;
	}
	else
	{
		lpLnkInfo->dwExeVerMS = 0;
		lpLnkInfo->dwExeVerLS = 0;
		return ERR_SUCCESS;
	}

Exit :
	if (errVal != ERR_NOMEMORY)
	{
#ifdef _DEBUG
		MyGlobalFree(lpstrVffInfo, FAILMEMF);
#else
		GlobalFree(lpstrVffInfo);
#endif
// Be sure to reset to NULL so that we can concat
		lpstrVffInfo = NULL;
	}

	return errVal;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


void SetLnkInfo(LPLINKINFO lpLinkInfo)
{
	ZeroMemory((void *)lpLinkInfo, sizeof(LINKINFO));
	lpLinkInfo->iAppCompat = APPCOMPATUNKNOWN;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

DWORD ReverseDWord(DWORD dwIn)
{
	DWORD dwOut= 0;
	while (dwIn != 0)
	{
		dwOut = dwOut << 8;
		dwOut =  dwOut | (dwIn & 0x000000FF);
		dwIn = dwIn >> 8;	
	}
	return dwOut;
}


/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////



BOOL CheckFileExists(LPTSTR szFullName, LPVOID ftLAD)
{
	BOOL bRC;
	HANDLE hFile;

	SetErrorMode(SEM_FAILCRITICALERRORS);
	hFile = CreateFile(
			szFullName,	// pointer to name of the file
			GENERIC_READ | GENERIC_WRITE,	// access (read-write) mode
			FILE_SHARE_READ|FILE_SHARE_WRITE,	// share mode
			NULL,	// pointer to security attributes
			OPEN_EXISTING,	// how to create
			NULL,	// file attributes
			NULL	// handle to file with attributes to copy
			);
	int i = GetLastError();
	if ((hFile == INVALID_HANDLE_VALUE) &&
		((i == ERROR_FILE_NOT_FOUND) || (i == ERROR_PATH_NOT_FOUND) ||
 		 (i == ERROR_BAD_NETPATH)))
	{
		bRC = FALSE;
	}
	else if (hFile == INVALID_HANDLE_VALUE)
		bRC = TRUE;
	else
	{
		if (ftLAD != 0)
			SetFileTime(hFile, NULL, (FILETIME *) ftLAD, NULL);

		CloseHandle(hFile);
		bRC = TRUE;
	}

	return bRC;
}



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


void CloseWalk(HWALK hWalk)
{
	LPWALKHEADER lpWalk = (LPWALKHEADER) hWalk;

	if (lpWalk != NULL)
	{
		while (lpWalk->lpSrchDirListHead != NULL)
			RemoveFromList(lpWalk);
		//BUGBUG : Must free everything in hWalk

		if (lpWalk != NULL)
		{
			if (lpWalk->lpszIniString != NULL)
			{
	#ifdef _DEBUG
				MyGlobalFree(lpWalk->lpszIniString, FAILMEMF);
	#else
				GlobalFree(lpWalk->lpszIniString);
	#endif
				lpWalk->lpszIniString = NULL;
			}
	#ifdef _DEBUG
			MyGlobalFree(lpWalk, FAILMEMF);
	#else
			GlobalFree(lpWalk);
	#endif
			lpWalk = NULL;
		}
	}
}


#ifdef _DEBUG
HGLOBAL MyGlobalFree(HGLOBAL hGlobal, BOOL FAILMEM)
{
	HGLOBAL hGbl;

	g_MemAlloced = g_MemAlloced - GlobalSize(hGlobal);
	hGbl = GlobalFree(hGlobal);
	return hGbl;
};

HGLOBAL MyGlobalAlloc(BOOL FAILMEM, DWORD dwBytes)
{
	HGLOBAL hGbl;
	if (FAILMEM)
	{
		hGbl = GlobalAlloc(GPTR, dwBytes);
		g_MemAlloced = g_MemAlloced + GlobalSize(hGbl);
		return hGbl;
	}
	else
		return NULL;
};


#endif



/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


BOOL
IsMsiApp(
    IShellLink *    psl
    )
{
    //
    // Find out if this link is to an MSI app.
    // The algorithm for finding out is from ProcessDarwinAd in
    // shell\shell32\unicpp\startmnu.cpp.
    //

    IShellLinkDataList * psldl;
    HRESULT hr = psl->QueryInterface(IID_IShellLinkDataList, (void **)&psldl);
    if (FAILED(hr))
    {
        DEBUG_OUT((DEB_ITRACE, "  QI for IShellLinkDataList failed %#x\n", hr));
        return FALSE;
    }

    EXP_DARWIN_LINK * pexpDarwin;

    hr = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);

    psldl->Release();

    if (FAILED(hr))
    {
        DEBUG_OUT((DEB_ITRACE, "  CopyDataBlock failed %#x\n", hr));
        return FALSE;
    }

    DEBUG_OUT((DEB_ITRACE, "  This IS a Darwin app\n"));

    LocalFree(pexpDarwin);
    return TRUE;
}

/////////////////////////////////////////////////////////////////
///////////////////////DDDDOOOONNNNEEEE//////////////////////////
/////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\walklib.h ===
#ifdef _CHICAGO_
#define REGSTR_SHELLFOLDERS			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#else
#define REGSTR_SHELLFOLDERS			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#endif // _CHICAGO_
#define REGSTR_CURRENTVERSION		TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")

#define RUNKEY						TEXT("Run")
#define RUNONCEKEY					TEXT("RunOnce")
#define RUNSERVICESKEY				TEXT("RunServices")
#define RUNSERVICESONCEKEY			TEXT("RunServicesOnce")

#define HELPIDSIZE					10
#define MAXRUNSTR					300
#define MAXENVPATHLEN				300

#define INPTYPE_FOLDER				0x0007
#define INPTYPE_INIFILE				0x0038
#define INPTYPE_REGISTRY			0x03C0
#define RESET_FLAG					0xFFFF

#define	FOLDER						101
#define INIFILE						102				
#define REGISTRY					103				

#define WININISTR					"WIN.INI, Run/Load="
#define REGRUNSTR					"REGISTRY: Run"
#define REGRUNSERVICESSTR			"REGISTRY: RunServices"
#define REGRUNONCESTR				"REGISTRY: RunOnce"
#define REGRUNSERVICESONCESTR		"REGISTRY: RunServicesOnce"

typedef struct tnode
{
	HANDLE hDirHandle;
	struct tnode *lpSrchDirNext;
} HSEARCHDIR, *LPHSEARCHDIR;

typedef struct 
{
	DWORD			dwWalkFlags;
	DWORD			dwCurrentFlag;
	LPHSEARCHDIR	lpSrchDirListHead; 
	LPHSEARCHDIR	lpSrchDirListTail;
	LPTSTR			lpszIniString;
	LPTSTR			lpszNextFile;
	LPTSTR			lpszFolder;
} WALKHEADER, *LPWALKHEADER;


INT		GetFileHandle(LPLINKINFO lpLnkInfo, LPWALKHEADER lpWalk, LPTSTR lpPath);
ERR		GetLnkInfo(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo, LPTSTR lpPath);
ERR		ResolveLnk(LPCTSTR pszShortcutFile, LPTSTR lpszLnkPath, LPWIN32_FIND_DATA lpwfdExeData, LPTSTR tszArgs);
ERR		AddToList(HANDLE hDir, LPWALKHEADER lpWalk);
ERR		RemoveFromList(LPWALKHEADER lpWalk);
ERR		GetExeVersion(LPLINKINFO lpLnkInfo);
void	SetLnkInfo(LPLINKINFO lpLinkInfo);
BOOL	CheckFileExists(LPTSTR szFullName, LPVOID ftLAD);
INT		GetInputType(LPWALKHEADER lpWalk);
ERR		GetFolder(LPTSTR lpszFolder, LPWALKHEADER lpWalk);
ERR		GetIniString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo);
ERR		GetRegistryString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo);
ERR		GetNextFileFromString(LPWALKHEADER lpWalk, LPLINKINFO lpLnkInfo);
BOOL	GetFileLAD(LPLINKINFO lpLnkInfo);
BOOL	InSkipList(LPTSTR lpszFileName);
void	GetDrivePath(LPTSTR lpszExePath, LPTSTR lpszDrPath);
DWORD	ReverseDWord(DWORD dwIn);


#ifdef _DEBUG

#define FAILMEMA	TRUE
#define FAILMEMF	TRUE

HGLOBAL MyGlobalAlloc(BOOL FAILMEM, DWORD dwBytes);
HGLOBAL MyGlobalFree(HGLOBAL hGlobal, BOOL FAILMEM);
INT		g_MemAlloced = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\weekly.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       weekly.cxx
//
//  Contents:   Task wizard weekly trigger property page implementation.
//
//  Classes:    CWeeklyPage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// Constants
//
// NWEEKS_MIN - minimum value for weekly_nweeks_ud spin control
// NWEEKS_MAX - maximum value for weekly_nweeks_ud spin control
//

#define NWEEKS_MIN  1
#define NWEEKS_MAX  52


//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::CWeeklyPage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWeeklyPage::CWeeklyPage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CTriggerPage(IDD_WEEKLY,
                     IDS_WEEKLY_HDR2,
                     ptszFolderPath,
                     phPSP)
{
    TRACE_CONSTRUCTOR(CWeeklyPage);

    _flDaysOfTheWeek = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::~CWeeklyPage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWeeklyPage::~CWeeklyPage()
{
    TRACE_DESTRUCTOR(CWeeklyPage);
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_OnCommand
//
//  Synopsis:   Update internal state to match user's control changes
//
//  Arguments:  [id]         - id of control changed
//              [hwndCtl]    - hwnd of control changed
//              [codeNotify] - what happened to control
//
//  Returns:    0 (handled) or 1 (not handled)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWeeklyPage::_OnCommand(
    INT id,
    HWND hwndCtl,
    UINT codeNotify)
{
    LRESULT lr = 0;

    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case weekly_sunday_ckbox:
            _flDaysOfTheWeek ^= TASK_SUNDAY;
            break;

        case weekly_monday_ckbox:
            _flDaysOfTheWeek ^= TASK_MONDAY;
            break;

        case weekly_tuesday_ckbox:
            _flDaysOfTheWeek ^= TASK_TUESDAY;
            break;

        case weekly_wednesday_ckbox:
            _flDaysOfTheWeek ^= TASK_WEDNESDAY;
            break;

        case weekly_thursday_ckbox:
            _flDaysOfTheWeek ^= TASK_THURSDAY;
            break;

        case weekly_friday_ckbox:
            _flDaysOfTheWeek ^= TASK_FRIDAY;
            break;

        case weekly_saturday_ckbox:
            _flDaysOfTheWeek ^= TASK_SATURDAY;
            break;

        default:
            lr = 1;
            break;
        }
        _UpdateWizButtons();
        break;

    case EN_UPDATE:
    {
        //
        // If the user just pasted non-numeric text or an illegal numeric
        // value, overwrite it and complain.
        //

        INT iNewPos = GetDlgItemInt(Hwnd(), weekly_nweeks_edit, NULL, FALSE);

        if (iNewPos < NWEEKS_MIN || iNewPos > NWEEKS_MAX)
        {
            HWND hUD = _hCtrl(weekly_nweeks_ud);
            UpDown_SetPos(hUD, UpDown_GetPos(hUD));
            MessageBeep(MB_ICONASTERISK);
        }
    }

    default:
        lr = 1;
        break;
    }
    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWeeklyPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE_METHOD(CWeeklyPage, _OnInitDialog);

    _UpdateTimeFormat();
    UpDown_SetRange(_hCtrl(weekly_nweeks_ud), NWEEKS_MIN, NWEEKS_MAX);
    UpDown_SetPos(_hCtrl(weekly_nweeks_ud), 1);
    Edit_LimitText(_hCtrl(weekly_nweeks_edit), 2);
    Button_SetCheck(_hCtrl(_idSelectedRadio), BST_CHECKED);
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_OnPSNSetActive
//
//  Synopsis:   Enable the Next button only if this page has valid data
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWeeklyPage::_OnPSNSetActive(
    LPARAM lParam)
{
    _UpdateWizButtons();
    return CPropPage::_OnPSNSetActive(lParam);
}




//===========================================================================
//
// CTriggerPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    5-06-1997   DavidMun   Created
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

VOID
CWeeklyPage::FillInTrigger(
    TASK_TRIGGER *pTrigger)
{
    pTrigger->TriggerType = TASK_TIME_TRIGGER_WEEKLY;

    pTrigger->Type.Weekly.WeeksInterval =
        UpDown_GetPos(_hCtrl(weekly_nweeks_ud));
    DEBUG_ASSERT(pTrigger->Type.Weekly.WeeksInterval);

    DEBUG_ASSERT(_flDaysOfTheWeek);
    pTrigger->Type.Weekly.rgfDaysOfTheWeek = _flDaysOfTheWeek;
    SYSTEMTIME st;

    GetLocalTime(&st);

    pTrigger->wBeginYear   = st.wYear;
    pTrigger->wBeginMonth  = st.wMonth;
    pTrigger->wBeginDay    = st.wDay;

    DateTime_GetSystemtime(_hCtrl(starttime_dp), &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}


//===========================================================================
//
// New methods
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWeeklyPage::_UpdateWizButtons
//
//  Synopsis:   Enable the Next control if page data is valid
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWeeklyPage::_UpdateWizButtons()
{
    //
    // Enable Next if user has selected which weeks to run on and picked
    // days of the week to run on.
    //

    if (_flDaysOfTheWeek)
    {
        _SetWizButtons(PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        _SetWizButtons(PSWIZB_BACK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\wizpage.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       wizpage.cxx
//
//  Contents:   Implementation of wizard page class
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"

//
// CWizPage statics
//

ULONG       CWizPage::s_cInstances;
HFONT       CWizPage::s_hfBigBold;
HFONT       CWizPage::s_hfBold;
#ifdef WIZARD95
SDIBitmap   CWizPage::s_Splash;
#endif // WIZARD95

#define DEFAULT_LARGE_FONT_SIZE         14


//===========================================================================
//
// CPropPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::CWizPage
//
//  Synopsis:   ctor
//
//  Arguments:  [szTmplt]     - dialog resource for page
//              [ptszJobPath] - full path to task object
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWizPage::CWizPage(
    LPCTSTR szTmplt,
    LPTSTR ptszJobPath):
#ifdef WIZARD95
        _fActiveWindow(FALSE),
        _fPaletteChanged(FALSE),
#endif // WIZARD95
        CPropPage(szTmplt, ptszJobPath)
{
    InterlockedIncrement((LPLONG) &s_cInstances);
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::~CWizPage
//
//  Synopsis:   dtor
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWizPage::~CWizPage()
{
    //
    // If no more instances of this class are active, destroy the gdi stuff
    // stored in statics.
    //

    if (!InterlockedDecrement((LPLONG) &s_cInstances))
    {
        if (s_hfBigBold)
        {
            VERIFY(DeleteObject(s_hfBigBold));
            s_hfBigBold = NULL;
        }

        if (s_hfBold)
        {
            VERIFY(DeleteObject(s_hfBold));
            s_hfBold = NULL;
        }
#ifdef WIZARD95
        _DeleteSplashBitmap();
#endif // WIZARD95
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::DlgProc
//
//  Synopsis:   Overrides the CPropPage dialog proc for special message
//              handling, delegates to it for everything else.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::DlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    LRESULT lr;

    if (uMsg == WM_INITDIALOG)
    {
        m_fInInit = TRUE;
        _BaseInit();

        //
        // Create the gdi objects stored in statics if this is the first
        // instance of the class to receive an initdialog.
        //

#ifdef WIZARD95
        if (!s_Splash.hbmp)
        {
            _CreateSplashBitmap();
        }
#endif // WIZARD95

        if(!s_hfBigBold && !s_hfBold)
        {
            _CreateHeaderFonts();
        }

        //
        // Set the fonts of header strings to bold and large bold
        //

        _InitHeaderFonts();

        //
        // Let derived class init the dialog controls
        //

        lr = _OnInitDialog(lParam);
        m_fInInit = FALSE;
    }
    else if (uMsg == g_msgFindWizard)
    {
        //
        // If this wizard is already focused on the tasks folder indicated
        // by lParam, come to the foreground and indicate to the caller
        // that another wizard would be a duplicate and shouldn't be opened.
        //

        if (!lstrcmpi((LPCTSTR) lParam, GetTaskPath()))
        {
            SetForegroundWindow(GetParent(Hwnd()));
            SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, g_msgFindWizard);
        }
        lr = TRUE; // indicate we processed message
    }
#ifdef WIZARD95
    else if (uMsg == WM_PALETTECHANGED && (HWND) wParam != Hwnd())
    {
        _fPaletteChanged = TRUE;
        InvalidateRect(Hwnd(), NULL, FALSE);
    }
    else if (uMsg == WM_ACTIVATE)
    {
        _fActiveWindow = LOWORD(wParam) != WA_INACTIVE;
        InvalidateRect(Hwnd(), NULL, FALSE);
    }
#endif // WIZARD95
    else if (uMsg == WM_PAINT)
    {
#ifdef WIZARD95
        //
        // If some other window changed the palette, restore it before
        // painting, unless we're merely a background app.
        //

        if (_fActiveWindow)
        {
            HDC hdc = GetDC(Hwnd());

            if (!SelectPalette(hdc, s_Splash.hPalette, FALSE))
            {
                DEBUG_OUT_LASTERROR;
            }

            if (RealizePalette(hdc) == GDI_ERROR)
            {
                DEBUG_OUT_LASTERROR;
            }

            _fPaletteChanged = FALSE;
            ReleaseDC(Hwnd(), hdc);
        }
#endif // WIZARD95

        //
        // Do any custom painting required (the splash bitmap on first and
        // last pages).  Returning FALSE will allow the dialog manager to
        // process the paint as well.
        //

        lr = _OnPaint((HDC) wParam);
    }
    else
    {
        //
        // The message has no special meaning for the wizard; delegate
        // to base class so it can dispatch to the appropriate member.
        //

        lr = CPropPage::DlgProc(uMsg, wParam, lParam);
    }

    return lr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnNotify
//
//  Synopsis:   Aggregate the CPropPage WM_NOTIFY handler to provide
//              wizard-specific dispatching.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnNotify(
    UINT    uMessage,
    UINT    uParam,
    LPARAM  lParam)
{
    // TRACE_METHOD(CWizPage, _OnNotify);

    LPNMHDR pnmhdr = (LPNMHDR) lParam;

    switch (pnmhdr->code)
    {
    //
    // Delegate to base class for notification processing it provides
    // which we don't need to override.
    //

    default:
        return CPropPage::_OnNotify(uMessage, uParam, lParam);

    //
    // Support notifications unique to wizard pages
    //

    case PSN_WIZBACK:
        return _OnWizBack();

    case PSN_WIZNEXT:
        return _OnWizNext();

    case PSN_WIZFINISH:
        return _OnWizFinish();
    }

    return TRUE;
}




//===========================================================================
//
// CWizPage methods
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnPaint
//
//  Synopsis:   Return FALSE to let dialog manager handle painting.
//
//  History:    5-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnPaint(
    HDC hdc)
{
#ifdef WIZARD95
    DEBUG_ASSERT(!hdc);
    _PaintSplashBitmap();
#endif // WIZARD95

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizBack
//
//  Synopsis:   Default handling of PSN_WIZBACK
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizBack()
{
    TRACE_METHOD(CWizPage, _OnWizBack);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizNext
//
//  Synopsis:   Default handling of PSN_WIZNEXT
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizNext()
{
    TRACE_METHOD(CWizPage, _OnWizNext);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizFinish
//
//  Synopsis:   Default handling of PSN_WIZFINISH
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizFinish()
{
    TRACE_METHOD(CWizPage, _OnWizFinish);

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_InitHeaderFonts
//
//  Synopsis:   Set the font for controls having the BOLDTITLE identifiers.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_InitHeaderFonts()
{
	_SetControlFont(s_hfBigBold, IDC_BIGBOLDTITLE);
	_SetControlFont(s_hfBold,    IDC_BOLDTITLE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_SetControlFont
//
//  Synopsis:   Set the font of control [nId] to [hFont]
//
//  Arguments:  [hFont] - font to use
//              [nId]   - id of control to set
//
//  History:    5-20-1997   DavidMun   Created
//
//  Notes:      Does nothing if control not found or font handle is NULL.
//
//---------------------------------------------------------------------------

VOID
CWizPage::_SetControlFont(
    HFONT    hFont,
    INT      nId)
{
    if (hFont)
    {
        HWND hwndControl = _hCtrl(nId);

        if (hwndControl)
        {
            SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_CreateHeaderFonts
//
//  Synopsis:   Create fonts used in header title static text controls.
//
//  History:    5-20-1997   DavidMun   Stolen from sample wizard97 code
//
//---------------------------------------------------------------------------

VOID
CWizPage::_CreateHeaderFonts()
{
    DEBUG_ASSERT(!s_hfBigBold);
    DEBUG_ASSERT(!s_hfBold);

    //
	// Create the fonts we need based on the dialog font
    //

	NONCLIENTMETRICS ncm;

    ZeroMemory(&ncm, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	VERIFY(SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0));

	LOGFONT lfBigBold  = ncm.lfMessageFont;
	LOGFONT lfBold     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //

    lfBigBold.lfWeight   = FW_BOLD;
	lfBold.lfWeight      = FW_BOLD;

    TCHAR tszFontSizeString[24];
    ULONG ulFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //

    BOOL fOk;

    fOk = LoadString(g_hInstance,
                     IDS_LARGEFONTNAME,
                     lfBigBold.lfFaceName,
                     LF_FACESIZE);

    if (!fOk)
    {
        DEBUG_OUT_LASTERROR;
        lstrcpy(lfBigBold.lfFaceName, TEXT("MS Shell Dlg"));
    }

    fOk = LoadString(g_hInstance,
                     IDS_LARGEFONTSIZE,
                     tszFontSizeString,
                     ARRAYLEN(tszFontSizeString));

    if (fOk)
    {
        ulFontSize = _tcstoul(tszFontSizeString, NULL, 10);
    }

    if (!fOk || !ulFontSize)
    {
        DEBUG_OUT_LASTERROR;
        ulFontSize = DEFAULT_LARGE_FONT_SIZE;
    }

	HDC hdc = GetDC(Hwnd());

    if (hdc)
    {
        //
        // See KB article PSS ID Number Q74299,
        //   "Calculating The Logical Height and Point Size of a Font"
        //

        lfBigBold.lfHeight = -MulDiv((INT) ulFontSize,
                                     GetDeviceCaps(hdc, LOGPIXELSY),
                                     72);

        s_hfBigBold = CreateFontIndirect(&lfBigBold);

        if (!s_hfBigBold)
        {
            DEBUG_OUT_LASTERROR;
        }

		s_hfBold = CreateFontIndirect(&lfBold);

        if (!s_hfBold)
        {
            DEBUG_OUT_LASTERROR;
        }

        ReleaseDC(Hwnd(), hdc);
    }
    else
    {
        DEBUG_OUT_LASTERROR;
    }
}




#ifdef WIZARD95
//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_CreateSplashBitmap
//
//  Synopsis:   Initialize a memory dc with the bitmap used on the first
//              and last pages.
//
//  History:    5-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_CreateSplashBitmap()
{
    TRACE_METHOD(CWizPage, _CreateSplashBitmap);

    DEBUG_ASSERT(!s_Splash.hbmp);
    DEBUG_ASSERT(!s_Splash.hdcMem);
    DEBUG_ASSERT(!s_Splash.hPalette);

    HDC     hdc = NULL;
    HRESULT hr = E_FAIL;

    do
    {
        s_Splash.hbmp = LoadResourceBitmap(IDB_SPLASH, &s_Splash.hPalette);

        if (!s_Splash.hbmp)
        {
            break;
        }

        BITMAP   bm;

        if (!GetObject(s_Splash.hbmp, sizeof(bm), (LPTSTR)&bm))
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        s_Splash.Dimensions.cx = bm.bmWidth;
        s_Splash.Dimensions.cy = bm.bmHeight;

        hdc = GetDC(Hwnd());

        if (!hdc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        s_Splash.hdcMem = CreateCompatibleDC(hdc);

        if (!s_Splash.hdcMem)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (!SelectPalette(hdc, s_Splash.hPalette, FALSE))
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        UINT uiResult = RealizePalette(hdc);

        if (uiResult == GDI_ERROR)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (!SelectPalette(s_Splash.hdcMem, s_Splash.hPalette, FALSE))
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        uiResult = RealizePalette(s_Splash.hdcMem);

        if (uiResult == GDI_ERROR)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        s_Splash.hbmpOld = (HBITMAP) SelectObject(s_Splash.hdcMem,
                                                  s_Splash.hbmp);


        hr = S_OK;
    } while (0);

    if (hdc)
    {
        ReleaseDC(Hwnd(), hdc);
    }

    if (FAILED(hr))
    {
        _DeleteSplashBitmap();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_DeleteSplashBitmap
//
//  Synopsis:   Free all gdi objects associated with splash bitmap.
//
//  History:    5-22-1997   DavidMun   Created
//
//  Notes:      Properly destroys a partly-initialized struct.  If the
//              struct is already empty, does nothing.
//
//---------------------------------------------------------------------------

VOID
CWizPage::_DeleteSplashBitmap()
{
    TRACE_METHOD(CWizPage, _DeleteSplashBitmap);

    if (s_Splash.hdcMem)
    {
        DEBUG_ASSERT(s_Splash.hbmp);
        DEBUG_ASSERT(s_Splash.hPalette);

        if (s_Splash.hbmpOld)
        {
            HBITMAP hbmp;

            hbmp = (HBITMAP) SelectObject(s_Splash.hdcMem, s_Splash.hbmpOld);

            DEBUG_ASSERT(hbmp == s_Splash.hbmp);
            s_Splash.hbmpOld = NULL;

            VERIFY(DeleteObject(s_Splash.hbmp));
            s_Splash.hbmp = NULL;
        }

        VERIFY(DeleteDC(s_Splash.hdcMem));
        VERIFY(DeleteObject(s_Splash.hPalette));

        s_Splash.hdcMem = NULL;
        s_Splash.hPalette = NULL;
    }
    else if (s_Splash.hbmp)
    {
        DEBUG_ASSERT(s_Splash.hPalette);
        VERIFY(DeleteObject(s_Splash.hbmp));
        VERIFY(DeleteObject(s_Splash.hPalette));
        s_Splash.hbmp = NULL;
        s_Splash.hPalette = NULL;
    }
    else
    {
        DEBUG_ASSERT(!s_Splash.hbmp);
        DEBUG_ASSERT(!s_Splash.hPalette);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_PaintSplashBitmap
//
//  Synopsis:   Paint the splash bitmap onto the dialog window.
//
//  History:    5-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_PaintSplashBitmap()
{
    TRACE_METHOD(CWizPage, _PaintSplashBitmap);
    HDC hdc = NULL;

    do
    {
        //
        // If an error prevented us from loading & processing the bitmap,
        // there's nothing to paint.
        //

        if (!s_Splash.hdcMem)
        {
            break;
        }

        //
        // Get the device context of this page's dialog, then blast the
        // bitmap onto it.
        //

        hdc = GetDC(Hwnd());

        if (!hdc)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        BOOL fOk = BitBlt(hdc,
                          0,
                          0,
                          s_Splash.Dimensions.cx,
                          s_Splash.Dimensions.cy,
                          s_Splash.hdcMem,
                          0,
                          0,
                          SRCCOPY);

        if (!fOk)
        {
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Mark the area containing the bitmap as a valid rect, so the
        // dialog manager won't paint over it.
        //

        RECT rc =
        {
            0,
            0,
            s_Splash.Dimensions.cx,
            s_Splash.Dimensions.cy
        };

        ValidateRect(Hwnd(), &rc);
    } while (0);

    if (hdc)
    {
        ReleaseDC(Hwnd(), hdc);
    }
}
#endif // WIZARD95




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_CreatePage
//
//  Synopsis:   Helper function that optionally loads title and subtitle
//              strings, sets appropriate flags, then creates the page.
//
//  Arguments:  [idsHeaderTitle]    - resource id of title, or 0 for none
//              [idsHeaderSubTitle] - resource id of subtitle, or 0 for none
//              [phPSP]             - filled with handle returned by
//                                      CreatePropertySheetPage
//
//  Modifies:   *[phPSP]
//
//  History:    5-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizPage::_CreatePage(
    ULONG idsHeaderTitle,
    ULONG idsHeaderSubTitle,
    HPROPSHEETPAGE *phPSP)
{
    TCHAR tszHeaderTitle[MAX_TITLE_CCH];
    TCHAR tszHeaderSubTitle[MAX_TITLE_CCH];
    HRESULT hr;

#ifdef WIZARD97
    if (idsHeaderTitle)
    {
        hr = LoadStr(idsHeaderTitle, tszHeaderTitle, MAX_TITLE_CCH);

        if (SUCCEEDED(hr))
        {
            m_psp.dwFlags |= PSP_USEHEADERTITLE;
        }
    }

    if (idsHeaderSubTitle)
    {
        hr = LoadStr(idsHeaderSubTitle, tszHeaderSubTitle, MAX_TITLE_CCH);

        if (SUCCEEDED(hr))
        {
            m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
        }
    }

    m_psp.pszHeaderTitle    = tszHeaderTitle;
    m_psp.pszHeaderSubTitle = tszHeaderSubTitle;
#endif // WIZARD97

    *phPSP = CreatePropertySheetPage(&m_psp);

    if (!*phPSP)
    {
        DEBUG_OUT_LASTERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\smdebug\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              23-Feb-01   JBenton     Added code to clean up crit sections
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <stdarg.h>

#include "smdebug.h"

//////////////////////////////////////////////////////////////////////////////

unsigned long SmInfoLevel = DEF_INFOLEVEL;
unsigned long SmInfoMask = 0xffffffff;
unsigned long SmAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fCritSecInit = FALSE;
BOOL fInfoLevelInit = FALSE;

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...);
static int _cdecl w4smprintf(const char *format, va_list arglist);

//////////////////////////////////////////////////////////////////////////////

static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[500];		// this is the message buffer

static int _cdecl w4dprintf(const char *format, ...)
{
	int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

	return ret;
}


static int _cdecl w4smprintf(const char *format, va_list arglist)
{
	int ret;

	EnterCriticalSection(&s_csMessageBuf);
    ret = wvsprintfA(g_szMessageBuf, format, arglist);
	OutputDebugStringA(g_szMessageBuf);
	LeaveCriticalSection(&s_csMessageBuf);
	return ret;
}

//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   SmAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

EXPORTIMP void APINOT
SmAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (SmAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

		_asdprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (SmAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (SmAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    SetSmInfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetSmInfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = SmInfoLevel;
    SmInfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetSmInfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetSmInfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = SmInfoMask;
    SmInfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetSmAssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetSmAssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = SmAssertLevel;
    SmAssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

EXPORTIMP int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintfA(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
              pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
						| MB_DEFAULT_DESKTOP_ONLY
						| MB_TASKMODAL
						| MB_ICONEXCLAMATION
						| MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
								| MB_SERVICE_NOTIFICATION
								| MB_TASKMODAL
								| MB_ICONEXCLAMATION
								| MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

EXPORTIMP void APINOT
smprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | SmInfoLevel) & SmInfoMask))
    {
		EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((SmInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%x.%03x> %s: ", pid, tid, pszComp);
            }

            SYSTEMTIME st;
            GetLocalTime(&st);
            w4dprintf("%02d:%02d:%02d.%03d ", st.wHour, st.wMinute,
                      st.wSecond, st.wMilliseconds);

            w4smprintf(ppszfmt, pargs);
        }

        //if (SmInfoLevel & DEB_STDOUT)
        //{
        //    if (! (ulCompMask & DEB_NOCOMPNAME))
        //    {
        //        printf("%x.%03x> %s: ", pid, tid, pszComp);
        //    }
        //    vprintf(ppszfmt, pargs);
        //}

		LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// SysMan debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define SMDEBUGKEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SmDebug"

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
EXPORTDEF void APINOT
CheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;
    if (fInfoLevelInit) return;
    if (!fCritSecInit) InitializeDebugging();
    fInfoLevelInit = TRUE;
    lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SMDEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
}

void APINOT InitializeDebugging(void)
{
    if (fCritSecInit) return;
	InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    fCritSecInit = TRUE;
}

void APINOT CleanUpDebugging(void)
{
    if (fCritSecInit)
	{
    	DeleteCriticalSection(&s_csMessageBuf);
        DeleteCriticalSection(&s_csDebugPrint);
        fCritSecInit = FALSE;
	}
}
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\wizard\welcome.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       welcome.cxx
//
//  Contents:   Task wizard welcome (initial) property page implementation.
//
//  Classes:    CWelcomePage
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "myheaders.hxx"




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::CWelcomePage
//
//  Synopsis:   ctor
//
//  Arguments:  [ptszFolderPath] - full path to tasks folder with dummy
//                                          filename appended
//              [phPSP]                - filled with prop page handle
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWelcomePage::CWelcomePage(
    CTaskWizard *pParent,
    LPTSTR ptszFolderPath,
    HPROPSHEETPAGE *phPSP):
        CWizPage(MAKEINTRESOURCE(IDD_WELCOME), ptszFolderPath)
{
    TRACE_CONSTRUCTOR(CWelcomePage);

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

    *phPSP = CreatePropertySheetPage(&m_psp);

    if (!*phPSP)
    {
        DEBUG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::~CWelcomePage
//
//  Synopsis:   dtor
//
//  History:    4-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWelcomePage::~CWelcomePage()
{
    TRACE_DESTRUCTOR(CWelcomePage);
}



//===========================================================================
//
// CWizPage overrides
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::_OnInitDialog
//
//  Synopsis:   Perform initialization that should only occur once.
//
//  Arguments:  [lParam] - LPPROPSHEETPAGE used to create this page
//
//  Returns:    TRUE (let windows set focus)
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWelcomePage::_OnInitDialog(
    LPARAM lParam)
{
    TCHAR tszCaption[MAX_TITLE_CCH];

    LoadStr(IDS_CAPTION, tszCaption, ARRAYLEN(tszCaption));
    VERIFY(SetWindowText(GetParent(Hwnd()), tszCaption));
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::_OnPSNSetActive
//
//  Synopsis:   Disable the back button, since this is the first page.
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWelcomePage::_OnPSNSetActive(
    LPARAM lParam)
{
    _SetWizButtons(PSWIZB_NEXT);
    return CPropPage::_OnPSNSetActive(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\smdebug\smdebug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//				following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//				 7-Oct-94   BruceFo		Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//              23-Feb-01   JBenton     Added code to clean up crit sections
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//  "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\SmDebug"
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif


#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
#define EXTRNC "C"
#else
#define EXTRNC
#endif

// smprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   smprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   EXPORTDEF void          APINOT
   SmAssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   EXPORTDEF unsigned long APINOT
   SetSmInfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetSmInfoMask(
       unsigned long ulNewMask);

   EXPORTDEF unsigned long APINOT
   SetSmAssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF void APINOT
   InitializeDebugging(
	   void);

   EXPORTDEF void APINOT
   CleanUpDebugging(
	   void);

   EXPORTDEF void APINOT
   CheckInit(char * pInfoLevelString, unsigned long * InfoLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

#define Win4Assert(x)  \
        (void)((x) || (SmAssertEx(__FILE__, __LINE__, #x),0))

#define Win4Verify(x) Win4Assert(x)


//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
 #define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif


#define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


#ifdef __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel); \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

#else  // ! __cplusplus

 #define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        CheckInit(comp##InfoLevelString, &comp##InfoLevel);
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            smprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

#endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

#define Win4Assert(x)  NULL
#define Win4Verify(x)  (x)

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\adsiedit.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

#include "pch.h"
#include "resource.h"

#include <SnapBase.h>

#include "ADSIEdit.h"
#include "snapdata.h"
#include "editor.h"
#include "connection.h"
#include "querynode.h"
#include "IAttredt.h"
#include "editorui.h"
#include "editimpl.h"

//#include "HelpArr.h"	// context help ID's


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

//////////////////////////////////////////////////////////////////////////////
// regsvr debugging

// define to enable MsgBox debugging for regsvr32
//#define _MSGBOX_ON_REG_FAIL


#ifdef _MSGBOX_ON_REG_FAIL
#define _MSGBOX(x) AfxMessageBox(x)
#else
#define _MSGBOX(x)
#endif

#ifdef _MSGBOX_ON_REG_FAIL
#define _REPORT_FAIL(lpszMessage, lpszClsid, lRes) \
  ReportFail(lpszMessage, lpszClsid, lRes)

void ReportFail(LPCWSTR lpszMessage, LPCWSTR lpszClsid, LONG lRes)
{
  if (lRes == ERROR_SUCCESS)
    return;

  CString sz;
  sz.Format(_T("%s %s %d"), lpszMessage,lpszClsid, lRes);
  AfxMessageBox(sz);
}

#else
#define _REPORT_FAIL(lpszMessage, lpszClsid, lRes)
#endif


//////////////////////////////////////////////////////////////////////////////
// global constants and macros

// GUIDs for snapin
// {1C5DACFA-16BA-11d2-81D0-0000F87A7AA3}
static const GUID CLSID_ADSIEditSnapin =
{ 0x1c5dacfa, 0x16ba, 0x11d2, { 0x81, 0xd0, 0x0, 0x0, 0xf8, 0x7a, 0x7a, 0xa3 } };

// {E6F27C2A-16BA-11d2-81D0-0000F87A7AA3}
static const GUID CLSID_ADSIEditAbout =
{ 0xe6f27c2a, 0x16ba, 0x11d2, { 0x81, 0xd0, 0x0, 0x0, 0xf8, 0x7a, 0x7a, 0xa3 } };


// GUIDs for node types

///////////////////////////////////////////////////////////////////////////////
// RESOURCES



// # of columns in the result pane and map for resource strings

extern RESULT_HEADERMAP _HeaderStrings[] =
{
	{ L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
	{ L"", IDS_HEADER_TYPE, LVCFMT_LEFT, 90},
	{ L"", IDS_HEADER_DN,	LVCFMT_LEFT, 450},
};

COLUMN_DEFINITION DefaultColumnDefinition =
{
  COLUMNSET_ID_DEFAULT,
  N_HEADER_COLS,
  _HeaderStrings
};

extern RESULT_HEADERMAP _PartitionsHeaderStrings[] =
{
	{ L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
  { L"", IDS_HEADER_NCNAME, LVCFMT_LEFT, 200},
	{ L"", IDS_HEADER_TYPE, LVCFMT_LEFT, 90},
	{ L"", IDS_HEADER_DN,	LVCFMT_LEFT, 450},
};

COLUMN_DEFINITION PartitionsColumnDefinition =
{
  COLUMNSET_ID_PARTITIONS,
  N_PARTITIONS_HEADER_COLS,
  _PartitionsHeaderStrings
};

extern PCOLUMN_DEFINITION ColumnDefinitions[] =
{
  &DefaultColumnDefinition,
  &PartitionsColumnDefinition,
  NULL
};


///////////////////////////////////////////////////////////////////////////////
// CADSIEditModule

HRESULT WINAPI CADSIEditModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
	static const WCHAR szIPS32[] = _T("InprocServer32");
	static const WCHAR szCLSID[] = _T("CLSID");

	HRESULT hRes = S_OK;

	LPOLESTR lpOleStrCLSIDValue;
	::StringFromCLSID(clsid, &lpOleStrCLSIDValue);
  if (lpOleStrCLSIDValue == NULL)
  {
    return E_OUTOFMEMORY;
  }

	CRegKey key;
	if (bRegister)
	{
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
    _REPORT_FAIL(L"key.Open(HKEY_CLASSES_ROOT", lpOleStrCLSIDValue, lRes);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpOleStrCLSIDValue);
      _REPORT_FAIL(L"key.Create(key", lpOleStrCLSIDValue, lRes);
			if (lRes == ERROR_SUCCESS)
			{
				WCHAR szModule[_MAX_PATH];
				::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
				lRes = key.SetKeyValue(szIPS32, szModule);
        _REPORT_FAIL(L"key.SetKeyValue(szIPS32", lpOleStrCLSIDValue, lRes);
			}
		}
		if (lRes != ERROR_SUCCESS)
			hRes = HRESULT_FROM_WIN32(lRes);
	}
	else
	{
		key.Attach(HKEY_CLASSES_ROOT);
		if (key.Open(key, szCLSID) == ERROR_SUCCESS)
			key.RecurseDeleteKey(lpOleStrCLSIDValue);
	}
	::CoTaskMemFree(lpOleStrCLSIDValue);
	return hRes;
}


///////////////////////////////////////////////////////////////////////////////
// Module, Object Map and DLL entry points

CADSIEditModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ADSIEditSnapin, CADSIEditComponentDataObject)
  OBJECT_ENTRY(CLSID_ADSIEditAbout, CADSIEditAbout)	
  OBJECT_ENTRY(CLSID_DsAttributeEditor, CAttributeEditor)
END_OBJECT_MAP()


STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}


static _NODE_TYPE_INFO_ENTRY _NodeTypeInfoEntryArray[] = {
	{ &CADSIEditRootData::NodeTypeGUID,			_T("Root ADSI Edit Subtree")		},
	{ &CADSIEditConnectionNode::NodeTypeGUID,	_T("ADSI Edit Connection Node")	},
	{ &CADSIEditContainerNode::NodeTypeGUID,	_T("ADSI Edit Container Node")	},
	{ &CADSIEditLeafNode::NodeTypeGUID,			_T("ADSI Edit Leaf Node")			},
	{ &CADSIEditQueryNode::NodeTypeGUID,		_T("ADSI Edit Query Node")			},
	{ NULL, NULL }
};


////////////////////////////////////////////////////////////////////


STDAPI DllRegisterServer(void)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// registers all objects
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
    _MSGBOX(_T("_Module.RegisterServer() failed"));
		return hr;
  }

  CString szVersion, szProvider, szSnapinName, szSnapinNameEx;

  szVersion.LoadString(IDS_SNAPIN_VERSION);
  szProvider.LoadString(IDS_SNAPIN_PROVIDER);
  szSnapinName.LoadString(IDS_SNAPIN_NAME);

	// register the standalone ADSI Edit snapin into the console snapin list
	hr = RegisterSnapin(&CLSID_ADSIEditSnapin,
                      &CADSIEditRootData::NodeTypeGUID,
                      &CLSID_ADSIEditAbout,
						szSnapinName, szVersion, szProvider,
            FALSE /*bExtension*/,
						_NodeTypeInfoEntryArray);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
    _MSGBOX(_T("RegisterSnapin(&CLSID_DNSSnapin) failed"));
		return hr;
  }

	// register the snapin nodes into the console node list
	for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
			pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
	{
		hr = RegisterNodeType(pCurrEntry->m_pNodeGUID,pCurrEntry->m_lpszNodeDescription);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
    {
      _MSGBOX(_T("RegisterNodeType() failed"));
			return hr;
    }
	}

	return hr;
}

STDAPI DllUnregisterServer(void)
{
	HRESULT hr  = _Module.UnregisterServer();
	ASSERT(SUCCEEDED(hr));

	// un register the standalone snapin
	hr = UnregisterSnapin(&CLSID_ADSIEditSnapin);
	ASSERT(SUCCEEDED(hr));

	// unregister the snapin nodes,
  // this removes also the server node, with the Services Snapin extension keys
	for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
			pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
	{
		hr = UnregisterNodeType(pCurrEntry->m_pNodeGUID);
		ASSERT(SUCCEEDED(hr));
	}

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CADSIEditSnapinApp

class CADSIEditSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CADSIEditSnapinApp theApp;

BOOL CADSIEditSnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);

	HRESULT hr = ::OleInitialize(NULL);
	if (FAILED(hr))
	{
		return FALSE;
	}

	if (!CADSIEditComponentDataObject::LoadResources())
		return FALSE;
	return CWinApp::InitInstance();
}

int CADSIEditSnapinApp::ExitInstance()
{
#ifdef _DEBUG_REFCOUNT
	TRACE(_T("CADSIEditSnapinApp::ExitInstance()\n"));
	ASSERT(CComponentDataObject::m_nOustandingObjects == 0);
	ASSERT(CComponentObject::m_nOustandingObjects == 0);
	ASSERT(CDataObject::m_nOustandingObjects == 0);
#endif // _DEBUG_REFCOUNT
	_Module.Term();
	return CWinApp::ExitInstance();
}

////////////////////////////////////////////////////////////////////////
// CADSIEditComponentObject (.i.e "view")


HRESULT CADSIEditComponentObject::InitializeHeaders(CContainerNode* pContainerNode)
{
  HRESULT hr = S_OK;
  ASSERT(m_pHeader);

  CColumnSet* pColumnSet = pContainerNode->GetColumnSet();
  POSITION pos = pColumnSet->GetHeadPosition();
  while (pos != NULL)
  {
    CColumn* pColumn = pColumnSet->GetNext(pos);

		hr = m_pHeader->InsertColumn(pColumn->GetColumnNum(), 
                                  pColumn->GetHeader(),
											            pColumn->GetFormat(),
											            AUTO_WIDTH);
		if (FAILED(hr))
			return hr;

    hr = m_pHeader->SetColumnWidth(pColumn->GetColumnNum(), 
                                    pColumn->GetWidth());
    if (FAILED(hr))
      return hr;
	}
  return hr;
}

HRESULT CADSIEditComponentObject::InitializeBitmaps(CTreeNode* cookie)
{
  HRESULT hr = S_OK;

  // image lists for nodes
  CBitmapHolder<IDB_16x16> _bmp16x16;
  CBitmapHolder<IDB_32x32> _bmp32x32;

  bool bBmpsLoaded = _bmp16x16.LoadBitmap() && _bmp32x32.LoadBitmap();
  
  if (bBmpsLoaded)
  {
    ASSERT(m_pImageResult != NULL);
    hr = m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp16x16)),
                                           reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp32x32)),
                                           0, 
                                           BMP_COLOR_MASK);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}


////////////////////////////////////////////////////////////////////////
// CADSIEditComponentDataObject (.i.e "document")

CADSIEditComponentDataObject::CADSIEditComponentDataObject()
{
/*
	CWatermarkInfo* pWatermarkInfo = new CWatermarkInfo;
	pWatermarkInfo->m_nIDBanner = IDB_WIZBANNER;
	pWatermarkInfo->m_nIDWatermark = IDB_WIZWATERMARK;
	SetWatermarkInfo(pWatermarkInfo);
*/
  m_pColumnSet = new CADSIEditColumnSet(COLUMNSET_ID_DEFAULT);
}



HRESULT CADSIEditComponentDataObject::OnSetImages(LPIMAGELIST lpScopeImage)
{
  HRESULT hr = S_OK;

  // image lists for nodes
  CBitmapHolder<IDB_16x16> _bmp16x16;
  CBitmapHolder<IDB_32x32> _bmp32x32;

  bool bBmpsLoaded = _bmp16x16.LoadBitmap() && _bmp32x32.LoadBitmap();
  
  if (bBmpsLoaded)
  {
    ASSERT(lpScopeImage != NULL);
    hr = lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp16x16)),
                                         reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp32x32)),
                                         0, 
                                         BMP_COLOR_MASK);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}



CRootData* CADSIEditComponentDataObject::OnCreateRootData()
{
	CADSIEditRootData* pADSIEditRootNode = new CADSIEditRootData(this);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString szSnapinType;
	szSnapinType.LoadString(IDS_SNAPIN_NAME);
	pADSIEditRootNode->SetDisplayName(szSnapinType);
	return pADSIEditRootNode;
}


BOOL CADSIEditComponentDataObject::LoadResources()
{
  BOOL bLoadColumnHeaders = TRUE;
  
  for (UINT nIdx = 0; ColumnDefinitions[nIdx]; nIdx++)
  {
    PCOLUMN_DEFINITION pColumnDef = ColumnDefinitions[nIdx];
    bLoadColumnHeaders = LoadResultHeaderResources(pColumnDef->headers, pColumnDef->dwColumnCount);
    if (!bLoadColumnHeaders)
    {
      break;
    }
  }

  return 
		LoadContextMenuResources(CADSIEditConnectMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CADSIEditContainerMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CADSIEditRootMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CADSIEditLeafMenuHolder::GetMenuMap()) &&
		LoadContextMenuResources(CADSIEditQueryMenuHolder::GetMenuMap()) &&
		bLoadColumnHeaders;
}


STDMETHODIMP CADSIEditComponentDataObject::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CADSIEditComponentObject>* pObject;
    CComObject<CADSIEditComponentObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

void CADSIEditComponentDataObject::OnNodeContextHelp(CTreeNode* pNode)
{
  ASSERT(pNode != NULL);

  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"w2rksupp.chm::/topics/adsiedit.htm");



//    spHelp->ShowTopic(L"w2rksupp.chm");
/*
  CString szNode;

  if (IS_CLASS(*pNode, CDNSRootData))
  {
    szNode = _T("Root Node");
  }
  else if (IS_CLASS(*pNode, CDNSServerNode))
  {
    szNode = _T("Server Node");
  }
  else if (IS_CLASS(*pNode, CDNSForwardZonesNode))
  {
    szNode = _T("Forward Zones Node");
  }
  else if (IS_CLASS(*pNode, CDNSReverseZonesNode))
  {
    szNode = _T("Reverse Zones Node");
  }
  else if (IS_CLASS(*pNode, CDNSZoneNode))
  {
    szNode = _T("Zone Node");
  }
  else if (IS_CLASS(*pNode, CDNSDomainNode))
  {
    szNode = _T("Domain Node");
  }
  else if (IS_CLASS(*pNode, CDNSCacheNode))
  {
    szNode = _T("Domain Node");
  }
  else if (dynamic_cast<CDNSRecordNodeBase*>(pNode) != NULL)
  {
    szNode = _T("Record Node");
  }

  if (!szNode.IsEmpty())
  {
    CString szMsg = _T("Context Help on ");
    szMsg += szNode;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    AfxMessageBox(szMsg);
  }
*/
}


LPCWSTR g_szContextHelpFileName = L"\\help\\adsiedit.hlp";
LPCWSTR g_szHTMLHelpFileName = L"w2rksupp.chm";

LPCWSTR CADSIEditComponentDataObject::GetHTMLHelpFileName()
{
  return g_szHTMLHelpFileName;
}

void CADSIEditComponentDataObject::OnDialogContextHelp(UINT nDialogID, HELPINFO* pHelpInfo)
{
	ULONG nContextTopic;
  // TODO
  //if (FindDialogContextTopic(nDialogID, pHelpInfo, &nContextTopic))
	//  WinHelp(g_szContextHelpFileName, HELP_CONTEXTPOPUP, nContextTopic);
}

STDMETHODIMP CADSIEditComponentDataObject::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;
  LPCWSTR lpszHelpFileName = GetHTMLHelpFileName();
  if (lpszHelpFileName == NULL)
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

  CString szResourceKitDir = _T("");
  CString szKey = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components\\5A18D5BFC37FA0A4E99D24135BABE742";

	CRegKey key;
	LONG lRes = key.Open(HKEY_LOCAL_MACHINE, szKey);
  _REPORT_FAIL(L"key.Open(HKEY_LOCAL_MACHINE", szKey, lRes);
	if (lRes == ERROR_SUCCESS)
	{
    PTSTR ptszValue = new TCHAR[2*MAX_PATH];
    DWORD dwCount = sizeof(TCHAR) * 2 * MAX_PATH;
		lRes = key.QueryValue(ptszValue, L"DC5632422F082D1189A9000CF497879A", &dwCount);
    _REPORT_FAIL(L"key.QueryValue(key", L"DC5632422F082D1189A9000CF497879A", lRes);
		if (lRes == ERROR_SUCCESS)
		{
			CString szValue = ptszValue;
      delete[] ptszValue;

      szResourceKitDir = szValue.Left(szValue.ReverseFind(L'\\') + 1);
		}
	}

  CString szHelpFilePath = szResourceKitDir + CString(lpszHelpFileName);
  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }

  return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// help context macros and maps

#if (FALSE)

#define BEGIN_HELP_MAP(map)	static DWORD map[] = {
#define HELP_MAP_ENTRY(x)	x, (DWORD)&g_aHelpIDs_##x ,
#define END_HELP_MAP		 0, 0 };


#define NEXT_HELP_MAP_ENTRY(p) ((p)+2)
#define MAP_ENTRY_DLG_ID(p) (*p)
#define MAP_ENTRY_TABLE(p) ((DWORD*)(*(p+1)))
#define IS_LAST_MAP_ENTRY(p) (MAP_ENTRY_DLG_ID(p) == 0)

#define NEXT_HELP_TABLE_ENTRY(p) ((p)+2)
#define TABLE_ENTRY_CTRL_ID(p) (*p)
#define TABLE_ENTRY_HELP_ID(p) (*(p+1))
#define IS_LAST_TABLE_ENTRY(p) (TABLE_ENTRY_CTRL_ID(p) == 0)

BEGIN_HELP_MAP(_DNSMgrContextHelpMap)
  // misc dialogs
  HELP_MAP_ENTRY(IDD_CHOOSER_CHOOSE_MACHINE)
  HELP_MAP_ENTRY(IDD_BROWSE_DIALOG)

  // misc. add dialogs
  HELP_MAP_ENTRY(IDD_DOMAIN_ADDNEWHOST) // TODO
  HELP_MAP_ENTRY(IDD_DOMAIN_ADDNEWDOMAIN)// TODO
  HELP_MAP_ENTRY(IDD_SELECT_RECORD_TYPE_DIALOG)

  // NOTE: this has several incarnations...
  HELP_MAP_ENTRY(IDD_NAME_SERVERS_PAGE)

  // server property pages
  HELP_MAP_ENTRY(IDD_SERVER_INTERFACES_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_FORWARDERS_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_ADVANCED_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_LOGGING_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_BOOTMETHOD_PAGE)
  HELP_MAP_ENTRY(IDD_SERVMON_STATISTICS_PAGE)
  HELP_MAP_ENTRY(IDD_SERVMON_TEST_PAGE)

  // zone property pages
  HELP_MAP_ENTRY(IDD_ZONE_GENERAL_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_WINS_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_NBSTAT_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_NOTIFY_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_WINS_ADVANCED) // this is a subdialog, need to hook up

  // record property pages
  HELP_MAP_ENTRY(IDD_RR_NS_EDIT)
  HELP_MAP_ENTRY(IDD_RR_SOA)
  HELP_MAP_ENTRY(IDD_RR_A)
  HELP_MAP_ENTRY(IDD_RR_CNAME)
  HELP_MAP_ENTRY(IDD_RR_MX)
  HELP_MAP_ENTRY(IDD_RR_UNK)
  HELP_MAP_ENTRY(IDD_RR_TXT)
  HELP_MAP_ENTRY(IDD_RR_X25)
  HELP_MAP_ENTRY(IDD_RR_ISDN)
  HELP_MAP_ENTRY(IDD_RR_HINFO)
  HELP_MAP_ENTRY(IDD_RR_AAAA)
  HELP_MAP_ENTRY(IDD_RR_MB)
  HELP_MAP_ENTRY(IDD_RR_MG)
  HELP_MAP_ENTRY(IDD_RR_MD)
  HELP_MAP_ENTRY(IDD_RR_MF)
  HELP_MAP_ENTRY(IDD_RR_MR)
  HELP_MAP_ENTRY(IDD_RR_MINFO)
  HELP_MAP_ENTRY(IDD_RR_RP)
  HELP_MAP_ENTRY(IDD_RR_RT)
  HELP_MAP_ENTRY(IDD_RR_AFSDB)
  HELP_MAP_ENTRY(IDD_RR_WKS)
  HELP_MAP_ENTRY(IDD_RR_PTR)
  HELP_MAP_ENTRY(IDD_RR_SRV)
  HELP_MAP_ENTRY(IDD_RR_KEY)
  HELP_MAP_ENTRY(IDD_RR_SIG)

END_HELP_MAP



BOOL CDNSComponentDataObjectBase::FindDialogContextTopic(/*IN*/UINT nDialogID,
                                              /*IN*/ HELPINFO* pHelpInfo,
                                              /*OUT*/ ULONG* pnContextTopic)
{
	ASSERT(pHelpInfo != NULL);
  *pnContextTopic = 0;
	const DWORD* pMapEntry = _DNSMgrContextHelpMap;
	while (!IS_LAST_MAP_ENTRY(pMapEntry))
	{
		if (nDialogID == MAP_ENTRY_DLG_ID(pMapEntry))
		{
			DWORD* pTable = MAP_ENTRY_TABLE(pMapEntry);
			// look inside the table
			while (!IS_LAST_TABLE_ENTRY(pTable))
			{
				if (TABLE_ENTRY_CTRL_ID(pTable) == pHelpInfo->iCtrlId)
        {
					*pnContextTopic = TABLE_ENTRY_HELP_ID(pTable);
          return TRUE;
        }
				pTable = NEXT_HELP_TABLE_ENTRY(pTable);
			}
		}
		pMapEntry = NEXT_HELP_MAP_ENTRY(pMapEntry);
	}
	return FALSE;
}

#endif


//////////////////////////////////////////////////////////////////////////
// CADSIEditAbout

CADSIEditAbout::CADSIEditAbout()
{
  m_uIdStrProvider = IDS_SNAPIN_PROVIDER;
	m_uIdStrVersion = IDS_SNAPIN_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_ADSIEDIT_SNAPIN;
	m_uIdBitmapSmallImage = IDB_ABOUT_16x16;
	m_uIdBitmapSmallImageOpen = IDB_ABOUT_16x16;
	m_uIdBitmapLargeImage = IDB_ABOUT_32x32;
	m_crImageMask = BMP_COLOR_MASK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "common.h"
#include "attr.h"

///////////////////////////////////////////////////////////////////////////
// CADSIAttribute

CADSIAttribute::CADSIAttribute(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly)
{
	m_pAttrInfo = pInfo;
	m_bDirty = FALSE;
	m_bMulti = bMulti;
	m_bReadOnly = bReadOnly;
  m_bSet = FALSE;
  m_bMandatory = FALSE;
  m_szSyntax = pszSyntax;

  PWSTR pwz = wcsrchr(pInfo->pszAttrName, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }

}

CADSIAttribute::CADSIAttribute(PADS_ATTR_INFO pInfo)
{
  //
  // REVIEW_JEFFJON : these need to be updated with correct values
  //
	m_pAttrInfo = pInfo;
	m_bDirty = FALSE;
	m_bMulti = FALSE;
	m_bReadOnly = FALSE;
  m_bSet = FALSE;
  m_bMandatory = FALSE;

  PWSTR pwz = wcsrchr(pInfo->pszAttrName, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }

}

CADSIAttribute::CADSIAttribute(LPCWSTR lpszAttr)
{
	m_pAttrInfo = new ADS_ATTR_INFO;
	memset(m_pAttrInfo, 0, sizeof(ADS_ATTR_INFO));

  PWSTR pwz = wcsrchr(lpszAttr, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }
	_AllocString(lpszAttr, &(m_pAttrInfo->pszAttrName));

	m_bMulti = FALSE;
	m_bDirty = FALSE;
	m_bReadOnly = FALSE;
  m_bSet = FALSE;
  m_bMandatory = FALSE;
}

CADSIAttribute::CADSIAttribute(CADSIAttribute* pOldAttr)
{
	m_pAttrInfo = NULL;
	ADS_ATTR_INFO* pAttrInfo = pOldAttr->GetAttrInfo();

	// These copies are done separately because there are places
	// that I need to copy only the ADsAttrInfo and not the values
	//
	_CopyADsAttrInfo(pAttrInfo, &m_pAttrInfo);
	_CopyADsValues(pAttrInfo, m_pAttrInfo );

	m_bReadOnly = FALSE;
	m_bMulti = pOldAttr->m_bMulti;
	m_bDirty = pOldAttr->m_bDirty;
   m_szSyntax = pOldAttr->m_szSyntax;
}


CADSIAttribute::~CADSIAttribute() 
{
  if (!m_bReadOnly)
  {
	  _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
  }
}


ADSVALUE* CADSIAttribute::GetADSVALUE(int idx)
{
	
	return &(m_pAttrInfo->pADsValues[idx]);
}

HRESULT CADSIAttribute::SetValues(PADSVALUE pADsValue, DWORD dwNumValues)
{
	HRESULT hr = S_OK;

	ADS_ATTR_INFO* pNewAttrInfo = NULL;
	if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
	{
		return E_FAIL;
	}

	pNewAttrInfo->dwNumValues = dwNumValues;
  pNewAttrInfo->pADsValues = pADsValue;

  if (pADsValue == NULL)
  {
    pNewAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
  }
  else
  {
    pNewAttrInfo->dwADsType = pADsValue->dwType;
  }

  //
	// Free the old one and swap in the new one
	//
  if (!m_bReadOnly)
  {
	  _FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
  }

	m_pAttrInfo = pNewAttrInfo;
	m_bReadOnly = FALSE;
	return hr;
}

HRESULT CADSIAttribute::SetValues(const CStringList& sValues)
{
	HRESULT hr;

	ADS_ATTR_INFO* pNewAttrInfo = NULL;
	if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
	{
		return E_FAIL;
	}

	int iCount = sValues.GetCount();
	pNewAttrInfo->dwNumValues = iCount;

	if (!_AllocValues(&pNewAttrInfo->pADsValues, iCount))
	{
		return E_FAIL;
	}
	
	int idx = 0;
	POSITION pos = sValues.GetHeadPosition();
	while (pos != NULL)
	{
		CString s = sValues.GetNext(pos);

		ADSVALUE* pADsValue = &(pNewAttrInfo->pADsValues[idx]);
		ASSERT(pADsValue != NULL);

		hr = _SetADsFromString(
													s,
													pNewAttrInfo->dwADsType, 
													pADsValue
													);
		if (FAILED(hr))
		{
			_FreeADsAttrInfo(&pNewAttrInfo, FALSE);
			return hr;
		}
		idx++;
	}

	// Free the old one and swap in the new one
	//
	_FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);

	m_pAttrInfo = pNewAttrInfo;
	m_bReadOnly = FALSE;
	return hr;
}

void CADSIAttribute::GetValues(CStringList& sValues, DWORD dwMaxCharCount)
{
	GetStringFromADs(m_pAttrInfo, sValues, dwMaxCharCount);
}

ADS_ATTR_INFO* CADSIAttribute::GetAttrInfo()
{
	return m_pAttrInfo; 
}

////////////////////////////////////////////////////////////////////////
// Public Helper Functions
///////////////////////////////////////////////////////////////////////
HRESULT CADSIAttribute::SetValuesInDS(CAttrList2* ptouchedAttr, IDirectoryObject* pDirObject)
{
	DWORD dwReturn;
	DWORD dwAttrCount = 0;
	ADS_ATTR_INFO* pAttrInfo;
	pAttrInfo = new ADS_ATTR_INFO[ptouchedAttr->GetCount()];

	CADSIAttribute* pCurrentAttr;
	POSITION pos = ptouchedAttr->GetHeadPosition();
	while(pos != NULL)
	{
		ptouchedAttr->GetNextDirty(pos, &pCurrentAttr);

		if (pCurrentAttr != NULL)
		{
			ADS_ATTR_INFO* pCurrentAttrInfo = pCurrentAttr->GetAttrInfo();
			ADS_ATTR_INFO* pNewAttrInfo = &pAttrInfo[dwAttrCount];

			if (!_CopyADsAttrInfo(pCurrentAttrInfo, pNewAttrInfo))
			{
				for (DWORD itr = 0; itr < dwAttrCount; itr++)
				{
					_FreeADsAttrInfo(&pAttrInfo[itr]);
				}
				delete[] pAttrInfo;
        pAttrInfo = NULL;
				return E_FAIL;
			}

			if (!_CopyADsValues(pCurrentAttrInfo, pNewAttrInfo))
			{
				delete[] pAttrInfo;
        pAttrInfo = NULL;
				return E_FAIL;
			}

			if (pAttrInfo[dwAttrCount].dwNumValues == 0)
			{
				pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_CLEAR;
			}
			else
			{
				pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_UPDATE;
			}

			dwAttrCount++;
		}
	}

	// Commit the changes that have been made to the ADSI cache
	//
	HRESULT hr = pDirObject->SetObjectAttributes(pAttrInfo, dwAttrCount, &dwReturn);

	for (DWORD itr = 0; itr < dwAttrCount; itr++)
	{
		_FreeADsAttrInfo(&pAttrInfo[itr]);
	}
	delete[] pAttrInfo;
  pAttrInfo = NULL;

	return hr;
}


/////////////////////////////////////////////////////////////////////////
// Private Helper Functions
////////////////////////////////////////////////////////////////////////

HRESULT CADSIAttribute::_SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue)
{
	HRESULT hr = E_FAIL;

  if ( adsType == ADSTYPE_INVALID )
	{
		return hr;
	}

	pADsValue->dwType = adsType;

	switch( adsType ) 
	{
		case ADSTYPE_DN_STRING :
			if (!_AllocString(lpszValue, &pADsValue->DNString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_CASE_EXACT_STRING :
			if (!_AllocString(lpszValue, &pADsValue->CaseExactString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_CASE_IGNORE_STRING :
			if (!_AllocString(lpszValue, &pADsValue->CaseIgnoreString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_PRINTABLE_STRING :
			if (!_AllocString(lpszValue, &pADsValue->PrintableString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_NUMERIC_STRING :
			if (!_AllocString(lpszValue, &pADsValue->NumericString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;
  
		case ADSTYPE_OBJECT_CLASS    :
			if (!_AllocString(lpszValue, &pADsValue->ClassName))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;
  
		case ADSTYPE_BOOLEAN :
			if (_wcsnicmp(lpszValue, L"TRUE", 4) == 0)
			{
				(DWORD)pADsValue->Boolean = TRUE;
			}
			else if (_wcsnicmp(lpszValue, L"FALSE", 5) == 0)
			{
				(DWORD)pADsValue->Boolean = FALSE;
			}
			else 
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;
  
		case ADSTYPE_INTEGER :
			int value;
			value = swscanf(lpszValue, L"%ld", &pADsValue->Integer);
			if (value > 0)
			{
				hr = S_OK;
			}
			else
			{
				hr = E_FAIL;
			}
			break;
  
		case ADSTYPE_OCTET_STRING : 
			{
				pADsValue->OctetString.lpValue = new BYTE[256];
				int iCount = 0, index = 0, iResult = 0;

				do
				{
					while (lpszValue[index] == ' ' || lpszValue[index] == '/t')
					{
						index++;
					}
					iResult = swscanf(&lpszValue[index], L"0x%2x", &pADsValue->OctetString.lpValue[iCount++]);
					if (iResult == 0 && lpszValue[index] == '\0')
					{
						hr = S_OK;
						break;
					}
					index += 4;  // REVIEW : OctetStrings must be in the form 0x00, ie 4 characters

				} while (iResult != 0);
				
				iCount--;  // the last one had to fail
				pADsValue->OctetString.dwLength = iCount;
			}
			break;
  
		case ADSTYPE_LARGE_INTEGER :
			wtoli(lpszValue, pADsValue->LargeInteger);
			hr = S_OK;
			break;
  
		case ADSTYPE_UTC_TIME :
			int iNum;
			WORD n;
			iNum = swscanf(lpszValue, L"%02d/%02d/%04d %02d:%02d:%02d", 
								&n, 
								&pADsValue->UTCTime.wDay, 
								&pADsValue->UTCTime.wYear,
								&pADsValue->UTCTime.wHour, 
								&pADsValue->UTCTime.wMinute, 
								&pADsValue->UTCTime.wSecond 
							  );
			pADsValue->UTCTime.wMonth = n;

			// This strange conversion is done so that the DayOfWeek will be set in 
			// the UTCTime.  By converting it to a filetime it ignores the dayofweek but
			// converting back fills it in.
			//
			FILETIME ft;
			SystemTimeToFileTime(&pADsValue->UTCTime, &ft);
			FileTimeToSystemTime(&ft, &pADsValue->UTCTime);

			if (iNum == 6)
			{
				hr = S_OK;
			}
			else
			{
				hr = E_FAIL;
			}
			break;

		default :
			break;
	}

	return hr;
}

BOOL CADSIAttribute::_AllocOctetString(ADS_OCTET_STRING& rOldOctetString, 
																	ADS_OCTET_STRING& rNew)
{
	_FreeOctetString(rNew.lpValue);

	int iLength = rOldOctetString.dwLength;
	rNew.dwLength =	iLength;
	rNew.lpValue = new BYTE[iLength];
	if (rNew.lpValue == NULL)
	{
		_FreeOctetString(rNew.lpValue);
		return FALSE;
	}
	memcpy(rNew.lpValue, rOldOctetString.lpValue, iLength);
	return TRUE;
}

void CADSIAttribute::_FreeOctetString(BYTE* lpValue)
{
	if (lpValue != NULL)
	{
		delete lpValue;
		lpValue = NULL;
	}
}

BOOL CADSIAttribute::_AllocString(LPCWSTR lpsz, LPWSTR* lppszNew)
{
	_FreeString(lppszNew);

	int iLength = wcslen(lpsz);
	*lppszNew = new WCHAR[iLength + 1];  // an extra for the NULL
	if (*lppszNew == NULL)
	{
		_FreeString(lppszNew);
		return FALSE;
	}
	wcscpy(*lppszNew, lpsz);

	return TRUE;
}
	
void CADSIAttribute::_FreeString(LPWSTR* lppsz)
{
	if (*lppsz != NULL)
	{
		delete *lppsz;
	}
	*lppsz = NULL;
}

BOOL CADSIAttribute::_AllocValues(ADSVALUE** ppValues, DWORD dwLength)
{
	_FreeADsValues(ppValues, dwLength);

	*ppValues = new ADSVALUE[dwLength];
	if (*ppValues == NULL)
	{
		_FreeADsValues(ppValues, dwLength);
		return FALSE;
	}
	memset(*ppValues, 0, sizeof(ADSVALUE) * dwLength);
	return TRUE;
}

BOOL CADSIAttribute::_CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
	_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);

	pNewAttrInfo->dwNumValues = pOldAttrInfo->dwNumValues;
	if (!_AllocValues(&pNewAttrInfo->pADsValues, pOldAttrInfo->dwNumValues))
	{
		_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
		return FALSE;
	}

	for (DWORD itr = 0; itr < pOldAttrInfo->dwNumValues; itr++)
	{
		pNewAttrInfo->pADsValues[itr].dwType = pOldAttrInfo->pADsValues[itr].dwType;

		switch( pNewAttrInfo->pADsValues[itr].dwType ) 
		{
			case ADSTYPE_DN_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].DNString,
													&pNewAttrInfo->pADsValues[itr].DNString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;

			case ADSTYPE_CASE_EXACT_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].CaseExactString,
													&pNewAttrInfo->pADsValues[itr].CaseExactString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
						
			case ADSTYPE_CASE_IGNORE_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].CaseIgnoreString,
													&pNewAttrInfo->pADsValues[itr].CaseIgnoreString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;

			case ADSTYPE_PRINTABLE_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].PrintableString,
													&pNewAttrInfo->pADsValues[itr].PrintableString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;

			case ADSTYPE_NUMERIC_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].NumericString,
													&pNewAttrInfo->pADsValues[itr].NumericString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
  
			case ADSTYPE_OBJECT_CLASS    :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].ClassName,
													&pNewAttrInfo->pADsValues[itr].ClassName))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
  
			case ADSTYPE_BOOLEAN :
				pNewAttrInfo->pADsValues[itr].Boolean = pOldAttrInfo->pADsValues[itr].Boolean;
				break;
  
			case ADSTYPE_INTEGER :
				pNewAttrInfo->pADsValues[itr].Integer = pOldAttrInfo->pADsValues[itr].Integer;
				break;
  
			case ADSTYPE_OCTET_STRING :
				if (!_AllocOctetString(pOldAttrInfo->pADsValues[itr].OctetString,
															 pNewAttrInfo->pADsValues[itr].OctetString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
  
			case ADSTYPE_LARGE_INTEGER :
				pNewAttrInfo->pADsValues[itr].LargeInteger = pOldAttrInfo->pADsValues[itr].LargeInteger;
				break;
  
			case ADSTYPE_UTC_TIME :
				pNewAttrInfo->pADsValues[itr].UTCTime = pOldAttrInfo->pADsValues[itr].UTCTime;
				break;

			default :
				break;
		}
	}
	return TRUE;
}

void CADSIAttribute::_FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength)
{
	ADSVALUE* pADsValue = *ppADsValues;

	for (DWORD idx = 0; idx < dwLength; idx++)
	{
		if (pADsValue != NULL)
		{
			switch( pADsValue->dwType ) 
			{
				case ADSTYPE_DN_STRING :
					_FreeString(&pADsValue->DNString);
					break;

				case ADSTYPE_CASE_EXACT_STRING :
					_FreeString(&pADsValue->CaseExactString);
					break;

				case ADSTYPE_CASE_IGNORE_STRING :
					_FreeString(&pADsValue->CaseIgnoreString);
					break;

				case ADSTYPE_PRINTABLE_STRING :
					_FreeString(&pADsValue->PrintableString);
					break;

				case ADSTYPE_NUMERIC_STRING :
					_FreeString(&pADsValue->NumericString);
					break;
  
				case ADSTYPE_OBJECT_CLASS :
					_FreeString(&pADsValue->ClassName);
					break;
  
				case ADSTYPE_OCTET_STRING :
					_FreeOctetString(pADsValue->OctetString.lpValue);
					break;
  
				default :
					break;
			}
			pADsValue++;
		}
	}
	// May be NULL if there are no values set
	// WARNING! : make sure that you memset the memory after
	// creating an ADS_ATTR_INFO so that it will be NULL if there
	// are no values
	//
	if (*ppADsValues != NULL)
	{
		delete *ppADsValues;
		*ppADsValues = NULL;
	}
}


// The values are not copied here.  They must be copied after the ADS_ATTR_INFO
// is copied by using _CopyADsValues()
//
BOOL CADSIAttribute::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo)
{
	_FreeADsAttrInfo(ppNewAttrInfo, FALSE);

	*ppNewAttrInfo = new ADS_ATTR_INFO;
	if (*ppNewAttrInfo == NULL)
	{
		return FALSE;
	}
	memset(*ppNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

	BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &((*ppNewAttrInfo)->pszAttrName));
	if (!bReturn)
	{
		_FreeADsAttrInfo(ppNewAttrInfo, FALSE);
		return FALSE;
	}

	(*ppNewAttrInfo)->dwADsType = pAttrInfo->dwADsType;
	(*ppNewAttrInfo)->dwControlCode = pAttrInfo->dwControlCode;
	(*ppNewAttrInfo)->dwNumValues = pAttrInfo->dwNumValues;

	return TRUE;
}

BOOL CADSIAttribute::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
	memset(pNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

	BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &pNewAttrInfo->pszAttrName);
	if (!bReturn)
	{
		return FALSE;
	}

	pNewAttrInfo->dwADsType = pAttrInfo->dwADsType;
	pNewAttrInfo->dwControlCode = pAttrInfo->dwControlCode;
	pNewAttrInfo->dwNumValues = pAttrInfo->dwNumValues;

	return TRUE;
}

void CADSIAttribute::_FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly)
{
	if (*ppAttrInfo == NULL)
	{
		return;
	}

	if (!bReadOnly)
	{
		_FreeString(&(*ppAttrInfo)->pszAttrName);
		_FreeADsValues(&(*ppAttrInfo)->pADsValues, (*ppAttrInfo)->dwNumValues);
		delete *ppAttrInfo;
	}
	else
	{
		FreeADsMem(*ppAttrInfo);
	}
	*ppAttrInfo = NULL;
}

void CADSIAttribute::_FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo)
{
	if (pAttrInfo == NULL)
	{
		return;
	}

	_FreeString(&pAttrInfo->pszAttrName);
	_FreeADsValues(&pAttrInfo->pADsValues, pAttrInfo->dwNumValues);
}



///////////////////////////////////////////////////////////////////////////
// CAttrList2

POSITION CAttrList2::FindProperty(LPCWSTR lpszAttr)
{
	CADSIAttribute* pAttr;
	
	for (POSITION p = GetHeadPosition(); p != NULL; GetNext(p))
	{
		// I use GetAt here because I don't want to advance the POSITION
		// because it is returned if they are equal
		//
		pAttr = GetAt(p);
		CString sName;
		pAttr->GetProperty(sName);
		if (wcscmp(sName, lpszAttr) == 0)
		{
			break;
		}
	}
	return p;
}

BOOL CAttrList2::HasProperty(LPCWSTR lpszAttr)
{
	POSITION pos = FindProperty(lpszAttr);
	return pos != NULL;
}


// Searches through the cache for the attribute
// ppAttr will point to the CADSIAttribute if found, NULL if not
//
void CAttrList2::GetNextDirty(POSITION& pos, CADSIAttribute** ppAttr)
{
	*ppAttr = GetNext(pos);
	if (pos == NULL && !(*ppAttr)->IsDirty())
	{
		*ppAttr = NULL;
		return;
	}

	while (!(*ppAttr)->IsDirty() && pos != NULL)
	{
		*ppAttr = GetNext(pos);
		if (!(*ppAttr)->IsDirty() && pos == NULL)
		{
			*ppAttr = NULL;
			break;
		}
	}
}

BOOL CAttrList2::HasDirty()
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CADSIAttribute* pAttr = GetNext(pos);
		if (pAttr->IsDirty())
		{
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\adsiedit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       adsiedit.h
//
//--------------------------------------------------------------------------


#ifndef _ADSIEDIT_H
#define _ADSIEDIT_H

#include <stdabout.h>

//////////////////////////////////////////////////////////////////////////////
// global constants and macros

extern const CLSID CLSID_ADSIEditSnapin;    // In-Proc server GUID
extern const CLSID CLSID_ADSIEditAbout;    // In-Proc server GUID
extern const CLSID CLSID_DsAttributeEditor;
extern const CLSID IID_IDsAttributeEditor; 

///////////////////////////////////////////////////////////////////////////////
// RESOURCES

// enumeration for image strips
enum
{
	ROOT_IMAGE = 0,

	SEPARATOR_1,
	
	// 10 (5 regular, 5 test failed) images for server
	SERVER_IMAGE_NOT_LOADED,
	SERVER_IMAGE_LOADING,
	SERVER_IMAGE_LOADED,
	SERVER_IMAGE_UNABLE_TO_LOAD,
	SERVER_IMAGE_ACCESS_DENIED,

	SERVER_IMAGE_NOT_LOADED_TEST_FAIL,
	SERVER_IMAGE_LOADING_TEST_FAIL,
	SERVER_IMAGE_LOADED_TEST_FAIL,
	SERVER_IMAGE_UNABLE_TO_LOAD_TEST_FAIL,
	SERVER_IMAGE_ACCESS_DENIED_TEST_FAIL,

	SEPARATOR_2,

	// 12 (6 primary, 6 secondary) images for zones
	ZONE_IMAGE_1,
	ZONE_IMAGE_LOADING_1,
	ZONE_IMAGE_UNABLE_TO_LOAD_1,
	ZONE_IMAGE_PAUSED_1,
	ZONE_IMAGE_EXPIRED_1,
	ZONE_IMAGE_ACCESS_DENIED_1,

	SEPARATOR_3,

	ZONE_IMAGE_2,
	ZONE_IMAGE_LOADING_2,
	ZONE_IMAGE_UNABLE_TO_LOAD_2,
	ZONE_IMAGE_PAUSED_2,
	ZONE_IMAGE_EXPIRED_2,
	ZONE_IMAGE_ACCESS_DENIED_2,
	
	SEPARATOR_4,
	
	// 4 images for domains
	DOMAIN_IMAGE,
	DOMAIN_IMAGE_UNABLE_TO_LOAD,
	DOMAIN_IMAGE_LOADING,
	DOMAIN_IMAGE_ACCESS_DENIED,
	
	SEPARATOR_5,

	// 4 images for delegated domains
	DELEGATED_DOMAIN_IMAGE,
	DELEGATED_DOMAIN_IMAGE_UNABLE_TO_LOAD,
	DELEGATED_DOMAIN_IMAGE_LOADING,
	DELEGATED_DOMAIN_IMAGE_ACCESS_DENIED,

	SEPARATOR_6,

	// 4 generic images shared by cache, fwd and rev lookup zones
	FOLDER_IMAGE,
	FOLDER_IMAGE_UNABLE_TO_LOAD,
	FOLDER_IMAGE_LOADING,
	FOLDER_IMAGE_ACCESS_DENIED,

	SEPARATOR_7,

	// 1 record image
	RECORD_IMAGE_BASE,
	
	OPEN_FOLDER, // unused
	FOLDER_WITH_HAND
};

////////////////////////////////////////////////////////////////
// aliases for images indexes that share the same icon

#define ZONE_IMAGE_NOT_LOADED_1				ZONE_IMAGE_1
#define ZONE_IMAGE_NOT_LOADED_2				ZONE_IMAGE_2
#define ZONE_IMAGE_LOADED_1					ZONE_IMAGE_1
#define ZONE_IMAGE_LOADED_2					ZONE_IMAGE_2

#define DOMAIN_IMAGE_NOT_LOADED				DOMAIN_IMAGE
#define DOMAIN_IMAGE_LOADED					DOMAIN_IMAGE

#define	DELEGATED_DOMAIN_IMAGE_NOT_LOADED	DELEGATED_DOMAIN_IMAGE
#define	DELEGATED_DOMAIN_IMAGE_LOADED		DELEGATED_DOMAIN_IMAGE

#define FOLDER_IMAGE_NOT_LOADED				FOLDER_IMAGE
#define FOLDER_IMAGE_LOADED					FOLDER_IMAGE

///////////////////////////////////////////////////////////////
// bitmaps and images constants

#define	BMP_COLOR_MASK RGB(255,0,255) // pink


///////////////////////////////////////////////////////////////
// headers for result pane

#define N_HEADER_COLS (3)
#define N_PARTITIONS_HEADER_COLS (4)

#define COLUMNSET_ID_DEFAULT L"--ADSI Edit Column Set--"
#define COLUMNSET_ID_PARTITIONS L"--Partitions Column Set--"
#define N_HEADER_NAME	(0)
#define N_HEADER_TYPE	(1)
#define N_HEADER_DN		(2)

#define N_PARTITIONS_HEADER_NAME	 (0)
#define N_PARTITIONS_HEADER_NCNAME (1)
#define N_PARTITIONS_HEADER_TYPE	 (2)
#define N_PARTITIONS_HEADER_DN		 (3)

typedef struct _ColumnDefinition
{
  PCWSTR            pszColumnID;
  DWORD             dwColumnCount;
  RESULT_HEADERMAP* headers;
} COLUMN_DEFINITION, *PCOLUMN_DEFINITION;

extern PCOLUMN_DEFINITION ColumnDefinitions[];
extern RESULT_HEADERMAP _HeaderStrings[];
extern RESULT_HEADERMAP _PartitionsHeaderStrings[];

///////////////////////////////////////////////////////////////
// context menus

// Identifiers for each of the commands in the context menu.
enum
{
	// items for the root node
	IDM_SNAPIN_ADVANCED_VIEW,
  IDM_SNAPIN_FILTERING,
	IDM_SNAPIN_CONNECT_TO_SERVER,

	// items for the server node
	IDM_SERVER_NEW_ZONE,
	IDM_SERVER_UPDATE_DATA_FILES,
	// items for the zone node
	IDM_ZONE_UPDATE_DATA_FILE,

	// items for the domain node
	IDM_DOMAIN_NEW_RECORD,
	IDM_DOMAIN_NEW_DOMAIN,
	IDM_DOMAIN_NEW_DELEGATION,
	IDM_DOMAIN_NEW_HOST,
	IDM_DOMAIN_NEW_ALIAS,
	IDM_DOMAIN_NEW_MX,
	IDM_DOMAIN_NEW_PTR,
	
	// common items
};


DECLARE_MENU(CADSIEditDataMenuHolder)

//////////////////////////////////////////////////////////////////////////
// CADSIEditColumnSet

class CADSIEditColumnSet : public CColumnSet
{
public :
	CADSIEditColumnSet(PCWSTR pszColumnID)
		: CColumnSet(pszColumnID)
	{
    PCOLUMN_DEFINITION pColumnDef = NULL;
    for (UINT nIdx = 0; ColumnDefinitions[nIdx]; nIdx++)
    {
      pColumnDef = ColumnDefinitions[nIdx];
      if (0 == _wcsicmp(pColumnDef->pszColumnID, pszColumnID))
      {
        break;
      }
    }

    if (pColumnDef)
    {
      for (int iCol = 0; iCol < pColumnDef->dwColumnCount; iCol++)
      {
        CColumn* pNewColumn = new CColumn(pColumnDef->headers[iCol].szBuffer,
                                          pColumnDef->headers[iCol].nFormat,
                                          pColumnDef->headers[iCol].nWidth,
                                          iCol);
        AddTail(pNewColumn);
      }
    }
    else
    {
      //
      // Fall back to adding the default column directly
      // 
		  for (int iCol = 0; iCol < N_HEADER_COLS; iCol++)
		  {
        CColumn* pNewColumn = new CColumn(_HeaderStrings[iCol].szBuffer,
                                          _HeaderStrings[iCol].nFormat,
                                          _HeaderStrings[iCol].nWidth,
                                          iCol);
        AddTail(pNewColumn);
 		  }
    }
	}
};


////////////////////////////////////////////////////////////////////////
// CADSIEditComponentObject (.i.e "view")

class CADSIEditComponentObject : public CComponentObject
{
BEGIN_COM_MAP(CADSIEditComponentObject)
	COM_INTERFACE_ENTRY(IComponent) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CComponentObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CADSIEditComponentObject)

protected:
	virtual HRESULT InitializeHeaders(CContainerNode* pContainerNode);
	virtual HRESULT InitializeBitmaps(CTreeNode* cookie);
  virtual HRESULT InitializeToolbar(IToolbar* pToolbar) { return E_NOTIMPL; }
};



////////////////////////////////////////////////////////////////////////
// CADSIEditComponentDataObject (.i.e "document")

class CADSIEditComponentDataObject :
		public CComponentDataObject,
		public CComCoClass<CADSIEditComponentDataObject,&CLSID_ADSIEditSnapin>
{
BEGIN_COM_MAP(CADSIEditComponentDataObject)
	COM_INTERFACE_ENTRY(IComponentData) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CComponentDataObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CADSIEditComponentDataObject)

DECLARE_REGISTRY_CLSID()

public:
  CADSIEditComponentDataObject();
  virtual ~CADSIEditComponentDataObject()
  {
    if (m_pColumnSet != NULL)
      delete m_pColumnSet;
  }

	// IComponentData interface members
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);

  	// IPersistStream interface members
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		ASSERT(pClassID != NULL);
		memcpy(pClassID, (GUID*)&GetObjectCLSID(), sizeof(CLSID));
		return S_OK;
	}

public:
	static BOOL LoadResources();
private:
	static BOOL FindDialogContextTopic(/*IN*/UINT nDialogID,
                                /*IN*/ HELPINFO* pHelpInfo,
                                /*OUT*/ ULONG* pnContextTopic);

// virtual functions
protected:
	virtual HRESULT OnSetImages(LPIMAGELIST lpScopeImage);
	
	virtual CRootData* OnCreateRootData();

	// help handling
  virtual LPCWSTR GetHTMLHelpFileName();
	virtual void OnNodeContextHelp(CTreeNode* pNode);
public:
	virtual void OnDialogContextHelp(UINT nDialogID, HELPINFO* pHelpInfo);

  // ISnapinHelp interface members
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

  CADSIEditColumnSet* GetColumnSet() { return m_pColumnSet; }

  //
  // Allow multiple selection
  //
  virtual BOOL IsMultiSelect() { return TRUE; }

private:
  CADSIEditColumnSet* m_pColumnSet;

};


//////////////////////////////////////////////////////////////////////////
// CADSIEditAbout

class CADSIEditAbout :
	public CSnapinAbout,
	public CComCoClass<CADSIEditAbout, &CLSID_ADSIEditAbout>

{
public:
DECLARE_REGISTRY_CLSID()
	CADSIEditAbout();
};

#endif _ADSIEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attredit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attredit.h
//
//--------------------------------------------------------------------------

#ifndef _ATTREDIT_H
#define _ATTREDIT_H

#include "common.h"
#include "attribute.h"
#include "editor.h"


// use the HIWORD for generic flags and leave the LOWORD for application specific data
#define TN_FLAG_SHOW_MULTI		(0x00010000) // shows combobox for multivalued attributes or edit box for single
#define TN_FLAG_ENABLE_ADD						(0x00020000) // shows add if set, shows set if not
#define TN_FLAG_ENABLE_REMOVE				(0x00040000) // shows remove if set, shows clear if not

////////////////////////////////////////////////////////////////////////

class CAttrEditor;

/////////////////////////////////////////////////////////////////////////
// CADSIAttrList

typedef CList<CADSIAttr*,CADSIAttr*> CAttrListBase;

class CAttrList : public CAttrListBase
{
public:
	virtual ~CAttrList()
	{
		RemoveAllAttr();
	}

	void RemoveAllAttr() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}
	POSITION FindProperty(LPCWSTR lpszAttr);
	BOOL HasProperty(LPCWSTR lpszAttr);
	void GetNextDirty(POSITION& pos, CADSIAttr** ppAttr);
	BOOL HasDirty();
  int GetDirtyCount()
  {
    int nCount = 0;
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      if (GetNext(pos)->IsDirty())
        nCount++;
    }
    return nCount;
  }

};

///////////////////////////////////////////////////////////////////////////
// CDNSManageButtonTextHelper

class CDNSManageButtonTextHelper
{
public:
	CDNSManageButtonTextHelper(int nStates);
	~CDNSManageButtonTextHelper();

	BOOL Init(CWnd* pParentWnd, UINT nButtonID, UINT* nStrArray);
	void SetStateX(int nIndex);

private:
	CWnd* m_pParentWnd;
	UINT m_nID;
	WCHAR* m_lpszText;

	int m_nStates;
	LPWSTR* m_lpszArr;
};

///////////////////////////////////////////////////////////////////////////
// CDNSButtonToggleTextHelper

class CDNSButtonToggleTextHelper : public CDNSManageButtonTextHelper
{
public:
	CDNSButtonToggleTextHelper();

	void SetToggleState(BOOL bFirst) { SetStateX(bFirst ? 0 : 1); }
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIEditBox

class CADSIEditBox : public CEdit
{
public: 
	CADSIEditBox(CAttrEditor* pEditor) 
	{
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnChange();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIValueBox

class	CADSIValueBox : public CEdit
{
public:
	CADSIValueBox(CAttrEditor* pEditor) 
	{
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////////////////////////////
// CADSIValueList

class	CADSIValueList: public CListBox
{
public:
	CADSIValueList(CAttrEditor* pEditor) 
	{ 
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnSelChange();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIAddButton

class	CADSIAddButton: public CButton
{
public:
	CADSIAddButton(CAttrEditor* pEditor) 
	{ 
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnAdd();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////////////////
// CADSIRemoveButton

class	CADSIRemoveButton: public CButton
{
public:
	CADSIRemoveButton(CAttrEditor* pEditor) 
	{ 
		ASSERT(pEditor != NULL); 
		m_pEditor = pEditor; 
	}

	afx_msg void OnRemove();

protected:
	CAttrEditor* m_pEditor;

	DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////////////////////////////
// CAttrEditor

class CAttrEditor 
{
public:
	// Constructor
	//
	CAttrEditor();

	// Destructor
	//
	~CAttrEditor() 
  {
  }

	BOOL Initialize(CPropertyPageBase* pParentWnd, CTreeNode* pTreeNode, LPCWSTR lpszServer, 
									UINT nIDEdit, UINT nIDSyntax, 
									UINT nIDValueBox,	UINT nIDValueList, 
									UINT nIDAddButton, UINT nIDRemoveButton,
									BOOL bComplete);

	BOOL Initialize(CPropertyPageBase* pParentWnd, CConnectionData* pConnectData, LPCWSTR lpszServer, 
									UINT nIDEdit, UINT nIDSyntax, 
									UINT nIDValueBox,	UINT nIDValueList, 
									UINT nIDAddButton, UINT nIDRemoveButton,
									BOOL bComplete, CAttrList* pAttrList);
	// Message Map functions
	//
	BOOL OnApply();
	void OnEditChange();
	void OnValueSelChange();
	void OnAddValue();
	void OnRemoveValue();

	void SetAttribute(LPCWSTR lpszAttr, LPCWSTR lpszPath);

	// I return a CADSIAttr* because I check the cache to see if
	// that attribute has already been touched.  If it has, the existing
	// attribute can be used to build the ui, if not a new one is created
	// and put into the cache.  It is then returned to build the ui.
	//
	CADSIAttr* TouchAttr(LPCWSTR lpszAttr);
	CADSIAttr* TouchAttr(ADS_ATTR_INFO* pADsInfo, BOOL bMulti);

protected:
	// Helper functions
	//
	void FillWithExisting();
	void DisplayAttribute();
	void DisplayFormatError();
	void DisplayRootDSE();
	BOOL IsMultiValued(ADS_ATTR_INFO* pAttrInfo);
	BOOL IsMultiValued(LPCWSTR lpszProp);
	BOOL IsRootDSEAttrMultiValued(LPCWSTR lpszAttr);
	void GetSyntax(LPCWSTR lpszProp, CString& sSyntax);
	void GetAttrFailed();
	void SetPropertyUI(DWORD dwFlags, BOOL bAnd, BOOL bReset = FALSE); 

	// Dialog Items
	//
	CADSIEditBox m_AttrEditBox;
	CADSIEditBox m_SyntaxBox;
	CADSIValueBox m_ValueBox;
	CADSIValueList m_ValueList;
	CADSIAddButton m_AddButton;
	CADSIRemoveButton m_RemoveButton;

	CPropertyPageBase* m_pParentWnd;
	CTreeNode* m_pTreeNode;

	// Data members
	//
	CString m_sAttr;
	CString m_sPath;
	CString m_sServer;
	CString m_sNotSet;
	CAttrList* m_ptouchedAttr;

	CADSIAttr* m_pAttr;
	CConnectionData* m_pConnectData;
  BOOL m_bExisting;

	DWORD m_dwMultiFlags;

	CDNSButtonToggleTextHelper m_AddButtonHelper;
	CDNSButtonToggleTextHelper m_RemoveButtonHelper;
};


#endif _ATTREDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.h
//
//--------------------------------------------------------------------------

#ifndef _ATTR_H
#define _ATTR_H

#include "common.h"

////////////////////////////////////////////////////////////////////////
// Forward Declarations
//
class CAttrList2;

////////////////////////////////////////////////////////////////////////
// CADSIAttribute

class CADSIAttribute
{
public:
	// Constructors
	//
	CADSIAttribute(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly = TRUE);
  CADSIAttribute(PADS_ATTR_INFO pInfo);
	CADSIAttribute(LPCWSTR lpszAttr);
	CADSIAttribute(CADSIAttribute* pAttr);

	// Destructor
	//
	~CADSIAttribute(); 

	// Data accessor functions
	//
	void GetProperty(CString& sProp) { sProp = m_pAttrInfo->pszAttrName; }
	DWORD GetNumValues() { return m_pAttrInfo->dwNumValues; }

  HRESULT SetValues(PADSVALUE pADsValue, DWORD dwNumValues);
	HRESULT SetValues(const CStringList& sValues); 
	void GetValues(CStringList& psValues, DWORD dwMaxCharCount = 1024);

	BOOL GetMultivalued() { return m_bMulti; }
	void SetMultivalued(BOOL bMulti) { m_bMulti = bMulti; }

	void SetDirty(const BOOL bDirty) { m_bDirty = bDirty; }
	BOOL IsDirty() { return m_bDirty; }

  void SetMandatory(const BOOL bMandatory) { m_bMandatory = bMandatory; }
  BOOL IsMandatory() { return m_bMandatory; }

  BOOL IsValueSet() { return m_bSet; }
  void SetValueSet(const BOOL bSet) { m_bSet = bSet; }

	ADSTYPE GetADsType() { return m_pAttrInfo->dwADsType; }
	void SetADsType(ADSTYPE dwType) { m_pAttrInfo->dwADsType = dwType; }

   CString GetSyntax() { return m_szSyntax; }
   void SetSyntax(PCWSTR pszSyntax) { m_szSyntax = pszSyntax; }

	ADS_ATTR_INFO* GetAttrInfo();
  void SetAttrInfo(PADS_ATTR_INFO pAttrInfo)
  {
    if (m_pAttrInfo != NULL)
    {
      _FreeADsAttrInfo(&m_pAttrInfo, FALSE);
    }
    m_pAttrInfo = pAttrInfo;
    m_bReadOnly = TRUE;
  }
	ADSVALUE* GetADsValues() { return m_pAttrInfo->pADsValues; }

	static HRESULT SetValuesInDS(CAttrList2* ptouchAttr, IDirectoryObject* pDirObject);

private:
	// Functions
	//
	ADSVALUE* GetADSVALUE(int idx);

	static BOOL _AllocOctetString(ADS_OCTET_STRING& rOldOctetString, ADS_OCTET_STRING& rNew);
	static void _FreeOctetString(BYTE* lpValue);
	static BOOL _AllocString(LPCWSTR lpsz, LPWSTR* lppszNew);
	static void _FreeString(LPWSTR* lppsz);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo);
	static BOOL _AllocValues(ADSVALUE** ppValues, DWORD dwLength);
	static BOOL _CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* ppNewAttrInfo);
	static void _FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength);

	static HRESULT _SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue);

	// Member data
	//
	ADS_ATTR_INFO* m_pAttrInfo;
	BOOL m_bDirty;
	BOOL m_bMulti;
	BOOL m_bReadOnly;
  BOOL m_bMandatory;
  BOOL m_bSet;
  CString m_szSyntax;
};

////////////////////////////////////////////////////////////////////////////////
//
//
typedef CList<CADSIAttribute*,CADSIAttribute*> CAttrListBase2;

class CAttrList2 : public CAttrListBase2
{
public:
  CAttrList2() : m_pMandatorySavedValues(NULL), m_pOptionalSavedValues(NULL)
  {
  }

	virtual ~CAttrList2()
	{
    if (m_pMandatorySavedValues != NULL)
    {
      FreeADsMem(m_pMandatorySavedValues);
    }
    if (m_pOptionalSavedValues != NULL)
    {
      FreeADsMem(m_pOptionalSavedValues);
    }
		RemoveAllAttr();
	}

	void RemoveAllAttr() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}
	POSITION FindProperty(LPCWSTR lpszAttr);
	BOOL HasProperty(LPCWSTR lpszAttr);
	void GetNextDirty(POSITION& pos, CADSIAttribute** ppAttr);
	BOOL HasDirty();
  int GetDirtyCount()
  {
    int nCount = 0;
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      if (GetNext(pos)->IsDirty())
        nCount++;
    }
    return nCount;
  }

  void SaveMandatoryValuesPointer(PADS_ATTR_INFO pAttrInfo) { m_pMandatorySavedValues = pAttrInfo; }
  void SaveOptionalValuesPointer(PADS_ATTR_INFO pAttrInfo) { m_pOptionalSavedValues = pAttrInfo; }

private:
  PADS_ATTR_INFO  m_pMandatorySavedValues;
  PADS_ATTR_INFO  m_pOptionalSavedValues;
};

#endif //_ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attredit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attredit.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "common.h"
#include "attredit.h"
#include "connection.h"
#include "attrqry.h"


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////////
// this is used to fill in the attributes for RootDSE
//
typedef struct tagRootDSEAttr
{
	LPCWSTR	lpszAttr;
	LPCWSTR	lpszSyntax;	 
   BOOL		bMulti;
} SYNTAXMAP;

extern SYNTAXMAP g_ldapRootDSESyntax[];
extern LPCWSTR g_lpszGC;
extern LPCWSTR g_lpszRootDSE;

///////////////////////////////////////////////////////////////////////////
// CAttrList

POSITION CAttrList::FindProperty(LPCWSTR lpszAttr)
{
	CADSIAttr* pAttr;
	
	for (POSITION p = GetHeadPosition(); p != NULL; GetNext(p))
	{
		// I use GetAt here because I don't want to advance the POSITION
		// because it is returned if they are equal
		//
		pAttr = GetAt(p);
		CString sName;
		pAttr->GetProperty(sName);
		if (wcscmp(sName, lpszAttr) == 0)
		{
			break;
		}
	}
	return p;
}

BOOL CAttrList::HasProperty(LPCWSTR lpszAttr)
{
	POSITION pos = FindProperty(lpszAttr);
	return pos != NULL;
}


// Searches through the cache for the attribute
// ppAttr will point to the CADSIAttr if found, NULL if not
//
void CAttrList::GetNextDirty(POSITION& pos, CADSIAttr** ppAttr)
{
	*ppAttr = GetNext(pos);
	if (pos == NULL && !(*ppAttr)->IsDirty())
	{
		*ppAttr = NULL;
		return;
	}

	while (!(*ppAttr)->IsDirty() && pos != NULL)
	{
		*ppAttr = GetNext(pos);
		if (!(*ppAttr)->IsDirty() && pos == NULL)
		{
			*ppAttr = NULL;
			break;
		}
	}
}

BOOL CAttrList::HasDirty()
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CADSIAttr* pAttr = GetNext(pos);
		if (pAttr->IsDirty())
		{
			return TRUE;
		}
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////
// CDNSManageButtonTextHelper

CDNSManageButtonTextHelper::CDNSManageButtonTextHelper(int nStates) 
{
	m_nID = 0;
	m_pParentWnd = NULL;
	m_nStates = nStates;
	m_lpszText = NULL;
	m_lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*m_nStates);
  if (m_lpszArr != NULL)
  {
	  memset(m_lpszArr, 0x0, sizeof(LPWSTR*)*m_nStates);
  }
}

CDNSManageButtonTextHelper::~CDNSManageButtonTextHelper()
{
	for (int k = 0; k < m_nStates; k++)
	{
		if (m_lpszArr[k] != NULL)
			free(m_lpszArr[k]);
	}

	free(m_lpszArr);
}

void CDNSManageButtonTextHelper::SetStateX(int nIndex)
{
	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	ASSERT(pWnd != NULL);
	ASSERT( (nIndex >0) || (nIndex < m_nStates));
	pWnd->SetWindowText(m_lpszArr[nIndex]);
}

BOOL CDNSManageButtonTextHelper::Init(CWnd* pParentWnd, UINT nButtonID, UINT* nStrArray)
{
	ASSERT(m_pParentWnd == NULL);
	ASSERT(pParentWnd != NULL);
	m_pParentWnd = pParentWnd;
	m_nID = nButtonID;

	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	if (pWnd == NULL)
		return FALSE;

	// get the text for the window
	int nSuccessEntries;
	LoadStringArrayFromResource(m_lpszArr, nStrArray, m_nStates, &nSuccessEntries);
	ASSERT(nSuccessEntries == m_nStates);

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////
// CDNSButtonToggleTextHelper

CDNSButtonToggleTextHelper::CDNSButtonToggleTextHelper()
		: CDNSManageButtonTextHelper(2)
{
}

///////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CADSIEditBox, CEdit)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

void CADSIEditBox::OnChange()
{
	m_pEditor->OnEditChange();
}

////////////////////////////////////////////////////////////////
// CADSIValueBox
BEGIN_MESSAGE_MAP(CADSIValueBox, CEdit)
//	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////
// CADSIValueList
BEGIN_MESSAGE_MAP(CADSIValueList, CListBox)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()

void CADSIValueList::OnSelChange()
{
	m_pEditor->OnValueSelChange();
}

////////////////////////////////////////////////////////////////
// CADSIAddButton
BEGIN_MESSAGE_MAP(CADSIAddButton, CButton)
	ON_CONTROL_REFLECT(BN_CLICKED, OnAdd)
END_MESSAGE_MAP()

void CADSIAddButton::OnAdd()
{
	m_pEditor->OnAddValue();
}

////////////////////////////////////////////////////////////////
// CADSIRemoveButton
BEGIN_MESSAGE_MAP(CADSIRemoveButton, CButton)
	ON_CONTROL_REFLECT(BN_CLICKED, OnRemove)
END_MESSAGE_MAP()

void CADSIRemoveButton::OnRemove()
{
	m_pEditor->OnRemoveValue();
}

////////////////////////////////////////////////////////////////
// CAttrEditor

CAttrEditor::CAttrEditor()  : m_AttrEditBox(this),
															m_SyntaxBox(this),
															m_ValueBox(this),
															m_ValueList(this),
															m_AddButton(this),
															m_RemoveButton(this),
															m_AddButtonHelper(),
															m_RemoveButtonHelper()
{
  m_bExisting = TRUE;
  m_ptouchedAttr = NULL;
}

BOOL CAttrEditor::Initialize(CPropertyPageBase* pParentWnd, CTreeNode* pTreeNode, 
														 LPCWSTR lpszServer, 
														 UINT nIDEdit, UINT nIDSyntax, 
														 UINT nIDValueBox, UINT nIDValueList, 
														 UINT nIDAddButton, UINT nIDRemoveButton,
														 BOOL bComplete)
{
	ASSERT(pParentWnd != NULL);
	if (pParentWnd == NULL)
		return FALSE;
	m_pParentWnd = pParentWnd;

  m_ptouchedAttr = new CAttrList();
  ASSERT(m_ptouchedAttr != NULL);

	if (pTreeNode == NULL)
  {
		m_bExisting = FALSE;
  }
  else
  {
    m_bExisting = TRUE;
  }

	m_sServer = lpszServer;

  if (m_bExisting)
  {
	  // This gets the CConnectionData from the ConnectionNode by finding a valid treenode and using its
	  //   CADsObject to get the ConnectionNode and then the CConnectionData
	  //
	  m_pTreeNode = pTreeNode;
	  CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(m_pTreeNode);
	  if (pContNode == NULL)
	  {
		  CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(m_pTreeNode);
		  ASSERT(pLeafNode != NULL);
		  m_pConnectData = pLeafNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
	  }
	  else
	  {
		  m_pConnectData = pContNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
	  }
  }

	// sublclass controls
	//
	BOOL bRes = m_AttrEditBox.SubclassDlgItem(nIDEdit, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_SyntaxBox.SubclassDlgItem(nIDSyntax, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_ValueBox.SubclassDlgItem(nIDValueBox, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_ValueList.SubclassDlgItem(nIDValueList, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_AddButton.SubclassDlgItem(nIDAddButton, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	UINT nAddButtonTextIDs[2] = { IDS_BUTTON_TEXT_ADD, IDS_BUTTON_TEXT_SET };
	m_AddButtonHelper.Init(m_pParentWnd, 
								  nIDAddButton, 
								  nAddButtonTextIDs);

	bRes = m_RemoveButton.SubclassDlgItem(nIDRemoveButton, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	UINT nRemoveButtonTextIDs[2] = { IDS_BUTTON_TEXT_REMOVE, IDS_BUTTON_TEXT_CLEAR };
	m_RemoveButtonHelper.Init(m_pParentWnd,
									  nIDRemoveButton,
									  nRemoveButtonTextIDs);

	if (!m_sNotSet.LoadString(IDS_NOT_SET))
	{
		return FALSE;
	}

	if ( bComplete)
	{
		// Show property values as single and without the ability to set or clear
		//
		SetPropertyUI(0, FALSE, TRUE);
	}
	else
	{
		m_AttrEditBox.ShowWindow(SW_HIDE);
		m_SyntaxBox.ShowWindow(SW_HIDE);
		m_ValueBox.ShowWindow(SW_HIDE);
		m_ValueList.ShowWindow(SW_HIDE);
		m_AddButton.ShowWindow(SW_HIDE);
		m_RemoveButton.ShowWindow(SW_HIDE);
	}
	return bRes;
}

BOOL CAttrEditor::Initialize(CPropertyPageBase* pParentWnd, CConnectionData* pConnectData, 
														 LPCWSTR lpszServer, 
														 UINT nIDEdit, UINT nIDSyntax, 
														 UINT nIDValueBox, UINT nIDValueList, 
														 UINT nIDAddButton, UINT nIDRemoveButton,
														 BOOL bComplete, CAttrList* pAttrList)
{
	ASSERT(pParentWnd != NULL);
	if (pParentWnd == NULL)
		return FALSE;
	m_pParentWnd = pParentWnd;

	m_bExisting = FALSE;
	m_sServer = lpszServer;
  m_pConnectData = pConnectData;

  ASSERT(pAttrList != NULL);
  m_ptouchedAttr = pAttrList;

	// sublclass controls
	//
	BOOL bRes = m_AttrEditBox.SubclassDlgItem(nIDEdit, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_SyntaxBox.SubclassDlgItem(nIDSyntax, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_ValueBox.SubclassDlgItem(nIDValueBox, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_ValueList.SubclassDlgItem(nIDValueList, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;

	bRes = m_AddButton.SubclassDlgItem(nIDAddButton, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	UINT nAddButtonTextIDs[2] = { IDS_BUTTON_TEXT_ADD, IDS_BUTTON_TEXT_SET };
	m_AddButtonHelper.Init(m_pParentWnd, 
								  nIDAddButton, 
								  nAddButtonTextIDs);

	bRes = m_RemoveButton.SubclassDlgItem(nIDRemoveButton, m_pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	UINT nRemoveButtonTextIDs[2] = { IDS_BUTTON_TEXT_REMOVE, IDS_BUTTON_TEXT_CLEAR };
	m_RemoveButtonHelper.Init(m_pParentWnd,
									  nIDRemoveButton,
									  nRemoveButtonTextIDs);

	if (!m_sNotSet.LoadString(IDS_NOT_SET))
	{
		return FALSE;
	}

	if ( bComplete)
	{
		// Show property values as single and without the ability to set or clear
		//
		SetPropertyUI(0, FALSE, TRUE);
	}
	else
	{
		m_AttrEditBox.ShowWindow(SW_HIDE);
		m_SyntaxBox.ShowWindow(SW_HIDE);
		m_ValueBox.ShowWindow(SW_HIDE);
		m_ValueList.ShowWindow(SW_HIDE);
		m_AddButton.ShowWindow(SW_HIDE);
		m_RemoveButton.ShowWindow(SW_HIDE);
	}
	return bRes;
}
void CAttrEditor::SetAttribute(LPCWSTR lpszAttr, LPCWSTR lpszPath)
{ 
	m_sAttr = lpszAttr; 
	m_sPath = lpszPath; 
	DisplayAttribute(); 
}


BOOL CAttrEditor::OnApply()
{
	if (m_bExisting && m_ptouchedAttr->HasDirty() && 
			!m_pConnectData->IsRootDSE() &&
			!m_pConnectData->IsGC())
	{
		CComPtr<IDirectoryObject> pDirObject;

		// bind to object with authentication
		//
		HRESULT hr, hCredResult;
		hr = OpenObjectWithCredentials(
																	 m_pConnectData, 
 																	 m_pConnectData->GetCredentialObject()->UseCredentials(),
																	 (LPWSTR)(LPCWSTR)m_sPath,
																	 IID_IDirectoryObject, 
																	 (LPVOID*) &pDirObject,
																	 NULL,
																	 hCredResult
																	 );

		if (FAILED(hr))
		{
			if (SUCCEEDED(hCredResult))
			{
				ADSIEditErrorMessage(hr);
				m_pParentWnd->SetModified(FALSE);
			}
			// Need to change the focus or we will not be able to navigate with the keyboard
			m_AttrEditBox.SetFocus();
			return FALSE;
		}

		// Change or add values to ADSI cache that have changed
		//
		hr = CADSIAttr::SetValuesInDS(m_ptouchedAttr, pDirObject);


		if (FAILED(hr))
		{
			//Format Error message and pop up a dialog
			ADSIEditErrorMessage(hr);

			m_ptouchedAttr->RemoveAllAttr();
			DisplayAttribute();

			m_pParentWnd->SetModified(FALSE);

      // Need to change the focus or we will not be able to navigate with the keyboard
			m_AttrEditBox.SetFocus();
			return FALSE;
		}
	}
	m_pParentWnd->SetModified(FALSE);
	return TRUE;
}

void CAttrEditor::OnAddValue()
{
	ASSERT(!m_pConnectData->IsRootDSE());
	ASSERT(!m_pConnectData->IsGC()); 
	
	CString s;
	m_AttrEditBox.GetWindowText(s);

	CStringList sList; 
	m_pAttr->GetValues(sList);

	if (m_pAttr->GetMultivalued())
	{
		// if it is the first value to be added we need to get rid of the "<not set>"
		//
		CString sNotSet;
		m_ValueList.GetText(0, sNotSet);
		if (sNotSet == m_sNotSet)
		{
			m_ValueList.ResetContent();
		}

		// then add the new value
		//
		sList.AddTail(s);
	}
	else
	{
		// since it is single valued, remove the old one and add the new one
		//
		sList.RemoveAll();
		sList.AddTail(s);
	}

	HRESULT hr = m_pAttr->SetValues(sList);
	if (FAILED(hr))
	{
		DisplayFormatError();
	}
	else
	{
		if ( m_pAttr->GetMultivalued())
		{
			m_ValueList.AddString(s);
		}
		else
		{
			m_ValueBox.SetWindowText(s);
		}

		m_AttrEditBox.SetWindowText(_T(""));
		m_pAttr->SetDirty(TRUE);
		m_pParentWnd->SetModified(TRUE);

		// Make the UI reflect the new data
		//
		m_AttrEditBox.SetFocus();
		SetPropertyUI(~TN_FLAG_ENABLE_ADD, TRUE);

		// Enable the clear button if the attribute is not multivalued
		//
		if ( !m_pAttr->GetMultivalued())
		{
			SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
		}
	}
}

void CAttrEditor::DisplayFormatError()
{
	switch (m_pAttr->GetADsType())
	{
		case ADSTYPE_DN_STRING :
		case ADSTYPE_CASE_EXACT_STRING :
		case ADSTYPE_CASE_IGNORE_STRING :
		case ADSTYPE_PRINTABLE_STRING :
		case ADSTYPE_NUMERIC_STRING :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}

		case ADSTYPE_BOOLEAN :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT_BOOLEAN, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}

		case ADSTYPE_INTEGER :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}

		case ADSTYPE_OCTET_STRING :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT_OCTET, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}

		case ADSTYPE_UTC_TIME :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT_TIME, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}

		case ADSTYPE_LARGE_INTEGER :
		case ADSTYPE_OBJECT_CLASS :
		case ADSTYPE_UNKNOWN :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}

		default :
		{
			ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
			if (m_pAttr->GetMultivalued())
			{
				if (m_ValueList.GetCount() < 1)
				{
					m_ValueList.AddString(m_sNotSet);
				}
			}
			break;
		}
	}
}

void CAttrEditor::OnRemoveValue()
{
	if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC()) 
	{
		CStringList sList;
		m_pAttr->GetValues(sList);

		DWORD dwNumVals = m_pAttr->GetNumValues();
		if (m_pAttr->GetMultivalued())
		{
			CString s, sVal;
			int iCount = m_ValueList.GetCurSel();
			m_ValueList.GetText(iCount, sVal);
			m_AttrEditBox.SetWindowText(sVal);
			m_ValueList.DeleteString(iCount);

			// Add "<not set>" to the UI if this is the last value being removed
			//
			if (m_ValueList.GetCount() == 0)
			{
				m_AttrEditBox.SetFocus();
				SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
				m_ValueList.AddString(m_sNotSet);
        if (!m_bExisting)
        {
          m_pAttr->SetDirty(FALSE);
        }
			}
			POSITION pos = sList.FindIndex(iCount);

			sList.RemoveAt(pos);
			HRESULT hr = m_pAttr->SetValues(sList);
			if (FAILED(hr))
			{
				ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
			}
      if (m_bExisting || m_ValueList.GetCount() > 0)
      {
        m_pAttr->SetDirty(TRUE);
      }
		}
		else
		{
			CString sVal;
			m_ValueBox.GetWindowText(sVal);
			m_AttrEditBox.SetWindowText(sVal);
			m_ValueBox.SetWindowText( m_sNotSet);
			sList.RemoveAll();
			HRESULT hr = m_pAttr->SetValues(sList);
			if (FAILED(hr))
			{
				ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
			}
      if (!m_bExisting)
      {
        m_pAttr->SetDirty(FALSE);
      }
      else
      {
        m_pAttr->SetDirty(TRUE);
      }
		}
		m_AttrEditBox.SetFocus();
		SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
		dwNumVals--;
		m_pParentWnd->SetModified(TRUE);
	}
}

void CAttrEditor::OnEditChange()
{
	if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC()) 
	{
		CString s;
		m_AttrEditBox.GetWindowText(s);
		if (s != _T(""))
		{
			SetPropertyUI(TN_FLAG_ENABLE_ADD, FALSE);
		}
		else
		{
			SetPropertyUI(~TN_FLAG_ENABLE_ADD, TRUE);
		}
	}
}

void CAttrEditor::OnValueSelChange()
{
	if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC())
	{
		SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
	}
}

void CAttrEditor::GetAttrFailed()
{
	CString sSyntax;

	GetSyntax(m_sAttr, sSyntax);
	m_SyntaxBox.SetWindowText(sSyntax);

	m_ValueList.ResetContent();
	m_ValueList.AddString(m_sNotSet);
  m_ValueBox.SetWindowText(m_sNotSet);

	SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
}

void CAttrEditor::FillWithExisting()
{
	CString s;
	m_pAttr = m_ptouchedAttr->GetAt(m_ptouchedAttr->FindProperty(m_sAttr));
  ASSERT(m_pAttr != NULL);

	CStringList slValues;
	m_pAttr->GetValues(slValues);

	if (m_pAttr->GetMultivalued())
	{
		m_ValueList.ResetContent();

		POSITION pos;
		if (slValues.GetCount() == 0)
		{
			slValues.AddTail(m_sNotSet);
		}
		
		for (pos = slValues.GetHeadPosition(); pos != NULL; slValues.GetNext(pos) )
		{
			s = slValues.GetAt(pos);
			m_ValueList.AddString(s);
		}

		SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
	}
	else
	{
		if (slValues.GetCount() > 0)
		{
			s = slValues.GetAt(slValues.GetHeadPosition());
			m_ValueBox.SetWindowText(s);

			if (!m_pConnectData->IsRootDSE() && !m_pConnectData->IsGC())
			{
				SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
			}
		}
		else
		{
			m_ValueBox.SetWindowText(m_sNotSet);
			SetPropertyUI(~TN_FLAG_ENABLE_REMOVE, TRUE);
		}
		SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
	}
}



void CAttrEditor::DisplayAttribute()
{
	int iCount;
	HRESULT hr, hCredResult;

	if (m_ptouchedAttr->HasProperty(m_sAttr))
	{
		FillWithExisting();
	}
	else
	{

		if (m_pConnectData->IsRootDSE())
		{
			DisplayRootDSE();
		}
    else if (!m_bExisting)
    {
			ADS_ATTR_INFO *pAttrInfo = NULL;
			GetAttrFailed();
			m_pAttr = TouchAttr(m_sAttr);
      ASSERT(m_pAttr != NULL);
      
      if (m_pAttr != NULL)
      {
			  if (m_pAttr->GetMultivalued())
			  {
				  SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
			  }
			  else
			  {
				  SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
			  }
      }
			return;
    }
		else
		{
			CComPtr<IDirectoryObject> pDirObject;

			hr = OpenObjectWithCredentials(
													 m_pConnectData, 
													 m_pConnectData->GetCredentialObject()->UseCredentials(),
													 (LPWSTR)(LPCWSTR)m_sPath,
													 IID_IDirectoryObject, 
													 (LPVOID*) &pDirObject,
													 NULL,
													 hCredResult
													 );
			if ( FAILED(hr) )
			{
				if (SUCCEEDED(hCredResult))
				{
					ADSIEditErrorMessage(hr);
				}
				return;
			}
      ASSERT(pDirObject != NULL);

			// Get attribute
			//
      CString szAttrName;
      szAttrName = m_sAttr + _T(";range=0-*");
      CString szFormat = m_sAttr + _T(";range=%ld-*");
			DWORD dwReturn = 0;
			DWORD dwNumAttr = 1;
			ADS_ATTR_INFO *pAttrInfo;

      const WCHAR wcSep = L'-';
      const WCHAR wcEnd = L'*';
      BOOL fMoreRemain = FALSE;

      CStringList sList;

      do
      {
        LPWSTR lpszAttrs[] = {(LPWSTR)(LPCWSTR)szAttrName};
			  hr = pDirObject->GetObjectAttributes(lpszAttrs, dwNumAttr, &pAttrInfo, &dwReturn);
			  if (FAILED(hr))
			  {
				  ADSIEditErrorMessage(hr);
				  return;
			  }

			  if (pAttrInfo == NULL)
			  {
				  GetAttrFailed();
				  m_pAttr = TouchAttr(m_sAttr);
          ASSERT(m_pAttr != NULL);
          
          if (m_pAttr != NULL)
          {
				    if (m_pAttr->GetMultivalued())
				    {
					    SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
				    }
				    else
				    {
					    SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
				    }
          }
				  return;
			  }

        if (dwReturn > 0)
        {
				  GetStringFromADs(pAttrInfo, sList);
        }

        //
        // Check to see if there is more data. If the last char of the
        // attribute name string is an asterisk, then we have everything.
        //
        int cchEnd = wcslen(pAttrInfo->pszAttrName);

        fMoreRemain = pAttrInfo->pszAttrName[cchEnd - 1] != wcEnd;

        if (fMoreRemain)
        {
            PWSTR pwz = wcsrchr(pAttrInfo->pszAttrName, wcSep);
            if (!pwz)
            {
                ASSERT(FALSE && pAttrInfo->pszAttrName);
                fMoreRemain = FALSE;
            }
            else
            {
                pwz++; // move past the hyphen to the range end value.
                ASSERT(*pwz);
                long lEnd = _wtol(pwz);
                lEnd++; // start with the next value.
                szAttrName.Format(szFormat, lEnd);
                TRACE(L"Range returned is %ws, now asking for %ws\n",
                             pAttrInfo->pszAttrName, szAttrName);
            }
        }
      } while (fMoreRemain);

			BOOL bMulti = FALSE;
      if (m_pConnectData->IsGC())
      {
        bMulti = IsMultiValued(pAttrInfo);
      }
      else
      {
        bMulti = IsMultiValued(m_sAttr);
      }

			if (pAttrInfo != NULL)
			{
				if (bMulti)
				{
					SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);

					m_ValueList.ResetContent();

					POSITION pos = sList.GetHeadPosition();
					while (pos != NULL)
					{
						CString sValue = sList.GetNext(pos);
						m_ValueList.AddString(sValue);
					}
				}
				else
				{
					SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);

          if (sList.GetCount() > 0)
          {
            m_ValueBox.SetWindowText(sList.GetHead());
          }
					if (!m_pConnectData->IsGC())
					{
						SetPropertyUI(TN_FLAG_ENABLE_REMOVE, FALSE);
					}
				}
			}
			else
			{
				GetAttrFailed();
				CStringList sTempList;
				m_pAttr = TouchAttr(pAttrInfo, bMulti);
				if (bMulti)
				{
					SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE, TRUE);
				}
				else
				{
					SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);
				}
				return;
			}
			m_pAttr = TouchAttr(pAttrInfo, bMulti);
		}	
	}

	CString sSyntax;
	GetSyntax(m_sAttr, sSyntax);
	m_SyntaxBox.SetWindowText(sSyntax);
}

void CAttrEditor::DisplayRootDSE()
{
	CString s = m_sPath;

	CComPtr<IADs> pADs;
	HRESULT hr, hCredResult;
	hr = OpenObjectWithCredentials(
											 m_pConnectData, 
 											 m_pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)s,
											 IID_IADs, 
											 (LPVOID*)&pADs,
											 NULL,
											 hCredResult
											 );

	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

	// This is to insure that the ADSI cache is current
	//
	hr = pADs->GetInfo();

	VARIANT var;
	hr = pADs->GetEx( (LPWSTR)(LPCWSTR)m_sAttr , &var );
	if ( FAILED(hr) )
	{
		GetAttrFailed();
		m_pAttr = TouchAttr(m_sAttr);
		return;
	}

	/////////////////////////////////////////
	//	Convert and populate
	///////////////////////////////////////////
	CStringList sList;
	hr = VariantToStringList( var, sList );
	if ( FAILED(hr) )
	{
		GetAttrFailed();
		VariantClear(&var);
		CStringList sTempList;
		m_pAttr = TouchAttr(m_sAttr);
		return;
	}
	VariantClear( &var );


	if ( IsRootDSEAttrMultiValued(m_sAttr) )
	{
		SetPropertyUI(TN_FLAG_SHOW_MULTI, FALSE);

		m_ValueList.ResetContent();

		POSITION pos = sList.GetHeadPosition();
		while (pos != NULL)
		{
			CString sValue = sList.GetNext(pos);
			m_ValueList.AddString(sValue);
		}
	}
	else
	{
		SetPropertyUI(~TN_FLAG_SHOW_MULTI, TRUE);

		s = sList.GetHead();
		m_ValueBox.SetWindowText(s);
	}

//	m_pAttr = TouchAttr(m_sAttr);

	CString sSyntax;
	GetSyntax(m_sAttr, sSyntax);
	m_SyntaxBox.SetWindowText(sSyntax);

	// REVEIW : this is the only occurrance of "UTCTime", if there
	//          becomes more we may need to make a global string or something
	//
	if (sSyntax == _T("UTCTime"))
	{
		CString sFormatted, sRemainder;
		CString sYear, sMonth, sDay, sHour, sMinute, sSecond;
		int iCount = 0;

		sYear = s.Left(4);
		iCount = s.GetLength();
		sRemainder = s.Right(iCount - 4);

		sMonth = sRemainder.Left(2);
		iCount = sRemainder.GetLength();
		sRemainder = sRemainder.Right(iCount - 2);

		sDay = sRemainder.Left(2);
		iCount = sRemainder.GetLength();
		sRemainder = sRemainder.Right(iCount - 2);

		sHour = sRemainder.Left(2);
		iCount = sRemainder.GetLength();
		sRemainder = sRemainder.Right(iCount - 2);

		sMinute = sRemainder.Left(2);
		iCount = sRemainder.GetLength();
		sRemainder = sRemainder.Right(iCount - 2);

		sSecond = sRemainder.Left(2);

		sFormatted = sMonth + _T("/") + sDay + _T("/") + sYear + _T(" ")
								 + sHour + _T(":") + sMinute + _T(":") + sSecond;
		m_ValueBox.SetWindowText(sFormatted);
	}
}

BOOL CAttrEditor::IsRootDSEAttrMultiValued(LPCWSTR lpszAttr)
{
	int idx=0, iCount = 0;

	iCount = wcslen(lpszAttr);

	while( g_ldapRootDSESyntax[idx].lpszAttr) 
	{
		if ( _wcsnicmp(g_ldapRootDSESyntax[idx].lpszAttr, lpszAttr, iCount) == 0)
		{
			return g_ldapRootDSESyntax[idx].bMulti;
		}
		idx++;
	}
	return FALSE;
}

// TODO : This is extremely ugly, redo it
//
void CAttrEditor::SetPropertyUI(DWORD dwFlags, BOOL bAnd, BOOL bReset)
{
	if (bReset)
	{
		m_dwMultiFlags = dwFlags;
	}

	if (bAnd)
	{
		m_dwMultiFlags &= dwFlags;
	}
	else
	{
		m_dwMultiFlags |= dwFlags;
	}

	if (m_dwMultiFlags & TN_FLAG_SHOW_MULTI)
	{
		m_AddButtonHelper.SetToggleState(TRUE);
		m_RemoveButtonHelper.SetToggleState(TRUE);
		m_ValueList.ShowWindow(SW_SHOW);
		m_ValueBox.ShowWindow(SW_HIDE);
	}
	else
	{
		m_AddButtonHelper.SetToggleState(FALSE);
		m_RemoveButtonHelper.SetToggleState(FALSE);
		m_ValueList.ShowWindow(SW_HIDE);
		m_ValueBox.ShowWindow(SW_SHOW);
	}

	if (m_dwMultiFlags & TN_FLAG_ENABLE_REMOVE)
	{
		m_RemoveButton.EnableWindow(TRUE);
	}
	else
	{
		m_RemoveButton.EnableWindow(FALSE);
	}

	if (m_dwMultiFlags & TN_FLAG_ENABLE_ADD)
	{
		m_AddButton.EnableWindow(TRUE);
	}
	else
	{
		m_AddButton.EnableWindow(FALSE);
	}

  if (m_bExisting && (m_pConnectData->IsGC() || m_pConnectData->IsRootDSE()))
  {
    m_AttrEditBox.EnableWindow(FALSE);
  }
  else
  {
    m_AttrEditBox.EnableWindow(TRUE);
  }
}

void CAttrEditor::GetSyntax(LPCWSTR lpszProp, CString& sSyntax)
{
	if (m_bExisting && m_pConnectData->IsRootDSE())
	{
		int idx=0;
		
		while( g_ldapRootDSESyntax[idx].lpszAttr )
		{
			if ( wcscmp(lpszProp, g_ldapRootDSESyntax[idx].lpszAttr) == 0 )
			{
				sSyntax = g_ldapRootDSESyntax[idx].lpszSyntax;
				return;
			}
			idx++;
		}
	}
	else
	{
		CComPtr<IADsProperty> pProp;
		HRESULT hr, hCredResult;
		CString schema;
		m_pConnectData->GetAbstractSchemaPath(schema);
		schema = schema + lpszProp;

		hr = OpenObjectWithCredentials(
																	 m_pConnectData, 
																	 m_pConnectData->GetCredentialObject()->UseCredentials(),
																	 (LPWSTR)(LPCWSTR)schema,
																	 IID_IADsProperty, 
																	 (LPVOID*) &pProp,
																	 NULL,
																	 hCredResult
																	 );

		if ( FAILED(hr) )
		{
			if (SUCCEEDED(hCredResult))
			{
				ADSIEditErrorMessage(hr);
			}
			return;
		}
	

		///////////////////////////////////////////////////
		// Create a new cached attribute and populate
		//////////////////////////////////////////////////

		BSTR bstr;

		hr = pProp->get_Syntax( &bstr );
		if ( SUCCEEDED(hr) )
		{
			sSyntax = bstr;
		}
		SysFreeString(bstr);
	}
}

BOOL CAttrEditor::IsMultiValued(ADS_ATTR_INFO* pAttrInfo)
{
  return (pAttrInfo->dwNumValues > 1) ? TRUE : FALSE;
}

BOOL CAttrEditor::IsMultiValued(LPCWSTR lpszProp)
{
	CString schema;
	BOOL bResult = FALSE;

	CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(m_pTreeNode);
	if (pContNode == NULL)
	{
		CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(m_pTreeNode);
		ASSERT(pLeafNode != NULL);
		bResult = pLeafNode->BuildSchemaPath(schema);
	}
	else
	{
		bResult = pContNode->BuildSchemaPath(schema);
	}

	if (!bResult)
	{
		return FALSE;
	}

	CADSIQueryObject schemaSearch;

	// Initialize search object with path, username and password
	//
	HRESULT hr = schemaSearch.Init(schema, m_pConnectData->GetCredentialObject());
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return FALSE;
	}

	int cCols = 1;
  LPWSTR pszAttributes[] = {L"isSingleValued"};
	LPWSTR pszDesiredAttr = L"attributeSyntax";
	ADS_SEARCH_COLUMN ColumnData;
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return FALSE;
	}

	BOOL bMulti = FALSE;

  CString csFilter;
	csFilter.Format(L"(&(objectClass=attributeSchema)(lDAPDisplayName=%s))", lpszProp);
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  if (SUCCEEDED(hr)) 
	{
    hr = schemaSearch.GetNextRow();
    if (SUCCEEDED(hr)) 
		{
			hr = schemaSearch.GetColumn(pszAttributes[0], &ColumnData);
			if (SUCCEEDED(hr))
			{
				TRACE(_T("\t\tisSingleValued: %d\n"), 
				     ColumnData.pADsValues->Boolean);
				bMulti = !ColumnData.pADsValues->Boolean;
			}
		}
	}
	return bMulti;
}

// NOTE : this is only called for the RootDSE or if we failed to get
//				values for the attribute.  An empty ADS_ATTR_INFO object is
//				created but should not be modified.  If values are to be changed
//				or set for this object a new ADS_ATTR_INFO should be created
//				with the desired block of memory allocated for the values
//
CADSIAttr* CAttrEditor::TouchAttr(LPCWSTR lpszAttr)
{
   POSITION pos = m_ptouchedAttr->FindProperty(lpszAttr);

   if (pos == NULL)
   {
      ADS_ATTR_INFO* pADsInfo = new ADS_ATTR_INFO;
      if (!pADsInfo)
      {
         return 0;
      }
      memset(pADsInfo, 0, sizeof(ADS_ATTR_INFO));

      int iLength = wcslen(lpszAttr);
      pADsInfo->pszAttrName = new WCHAR[iLength + 1];
      wcscpy(pADsInfo->pszAttrName, lpszAttr);

      CADSIQueryObject schemaSearch;

      BOOL bResult;
      CString schema;
      CADSIEditContainerNode* pContNode = m_pConnectData->GetConnectionNode();
      bResult = pContNode->BuildSchemaPath(schema);
      if (!bResult)
      {
         return NULL;
      }

      // Initialize search object with path, username and password
      //
      HRESULT hr = schemaSearch.Init(schema, m_pConnectData->GetCredentialObject());
      if (FAILED(hr))
      {
         ADSIEditErrorMessage(hr);
         return NULL;
      }

      int cCols = 3;
      LPWSTR pszAttributes[] = {L"lDAPDisplayName", L"attributeSyntax", L"isSingleValued"};
      LPWSTR pszDesiredAttr = _T("attributeSyntax");
      ADS_SEARCH_COLUMN ColumnData;
      hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
      if (FAILED(hr))
      {
         ADSIEditErrorMessage(hr);
         return NULL;
      }

      BOOL bMulti = FALSE;
      CString szSyntax;

      CString csFilter;
      csFilter.Format(L"(&(objectClass=attributeSchema)(lDAPDisplayName=%s))", lpszAttr);
      schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
      schemaSearch.SetAttributeList (pszAttributes, cCols);
      hr = schemaSearch.DoQuery ();
      if (SUCCEEDED(hr)) 
      {
         hr = schemaSearch.GetNextRow();
         if (SUCCEEDED(hr)) 
         {
            hr = schemaSearch.GetColumn(pszDesiredAttr,
                                  &ColumnData);
            if (SUCCEEDED(hr))
            {
               TRACE(_T("\t\tattributeSyntax: %s\n"), 
	                 ColumnData.pADsValues->CaseIgnoreString);

               ADSTYPE dwType;
               dwType = GetADsTypeFromString(ColumnData.pADsValues->CaseIgnoreString, szSyntax);
               pADsInfo->dwADsType = dwType;
            }

            hr = schemaSearch.GetColumn(pszAttributes[2], &ColumnData);
            if (SUCCEEDED(hr))
            {
               TRACE(_T("\t\tisSingleValued: %d\n"), 
	                 ColumnData.pADsValues->Boolean);
               pADsInfo->dwNumValues = 0;
               bMulti = !ColumnData.pADsValues->Boolean;
				}
			}
		}

		CADSIAttr* pAttr = new CADSIAttr(pADsInfo, bMulti, szSyntax, FALSE);
		m_ptouchedAttr->AddTail(pAttr);
		return pAttr;
	}

	return m_ptouchedAttr->GetAt(pos);
}

CADSIAttr* CAttrEditor::TouchAttr(ADS_ATTR_INFO* pADsInfo, BOOL bMulti)
{
	POSITION pos = m_ptouchedAttr->FindProperty(pADsInfo->pszAttrName);

	if (pos == NULL)
	{
		CADSIAttr* pAttr = new CADSIAttr(pADsInfo, bMulti, L"");
		m_ptouchedAttr->AddTail(pAttr);
		return pAttr;
	}

	return m_ptouchedAttr->GetAt(pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attribute.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.h
//
//--------------------------------------------------------------------------

#ifndef _ATTRIBUTE_H
#define _ATTRIBUTE_H

#include "common.h"

///////////////////////////////////////////////////////////////////////
class CAttrList;

////////////////////////////////////////////////////////////////////////
// CADSIAttr

class CADSIAttr
{
public:
	// Constructors
	//
	CADSIAttr(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly = TRUE);
	CADSIAttr(LPCWSTR lpszAttr);
	CADSIAttr(CADSIAttr* pAttr);

	// Destructor
	//
	~CADSIAttr(); 

	// Data accessor functions
	//
	void GetProperty(CString& sProp) { sProp = m_pAttrInfo->pszAttrName; }
	DWORD GetNumValues() { return m_pAttrInfo->dwNumValues; }

	HRESULT SetValues(const CStringList& sValues); 
	void GetValues(CStringList& psValues, DWORD dwMaxCharCount = 1024);

	BOOL GetMultivalued() { return m_bMulti; }
	void SetMultivalued(BOOL bMulti) { m_bMulti = bMulti; }

	void SetDirty(const BOOL bDirty) { m_bDirty = bDirty; }
	BOOL IsDirty() { return m_bDirty; }

	ADSTYPE GetADsType() { return m_pAttrInfo->dwADsType; }
	void SetADsType(ADSTYPE dwType) { m_pAttrInfo->dwADsType = dwType; }

   CString GetSyntax() { return m_szSyntax; }
   void SetSyntax(PCWSTR pszSyntax) { m_szSyntax = pszSyntax; }

	ADS_ATTR_INFO* GetAttrInfo();
	ADSVALUE* GetADsValues() { return m_pAttrInfo->pADsValues; }

	static HRESULT SetValuesInDS(CAttrList* ptouchAttr, IDirectoryObject* pDirObject);

private:
	// Functions
	//
	ADSVALUE* GetADSVALUE(int idx);

	static BOOL _AllocOctetString(ADS_OCTET_STRING& rOldOctetString, ADS_OCTET_STRING& rNew);
	static void _FreeOctetString(BYTE* lpValue);
	static BOOL _AllocString(LPCWSTR lpsz, LPWSTR* lppszNew);
	static void _FreeString(LPWSTR* lppsz);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo);
	static BOOL _CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly);
	static void _FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo);
	static BOOL _AllocValues(ADSVALUE** ppValues, DWORD dwLength);
	static BOOL _CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* ppNewAttrInfo);
	static void _FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength);

	static HRESULT _SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue);

	// Member data
	//
	ADS_ATTR_INFO* m_pAttrInfo;
	BOOL m_bDirty;
	BOOL m_bMulti;
	BOOL m_bReadOnly;
   CString m_szSyntax;
};

#endif //_ATTRIBUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attribute.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       attribute.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "common.h"
#include "attredit.h"
#include "attribute.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

///////////////////////////////////////////////////////////////////////////
// CADSIAttr

CADSIAttr::CADSIAttr(ADS_ATTR_INFO* pInfo, BOOL bMulti, PCWSTR pszSyntax, BOOL bReadOnly)
{
	m_pAttrInfo = pInfo;
	m_bDirty = FALSE;
	m_bMulti = bMulti;
	m_bReadOnly = bReadOnly;
   m_szSyntax = pszSyntax;

  PWSTR pwz = wcsrchr(pInfo->pszAttrName, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }

}

CADSIAttr::CADSIAttr(LPCWSTR lpszAttr)
{
	m_pAttrInfo = new ADS_ATTR_INFO;
	memset(m_pAttrInfo, 0, sizeof(ADS_ATTR_INFO));

  PWSTR pwz = wcsrchr(lpszAttr, L';');
  if (pwz)
  {
    pwz; // move past the hyphen to the range end value.
    ASSERT(*pwz);
    *pwz=L'\0';
  }
	_AllocString(lpszAttr, &(m_pAttrInfo->pszAttrName));

	m_bMulti = FALSE;
	m_bDirty = FALSE;
	m_bReadOnly = FALSE;
}

CADSIAttr::CADSIAttr(CADSIAttr* pOldAttr)
{
	m_pAttrInfo = NULL;
	ADS_ATTR_INFO* pAttrInfo = pOldAttr->GetAttrInfo();

	// These copies are done separately because there are places
	// that I need to copy only the ADsAttrInfo and not the values
	//
	_CopyADsAttrInfo(pAttrInfo, &m_pAttrInfo);
	_CopyADsValues(pAttrInfo, m_pAttrInfo );

	m_bReadOnly = FALSE;
	m_bMulti = pOldAttr->m_bMulti;
	m_bDirty = pOldAttr->m_bDirty;
}


CADSIAttr::~CADSIAttr() 
{
	_FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);
}


ADSVALUE* CADSIAttr::GetADSVALUE(int idx)
{
	
	return &(m_pAttrInfo->pADsValues[idx]);
}


HRESULT CADSIAttr::SetValues(const CStringList& sValues)
{
	HRESULT hr;

	ADS_ATTR_INFO* pNewAttrInfo = NULL;
	if (!_CopyADsAttrInfo(m_pAttrInfo, &pNewAttrInfo))
	{
		return E_FAIL;
	}

	int iCount = sValues.GetCount();
	pNewAttrInfo->dwNumValues = iCount;

	if (!_AllocValues(&pNewAttrInfo->pADsValues, iCount))
	{
		return E_FAIL;
	}
	
	int idx = 0;
	POSITION pos = sValues.GetHeadPosition();
	while (pos != NULL)
	{
		CString s = sValues.GetNext(pos);

		ADSVALUE* pADsValue = &(pNewAttrInfo->pADsValues[idx]);
		ASSERT(pADsValue != NULL);

		hr = _SetADsFromString(
													s,
													pNewAttrInfo->dwADsType, 
													pADsValue
													);
		if (FAILED(hr))
		{
			_FreeADsAttrInfo(&pNewAttrInfo, FALSE);
			return hr;
		}
		idx++;
	}

	// Free the old one and swap in the new one
	//
	_FreeADsAttrInfo(&m_pAttrInfo, m_bReadOnly);

	m_pAttrInfo = pNewAttrInfo;
	m_bReadOnly = FALSE;
	return hr;
}

void CADSIAttr::GetValues(CStringList& sValues, DWORD dwMaxCharCount)
{
	GetStringFromADs(m_pAttrInfo, sValues, dwMaxCharCount);
}

ADS_ATTR_INFO* CADSIAttr::GetAttrInfo()
{
	return m_pAttrInfo; 
}

////////////////////////////////////////////////////////////////////////
// Public Helper Functions
///////////////////////////////////////////////////////////////////////
HRESULT CADSIAttr::SetValuesInDS(CAttrList* ptouchedAttr, IDirectoryObject* pDirObject)
{
	DWORD dwReturn;
	DWORD dwAttrCount = 0;
	ADS_ATTR_INFO* pAttrInfo;
	pAttrInfo = new ADS_ATTR_INFO[ptouchedAttr->GetCount()];

	CADSIAttr* pCurrentAttr;
	POSITION pos = ptouchedAttr->GetHeadPosition();
	while(pos != NULL)
	{
		ptouchedAttr->GetNextDirty(pos, &pCurrentAttr);

		if (pCurrentAttr != NULL)
		{
			ADS_ATTR_INFO* pCurrentAttrInfo = pCurrentAttr->GetAttrInfo();
			ADS_ATTR_INFO* pNewAttrInfo = &pAttrInfo[dwAttrCount];

			if (!_CopyADsAttrInfo(pCurrentAttrInfo, pNewAttrInfo))
			{
				for (int itr = 0; itr < dwAttrCount; itr++)
				{
					_FreeADsAttrInfo(&pAttrInfo[itr]);
				}
				delete[] pAttrInfo;

				return E_FAIL;
			}

			if (!_CopyADsValues(pCurrentAttrInfo, pNewAttrInfo))
			{
				delete[] pAttrInfo;
				return E_FAIL;
			}

			if (pAttrInfo[dwAttrCount].dwNumValues == 0)
			{
				pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_CLEAR;
			}
			else
			{
				pAttrInfo[dwAttrCount].dwControlCode = ADS_ATTR_UPDATE;
			}

			dwAttrCount++;
		}
	}

	// Commit the changes that have been made to the ADSI cache
	//
	HRESULT hr = pDirObject->SetObjectAttributes(pAttrInfo, dwAttrCount, &dwReturn);

	for (int itr = 0; itr < dwAttrCount; itr++)
	{
		_FreeADsAttrInfo(&pAttrInfo[itr]);
	}
	delete[] pAttrInfo;

	return hr;
}


/////////////////////////////////////////////////////////////////////////
// Private Helper Functions
////////////////////////////////////////////////////////////////////////

HRESULT CADSIAttr::_SetADsFromString(LPCWSTR lpszValue, ADSTYPE adsType, ADSVALUE* pADsValue)
{
	HRESULT hr = E_FAIL;

  if ( adsType == ADSTYPE_INVALID )
	{
		return hr;
	}

	pADsValue->dwType = adsType;

	switch( adsType ) 
	{
		case ADSTYPE_DN_STRING :
			if (!_AllocString(lpszValue, &pADsValue->DNString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_CASE_EXACT_STRING :
			if (!_AllocString(lpszValue, &pADsValue->CaseExactString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_CASE_IGNORE_STRING :
			if (!_AllocString(lpszValue, &pADsValue->CaseIgnoreString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_PRINTABLE_STRING :
			if (!_AllocString(lpszValue, &pADsValue->PrintableString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;

		case ADSTYPE_NUMERIC_STRING :
			if (!_AllocString(lpszValue, &pADsValue->NumericString))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;
  
		case ADSTYPE_OBJECT_CLASS    :
			if (!_AllocString(lpszValue, &pADsValue->ClassName))
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;
  
		case ADSTYPE_BOOLEAN :
			if (_wcsnicmp(lpszValue, L"TRUE", 4) == 0)
			{
				(DWORD)pADsValue->Boolean = TRUE;
			}
			else if (_wcsnicmp(lpszValue, L"FALSE", 5) == 0)
			{
				(DWORD)pADsValue->Boolean = FALSE;
			}
			else 
			{
				return E_FAIL;
			}
			hr = S_OK;
			break;
  
		case ADSTYPE_INTEGER :
			int value;
			value = swscanf(lpszValue, L"%ld", &pADsValue->Integer);
			if (value > 0)
			{
				hr = S_OK;
			}
			else
			{
				hr = E_FAIL;
			}
			break;
  
		case ADSTYPE_OCTET_STRING : 
			{
				pADsValue->OctetString.lpValue = new BYTE[256];
				int iCount = 0, index = 0, iResult = 0;

				do
				{
					while (lpszValue[index] == ' ' || lpszValue[index] == '/t')
					{
						index++;
					}
					iResult = swscanf(&lpszValue[index], L"0x%2x", &pADsValue->OctetString.lpValue[iCount++]);
					if (iResult == 0 && lpszValue[index] == '\0')
					{
						hr = S_OK;
						break;
					}
					index += 4;  // NOTE : OctetStrings must be in the form 0x00, ie 4 characters

				} while (iResult != 0);
				
				iCount--;  // the last one had to fail
				pADsValue->OctetString.dwLength = iCount;
			}
			break;
  
		case ADSTYPE_LARGE_INTEGER :
			wtoli(lpszValue, pADsValue->LargeInteger);
			hr = S_OK;
			break;
  
		case ADSTYPE_UTC_TIME :
			int iNum;
			WORD n;
			iNum = swscanf(lpszValue, L"%02d/%02d/%04d %02d:%02d:%02d", 
								&n, 
								&pADsValue->UTCTime.wDay, 
								&pADsValue->UTCTime.wYear,
								&pADsValue->UTCTime.wHour, 
								&pADsValue->UTCTime.wMinute, 
								&pADsValue->UTCTime.wSecond 
							  );
			pADsValue->UTCTime.wMonth = n;

			// This strange conversion is done so that the DayOfWeek will be set in 
			// the UTCTime.  By converting it to a filetime it ignores the dayofweek but
			// converting back fills it in.
			//
			FILETIME ft;
			SystemTimeToFileTime(&pADsValue->UTCTime, &ft);
			FileTimeToSystemTime(&ft, &pADsValue->UTCTime);

			if (iNum == 6)
			{
				hr = S_OK;
			}
			else
			{
				hr = E_FAIL;
			}
			break;

		default :
			break;
	}

	return hr;
}

BOOL CADSIAttr::_AllocOctetString(ADS_OCTET_STRING& rOldOctetString, 
																	ADS_OCTET_STRING& rNew)
{
	_FreeOctetString(rNew.lpValue);

	int iLength = rOldOctetString.dwLength;
	rNew.dwLength =	iLength;
	rNew.lpValue = new BYTE[iLength];
	if (rNew.lpValue == NULL)
	{
		_FreeOctetString(rNew.lpValue);
		return FALSE;
	}
	memcpy(rNew.lpValue, rOldOctetString.lpValue, iLength);
	return TRUE;
}

void CADSIAttr::_FreeOctetString(BYTE* lpValue)
{
	if (lpValue != NULL)
	{
		delete lpValue;
		lpValue = NULL;
	}
}

BOOL CADSIAttr::_AllocString(LPCWSTR lpsz, LPWSTR* lppszNew)
{
	_FreeString(lppszNew);

	int iLength = wcslen(lpsz);
	*lppszNew = new WCHAR[iLength + 1];  // an extra for the NULL
	if (*lppszNew == NULL)
	{
		_FreeString(lppszNew);
		return FALSE;
	}
	wcscpy(*lppszNew, lpsz);

	return TRUE;
}
	
void CADSIAttr::_FreeString(LPWSTR* lppsz)
{
	if (*lppsz != NULL)
	{
		delete *lppsz;
	}
	*lppsz = NULL;
}

BOOL CADSIAttr::_AllocValues(ADSVALUE** ppValues, DWORD dwLength)
{
	_FreeADsValues(ppValues, dwLength);

	*ppValues = new ADSVALUE[dwLength];
	if (*ppValues == NULL)
	{
		_FreeADsValues(ppValues, dwLength);
		return FALSE;
	}
	memset(*ppValues, 0, sizeof(ADSVALUE) * dwLength);
	return TRUE;
}

BOOL CADSIAttr::_CopyADsValues(ADS_ATTR_INFO* pOldAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
	_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);

	pNewAttrInfo->dwNumValues = pOldAttrInfo->dwNumValues;
	if (!_AllocValues(&pNewAttrInfo->pADsValues, pOldAttrInfo->dwNumValues))
	{
		_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
		return FALSE;
	}

	for (int itr = 0; itr < pOldAttrInfo->dwNumValues; itr++)
	{
		pNewAttrInfo->pADsValues[itr].dwType = pOldAttrInfo->pADsValues[itr].dwType;

		switch( pNewAttrInfo->pADsValues[itr].dwType ) 
		{
			case ADSTYPE_DN_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].DNString,
													&pNewAttrInfo->pADsValues[itr].DNString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;

			case ADSTYPE_CASE_EXACT_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].CaseExactString,
													&pNewAttrInfo->pADsValues[itr].CaseExactString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
						
			case ADSTYPE_CASE_IGNORE_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].CaseIgnoreString,
													&pNewAttrInfo->pADsValues[itr].CaseIgnoreString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;

			case ADSTYPE_PRINTABLE_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].PrintableString,
													&pNewAttrInfo->pADsValues[itr].PrintableString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;

			case ADSTYPE_NUMERIC_STRING :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].NumericString,
													&pNewAttrInfo->pADsValues[itr].NumericString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
  
			case ADSTYPE_OBJECT_CLASS    :
				if (!_AllocString(pOldAttrInfo->pADsValues[itr].ClassName,
													&pNewAttrInfo->pADsValues[itr].ClassName))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
  
			case ADSTYPE_BOOLEAN :
				pNewAttrInfo->pADsValues[itr].Boolean = pOldAttrInfo->pADsValues[itr].Boolean;
				break;
  
			case ADSTYPE_INTEGER :
				pNewAttrInfo->pADsValues[itr].Integer = pOldAttrInfo->pADsValues[itr].Integer;
				break;
  
			case ADSTYPE_OCTET_STRING :
				if (!_AllocOctetString(pOldAttrInfo->pADsValues[itr].OctetString,
															 pNewAttrInfo->pADsValues[itr].OctetString))
				{
					_FreeADsValues(&pNewAttrInfo->pADsValues, pNewAttrInfo->dwNumValues);
					return FALSE;
				}
			break;
  
			case ADSTYPE_LARGE_INTEGER :
				pNewAttrInfo->pADsValues[itr].LargeInteger = pOldAttrInfo->pADsValues[itr].LargeInteger;
				break;
  
			case ADSTYPE_UTC_TIME :
				pNewAttrInfo->pADsValues[itr].UTCTime = pOldAttrInfo->pADsValues[itr].UTCTime;
				break;

			default :
				break;
		}
	}
	return TRUE;
}

void CADSIAttr::_FreeADsValues(ADSVALUE** ppADsValues, DWORD dwLength)
{
	ADSVALUE* pADsValue = *ppADsValues;

	for (int idx = 0; idx < dwLength; idx++)
	{
		if (pADsValue != NULL)
		{
			switch( pADsValue->dwType ) 
			{
				case ADSTYPE_DN_STRING :
					_FreeString(&pADsValue->DNString);
					break;

				case ADSTYPE_CASE_EXACT_STRING :
					_FreeString(&pADsValue->CaseExactString);
					break;

				case ADSTYPE_CASE_IGNORE_STRING :
					_FreeString(&pADsValue->CaseIgnoreString);
					break;

				case ADSTYPE_PRINTABLE_STRING :
					_FreeString(&pADsValue->PrintableString);
					break;

				case ADSTYPE_NUMERIC_STRING :
					_FreeString(&pADsValue->NumericString);
					break;
  
				case ADSTYPE_OBJECT_CLASS :
					_FreeString(&pADsValue->ClassName);
					break;
  
				case ADSTYPE_OCTET_STRING :
					_FreeOctetString(pADsValue->OctetString.lpValue);
					break;
  
				default :
					break;
			}
			pADsValue++;
		}
	}
	// May be NULL if there are no values set
	// WARNING! : make sure that you memset the memory after
	// creating an ADS_ATTR_INFO so that it will be NULL if there
	// are no values
	//
	if (*ppADsValues != NULL)
	{
		delete *ppADsValues;
		*ppADsValues = NULL;
	}
}


// The values are not copied here.  They must be copied after the ADS_ATTR_INFO
// is copied by using _CopyADsValues()
//
BOOL CADSIAttr::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO** ppNewAttrInfo)
{
	_FreeADsAttrInfo(ppNewAttrInfo, FALSE);

	*ppNewAttrInfo = new ADS_ATTR_INFO;
	if (*ppNewAttrInfo == NULL)
	{
		return FALSE;
	}
	memset(*ppNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

	BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &((*ppNewAttrInfo)->pszAttrName));
	if (!bReturn)
	{
		_FreeADsAttrInfo(ppNewAttrInfo, FALSE);
		return FALSE;
	}

	(*ppNewAttrInfo)->dwADsType = pAttrInfo->dwADsType;
	(*ppNewAttrInfo)->dwControlCode = pAttrInfo->dwControlCode;
	(*ppNewAttrInfo)->dwNumValues = pAttrInfo->dwNumValues;

	return TRUE;
}

BOOL CADSIAttr::_CopyADsAttrInfo(ADS_ATTR_INFO* pAttrInfo, ADS_ATTR_INFO* pNewAttrInfo)
{
	memset(pNewAttrInfo, 0, sizeof(ADS_ATTR_INFO));

	BOOL bReturn = _AllocString(pAttrInfo->pszAttrName, &pNewAttrInfo->pszAttrName);
	if (!bReturn)
	{
		return FALSE;
	}

	pNewAttrInfo->dwADsType = pAttrInfo->dwADsType;
	pNewAttrInfo->dwControlCode = pAttrInfo->dwControlCode;
	pNewAttrInfo->dwNumValues = pAttrInfo->dwNumValues;

	return TRUE;
}

void CADSIAttr::_FreeADsAttrInfo(ADS_ATTR_INFO** ppAttrInfo, BOOL bReadOnly)
{
	if (*ppAttrInfo == NULL)
	{
		return;
	}

	if (!bReadOnly)
	{
		_FreeString(&(*ppAttrInfo)->pszAttrName);
		_FreeADsValues(&(*ppAttrInfo)->pADsValues, (*ppAttrInfo)->dwNumValues);
		delete *ppAttrInfo;
	}
	else
	{
		FreeADsMem(*ppAttrInfo);
	}
	*ppAttrInfo = NULL;
}

void CADSIAttr::_FreeADsAttrInfo(ADS_ATTR_INFO* pAttrInfo)
{
	if (pAttrInfo == NULL)
	{
		return;
	}

	_FreeString(&pAttrInfo->pszAttrName);
	_FreeADsValues(&pAttrInfo->pADsValues, pAttrInfo->dwNumValues);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attrqry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "attrqry.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

	///////////////////////////////////////////////////////////////////////////////
CADSIQueryObject2::CADSIQueryObject2()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}

CADSIQueryObject2::~CADSIQueryObject2()
{
  if (m_SearchHandle) 
  {
    m_pObj->CloseSearchHandle (m_SearchHandle);
  }
  if (aSearchPref != NULL)
  {
    delete aSearchPref;
    aSearchPref = NULL;
  }
}


HRESULT CADSIQueryObject2::Init(IDirectorySearch * pObj)
{
  HRESULT hr = S_OK;
  
  m_pObj = pObj;
  m_bInitialized = TRUE;
  
  return hr;
}

HRESULT CADSIQueryObject2::SetAttributeList (LPTSTR *pszAttribs, INT cAttrs)
{

  m_pszAttribs = pszAttribs;
  m_nAttrs = cAttrs;
  return S_OK;
}

const int nSearchPrefs = 4;
HRESULT CADSIQueryObject2::SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount)
{
  HRESULT hr;
	int nNumPrefs = nSearchPrefs;
	if (nMaxObjectCount == 0)
	{
		nNumPrefs--;
	}
  aSearchPref = new ADS_SEARCHPREF_INFO[nNumPrefs];

  if (m_bInitialized) 
	{
    aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[0].vValue.Integer = scope;
    aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    aSearchPref[1].vValue.dwType = ADSTYPE_BOOLEAN;
    aSearchPref[1].vValue.Boolean = TRUE;
    aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    aSearchPref[2].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[2].vValue.Integer = QUERY_PAGESIZE;
		
		if (nMaxObjectCount > 0)
		{
			aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
			aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
			aSearchPref[3].vValue.Integer = nMaxObjectCount;
		}
		hr = m_pObj->SetSearchPreference (aSearchPref, nNumPrefs);
    delete aSearchPref;
    aSearchPref = NULL;
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}


const int NUM_PREFS=3;
HRESULT CADSIQueryObject2::DoQuery()
{
  HRESULT hr;
  if (m_bInitialized) 
	{
     hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                 m_pszAttribs,
                                 m_nAttrs,
                                 &m_SearchHandle);
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}

HRESULT CADSIQueryObject2::GetNextRow()
{
  if (m_bInitialized) 
	{
    return m_pObj->GetNextRow (m_SearchHandle);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT CADSIQueryObject2::GetColumn(LPWSTR Attribute, PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) 
	{
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attrqry.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

#ifndef _ADSIQUERY_H
#define _ADSIQUERY_H

#define QUERY_PAGESIZE 256

class CConnectionData;
class CCredentialObject;

////////////////////////////////////////////////////////////////////////
// CADSIQueryObject2

class CADSIQueryObject2
{
public:
  CADSIQueryObject2();
  ~CADSIQueryObject2();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
	{
    return m_pObj->FreeColumn(pColumnData);
  };

  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);
  HRESULT SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount = 0);
  HRESULT SetFilterString (LPWSTR pszFilter)
	{
    m_pwszFilter = pszFilter;
    return S_OK;
  }

  //Attributes
public:
  CComPtr<IDirectorySearch> m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR            m_pwszFilter;
  LPWSTR          * m_pszAttribs;
  ULONG             m_nAttrs;
  BOOL							m_bInitialized;

	ADS_SEARCHPREF_INFO* aSearchPref;
};
        
#endif //_ADSIQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\attrres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by attredit.rc
//
#define IDC_EDIT_BUTTON                 1072
#define IDS_PROJNAME                    5000
#define IDD_ATTRIBUTE_EDITOR_DIALOG     5001
#define IDS_NOTSET                      5001
#define IDC_MANDATORY_CHECK             5002
#define IDD_STRING_EDITOR_DIALOG        5002
#define IDS_NO_EDITOR                   5002
#define IDC_OPTIONAL_CHECK              5003
#define IDD_STRING_EDITOR_MULTI_DIALOG  5003
#define IDS_NO_ATTRIBUTE_INFO           5003
#define IDC_SET_CHECK                   5004
#define IDC_ATTRIBUTE_LIST              5006
#define IDC_VALUE_EDIT                  5008
#define IDC_VALUE_LIST                  5010
#define IDC_CLEAR_BUTTON                5014
#define IDD_INT_EDITOR_DIALOG           5020
#define IDD_LARGEINT_EDITOR_DIALOG      5021
#define IDD_BOOLEAN_EDITOR_DIALOG       5022
#define IDD_TIME_EDITOR_DIALOG          5023
#define IDD_OCTET_STRING_EDITOR_DIALOG  5024
#define IDS_ATTR_COL_SYNTAX             5025
#define IDC_ATTRIBUTE_STATIC            6000
#define IDS_ATTR_COL_ATTRIBUTE          6000
#define IDS_ATTR_COL_SETNOTSET          6001
#define IDC_TRUE_RADIO                  6002
#define IDS_ATTR_COL_VALUE              6002
#define IDC_FALSE_RADIO                 6003
#define IDS_ATTR_SET                    6003
#define IDC_NOTSET_RADIO                6004
#define IDS_ATTR_NOTSET                 6004
#define IDC_DATE_PICKER                 6005
#define IDC_TIME_PICKER                 6006
#define IDC_EDIT2                       6008
#define IDC_VIEW_TYPE_COMBO             6010
#define IDS_HEXADECIMAL                 6050
#define IDS_DECIMAL                     6051
#define IDS_BINARY                      6052
#define IDS_WCHAR                       6053
#define IDS_CHAR                        6054
#define IDS_OCTAL                       6055
#define IDS_FAILED_INITIALIZE_EDITOR    6070
#define IDS_FAILED_GET_NEW_VALUE_EDITOR 6071

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5026
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         6013
#define _APS_NEXT_SYMED_VALUE           7000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\common.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       common.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "common.h"
#include "editor.h"
#include "connection.h"
#include "credui.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_lpszRootDSE;

////////////////////////////////////////////////////////////////////////////////////////


HRESULT OpenObjectWithCredentials(
																	CConnectionData* pConnectData,
																	const BOOL bUseCredentials,
																	LPCWSTR lpszPath, 
																	const IID& iid,
																	LPVOID* ppObject,
																	HWND hWnd,
																	HRESULT& hResult
																	)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;
	hResult = S_OK;

  CWaitCursor cursor;
	CWnd* pCWnd = CWnd::FromHandle(hWnd);

	CCredentialObject* pCredObject = pConnectData->GetCredentialObject();

	if (bUseCredentials)
	{

		CString sUserName;
		UINT uiDialogResult = IDOK;
		WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];

		while (uiDialogResult != IDCANCEL)
		{
			pCredObject->GetUsername(sUserName);
			pCredObject->GetPassword(szPassword);

			hr = ADsOpenObject((LPWSTR)lpszPath, 
												(LPWSTR)(LPCWSTR)sUserName, 
												szPassword, 
												ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
												iid, 
												ppObject
												);

			ZeroMemory(szPassword, sizeof(WCHAR[MAX_PASSWORD_LENGTH + 1]));

			// If logon fails pop up the credentials dialog box
			//
			if (HRESULT_CODE(hr) == ERROR_LOGON_FAILURE ||
             HRESULT_CODE(hr) == ERROR_NOT_AUTHENTICATED ||
             HRESULT_CODE(hr) == ERROR_INVALID_PASSWORD ||
             HRESULT_CODE(hr) == ERROR_PASSWORD_EXPIRED ||
             HRESULT_CODE(hr) == ERROR_ACCOUNT_DISABLED ||
             HRESULT_CODE(hr) == ERROR_ACCOUNT_LOCKED_OUT ||
             hr == E_ADS_BAD_PATHNAME)
			{
				CString sConnectName;

				// GetConnectionNode() is NULL when the connection is first being
				// create, but since it is the connection node we can get the name
				// directly from the CConnectionData.
				//
				ASSERT(pConnectData != NULL);
				if (pConnectData->GetConnectionNode() == NULL)
				{
					pConnectData->GetName(sConnectName);
				}
				else
				{
					sConnectName = pConnectData->GetConnectionNode()->GetDisplayName();
				}

				CCredentialDialog credDialog(pCredObject, sConnectName, pCWnd);
				uiDialogResult = credDialog.DoModal();
        cursor.Restore();
				if (uiDialogResult == IDCANCEL)
				{
					hResult = E_FAIL;
				}
				else
				{
					hResult = S_OK;
				}
			}
			else
			{
				break;
			}
		}
	}
	else
	{
		hr = ADsOpenObject((LPWSTR)lpszPath, NULL, NULL, 
											 ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, iid, ppObject);
	}
	return hr;
}

HRESULT OpenObjectWithCredentials(
																	CCredentialObject* pCredObject,
																	LPCWSTR lpszPath, 
																	const IID& iid,
																	LPVOID* ppObject
																	)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr;

	if (pCredObject->UseCredentials())
	{

		CString sUserName;
		UINT uiDialogResult = IDOK;
		WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];

		pCredObject->GetUsername(sUserName);
		pCredObject->GetPassword(szPassword);

		hr = ADsOpenObject((LPWSTR)lpszPath, 
											(LPWSTR)(LPCWSTR)sUserName, 
											szPassword, 
											ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
											iid, 
											ppObject
											);

		ZeroMemory(szPassword, sizeof(WCHAR[MAX_PASSWORD_LENGTH + 1]));

	}
	else
	{
		hr = ADsOpenObject((LPWSTR)lpszPath, NULL, NULL, 
											 ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, iid, ppObject);
	}
	return hr;
}

HRESULT CALLBACK BindingCallbackFunction(LPCWSTR lpszPathName,
                                         DWORD  dwReserved,
                                         REFIID riid,
                                         void FAR * FAR * ppObject,
                                         LPARAM lParam)
{
  CCredentialObject* pCredObject = reinterpret_cast<CCredentialObject*>(lParam);
  if (pCredObject == NULL)
  {
    return E_FAIL;
  }

  HRESULT hr = OpenObjectWithCredentials(pCredObject,
																	       lpszPathName, 
																	       riid,
																	       ppObject);
  return hr;
}

HRESULT GetRootDSEObject(CConnectionData* pConnectData,
                         IADs** ppDirObject)
{
	// Get data from connection node
	//
	CString sRootDSE, sServer, sPort, sLDAP;
	pConnectData->GetDomainServer(sServer);
	pConnectData->GetLDAP(sLDAP);
	pConnectData->GetPort(sPort);

	if (sServer != _T(""))
	{
		sRootDSE = sLDAP + sServer;
		if (sPort != _T(""))
		{
			sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
		}
		else
		{
			sRootDSE = sRootDSE + _T("/");
		}
		sRootDSE = sRootDSE + g_lpszRootDSE;
	}
	else
	{
		sRootDSE = sLDAP + g_lpszRootDSE;
	}

	HRESULT hr, hCredResult;
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sRootDSE,
											 IID_IADs, 
											 (LPVOID*) ppDirObject,
											 NULL,
											 hCredResult
											);

	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return hr;
	}
  return hr;
}

HRESULT GetItemFromRootDSE(LPCWSTR lpszRootDSEItem, 
			  				           CString& sItem, 
								           CConnectionData* pConnectData)
{
	// Get data from connection node
	//
	CString sRootDSE, sServer, sPort, sLDAP;
	pConnectData->GetDomainServer(sServer);
	pConnectData->GetLDAP(sLDAP);
	pConnectData->GetPort(sPort);

	if (sServer != _T(""))
	{
		sRootDSE = sLDAP + sServer;
		if (sPort != _T(""))
		{
			sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
		}
		else
		{
			sRootDSE = sRootDSE + _T("/");
		}
		sRootDSE = sRootDSE + g_lpszRootDSE;
	}
	else
	{
		sRootDSE = sLDAP + g_lpszRootDSE;
	}

	CComPtr<IADs> pADs;
	HRESULT hr, hCredResult;

	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sRootDSE,
											 IID_IADs, 
											 (LPVOID*) &pADs,
											 NULL,
											 hCredResult
											);

	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return hr;
	}
	VARIANT var;
	VariantInit(&var);
	hr = pADs->Get( (LPWSTR)lpszRootDSEItem, &var );
	if ( FAILED(hr) )
	{
		VariantClear(&var);
		return hr;
	}

	BSTR bstrItem = V_BSTR(&var);
	sItem = bstrItem;
	VariantClear(&var);

	return S_OK;
}


HRESULT  VariantToStringList(  VARIANT& refvar, CStringList& refstringlist)
{
    HRESULT hr = S_OK;
    long start, end;

  if ( !(V_VT(&refvar) &  VT_ARRAY)  )
    {
                
		if ( V_VT(&refvar) != VT_BSTR )
		{
			
			hr = VariantChangeType( &refvar, &refvar,0, VT_BSTR );

			if( FAILED(hr) )
			{
				return hr;
			}

		}

		refstringlist.AddHead( V_BSTR(&refvar) );
        return hr;
    }

    SAFEARRAY *saAttributes = V_ARRAY( &refvar );

    //
    // Figure out the dimensions of the array.
    //

    hr = SafeArrayGetLBound( saAttributes, 1, &start );
        if( FAILED(hr) )
                return hr;

    hr = SafeArrayGetUBound( saAttributes, 1, &end );
        if( FAILED(hr) )
                return hr;

    VARIANT SingleResult;
    VariantInit( &SingleResult );

    //
    // Process the array elements.
    //

    for ( long idx = start; idx <= end; idx++   ) 
	{

        hr = SafeArrayGetElement( saAttributes, &idx, &SingleResult );
        if( FAILED(hr) )
		{
            return hr;
		}

		if ( V_VT(&SingleResult) != VT_BSTR )
		{
			if ( V_VT(&SingleResult) == VT_NULL )
			{
				V_VT(&SingleResult ) = VT_BSTR;
				V_BSTR(&SingleResult ) = SysAllocString(L"0");
			}
			else
			{
				hr = VariantChangeType( &SingleResult, &SingleResult,0, VT_BSTR );

				if( FAILED(hr) )
				{
					return hr;
				}
			}
		}


        //if ( V_VT(&SingleResult) != VT_BSTR )
         //               return E_UNEXPECTED;

         refstringlist.AddHead( V_BSTR(&SingleResult) );
        VariantClear( &SingleResult );
    }

    return S_OK;
} // VariantToStringList()

/////////////////////////////////////////////////////////////////////
HRESULT StringListToVariant( VARIANT& refvar, const CStringList& refstringlist)
{
    HRESULT hr = S_OK;
    int cCount = refstringlist.GetCount();

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cCount;

    SAFEARRAY* psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (NULL == psa)
        return E_OUTOFMEMORY;

    VariantClear( &refvar );
    V_VT(&refvar) = VT_VARIANT|VT_ARRAY;
    V_ARRAY(&refvar) = psa;

    VARIANT SingleResult;
    VariantInit( &SingleResult );
    V_VT(&SingleResult) = VT_BSTR;
    POSITION pos = refstringlist.GetHeadPosition();
    long i;
    for (i = 0; i < cCount, pos != NULL; i++)
    {
        V_BSTR(&SingleResult) = T2BSTR((LPCTSTR)refstringlist.GetNext(pos));
        hr = SafeArrayPutElement(psa, &i, &SingleResult);
        if( FAILED(hr) )
            return hr;
    }
    if (i != cCount || pos != NULL)
        return E_UNEXPECTED;

    return hr;
} // StringListToVariant()

///////////////////////////////////////////////////////////////////////////////////////

BOOL GetErrorMessage(HRESULT hr, CString& szErrorString, BOOL bTryADsIErrors)
{
  HRESULT hrGetLast = S_OK;
  DWORD status;
  PTSTR ptzSysMsg = NULL;

  // first check if we have extended ADs errors
  if ((hr != S_OK) && bTryADsIErrors) 
  {
    WCHAR Buf1[256], Buf2[256];
    hrGetLast = ::ADsGetLastError(&status, Buf1, 256, Buf2, 256);
    TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
          status, Buf1, Buf2);
    if ((status != ERROR_INVALID_DATA) && (status != 0)) 
    {
      hr = status;
    }
  }

  // try the system first
  int nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)&ptzSysMsg, 0, NULL);

  if (nChars == 0) 
  { 
    //try ads errors
    static HMODULE g_adsMod = 0;
    if (0 == g_adsMod)
      g_adsMod = GetModuleHandle (L"activeds.dll");
    nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE, g_adsMod, hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)&ptzSysMsg, 0, NULL);
  }

  if (nChars > 0)
  {
    szErrorString = ptzSysMsg;
    ::LocalFree(ptzSysMsg);
  }
	else
	{
		szErrorString.Format(L"Error code: X%x", hr);
	}

  return (nChars > 0);
}

////////////////////////////////////////////////////////////////////////////////////
typedef struct tagSYNTAXMAP
{
	LPCWSTR		lpszAttr;
	VARTYPE		type;
	
} SYNTAXMAP;

SYNTAXMAP ldapSyntax[] = 
{
	_T("DN"), VT_BSTR,
	_T("DIRECTORYSTRING"), VT_BSTR,
	_T("IA5STRING"), VT_BSTR,
	_T("CASEIGNORESTRING"), VT_BSTR,
	_T("PRINTABLESTRING"), VT_BSTR,
	_T("NUMERICSTRING"), VT_BSTR,
	_T("UTCTIME"), VT_DATE,
	_T("ORNAME"), VT_BSTR,
	_T("OCTETSTRING"), VT_BSTR,
	_T("BOOLEAN"), VT_BOOL,
	_T("INTEGER"), VT_I4,
	_T("OID"), VT_BSTR,
	_T("INTEGER8"), VT_I8,
	_T("OBJECTSECURITYDESCRIPTOR"), VT_BSTR,
	NULL,	  0,
};
#define MAX_ATTR_STRING_LENGTH 30

VARTYPE VariantTypeFromSyntax(LPCWSTR lpszProp )
{
	int idx=0;

	while( ldapSyntax[idx].lpszAttr )
	{
		if ( _wcsnicmp(lpszProp, ldapSyntax[idx].lpszAttr, MAX_ATTR_STRING_LENGTH) )
		{
			return ldapSyntax[idx].type;
		}
		idx++;
	}
	ASSERT(FALSE);
	return VT_BSTR;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function : GetStringFromADsValue
//
//  Formats an ADSVALUE struct into a string 
//
///////////////////////////////////////////////////////////////////////////////////////////////////
void GetStringFromADsValue(const PADSVALUE pADsValue, CString& szValue, DWORD dwMaxCharCount)
{
  szValue.Empty();

  if (!pADsValue)
  {
    ASSERT(pADsValue);
    return;
  }

  CString sTemp;
	switch( pADsValue->dwType ) 
	{
		case ADSTYPE_DN_STRING         :
			sTemp.Format(L"%s", pADsValue->DNString);
			break;

		case ADSTYPE_CASE_EXACT_STRING :
			sTemp.Format(L"%s", pADsValue->CaseExactString);
			break;

		case ADSTYPE_CASE_IGNORE_STRING:
			sTemp.Format(L"%s", pADsValue->CaseIgnoreString);
			break;

		case ADSTYPE_PRINTABLE_STRING  :
			sTemp.Format(L"%s", pADsValue->PrintableString);
			break;

		case ADSTYPE_NUMERIC_STRING    :
			sTemp.Format(L"%s", pADsValue->NumericString);
			break;
  
		case ADSTYPE_OBJECT_CLASS    :
			sTemp.Format(L"%s", pADsValue->ClassName);
			break;
  
		case ADSTYPE_BOOLEAN :
			sTemp.Format(L"%s", ((DWORD)pADsValue->Boolean) ? L"TRUE" : L"FALSE");
			break;
  
		case ADSTYPE_INTEGER           :
			sTemp.Format(L"%d", (DWORD) pADsValue->Integer);
			break;
  
		case ADSTYPE_OCTET_STRING      :
			{
				CString sOctet;
		
				BYTE  b;
				for ( DWORD idx=0; idx<pADsValue->OctetString.dwLength; idx++) 
				{
					b = ((BYTE *)pADsValue->OctetString.lpValue)[idx];
					sOctet.Format(L"0x%02x ", b);
					sTemp += sOctet;

          if (dwMaxCharCount != 0 && sTemp.GetLength() > dwMaxCharCount)
          {
            break;
          }
				}
			}
			break;
  
		case ADSTYPE_LARGE_INTEGER :
			litow(pADsValue->LargeInteger, sTemp);
			break;
  
		case ADSTYPE_UTC_TIME          :
			sTemp.Format(L"%02d/%02d/%04d %02d:%02d:%02d", 
                   pADsValue->UTCTime.wMonth, 
                   pADsValue->UTCTime.wDay, 
                   pADsValue->UTCTime.wYear,
				           pADsValue->UTCTime.wHour, 
                   pADsValue->UTCTime.wMinute, 
                   pADsValue->UTCTime.wSecond);
			break;

		case ADSTYPE_NT_SECURITY_DESCRIPTOR: // I use the ACLEditor instead
			{
   		}
			break;

		default :
			break;
	}

  szValue = sTemp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function : GetStringFromADs
//
//  Formats an ADS_ATTR_INFO structs values into strings and APPENDS them to a CStringList that is
//  passed in as a parameter.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
void GetStringFromADs(const ADS_ATTR_INFO* pInfo, CStringList& sList, DWORD dwMaxCharCount)
{
	CString sTemp;

	if ( pInfo == NULL )
	{
		return;
	}

	ADSVALUE *pValues = pInfo->pADsValues;

	for (DWORD x=0; x < pInfo->dwNumValues; x++) 
	{
    if ( pInfo->dwADsType == ADSTYPE_INVALID )
		{
			continue;
		}

		sTemp.Empty();

    GetStringFromADsValue(pValues, sTemp, dwMaxCharCount);
			
		pValues++;
		sList.AddTail( sTemp );
	}
}


//////////////////////////////////////////////////////////////////////
typedef struct tagSYNTAXTOADSMAP
{
	LPCWSTR		lpszAttr;
	ADSTYPE		type;
   UINT        nSyntaxResID;
	
} SYNTAXTOADSMAP;

SYNTAXTOADSMAP adsType[] = 
{
	L"2.5.5.0",		ADSTYPE_INVALID,                 IDS_SYNTAX_UNKNOWN,                
	L"2.5.5.1",		ADSTYPE_DN_STRING,               IDS_SYNTAX_DN,         
	L"2.5.5.2",		ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_OID,                          
	L"2.5.5.3", 	ADSTYPE_CASE_EXACT_STRING,       IDS_SYNTAX_NOCASE_STR,                   
	L"2.5.5.4",		ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_PRCS_STR,                     
	L"2.5.5.5",		ADSTYPE_PRINTABLE_STRING,        IDS_SYNTAX_I5_STR,                        
	L"2.5.5.6",		ADSTYPE_NUMERIC_STRING,          IDS_SYNTAX_NUMSTR,                              
	L"2.5.5.7",		ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_DN_BINARY,                         
	L"2.5.5.8",		ADSTYPE_BOOLEAN,                 IDS_SYNTAX_BOOLEAN,                            
	L"2.5.5.9",		ADSTYPE_INTEGER,                 IDS_SYNTAX_INTEGER,                         
	L"2.5.5.10",	ADSTYPE_OCTET_STRING,            IDS_SYNTAX_OCTET,                        
	L"2.5.5.11",	ADSTYPE_UTC_TIME,                IDS_SYNTAX_UTC,                      
	L"2.5.5.12",	ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_UNICODE,                                
	L"2.5.5.13",	ADSTYPE_CASE_IGNORE_STRING,      IDS_SYNTAX_ADDRESS,                             
	L"2.5.5.14",	ADSTYPE_INVALID,                 IDS_SYNTAX_DNSTRING,                                         
	L"2.5.5.15",	ADSTYPE_NT_SECURITY_DESCRIPTOR,  IDS_SYNTAX_SEC_DESC,                                  
	L"2.5.5.16",	ADSTYPE_LARGE_INTEGER,           IDS_SYNTAX_LINT,                                
	L"2.5.5.17",	ADSTYPE_OCTET_STRING,            IDS_SYNTAX_SID,                            
	NULL,					ADSTYPE_INVALID,              IDS_SYNTAX_UNKNOWN                           
};   

ADSTYPE GetADsTypeFromString(LPCWSTR lps, CString& szSyntaxName)
{
	int idx=0;
	
	while( adsType[idx].lpszAttr )
	{
		if ( wcscmp(lps, adsType[idx].lpszAttr) == 0 )
		{
         szSyntaxName.LoadString(adsType[idx].nSyntaxResID);
			return adsType[idx].type;
		}
		idx++;
	}
	return ADSTYPE_INVALID;
}

////////////////////////////////////////////////////////////////
// Type conversions for LARGE_INTEGERs

void wtoli(LPCWSTR p, LARGE_INTEGER& liOut)
{
	liOut.QuadPart = 0;
	BOOL bNeg = FALSE;
	if (*p == L'-')
	{
		bNeg = TRUE;
		p++;
	}
	while (*p != L'\0')
	{
		liOut.QuadPart = 10 * liOut.QuadPart + (*p-L'0');
		p++;
	}
	if (bNeg)
	{
		liOut.QuadPart *= -1;
	}
}

void litow(LARGE_INTEGER& li, CString& sResult)
{
	LARGE_INTEGER n;
	n.QuadPart = li.QuadPart;

	if (n.QuadPart == 0)
	{
		sResult = L"0";
	}
	else
	{
		CString sNeg;
		sResult = L"";
		if (n.QuadPart < 0)
		{
			sNeg = CString(L'-');
			n.QuadPart *= -1;
		}
		while (n.QuadPart > 0)
		{
			sResult += CString(L'0' + (n.QuadPart % 10));
			n.QuadPart = n.QuadPart / 10;
		}
		sResult = sResult + sNeg;
	}
	sResult.MakeReverse();
}

void ultow(ULONG ul, CString& sResult)
{
	ULONG n;
	n = ul;

	if (n == 0)
	{
		sResult = L"0";
	}
	else
	{
		sResult = L"";
		while (n > 0)
		{
			sResult += CString(L'0' + (n % 10));
			n = n / 10;
		}
	}
	sResult.MakeReverse();
}

//+----------------------------------------------------------------------------
//
//  Function:   UnicodeToTchar
//
//  Synopsis:   Converts a Unicode string to a TCHAR string. Allocates memory
//              for the returned string using new. Callers must free the
//              string memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL UnicodeToChar(LPWSTR pwszIn, LPSTR * ppszOut)
{
  size_t len;

  len = WideCharToMultiByte(CP_ACP, 0, pwszIn, -1, NULL, 0, NULL, NULL);
  
  *ppszOut = new CHAR[len + 1];
  if (*ppszOut == NULL)
  {
    return FALSE;
  }

  if (WideCharToMultiByte(CP_ACP, 0, pwszIn, -1,
                          *ppszOut, len, NULL, NULL) == 0)
  {
    delete[] *ppszOut;
    return FALSE;
  }
  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   TcharToUnicode
//
//  Synopsis:   Converts a TCHAR string to a Unicode string. Allocates memory
//              for the returned string using new. Callers must free the
//              string memory when done using delete.
//
//  Returns:    FALSE for out of memory failures.
//
//-----------------------------------------------------------------------------
BOOL CharToUnicode(LPSTR pszIn, LPWSTR * ppwszOut)
{
  size_t len;

  len = MultiByteToWideChar(CP_ACP, 0, pszIn, -1, NULL, 0);
  
  *ppwszOut = new WCHAR[len + 1];
  if (*ppwszOut == NULL)
  {
    return FALSE;
  }

  if (MultiByteToWideChar(CP_ACP, 0, pszIn, -1, *ppwszOut, len) == 0)
  {
    delete[] *ppwszOut;
    return FALSE;
  }
  return TRUE;
}


/////////////////////////////////////////////////////////////////////
// IO to/from Streams

void SaveStringToStream(IStream* pStm, const CString& sString)
{
	ULONG cbWrite;
	ULONG nLen;

	nLen = wcslen(sString)+1; // WCHAR including NULL
	VERIFY(SUCCEEDED(pStm->Write((void*)&nLen, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));
	VERIFY(SUCCEEDED(pStm->Write((void*)((LPCWSTR)sString), sizeof(WCHAR)*nLen,&cbWrite)));
	ASSERT(cbWrite == sizeof(WCHAR)*nLen);
}

HRESULT SaveStringListToStream(IStream* pStm, CStringList& sList)
{
	// for each string in the list, write # of chars+NULL, and then the string
	ULONG cbWrite;
	ULONG nLen;
	UINT nCount;

	// write # of strings in list 
	nCount = (UINT)sList.GetCount();
	VERIFY(SUCCEEDED(pStm->Write((void*)&nCount, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));

	POSITION pos = sList.GetHeadPosition();
	while (pos != NULL)
	{
		CString s = sList.GetNext(pos);
		SaveStringToStream(pStm, s);
	}
	return S_OK;
}

void LoadStringFromStream(IStream* pStm, CString& sString)
{
	WCHAR szBuffer[256]; // REVIEW_MARCOC: hardcoded
	ULONG nLen; // WCHAR counting NULL
	ULONG cbRead;

	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	VERIFY(SUCCEEDED(pStm->Read((void*)szBuffer,sizeof(WCHAR)*nLen, &cbRead)));
	ASSERT(cbRead == sizeof(WCHAR)*nLen);
	sString = szBuffer;
}

HRESULT LoadStringListFromStream(IStream* pStm, CStringList& sList)
{
	ULONG cbRead;
	ULONG nCount;

	VERIFY(SUCCEEDED(pStm->Read((void*)&nCount,sizeof(ULONG), &cbRead)));
	ASSERT(cbRead == sizeof(ULONG));

	for (int k=0; k< (int)nCount; k++)
	{
		CString sString;
		LoadStringFromStream(pStm, sString);
		sList.AddTail(sString);
	}
	if (sList.GetCount() == nCount)
	{
		return S_OK;
	}
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////
/////////////////////// Message Boxes ///////////////////////////////
/////////////////////////////////////////////////////////////////////

int ADSIEditMessageBox(LPCTSTR lpszText, UINT nType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return ::AfxMessageBox(lpszText, nType);
}

int ADSIEditMessageBox(UINT nIDPrompt, UINT nType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return ::AfxMessageBox(nIDPrompt, nType);
}

void ADSIEditErrorMessage(PCWSTR pszMessage)
{
  ADSIEditMessageBox(pszMessage, MB_OK);
}

void ADSIEditErrorMessage(HRESULT hr)
{
	CString s;
	GetErrorMessage(hr, s);
	ADSIEditMessageBox(s, MB_OK);
}

void ADSIEditErrorMessage(HRESULT hr, UINT nIDPrompt, UINT nType)
{
  CString s;
  GetErrorMessage(hr, s);

  CString szMessage;
  szMessage.Format(nIDPrompt, s);

  ADSIEditMessageBox(szMessage, MB_OK);
}

/////////////////////////////////////////////////////////////////////

BOOL LoadStringsToComboBox(HINSTANCE hInstance, CComboBox* pCombo,
						                UINT nStringID, UINT nMaxLen, UINT nMaxAddCount)
{
	pCombo->ResetContent();
	ASSERT(hInstance != NULL);
	WCHAR* szBuf = (WCHAR*)malloc(sizeof(WCHAR)*nMaxLen);
  if (!szBuf)
  {
    return FALSE;
  }

	if ( ::LoadString(hInstance, nStringID, szBuf, nMaxLen) == 0)
  {
    free(szBuf);
		return FALSE;
  }

	LPWSTR* lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*nMaxLen);
  if (lpszArr)
  {
	  int nArrEntries = 0;
	  ParseNewLineSeparatedString(szBuf,lpszArr, &nArrEntries);
	  
	  if (nMaxAddCount < nArrEntries) nArrEntries = nMaxAddCount;
	  for (int k=0; k<nArrEntries; k++)
		  pCombo->AddString(lpszArr[k]);
  }

  if (szBuf)
  {
    free(szBuf);
  }
  if (lpszArr)
  {
    free(lpszArr);
  }
	return TRUE;
}

void ParseNewLineSeparatedString(LPWSTR lpsz, 
								 LPWSTR* lpszArr, 
								 int* pnArrEntries)
{
	static WCHAR lpszSep[] = L"\n";
	*pnArrEntries = 0;
	int k = 0;
	lpszArr[k] = wcstok(lpsz, lpszSep);
	if (lpszArr[k] == NULL)
		return;

	while (TRUE)
	{
		WCHAR* lpszToken = wcstok(NULL, lpszSep);
		if (lpszToken != NULL)
			lpszArr[++k] = lpszToken;
		else
			break;
	}
	*pnArrEntries = k+1;
}

void LoadStringArrayFromResource(LPWSTR* lpszArr,
											UINT* nStringIDs,
											int nArrEntries,
											int* pnSuccessEntries)
{
	CString szTemp;
	
	*pnSuccessEntries = 0;
	for (int k = 0;k < nArrEntries; k++)
	{
		if (!szTemp.LoadString(nStringIDs[k]))
		{
			lpszArr[k] = NULL;
			continue;
		}
		
		int iLength = szTemp.GetLength() + 1;
		lpszArr[k] = (LPWSTR)malloc(sizeof(WCHAR)*iLength);
		if (lpszArr[k] != NULL)
		{
			wcscpy(lpszArr[k], (LPWSTR)(LPCWSTR)szTemp);
			(*pnSuccessEntries)++;
		}
	}
}

///////////////////////////////////////////////////////////////

void GetStringArrayFromStringList(CStringList& sList, LPWSTR** ppStrArr, UINT* nCount)
{
  *nCount = sList.GetCount();

  *ppStrArr = new LPWSTR[*nCount];

  UINT idx = 0;
  POSITION pos = sList.GetHeadPosition();
  while (pos != NULL)
  {
    CString szString = sList.GetNext(pos);
    (*ppStrArr)[idx] = new WCHAR[szString.GetLength() + 1];
    ASSERT((*ppStrArr)[idx] != NULL);

    wcscpy((*ppStrArr)[idx], szString);
    idx++;
  }
  *nCount = idx;
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CByteArrayComboBox, CComboBox)
	ON_CONTROL_REFLECT(CBN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()

BOOL CByteArrayComboBox::Initialize(CByteArrayDisplay* pDisplay, 
                                    DWORD dwDisplayFlags)
{
  ASSERT(pDisplay != NULL);
  m_pDisplay = pDisplay;

  //
  // Load the combo box based on the flags given
  //
  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_HEX)
  {
    CString szHex;
    VERIFY(szHex.LoadString(IDS_HEXADECIMAL));
    int idx = AddString(szHex);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_HEX);
    }
  }

  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_OCT)
  {
    CString szOct;
    VERIFY(szOct.LoadString(IDS_OCTAL));
    int idx = AddString(szOct);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_OCT);
    }
  }

  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_DEC)
  {
    CString szDec;
    VERIFY(szDec.LoadString(IDS_DECIMAL));
    int idx = AddString(szDec);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_DEC);
    }
  }

  if (dwDisplayFlags & BYTE_ARRAY_DISPLAY_BIN)
  {
    CString szBin;
    VERIFY(szBin.LoadString(IDS_BINARY));
    int idx = AddString(szBin);
    if (idx != CB_ERR)
    {
      SetItemData(idx, BYTE_ARRAY_DISPLAY_BIN);
    }
  }

  return TRUE;
}

DWORD CByteArrayComboBox::GetCurrentDisplay()
{
  DWORD dwRet = 0;
  int iSel = GetCurSel();
  if (iSel != CB_ERR)
  {
    dwRet = GetItemData(iSel);
  }
  return dwRet;
}
  
void CByteArrayComboBox::SetCurrentDisplay(DWORD dwSel)
{
  int iCount = GetCount();
  for (int idx = 0; idx < iCount; idx++)
  {
    DWORD dwData = GetItemData(idx);
    if (dwData == dwSel)
    {
      SetCurSel(idx);
      return;
    }
  }
}

void CByteArrayComboBox::OnSelChange()
{
  if (m_pDisplay != NULL)
  {
    int iSel = GetCurSel();
    if (iSel != CB_ERR)
    {
      DWORD dwData = GetItemData(iSel);
      m_pDisplay->OnTypeChange(dwData);
    }
  }
}

////////////////////////////////////////////////////////////////

CByteArrayEdit::CByteArrayEdit()
  : m_pData(NULL), 
    m_dwLength(0),
    CEdit()
{
}

CByteArrayEdit::~CByteArrayEdit()
{
}

BEGIN_MESSAGE_MAP(CByteArrayEdit, CEdit)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

BOOL CByteArrayEdit::Initialize(CByteArrayDisplay* pDisplay)
{
  ASSERT(pDisplay != NULL);
  m_pDisplay = pDisplay;

  ConvertToFixedPitchFont(GetSafeHwnd());
  return TRUE;
}

DWORD CByteArrayEdit::GetLength()
{
  return m_dwLength;
}

BYTE* CByteArrayEdit::GetDataPtr()
{
  return m_pData;
}

DWORD CByteArrayEdit::GetDataCopy(BYTE** ppData)
{
  if (m_pData != NULL && m_dwLength > 0)
  {
    *ppData = new BYTE[m_dwLength];
    if (*ppData != NULL)
    {
      memcpy(*ppData, m_pData, m_dwLength);
      return m_dwLength;
    }
  }

  *ppData = NULL;
  return 0;
}

void CByteArrayEdit::SetData(BYTE* pData, DWORD dwLength)
{
  if (m_pData != NULL)
  {
    delete[] m_pData;
    m_pData = NULL;
    m_dwLength = 0;
  }

  if (dwLength > 0 && pData != NULL)
  {
    //
    // Set the new data
    //
    m_pData = new BYTE[dwLength];
    if (m_pData != NULL)
    {
      memcpy(m_pData, pData, dwLength);
      m_dwLength = dwLength;
    }
  }
}

void CByteArrayEdit::OnChangeDisplay()
{
  CString szOldDisplay;
  GetWindowText(szOldDisplay);

  if (!szOldDisplay.IsEmpty())
  {
    BYTE* pByte = NULL;
    DWORD dwLength = 0;
    switch (m_pDisplay->GetPreviousDisplay())
    {
      case BYTE_ARRAY_DISPLAY_HEX :
        dwLength = HexStringToByteArray(szOldDisplay, &pByte);
        break;
     
      case BYTE_ARRAY_DISPLAY_OCT :
        dwLength = OctalStringToByteArray(szOldDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_DEC :
        dwLength = DecimalStringToByteArray(szOldDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_BIN :
        dwLength = BinaryStringToByteArray(szOldDisplay, &pByte);
        break;

      default :
        ASSERT(FALSE);
        break;
    }

    if (pByte != NULL && dwLength != (DWORD)-1)
    {
      SetData(pByte, dwLength);
      delete[] pByte;
      pByte = 0;
    }
  }

  CString szDisplayValue;
  switch (m_pDisplay->GetCurrentDisplay())
  {
    case BYTE_ARRAY_DISPLAY_HEX :
      ByteArrayToHexString(GetDataPtr(), GetLength(), szDisplayValue);
      break;

    case BYTE_ARRAY_DISPLAY_OCT :
      ByteArrayToOctalString(GetDataPtr(), GetLength(), szDisplayValue);
      break;
     
    case BYTE_ARRAY_DISPLAY_DEC :
      ByteArrayToDecimalString(GetDataPtr(), GetLength(), szDisplayValue);
      break;

    case BYTE_ARRAY_DISPLAY_BIN :
      ByteArrayToBinaryString(GetDataPtr(), GetLength(), szDisplayValue);
      break;

    default :
      ASSERT(FALSE);
      break;
  }
  SetWindowText(szDisplayValue);
}

void CByteArrayEdit::OnChange()
{
  if (m_pDisplay != NULL)
  {
    m_pDisplay->OnEditChange();
  }
}

////////////////////////////////////////////////////////////////

BOOL CByteArrayDisplay::Initialize(UINT   nEditCtrl, 
                                   UINT   nComboCtrl, 
                                   DWORD  dwDisplayFlags,
                                   DWORD  dwDefaultDisplay,
                                   CWnd*  pParent,
                                   DWORD  dwMaxSizeLimit,
                                   UINT   nMaxSizeMessageID)
{
  //
  // Initialize the edit control
  //
  VERIFY(m_edit.SubclassDlgItem(nEditCtrl, pParent));
  VERIFY(m_edit.Initialize(this));

  //
  // Initialize the combo box
  //
  VERIFY(m_combo.SubclassDlgItem(nComboCtrl, pParent));
  VERIFY(m_combo.Initialize(this, dwDisplayFlags));

  m_dwMaxSizeBytes = dwMaxSizeLimit;
  m_nMaxSizeMessage = nMaxSizeMessageID;

  //
  // Selects the default display in the combo box and
  // populates the edit field
  //
  SetCurrentDisplay(dwDefaultDisplay);
  m_dwPreviousDisplay = dwDefaultDisplay;
  m_combo.SetCurrentDisplay(dwDefaultDisplay);
  m_edit.OnChangeDisplay();

  return TRUE;
}

void CByteArrayDisplay::OnEditChange()
{
}

void CByteArrayDisplay::OnTypeChange(DWORD dwDisplayType)
{
  SetCurrentDisplay(dwDisplayType);
  m_edit.OnChangeDisplay();
}

void CByteArrayDisplay::ClearData()
{
  m_edit.SetData(NULL, 0);
  m_edit.OnChangeDisplay();
}

void CByteArrayDisplay::SetData(BYTE* pData, DWORD dwLength)
{
  if (dwLength > m_dwMaxSizeBytes)
  {
    //
    // If the data is too large to load into the edit box
    // load the provided message and set the edit box to read only
    //
    CString szMessage;
    VERIFY(szMessage.LoadString(m_nMaxSizeMessage));
    m_edit.SetWindowText(szMessage);
    m_edit.SetReadOnly();

    //
    // Still need to set the data in the edit box even though we are not going to show it
    //
    m_edit.SetData(pData, dwLength);
  }
  else
  {
    m_edit.SetReadOnly(FALSE);
    m_edit.SetData(pData, dwLength);
    m_edit.OnChangeDisplay();
  }
}

DWORD CByteArrayDisplay::GetData(BYTE** ppData)
{
  CString szDisplay;
  m_edit.GetWindowText(szDisplay);

  if (!szDisplay.IsEmpty())
  {
    BYTE* pByte = NULL;
    DWORD dwLength = 0;
    switch (GetCurrentDisplay())
    {
      case BYTE_ARRAY_DISPLAY_HEX :
        dwLength = HexStringToByteArray(szDisplay, &pByte);
        break;
     
      case BYTE_ARRAY_DISPLAY_OCT :
        dwLength = OctalStringToByteArray(szDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_DEC :
        dwLength = DecimalStringToByteArray(szDisplay, &pByte);
        break;

      case BYTE_ARRAY_DISPLAY_BIN :
        dwLength = BinaryStringToByteArray(szDisplay, &pByte);
        break;

      default :
        ASSERT(FALSE);
        break;
    }

    if (pByte != NULL && dwLength != (DWORD)-1)
    {
      m_edit.SetData(pByte, dwLength);
      delete[] pByte;
      pByte = 0;
    }
  }

  return m_edit.GetDataCopy(ppData);
}

void CByteArrayDisplay::SetCurrentDisplay(DWORD dwCurrentDisplay)
{ 
  m_dwPreviousDisplay = m_dwCurrentDisplay;
  m_dwCurrentDisplay = dwCurrentDisplay; 
}

////////////////////////////////////////////////////////////////////////////////
// String to byte array conversion routines

DWORD HexStringToByteArray(PCWSTR pszHexString, BYTE** ppByte)
{
  CString szHexString = pszHexString;
  BYTE* pToLargeArray = new BYTE[szHexString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return (DWORD)-1;
  }
  
  UINT nByteCount = 0;
  while (!szHexString.IsEmpty())
  {
    //
    // Hex strings should always come 2 characters per byte
    //
    CString szTemp = szHexString.Left(2);

    int iTempByte = 0;
    swscanf(szTemp, L"%X", &iTempByte);
    if (iTempByte <= 0xff)
    {
      pToLargeArray[nByteCount++] = iTempByte & 0xff;
    }
    else
    {
      //
      // Format hex error
      //
      ADSIEditMessageBox(IDS_FORMAT_HEX_ERROR, MB_OK);
      delete[] pToLargeArray;
      pToLargeArray = NULL;
      return (DWORD)-1;
    }

    //
    // Take off the value retrieved and the trailing space
    //
    szHexString = szHexString.Right(szHexString.GetLength() - 3);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToHexString(BYTE* pByte, DWORD dwLength, CString& szHexString)
{
  szHexString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    szTempString.Format(L"%2.2X", pByte[dwIdx]);

    if (dwIdx != 0)
    {
      szHexString += L" ";
    }
    szHexString += szTempString;
  }
}

DWORD OctalStringToByteArray(PCWSTR pszOctString, BYTE** ppByte)
{
  CString szOctString = pszOctString;
  BYTE* pToLargeArray = new BYTE[szOctString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return (DWORD)-1;
  }
  
  UINT nByteCount = 0;
  while (!szOctString.IsEmpty())
  {
    //
    // Octal strings should always come 2 characters per byte
    //
    CString szTemp = szOctString.Left(3);

    int iTempByte = 0;
    swscanf(szTemp, L"%o", &iTempByte);
    if (iTempByte <= 0xff)
    {
      pToLargeArray[nByteCount++] = iTempByte & 0xff;
    }
    else
    {
      //
      // Format octal error
      //
      ADSIEditMessageBox(IDS_FORMAT_OCTAL_ERROR, MB_OK);
      delete[] pToLargeArray;
      pToLargeArray = NULL;
      return (DWORD)-1;
    }

    //
    // Take off the value retrieved and the trailing space
    //
    szOctString = szOctString.Right(szOctString.GetLength() - 4);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToOctalString(BYTE* pByte, DWORD dwLength, CString& szOctString)
{
  szOctString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    szTempString.Format(L"%3.3o", pByte[dwIdx]);

    if (dwIdx != 0)
    {
      szOctString += L" ";
    }
    szOctString += szTempString;
  }
}

DWORD DecimalStringToByteArray(PCWSTR pszDecString, BYTE** ppByte)
{
  CString szDecString = pszDecString;
  BYTE* pToLargeArray = new BYTE[szDecString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return 0;
  }
  
  UINT nByteCount = 0;
  while (!szDecString.IsEmpty())
  {
    //
    // Hex strings should always come 2 characters per byte
    //
    CString szTemp = szDecString.Left(3);

    int iTempByte = 0;
    swscanf(szTemp, L"%d", &iTempByte);
    if (iTempByte <= 0xff)
    {
      pToLargeArray[nByteCount++] = iTempByte & 0xff;
    }
    else
    {
      //
      // Format decimal error
      //
      ADSIEditMessageBox(IDS_FORMAT_DECIMAL_ERROR, MB_OK);
      delete[] pToLargeArray;
      pToLargeArray = NULL;
      return (DWORD)-1;
    }

    //
    // Take off the value retrieved and the trailing space
    //
    szDecString = szDecString.Right(szDecString.GetLength() - 4);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToDecimalString(BYTE* pByte, DWORD dwLength, CString& szDecString)
{
  szDecString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    szTempString.Format(L"%3.3d", pByte[dwIdx]);
    if (dwIdx != 0)
    {
      szDecString += L" ";
    }
    szDecString += szTempString;
  }
}

DWORD BinaryStringToByteArray(PCWSTR pszBinString, BYTE** ppByte)
{
  CString szBinString = pszBinString;
  BYTE* pToLargeArray = new BYTE[szBinString.GetLength()];
  if (pToLargeArray == NULL)
  {
    *ppByte = NULL;
    return (DWORD)-1;
  }
  
  UINT nByteCount = 0;
  while (!szBinString.IsEmpty())
  {
    //
    // Binary strings should always come 8 characters per byte
    //
    BYTE chByte = 0;
    CString szTemp = szBinString.Left(8);
    for (int idx = 0; idx < 8; idx++)
    {
      if (szTemp[idx] == L'1')
      {
        chByte = 0x1 << (8 - idx);
      }
    }

    pToLargeArray[nByteCount++] = chByte;

    //
    // Take off the value retrieved and the trailing space
    //
    szBinString = szBinString.Right(szBinString.GetLength() - 9);
  }

  *ppByte = new BYTE[nByteCount];
  if (*ppByte == NULL)
  {
    delete[] pToLargeArray;
    pToLargeArray = NULL;
    return (DWORD)-1;
  }

  memcpy(*ppByte, pToLargeArray, nByteCount);
  delete[] pToLargeArray;
  pToLargeArray = NULL;
  return nByteCount;
}

void  ByteArrayToBinaryString(BYTE* pByte, DWORD dwLength, CString& szBinString)
{
  szBinString.Empty();
  for (DWORD dwIdx = 0; dwIdx < dwLength; dwIdx++)
  {
    CString szTempString;
    BYTE chTemp = pByte[dwIdx];
    for (size_t idx = 0; idx < sizeof(BYTE) * 8; idx++)
    {
      if ((chTemp & (0x1 << idx)) == 0)
      {
        szTempString = L'0' + szTempString;
      }
      else
      {
        szTempString = L'1' + szTempString;
      }
    }

    if (dwIdx != 0)
    {
      szBinString += L" ";
    }
    szBinString += szTempString;
  }
}

DWORD WCharStringToByteArray(PCWSTR pszWString, BYTE** ppByte)
{
  DWORD dwSize = static_cast<DWORD>(wcslen(pszWString) * sizeof(WCHAR));
  *ppByte = new BYTE[dwSize];
  if (*ppByte != NULL)
  {
    memcpy(*ppByte, pszWString, dwSize);
  }
  else
  {
    dwSize = 0;
  }
  return dwSize;
}

void ByteArrayToWCharString(BYTE* pByte, DWORD dwLength, CString& szWString)
{
  PWSTR pszValue = new WCHAR[(dwLength / sizeof(WCHAR)) + 1]; // +1 is for the /0 at the end
  if (pszValue != NULL)
  {
    memset(pszValue, 0, dwLength + sizeof(WCHAR));
    memcpy(pszValue, pByte, dwLength);
  }
  szWString = pszValue;
}

DWORD CharStringToByteArray(PCSTR pszCString, BYTE** ppByte)
{
  DWORD dwSize = static_cast<DWORD>(strlen(pszCString) * sizeof(CHAR));
  *ppByte = new BYTE[dwSize];
  if (*ppByte != NULL)
  {
    memcpy(*ppByte, pszCString, dwSize);
  }
  else
  {
    dwSize = 0;
  }
  return dwSize;
}

void  ByteArrayToCharString(BYTE* pByte, DWORD dwLength, CString& szCString)
{
  PSTR pszValue = new CHAR[(dwLength / sizeof(CHAR)) + 1]; // +1 is for the /0 at the end
  if (pszValue != NULL)
  {
    memset(pszValue, 0, dwLength + sizeof(CHAR));
    memcpy(pszValue, pByte, dwLength);
  }

  PWSTR pwzValue = NULL;
  if (CharToUnicode(pszValue, &pwzValue))
  {
    szCString = pwzValue;
    delete[] pwzValue;
    pwzValue = NULL;
  }
}

//////////////////////////////////////////////////////////////////////////////

BOOL LoadFileAsByteArray(PCWSTR pszPath, LPBYTE* ppByteArray, DWORD* pdwSize)
{
  if (ppByteArray == NULL ||
      pdwSize == NULL)
  {
    return FALSE;
  }

  CFile file;
  if (!file.Open(pszPath, CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary))
  {
    return FALSE;
  }

  *pdwSize = file.GetLength();
  *ppByteArray = new BYTE[*pdwSize];
  if (*ppByteArray == NULL)
  {
    return FALSE;
  }

  UINT uiCount = file.Read(*ppByteArray, *pdwSize);
  ASSERT(uiCount == *pdwSize);

  return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToFixedPitchFont
//
//  Synopsis:   Converts a windows font to a fixed pitch font.
//
//  Arguments:  [hwnd] -- IN window handle
//
//  Returns:    BOOL
//
//  History:    7/15/1995   RaviR   Created
//
//----------------------------------------------------------------------------

BOOL ConvertToFixedPitchFont(HWND hwnd)
{
  LOGFONT     lf;

  HFONT hFont = reinterpret_cast<HFONT>(::SendMessage(hwnd, WM_GETFONT, 0, 0));

  if (!GetObject(hFont, sizeof(LOGFONT), &lf))
  {
    return FALSE;
  }

  lf.lfQuality        = PROOF_QUALITY;
  lf.lfPitchAndFamily &= ~VARIABLE_PITCH;
  lf.lfPitchAndFamily |= FIXED_PITCH;
  lf.lfFaceName[0]    = L'\0';

  HFONT hf = CreateFontIndirect(&lf);

  if (hf == NULL)
  {
    return FALSE;
  }

  ::SendMessage(hwnd, WM_SETFONT, (WPARAM)hf, (LPARAM)TRUE); // macro in windowsx.h
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef _COMMON_ADSIEDIT_H
#define _COMMON_ADSIEDIT_H

class CConnectionData;
class CCredentialObject;

//////////////////////////////////////////////
#define MAX_PASSWORD_LENGTH 15  // not counting NULL terminator

//////////////////////////////////////////////
// Global API

HRESULT OpenObjectWithCredentials(
											 CConnectionData* pConnectData,
											 const BOOL bUseCredentials,
											 LPCWSTR lpszPath, 
											 const IID& iid,
											 LPVOID* ppObject,
											 HWND hWnd,
											 HRESULT& hResult
											);

HRESULT OpenObjectWithCredentials(
											 CCredentialObject* pCredObject,
											 LPCWSTR lpszPath, 
											 const IID& iid,
											 LPVOID* ppObject
											);

HRESULT CALLBACK BindingCallbackFunction(LPCWSTR lpszPathName,
                                         DWORD  dwReserved,
                                         REFIID riid,
                                         void FAR * FAR * ppObject,
                                         LPARAM lParam);

//////////////////////////////////////////////////////////////////////////
// Commonly used utilities
//
inline void CopyStringList(CStringList *dest, const CStringList *src)
{
	dest->RemoveAll();
	dest->AddTail(const_cast<CStringList*>(src));
}
HRESULT  VariantToStringList(  VARIANT& refvar, CStringList& refstringlist);
HRESULT StringListToVariant( VARIANT& refvar, const CStringList& refstringlist);
VARTYPE VariantTypeFromSyntax(LPCWSTR lpszProp );
HRESULT GetItemFromRootDSE(LPCWSTR lpszRootDSEItem, CString& sItem, CConnectionData* pConnectData);
HRESULT GetRootDSEObject(CConnectionData* pConnectData, IADs** ppDirObject);

///////////////////////////////////////////////////////////////////////////
// Formats Error Messages
//
BOOL GetErrorMessage(HRESULT hr, CString& szErrorString, BOOL bTryADsIErrors = TRUE);

///////////////////////////////////////////////////////////////////////////
// Converts ADSTYPE to/from String
//
void GetStringFromADsValue(const PADSVALUE pADsValue, CString& szValue, DWORD dwMaxCharCount = 0);
void GetStringFromADs(const ADS_ATTR_INFO* pInfo, CStringList& sList, DWORD dwMaxCharCount = 0);
ADSTYPE GetADsTypeFromString(LPCWSTR lps, CString& szSyntax);

////////////////////////////////////////////////////////////////////////////
// type conversions
//
void wtoli(LPCWSTR lpsz, LARGE_INTEGER& liOut);
void litow(LARGE_INTEGER& li, CString& sResult);
void ultow(ULONG ul, CString& sResult);

BOOL UnicodeToChar(LPWSTR pwszIn, LPTSTR * pptszOut);
BOOL CharToUnicode(LPTSTR ptszIn, LPWSTR * ppwszOut);

///////////////////////////////////////////////////////////////////////////
// IO to/from Streams
//
void SaveStringToStream(IStream* pStm, const CString& sString);
HRESULT SaveStringListToStream(IStream* pStm, CStringList& sList);
void LoadStringFromStream(IStream* pStm, CString& sString);
HRESULT LoadStringListFromStream(IStream* pStm, CStringList& sList);

////////////////////////////////////////////////////////////////////////////
// Message Boxes
int ADSIEditMessageBox(LPCTSTR lpszText, UINT nType);
int ADSIEditMessageBox(UINT nIDPrompt, UINT nType);
void ADSIEditErrorMessage(PCWSTR pszMessage);
void ADSIEditErrorMessage(HRESULT hr);
void ADSIEditErrorMessage(HRESULT hr, UINT nIDPrompt, UINT nType);

///////////////////////////////////////////////////////////////////////////
// Other utils
BOOL LoadStringsToComboBox(HINSTANCE hInstance, CComboBox* pCombo,
						   UINT nStringID, UINT nMaxLen, UINT nMaxAddCount);
void ParseNewLineSeparatedString(LPWSTR lpsz, LPWSTR* lpszArr, int* pnArrEntries);
void LoadStringArrayFromResource(LPWSTR* lpszArr,
											UINT* nStringIDs,
											int nArrEntries,
											int* pnSuccessEntries);

/////////////////////////////////////////////////////////////////////////////

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

void GetStringArrayFromStringList(CStringList& sList, LPWSTR** ppStrArr, UINT* nCount);


//////////////////////////////////////////////////////////////////////////////
// UI helper classes

// Fwd declaration
class CByteArrayDisplay;

#define BYTE_ARRAY_DISPLAY_HEX    0x00000001
#define BYTE_ARRAY_DISPLAY_DEC    0x00000002
#define BYTE_ARRAY_DISPLAY_BIN    0x00000004
#define BYTE_ARRAY_DISPLAY_OCT    0x00000008

class CByteArrayComboBox : public CComboBox
{
public:
  BOOL Initialize(CByteArrayDisplay* pDisplay, DWORD dwDisplayFlags);

  DWORD GetCurrentDisplay();
  void SetCurrentDisplay(DWORD dwCurrentDisplayFlag);

protected:
  afx_msg void OnSelChange();

private:
  CByteArrayDisplay*  m_pDisplay;

  DECLARE_MESSAGE_MAP()
};

class CByteArrayEdit : public CEdit
{
public:
  CByteArrayEdit();
  ~CByteArrayEdit();
  BOOL Initialize(CByteArrayDisplay* pDisplay);

  DWORD GetLength();
  BYTE* GetDataPtr();
  DWORD GetDataCopy(BYTE** ppData);

  void SetData(BYTE* pData, DWORD dwLength);

  void OnChangeDisplay();

  afx_msg void OnChange();

private:
  CByteArrayDisplay*  m_pDisplay;

  BYTE*               m_pData;
  DWORD               m_dwLength;

  DECLARE_MESSAGE_MAP()
};

class CByteArrayDisplay
{
public:
  CByteArrayDisplay()
    : m_dwPreviousDisplay(0),
      m_dwCurrentDisplay(0),
      m_dwMaxSizeBytes(0),
      m_nMaxSizeMessage(0)
  {}
  ~CByteArrayDisplay() {}

  BOOL Initialize(UINT  nEditCtrl, 
                  UINT  nComboCtrl, 
                  DWORD dwDisplayFlags, 
                  DWORD dwDefaultDisplay, 
                  CWnd* pParent,
                  DWORD dwMaxSizeBytes,
                  UINT  nMaxSizeMessage);

  void ClearData();
  void SetData(BYTE* pData, DWORD dwLength);
  DWORD GetData(BYTE** ppData);

  void OnEditChange();
  void OnTypeChange(DWORD dwCurrentDisplayFlag);
  DWORD GetCurrentDisplay() { return m_dwCurrentDisplay; }
  void SetCurrentDisplay(DWORD dwCurrentDisplay);
  DWORD GetPreviousDisplay() { return m_dwPreviousDisplay; }

private:
  CByteArrayEdit      m_edit;
  CByteArrayComboBox  m_combo;

  DWORD               m_dwPreviousDisplay;
  DWORD               m_dwCurrentDisplay;

  DWORD               m_dwMaxSizeBytes;     // The maximum number of bytes that will be shown in the edit box
  UINT                m_nMaxSizeMessage;    // The message that is put in the edit box when the max size is reached
};


////////////////////////////////////////////////////////////////////////////////
// String to byte array conversion routines

DWORD HexStringToByteArray(PCWSTR pszHexString, BYTE** ppByte);
void  ByteArrayToHexString(BYTE* pByte, DWORD dwLength, CString& szHexString);

DWORD OctalStringToByteArray(PCWSTR pszHexString, BYTE** ppByte);
void  ByteArrayToOctalString(BYTE* pByte, DWORD dwLength, CString& szHexString);

DWORD DecimalStringToByteArray(PCWSTR pszDecString, BYTE** ppByte);
void  ByteArrayToDecimalString(BYTE* pByte, DWORD dwLength, CString& szDecString);

DWORD BinaryStringToByteArray(PCWSTR pszBinString, BYTE** ppByte);
void  ByteArrayToBinaryString(BYTE* pByte, DWORD dwLength, CString& szBinString);

DWORD WCharStringToByteArray(PCWSTR pszWString, BYTE** ppByte);
void  ByteArrayToWCharString(BYTE* pByte, DWORD dwLength, CString& szWString);

DWORD CharStringToByteArray(PCSTR pszCString, BYTE** ppByte);
void  ByteArrayToCharString(BYTE* pByte, DWORD dwLength, CString& szCString);

/////////////////////////////////////////////////////////////////////////////////

BOOL LoadFileAsByteArray(PCWSTR pszPath, LPBYTE* ppByteArray, DWORD* pdwSize);

/////////////////////////////////////////////////////////////////////////////////

BOOL ConvertToFixedPitchFont(HWND hwnd);

#endif _COMMON_ADSIEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\connection.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connection.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "createwiz.h"
#include "connection.h"
#include "connectionui.h"
#include "editorui.h"
#include "filterui.h"
#include "credui.h"
#include "queryui.h"


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

///////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_lpszRootDSE;

///////////////////////////////////////////////////////////////////////////////

// {5C225203-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditConnectionNode::NodeTypeGUID = 
{ 0x5c225203, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };


CADSIEditConnectionNode::~CADSIEditConnectionNode()
{
	RemoveAndDeleteAllQueriesFromList();
	delete m_pConnectData;
  HRESULT hr = m_SchemaCache.Destroy();
  ASSERT(SUCCEEDED(hr));
}

bool CADSIEditConnectionNode::IsClassAContainer(CCredentialObject* pCredObject,
                                                PCWSTR pszClass, 
                                                PCWSTR pszSchemaPath)
{
  bool bContainer = false;

  do // false loop
  {
    if (!pCredObject ||
        !pszClass    ||
        !pszSchemaPath)
    {
      ASSERT(pCredObject);
      ASSERT(pszClass);
      ASSERT(pszSchemaPath);
      bContainer = false;
      break;
    }

    CADSIEditClassCacheItemBase* pSchemaCacheItem = m_SchemaCache.FindClassCacheItem(pCredObject, 
                                                                                     pszClass, 
                                                                                     pszSchemaPath);
    if (pSchemaCacheItem)
    {
      bContainer = pSchemaCacheItem->IsContainer();
    }

  } while (false);

  return bContainer;
}

BOOL CADSIEditConnectionNode::OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync)
{

	CString path, basePath;
	GetADsObject()->GetPath(path);
	m_pConnectData->GetBasePath(basePath);

	CComPtr<IDirectoryObject> spDirectoryObject;
	HRESULT hr, hCredResult;
	CADsObject* pObject = new CADsObject();
  if (pObject)
  {
	  if (m_pConnectData->IsRootDSE())
	  {
		  pObject->SetContainer(TRUE);
		  pObject->SetName(g_lpszRootDSE);
		  pObject->SetPath(path);
		  pObject->SetClass(g_lpszRootDSE);
		  pObject->SetConnectionNode(this);
		  pObject->SetIntermediateNode(TRUE);
		  pObject->SetComplete(TRUE);
		  CADSIEditContainerNode *pNewContNode = new CADSIEditContainerNode(pObject);
		  if (pNewContNode)
      {
        pNewContNode->SetDisplayName(g_lpszRootDSE);

		    VERIFY(AddChildToList(pNewContNode));
      }
      pComponentData->SetDescriptionBarText(this);
	  }
	  else
	  {
		  hr = OpenObjectWithCredentials(
												   m_pConnectData, 
												   m_pConnectData->GetCredentialObject()->UseCredentials(),
												   (LPWSTR)(LPCWSTR)path,
												   IID_IDirectoryObject, 
												   (LPVOID*) &spDirectoryObject,
												   NULL,
												   hCredResult
												   );

		  if ( FAILED(hr) )
		  {
			  if (SUCCEEDED(hCredResult))
			  {
				  ADSIEditErrorMessage(hr);
			  }
        if (pObject)
        {
          delete pObject;
          pObject = 0;
        }
			  return FALSE;
		  }

		  ADS_OBJECT_INFO* pInfo = 0;
		  hr = spDirectoryObject->GetObjectInformation(&pInfo);
		  if (FAILED(hr))
		  {
			  ADSIEditErrorMessage(hr);
        if (pObject)
        {
          delete pObject;
          pObject = 0;
        }
			  return FALSE;
		  }

		  // Name
		  pObject->SetName(basePath);
		  pObject->SetDN(basePath);
		  pObject->SetPath(path);

		  // Make sure the prefix is uppercase
		  CString sBasePath(basePath);
		  int idx = sBasePath.Find(L'=');

		  if (idx != -1)
		  {
			  CString sPrefix, sRemaining;
			  sPrefix = sBasePath.Left(idx);
			  sPrefix.MakeUpper();

			  int iCount = sBasePath.GetLength();
			  sRemaining = sBasePath.Right(iCount - idx);
			  sBasePath = sPrefix + sRemaining;
		  }

		  // Class
		  pObject->SetClass(pInfo->pszClassName);

		  pObject->SetIntermediateNode(TRUE);
		  pObject->SetContainer(TRUE);
		  pObject->SetComplete(TRUE);
		  CADSIEditContainerNode *pNewContNode = new CADSIEditContainerNode(pObject);
      if (pNewContNode)
      {
		    CString sName;
		    pNewContNode->SetDisplayName(sBasePath);

		    GetConnectionData()->SetIDirectoryInterface(spDirectoryObject);
		    pNewContNode->GetADsObject()->SetConnectionNode(this);
		    VERIFY(AddChildToList(pNewContNode));
        pComponentData->SetDescriptionBarText(this);
		    FreeADsMem(pInfo);
      }
	  }

	  EnumerateQueries();
  }

	return TRUE;
}

void CADSIEditConnectionNode::EnumerateQueries()
{
	POSITION pos = m_queryList.GetHeadPosition();
	while(pos != NULL)
	{
		CADSIEditQueryData* pQueryData = m_queryList.GetNext(pos);

		CADsObject* pObject = new CADsObject();
    if (pObject)
    {
		
		  CString sPath, sName;
		  pQueryData->GetName(sName);
		  pObject->SetName(sName);

		  pQueryData->GetRootPath(sPath);
		  pObject->SetPath(sPath);

		  pObject->SetComplete(TRUE);
		  pObject->SetConnectionNode(this);
		  pObject->SetContainer(TRUE);
		  pObject->SetIntermediateNode(TRUE);

		  CADSIEditQueryNode* pNewQuery = new CADSIEditQueryNode(pObject, pQueryData);
      if (pNewQuery)
      {

		    CString sDisplayName;
		    pQueryData->GetDisplayName(sDisplayName);
		    pNewQuery->SetDisplayName(sDisplayName);
		    VERIFY(AddChildToList(pNewQuery));
      }
    }
	}
}

BOOL CADSIEditConnectionNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                               BOOL* pbHideVerb, 
                                               CNodeList* pNodeList)
{
	*pbHideVerb = TRUE; // always hide the verb
	return FALSE;
}

BOOL CADSIEditConnectionNode::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList)
{
	CString szPath;
	GetADsObject()->GetPath(szPath);

	if (wcscmp(lpszPath, (LPCWSTR)szPath) == 0)
	{
		foundNodeList.AddHead(this);
		return TRUE;
	}

	BOOL bFound = FALSE;
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pNode);

		if (pContNode != NULL)
		{
			BOOL bTemp;
			bTemp = pContNode->FindNode(lpszPath, foundNodeList);
			if (!bFound)
			{
				bFound = bTemp;
			}
		}
	}
	return bFound;
}

int CADSIEditConnectionNode::GetImageIndex(BOOL bOpenImage) 
{
	int nIndex = 0;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = SERVER_IMAGE_NOT_LOADED;
		break;
	case loading:
		nIndex = SERVER_IMAGE_LOADING;
		break;
	case loaded:
		nIndex = SERVER_IMAGE_LOADED;
		break;
	case unableToLoad:
		nIndex = SERVER_IMAGE_UNABLE_TO_LOAD;
		break;
	case accessDenied:
		nIndex = SERVER_IMAGE_ACCESS_DENIED;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}

void CADSIEditConnectionNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
	switch (m_nState)
	{
	case notLoaded:
	case loaded:
	case unableToLoad:
	case accessDenied:
	{
		m_nState = loading;
		m_dwErr = 0;
	}
	break;
	case loading:
	{
		if (m_dwErr == 0)
			m_nState = loaded;
		else if (m_dwErr == ERROR_ACCESS_DENIED)
			m_nState = accessDenied;
		else 
			m_nState = unableToLoad;
	}
	break;
	default:
		ASSERT(FALSE);
	}
	VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
	VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
}


BOOL CADSIEditConnectionNode::OnRefresh(CComponentDataObject* pComponentData,
                                        CNodeList* pNodeList)
{
  BOOL bRet = FALSE;

  DWORD dwCount = 0;
  if (pNodeList == NULL)
  {
    dwCount = 1;
  }
  else
  {
    dwCount = pNodeList->GetCount();
  }

  if (dwCount > 1) // multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
  else if (dwCount  == 1) // single selection
  {
	  if(CContainerNode::OnRefresh(pComponentData, pNodeList))
	  {
		  CADSIEditContainerNode * pNextNode;
		  POSITION pos = m_containerChildList.GetHeadPosition();
		  while (pos != NULL)
		  {
			  pNextNode = dynamic_cast<CADSIEditContainerNode*>(m_containerChildList.GetNext(pos));
			  ASSERT(pNextNode != NULL);

        CNodeList nodeList;
        nodeList.AddTail(pNextNode);

			  pNextNode->OnRefresh(pComponentData, &nodeList);
		  }
		  return TRUE;
	  }
  }
	return FALSE;
}


HRESULT CADSIEditConnectionNode::OnCommand(long nCommandID, 
                                           DATA_OBJECT_TYPES type, 
								                           CComponentDataObject* pComponentData,
                                           CNodeList* pNodeList)
{
  ASSERT (pNodeList->GetCount() == 1); // should only be a single selection

	switch (nCommandID)
	{
	case IDM_SETTINGS_CONNECTION : 
		OnSettings(pComponentData);
		break;
	case IDM_REMOVE_CONNECTION :
		OnRemove(pComponentData);
		break;
	case IDM_NEW_OBJECT :
		OnCreate(pComponentData);
		break;
	case IDM_FILTER :
		OnFilter(pComponentData);
		break;
  case IDM_UPDATE_SCHEMA :
    OnUpdateSchema();
    break;
	case IDM_NEW_QUERY :
		OnNewQuery(pComponentData);
		break;
  default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
  return S_OK;
}

void CADSIEditConnectionNode::OnUpdateSchema()
{
  // Force an update of the schema cache
  CString szRootDSE;
  CConnectionData* pConnectData = GetConnectionData();

  CComPtr<IADs> spDirObject;
  HRESULT hr = GetRootDSEObject(pConnectData, &spDirObject);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return;
  }

  VARIANT var;
  var.vt = VT_I4;
  var.lVal = 1;
  hr = spDirObject->Put(L"updateSchemaNow", var);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return;
  }

  CString szSchema;
  pConnectData->GetAbstractSchemaPath(szSchema);
  szSchema = szSchema.Left(szSchema.GetLength()- 1);
  CComPtr<IADs> spSchemaObject;
	HRESULT hCredResult;
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)szSchema,
											 IID_IADs, 
											 (LPVOID*) &spSchemaObject,
											 NULL,
											 hCredResult
											);

	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

  hr = spSchemaObject->GetInfo();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
  }

  //
  // Now clear the schema cache
  //
  m_SchemaCache.Clear();

  ADSIEditMessageBox(IDS_SCHEMA_UPDATE_SUCCESSFUL, MB_OK);
}

void CADSIEditConnectionNode::OnNewQuery(CComponentDataObject* pComponentData)
{
	CString sConnectPath;
	GetADsObject()->GetPath(sConnectPath);
	CCredentialObject* pCredObject = GetConnectionData()->GetCredentialObject();

	CADSIEditQueryDialog queryDialog(sConnectPath, pCredObject);
	if (queryDialog.DoModal() == IDOK)
	{
		BOOL bOneLevel;
		CString sQueryString, sName, sPath;
		queryDialog.GetResults(sName, sQueryString, sPath, &bOneLevel);

		CADSIEditConnectionNode* pConnectNode = GetADsObject()->GetConnectionNode();

		CADsObject* pObject = new CADsObject();
    if (pObject)
    {
		  CADSIEditQueryData *pQueryData = new CADSIEditQueryData();
      if (pQueryData)
      {

		    // Name
		    pObject->SetName(sName);
		    pQueryData->SetName(sName);

		    // Set the root path of the query string
		    pObject->SetPath(sPath);
		    pQueryData->SetRootPath(sPath);

		    // Set the query string
		    pQueryData->SetFilter(sQueryString);

		    pObject->SetIntermediateNode(TRUE);
		    pObject->SetContainer(TRUE);
		    pObject->SetComplete(TRUE);
		    pObject->SetConnectionNode(pConnectNode);

		    // Set the scope of the query
		    ADS_SCOPEENUM scope;
		    scope = (bOneLevel) ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE;
		    pQueryData->SetScope(scope);

		    // Create the query node with imbedded objects
		    CADSIEditQueryNode* pNewQueryNode = new CADSIEditQueryNode(pObject, pQueryData);
        if (pNewQueryNode)
        {

          //
		      // Set the display name
          //
		      CString sDisplayName;
		      pQueryData->GetDisplayName(sDisplayName);
		      pNewQueryNode->SetDisplayName(sDisplayName);

          //
		      // Add to connection node's list of queries
          //
		      pConnectNode->AddQueryToList(pQueryData);
		      
		      if (pConnectNode->IsExpanded())
		      {
			      VERIFY(pConnectNode->AddChildToListAndUI(pNewQueryNode, pComponentData));
            pComponentData->SetDescriptionBarText(this);
		      }
        }
      }
	  }
  }
}

void CADSIEditConnectionNode::OnFilter(CComponentDataObject* pComponentData)
{
	CADSIFilterDialog filterDialog(m_pConnectData);
	if (filterDialog.DoModal() == IDOK)
	{
    CNodeList nodeList;
    nodeList.AddTail(this);
		OnRefresh(pComponentData, &nodeList);
	}
}

void CADSIEditConnectionNode::OnCreate(CComponentDataObject* pComponentData)
{
	CCreatePageHolder* pHolder = new CCreatePageHolder(GetContainer(), this, pComponentData);
	ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
	pHolder->DoModalWizard();
}

BOOL CADSIEditConnectionNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                                   BOOL* pbHideVerb, 
                                                   CNodeList* pNodeList)
{
	*pbHideVerb = TRUE; // always hid the verb
	return FALSE;
}

BOOL CADSIEditConnectionNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
																					 long *pInsertionAllowed)
{
	if (IsThreadLocked() || IsSheetLocked())
	{
		pContextMenuItem->fFlags = MF_GRAYED;
		return TRUE;
	}

	if (GetConnectionData()->GetFilter()->InUse())
	{
		pContextMenuItem->fFlags = MF_CHECKED;
		return TRUE;
	}
	return TRUE;
}

void CADSIEditConnectionNode::OnRemove(CComponentDataObject* pComponentData)
{
	CString sLoadString, sCaption;
	if (sLoadString.LoadString(IDS_MSG_REMOVE_CONNECTION))
	{
		sCaption.Format((LPWSTR)(LPCWSTR)sLoadString, GetDisplayName());
	}

	if (ADSIEditMessageBox(sCaption, MB_OKCANCEL) == IDOK)
	{
		if (IsSheetLocked())
		{
			if (!CanCloseSheets())
				return;
			pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
		}
		ASSERT(!IsSheetLocked());

		// now remove from the UI
		DeleteHelper(pComponentData);
    pComponentData->SetDescriptionBarText(GetContainer());
    pComponentData->UpdateResultPaneView(GetContainer());

		delete this; // gone
	}
}

void CADSIEditConnectionNode::OnSettings(CComponentDataObject* pComponentData)
{
  CWaitCursor cursor;
	CComponentDataObject* pComponentDataObject = 
			((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
	ASSERT(pComponentDataObject != NULL);
	
	CContainerNode* pContNode = dynamic_cast<CContainerNode*>(GetContainer());
	ASSERT(pContNode != NULL);

	CADSIEditConnectDialog ConnectDialog(pContNode, 
													 this, 
													 pComponentDataObject,
													 m_pConnectData);
	if (ConnectDialog.DoModal() == IDOK)
	{
    cursor.Restore();
		if (HasQueries())
		{
			if (AfxMessageBox(IDS_MSG_EXISTING_QUERIES, MB_YESNO) == IDYES)
			{
				RemoveAllQueriesFromList();
			}
		}
    CNodeList nodeList;
    nodeList.AddTail(this);
		OnRefresh(pComponentData, &nodeList);
	}

}

BOOL CADSIEditConnectionNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                                    BOOL* pbHide, 
                                                    CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

	*pbHide = FALSE;
	return !IsThreadLocked();
}


HRESULT CADSIEditConnectionNode::CreateFromStream(IStream* pStm, CADSIEditConnectionNode** ppConnectionNode)
{
	WCHAR szBuffer[MAX_CONNECT_NAME_LENGTH + 1];
	ULONG nLen; // WCHAR counting NULL
	ULONG cbRead;

	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	VERIFY(SUCCEEDED(pStm->Read((void*)szBuffer,sizeof(WCHAR)*nLen, &cbRead)));
	ASSERT(cbRead == sizeof(WCHAR)*nLen);

	CConnectionData* pConnect = CConnectionData::Load(pStm);
	*ppConnectionNode = new CADSIEditConnectionNode(pConnect);
	ASSERT(*ppConnectionNode != NULL);

	CString szDisplayExtra, szDisplay;
	pConnect->GetDomainServer(szDisplayExtra);
	szDisplay = CString(szBuffer) + L" [" + szDisplayExtra + L"]";
	(*ppConnectionNode)->SetDisplayName(szDisplay);
	(*ppConnectionNode)->SetConnectionNode(*ppConnectionNode);
	(*ppConnectionNode)->LoadQueryListFromStream(pStm);

	return S_OK;
}


HRESULT CADSIEditConnectionNode::SaveToStream(IStream* pStm)
{
	// for each connection name, write # of chars+NULL, and then the name
	ULONG cbWrite;
	CString szName;
	m_pConnectData->GetName(szName);
	SaveStringToStream(pStm, szName);

	m_pConnectData->Save(pStm);
	SaveQueryListToStream(pStm);

	return S_OK;
}

void CADSIEditConnectionNode::LoadQueryListFromStream(IStream* pStm)
{
	ULONG cbRead;
	int iCount;

	VERIFY(SUCCEEDED(pStm->Read((void*)&iCount,sizeof(int), &cbRead)));
	ASSERT(cbRead == sizeof(int));

	for (int idx = 0; idx < iCount; idx++)
	{
		CADSIEditQueryData* pQueryData = new CADSIEditQueryData();
		
		CString sName, sQueryString, sPath;
		LoadStringFromStream(pStm, sName);
		LoadStringFromStream(pStm, sQueryString);
		LoadStringFromStream(pStm, sPath);

		pQueryData->SetName(sName);
		pQueryData->SetFilter(sQueryString);
		CString sRootPath;
		BuildQueryPath(sPath, sRootPath);
		pQueryData->SetRootPath(sRootPath);

		ADS_SCOPEENUM scope;
		VERIFY(SUCCEEDED(pStm->Read((void*)&scope, sizeof(ADS_SCOPEENUM), &cbRead)));
		ASSERT(cbRead == sizeof(ADS_SCOPEENUM));

		pQueryData->SetScope(scope);

		AddQueryToList(pQueryData);
	}
}

void CADSIEditConnectionNode::BuildQueryPath(const CString& sPath, CString& sRootPath)
{
	CConnectionData* pConnectData = GetConnectionData();

	CString sServer, sLDAP, sPort, sTemp;
	pConnectData->GetDomainServer(sServer);
	pConnectData->GetLDAP(sLDAP);
	pConnectData->GetPort(sPort);

	if (sServer != _T(""))
	{
		sTemp = sLDAP + sServer;
		if (sPort != _T(""))
		{
			sTemp = sTemp + _T(":") + sPort + _T("/");
		}
		else
		{
			sTemp = sTemp + _T("/");
		}
		sRootPath = sTemp + sPath;
	}
	else
	{
		sRootPath = sLDAP + sPath;
	}

}

void CADSIEditConnectionNode::SaveQueryListToStream(IStream* pStm)
{
	ULONG cbWrite;
	int iCount = m_queryList.GetCount();
	VERIFY(SUCCEEDED(pStm->Write((void*)&iCount, sizeof(int),&cbWrite)));
	ASSERT(cbWrite == sizeof(int));
	
	POSITION pos = m_queryList.GetHeadPosition();
	while (pos != NULL)
	{
		CADSIEditQueryData* pQueryData = m_queryList.GetNext(pos);
		ASSERT(pQueryData != NULL);

		ADS_SCOPEENUM scope;
		CString sName, sQueryString, sRootPath;
		pQueryData->GetName(sName);
		pQueryData->GetFilter(sQueryString);
		pQueryData->GetDisplayPath(sRootPath);
		scope = pQueryData->GetScope();

		// save the query info to stream
		SaveStringToStream(pStm, sName);
		SaveStringToStream(pStm, sQueryString);
		SaveStringToStream(pStm, sRootPath);

		// Save the scope
		VERIFY(SUCCEEDED(pStm->Write((void*)&scope, sizeof(ADS_SCOPEENUM),&cbWrite)));
		ASSERT(cbWrite == sizeof(ADS_SCOPEENUM));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\connectionui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connectionui.h
//
//--------------------------------------------------------------------------

#ifndef _CONNECTIONUI_H
#define _CONNECTIONUI_H

#include "snapdata.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditConnectDialog

class CADSIEditConnectDialog : public CDialog
{

// Construction
public:
  CADSIEditConnectDialog(CContainerNode* pRootnode,
												 CTreeNode* pTreeNode,
												 CComponentDataObject* pComponentData,
												 CConnectionData* pConnectData
												 );
	~CADSIEditConnectDialog();

protected:

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual BOOL OnApply();
	afx_msg void OnSelChangeContextList();
	afx_msg void OnSelChangeDSList();
	afx_msg void OnSelChangeDNList();
	afx_msg void OnEditChangeDSList();
	afx_msg void OnEditChangeDNList();
	afx_msg void OnAdvanced();
	afx_msg void OnDNRadio();
	afx_msg void OnNCRadio();
	afx_msg void OnDSRadio();
	afx_msg void OnDefaultRadio();

	void SetAndDisplayPath();
	void LoadNamingContext();
	void SetupUI();
	void SetDirty()
	{
		m_bDirty = TRUE;
	}
	BOOL BuildPath(CString& s, BSTR bstrPath, IADs *pADs);
	BOOL BuildNamingContext(CComBSTR& bstrPath);
	void BuildRootDSE(CString& sRootDSE);
	BOOL DoDirty();

	void SaveMRUs();
	void LoadMRUs();

	BOOL m_bDirty;

	CConnectionData* m_pNewConnectData;
	CComponentDataObject* m_pComponentData;

	CADSIEditRootData* GetRootNode() 
	{ 
		CADSIEditRootData* pRoot = dynamic_cast<CADSIEditRootData*>(GetTreeNode());
		if (pRoot == NULL)
		{
			pRoot = dynamic_cast<CADSIEditRootData*>(GetContainerNode());
			ASSERT(pRoot != NULL);
		}
		return pRoot;
	}

	CTreeNode* GetTreeNode() { return m_pTreeNode; }
	CContainerNode* GetContainerNode() { return m_pContainerNode; }
	CComponentDataObject* GetComponentData() { return m_pComponentData; }
	CConnectionData* GetConnectionData() { return m_pNewConnectData; }

private:
	BOOL m_bNewConnect;
	CTreeNode* m_pTreeNode;
	CContainerNode* m_pContainerNode;
	CString m_szDisplayExtra;
	CString m_sDefaultServerName;

	CString m_szDomain;
	CString m_szConfigContainer;
	CString m_szRootDSE;
	CString m_szSchema;

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// CADSIEditAdvancedConnectionPageHolder

class CADSIEditAdvancedConnectionDialog : public CDialog
{
public:
	CADSIEditAdvancedConnectionDialog(CContainerNode* pRootDataNode, CTreeNode* pContainerNode,
			CComponentDataObject* pComponentData, CConnectionData* pConnectData); 
	~CADSIEditAdvancedConnectionDialog();

protected:
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
	virtual void OnOK();
	virtual void OnCredentials();

	// Member Data
	//
	CTreeNode* m_pTreeNode;
	CContainerNode* m_pContainerNode;
	CComponentDataObject* m_pComponentData;
	CConnectionData* m_pConnectData;

	DECLARE_MESSAGE_MAP()
};
#endif _CONNECTIONUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\createwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       createwiz.cpp
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////
// createwiz.cpp

#include "pch.h"
#include <SnapBase.h>

#include "createwiz.h"
#include "connection.h"
#include "editorui.h"
#include "query.h"
#include "resource.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

//////////////////////////////////////////////////////////////////////////////////////
// CCreateClassPage

BEGIN_MESSAGE_MAP(CCreateClassPage, CPropertyPageBase)
	//{{AFX_MSG_MAP(CADsObjectDialog)
//	ON_CBN_SELCHANGE(IDC_CLASS_LIST, OnSelChangeClassList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCreateClassPage::CCreateClassPage(CADSIEditContainerNode* pNode) : CPropertyPageBase(IDD_CREATE_CLASS_PAGE)
{
	m_pCurrentNode = pNode;
}

CCreateClassPage::~CCreateClassPage()
{

}

BOOL CCreateClassPage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();

	CListBox* pClassList = (CListBox*)GetDlgItem(IDC_CLASS_LIST);

  // disable IME support on numeric edit fields
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_NUMBER_VALUE_BOX), NULL);

	FillList();
	pClassList->SetCurSel(0);
	return TRUE;
}

void CCreateClassPage::FillList()
{
	CListBox* pClassList = (CListBox*)GetDlgItem(IDC_CLASS_LIST);

  HRESULT hr, hCredResult;
	
	CString sPath, schema;
	m_pCurrentNode->GetADsObject()->GetPath(sPath);

	CConnectionData* pConnectData = m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData();

	// bind to Container for IPropertyList
	CComPtr<IADsPropertyList> spDSObject;
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sPath,
											 IID_IADsPropertyList, 
											 (LPVOID*) &spDSObject,
											 GetSafeHwnd(),
											 hCredResult
											 );

  if (FAILED(hr))
	{
    TRACE(_T("Bind to Container for IPropertyList failed: %lx.\n"), hr);
    return;
  }

  // need to do this hack to load the cache
  CComPtr<IADs> spIADs;
  hr = spDSObject->QueryInterface (IID_IADs, (LPVOID*)&spIADs);
  if (FAILED(hr)) 
  {
    TRACE(_T("QI to Container for IADs failed: %lx.\n"), hr);
    return;
  }

	PWSTR g_wzAllowedChildClassesEffective = L"allowedChildClassesEffective";
  CComVariant varHints;
  ADsBuildVarArrayStr (&g_wzAllowedChildClassesEffective, 1, &varHints);
  spIADs->GetInfoEx(varHints, 0);


	// get allowed child classes as VARIANT
	CComVariant VarProp;
  hr = spDSObject->GetPropertyItem(g_wzAllowedChildClassesEffective,
                                     ADSTYPE_CASE_IGNORE_STRING, &VarProp);
  if (FAILED(hr)) 
	{
		TRACE(_T("GetPropertyItem failed: %lx.\n"), hr);
		return;
  }

	// extract the IADsPropertyEntry interface pointer
	IDispatch* pDisp = V_DISPATCH(&VarProp);
	CComPtr<IADsPropertyEntry> spPropEntry;
  hr = pDisp->QueryInterface(IID_IADsPropertyEntry, (void **)&spPropEntry);
	if (FAILED(hr))
	{
		return;
	}

	// get SAFEARRAY out of IADsPropertyEntry pointer
	CComVariant Var;
  hr = spPropEntry->get_Values(&Var);
	if (FAILED(hr))
	{
		return;
	}

	long uBound, lBound;
  hr = ::SafeArrayGetUBound(V_ARRAY(&Var), 1, &uBound);
  hr = ::SafeArrayGetLBound(V_ARRAY(&Var), 1, &lBound);

	VARIANT* pNames;
  hr = ::SafeArrayAccessData(V_ARRAY(&Var), (void **)&pNames);
  if (FAILED(hr))
	{
		TRACE(_T("Accessing safearray data failed: %lx.\n"), hr);
		SafeArrayUnaccessData(V_ARRAY(&Var));
		return;
  }

	// now got the array of items, loop through them
  WCHAR szFrendlyName[1024];
  HRESULT hrName;
	
  long nChildClassesCount = uBound - lBound + 1;

  for (long index = lBound; index <= uBound; index++) 
	{
		CComPtr<IADsPropertyValue> spEntry;
		hr = (pNames[index].pdispVal)->QueryInterface (IID_IADsPropertyValue,
                                                     (void **)&spEntry);
		if (SUCCEEDED(hr)) 
		{
			BSTR bsObject = NULL;
			hr = spEntry->get_CaseIgnoreString(&bsObject);
			if (SUCCEEDED(hr))
			{
//        hrName = ::DsGetFriendlyClassName(bsObject, szFrendlyName, 1024);
//        ASSERT(SUCCEEDED(hrName));
				pClassList->AddString(bsObject);
			} // if
			::SysFreeString(bsObject);
        } // if
    } // for
	
	::SafeArrayUnaccessData(V_ARRAY(&Var));
}


BOOL CCreateClassPage::OnSetActive()
{	
	GetHolder()->SetWizardButtonsFirst(TRUE);

	return TRUE;
}


LRESULT CCreateClassPage::OnWizardNext()
{
	CListBox* pClassList = (CListBox*)GetDlgItem(IDC_CLASS_LIST);

	CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
	ASSERT(pHolder != NULL);

	CString sClass;
	pClassList->GetText(pClassList->GetCurSel(), sClass);
	
	if (m_sClass != sClass)
	{
		m_sClass = sClass;
		pHolder->AddAttrPage(sClass);
	}

	return 0; //next page
}


/////////////////////////////////////////////////////////////////////////////////////////
// CCreateAttributePage

BEGIN_MESSAGE_MAP(CCreateAttributePage, CPropertyPageBase)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_EN_CHANGE(IDC_ATTR_VALUE_BOX, OnEditChangeValue)
	ON_EN_CHANGE(IDC_NUMBER_VALUE_BOX, OnEditChangeValue)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCreateAttributePage::CCreateAttributePage(UINT nID, CADSIAttr* pAttr) : CPropertyPageBase(nID)
{
	m_bInitialized = FALSE;
	m_bNumber = FALSE;
	m_pAttr = pAttr;
}

CCreateAttributePage::~CCreateAttributePage()
{
}

BOOL CCreateAttributePage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();

	CEdit* pAttrBox = (CEdit*)GetDlgItem(IDC_ATTR_BOX);

  // disable IME support on numeric edit fields
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_NUMBER_VALUE_BOX), NULL);

	CString sAttr;
	m_pAttr->GetProperty(sAttr);
	pAttrBox->SetWindowText(sAttr);

	SetSyntax(sAttr);
	m_bInitialized = TRUE;
	return TRUE;
}

void CCreateAttributePage::GetValue(CString& sVal)
{ 
	CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
	pValueBox->GetWindowText(sVal);
}

void CCreateAttributePage::SetSyntax(CString sAttr)
{
	CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
	CEdit* pNumberBox = (CEdit*)GetDlgItem(IDC_NUMBER_VALUE_BOX);
	CEdit* pSyntaxBox = (CEdit*)GetDlgItem(IDC_SYNTAX_BOX);

	CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
	ASSERT(pHolder != NULL);
  if (pHolder != NULL)
  {
	  CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pHolder->GetTreeNode());
	  ASSERT(pContNode != NULL);

    if (pContNode != NULL)
    {
	    CConnectionData* pConnectData = pContNode->GetADsObject()->GetConnectionNode()->GetConnectionData();

	    CString sPath, sSyntax;
	    CComPtr<IADsProperty> pProp;

	    pHolder->GetSchemaPath(sAttr, sPath);

	    // bind to object with authentication
	    //
	    HRESULT hr, hCredResult;
	    hr = OpenObjectWithCredentials(
																     pConnectData, 
																     pConnectData->GetCredentialObject()->UseCredentials(),
																     (LPWSTR)(LPCWSTR)sPath,
																     IID_IADsProperty, 
																     (LPVOID*) &pProp,
																     GetSafeHwnd(),
																     hCredResult
																     );

	    if ( FAILED(hr) )
	    {
		    if (SUCCEEDED(hCredResult))
		    {
			    ADSIEditErrorMessage(hr);
		    }
		    return;
	    }
	    
	    BSTR bstr;

	    hr = pProp->get_Syntax( &bstr );
	    if ( SUCCEEDED(hr) )
	    {
		    sSyntax = bstr;
	    }

	    pSyntaxBox->SetWindowText(sSyntax);

	    BOOL varType = VariantTypeFromSyntax(sSyntax);
	    switch (varType)
	    {
		    case VT_BSTR :
			    pNumberBox->ShowWindow(FALSE);
			    pValueBox->ShowWindow(TRUE);
			    m_bNumber = FALSE;
			    break;
		    case VT_I4 :
		    case VT_I8 :
			    pNumberBox->ShowWindow(TRUE);
			    pValueBox->ShowWindow(FALSE);
			    m_bNumber = TRUE;
			    break;
		    default :
			    pNumberBox->ShowWindow(FALSE);
			    pValueBox->ShowWindow(TRUE);
			    m_bNumber = FALSE;
			    break;
	    }
	    pProp->get_MaxRange(&m_lMaxRange);
	    pProp->get_MinRange(&m_lMinRange);
	    
	    SetADsType(sAttr);
    }
  }
}

void CCreateAttributePage::SetADsType(CString sProp)
{
	CString schema, sServer;
	BOOL bResult = FALSE;

	CConnectionData* pConnectData;
	CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetHolder()->GetTreeNode());
	if (pContNode == NULL)
	{
		CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(GetHolder()->GetTreeNode());
		ASSERT(pLeafNode != NULL);
		bResult = pLeafNode->BuildSchemaPath(schema);

		pConnectData = pLeafNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
	}
	else
	{
		bResult = pContNode->BuildSchemaPath(schema);
		pConnectData = pContNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
	}

	if (!bResult)
	{
		return;
	}

	CADSIQueryObject schemaSearch;

	// Initialize search object with path, username and password
	//
	HRESULT hr = schemaSearch.Init(schema, pConnectData->GetCredentialObject());
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	int cCols = 2;
  LPWSTR pszAttributes[] = {L"attributeSyntax", L"isSingleValued"};
	ADS_SEARCH_COLUMN ColumnData;
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

  CString csFilter = _T("(&(objectClass=attributeSchema)(lDAPDisplayName=") +
												sProp + _T("))");
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  if (SUCCEEDED(hr)) 
	{
    hr = schemaSearch.GetNextRow();

    if (SUCCEEDED(hr)) 
		{

      hr = schemaSearch.GetColumn(pszAttributes[0],
		                              &ColumnData);
			if (SUCCEEDED(hr))
			{
				TRACE(_T("\t\tattributeSyntax: %s\n"), 
				     ColumnData.pADsValues->CaseIgnoreString);

            CString szSyntax;
				ADSTYPE dwType;
				dwType = GetADsTypeFromString(ColumnData.pADsValues->CaseIgnoreString, szSyntax);
				m_pAttr->SetADsType(dwType);
            m_pAttr->SetSyntax(szSyntax);
			}
			else
			{
				ADSIEditErrorMessage(hr);
			}

			hr = schemaSearch.GetColumn(pszAttributes[1], &ColumnData);
			if (SUCCEEDED(hr))
			{
				TRACE(_T("\t\tisSingleValued: %d\n"), 
				     ColumnData.pADsValues->Boolean);
				m_pAttr->SetMultivalued(!ColumnData.pADsValues->Boolean);
			}
			else
			{
				ADSIEditErrorMessage(hr);
			}
		}
	}
}


void CCreateAttributePage::OnEditChangeValue()
{
	CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
	CEdit* pNumberBox = (CEdit*)GetDlgItem(IDC_NUMBER_VALUE_BOX);

	CString sValue, sAttr;
	CEdit* pBox;

	if (m_bNumber)
	{
		pBox = pNumberBox;
	}
	else
	{
		pBox = pValueBox;
	}
	
	pBox->GetWindowText(sValue);
	
	CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
	ASSERT(pHolder != NULL);
	m_pAttr->GetProperty(sAttr);

	CString sNamingAttr;
	pHolder->GetNamingAttribute(sNamingAttr);

	if (sAttr == sNamingAttr)
	{
		pHolder->SetName(sValue);
	}
	
	if (sValue == _T(""))
	{
		GetHolder()->SetWizardButtons(PSWIZB_BACK);
	}
	else
	{
		GetHolder()->SetWizardButtons(PSWIZB_BACK|PSWIZB_NEXT);
	}

}


BOOL CCreateAttributePage::OnSetActive()
{
	if (m_bInitialized)
	{
		OnEditChangeValue();
	}
	else
	{
		GetHolder()->SetWizardButtonsMiddle(FALSE);
	}
	
	return TRUE;
}

LRESULT CCreateAttributePage::OnWizardNext()
{
	CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
	CEdit* pNumberBox = (CEdit*)GetDlgItem(IDC_NUMBER_VALUE_BOX);

	m_pAttr->SetDirty(TRUE);

	CString sValue;
	CEdit* pBox;

	if (m_bNumber)
	{
		pBox = pNumberBox;
	}
	else
	{
		pBox = pValueBox;
	}
	
	pBox->GetWindowText(sValue);

	m_sAttrValue.RemoveAll();
	m_sAttrValue.AddTail(sValue);
	HRESULT hr = m_pAttr->SetValues(m_sAttrValue);
	if (FAILED(hr))
	{
		ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
		return -1; //don't advance pages
	}
	return 0; //next page
}

/////////////////////////////////////////////////////////////////////////////////////////
// CCreateFinishPage

BEGIN_MESSAGE_MAP(CCreateFinishPage, CPropertyPageBase)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_BN_CLICKED(IDC_BUTTON_MORE, OnMore)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCreateFinishPage::CCreateFinishPage(UINT nID) : CPropertyPageBase(nID)
{
	m_bInitialized = FALSE;
}

CCreateFinishPage::~CCreateFinishPage()
{
}

BOOL CCreateFinishPage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();

	GetHolder()->SetWizardButtons(PSWIZB_FINISH);
	m_bInitialized = TRUE;
	return TRUE;
}

void CCreateFinishPage::OnMore()
{
	CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
	ASSERT(pHolder != NULL);
	pHolder->OnMore();
}

BOOL CCreateFinishPage::OnSetActive()
{
	GetHolder()->SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);
	return TRUE;
}

BOOL CCreateFinishPage::OnWizardFinish()
{
	CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
	ASSERT(pHolder != NULL);
	return pHolder->OnFinish();
}

////////////////////////////////////////////////////////////////////////////////////////
// CCreatePageHolder

CCreatePageHolder::	CCreatePageHolder(CContainerNode* pContNode, CADSIEditContainerNode* pNode, 
		CComponentDataObject* pComponentData) : CPropertyPageHolderBase(pContNode, pNode, pComponentData)
{
	ASSERT(pComponentData != NULL);
	ASSERT(pContNode != NULL);
	ASSERT(pContNode == GetContainerNode());
	m_pCurrentNode = pNode;
  m_pComponentData = pComponentData;

	m_bAutoDeletePages = FALSE; // we have the page as embedded member

	m_pClassPage = new CCreateClassPage(pNode);
	AddPageToList((CPropertyPageBase*)m_pClassPage);
}

CCreatePageHolder::~CCreatePageHolder()
{
	m_pageList.RemoveAll();
}

void CCreatePageHolder::AddAttrPage(CString sClass)
{
	RemoveAllPages();

	m_sClass = sClass;
	CStringList sMandList;
	GetMandatoryAttr(sClass, &sMandList);
	CString sAttr;

	if (!m_pCurrentNode->GetNamingAttribute(sClass, &m_sNamingAttr))
	{
		return;
	}

	// Remove attributes from list that do not need a page
	RemovePresetAttr(&sMandList);

	// find the naming attribute and put it first
	POSITION fpos = sMandList.Find(m_sNamingAttr.GetHead());
	if (fpos != NULL)
	{
		sMandList.AddHead(sMandList.GetAt(fpos));
		sMandList.RemoveAt(fpos);
	}
	else
	{
		sMandList.AddHead(m_sNamingAttr.GetHead());
	}

	POSITION pos = sMandList.GetHeadPosition();
	while (pos != NULL)
	{
		CCreateAttributePage* pAttrPage;
		sAttr = sMandList.GetNext(pos);

    // Maintain the list of attributes here so that we can pop up the prop page for more advanced editting
    CADSIAttr* pNewAttr = new CADSIAttr(sAttr);
    m_AttrList.AddTail(pNewAttr);
		pAttrPage = new CCreateAttributePage(IDD_CREATE_EMPTY_PAGE, pNewAttr);
		
    // Add the naming attribute as the first page so that they type the name first
		if (sAttr == m_sNamingAttr.GetHead())
		{
			m_pageList.AddHead(pAttrPage);
		}
		else
		{
			m_pageList.AddTail(pAttrPage);
		}
	}
  // Add the finish page to the end
  CCreateFinishPage* pFinishPage = new CCreateFinishPage(IDD_CREATE_LAST_PAGE);
  m_pageList.AddTail(pFinishPage);

  // Add the pages to the UI
	pos = m_pageList.GetHeadPosition();
	while (pos != NULL)
	{
		CPropertyPageBase* pAttrPage;
		pAttrPage = m_pageList.GetNext(pos);

		AddPageToList(pAttrPage);
		AddPageToSheet(pAttrPage);
	}
}

void CCreatePageHolder::RemovePresetAttr(CStringList* psMandList)
{
	// this is a hack to keep from trying to set properties that are not allowed to be set.
	POSITION fpos = psMandList->Find(_T("nTSecurityDescriptor"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
	fpos = psMandList->Find(_T("instanceType"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
	fpos = psMandList->Find(_T("objectClass"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
	fpos = psMandList->Find(_T("objectCategory"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
	fpos = psMandList->Find(_T("objectSid"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}

	fpos = psMandList->Find(_T("objectClassCategory"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
	fpos = psMandList->Find(_T("schemaIDGUID"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
	fpos = psMandList->Find(_T("defaultObjectCategory"));
	if (fpos != NULL)
	{
		psMandList->RemoveAt(fpos);
	}
}

void CCreatePageHolder::GetSchemaPath(CString sClass, CString& schema)
{
	m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData()->GetAbstractSchemaPath(schema);
	schema += sClass;
}

void CCreatePageHolder::GetMandatoryAttr(CString sClass, CStringList* sMandList)
{
	CComPtr<IADsClass> pClass;
	CString schema;
	HRESULT hr, hCredResult;

	GetSchemaPath(sClass, schema);

	CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetTreeNode());
	CConnectionData* pConnectData = m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData();

	hr = OpenObjectWithCredentials(
																 pConnectData, 
																 pConnectData->GetCredentialObject()->UseCredentials(),
																 (LPWSTR)(LPCWSTR)schema,
																 IID_IADsClass, 
																 (LPVOID*) &pClass,
																 NULL,
																 hCredResult
																 );

	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

	VARIANT var;
	VariantInit(&var);
	pClass->get_MandatoryProperties(&var);
	VariantToStringList( var, *sMandList );
	VariantClear(&var);	
}

void CCreatePageHolder::RemoveAllPages()
{
	while (!m_pageList.IsEmpty())
	{
		CPropertyPageBase* pPropPage = m_pageList.RemoveTail();
		RemovePageFromSheet(pPropPage);
		RemovePageFromList(pPropPage, FALSE);
		delete pPropPage;
	}
}

BOOL CCreatePageHolder::OnFinish()
{
  CWaitCursor cursor;

	CComPtr<IDirectoryObject> pDirObject;
	HRESULT hr, hCredResult;
	CString sContPath;
	
	m_pCurrentNode->GetADsObject()->GetPath(sContPath);

	CADSIEditContainerNode* pTreeNode = dynamic_cast<CADSIEditContainerNode*>(GetTreeNode());
	ASSERT(pTreeNode != NULL);
	CADSIEditConnectionNode* pConnectNode = pTreeNode->GetADsObject()->GetConnectionNode();
	CConnectionData* pConnectData = pConnectNode->GetConnectionData();

	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sContPath,
											 IID_IDirectoryObject, 
											 (LPVOID*) &pDirObject,
											 NULL,
											 hCredResult
											 );
  if ( FAILED(hr) )
  {
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return FALSE;
  }

	int iCount = m_AttrList.GetDirtyCount();
	ADS_ATTR_INFO* pAttrInfo;
	pAttrInfo = new ADS_ATTR_INFO[iCount + 1];  // Add an extra to specify the class type
	int idx = 0;

	pAttrInfo[idx].pszAttrName = L"objectClass";
	pAttrInfo[idx].dwControlCode = ADS_ATTR_UPDATE;
	pAttrInfo[idx].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
	pAttrInfo[idx].pADsValues = new ADSVALUE;
	pAttrInfo[idx].pADsValues->dwType = ADSTYPE_CASE_IGNORE_STRING;

	int iLength = m_sClass.GetLength();
	pAttrInfo[idx].pADsValues->CaseIgnoreString = new WCHAR[iLength + 1];
	wcscpy(pAttrInfo[idx].pADsValues->CaseIgnoreString, m_sClass);
	
	pAttrInfo[idx].dwNumValues = 1;
	idx++;

	POSITION pos = m_AttrList.GetHeadPosition();
	while(pos != NULL)
	{
    CADSIAttr* pAttr = m_AttrList.GetNext(pos);
    if (pAttr->IsDirty())
    {
		  pAttrInfo[idx] = *(pAttr->GetAttrInfo());
      idx++;
    }
	}

	// make the prefix uppercase
	CString sName(m_sName);
	int indx = sName.Find(L'=');

	if (indx != -1)
	{
		CString sPrefix, sRemaining;
		sPrefix = sName.Left(indx);
		sPrefix.MakeUpper();

		int iLen = sName.GetLength();
		sRemaining = sName.Right(iLen - indx);
		sName = sPrefix + sRemaining;
	}
  m_sName = sName;

	CString sEscapedName;
	hr = EscapePath(sEscapedName, sName);

	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return FALSE;
	}

  CComPtr<IDispatch> pDisp;
	hr = pDirObject->CreateDSObject((LPWSTR)(LPCWSTR)sEscapedName, pAttrInfo, idx, &pDisp);
  if ( FAILED(hr) )
  {
		//Format Error message and pop up a dialog
		ADSIEditErrorMessage(hr);
	  return FALSE;
  }
  delete pAttrInfo[0].pADsValues->CaseIgnoreString;
  delete pAttrInfo[0].pADsValues;
	delete[] pAttrInfo;

	// Get the IDirectoryObject of the new node
	//
	CComPtr<IDirectoryObject> pNewDirObject;
	hr = pDisp->QueryInterface(IID_IDirectoryObject, (LPVOID*)&pNewDirObject);
   
  if ( FAILED(hr) )
  {
		//Format Error message and pop up a dialog
		ADSIEditErrorMessage(hr);
	  return FALSE;
  }

	ADS_OBJECT_INFO* pInfo;
	hr = pNewDirObject->GetObjectInformation(&pInfo);
  if ( FAILED(hr) )
  {
		//Format Error message and pop up a dialog
		ADSIEditErrorMessage(hr);
	  return FALSE;
  }

	CADsObject* pObject = new CADsObject();

	// Name
  CString sDN;
	pObject->SetName(m_sName);
  GetDN(pInfo->pszObjectDN, sDN);
	pObject->SetDN(sDN);
	pObject->SetPath(pInfo->pszObjectDN);

	// Class
	pObject->SetClass(pInfo->pszClassName);

	//Get the class object so that we can get the properties
	//
	CString sServer, schema;
	pConnectNode->GetConnectionData()->GetAbstractSchemaPath(schema);
	schema += CString(pInfo->pszClassName);

	// bind to object with authentication
	//
	CComPtr<IADsClass> pClass;
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)schema,
											 IID_IADsClass, 
											 (LPVOID*) &pClass,
											 NULL,
											 hCredResult
											 );
	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return FALSE;
	}

	pObject->SetComplete(TRUE);

	short    bContainer;
	pClass->get_Container( &bContainer );
	if (bContainer == -1)
	{
		pObject->SetContainer(TRUE);
	  CADSIEditContainerNode *pNewContNode = new CADSIEditContainerNode(pObject);
	  pNewContNode->SetDisplayName(m_sName);

		pNewContNode->GetADsObject()->SetConnectionNode(pConnectNode);
 		VERIFY(pTreeNode->AddChildToListAndUI(pNewContNode, GetComponentData()));
    GetComponentData()->SetDescriptionBarText(pTreeNode);

		// Refresh any other subtrees of connections that contain this node
		//
		CList<CTreeNode*, CTreeNode*> foundNodeList;
		CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(pTreeNode->GetRootContainer());
		if (pRootNode != NULL)
		{
			BOOL bFound = pRootNode->FindNode(sContPath, foundNodeList);
			if (bFound)
			{
				POSITION posList = foundNodeList.GetHeadPosition();
				while (posList != NULL)
				{
					CADSIEditContainerNode* pFoundContNode = dynamic_cast<CADSIEditContainerNode*>(foundNodeList.GetNext(posList));
					if (pFoundContNode != NULL && pFoundContNode != pTreeNode && pFoundContNode != pConnectNode)
					{
						CADSIEditContainerNode* pNewFoundNode = new CADSIEditContainerNode(pNewContNode);
						pNewFoundNode->GetADsObject()->SetConnectionNode(pFoundContNode->GetADsObject()->GetConnectionNode());
				 		VERIFY(pFoundContNode->AddChildToListAndUI(pNewFoundNode, GetComponentData()));
            GetComponentData()->SetDescriptionBarText(pFoundContNode);
					}
				}
			}
		}
	}
	else
	{
		pObject->SetContainer(FALSE);
		CADSIEditLeafNode *pLeafNode = new CADSIEditLeafNode(pObject);
	  pLeafNode->SetDisplayName(m_sName);
		pLeafNode->GetADsObject()->SetConnectionNode(pConnectNode);
 		VERIFY(pTreeNode->AddChildToListAndUI(pLeafNode, GetComponentData()));
    GetComponentData()->SetDescriptionBarText(pTreeNode);

		// Refresh any other subtrees of connections that contain this node
		//
		CList<CTreeNode*, CTreeNode*> foundNodeList;
		CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(pTreeNode->GetRootContainer());
		if (pRootNode != NULL)
		{
			BOOL bFound = pRootNode->FindNode(sContPath, foundNodeList);
			if (bFound)
			{
        POSITION posList = foundNodeList.GetHeadPosition();
				while (posList != NULL)
				{
					CADSIEditContainerNode* pFoundContNode = dynamic_cast<CADSIEditContainerNode*>(foundNodeList.GetNext(posList));
					if (pFoundContNode != NULL && pFoundContNode != pTreeNode && pFoundContNode != pConnectNode)
					{
						CADSIEditLeafNode* pNewFoundNode = new CADSIEditLeafNode(pLeafNode);
						pNewFoundNode->GetADsObject()->SetConnectionNode(pFoundContNode->GetADsObject()->GetConnectionNode());
				 		VERIFY(pFoundContNode->AddChildToListAndUI(pNewFoundNode, GetComponentData()));
            GetComponentData()->SetDescriptionBarText(pFoundContNode);
					}
				}
			}
		}
	}

	FreeADsMem(pInfo);
	return TRUE;
}

HRESULT CCreatePageHolder::EscapePath(CString& sEscapedName, const CString& sName)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	CComBSTR bstrEscaped;
	hr = pIADsPathname->GetEscapedElement(0, //reserved
														(BSTR)(LPCWSTR)sName,
														&bstrEscaped);
	sEscapedName = bstrEscaped;
	return hr;
}


void CCreatePageHolder::GetDN(PWSTR pwszName, CString& sDN)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	hr = pIADsPathname->Set(pwszName, ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
    sDN = L"";
    return;
  }

	// Get the leaf DN
	CComBSTR bstrDN;
	hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDN = L"";
	}
	else
	{
		sDN = bstrDN;
	}
}

void CCreatePageHolder::OnMore()
{
  CString sServer;
  m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData()->GetDomainServer(sServer);
  CCreateWizPropertyPageHolder propPage(m_pCurrentNode, m_pComponentData, m_sClass, sServer, &m_AttrList);

  if (propPage.DoModalDialog(m_sName) == IDOK)
  {
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\connection.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connection.h
//
//--------------------------------------------------------------------------


#ifndef _CONNECTION_H
#define _CONNECTION_H

#include "editor.h"
#include "resource.h"
#include "snapdata.h"
#include "querynode.h"
#include "schemacache.h"

///////////////////////////////////////////////////////////////////

#define MAX_CONNECT_NAME_LENGTH 255

///////////////////////////////////////////////////////////////////
// CADSIConnectionNode

class CADSIEditConnectionNode : public CADSIEditContainerNode
{
public:

	CADSIEditConnectionNode(CConnectionData* pConnectData) 
	{
		m_pConnectData = new CConnectionData(pConnectData);
    HRESULT hr = m_SchemaCache.Initialize();
    ASSERT(SUCCEEDED(hr));
	}
	
	CADSIEditConnectionNode(LPCWSTR lpszDisplayName) 
	{ 
		SetDisplayName(lpszDisplayName); 
    HRESULT hr = m_SchemaCache.Initialize();
    ASSERT(SUCCEEDED(hr));
	}

	~CADSIEditConnectionNode();

	// node info
	DECLARE_NODE_GUID()

	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
	void EnumerateQueries();
	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem, 
                        long *pInsertionAllowed);
	virtual void OnSettings(CComponentDataObject* pComponentData);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type,
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnRemove(CComponentDataObject* pComponentData);
	virtual void OnFilter(CComponentDataObject* pComponentData);
  virtual void OnUpdateSchema();
	virtual void OnNewQuery(CComponentDataObject* pComponentData);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual void OnCreate(CComponentDataObject* pComponentData);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);

	HRESULT SaveToStream(IStream* pStm);
	static HRESULT CreateFromStream(IStream* pStm, CADSIEditConnectionNode** ppConnectionNode);
	void SaveQueryListToStream(IStream* pStm);
	void LoadQueryListFromStream(IStream* pStm);
	void BuildQueryPath(const CString& sPath, CString& sRootPath);

	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
			{ return CADSIEditConnectMenuHolder::GetContextMenuItem(); }

	CADSIEditConnectionNode* GetConnectionNode() { return this; }
	void SetConnectionNode(CADSIEditConnectionNode* pConnect) { m_pConnectData->SetConnectionNode(pConnect); }

  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);

	int GetImageIndex(BOOL bOpenImage);
	void OnChangeState(CComponentDataObject* pComponentDataObject);

	virtual BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);

	virtual CADsObject* GetADsObject() { return m_pConnectData; }
	virtual CConnectionData* GetConnectionData() { return m_pConnectData; }

	// Accessors to query list
	void AddQueryToList(CADSIEditQueryData* pQueryData)
	{
		m_queryList.AddHead(pQueryData);
	}

	void RemoveQueryFromList(CADSIEditQueryData* pQueryData)
	{
		POSITION pos = m_queryList.Find(pQueryData);
		if (pos != NULL)
		{
			CADSIEditQueryData* pData = m_queryList.GetAt(pos);
			m_queryList.RemoveAt(pos);
			delete pData;
		}
	}

	void RemoveAndDeleteAllQueriesFromList()
	{
		POSITION pos = m_queryList.GetHeadPosition();
		while (pos != NULL)
		{
			CADSIEditQueryData* pQueryData = m_queryList.GetNext(pos);
			delete pQueryData;
		}
	}

	void RemoveAllQueriesFromList()
	{
		m_queryList.RemoveAll();
	}


	BOOL HasQueries()
	{
		return (m_queryList.GetCount() > 0);
	}

	CList<CADSIEditQueryData*, CADSIEditQueryData*>* GetQueryList() { return &m_queryList; }

  bool IsClassAContainer(CCredentialObject* pCredObject,
                         PCWSTR pszClass, 
                         PCWSTR pszSchemaPath);

private:
	CConnectionData* m_pConnectData;

	CList<CADSIEditQueryData*, CADSIEditQueryData*> m_queryList;
  CADSIEditSchemaCache m_SchemaCache;
};


#endif _CONNECTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\credui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       credui.cpp
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////
// credui.cpp
#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "editor.h"
#include "credui.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MESSAGE_MAP(CCredentialDialog, CDialog)
END_MESSAGE_MAP()

CCredentialDialog::CCredentialDialog(CCredentialObject* pCredObject, 
																		 LPCWSTR lpszConnectName,
																		 CWnd* pCWnd)
																		: CDialog(IDD_CREDENTIAL_DIALOG, pCWnd)
{
	m_sConnectName = lpszConnectName;
	m_pCredObject = pCredObject;
}


CCredentialDialog::~CCredentialDialog()
{
}

BOOL CCredentialDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CEdit* pUserBox = (CEdit*) GetDlgItem(IDC_USERNAME);
	CEdit* pPassBox = (CEdit*) GetDlgItem(IDC_PASSWORD);
	CStatic* pConnectStatic = (CStatic*) GetDlgItem(IDC_CONNECTION_STATIC);

	CString sUsername;
	m_pCredObject->GetUsername(sUsername);
	pUserBox->SetWindowText(sUsername);

	CString sStatic;
	pConnectStatic->GetWindowText(sStatic);
	sStatic += m_sConnectName + _T("\":");
	pConnectStatic->SetWindowText(sStatic);

	pPassBox->SetLimitText(MAX_PASSWORD_LENGTH);
	return TRUE;
}

void CCredentialDialog::OnOK()
{
	CEdit* pUserBox = (CEdit*) GetDlgItem(IDC_USERNAME);
	CEdit* pPassBox = (CEdit*) GetDlgItem(IDC_PASSWORD);

	CString sUsername;
	pUserBox->GetWindowText(sUsername);

	HWND hWnd = pPassBox->GetSafeHwnd();

	m_pCredObject->SetUsername(sUsername);
	m_pCredObject->SetPasswordFromHwnd(hWnd);

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\connectui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connectui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "connection.h"
#include "connectionui.h"
#include <aclpage.h>


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_lpszGC;
extern LPCWSTR g_lpszLDAP;
extern LPCWSTR g_lpszRootDSE;

///////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CADSIEditConnectDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_CBN_SELCHANGE(IDC_NC_BOX, OnSelChangeContextList)
	ON_CBN_SELCHANGE(IDC_DOMAIN_SERVER_BOX, OnSelChangeDSList)
	ON_CBN_SELCHANGE(IDC_DN_BOX, OnSelChangeDNList)
	ON_CBN_EDITCHANGE(IDC_DOMAIN_SERVER_BOX, OnEditChangeDSList)
	ON_CBN_EDITCHANGE(IDC_DN_BOX, OnEditChangeDNList)
	ON_BN_CLICKED(IDC_DN_RADIO, OnDNRadio)
	ON_BN_CLICKED(IDC_NC_RADIO, OnNCRadio)
	ON_BN_CLICKED(IDC_DOMAIN_SERVER_RADIO, OnDSRadio)
	ON_BN_CLICKED(IDC_DEFAULT_RADIO, OnDefaultRadio)
	ON_BN_CLICKED(IDC_ADVANCED_BUTTON, OnAdvanced)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIEditConnectDialog::CADSIEditConnectDialog(CContainerNode* pRootnode,
															  CTreeNode* pTreeNode,
															  CComponentDataObject* pComponentData,
															  CConnectionData* pConnectData
															 ) : CDialog(IDD_CONNECTION_DIALOG)
{
	m_pContainerNode = pRootnode;
	m_pTreeNode = pTreeNode;
	m_pComponentData = pComponentData;
	m_pNewConnectData = pConnectData;
	m_szDisplayExtra = L"";
	m_sDefaultServerName = L"";
}

CADSIEditConnectDialog::~CADSIEditConnectDialog()
{
  if (m_bNewConnect && m_pNewConnectData != NULL)
    delete m_pNewConnectData;
}


BOOL CADSIEditConnectDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CConnectionData* pConnectData = GetConnectionData();

	if (pConnectData == NULL)
	{
		m_pNewConnectData = new CConnectionData();
    if (m_pNewConnectData)
    {
		  m_bNewConnect = TRUE;

		  CString sServerName;
		  m_pNewConnectData->GetDomainServer(sServerName);

		  if (sServerName == L"")
		  {
			  HRESULT hr = CConnectionData::GetServerNameFromDefault(m_pNewConnectData);
        if (SUCCEEDED(hr))
        {
			    m_pNewConnectData->GetDomainServer(m_sDefaultServerName);
        }
		  }
		  m_pNewConnectData->GetDomainServer(m_szDisplayExtra);
    }
	}
	else
	{
		m_pNewConnectData = pConnectData;
		m_bNewConnect = FALSE;
	}

	LoadNamingContext();
	SetupUI();
	SetDirty();

	return TRUE;
}

void CADSIEditConnectDialog::LoadNamingContext()
{
	CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);

	m_szDomain.LoadString(IDS_DOMAIN_NC);
	m_szConfigContainer.LoadString(IDS_CONFIG_CONTAINER);
	m_szRootDSE.LoadString(IDS_ROOTDSE);
	m_szSchema.LoadString(IDS_SCHEMA);

	pcNCBox->AddString(m_szDomain);
	pcNCBox->AddString(m_szConfigContainer);
	pcNCBox->AddString(m_szRootDSE);
	pcNCBox->AddString(m_szSchema);
}

void CADSIEditConnectDialog::SetupUI()
{
	CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);
	CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);
	CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);
	CButton* pcDSRadio	= (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
	CButton* pcDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);
	CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);


	//Setup UI to reflect data
	LoadMRUs();

	CString  sDistinguishedName;
	m_pNewConnectData->GetDistinguishedName(sDistinguishedName);

	if (!sDistinguishedName.IsEmpty())
	{
		int iIndex = pcDNBox->FindStringExact(-1, sDistinguishedName);
		if (iIndex != CB_ERR)
		{
			pcDNBox->SetCurSel(iIndex);
		}
		else
		{
			int nIndex = pcDNBox->AddString(sDistinguishedName);
			pcDNBox->SetCurSel(nIndex);
		}
		OnSelChangeDNList();
		pcDNRadio->SetCheck(BST_CHECKED);
	}
	else
	{
		CString sNamingContext;
		m_pNewConnectData->GetNamingContext(sNamingContext);

		int iIndex = pcNCBox->FindStringExact(-1, sNamingContext);
		if (iIndex != CB_ERR)
		{
			pcNCBox->SetCurSel(iIndex);

		}
		else
		{
			pcNCBox->SetCurSel(0);
		}
		OnSelChangeContextList();
		pcNCRadio->SetCheck(BST_CHECKED);
	}

	CString sServer;
	m_pNewConnectData->GetDomainServer(sServer);

	BOOL bUserDefinedServer;
	bUserDefinedServer = m_pNewConnectData->GetUserDefinedServer();

	if (!sServer.IsEmpty() && bUserDefinedServer)
	{
		int iIndex = pcDomainServerBox->FindStringExact(-1, sServer);
		if (iIndex != CB_ERR)
		{
			pcDomainServerBox->SetCurSel(iIndex);
		}
		else
		{
			int nIndex = pcDomainServerBox->AddString(sServer);
			pcDomainServerBox->SetCurSel(nIndex);
		}
		OnSelChangeDSList();
		pcDSRadio->SetCheck(BST_CHECKED);
	}
	else
	{
		pcDefaultRadio->SetCheck(BST_CHECKED);
	}
	CString sName;
	m_pNewConnectData->GetName(sName);

	pcNameBox->SetLimitText(MAX_CONNECT_NAME_LENGTH);
	if (sName.IsEmpty())
	{
		if (pcNCRadio->GetCheck())
		{
			CString szNCName;
			pcNCBox->GetLBText(pcNCBox->GetCurSel(), szNCName);
			pcNameBox->SetWindowText(szNCName);
			m_pNewConnectData->GetDomainServer(m_szDisplayExtra);
		}
		else
		{
			CString szMyConnection;
			szMyConnection.LoadString(IDS_MY_CONNECTION);
			pcNameBox->SetWindowText(szMyConnection);
		}
	}
	else
	{
		pcNameBox->SetWindowText(sName);
	}

	SetAndDisplayPath();
}

void CADSIEditConnectDialog::LoadMRUs()
{
	CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
	CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);

	CADSIEditRootData* pRootNode = GetRootNode();
	CStringList sServerMRU, sDNMRU;
	pRootNode->GetServerMRU(&sServerMRU);
	pRootNode->GetDNMRU(&sDNMRU);

	POSITION pos = sServerMRU.GetHeadPosition();
	while (pos != NULL)
	{
		CString sMRU;
		sMRU = sServerMRU.GetNext(pos);
		pcDomainServerBox->AddString(sMRU);
	}

	pos = sDNMRU.GetHeadPosition();
	while (pos != NULL)
	{
		CString sMRU;
		sMRU = sDNMRU.GetNext(pos);
		pcDNBox->AddString(sMRU);
	}
}

void CADSIEditConnectDialog::SaveMRUs()
{
	CADSIEditRootData* pRootNode = GetRootNode();
	CStringList sDNMRU, sServerMRU;
	CString sDS, sDN;
	BOOL bFound = FALSE;

	m_pNewConnectData->GetDistinguishedName(sDN);
	m_pNewConnectData->GetDomainServer(sDS);

	pRootNode->GetServerMRU(&sServerMRU);
	pRootNode->GetDNMRU(&sDNMRU);

	POSITION pos = sServerMRU.GetHeadPosition();
	while (pos != NULL)
	{
		CString sServer;
		sServer = sServerMRU.GetNext(pos);
		if (sServer == sDS)
		{
			bFound = TRUE;
			break;
		}
	}

	if (!bFound && !sDS.IsEmpty())
	{
		sServerMRU.AddHead(sDS);
		pRootNode->SetServerMRU(&sServerMRU);
	}

	bFound = FALSE;
	pos = sDNMRU.GetHeadPosition();
	while (pos != NULL)
	{
		CString sDistinguishedName;
		sDistinguishedName = sDNMRU.GetNext(pos);
		if (sDistinguishedName == sDN)
		{
			bFound = TRUE;
			break;
		}
	}

	if (!bFound && !sDN.IsEmpty())
	{
		sDNMRU.AddHead(sDN);
		pRootNode->SetDNMRU(&sDNMRU);
	}
}

void CADSIEditConnectDialog::OnDNRadio()
{
	SetDirty();
	SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnNCRadio()
{
	SetDirty();
	SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnDSRadio()
{
	CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);

	CString szDS;
	pcDomainServerBox->GetWindowText(szDS);
	m_pNewConnectData->SetDomainServer(szDS);
	m_pNewConnectData->SetUserDefinedServer(TRUE);

	SetDirty();
	SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnDefaultRadio()
{
	m_pNewConnectData->SetUserDefinedServer(FALSE);

  if (m_pNewConnectData->IsGC())
  {
    m_pNewConnectData->SetDomainServer(L"");
  }
  else
  {
    m_pNewConnectData->SetDomainServer(m_sDefaultServerName);
  }

	SetDirty();
	SetAndDisplayPath();
}

void CADSIEditConnectDialog::SetAndDisplayPath()
{
	CEdit* pcPathBox = (CEdit*)GetDlgItem(IDC_FULLPATH_BOX);
	CButton* pcDSRadio	= (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);

	// Get data from connection node
	//
	CString szLDAP, sServer, sPort, sDistinguishedName, sNamingContext;
	m_pNewConnectData->GetLDAP(szLDAP);
	m_pNewConnectData->GetDomainServer(sServer);
	m_pNewConnectData->GetPort(sPort);
	m_pNewConnectData->GetDistinguishedName(sDistinguishedName);
	m_pNewConnectData->GetNamingContext(sNamingContext);
	m_pNewConnectData->SetRootDSE(FALSE);

	CString szFullPath;
	if (!sServer.IsEmpty())
	{
		szFullPath = szFullPath + sServer;
		if (!sPort.IsEmpty())
		{
			szFullPath = szFullPath + _T(":") + sPort + _T("/");
		}
		else
		{
			szFullPath = szFullPath + _T("/");
		}
	}

	if (pcDNRadio->GetCheck() && !sDistinguishedName.IsEmpty())
	{
		szFullPath = szFullPath + sDistinguishedName;
		if (wcscmp(sDistinguishedName, g_lpszRootDSE) == 0)
		{
			m_pNewConnectData->SetRootDSE(TRUE);
		}
	}
	else
	{
		szFullPath = szFullPath + sNamingContext;
		if (wcscmp(sNamingContext, g_lpszRootDSE) == 0)
		{
			m_pNewConnectData->SetRootDSE(TRUE);
		}
	}	

	m_pNewConnectData->GetDomainServer(m_szDisplayExtra);
	m_szDisplayExtra = L" [" + m_szDisplayExtra + L"]";

	szFullPath = szLDAP + szFullPath;
	pcPathBox->SetWindowText(szFullPath);
}

void CADSIEditConnectDialog::OnSelChangeContextList()
{
	CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);
	CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);

	CString szContext;
	SetDirty();
	pcNCBox->GetLBText(pcNCBox->GetCurSel(), szContext);
	m_pNewConnectData->SetNamingContext(szContext);
	pcNCRadio->SetCheck(BST_CHECKED);
	pcDNRadio->SetCheck(BST_UNCHECKED);

	CString sName;
	pcNCBox->GetLBText(pcNCBox->GetCurSel(), sName);
	pcNameBox->SetWindowText(sName);

	SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnSelChangeDSList()
{
	CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
	CButton* pcDSRadio	= (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
	CButton* pcDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);

	SetDirty();
	if (pcDomainServerBox->GetCount() > 0)
	{
		CString sServer;
		pcDomainServerBox->GetLBText(pcDomainServerBox->GetCurSel(), sServer);
		m_pNewConnectData->SetDomainServer(sServer);
		m_pNewConnectData->SetUserDefinedServer(TRUE);
	}
	pcDSRadio->SetCheck(BST_CHECKED);
	pcDefaultRadio->SetCheck(BST_UNCHECKED);
	SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnSelChangeDNList()
{
	CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

	SetDirty();
	if (pcDNBox->GetCount() > 0)
	{
		CString sDistinguishedName;
		pcDNBox->GetLBText(pcDNBox->GetCurSel(), sDistinguishedName);
		m_pNewConnectData->SetDistinguishedName(sDistinguishedName);
	}
	pcDNRadio->SetCheck(BST_CHECKED);
	pcNCRadio->SetCheck(BST_UNCHECKED);
	SetAndDisplayPath();
}


void CADSIEditConnectDialog::OnEditChangeDSList()
{
	CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
	CButton* pcDSRadio	= (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
	CButton* pcDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);

	SetDirty();
	CString szDS, sOldDS;

	pcDomainServerBox->GetWindowText(szDS);
	m_pNewConnectData->SetDomainServer(szDS);

	pcDSRadio->SetCheck(BST_CHECKED);
	pcDefaultRadio->SetCheck(BST_UNCHECKED);
	SetAndDisplayPath();
	m_pNewConnectData->SetUserDefinedServer(TRUE);
}

void CADSIEditConnectDialog::OnEditChangeDNList()
{
	CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

	SetDirty();
	CString s, sOldDN;

	pcDNBox->GetWindowText(s);
	m_pNewConnectData->SetDistinguishedName(s);

	pcDNRadio->SetCheck(BST_CHECKED);
	pcNCRadio->SetCheck(BST_UNCHECKED);
	SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnAdvanced()
{
  CWaitCursor cursor;
	CADSIEditRootData* pRootNode = GetRootNode();
	
	CADSIEditAdvancedConnectionDialog AdvancedDialog(NULL, 
																	 pRootNode, 
																	 m_pComponentData, 
																	 m_pNewConnectData);
	if (AdvancedDialog.DoModal() == IDOK)
	{
    cursor.Restore();
    if (m_pNewConnectData->IsGC() && !m_pNewConnectData->GetUserDefinedServer())
    {
      m_pNewConnectData->SetDomainServer(L"");
    }
    else if (!m_pNewConnectData->IsGC())
    {
			CConnectionData::GetServerNameFromDefault(m_pNewConnectData);
    }

		SetDirty();
		SetAndDisplayPath();
	}
}

void CADSIEditConnectDialog::OnOK()
{
	if (OnApply())
	{
		CDialog::OnOK();
	}
}

BOOL CADSIEditConnectDialog::OnApply()
{
	CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);

	CADSIEditRootData* pRootNode = GetRootNode();
	ASSERT(pRootNode != NULL);
	CComponentDataObject* pComponentData = GetComponentData();

	BSTR bstrPath;

	CString sName;
	pcNameBox->GetWindowText(sName);
	m_pNewConnectData->SetName(sName);

	if (m_bDirty)
	{
		if (!DoDirty())
		{
			return FALSE;
		}
	}
	else
	{
		if (pRootNode->GetDisplayName() != sName)
		{
			pRootNode->SetDisplayName(sName + m_szDisplayExtra);
		}
		else
		{
			ADSIEditMessageBox(IDS_MSG_CONNECTION_NAME, MB_OK);
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CADSIEditConnectDialog::DoDirty()
{
	CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);

	CADSIEditContainerNode* pTreeNode = dynamic_cast<CADSIEditContainerNode*>(GetTreeNode());

	CADSIEditRootData* pRootNode = GetRootNode();
	ASSERT(pRootNode != NULL);
	CComponentDataObject* pComponentData = GetComponentData();

	SaveMRUs();

	CString sRootDSE, s;
	BuildRootDSE(sRootDSE);

	CComPtr<IADs> spRootADs;
	HRESULT hr, hCredResult;
	hr = OpenObjectWithCredentials(
											 m_pNewConnectData, 
											 m_pNewConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sRootDSE,
											 IID_IADs, 
											 (LPVOID*) &spRootADs,
											 GetSafeHwnd(),
											 hCredResult
											 );
	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return FALSE;
	}

	CString sNamingContext, sDistinguishedName, sServerName;
	m_pNewConnectData->GetNamingContext(sNamingContext);
	m_pNewConnectData->GetDistinguishedName(sDistinguishedName);

	if ( m_pNewConnectData->IsRootDSE())
	{
		s = g_lpszRootDSE;
		if (!m_bNewConnect)
		{
			CString sName;
			pcNameBox->GetWindowText(sName);
			m_pNewConnectData->SetName(sName);

      CString szProvider, sServer, sPort, sPath;
	    m_pNewConnectData->GetDomainServer(sServer);
	    m_pNewConnectData->GetPort(sPort);
      m_pNewConnectData->GetLDAP(szProvider);

      if (sServer != _T(""))
      {
        if (sPort != _T(""))
        {
          sPath = szProvider + sServer + _T(":") + sPort + _T("/") + CString(sName);
        }
        else
        {
          sPath = szProvider + sServer + _T("/") + CString(sName);
        }
      }
      else
      {
        sPath = szProvider + CString(sName);
      }
 			m_pNewConnectData->SetPath(sPath);
			
			ASSERT(pTreeNode != NULL);
			pTreeNode->SetDisplayName(sName + m_szDisplayExtra);
			m_pNewConnectData->SetBasePath(_T(""));
		}
		else
		{
			// Name
			LPWSTR objectName;
			spRootADs->get_Name(&objectName);
			if (objectName == NULL)
			{
				ADSIEditMessageBox(IDS_MSG_ROOTDSE_ERROR, MB_OK);
				return FALSE;
			}
			m_pNewConnectData->SetName(objectName);

      CString szProvider, sServer, sPort, sPath;
	    m_pNewConnectData->GetDomainServer(sServer);
	    m_pNewConnectData->GetPort(sPort);
      m_pNewConnectData->GetLDAP(szProvider);

      if (sServer != _T(""))
      {
        if (sPort != _T(""))
        {
          sPath = szProvider + sServer + _T(":") + sPort + _T("/") + CString(objectName);
        }
        else
        {
          sPath = szProvider + sServer + _T("/") + CString(objectName);
        }
      }
      else
      {
        sPath = szProvider + CString(objectName);
      }
 			m_pNewConnectData->SetPath(sPath);

      m_pNewConnectData->SetClass(_T(""));

			CString sName;
			pcNameBox->GetWindowText(sName);
			if (sName.GetLength() > 0)
			{
				//Create a connection node
				m_pNewConnectData->SetName(sName);
				CADSIEditConnectionNode *pConnectNode = new CADSIEditConnectionNode(m_pNewConnectData);
				pConnectNode->SetDisplayName(sName + m_szDisplayExtra);
				pConnectNode->GetConnectionData()->SetConnectionNode(pConnectNode);
				VERIFY(pRootNode->AddChildToListAndUI(pConnectNode, pComponentData));
        pComponentData->SetDescriptionBarText(pRootNode);
			}
	
			else
			{
				ADSIEditMessageBox(IDS_MSG_CONNECTION_NAME, MB_OK);
				return FALSE;
			}
		}
	}		//if RootDSE
	else
	{
		CComBSTR bstrPath;
		if (!BuildNamingContext(bstrPath))
		{
			return FALSE;
		}

		if (!BuildPath(s, (BSTR)bstrPath, spRootADs))
		{
			return FALSE;
		}
		
		if (!m_bNewConnect)
		{
			CString sName;
			pcNameBox->GetWindowText(sName);
			m_pNewConnectData->SetName(sName);
			m_pNewConnectData->SetPath(s);

			ASSERT(pTreeNode != NULL);
			pTreeNode->SetDisplayName(sName + m_szDisplayExtra);

			if (!pTreeNode->OnEnumerate(pComponentData))
			{
				return FALSE;
			}

/*			if (!pTreeNode->OnRefresh(pComponentData))
			{
				return FALSE;
			}
			*/
		}
		else
		{
			CComPtr<IDirectoryObject> spDirObject;

			hr = OpenObjectWithCredentials(
													 m_pNewConnectData, 
													 m_pNewConnectData->GetCredentialObject()->UseCredentials(),
													 (LPWSTR)(LPCWSTR)s,
													 IID_IDirectoryObject, 
													 (LPVOID*) &spDirObject,
													 GetSafeHwnd(),
													 hCredResult
													);
			if ( FAILED(hr) )
			{
				if (SUCCEEDED(hCredResult))
				{
					ADSIEditErrorMessage(hr);
				}
				return FALSE;
			}

			ADS_OBJECT_INFO* pInfo;
			hr = spDirObject->GetObjectInformation(&pInfo);
			if (FAILED(hr))
			{
				ADSIEditErrorMessage(hr);
				return FALSE;
			}

			// Name
			m_pNewConnectData->SetName(pInfo->pszRDN);
			m_pNewConnectData->SetPath(s);

			// Class
			m_pNewConnectData->SetClass(pInfo->pszClassName);
			FreeADsMem(pInfo);

			CString sName;
			pcNameBox->GetWindowText(sName);
			if (sName.GetLength() > 0)
			{
				//Create a connection node
				m_pNewConnectData->SetName(sName);
				CADSIEditConnectionNode *pConnectNode = new CADSIEditConnectionNode(m_pNewConnectData);
				pConnectNode->SetDisplayName(sName + m_szDisplayExtra);
				pConnectNode->GetConnectionData()->SetConnectionNode(pConnectNode);
				VERIFY(pRootNode->AddChildToListAndUI(pConnectNode, pComponentData));
        pComponentData->SetDescriptionBarText(pRootNode);
			}
			else
			{
				ADSIEditMessageBox(IDS_MSG_CONNECTION_NAME, MB_OK);
				return FALSE;
			}
		}
	}		//else

	return TRUE;
}

BOOL CADSIEditConnectDialog::BuildPath(CString& s, BSTR bstrPath, IADs* pADs)
{
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

	HRESULT hr;
	CString szLDAP, basePath, sServer, sPort, sDistinguishedName;
	m_pNewConnectData->GetLDAP(szLDAP);
	m_pNewConnectData->GetDomainServer(sServer);
	m_pNewConnectData->GetPort(sPort);
	m_pNewConnectData->GetDistinguishedName(sDistinguishedName);

	if ( pcNCRadio->GetCheck())
	{
		VARIANT var;
		VariantInit(&var);
		hr = pADs->Get( bstrPath, &var );

		if ( FAILED(hr) )
		{
			VariantClear(&var);
			return FALSE;
		}

		if (!sServer.IsEmpty())
		{
			s = s + sServer;
			if (!sPort.IsEmpty())
			{
				s = s + _T(":") + sPort + _T("/");
			}
			else
			{
				s = s + _T("/");
			}
		}
		s = s  + V_BSTR(&var);
		basePath = V_BSTR(&var);
		VariantClear(&var);
	}
	else if(pcDNRadio->GetCheck())
	{
		if (!sServer.IsEmpty())
		{
			s = s + sServer;
			if (!sPort.IsEmpty())
			{
				s = s + _T(":") + sPort + _T("/");
			}
			else
			{
				s = s + _T("/");
			}
		}
		s = s + sDistinguishedName;
		basePath = sDistinguishedName;
	}

	m_pNewConnectData->SetBasePath(basePath);
	s = szLDAP + s;
	return TRUE;
}

BOOL CADSIEditConnectDialog::BuildNamingContext(CComBSTR& bstrPath)
{
	CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
	CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

	CString sNamingContext;
	m_pNewConnectData->GetNamingContext(sNamingContext);

	if ( pcNCRadio->GetCheck())
	{
		if ( sNamingContext == m_szDomain)
		{
			bstrPath = SysAllocString( L"defaultNamingContext");
		}
		else if ( sNamingContext == m_szSchema)
		{
			bstrPath = SysAllocString(L"schemaNamingContext");
		}
		else if ( sNamingContext == m_szConfigContainer)
		{
			bstrPath = SysAllocString(L"configurationNamingContext");
		}
		else
		{
			bstrPath = SysAllocString( L"defaultNamingContext");
		}	
		m_pNewConnectData->SetDistinguishedName(_T(""));
	}
	else if (pcDNRadio->GetCheck())
	{
		CString sDistinguishedName;
		m_pNewConnectData->GetDistinguishedName(sDistinguishedName);
		if (sDistinguishedName.Find(L'=') == -1)
		{
			int iResult = ADSIEditMessageBox(IDS_MSG_NOT_X500_PATH,	MB_YESNO);
			if (iResult ==	IDNO)
			{
				return FALSE;
			}
		}
		bstrPath = sDistinguishedName.AllocSysString();
		m_pNewConnectData->SetNamingContext(_T(""));
	}
	return TRUE;
}

void CADSIEditConnectDialog::BuildRootDSE(CString& sRootDSE)
{
	CButton* pDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);

	CString sServer, sPort, sLDAP;
	m_pNewConnectData->GetDomainServer(sServer);
	m_pNewConnectData->GetPort(sPort);
	m_pNewConnectData->GetLDAP(sLDAP);

	if (!sServer.IsEmpty())
	{
		sRootDSE = sLDAP + sServer;
		if (!sPort.IsEmpty())
		{
			sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
		}
		else
		{
			sRootDSE = sRootDSE + _T("/");
		}
		sRootDSE = sRootDSE + g_lpszRootDSE;
	}
	else
	{
		sRootDSE = sLDAP + g_lpszRootDSE;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// CADSIEditAdvancedConnectionDialog :

BEGIN_MESSAGE_MAP(CADSIEditAdvancedConnectionDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_BN_CLICKED(IDC_CREDENTIALS_CHECK, OnCredentials)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CADSIEditAdvancedConnectionDialog::CADSIEditAdvancedConnectionDialog(CContainerNode* pRootDataNode, 
			CTreeNode* pContainerNode, CComponentDataObject* pComponentData, CConnectionData* pConnectData) 
				: CDialog(IDD_CONNECTION_ADVANCED)
{
	// Get the local data
	//
	m_pTreeNode = pContainerNode;
	m_pContainerNode = pRootDataNode;
	ASSERT(pComponentData != NULL);
	m_pComponentData = pComponentData;
	ASSERT(pConnectData != NULL);
	m_pConnectData = pConnectData;
}

CADSIEditAdvancedConnectionDialog::~CADSIEditAdvancedConnectionDialog() 
{
}

BOOL CADSIEditAdvancedConnectionDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Attach all the controls
	//
	CEdit* pcPortBox = (CEdit*)GetDlgItem(IDC_PORT);
	CButton* pcLDAPRadio = (CButton*)GetDlgItem(IDC_LDAP_RADIO);
	CButton* pcGCRadio = (CButton*)GetDlgItem(IDC_GC_RADIO);
	CButton* pcCredCheck = (CButton*)GetDlgItem(IDC_CREDENTIALS_CHECK);
	CEdit* pcUsernameBox = (CEdit*)GetDlgItem(IDC_USERNAME);
	CEdit* pcPasswordBox = (CEdit*)GetDlgItem(IDC_PASSWORD);

  // disable IME support on numeric edit fields
  ImmAssociateContext(pcPortBox->GetSafeHwnd(), NULL);

	// Set the initial state of the controls
	//
	CString sLDAP;
	m_pConnectData->GetLDAP(sLDAP);

	if (wcscmp(sLDAP, g_lpszLDAP) == 0)
	{
		pcLDAPRadio->SetCheck(BST_CHECKED);
	}
	else
	{
		pcGCRadio->SetCheck(BST_CHECKED);
	}

	CString sPort;
	m_pConnectData->GetPort(sPort);
	pcPortBox->SetWindowText(sPort);

	if (m_pConnectData->GetCredentialObject()->UseCredentials())
	{
		CString sUser;
		m_pConnectData->GetCredentialObject()->GetUsername(sUser);
		pcCredCheck->SetCheck(TRUE);
		OnCredentials();
		pcUsernameBox->SetWindowText(sUser);
	}

	pcPasswordBox->SetLimitText(MAX_PASSWORD_LENGTH);

	return TRUE;
}

void CADSIEditAdvancedConnectionDialog::OnOK()
{
	OnApply();
	CDialog::OnOK();
}

BOOL CADSIEditAdvancedConnectionDialog::OnApply()
{
	CEdit* pcPortBox = (CEdit*)GetDlgItem(IDC_PORT);
	CButton* pcLDAPRadio = (CButton*)GetDlgItem(IDC_LDAP_RADIO);
	CButton* pcCredCheck = (CButton*)GetDlgItem(IDC_CREDENTIALS_CHECK);
	CEdit* pcUsernameBox = (CEdit*)GetDlgItem(IDC_USERNAME);
	CEdit* pcPasswordBox = (CEdit*)GetDlgItem(IDC_PASSWORD);

	// Make the connection data reflect the controls
	//
	CString sPort;
	pcPortBox->GetWindowText(sPort);
	m_pConnectData->SetPort(sPort);

	if (pcLDAPRadio->GetCheck())
	{
		m_pConnectData->SetLDAP(g_lpszLDAP);
	}
	else
	{
		m_pConnectData->SetLDAP(g_lpszGC);
	}

	if (pcCredCheck->GetCheck())
	{
		// Get user name and password
		//
		CString sUser;
		pcUsernameBox->GetWindowText(sUser);
		
		HWND hWnd = pcPasswordBox->GetSafeHwnd();
		m_pConnectData->GetCredentialObject()->SetUsername(sUser);
		m_pConnectData->GetCredentialObject()->SetPasswordFromHwnd(hWnd);
		m_pConnectData->GetCredentialObject()->SetUseCredentials(TRUE);
	}
	else
	{
		m_pConnectData->GetCredentialObject()->SetUseCredentials(FALSE);
	}

	return TRUE;
}

void CADSIEditAdvancedConnectionDialog::OnCredentials()
{
	CButton* pcCredCheck = (CButton*)GetDlgItem(IDC_CREDENTIALS_CHECK);
	CButton* pcCredGroup = (CButton*)GetDlgItem(IDC_CREDENTIALS_GROUP);
	CStatic* pcCredUser = (CStatic*)GetDlgItem(IDC_CREDENTIALS_USER);
	CStatic* pcCredPassword = (CStatic*)GetDlgItem(IDC_CREDENTIALS_PASSWORD);
	CEdit* pcUsernameBox = (CEdit*)GetDlgItem(IDC_USERNAME);
	CEdit* pcPasswordBox = (CEdit*)GetDlgItem(IDC_PASSWORD);

	BOOL bResult = pcCredCheck->GetCheck();
	if (bResult)
	{
		// Enable Username and password fields
		//
		pcCredGroup->EnableWindow(bResult);
		pcCredUser->EnableWindow(bResult);
		pcCredPassword->EnableWindow(bResult);
		pcUsernameBox->EnableWindow(bResult);
		pcPasswordBox->EnableWindow(bResult);
	}
	else
	{
		// Enable Username and password fields
		//
		pcCredGroup->EnableWindow(FALSE);
		pcCredUser->EnableWindow(FALSE);
		pcCredPassword->EnableWindow(FALSE);
		pcUsernameBox->EnableWindow(FALSE);
		pcPasswordBox->EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\credui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       credui.h
//
//--------------------------------------------------------------------------

///////////////////////////////////////////
// credui.h
#ifndef _CREDUI_H
#define _CREDUI_H

#include "editor.h"

class CCredentialDialog : public CDialog
{
public :
	CCredentialDialog::CCredentialDialog(CCredentialObject* pCredObject,
																			 LPCWSTR lpszConnectName,
																			 CWnd* pCWnd);
	~CCredentialDialog();

	virtual BOOL OnInitDialog();
	virtual void OnOK();

private :
	CCredentialObject* m_pCredObject;
	CString m_sConnectName;

	DECLARE_MESSAGE_MAP()
};

#endif //_CREDUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\createwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       createwiz.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
// createwiz.h

#ifndef _CREATEWIZ_H
#define _CREATEWIZ_H

#include "attredit.h"
#include "editor.h"

enum
{
	first,
	middle,
	last
};

//////////////////////////////////////////////////////////////////////////
// CCreateClassPage

class CCreateClassPage : public CPropertyPageBase
{
public:
	CCreateClassPage(CADSIEditContainerNode* pCurrentNode);
	~CCreateClassPage();

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();

	virtual BOOL OnInitDialog();

protected:
	void FillList();

	CADSIEditContainerNode* m_pCurrentNode;

	CString m_sClass;

	DECLARE_MESSAGE_MAP()

}; 

////////////////////////////////////////////////////////////////////////
// CCreateAttributePage

class CCreateAttributePage : public CPropertyPageBase
{
public:
	CCreateAttributePage(UINT nID, CADSIAttr* pAttr);
	~CCreateAttributePage();

	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	virtual LRESULT OnWizardNext();

	virtual void OnEditChangeValue();

	CADSIAttr* GetAttr() { return m_pAttr; }
	virtual void GetValue(CString& sVal);
	void SetSyntax(CString sAttr);
	void SetADsType(CString sProp);


protected:
	CADSIAttr* m_pAttr;

	CStringList m_sAttrValue;
	BOOL m_bInitialized;
	BOOL m_bNumber;
	long m_lMaxRange;
	long m_lMinRange;

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////
// CCreateFinishPage

class CCreateFinishPage : public CPropertyPageBase
{
public:
	CCreateFinishPage(UINT nID);
	~CCreateFinishPage();

	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	virtual BOOL OnWizardFinish();
  virtual void OnMore();

protected:
	BOOL m_bInitialized;

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////
// CPropertyPageList

typedef CList<CPropertyPageBase*,CPropertyPageBase*> CPropertyPageListBase;

class CPropertyPageList : public CPropertyPageListBase
{
public:
	void RemoveAll() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}

};


////////////////////////////////////////////////////////////////////////
// CCreatePageHolder

class CCreatePageHolder : public CPropertyPageHolderBase
{
public:
	CCreatePageHolder(CContainerNode* pContNode, CADSIEditContainerNode* pNode, 
		CComponentDataObject* pComponentData);
	~CCreatePageHolder();

	void AddAttrPage(CString sClass);  //Adds the dynamic attribute pages
	void RemoveAllPages();
	void GetMandatoryAttr(CString sClass, CStringList* sMandList);
	void RemovePresetAttr(CStringList* sMandList);
	void SetName(CString sName) { m_sName = m_sNamingAttr.GetHead() + _T("=") + sName; }
	void GetNamingAttribute(CString& sNamingAttr) { sNamingAttr = m_sNamingAttr.GetHead(); }
	void GetSchemaPath(CString sClass, CString& schema);
	HRESULT EscapePath(CString& sEscapedName, const CString& sName);
  void GetDN(PWSTR pwszName, CString& sDN);
  CAttrList* GetAttrList() { return &m_AttrList; }

	BOOL OnFinish();
  void OnMore();

protected:
	CPropertyPageList m_pageList;
	CCreateClassPage* m_pClassPage;
	CString m_sClass;
	CString m_sName;
	CStringList m_sNamingAttr;
  CAttrList m_AttrList;

	CADSIEditContainerNode* m_pCurrentNode;
  CComponentDataObject* m_pComponentData;
};

#endif _CREATEWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editimpl.h ===
#ifndef __ATTRIBUTEEDITORIMPL_H
#define __ATTRIBUTEEDITORIMPL_H

#include "editui.h"

class /*ATL_NO_VTABLE*/ CAttributeEditor : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDsAttributeEditor,
  public CComCoClass<CAttributeEditor, &CLSID_DsAttributeEditor>
{
public:
   CAttributeEditor() : m_pHolder(0)
	{
    m_szClass = _T("");
    m_pEditor = NULL;
	}

 	~CAttributeEditor()
	{
    if (m_pEditor != NULL)
    {
      delete m_pEditor;
    }

    if (m_BindingInfo.lpszProviderServer != NULL)
    {
      delete[] m_BindingInfo.lpszProviderServer;
    }
	}
  DECLARE_REGISTRY_CLSID();

BEGIN_COM_MAP(CAttributeEditor)
	COM_INTERFACE_ENTRY(IDsAttributeEditor)
END_COM_MAP()


public:

  //
  // IDsAttributeEditor interface
  //
  STDMETHOD(Initialize)(
     IADs* pADsObj, 
     LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
     CADSIEditPropertyPageHolder* pHolder);
  STDMETHOD(CreateModal)();
  STDMETHOD(GetPage)(HPROPSHEETPAGE* phPropSheetPage);

private:
  CComPtr<IADs> m_spIADs;
  CString m_szClass;

  CAttributeEditorPropertyPage* m_pEditor;
  DS_ATTREDITOR_BINDINGINFO m_BindingInfo;
  CADSIEditPropertyPageHolder* m_pHolder;
};


#endif  //__ATTRIBUTEEDITORIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editimpl.cpp ===
#include "pch.h"
#include <snapbase.h>
#include "editimpl.h"

HRESULT CAttributeEditor::Initialize(
   IADs* pADsObj, 
   LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
   CADSIEditPropertyPageHolder* pHolder)
{
  TRACE(_T("CAttributeEditor::Initialize()\n"));
  m_spIADs = pADsObj;

  ASSERT(pBindingInfo != NULL);
  ASSERT(pBindingInfo->lpfnBind != NULL);
  ASSERT(pBindingInfo->lpszProviderServer != NULL);

  m_BindingInfo.lParam   = pBindingInfo->lParam;
  m_BindingInfo.lpfnBind = pBindingInfo->lpfnBind;
  m_BindingInfo.dwFlags  = pBindingInfo->dwFlags;

  int nCount = wcslen(pBindingInfo->lpszProviderServer);
  m_BindingInfo.lpszProviderServer = new WCHAR[nCount + 1];
  wcscpy(m_BindingInfo.lpszProviderServer, pBindingInfo->lpszProviderServer);

  m_BindingInfo.dwSize = sizeof(DS_ATTREDITOR_BINDINGINFO);

  m_pHolder = pHolder;
  ASSERT(m_pHolder);

  //
  // Retrieve the class name
  //
  CComBSTR bstrClass;
  HRESULT hr = S_OK;
  hr = m_spIADs->get_Class(&bstrClass);
  if (SUCCEEDED(hr))
  {
    m_szClass = bstrClass;
  }
  return hr;
}

HRESULT CAttributeEditor::CreateModal()
{
  TRACE(_T("CAttributeEditor::CreateModal()\n"));

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Build the abstract schema path
  //
  CString szSchemaClass(m_BindingInfo.lpszProviderServer);
  szSchemaClass = szSchemaClass + _T("schema/") + m_szClass;

  //
  // Bind to the class object in the abstract schema
  //
  HRESULT hr = S_OK;
  CComPtr<IADsClass> spIADsClass;

  if (m_BindingInfo.dwFlags & DSATTR_EDITOR_ROOTDSE)
  {
    //
    // Trying to bind to the schema class of the RootDSE will fail.
    // Just pass NULL instead
    //
    spIADsClass = NULL;
  }
  else
  {
    hr = m_BindingInfo.lpfnBind((LPWSTR)(LPCWSTR)szSchemaClass,
                                  ADS_SECURE_AUTHENTICATION,
                                  IID_IADsClass, 
                                  (PVOID*)&spIADsClass,
                                  m_BindingInfo.lParam);
  }

  if (SUCCEEDED(hr))
  {
    //
    // Invoke the editor
    //
    m_pEditor = new CAttributeEditorPropertyPage(m_spIADs, spIADsClass, &m_BindingInfo, m_pHolder);
    if (m_pEditor)
    {
	    CPropertySheet*	m_pDummySheet = new CPropertySheet();
      if (m_pDummySheet)
      {
	      m_pDummySheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;

        CString szCaption;
        VERIFY(szCaption.LoadString(IDS_ATTREDITOR_CAPTION));
	      m_pDummySheet->m_psh.pszCaption = szCaption;
	      
        m_pDummySheet->AddPage(m_pEditor);
        hr = (m_pDummySheet->DoModal() == IDOK) ? S_OK : S_FALSE;
      }
      delete m_pEditor;
      m_pEditor = NULL;
    }
  }

  return hr;
}

HRESULT CAttributeEditor::GetPage(HPROPSHEETPAGE* phPropSheetPage)
{
  TRACE(_T("CAttributeEditor::GetPage()\n"));

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Build the abstract schema path
  //
  CString szSchemaClass(m_BindingInfo.lpszProviderServer);
  szSchemaClass = szSchemaClass + _T("schema/") + m_szClass;

  //
  // Bind to the class object in the abstract schema
  //
  HRESULT hr = S_OK;
  CComPtr<IADsClass> spIADsClass;

  if (m_BindingInfo.dwFlags & DSATTR_EDITOR_ROOTDSE)
  {
    //
    // Trying to bind to the schema class of the RootDSE will fail.
    // Just pass NULL instead
    //
    spIADsClass = NULL;
  }
  else
  {

    hr = m_BindingInfo.lpfnBind((LPWSTR)(LPCWSTR)szSchemaClass,
                                  ADS_SECURE_AUTHENTICATION,
                                  IID_IADsClass, 
                                  (PVOID*)&spIADsClass,
                                  m_BindingInfo.lParam);
  }
  if (SUCCEEDED(hr))
  {
    //
    // Invoke the editor
    //
    m_pEditor = new CAttributeEditorPropertyPage(m_spIADs, spIADsClass, &m_BindingInfo, m_pHolder);
    *phPropSheetPage = CreatePropertySheetPage((PROPSHEETPAGE*)(&m_pEditor->m_psp));
    if (*phPropSheetPage == NULL)
    {
      hr = E_FAIL;
    }
  }
  else
  {
     ADSIEditErrorMessage(hr);
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editor.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editor.cpp
//
//--------------------------------------------------------------------------



#include "pch.h"

#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>

#include <SnapBase.h>

#include "resource.h"
#include "adsiedit.h"
#include "editor.h"
#include "editorui.h"
#include "snapdata.h"
#include "common.h"
#include "connection.h"
#include "createwiz.h"
#include "query.h"
#include "querynode.h"
#include "queryui.h"
#include "renameui.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

//////////////////////////////////////////////////////////////////////////

LPCWSTR g_lpszGC = L"GC://";
LPCWSTR g_lpszLDAP = L"LDAP://";
LPCWSTR g_lpszRootDSE = L"RootDSE";

//////////////////////////////////////////////////////////////////////////

CADsObject::CADsObject()
{
	m_bContainer = FALSE;
	m_bIntermediate = FALSE;
	m_pConnectionNode = NULL;
	m_sName = _T("");
	m_sDN = _T("");
	m_sPath = _T("");
	m_sClass = _T("");
	m_bComplete = FALSE;

}

CADsObject::CADsObject(CADSIEditConnectionNode* pConnectNode)
{
	m_bContainer = FALSE;
	m_bIntermediate = FALSE;
	m_pConnectionNode = pConnectNode;
	m_bComplete = FALSE;
}

CADsObject::CADsObject(CADsObject* pADsObject)
{
	m_sName = pADsObject->m_sName;
	m_sDN = pADsObject->m_sDN;
	m_sPath = pADsObject->m_sPath;
	m_sClass = pADsObject->m_sClass;
	m_bContainer = pADsObject->m_bContainer;
	m_bIntermediate = pADsObject->m_bIntermediate;
	m_pConnectionNode = pADsObject->m_pConnectionNode;
	m_bComplete = pADsObject->m_bComplete;
}

void CADsObject::SetName(LPCWSTR lpszName)
{
	CString sPrefix, sRemaining, sTemp;
	sTemp = lpszName;
	int idx = sTemp.Find(L'=');

	if (idx != -1)
	{
		sPrefix = sTemp.Left(idx);
		sPrefix.MakeUpper();

		int iCount = sTemp.GetLength();
		sRemaining = sTemp.Right(iCount - idx);
		sTemp = sPrefix + sRemaining;
	}

	m_sName = sTemp;
}

////////////////////////////////////////////////////////////////////////
// CCredentialObject

CCredentialObject::CCredentialObject(CCredentialObject* pCredObject)
{
	m_sUsername = pCredObject->m_sUsername;
	if (pCredObject->m_lpszPassword != NULL)
	{
		m_lpszPassword = (LPWSTR)malloc(sizeof(WCHAR[MAX_PASSWORD_LENGTH + 1]));
    if (m_lpszPassword != NULL)
    {
		  wcscpy(m_lpszPassword, pCredObject->m_lpszPassword);
    }
	}
	else
	{
		m_lpszPassword = NULL;
	}

	m_bUseCredentials = pCredObject->m_bUseCredentials;
}

// A prime number used to seed the encoding and decoding
//
#define NW_ENCODE_SEED3  0x83

HRESULT CCredentialObject::SetPasswordFromHwnd(HWND hWnd)
{
	UNICODE_STRING Password;

	if (m_lpszPassword) 
	{
		free(m_lpszPassword);
		m_lpszPassword = NULL;
	}

	UCHAR Seed = NW_ENCODE_SEED3;
	Password.Length = 0;

	WCHAR szBuffer[MAX_PASSWORD_LENGTH + 1];
	::GetWindowText(hWnd, szBuffer, MAX_PASSWORD_LENGTH + 1);
	if (!szBuffer)
	{
		return S_OK;
	}

	RtlInitUnicodeString(&Password, szBuffer);
	RtlRunEncodeUnicodeString(&Seed, &Password);

	m_lpszPassword = (LPWSTR)malloc(sizeof(WCHAR[MAX_PASSWORD_LENGTH + 1]));
	if(!m_lpszPassword) 
	{
		return E_OUTOFMEMORY;
	}
	wcscpy(m_lpszPassword, szBuffer);

	return S_OK;
}

HRESULT CCredentialObject::GetPassword(LPWSTR lpszBuffer)
{
	UNICODE_STRING Password;
	UCHAR Seed = NW_ENCODE_SEED3;

	Password.Length = 0;

	if (!lpszBuffer) 
	{
		return E_FAIL;
	}

	if (!m_lpszPassword) 
	{
		return E_FAIL;
	}

	wcscpy(lpszBuffer, m_lpszPassword);

	RtlInitUnicodeString(&Password, lpszBuffer);
	RtlRunDecodeUnicodeString(Seed, &Password);

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////
//  CConnectionData
//
CConnectionData::CConnectionData()
{ 
	ConstructorHelper();
}

CConnectionData::CConnectionData(CADSIEditConnectionNode* pConnectNode)	: CADsObject(pConnectNode)
{
	ConstructorHelper();
}

void CConnectionData::ConstructorHelper()
{
	m_pFilterObject = new CADSIFilterObject();
	m_pCredentialsObject = new CCredentialObject();

	m_sBasePath = _T("");
	m_sDomainServer = _T("");
	m_sPort = _T("");
	m_sDistinguishedName = _T("");
	m_sNamingContext = _T("Domain");
	m_sLDAP = g_lpszLDAP;

	m_sSchemaPath = _T("");
	m_sAbstractSchemaPath = _T("");
	m_bRootDSE = FALSE;
	m_bUserDefinedServer = FALSE;
	m_pDirObject = NULL;
	m_nMaxObjectCount = ADSIEDIT_QUERY_OBJ_COUNT_DEFAULT;
}

CConnectionData::CConnectionData(CConnectionData* pConnectData) : CADsObject(pConnectData)
{
	// Path data
	//
	m_sBasePath = pConnectData->m_sBasePath;
	m_sDomainServer = pConnectData->m_sDomainServer;
	m_sPort = pConnectData->m_sPort;
	m_sDistinguishedName = pConnectData->m_sDistinguishedName;
	m_sNamingContext = pConnectData->m_sNamingContext;
	m_sLDAP = pConnectData->m_sLDAP;
	m_sSchemaPath = pConnectData->m_sSchemaPath;
	m_sAbstractSchemaPath = pConnectData->m_sAbstractSchemaPath;

	// Filter
	//
	m_pFilterObject = new CADSIFilterObject(pConnectData->m_pFilterObject);

	// Credentials
	//
	m_pCredentialsObject = new CCredentialObject(pConnectData->m_pCredentialsObject);

	m_bRootDSE = pConnectData->m_bRootDSE;
	m_bUserDefinedServer = pConnectData->m_bUserDefinedServer;
	m_pDirObject = NULL;

	m_nMaxObjectCount = pConnectData->m_nMaxObjectCount;
}

CConnectionData::~CConnectionData()
{
	if (m_pDirObject != NULL)
	{
		m_pDirObject->Release();
	}
	delete m_pCredentialsObject;
	delete m_pFilterObject;
}

void CConnectionData::Save(IStream* pStm)
{
	SaveStringToStream(pStm, m_sBasePath);

	if (m_bUserDefinedServer)
	{
		SaveStringToStream(pStm, m_sDomainServer);
	}
	else
	{
		SaveStringToStream(pStm, _T(""));
	}
	SaveStringToStream(pStm, m_sPort);
	SaveStringToStream(pStm, m_sDistinguishedName);
	SaveStringToStream(pStm, m_sNamingContext);
	SaveStringToStream(pStm, m_sLDAP);

	CString sName;
	GetName(sName);
	SaveStringToStream(pStm, sName);

	if (m_bUserDefinedServer)
	{
		CString sPath;
		GetPath(sPath);
		SaveStringToStream(pStm, sPath);
	}
	else
	{
		SaveStringToStream(pStm, _T(""));
	}

	CString sClass;
	GetClass(sClass);
	SaveStringToStream(pStm, sClass);

	ULONG cbWrite;
	BOOL bUseCredentials = m_pCredentialsObject->UseCredentials();
	VERIFY(SUCCEEDED(pStm->Write((void*)&bUseCredentials, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));

	VERIFY(SUCCEEDED(pStm->Write((void*)&m_bRootDSE, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));

	GetFilter()->Save(pStm);

	BOOL bContainer = GetContainer();
	VERIFY(SUCCEEDED(pStm->Write((void*)&bContainer, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));

	ULONG nMaxNum = GetMaxObjectCount();
	VERIFY(SUCCEEDED(pStm->Write((void*)&nMaxNum, sizeof(ULONG),&cbWrite)));
	ASSERT(cbWrite == sizeof(ULONG));
}

CConnectionData* CConnectionData::Load(IStream* pStm)
{
	WCHAR szBuffer[256]; // REVIEW_MARCOC: hardcoded
	ULONG nLen; // WCHAR counting NULL
	ULONG cbRead;

	CConnectionData* pConnectData = new CConnectionData();

	LoadStringFromStream(pStm, pConnectData->m_sBasePath);

	LoadStringFromStream(pStm, pConnectData->m_sDomainServer);

	LoadStringFromStream(pStm, pConnectData->m_sPort);

	LoadStringFromStream(pStm, pConnectData->m_sDistinguishedName);

	LoadStringFromStream(pStm, pConnectData->m_sNamingContext);

	LoadStringFromStream(pStm, pConnectData->m_sLDAP);

	CString sString;
  CString szConnectionName;
	LoadStringFromStream(pStm, szConnectionName);
	pConnectData->SetName(szConnectionName);

	LoadStringFromStream(pStm, sString);
	pConnectData->SetPath(sString);

	LoadStringFromStream(pStm, sString);
	pConnectData->SetClass(sString);

	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	pConnectData->GetCredentialObject()->SetUseCredentials(nLen);

	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	pConnectData->SetRootDSE(nLen);

	CADSIFilterObject* pFilterObject;
	HRESULT hr = CADSIFilterObject::CreateFilterFromStream(pStm, &pFilterObject);
	if (SUCCEEDED(hr))
	{
		pConnectData->SetFilter(pFilterObject);
	}

	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	pConnectData->SetContainer(nLen);

	ULONG nMaxCount;
	VERIFY(SUCCEEDED(pStm->Read((void*)&nMaxCount,sizeof(ULONG), &cbRead)));
	ASSERT(cbRead == sizeof(ULONG));
	pConnectData->SetMaxObjectCount(nMaxCount);

	if (pConnectData->m_sNamingContext != L"")
	{
		hr = LoadBasePathFromContext(pConnectData, pConnectData->m_sNamingContext);
    if (FAILED(hr))
    {
      CString szHrErr;
      GetErrorMessage(hr, szHrErr);

      CString szFormatErr;
      VERIFY(szFormatErr.LoadString(IDS_ERRMSG_FAILED_CONNECTION));

      CString szMessage;
      szMessage.Format(szFormatErr, szConnectionName, szHrErr);

      ADSIEditErrorMessage(szMessage);
      return pConnectData;
    }
	}

	if (pConnectData->m_sDomainServer == L"")
	{
		hr = GetServerNameFromDefault(pConnectData);
    if (FAILED(hr))
    {
      CString szHrErr;
      GetErrorMessage(hr, szHrErr);

      CString szFormatErr;
      VERIFY(szFormatErr.LoadString(IDS_ERRMSG_FAILED_CONNECTION));

      CString szMessage;
      szMessage.Format(szFormatErr, szConnectionName, szHrErr);

      ADSIEditErrorMessage(szMessage);
    }
		pConnectData->BuildPath();
	}

	return pConnectData;
}

void CConnectionData::BuildPath()
{
	// Get data from connection node
	//
	CString sServer, sLDAP, sPort, path;
	GetDomainServer(sServer);
	GetLDAP(sLDAP);
	GetPort(sPort);

	if (sServer == _T(""))
	{
		path = sLDAP + path;
	}
	else
	{
		if (sPort == _T(""))
		{
			path = sServer + _T("/") + path;
		}
		else
		{
			path = sServer + _T(":") + sPort + _T("/") + path;
		}
		path = sLDAP + path;
	}
	path += m_sBasePath;

	if (IsRootDSE())
	{
		path += g_lpszRootDSE;
	}
	SetPath(path);
}

HRESULT CConnectionData::GetServerNameFromDefault(CConnectionData* pConnectData)
{
	CString sSchemaPath, szServerName;
	HRESULT hr = pConnectData->GetSchemaPath(sSchemaPath);
  if (FAILED(hr))
  {
    return hr;
  }

  CComPtr<IADs> spConfig;
	hr = OpenObjectWithCredentials (pConnectData->GetCredentialObject(),
											  (LPWSTR)(LPCWSTR)sSchemaPath,
											  IID_IADs,
											  (LPVOID*)&spConfig
											 );
	if (FAILED(hr))
	{
		TRACE(L"Failed ADsOpenObject(%s) on naming context\n", (LPCWSTR)sSchemaPath);
		return hr;
	}
	hr = pConnectData->GetADSIServerName(szServerName, spConfig);
	if (FAILED(hr))
	{
		TRACE(L"Failed GetADSIServerName(%s)\n", (LPCWSTR)szServerName);
		return hr;
	}

	pConnectData->SetDomainServer(szServerName);
	pConnectData->SetUserDefinedServer(FALSE);

  return hr;
}


HRESULT CConnectionData::GetADSIServerName(OUT CString& szServer, IN IUnknown* pUnk)
{
  szServer.Empty();

  CComPtr<IADsObjectOptions> spIADsObjectOptions;
  HRESULT hr = pUnk->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);
  if (FAILED(hr))
    return hr;

  CComVariant var;
  hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
  if (FAILED(hr))
    return hr;

  ASSERT(var.vt == VT_BSTR);
  szServer = V_BSTR(&var);
  return hr;
}


HRESULT CConnectionData::LoadBasePathFromContext(CConnectionData* pConnectData, const CString sContext)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString sContextPath, szSchema, szDomain, szConfig;

	if ( !szSchema.LoadString(IDS_SCHEMA)	||
		  !szDomain.LoadString(IDS_DOMAIN_NC) ||
		  !szConfig.LoadString(IDS_CONFIG_CONTAINER))
	{
		ADSIEditMessageBox(IDS_MSG_FAIL_TO_LOAD, MB_OK);
		return S_FALSE;
	}

	if (sContext == szSchema)
	{
		sContextPath = L"schemaNamingContext";
	}
	else if (sContext == szDomain)
	{
		sContextPath = L"defaultNamingContext";
	}
	else if (sContext == szConfig)
	{
		sContextPath = L"configurationNamingContext";
	}
	else		// RootDSE
	{
		return E_FAIL;
	}

	// Get data from connection node
	//
	CString sRootDSE, sServer, sPort, sLDAP;
	pConnectData->GetDomainServer(sServer);
	pConnectData->GetLDAP(sLDAP);
	pConnectData->GetPort(sPort);

	if (sServer != _T(""))
	{
		sRootDSE = sLDAP + sServer;
		if (sPort != _T(""))
		{
			sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
		}
		else
		{
			sRootDSE = sRootDSE + _T("/");
		}
		sRootDSE = sRootDSE + g_lpszRootDSE;
	}
	else
	{
		sRootDSE = sLDAP + g_lpszRootDSE;
	}

	CComPtr<IADs> pADs;
	HRESULT hr, hCredResult;

	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sRootDSE,
											 IID_IADs, 
											 (LPVOID*) &pADs,
											 NULL,
											 hCredResult
											 );

	if ( FAILED(hr) )
	{
		if (SUCCEEDED(hCredResult))
		{
			return hr;
		}
		return hCredResult;
	}
	VARIANT var;
	VariantInit(&var);
	hr = pADs->Get( (LPWSTR)(LPCWSTR)sContextPath, &var );

	if ( FAILED(hr) )
	{
		VariantClear(&var);
		return hr;
	}

	BSTR bstrItem = V_BSTR(&var);
	pConnectData->m_sBasePath = bstrItem;
	VariantClear(&var);

  return hr;
}

HRESULT CConnectionData::GetSchemaPath(CString& sSchemaPath)
{
	CString sLDAP, sServer, sPort, sTemp;
	GetLDAP(sLDAP);
	GetDomainServer(sServer);
	GetPort(sPort);

  HRESULT hr = GetItemFromRootDSE(_T("schemaNamingContext"), sSchemaPath, this);
	if (FAILED(hr))
	{
		return hr;
	}
	if (sServer != _T(""))
	{
		sTemp = sLDAP + sServer;
		if (sPort != _T(""))
		{
			sTemp = sTemp + _T(":") + sPort + _T("/");
		}
		else
		{
			sTemp = sTemp + _T("/");
		}
		sSchemaPath = sTemp + sSchemaPath;
	}
	else
	{
		sSchemaPath = sLDAP + sSchemaPath;
	}
	m_sSchemaPath = sSchemaPath;
  return S_OK;
}

void CConnectionData::GetAbstractSchemaPath(CString& sSchemaPath)
{
	if (m_sAbstractSchemaPath == _T(""))
	{
		if (m_sDomainServer != _T(""))
		{
			sSchemaPath = m_sLDAP + m_sDomainServer;
			if (m_sPort != _T(""))
			{
				sSchemaPath = sSchemaPath + _T(":") + m_sPort + _T("/");
			}
			else
			{
				sSchemaPath = sSchemaPath + _T("/");
			}
			sSchemaPath = sSchemaPath + _T("schema") + _T("/");
		}
		else
		{
			sSchemaPath = m_sLDAP + _T("schema") + _T("/");
		}
		m_sAbstractSchemaPath = sSchemaPath;
	}
	else
	{
		sSchemaPath = m_sAbstractSchemaPath;
	}
}

void CConnectionData::GetBaseLDAPPath(CString& sBasePath)
{
	if (m_sDomainServer == _T(""))
	{
		sBasePath = m_sLDAP + sBasePath;
	}
	else
	{
		if (m_sPort == _T(""))
		{
			sBasePath = m_sDomainServer + _T("/") + sBasePath;
		}
		else
		{
			sBasePath = m_sDomainServer + _T(":") + m_sPort + _T("/") + sBasePath;
		}
		sBasePath = m_sLDAP + sBasePath;
	}
}

void CConnectionData::SetIDirectoryInterface(IDirectoryObject* pDirObject)
{
	if (m_pDirObject != NULL)
	{
		m_pDirObject->Release();
		m_pDirObject = NULL;
	}
	if (pDirObject != NULL)
	{
		m_pDirObject = pDirObject;
		m_pDirObject->AddRef();
	}
}

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterObject

CADSIFilterObject::CADSIFilterObject()
{
	m_bInUse = FALSE;
}

CADSIFilterObject::CADSIFilterObject(CADSIFilterObject* pFilterObject)
{
	m_sFilterString = pFilterObject->m_sFilterString;
	m_sUserFilter = pFilterObject->m_sUserFilter;
	CopyStringList(&m_ContainerList, &(pFilterObject->m_ContainerList));
	m_bInUse = pFilterObject->m_bInUse;
}

void CADSIFilterObject::GetFilterString(CString& sFilterString)
{
	if (m_bInUse)
	{
		if (m_ContainerList.GetCount() != 0)
		{
			sFilterString = _T("(|") + m_sUserFilter;
		
			POSITION pos = m_ContainerList.GetHeadPosition();
			while (pos != NULL)
			{
				CString sContainer = m_ContainerList.GetNext(pos);
				sFilterString += _T("(objectCategory=") + sContainer + _T(")");
			}
			sFilterString += _T(")");
		}
		else
		{
			sFilterString = m_sUserFilter;
		}
		m_sFilterString = sFilterString;
	}
	else
	{
		sFilterString = L"(objectClass=*)";
	}
}

void CADSIFilterObject::Save(IStream* pStm)
{
	ULONG cbWrite;
	ULONG nLen;

	BOOL bInUse = InUse();
	VERIFY(SUCCEEDED(pStm->Write((void*)&bInUse, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));
	
	if (InUse())
	{
		SaveStringToStream(pStm, m_sUserFilter);
		SaveStringListToStream(pStm, m_ContainerList);
	}
}

HRESULT CADSIFilterObject::CreateFilterFromStream(IStream* pStm,
																									CADSIFilterObject** ppFilterObject)
{
	ULONG nLen; // WCHAR counting NULL
	ULONG cbRead;

	*ppFilterObject = new CADSIFilterObject();
	
	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	(*ppFilterObject)->SetInUse(nLen);

	if ((*ppFilterObject)->InUse())
	{
		CString sUserFilter;
		LoadStringFromStream(pStm, sUserFilter);
		(*ppFilterObject)->SetUserDefinedFilter(sUserFilter);

		CStringList sContainerFilter;
		LoadStringListFromStream(pStm, sContainerFilter);
		(*ppFilterObject)->SetContainerList(&sContainerFilter);
	}
	return S_OK;
}

	
////////////////////////////////////////////////////////////////////////
// CADSIEditContainerNode
//

// {8690ABBB-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditContainerNode::NodeTypeGUID = 
{ 0x8690abbb, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };


CADSIEditContainerNode::CADSIEditContainerNode(CADsObject* pADsObject)
  : m_pPartitionsColumnSet(NULL) 
{	
	m_pADsObject = pADsObject;
	m_nState = notLoaded; 
  m_szDescriptionText = L"";
}

CADSIEditContainerNode::CADSIEditContainerNode(CADSIEditContainerNode* pContNode)
  : m_pPartitionsColumnSet(NULL) 
{
	m_pADsObject = new CADsObject(pContNode->m_pADsObject);
	m_nState = notLoaded;
	CString sName;
	m_pADsObject->GetName(sName);

	SetDisplayName(sName);
  m_szDescriptionText = L"";
}


HRESULT CADSIEditContainerNode::OnCommand(long nCommandID, 
																					DATA_OBJECT_TYPES type, 
																					CComponentDataObject* pComponentData,
                                          CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1); // for now I am not allowing multiple selection for any of these

	switch (nCommandID)
	{
    case IDM_MOVE :
		  OnMove(pComponentData);
		  break;
	  case IDM_NEW_OBJECT :
		  OnCreate(pComponentData);
		  break;
    case IDM_NEW_CONNECT_FROM_HERE :
      OnConnectFromHere(pComponentData);
      break;
    case IDM_NEW_NC_CONNECT_FROM_HERE :
      OnConnectToNCFromHere(pComponentData);
      break;
    default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
  return S_OK;
}

void CADSIEditContainerNode::OnConnectFromHere(CComponentDataObject* pComponentData)
{
  //
  // Retrieve the path to create the connection at
  //
  CADsObject* pADsObject = GetADsObject();
  CString szDN, szPath, szName;
  pADsObject->GetDN(szDN);
  pADsObject->GetPath(szPath);
  pADsObject->GetName(szName);

  //
  // Create the new connection node
  //
  CConnectionData* pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
  CADSIEditConnectionNode* pNewConnectNode = new CADSIEditConnectionNode(pConnectData);
  pNewConnectNode->SetDisplayName(GetDisplayName());
  pNewConnectNode->GetConnectionData()->SetBasePath(szDN);
  pNewConnectNode->GetConnectionData()->SetDistinguishedName(szDN);
  pNewConnectNode->GetConnectionData()->SetNamingContext(L"");
  pNewConnectNode->GetConnectionData()->SetDN(szDN);
  pNewConnectNode->GetConnectionData()->SetPath(szPath);
  pNewConnectNode->GetConnectionData()->SetName(szName);

  //
  // Add the new connection node to the root container
  //
  CADSIEditRootData* pRootData = (CADSIEditRootData*)pComponentData->GetRootData();
  BOOL bResult = pRootData->AddChildToListAndUI(pNewConnectNode, pComponentData);
  ASSERT(bResult);

  // 
  //  Select the new connection node
  //
  pComponentData->UpdateResultPaneView(pNewConnectNode);
}

void CADSIEditContainerNode::OnConnectToNCFromHere(CComponentDataObject* pComponentData)
{
  //
  // Retrieve the path to create the connection at
  //
  CADsObject* pADsObject = GetADsObject();
  CString szDN, szPath, szName, szNCName;
  pADsObject->GetDN(szDN);
  pADsObject->GetPath(szPath);
  pADsObject->GetName(szName);
  szNCName = pADsObject->GetNCName();

  ASSERT(!szNCName.IsEmpty());
  if (!szNCName.IsEmpty())
  {
    //
    // Create the new connection node
    //
    HRESULT hr = S_OK;
    CConnectionData* pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
    CADSIEditConnectionNode* pNewConnectNode = new CADSIEditConnectionNode(pConnectData);
    if (pNewConnectNode)
    {
      pNewConnectNode->SetDisplayName(GetDisplayName());
      pNewConnectNode->GetConnectionData()->SetBasePath(szNCName);
      pNewConnectNode->GetConnectionData()->SetDistinguishedName(szNCName);
      pNewConnectNode->GetConnectionData()->SetNamingContext(L"");
      pNewConnectNode->GetConnectionData()->SetDN(szNCName);
      pNewConnectNode->GetConnectionData()->SetName(szNCName);

      CString szServer, szProvider;
      pConnectData->GetDomainServer(szServer);
      pConnectData->GetLDAP(szProvider);

      do // false loop
      {
        //
        // Crack the path to get the path to the new NC
        //
        CComPtr<IADsPathname> spPathCracker;
        hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IADsPathname, (PVOID *)&(spPathCracker));
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set((PWSTR)(PCWSTR)szNCName, ADS_SETTYPE_DN);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set((PWSTR)(PCWSTR)szServer, ADS_SETTYPE_SERVER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set((PWSTR)(PCWSTR)L"LDAP", ADS_SETTYPE_PROVIDER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        CComBSTR sbstrNewPath;
        hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &sbstrNewPath);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        pNewConnectNode->GetConnectionData()->SetPath(sbstrNewPath);

        //
        // Add the new connection node to the root container
        //
        CADSIEditRootData* pRootData = (CADSIEditRootData*)pComponentData->GetRootData();
        BOOL bResult = pRootData->AddChildToListAndUI(pNewConnectNode, pComponentData);
        ASSERT(bResult);

        // 
        //  Select the new connection node
        //
        pComponentData->UpdateResultPaneView(pNewConnectNode);
      } while (false);

      if (FAILED(hr))
      {
        delete pNewConnectNode;
        pNewConnectNode = 0;
      }
    } 
  }
}

HRESULT CADSIEditContainerNode::OnRename(CComponentDataObject* pComponentData,
                                         LPWSTR lpszNewName)
{
  HRESULT hr = S_OK;
	BOOL bLocked = IsThreadLocked();
	ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
	if (bLocked)
		return hr; 
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return S_FALSE;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

  CString szPath, szOldPath;
  CADsObject* pADsObject = GetADsObject();
  pADsObject->GetPath(szPath);
  szOldPath = szPath;
	CADSIEditConnectionNode* pConnectionNode = pADsObject->GetConnectionNode();
	CConnectionData* pConnectData = pConnectionNode->GetConnectionData();

  CComPtr<IADsPathname> spPathCracker;
  hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&(spPathCracker));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->Set((PWSTR)(PCWSTR)szPath, ADS_SETTYPE_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrOldLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrOldLeaf);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CString szOldLeaf = bstrOldLeaf;
  CString szPrefix;
  szPrefix = szOldLeaf.Left(szOldLeaf.Find(L'=') + 1);

  hr = spPathCracker->RemoveLeafElement();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrParentPath;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrParentPath);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComPtr<IADsContainer> spDestination;
  CString sContPath(bstrParentPath);
	hr = OpenObjectWithCredentials(
											 pConnectData->GetCredentialObject(), 
											 bstrParentPath,
											 IID_IADsContainer, 
											 (LPVOID*) &spDestination
											 );
	if (FAILED(hr)) 
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

  //
  // Place the prefix in front of the name if it wasn't typed in by
  // the user
  //
  CString szNewLeaf, szNewName = lpszNewName;
  if (szNewName.Find(L'=') == -1)
  {
    szNewLeaf = szPrefix + lpszNewName;
  }
  else
  {
    szNewLeaf = lpszNewName;
  }
  hr = spPathCracker->AddLeafElement((PWSTR)(PCWSTR)szNewLeaf);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

	CComPtr<IDispatch> spObject;
	hr = spDestination->MoveHere((LPWSTR)(LPCWSTR)szOldPath,
                              (PWSTR)(PCWSTR)szNewLeaf,
                              &spObject);
  if (FAILED(hr)) 
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

	CComPtr<IADs> spIADs;
	hr = spObject->QueryInterface(IID_IADs, (LPVOID*)&spIADs);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

	CComBSTR bstrPath;
	hr = spIADs->get_ADsPath(&bstrPath);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

  CComBSTR bstrDN;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

  CComBSTR bstrLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrLeaf);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

	GetADsObject()->SetPath(bstrPath);
	GetADsObject()->SetName(bstrLeaf);
	GetADsObject()->SetDN(bstrDN);

	SetDisplayName(bstrLeaf);

  CNodeList nodeList;
  nodeList.AddTail(this);
  OnRefresh(pComponentData, &nodeList); 
  return hr;
}

void CADSIEditContainerNode::RefreshOverlappedTrees(CString& szPath, CComponentDataObject* pComponentData)
{
  //
  // REVIEW_JEFFJON : need to revisit this.  I am getting different behavior for
  //                  different verbs
  //

  //
	// Refresh any other subtrees of connections that contain this node
	//
	CList<CTreeNode*, CTreeNode*> foundNodeList;
	CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(GetRootContainer());
	if (pRootNode != NULL)
	{
		BOOL bFound = pRootNode->FindNode(szPath, foundNodeList);
		if (bFound)
		{
			POSITION pos = foundNodeList.GetHeadPosition();
			while (pos != NULL)
			{
				CADSIEditContainerNode* pFoundContNode = dynamic_cast<CADSIEditContainerNode*>(foundNodeList.GetNext(pos));
				if (pFoundContNode != NULL)
				{
					if (pFoundContNode->IsSheetLocked())
					{
						if (!pFoundContNode->CanCloseSheets())
							continue;
						pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pFoundContNode);
					}
					ASSERT(!pFoundContNode->IsSheetLocked());

          CNodeList nodeList;
          nodeList.AddTail(pFoundContNode);
					pFoundContNode->GetContainer()->OnRefresh(pComponentData, &nodeList);
				}
			}
		}
	}
}

void CADSIEditContainerNode::OnCreate(CComponentDataObject* pComponentData)
{
	CCreatePageHolder* pHolder = new CCreatePageHolder(GetContainer(), this, pComponentData);
	ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
	pHolder->DoModalWizard();
}

void CADSIEditContainerNode::OnMove(CComponentDataObject* pComponentData)
{
	BOOL bLocked = IsThreadLocked();
	ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
	if (bLocked)
		return; 
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

	HRESULT hr = S_OK, hCredResult;
	DWORD result;
	CComPtr<IADsContainer> pDSDestination = NULL;
	CComPtr<IDispatch> pDSObject = NULL;
	CString strDestPath;
	CString strTitle;
	strTitle.LoadString (IDS_MOVE_TITLE);

	DSBROWSEINFO dsbi;
	::ZeroMemory( &dsbi, sizeof(dsbi) );

	TCHAR szPath[MAX_PATH+1];
	CString str;
	str.LoadString(IDS_MOVE_TARGET);

	
	CADSIEditConnectionNode* pConnectNode = GetADsObject()->GetConnectionNode();
	CCredentialObject* pCredObject = pConnectNode->GetConnectionData()->GetCredentialObject();

	CString strRootPath;
	GetADsObject()->GetConnectionNode()->GetADsObject()->GetPath(strRootPath);

	dsbi.hwndOwner = NULL;
	dsbi.cbStruct = sizeof (DSBROWSEINFO);
	dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
	dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
	dsbi.pszRoot = strRootPath;
	dsbi.pszPath = szPath;
	dsbi.cchPath = (sizeof(szPath) / sizeof(TCHAR));
	dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
	dsbi.pfnCallback = NULL;
	dsbi.lParam = 0;
//  dsbi.dwReturnFormat = ADS_FORMAT_X500;

	// Specify credentials
	CString sUserName;
	WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];
	if (pCredObject->UseCredentials())
	{
		pCredObject->GetUsername(sUserName);
		pCredObject->GetPassword(szPassword);
		dsbi.dwFlags |= DSBI_HASCREDENTIALS;
		dsbi.pUserName = sUserName;
		dsbi.pPassword = szPassword;
	}
    
	result = DsBrowseForContainer( &dsbi );
 
	if ( result == IDOK ) 
	{ // returns -1, 0, IDOK or IDCANCEL
		// get path from BROWSEINFO struct, put in text edit field
		TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
			 dsbi.pszPath);
		strDestPath = dsbi.pszPath;

		CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();

		hr = OpenObjectWithCredentials(
												 pConnectData, 
												 pConnectData->GetCredentialObject()->UseCredentials(),
												 (LPWSTR)(LPCWSTR)strDestPath,
												 IID_IADsContainer, 
												 (LPVOID*) &pDSDestination,
												 NULL,
												 hCredResult
												 );
		if (FAILED(hr)) 
		{
			if (SUCCEEDED(hCredResult))
			{
				ADSIEditErrorMessage(hr);
			}
			return;
		}

		CString sCurrentPath;
		GetADsObject()->GetPath(sCurrentPath);
		hr = pDSDestination->MoveHere((LPWSTR)(LPCWSTR)sCurrentPath,
                                 NULL,
                                 &pDSObject);
	  if (FAILED(hr)) 
		{
			ADSIEditErrorMessage(hr);
			return;
		}

		DeleteHelper(pComponentData);

//		RefreshOverlappedTrees(sCurrentPath, pComponentData);
//		RefreshOverlappedTrees(strDestPath, pComponentData);

		delete this;
	}
}

BOOL CADSIEditContainerNode::OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                                  BOOL* pbHideVerb, 
                                                  CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

	if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsGC())
	{
		*pbHideVerb = TRUE; // always hide the verb
		return FALSE;
	}

	*pbHideVerb = FALSE; // always show the verb
	return TRUE;
}

BOOL CADSIEditContainerNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                                  BOOL* pbHideVerb, 
                                                  CNodeList* pNodeList)
{
	CADsObject* pADsObject = GetADsObject();
	*pbHideVerb = FALSE; // always show the verb

  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return !pADsObject->GetConnectionNode()->GetConnectionData()->IsGC();
  }

  if (pADsObject->IsIntermediateNode() || pADsObject->GetConnectionNode()->GetConnectionData()->IsGC())
	{
		return FALSE;
	}


	if (m_nState == loading)
	{
		return FALSE;
	}

	if (IsThreadLocked())
	{
		return FALSE;
	}
	return TRUE;
}

void CADSIEditContainerNode::OnDeleteMultiple(CComponentDataObject* pComponentData,
                                              CNodeList* pNodeList)
{
	if (ADSIEditMessageBox(IDS_MSG_DELETE_OBJECT, MB_OKCANCEL) == IDOK)
	{
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      //
      // Check all the nodes to be sure that none have property pages up 
      // or their thread is locked
      //
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);
      
      if (pNode->IsContainer())
      {
        CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pNode);
        ASSERT(pContNode != NULL);

		    BOOL bLocked = pContNode->IsThreadLocked();
		    ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
		    if (bLocked)
        {
			    return; 
        }
      }

		  if (pNode->IsSheetLocked())
		  {
			  if (!pNode->CanCloseSheets())
        {
				  return;
        }
			  pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pNode);
		  }
		  ASSERT(!pNode->IsSheetLocked());
    }

    //
    // REVIEW_JEFFJON : this should really only bring up an error message after all 
    //                  the objects have attempted a delete
    //
    POSITION pos2 = pNodeList->GetHeadPosition();
    while (pos2 != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos2);
      ASSERT(pNode != NULL);

      CString sName, sClass, sPath;
      if (pNode->IsContainer())
      {
        CADSIEditContainerNode* pContainerNode = dynamic_cast<CADSIEditContainerNode*>(pNode);
        ASSERT(pContainerNode != NULL);

		    pContainerNode->GetADsObject()->GetPath(sPath);
        pContainerNode->GetADsObject()->GetName(sName);
		    pContainerNode->GetADsObject()->GetClass(sClass);
      }
      else
      {
        CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(pNode);
        ASSERT(pLeafNode != NULL);

		    pLeafNode->GetADsObject()->GetPath(sPath);
        pLeafNode->GetADsObject()->GetName(sName);
		    pLeafNode->GetADsObject()->GetClass(sClass);
      }

		  HRESULT hr = DeleteChild(sClass, sPath);

		  if (FAILED(hr))
		  {
			  if (HRESULT_CODE(hr) == ERROR_DS_CANT_ON_NON_LEAF)
			  {
					hr = DeleteSubtree(sPath);
					if (FAILED(hr))
					{
						ADSIEditErrorMessage(hr);
					}
	        ASSERT(pComponentData != NULL);
	        ASSERT(pNode->GetContainer() != pNode);
	        CContainerNode* pCont = pNode->GetContainer();
	        VERIFY(pCont->RemoveChildFromList(pNode));
	        ASSERT(pNode->GetContainer() == NULL);
	        pNode->SetContainer(pCont); // not in the container's list of children, but still needed
	        
	        // remove all the containers from UI only if the container is visible
          // all the leaves will be removed by the framework
          //
	        if (pCont->IsVisible())
          {
            if (pNode->IsContainer())
            {
		          VERIFY(SUCCEEDED(pComponentData->DeleteNode(pNode))); // remove from the UI
            }
          }

          pComponentData->SetDescriptionBarText(this);
		      delete pNode;
          pNode = NULL;
        }
			  else
			  {
          //
				  //Format Error message and pop up a dialog
          //
				  ADSIEditErrorMessage(hr);
			  }
      }
      else // Delete Succeeded
      {
	      ASSERT(pComponentData != NULL);
	      ASSERT(pNode->GetContainer() != pNode);
	      CContainerNode* pCont = pNode->GetContainer();
	      VERIFY(pCont->RemoveChildFromList(pNode));
	      ASSERT(pNode->GetContainer() == NULL);
	      pNode->SetContainer(pCont); // not in the container's list of children, but still needed
	      
	      // remove all the containers from UI only if the container is visible
        // all the leaves will be removed by the framework
        //
	      if (pCont->IsVisible())
        {
		      VERIFY(SUCCEEDED(pComponentData->DeleteNode(pNode))); // remove from the UI
        }

        pComponentData->SetDescriptionBarText(this);
		    delete pNode;
        pNode = NULL;
      }
    }
  }
}

void CADSIEditContainerNode::OnDelete(CComponentDataObject* pComponentData,
                                      CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    OnDeleteMultiple(pComponentData, pNodeList);
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
	  if (ADSIEditMessageBox(IDS_MSG_DELETE_OBJECT, MB_OKCANCEL) == IDOK)
	  {
		  CString sPath;
		  GetADsObject()->GetPath(sPath);

		  BOOL bLocked = IsThreadLocked();
		  ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
		  if (bLocked)
			  return; 
		  if (IsSheetLocked())
		  {
			  if (!CanCloseSheets())
				  return;
			  pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
		  }
		  ASSERT(!IsSheetLocked());

		  CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
		  ASSERT(pContNode != NULL);

		  CString sClass;
		  GetADsObject()->GetClass(sClass);

		  HRESULT hr = pContNode->DeleteChild(sClass, sPath);

		  if (FAILED(hr))
		  {
			  if (HRESULT_CODE(hr) == ERROR_DS_CANT_ON_NON_LEAF)
			  {
				  if (ADSIEditMessageBox(IDS_MSG_DELETE_CONTAINER, MB_OKCANCEL) == IDOK)
				  {
					  hr = DeleteSubtree(sPath);
					  if (FAILED(hr))
					  {
						  ADSIEditErrorMessage(hr);
						  return;
					  }
				  }
				  else
				  {
					  return;
				  }
			  }
			  else
			  {
				  //Format Error message and pop up a dialog
				  ADSIEditErrorMessage(hr);
				  return;
			  }
		  }

		  DeleteHelper(pComponentData);
//		  RefreshOverlappedTrees(sPath, pComponentData);
      pComponentData->SetDescriptionBarText(pContNode);

		  delete this;
	  }
  }
}

BOOL CADSIEditContainerNode::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList)
{
	CString szPath;
	GetADsObject()->GetPath(szPath);

	if (wcscmp(lpszPath, (LPCWSTR)szPath) == 0)
	{
		foundNodeList.AddHead(this);
		return TRUE;
	}

  BOOL bFound = FALSE;

  //
  // Look through the leaf child list first
  //
  POSITION leafPos;
  for (leafPos = m_leafChildList.GetHeadPosition(); leafPos != NULL; )
  {
    CTreeNode* pNode = m_leafChildList.GetNext(leafPos);
    CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(pNode);

    if (pLeafNode != NULL)
    {
      BOOL bTemp;
      bTemp = pLeafNode->FindNode(lpszPath, foundNodeList);
      if (!bFound)
      {
        bFound = bTemp;
      }
    }
  }

	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pNode);

		if (pContNode != NULL)
		{
			BOOL bTemp;
			bTemp = pContNode->FindNode(lpszPath, foundNodeList);
			if (!bFound)
			{
				bFound = bTemp;
			}
		}
	}
	return bFound;
}

HRESULT CADSIEditContainerNode::DeleteChild(LPCWSTR lpszClass, LPCWSTR lpszPath)
{
	HRESULT hr, hCredResult;
   //
   // Get the escaped name from the path 
   //
  CComPtr<IADsPathname> spPathCracker;
  hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&(spPathCracker));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->Set((PWSTR)lpszPath, ADS_SETTYPE_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_ON);
  if (FAILED(hr))
  {
     ADSIEditErrorMessage(hr);
     return S_FALSE;
  }

  CComBSTR bstrChild;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrChild);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

	CComPtr<IADsContainer> pContainer;
	CString sPath;
	GetADsObject()->GetPath(sPath);

	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sPath,
											 IID_IADsContainer, 
											 (LPVOID*) &pContainer,
											 NULL,
											 hCredResult
											 );

	if (FAILED(hr))
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return E_FAIL;
	}

	hr = pContainer->Delete((LPWSTR)lpszClass, bstrChild);

	return hr;
}

HRESULT CADSIEditContainerNode::DeleteSubtree(LPCWSTR lpszPath)
{

  HRESULT hr = S_OK, hCredResult;
  CComPtr<IADsDeleteOps> pObj = NULL;

	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	hr = OpenObjectWithCredentials(
																 pConnectData, 
																 pConnectData->GetCredentialObject()->UseCredentials(),
																 lpszPath,
																 IID_IADsDeleteOps, 
																 (LPVOID*) &pObj,
																 NULL,
																 hCredResult
																 );
  if (FAILED(hr))
    return hr;

  hr = pObj->DeleteObject(NULL); //flag is reserved by ADSI
  return hr;
}

LPCWSTR CADSIEditContainerNode::GetString(int nCol) 
{ 
	CString sClass, sDN;
	GetADsObject()->GetClass(sClass);
	GetADsObject()->GetDN(sDN);

  if (GetContainer()->GetColumnSet()->GetColumnID() &&
      _wcsicmp(GetContainer()->GetColumnSet()->GetColumnID(), COLUMNSET_ID_PARTITIONS) == 0)
  {
	  switch(nCol)
	  {
		  case N_PARTITIONS_HEADER_NAME :
			  return GetDisplayName();
      case N_PARTITIONS_HEADER_NCNAME :
        return GetADsObject()->GetNCName();
		  case N_PARTITIONS_HEADER_TYPE :
			  return sClass;
		  case N_PARTITIONS_HEADER_DN :
			  return sDN;
		  default :
			  return NULL;
	  }
  }
  else
  {
	  switch(nCol)
	  {
		  case N_HEADER_NAME :
			  return GetDisplayName();
		  case N_HEADER_TYPE :
			  return sClass;
		  case N_HEADER_DN :
			  return sDN;
		  default :
			  return NULL;
	  }
  }
}

BOOL CADSIEditContainerNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                              BOOL* pbHideVerb, 
                                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
	  *pbHideVerb = FALSE; // always show the verb
	  return TRUE;
  }

  //
  // Multiple selection
  //
  *pbHideVerb = TRUE;
  return FALSE;
}

HRESULT CADSIEditContainerNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                                    LONG_PTR handle,
                                                    CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1)
  {
    return S_OK;
  }

  CWaitCursor cursor;
	CComponentDataObject* pComponentDataObject = 
			((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
	ASSERT(pComponentDataObject != NULL);

	CADSIEditContainerNode* pCont = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
  ASSERT(pCont != NULL);

	CString path;
	GetADsObject()->GetPath(path);

	CString sServer, sClass;
	GetADsObject()->GetClass(sClass);
	GetADsObject()->GetConnectionNode()->GetConnectionData()->GetDomainServer(sServer);

	CADSIEditPropertyPageHolder* pHolder = new CADSIEditPropertyPageHolder(pCont, 
			this, pComponentDataObject, sClass, sServer, path);
	ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
	return pHolder->CreateModelessSheet(lpProvider, handle);
}

BOOL CADSIEditContainerNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
																					 long *pInsertionAllowed)
{
	CString sNC, sClass;
	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	pConnectData->GetNamingContext(sNC);
  GetADsObject()->GetClass(sClass);

	if (pConnectData->IsGC() && pContextMenuItem->lCommandID != IDM_NEW_QUERY)
	{
		return FALSE;
	}

	if ((pContextMenuItem->lCommandID == IDM_RENAME ||
			pContextMenuItem->lCommandID == IDM_MOVE ||
			pContextMenuItem->lCommandID == IDM_NEW_OBJECT ||
			pContextMenuItem->lCommandID == IDM_NEW_QUERY ||
      pContextMenuItem->lCommandID == IDM_NEW_CONNECT_FROM_HERE) && 
			(m_nState == loading))
	{
		pContextMenuItem->fFlags = MF_GRAYED;
		return TRUE;
	}

  CString szNCName = GetADsObject()->GetNCName();
  if (pContextMenuItem->lCommandID == IDM_NEW_NC_CONNECT_FROM_HERE)
  {
    if (szNCName.IsEmpty())
    {
      return FALSE;
    }
    return TRUE;
  }

	if (IsThreadLocked() && 
		(pContextMenuItem->lCommandID == IDM_RENAME ||
			pContextMenuItem->lCommandID == IDM_MOVE))
	{
		pContextMenuItem->fFlags = MF_GRAYED;
		return TRUE;
	}

  //
  // Load the NC strings from the resource to use in the comparisons
  //
  CString szDomain;
  CString szSchema;
  CString szConfig;
  CString szRootDSE;

  if (!szDomain.LoadString(IDS_DOMAIN_NC))
  {
    szDomain = L"Domain";
  }

  if (!szSchema.LoadString(IDS_SCHEMA))
  {
    szSchema = L"Schema";
  }

  if (!szConfig.LoadString(IDS_CONFIG_CONTAINER))
  {
    szConfig = L"Configuration";
  }

  if (!szRootDSE.LoadString(IDS_ROOTDSE))
  {
    szRootDSE = g_lpszRootDSE;
  }

	if (GetADsObject()->IsIntermediateNode())
	{
		if (pContextMenuItem->lCommandID == IDM_RENAME)
		{
			if (sNC.CompareNoCase(szSchema) == 0  || 
					sNC.CompareNoCase(szRootDSE) == 0 || 
					sNC.CompareNoCase(szConfig) == 0  ||
          sNC.CompareNoCase(szDomain) == 0  ||
          sClass.CompareNoCase(L"domainDNS") == 0)
			{
				return FALSE;
			}
			else
			{
				return TRUE;
			}
		}
		else if (pContextMenuItem->lCommandID == IDM_MOVE ||
              pContextMenuItem->lCommandID == IDM_NEW_CONNECT_FROM_HERE)
		{
			return FALSE;
		}
		else if (pContextMenuItem->lCommandID == IDM_NEW_OBJECT ||
					pContextMenuItem->lCommandID == IDM_NEW_QUERY)
		{
			if (wcscmp(sNC, g_lpszRootDSE) == 0)
			{
				return FALSE;
			}
			else
			{
				return TRUE;
			}
		}
	}
	return TRUE;
}


int CADSIEditContainerNode::GetImageIndex(BOOL bOpenImage) 
{
	int nIndex = 0;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = FOLDER_IMAGE_NOT_LOADED;
		break;
	case loading:
		nIndex = FOLDER_IMAGE_LOADING;
		break;
	case loaded:
		nIndex = FOLDER_IMAGE_LOADED;
		break;
	case unableToLoad:
		nIndex = FOLDER_IMAGE_UNABLE_TO_LOAD;
		break;
	case accessDenied:
		nIndex = FOLDER_IMAGE_ACCESS_DENIED;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}

void CADSIEditContainerNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
	switch (m_nState)
	{
	case notLoaded:
	case loaded:
	case unableToLoad:
	case accessDenied:
	{
		m_nState = loading;
		m_dwErr = 0;
	}
	break;
	case loading:
	{
		if (m_dwErr == 0)
			m_nState = loaded;
		else if (m_dwErr == ERROR_ACCESS_DENIED)
			m_nState = accessDenied;
		else 
			m_nState = unableToLoad;
	}
	break;
	default:
		ASSERT(FALSE);
	}
	VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
	VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
}

BOOL CADSIEditContainerNode::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
	//return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}

void CADSIEditContainerNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	CTreeNode* p = dynamic_cast<CTreeNode*>(pObj);
	ASSERT(p != NULL);
	if (p != NULL)
	{
		AddChildToListAndUI(p, pComponentDataObject);
    pComponentDataObject->SetDescriptionBarText(this);
	}
}


void CADSIEditContainerNode::OnError(DWORD dwerr) 
{
	if (dwerr == ERROR_TOO_MANY_NODES)
	{
	  // need to pop message
	 AFX_MANAGE_STATE(AfxGetStaticModuleState());
	 CString szFmt;
	 szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
	 CString szMsg;
	 szMsg.Format(szFmt, GetDisplayName()); 
	 AfxMessageBox(szMsg);
	}
	else
	{
		ADSIEditErrorMessage(dwerr);
	}
}

CQueryObj* CADSIEditContainerNode::OnCreateQuery()
{
	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	if (!pConnectData->IsRootDSE())
	{
		CADSIEditRootData* pRootData = static_cast<CADSIEditRootData*>(GetRootContainer());
		CComponentDataObject* pComponentData = pRootData->GetComponentDataObject();
		RemoveAllChildrenHelper(pComponentData);

		CString sFilter;
		pConnectData->GetFilter()->GetFilterString(sFilter);
		CString path;
		GetADsObject()->GetPath(path);

		CADSIEditQueryObject* pQuery = new CADSIEditQueryObject(path, sFilter, ADS_SCOPE_ONELEVEL,
																					pConnectData->GetMaxObjectCount(),
																					pConnectData->GetCredentialObject(),
                                          pConnectData->IsGC(),
																					pConnectData->GetConnectionNode());

    TRACE(_T("Sizeof query object: %i\n"),
          sizeof(CADSIEditQueryObject));

		return pQuery;
	}
  return CMTContainerNode::OnCreateQuery();
}

BOOL CADSIEditContainerNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                                   BOOL* pbHide, 
                                                   CNodeList* pNodeList)
{
	if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsRootDSE())
	{
		*pbHide = TRUE;
		return FALSE;
	}
	*pbHide = FALSE;

	if (m_nState == loading)
	{
		return FALSE;
	}

	return !IsThreadLocked();
}

BOOL CADSIEditContainerNode::GetNamingAttribute(LPCWSTR lpszClass, CStringList* sNamingAttr)
{
	CString sSchemaPath;
	CConnectionData* pConnectData = (GetADsObject()->GetConnectionNode())->GetConnectionData();

	pConnectData->GetAbstractSchemaPath(sSchemaPath);
	sSchemaPath += lpszClass;

	CComPtr<IADsClass> pClass;
	HRESULT hr, hCredResult;

	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sSchemaPath,
											 IID_IADsClass, 
											 (LPVOID*) &pClass,
											 NULL,
											 hCredResult
											);
	if (FAILED(hr))
	{
		return FALSE;
	}

	VARIANT var;
	VariantInit(&var);
	hr = pClass->get_NamingProperties( &var );

	if ( FAILED(hr) )
	{
		VariantClear(&var);
		return FALSE;
	}

	hr = VariantToStringList(var, *sNamingAttr);
	if (FAILED(hr))
	{
		VariantClear(&var);
		return FALSE;
	}

	VariantClear(&var);
	return TRUE;
}


BOOL CADSIEditContainerNode::BuildSchemaPath(CString& path)
{
	CString sSchemaPath, sLDAP, sServer, sPort, sTemp;
	CConnectionData* m_pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	m_pConnectData->GetLDAP(sLDAP);
	m_pConnectData->GetDomainServer(sServer);
	m_pConnectData->GetPort(sPort);
	HRESULT hr = m_pConnectData->GetSchemaPath(sSchemaPath);
  if (FAILED(hr))
  {
    return FALSE;
  }

	if (sSchemaPath.IsEmpty())
	{
		if (!GetItemFromRootDSE(_T("schemaNamingContext"), sSchemaPath, m_pConnectData))
		{
			return FALSE;
		}
		if (sServer != _T(""))
		{
			sTemp = sLDAP + sServer;
			if (sPort != _T(""))
			{
				sTemp = sTemp + _T(":") + sPort + _T("/");
			}
			else
			{
				sTemp = sTemp + _T("/");
			}
			sSchemaPath = sTemp + sSchemaPath;
		}
		else
		{
			sSchemaPath = sLDAP + sSchemaPath;
		}
		m_pConnectData->SetSchemaPath(sSchemaPath);
	}

	path = sSchemaPath;
	return TRUE;
}

CColumnSet* CADSIEditContainerNode::GetColumnSet() 
{ 
  CColumnSet* pColumnSet = NULL;
  if (_wcsicmp(GetDisplayName(), L"CN=Partitions") == 0)
  {
    //
    // Since this is the partitions container we need to use a different column set
    //
    if (!m_pPartitionsColumnSet)
    {
      m_pPartitionsColumnSet = new CADSIEditColumnSet(COLUMNSET_ID_PARTITIONS);
    }
    pColumnSet = m_pPartitionsColumnSet;
  }

  if (!pColumnSet)
  {
    CRootData* pRootData = (CRootData*)GetRootContainer();
    pColumnSet = pRootData->GetColumnSet(); 
  }
  return pColumnSet;
}

//////////////////////////////////////////////////////////////////////////////////////
// CADSIEditLeafNode

// {70B9C151-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditLeafNode::NodeTypeGUID  = 
{ 0x70b9c151, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };

BOOL CADSIEditLeafNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
																			long *pInsertionAllowed)
{
	CString sNC;
	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	pConnectData->GetNamingContext(sNC);

	if ((pContextMenuItem->lCommandID == IDM_RENAME ||
			pContextMenuItem->lCommandID == IDM_MOVE) &&
			pConnectData->IsGC())
	{
		return FALSE;
	}

  CString szNCName = GetADsObject()->GetNCName();
  if (pContextMenuItem->lCommandID == IDM_NEW_NC_CONNECT_FROM_HERE)
  {
    if (szNCName.IsEmpty())
    {
      return FALSE;
    }
    return TRUE;
  }

	if (pContextMenuItem->lCommandID == IDM_RENAME &&
			(sNC == _T("Schema") || 
			wcscmp(sNC, g_lpszRootDSE) == 0 || 
			pConnectData->IsGC()))
	{
		return FALSE;
	}
	return TRUE;
}


HRESULT CADSIEditLeafNode::OnCommand(long nCommandID, 
                                     DATA_OBJECT_TYPES type, 
								                     CComponentDataObject* pComponentData,
                                     CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

	switch (nCommandID)
	{
		case IDM_MOVE :
			OnMove(pComponentData);
			break;
    case IDM_NEW_NC_CONNECT_FROM_HERE :
      OnConnectToNCFromHere(pComponentData);
      break;
	  default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}

  return S_OK;
}

void CADSIEditLeafNode::OnConnectToNCFromHere(CComponentDataObject* pComponentData)
{
  //
  // Retrieve the path to create the connection at
  //
  CADsObject* pADsObject = GetADsObject();
  CString szDN, szPath, szName, szNCName;
  pADsObject->GetDN(szDN);
  pADsObject->GetPath(szPath);
  pADsObject->GetName(szName);
  szNCName = pADsObject->GetNCName();

  HRESULT hr = S_OK;

  ASSERT(!szNCName.IsEmpty());
  if (!szNCName.IsEmpty())
  {
    //
    // Create the new connection node
    //
    CConnectionData* pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
    CADSIEditConnectionNode* pNewConnectNode = new CADSIEditConnectionNode(pConnectData);
    if (pNewConnectNode)
    {
      pNewConnectNode->SetDisplayName(GetDisplayName());
      pNewConnectNode->GetConnectionData()->SetBasePath(szNCName);
      pNewConnectNode->GetConnectionData()->SetDistinguishedName(szNCName);
      pNewConnectNode->GetConnectionData()->SetNamingContext(L"");
      pNewConnectNode->GetConnectionData()->SetDN(szNCName);
      pNewConnectNode->GetConnectionData()->SetName(szNCName);

      CString szServer, szProvider;
      pConnectData->GetDomainServer(szServer);
      pConnectData->GetLDAP(szProvider);

      do // false loop
      {
        //
        // Crack the path to get the path to the new NC
        //
        CComPtr<IADsPathname> spPathCracker;
        hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IADsPathname, (PVOID *)&(spPathCracker));
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set((PWSTR)(PCWSTR)szNCName, ADS_SETTYPE_DN);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set((PWSTR)(PCWSTR)szServer, ADS_SETTYPE_SERVER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set((PWSTR)(PCWSTR)L"LDAP", ADS_SETTYPE_PROVIDER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        CComBSTR sbstrNewPath;
        hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &sbstrNewPath);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        pNewConnectNode->GetConnectionData()->SetPath(sbstrNewPath);

        //
        // Add the new connection node to the root container
        //
        CADSIEditRootData* pRootData = (CADSIEditRootData*)pComponentData->GetRootData();
        BOOL bResult = pRootData->AddChildToListAndUI(pNewConnectNode, pComponentData);
        ASSERT(bResult);

        // 
        //  Select the new connection node
        //
        pComponentData->UpdateResultPaneView(pNewConnectNode);
      } while (false);

      if (FAILED(hr))
      {
        delete pNewConnectNode;
        pNewConnectNode = 0;
      }
    }
  }
}

BOOL CADSIEditLeafNode::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList)
{
	CString szPath;
	GetADsObject()->GetPath(szPath);

	if (wcscmp(lpszPath, (LPCWSTR)szPath) == 0)
	{
		foundNodeList.AddHead(this);
		return TRUE;
	}

	return FALSE;
}

void CADSIEditLeafNode::RefreshOverlappedTrees(CString& szPath, CComponentDataObject* pComponentData)
{
	// Refresh any other subtrees of connections that contain this node
	//
	CList<CTreeNode*, CTreeNode*> foundNodeList;
	CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(GetRootContainer());
	if (pRootNode != NULL)
	{
		BOOL bFound = pRootNode->FindNode(szPath, foundNodeList);
		if (bFound)
		{
			POSITION pos = foundNodeList.GetHeadPosition();
			while (pos != NULL)
			{
				CADSIEditLeafNode* pFoundNode = dynamic_cast<CADSIEditLeafNode*>(foundNodeList.GetNext(pos));
//				if (pFoundNode != NULL && pFoundNode != this)
				if (pFoundNode != NULL)
				{
					if (pFoundNode->IsSheetLocked())
					{
						if (!pFoundNode->CanCloseSheets())
							continue;
						pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pFoundNode);
					}
					ASSERT(!pFoundNode->IsSheetLocked());

          CNodeList nodeList;
          nodeList.AddTail(pFoundNode);

					pFoundNode->GetContainer()->OnRefresh(pComponentData, &nodeList);
				}
			}
		}
	}
}


HRESULT CADSIEditLeafNode::OnRename(CComponentDataObject* pComponentData,
                                    LPWSTR lpszNewName)
{
  HRESULT hr = S_OK;
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return S_FALSE;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

  CString szPath, szOldPath;
  CADsObject* pADsObject = GetADsObject();
  pADsObject->GetPath(szPath);
  szOldPath = szPath;
	CADSIEditConnectionNode* pConnectionNode = pADsObject->GetConnectionNode();
	CConnectionData* pConnectData = pConnectionNode->GetConnectionData();

  CComPtr<IADsPathname> spPathCracker;
  hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&(spPathCracker));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->Set((PWSTR)(PCWSTR)szPath, ADS_SETTYPE_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrOldLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrOldLeaf);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CString szOldLeaf = bstrOldLeaf;
  CString szPrefix;
  szPrefix = szOldLeaf.Left(szOldLeaf.Find(L'=') + 1);

  hr = spPathCracker->RemoveLeafElement();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrParentPath;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrParentPath);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComPtr<IADsContainer> spDestination;
  CString sContPath(bstrParentPath);
	hr = OpenObjectWithCredentials(
											 pConnectData->GetCredentialObject(), 
											 bstrParentPath,
											 IID_IADsContainer, 
											 (LPVOID*) &spDestination
											 );
	if (FAILED(hr)) 
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

  //
  // Place the prefix in front of the name if it wasn't typed in by
  // the user
  //
  CString szNewLeaf, szNewName = lpszNewName;
  if (szNewName.Find(L'=') == -1)
  {
    szNewLeaf = szPrefix + lpszNewName;
  }
  else
  {
    szNewLeaf = lpszNewName;
  }
  hr = spPathCracker->AddLeafElement((PWSTR)(PCWSTR)szNewLeaf);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

	CComPtr<IDispatch> spObject;
	hr = spDestination->MoveHere((LPWSTR)(LPCWSTR)szOldPath,
                              (PWSTR)(PCWSTR)szNewLeaf,
                              &spObject);
  if (FAILED(hr)) 
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

	CComPtr<IADs> spIADs;
	hr = spObject->QueryInterface(IID_IADs, (LPVOID*)&spIADs);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

	CComBSTR bstrPath;
	hr = spIADs->get_ADsPath(&bstrPath);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

  CComBSTR bstrDN;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

  CComBSTR bstrLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrLeaf);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return S_FALSE;
	}

	GetADsObject()->SetPath(bstrPath);
	GetADsObject()->SetName(bstrLeaf);
	GetADsObject()->SetDN(bstrDN);

	SetDisplayName(bstrLeaf);

  return hr;
}

void CADSIEditLeafNode::OnMove(CComponentDataObject* pComponentData)
{
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

  HRESULT hr = S_OK, hCredResult;
  DWORD result;
  CComPtr<IADsContainer> pDSDestination = NULL;
  CComPtr<IDispatch> pDSObject = NULL;
  CString strDestPath;
  CString strTitle;
  strTitle.LoadString (IDS_MOVE_TITLE);

  DSBROWSEINFO dsbi;
  ::ZeroMemory( &dsbi, sizeof(dsbi) );

	TCHAR szPath[MAX_PATH+1];
  CString str;
  str.LoadString(IDS_MOVE_TARGET);

	CString strRootPath;
	GetADsObject()->GetConnectionNode()->GetADsObject()->GetPath(strRootPath);

  dsbi.hwndOwner = NULL;
  dsbi.cbStruct = sizeof (DSBROWSEINFO);
  dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
  dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
  dsbi.pszRoot = strRootPath;
  dsbi.pszPath = szPath;
  dsbi.cchPath = (sizeof(szPath) / sizeof(TCHAR));
  dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
  dsbi.pfnCallback = NULL;
  dsbi.lParam = 0;
    
  result = DsBrowseForContainer( &dsbi );
    
  if ( result == IDOK ) 
	{ // returns -1, 0, IDOK or IDCANCEL
    // get path from BROWSEINFO struct, put in text edit field
    TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
          dsbi.pszPath);
    strDestPath = dsbi.pszPath;

		CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
		hr = OpenObjectWithCredentials(
																	 pConnectData, 
																	 pConnectData->GetCredentialObject()->UseCredentials(),
																	 (LPWSTR)(LPCWSTR)strDestPath,
																	 IID_IADsContainer, 
																	 (LPVOID*) &pDSDestination,
																	 NULL,
																	 hCredResult
																	 );

		if (FAILED(hr))
		{
			if (SUCCEEDED(hCredResult))
			{
				ADSIEditErrorMessage(hr);
			}
			return;
		}

		CString sCurrentPath;
		GetADsObject()->GetPath(sCurrentPath);
		hr = pDSDestination->MoveHere((LPWSTR)(LPCWSTR)sCurrentPath,
                                 NULL,
                                 &pDSObject);
	  if (FAILED(hr)) 
		{
			ADSIEditErrorMessage(hr);
			return;
		}

		DeleteHelper(pComponentData);
		
//		RefreshOverlappedTrees(sCurrentPath, pComponentData);
//		RefreshOverlappedTrees(strDestPath, pComponentData);

		delete this;
	}
}


CADSIEditLeafNode::CADSIEditLeafNode(CADSIEditLeafNode* pLeafNode)
{
	m_pADsObject = new CADsObject(pLeafNode->m_pADsObject);
	CString sName;
	m_pADsObject->GetName(sName);

	SetDisplayName(sName);
}

BOOL CADSIEditLeafNode::OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                             BOOL* pbHideVerb, 
                                             CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

	if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsGC())
	{
		*pbHideVerb = TRUE; // always hide the verb
		return FALSE;
	}

	*pbHideVerb = FALSE; // always show the verb
	return TRUE;
}

BOOL CADSIEditLeafNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                             BOOL* pbHideVerb, 
                                             CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

	if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsGC())
	{
		*pbHideVerb = TRUE; // always hide the verb
		return FALSE;
	}

	*pbHideVerb = FALSE; // always show the verb
	return TRUE;
}

void CADSIEditLeafNode::OnDelete(CComponentDataObject* pComponentData,
                                 CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

	if (ADSIEditMessageBox(IDS_MSG_DELETE_OBJECT, MB_OKCANCEL) == IDOK)
	{
		if (IsSheetLocked())
		{
			if (!CanCloseSheets())
				return;
			pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
		}
		ASSERT(!IsSheetLocked());

		CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
		ASSERT(pContNode != NULL);

		CString sName, sClass, sPath;
		GetADsObject()->GetName(sName);
		GetADsObject()->GetClass(sClass);
		GetADsObject()->GetPath(sPath);

		HRESULT hr;
	
		hr = pContNode->DeleteChild(sClass, sPath);

		if (FAILED(hr))
		{
			//Format Error message and pop up a dialog
			ADSIEditErrorMessage(hr);
			return;
		}

//		RefreshOverlappedTrees(sPath, pComponentData);

		DeleteHelper(pComponentData);
    pComponentData->SetDescriptionBarText(pContNode);
		delete this;
	}
}

LPCWSTR CADSIEditLeafNode::GetString(int nCol) 
{ 
	CString sClass, sDN;
	GetADsObject()->GetClass(sClass);
	GetADsObject()->GetDN(sDN);

  if (GetContainer()->GetColumnSet()->GetColumnID() &&
      _wcsicmp(GetContainer()->GetColumnSet()->GetColumnID(), COLUMNSET_ID_PARTITIONS) == 0)
  {
	  switch(nCol)
	  {
		  case N_PARTITIONS_HEADER_NAME :
			  return GetDisplayName();
      case N_PARTITIONS_HEADER_NCNAME :
        return GetADsObject()->GetNCName();
		  case N_PARTITIONS_HEADER_TYPE :
			  return sClass;
		  case N_PARTITIONS_HEADER_DN :
			  return sDN;
		  default :
			  return NULL;
	  }
  }
  else
  {
	  switch(nCol)
	  {
		  case N_HEADER_NAME :
			  return GetDisplayName();
		  case N_HEADER_TYPE :
			  return sClass;
		  case N_HEADER_DN :
			  return sDN;
		  default :
			  return NULL;
	  }
  }
}

int CADSIEditLeafNode::GetImageIndex(BOOL bOpenImage) 
{
	return RECORD_IMAGE_BASE;
}

BOOL CADSIEditLeafNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                         BOOL* pbHideVerb, 
                                         CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);
	*pbHideVerb = FALSE; // always show the verb
	return TRUE;
}


HRESULT CADSIEditLeafNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                               LONG_PTR handle,
                                               CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1)
  {
    return S_OK;
  }

	CComponentDataObject* pComponentDataObject = 
			((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
	ASSERT(pComponentDataObject != NULL);
	
	CString path;
	GetADsObject()->GetPath(path);

	CString sServer, sClass;
	GetADsObject()->GetClass(sClass);
	GetADsObject()->GetConnectionNode()->GetConnectionData()->GetDomainServer(sServer);

	CADSIEditContainerNode *pContNode = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
	ASSERT(pContNode != NULL);

	CADSIEditPropertyPageHolder* pHolder = new CADSIEditPropertyPageHolder(pContNode, this, 
			pComponentDataObject, sClass, sServer, path );
	ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
	return pHolder->CreateModelessSheet(lpProvider, handle);
}

BOOL CADSIEditLeafNode::BuildSchemaPath(CString& path)
{
	return ((CADSIEditContainerNode*)m_pContainer)->BuildSchemaPath(path);
}


BOOL CADSIEditLeafNode::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
	//return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
// CADSIEditQuery


BOOL CADSIEditQueryObject::Enumerate()
{
	CADSIQueryObject enumSearch;

	// Initialize search object with path, username and password
	//
	HRESULT hCredResult = S_OK;
	HRESULT hr = enumSearch.Init(m_sPath, &m_credentialObject);
	if (FAILED(hr))
	{
		OnError(hr);
		return FALSE;
	}

  TRACE(_T("Sizeof CredentialObject: %i\n"), sizeof(CCredentialObject));

	int cCols = 2;
	LPWSTR pszAttributes[] = {L"aDSPath", L"nCName" };

	hr = enumSearch.SetSearchPrefs(m_Scope, m_ulMaxObjectCount);
	if (FAILED(hr))
	{
		OnError(hr);
		return FALSE;
	}

	enumSearch.SetFilterString((LPWSTR)(LPCWSTR)m_sFilter);
	enumSearch.SetAttributeList (pszAttributes, cCols);
	hr = enumSearch.DoQuery();
	if (SUCCEEDED(hr)) 
	{
		GetResults(enumSearch);
	}
	else
	{
		OnError(hr);
	}

	return FALSE;
}

void CADSIEditQueryObject::GetResults(CADSIQueryObject& enumSearch)
{
	HRESULT hr = S_OK;

	ADS_OBJECT_INFO* pInfo = NULL;
	ADS_SEARCH_COLUMN ColumnData;
  BOOL bNeedToFreeColumnData = FALSE;

	QUERY_STATE dwErr = QUERY_OK;
	ULONG nObjectCount = 0;
	ASSERT(nObjectCount <= m_ulMaxObjectCount);

	while (SUCCEEDED(hr))
	{
    hr = enumSearch.GetNextRow();
    if (hr == S_ADS_NOMORE_ROWS)
    {
      break;
    }

		if (FAILED(hr)) 
		{
			OnError(hr);
      break;
		}

    //
    // Get the NCName. Note this will be empty for all objects except
    // crossRef objects for app directory partitions (formerly known as NDNCs)
    //
    CString szNCName;
    hr = enumSearch.GetColumn(L"nCName", &ColumnData);
    if (SUCCEEDED(hr) && ColumnData.pADsValues)
    {
      szNCName = ColumnData.pADsValues->DNString;
      enumSearch.FreeColumn(&ColumnData);
    }

		// Get the path column
		bNeedToFreeColumnData = FALSE;
		hr = enumSearch.GetColumn(L"aDSPath", &ColumnData);
		if (FAILED(hr))
		{
			enumSearch.FreeColumn(&ColumnData);
			bNeedToFreeColumnData = FALSE;

			ADSIEditErrorMessage(hr);

      //
			// if we can't get the path there must be something extremely wrong since the
			// since the path is guaranteed, so we should break instead of continuing
      //
			break;
		}
		
		bNeedToFreeColumnData = TRUE;
		if (nObjectCount >= m_ulMaxObjectCount)
		{
			dwErr = ERROR_TOO_MANY_NODES;
			OnError(dwErr);
			break;
		}
		CString sPath(ColumnData.pADsValues->CaseIgnoreString);

		CComPtr<IDirectoryObject> spDirObject;
		hr = OpenObjectWithCredentials(
												 &m_credentialObject,
												 (LPWSTR)(LPCWSTR)sPath,
												 IID_IDirectoryObject, 
												 (LPVOID*) &spDirObject
												 );
		if ( FAILED(hr) )
		{
      TRACE(_T("Unable to bind to new object. Creating incomplete object. hr=0x%x\n"), hr);
			// Create an incomplete object
			CreateNewObject(sPath, NULL, szNCName);

			if (bNeedToFreeColumnData)
			{
				enumSearch.FreeColumn(&ColumnData);
				bNeedToFreeColumnData = FALSE;
			}
			continue;
		}

		ASSERT(pInfo == NULL);
		hr = spDirObject->GetObjectInformation(&pInfo);
		if (FAILED(hr))
		{
      TRACE(_T("Unable to get object info. Creating incomplete object. hr=0x%x\n"), hr);

			// Create an incomplete object
			CreateNewObject(sPath, NULL, szNCName);

			if (bNeedToFreeColumnData)
			{
				enumSearch.FreeColumn(&ColumnData);
				bNeedToFreeColumnData = FALSE;
			}

			continue;
		}

		ASSERT(pInfo != NULL);
    TRACE(_T("Creating complete object\n"));

		// Create a complete object
		CreateNewObject(sPath, pInfo, szNCName);

		FreeADsMem(pInfo);
		pInfo = NULL;

		enumSearch.FreeColumn(&ColumnData);
		bNeedToFreeColumnData = FALSE;
		nObjectCount++;
	} // while

	if (pInfo != NULL)
	{
		FreeADsMem(pInfo);
	}

	if (bNeedToFreeColumnData)
	{
		enumSearch.FreeColumn(&ColumnData);
	}

}

void CADSIEditQueryObject::CreateNewObject(CString& sPath,
														               ADS_OBJECT_INFO* pInfo,
                                           PCWSTR pszNCName)
{
	CADsObject* pObject = new CADsObject(m_pConnectNode);	
  if (pObject)
  {
    pObject->SetNCName(pszNCName);

	  if (pInfo != NULL)
	  {
		  // This means we have a complete object
		  pObject->SetPath(sPath);

		  // Get the leaf name via PathCracker
		  CString sDisplayName, sDN;
		  CrackPath(sPath, sDisplayName, sDN);
		  pObject->SetName(sDisplayName);
		  pObject->SetDN(sDN);

		  // make the prefix uppercase
		  int idx = sDisplayName.Find(L'=');
		  if (idx != -1)
		  {
			  CString sPrefix, sRemaining;
			  sPrefix = sDisplayName.Left(idx);
			  sPrefix.MakeUpper();

			  int iCount = sDisplayName.GetLength();
			  sRemaining = sDisplayName.Right(iCount - idx);
			  sDisplayName = sPrefix + sRemaining;
		  }

		  pObject->SetClass(pInfo->pszClassName);
		  pObject->SetComplete(TRUE);


		  if (IsContainer(pInfo->pszClassName, pInfo->pszSchemaDN))
		  {
        TRACE(_T("IsContainer returned TRUE\n"));
			  CADSIEditContainerNode* pContNode = new CADSIEditContainerNode(pObject);
			  pObject = NULL;
			  pContNode->SetDisplayName(sDisplayName);

			  pContNode->GetADsObject()->SetConnectionNode(m_pConnectNode);
		 	  VERIFY(AddQueryResult(pContNode));
		  }
		  else
		  {
        TRACE(_T("IsContainer returned FALSE\n"));
			  CADSIEditLeafNode *pLeafNode = new CADSIEditLeafNode(pObject);
			  pObject = NULL;
			  pLeafNode->SetDisplayName(sDisplayName);
			  pLeafNode->GetADsObject()->SetConnectionNode(m_pConnectNode);
			  VERIFY(AddQueryResult(pLeafNode));
		  }
	  }
	  else
	  {
		  // Get the leaf name and DN via PathCracker
		  CString sCrackPath, sDN;
		  CrackPath(sPath, sCrackPath, sDN);
		  pObject->SetName(sCrackPath);
		  pObject->SetDN(sDN);
		  pObject->SetPath(sPath);

		  CString sDisplayName;
		  sDisplayName = sPath;

		  // Make the prefix upper case
		  int idx = sDisplayName.Find(L'=');
		  if (idx != -1)
		  {
			  CString sPrefix, sRemaining;
			  sPrefix = sDisplayName.Left(idx);
			  sPrefix.MakeUpper();

			  int iCount = sDisplayName.GetLength();
			  sRemaining = sDisplayName.Right(iCount - idx);
			  sDisplayName = sPrefix + sRemaining;
		  }
		  pObject->SetComplete(FALSE);

		  // Make all nodes that were of undetermined type leaf nodes
		  CADSIEditLeafNode *pLeafNode = new CADSIEditLeafNode(pObject);
		  pObject = NULL;

		  pLeafNode->SetDisplayName(sCrackPath);
		  pLeafNode->GetADsObject()->SetConnectionNode(m_pConnectNode);
		  VERIFY(AddQueryResult(pLeafNode));
	  }
  }

	if (pObject != NULL)
	{
		delete pObject;
		pObject = NULL;
	}
}

void CADSIEditQueryObject::CrackPath(const CString sName, CString& sPath, CString& sDN)
{
	HRESULT hr = PathCracker()->Set((LPWSTR)(LPCWSTR)sName, ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
		TRACE(_T("Set failed. %s"), hr);
	}

  //
  // Get the current escaped mode
  //
  LONG lEscapedMode = ADS_ESCAPEDMODE_DEFAULT;
  hr = PathCracker()->get_EscapedMode(&lEscapedMode);

  hr = PathCracker()->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);

	// Get the leaf name
	CComBSTR bstrPath;
	hr = PathCracker()->Retrieve(ADS_FORMAT_LEAF, &bstrPath);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sPath = L"";
	}
	else
	{
		sPath = bstrPath;
	}

  //
  // Put the escaped mode back to what it was
  //
  hr = PathCracker()->put_EscapedMode(lEscapedMode);

	// Get the leaf DN
	CComBSTR bstrDN;
	hr = PathCracker()->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDN = L"";
	}
	else
	{
		sDN = bstrDN;
	}
}

IADsPathname* CADSIEditQueryObject::PathCracker()
{
  if (m_pPathCracker == NULL)
  {
     HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IADsPathname, (PVOID *)&(m_pPathCracker));
     ASSERT((S_OK == hr) && ((m_pPathCracker) != NULL));
  }
  return m_pPathCracker;
}

bool CADSIEditQueryObject::IsContainer(PCWSTR pszClass, PCWSTR pszPath)
{
  return m_pConnectNode->IsClassAContainer(&m_credentialObject, pszClass, pszPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editor.h
//
//--------------------------------------------------------------------------

#ifndef _ADSIEDIT_EDIT_H
#define _ADSIEDIT_EDIT_H

class CADSIEditConnectionNode;
class CADSIFilterObject;

#include "common.h"
#include "snapdata.h"
#include "filterui.h"
#include "query.h"

typedef enum
{
	QUERY_OK = 0,
	ERROR_TOO_MANY_NODES
} QUERY_STATE;

extern LPCWSTR g_lpszGC;

class CADSIEditContainerNode; 

///////////////////////////////////////////////////////////////////////////////
// CADSIEditBackgroundThread

class CADSIEditBackgroundThread : public CBackgroundThread
{
public:
	CADSIEditBackgroundThread() : CBackgroundThread(){};

  virtual BOOL InitInstance() 
	{ 
		HRESULT hr = ::OleInitialize(NULL);
		if (FAILED(hr))
		{
			return FALSE;
		}
		return TRUE; 
	}	// MFC override

	virtual int ExitInstance()
	{
		::OleUninitialize();
		return CWinThread::ExitInstance();
	}
};

/////////////////////////////////////////////////////////////////////////////////
// CADsObject :

class CADsObject : public CObject
{
public:
	CADsObject(CADSIEditConnectionNode* cConnectNode);
	CADsObject(CADsObject* pADsObject);
	CADsObject();

	CADSIEditConnectionNode* GetConnectionNode() { return m_pConnectionNode; }
	void SetConnectionNode(CADSIEditConnectionNode* pConnectionNode) { m_pConnectionNode = pConnectionNode; }
	void GetName(CString& sName) { sName = m_sName; }
	void SetName(LPCWSTR lpszName);
	void GetDN(CString& sDN) { sDN = m_sDN; }
  PCWSTR GetDNString() { return m_sDN; }
	void SetDN(LPCWSTR lpszDN) { m_sDN = lpszDN; }
	void GetPath(CString& sPath) { sPath = m_sPath; }
	void SetPath(LPCWSTR sPath) { m_sPath = sPath; }	
	void GetClass(CString& sClass ) { sClass = m_sClass; }
	void SetClass(LPCWSTR lpszClass) { m_sClass = lpszClass; }
	BOOL GetContainer() { return m_bContainer; }
	void SetContainer(const BOOL bContainer) { m_bContainer = bContainer; }
	BOOL IsIntermediateNode() { return m_bIntermediate; }
	void SetIntermediateNode(BOOL bIntermediate) { m_bIntermediate = bIntermediate; }
	BOOL IsComplete() { return m_bComplete; }
	void SetComplete(const BOOL bComplete) { m_bComplete = bComplete; }
  PCWSTR GetNCName() { return m_szNCName; }
  void SetNCName(PCWSTR pszNCName) { m_szNCName = pszNCName; }

private:
	CADSIEditConnectionNode* m_pConnectionNode;
	CString m_sName;
	CString m_sDN;
	CString m_sClass;
	CString m_sPath;
  CString m_szNCName;

	BOOL m_bContainer;
	BOOL m_bIntermediate;
	BOOL m_bComplete;
};

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterObject

class CADSIFilterObject
{
public :
	CADSIFilterObject();
	CADSIFilterObject(CADSIFilterObject* pFilterObject);
	~CADSIFilterObject() {}

	void GetFilterString(CString& sFilter);
	void GetUserDefinedFilter(CString& sUserFilter) { sUserFilter = m_sUserFilter; }
	void SetUserDefinedFilter(LPCWSTR lpszUserFilter) { m_sUserFilter = lpszUserFilter; }
	void GetContainerList(CStringList* pContainerList) { CopyStringList(pContainerList, &m_ContainerList); }
	void SetContainerList(CStringList* pContainerList) { CopyStringList(&m_ContainerList, pContainerList); }
	BOOL InUse() { return m_bInUse; }
	void SetInUse(BOOL bInUse) { m_bInUse = bInUse; }

	void Save(IStream* pStm);
	static HRESULT CreateFilterFromStream(IStream* pStm, CADSIFilterObject** ppFilterObject);

private :
	CString m_sFilterString;
	CString m_sUserFilter;
	CStringList m_ContainerList;
	BOOL m_bInUse;
};

////////////////////////////////////////////////////////////////////////////////
// CCredentialObject

class CCredentialObject
{
public :
	CCredentialObject() 
	{
		m_sUsername = _T("");
		m_lpszPassword = NULL;
		m_bUseCredentials = FALSE;
	}

	CCredentialObject(CCredentialObject* pCredObject);

	~CCredentialObject() 
	{
		free(m_lpszPassword);
	}

	void GetUsername(CString& sUsername) { sUsername = m_sUsername; }
	void SetUsername(LPCWSTR lpszUsername) { m_sUsername = lpszUsername; }
	HRESULT GetPassword(LPWSTR lpszPassword);
	HRESULT SetPasswordFromHwnd(HWND hWnd);
	BOOL UseCredentials() { return m_bUseCredentials; }
	void SetUseCredentials(const BOOL bUseCred) { m_bUseCredentials = bUseCred; }

private :
	CString m_sUsername;
	LPWSTR m_lpszPassword;
	BOOL m_bUseCredentials;
};

/////////////////////////////////////////////////////////////////////////////////
// CConnectionData

class CConnectionData : public CADsObject
{
public:
	CConnectionData();

	CConnectionData(CADSIEditConnectionNode* pConnectNode);
	CConnectionData(CConnectionData* pConnectData);
	~CConnectionData();

	void ConstructorHelper();

	void GetDomainServer(CString& sServer) { sServer = m_sDomainServer; }
	void SetDomainServer(LPCWSTR lpszDomainServer) { m_sDomainServer = lpszDomainServer; }
	void GetPort(CString& sPort) { sPort = m_sPort; }
	void SetPort(LPCWSTR lpszPort) { m_sPort = lpszPort; }
	void GetDistinguishedName(CString& sDistinguished) { sDistinguished = m_sDistinguishedName; }
	void SetDistinguishedName(LPCWSTR lpszDistName) { m_sDistinguishedName = lpszDistName; }
	void GetNamingContext(CString& sNamingContext) { sNamingContext = m_sNamingContext; }
	void SetNamingContext(LPCWSTR lpszNamingContext) { m_sNamingContext = lpszNamingContext; }
	void GetBasePath(CString& sBasePath) { sBasePath = m_sBasePath; }
	void SetBasePath(LPCWSTR lpszPath) { m_sBasePath = lpszPath; }
	void GetBaseLDAPPath(CString& sBasePath);
	void GetLDAP(CString& sLDAP) { sLDAP = m_sLDAP; }
	void SetLDAP(LPCWSTR lpszLDAP) { m_sLDAP = lpszLDAP; }
	BOOL GetUserDefinedServer() { return m_bUserDefinedServer; }
	void SetUserDefinedServer(BOOL bUserDefinedServer) { m_bUserDefinedServer = bUserDefinedServer; }
	void SetPath(LPCWSTR lpszPath) { CADsObject::SetPath(lpszPath); }

	// Schema paths
	//
	void SetSchemaPath(LPCWSTR lpszPath) { m_sSchemaPath = lpszPath; }
	HRESULT GetSchemaPath(CString& sPath);
	void SetAbstractSchemaPath(LPCWSTR lpszPath) { m_sAbstractSchemaPath = lpszPath; }
	void GetAbstractSchemaPath(CString& sPath);

	// Filter Options
	//
	void SetFilter(CADSIFilterObject* pFilter) { m_pFilterObject = pFilter; }
	CADSIFilterObject* GetFilter() { return m_pFilterObject; }

	CCredentialObject* GetCredentialObject() { return m_pCredentialsObject; }

	ULONG GetMaxObjectCount() { return m_nMaxObjectCount; }
	void SetMaxObjectCount(ULONG nMaxCount) { m_nMaxObjectCount = nMaxCount; }

  BOOL IsGC() { return (_wcsicmp(LPCWSTR(m_sLDAP), g_lpszGC) == 0); }
	BOOL IsRootDSE() { return m_bRootDSE; }
	void SetRootDSE(const BOOL bRootDSE) { m_bRootDSE = bRootDSE; }
	void SetIDirectoryInterface(IDirectoryObject* pDirObject);

	void Save(IStream* pStm);
	static CConnectionData* Load(IStream* pStm);
	static HRESULT LoadBasePathFromContext(CConnectionData* pConnectData, const CString sContext);
	static HRESULT GetServerNameFromDefault(CConnectionData* pConnectData);
	void BuildPath();

	HRESULT GetADSIServerName(OUT CString& szServer, IN IUnknown* pUnk);

private:
	CString m_sBasePath;
	CString m_sDomainServer;
	CString m_sPort;
	CString m_sDistinguishedName;
	CString m_sNamingContext;
	CString m_sLDAP;
	CString m_sSchemaPath;
	CString m_sAbstractSchemaPath;

	// Filter Options
	//
	CADSIFilterObject* m_pFilterObject;

	CCredentialObject* m_pCredentialsObject;

	IDirectoryObject* m_pDirObject;

	BOOL m_bCredentials;
	BOOL m_bRootDSE;
	BOOL m_bUserDefinedServer;
	ULONG m_nMaxObjectCount;	// Maximum Number of objects per container
};



//////////////////////////////////////////////////////////////////////////////////
// CADSIEditLeafNode : 

class CADSIEditLeafNode : public CLeafNode
{
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;

protected:
	CADsObject* m_pADsObject;

public:
  CADSIEditLeafNode(CADsObject* pADsObject) 
	{ 
		m_pADsObject = pADsObject;
	}

	~CADSIEditLeafNode()
	{
		delete m_pADsObject;
	}

	// node info
	DECLARE_NODE_GUID()

	CADSIEditLeafNode(CADSIEditLeafNode* pLeafNode);

	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
								 						 long *pInsertionAllowed);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
  virtual void OnConnectToNCFromHere(CComponentDataObject* pComponentData);
	virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual HRESULT OnRename(CComponentDataObject* pComponentData, LPWSTR lpszNewName);
	virtual void OnMove(CComponentDataObject* pComponentData);
	virtual LPCWSTR GetString(int nCol);
  virtual int GetImageIndex(BOOL bOpenImage);

	virtual BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);
	virtual void RefreshOverlappedTrees(CString& szPath, CComponentDataObject* pComponentData);

  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);
  virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);

	virtual BOOL CanCloseSheets();

	virtual void SetContainer(BOOL container) { m_pADsObject->SetContainer(container); }

	BOOL BuildSchemaPath(CString& sPath);

	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
		{ return CADSIEditLeafMenuHolder::GetContextMenuItem(); }


	virtual CADsObject* GetADsObject() { return m_pADsObject; }

	CContainerNode* GetRootContainer()
		{ return (m_pContainer != NULL) ? m_pContainer->GetRootContainer() : NULL; }
};

//////////////////////////////////////////////////////////////////////////////////
// CADSIEditContainerNode :

class CADSIEditContainerNode : public CMTContainerNode
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;



public:
  CADSIEditContainerNode() : m_pPartitionsColumnSet(NULL)
	{
		m_pADsObject = new CADsObject();
		m_nState = notLoaded;
    m_szDescriptionText = L"";
	}

	CADSIEditContainerNode(CADsObject* pADsObject);
	CADSIEditContainerNode(CADSIEditContainerNode* pContNode);

	~CADSIEditContainerNode()
	{
		delete m_pADsObject;

    if (m_pPartitionsColumnSet)
    {
      delete m_pPartitionsColumnSet;
      m_pPartitionsColumnSet = NULL;
    }
	}

	// node info
	DECLARE_NODE_GUID()

	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
							               long *pInsertionAllowed);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual HRESULT OnRename(CComponentDataObject* pComponentData, LPWSTR lpszNewName);
	virtual void OnMove(CComponentDataObject* pComponentData);
	virtual void OnCreate(CComponentDataObject* pComponentData);
  virtual void OnConnectFromHere(CComponentDataObject* pComponentData);
  virtual void OnConnectToNCFromHere(CComponentDataObject* pComponentData);
	virtual CQueryObj* OnCreateQuery();
	virtual LPCWSTR GetString(int nCol);

  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);
  virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);

	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);

	virtual void SetContainer(BOOL container) { m_pADsObject->SetContainer(container); }

	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
		{ return CADSIEditContainerMenuHolder::GetContextMenuItem(); }

	virtual int GetImageIndex(BOOL bOpenImage);

	virtual CBackgroundThread* CreateThreadObject() 
	{ 
		return new CADSIEditBackgroundThread(); // override if need derived tipe of object
	} 

	BOOL GetNamingAttribute(LPCWSTR lpszClass, CStringList* sNamingAttr);
	BOOL BuildSchemaPath(CString& sPath);

  virtual void OnDeleteMultiple(CComponentDataObject* pComponentData,
                                CNodeList* pNodeList);

	virtual HRESULT DeleteChild(LPCWSTR lpszClass, LPCWSTR lpszPath);
	virtual HRESULT DeleteSubtree(LPCWSTR lpszPath);
	virtual BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);
	void RefreshOverlappedTrees(CString& sPath, CComponentDataObject* pComponentData);

	virtual CADsObject* GetADsObject() { return m_pADsObject; }

  virtual CColumnSet* GetColumnSet();

  virtual LPCWSTR GetColumnID()
  { 
    return GetColumnSet()->GetColumnID();
  }

  virtual LPWSTR GetDescriptionBarText()
  {
    LPWSTR lpszFormat = L"%d Object(s)";
    int iCount = m_containerChildList.GetCount() + m_leafChildList.GetCount();

    m_szDescriptionText.Format(lpszFormat, iCount);
    return (LPWSTR)(LPCWSTR)m_szDescriptionText;
  }

  //
  // Allow multiple selection
  //
  virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    return S_FALSE;
  }

protected:
	virtual BOOL CanCloseSheets();
	virtual void OnChangeState(CComponentDataObject* pComponentDataObject);
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);
  virtual void OnError(DWORD dwErr);

	CADsObject* m_pADsObject;

  CADSIEditColumnSet* m_pPartitionsColumnSet;
  CString m_szDescriptionText;
};

//////////////////////////////////////////////////////////////////////

class CADSIEditQueryObject : public CQueryObj
{
public:
	CADSIEditQueryObject(LPCWSTR lpszPath, 
											 LPCWSTR lpszFilter,
											 ADS_SCOPEENUM scope,
											 ULONG ulMaxObjectCount,
											 CCredentialObject* pCredObject,
                       BOOL bIsGC,
											 CADSIEditConnectionNode* pConnectNode) 
											: m_credentialObject(pCredObject)
	{ 
		m_sPath = lpszPath;
		m_sFilter = lpszFilter;
		m_ulMaxObjectCount = ulMaxObjectCount;
		m_Scope = scope;
    m_bIsGC = bIsGC;

    m_pPathCracker = NULL;

		// NOTE : this holds a pointer across threads but is not
		//					being used.  We should be sure not to use it or
		//					find another way to put the pointer in the data
		//					structures for any new nodes created
		//
		m_pConnectNode = pConnectNode;		
			
	}

  virtual ~CADSIEditQueryObject()
  {
/*    if (m_pPathCracker != NULL)
    {
      m_pPathCracker->Release();
    }
*/  }

	virtual BOOL Enumerate();
	virtual bool IsContainer(PCWSTR pszClass, PCWSTR pszPath);

  BOOL IsGC() { return m_bIsGC; }

	void GetResults(CADSIQueryObject& enumSearch);
	void CreateNewObject(CString& sPath,
		 					         ADS_OBJECT_INFO* pInfo,
                       PCWSTR pszNCName);
	void CrackPath(const CString sName, CString& sPath, CString& sDN);
  IADsPathname* PathCracker();
	void SetFilter(LPCWSTR lpszFilter) { m_sFilter = lpszFilter; }
	void GetFilter(CString& sFilter) { sFilter = m_sFilter; }

protected:
//	CADsObject *m_pADsObject;
	CString m_sPath;
	CString m_sFilter;

	ADS_SCOPEENUM m_Scope;

  BOOL m_bIsGC;
	ULONG m_ulMaxObjectCount;
	CCredentialObject m_credentialObject;
	CADSIEditConnectionNode* m_pConnectNode;

  CComPtr<IADsPathname> m_pPathCracker;
};


#endif _ADSIEDIT_EDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editui.cpp ===
#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "query.h"
#include "attrres.h"
#include "editui.h"
#include "common.h"
#include "attrqry.h"
#include "editorui.h"

///////////////////////////////////////////////////////////////////////////////////////
// CValueEditDialog

BEGIN_MESSAGE_MAP(CValueEditDialog, CDialog)
END_MESSAGE_MAP()

HRESULT CValueEditDialog::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  m_pOldADsValue    = pAttributeEditorInfo->pADsValue;
  m_dwOldNumValues  = pAttributeEditorInfo->dwNumValues;
  m_szClass         = pAttributeEditorInfo->lpszClass;
  m_szAttribute     = pAttributeEditorInfo->lpszAttribute;
  m_bMultivalued    = pAttributeEditorInfo->bMultivalued;
  m_pfnBindingFunction = pAttributeEditorInfo->lpfnBind;
  m_lParam          = pAttributeEditorInfo->lParam;

  return hr;
}

HRESULT CValueEditDialog::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  *ppADsValue = NULL;
  *pdwNumValues = 0;
  return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// CSingleStringEditor

CValueEditDialog* CreateSingleStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CSingleStringEditor;
}

BEGIN_MESSAGE_MAP(CSingleStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CSingleStringEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (m_szOldValue.IsEmpty())
  {
    CString szNotSet;
    VERIFY(szNotSet.LoadString(IDS_NOTSET));
    SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  }
  else
  {
    SetDlgItemText(IDC_VALUE_EDIT, m_szOldValue);
  }

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  return CDialog::OnInitDialog();
}

void CSingleStringEditor::OnOK()
{
  GetDlgItemText(IDC_VALUE_EDIT, m_szNewValue);

  CDialog::OnOK();
}

HRESULT CSingleStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_CASE_IGNORE_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->CaseIgnoreString;
          break;

        case ADSTYPE_CASE_EXACT_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->CaseExactString;
          break;

        case ADSTYPE_PRINTABLE_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->PrintableString;
          break;

        case ADSTYPE_DN_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->DNString;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
  }
  return hr;
}

void CSingleStringEditor::OnClear()
{
  //
  // Change the text in the edit box to "<not set>"
  //
  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));
  SetDlgItemText(IDC_VALUE_EDIT, szNotSet);

  //
  // Change the focus to the edit box
  //
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);
}

HRESULT CSingleStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));

  if (m_szNewValue == szNotSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_CASE_IGNORE_STRING:
          (*ppADsValue)->CaseIgnoreString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->CaseIgnoreString != NULL)
          {
            wcscpy((*ppADsValue)->CaseIgnoreString, m_szNewValue);
          }
          else
          {
            delete *ppADsValue;
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        case ADSTYPE_CASE_EXACT_STRING:
          (*ppADsValue)->CaseExactString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->CaseExactString != NULL)
          {
            wcscpy((*ppADsValue)->CaseExactString, m_szNewValue);
          }
          else
          {
            delete *ppADsValue;
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        case ADSTYPE_PRINTABLE_STRING:
          (*ppADsValue)->PrintableString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->PrintableString != NULL)
          {
            wcscpy((*ppADsValue)->PrintableString, m_szNewValue);
          }
          else
          {
            delete *ppADsValue;
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        case ADSTYPE_DN_STRING:
          (*ppADsValue)->DNString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->DNString != NULL)
          {
            wcscpy((*ppADsValue)->DNString, m_szNewValue);
          }
          else
          {
            delete *ppADsValue;
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        default:
          ASSERT(FALSE);
          delete *ppADsValue;
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CMultiStringEditor

CValueEditDialog* CreateMultiStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CMultiStringEditor;
}

BEGIN_MESSAGE_MAP(CMultiStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
  ON_EN_CHANGE(IDC_VALUE_EDIT, OnEditChange)
END_MESSAGE_MAP()

BOOL CMultiStringEditor::OnInitDialog()
{
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Fill the list box with the current values
  //
  POSITION pos = m_szOldValueList.GetHeadPosition();
  while (pos != NULL)
  {
    CString szValue = m_szOldValueList.GetNext(pos);
    if (!szValue.IsEmpty())
    {
      SendDlgItemMessage(IDC_VALUE_LIST, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)szValue);
    }
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiStringEditor::OnOK()
{
  //
  // Get the values out of the list box
  //
  m_szNewValueList.RemoveAll();

  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
    int iCount = pListBox->GetCount();
    for (int idx = 0; idx < iCount; idx++)
    {
      CString szNewValue;
      pListBox->GetText(idx, szNewValue);

      m_szNewValueList.AddTail(szNewValue);
    }
  }
  CDialog::OnOK();
}

void CMultiStringEditor::OnAddButton()
{
  //
  // Add the value to the list box and clear the edit field
  //
  CString szNewValue;
  GetDlgItemText(IDC_VALUE_EDIT, szNewValue);

  if (!szNewValue.IsEmpty())
  {
    LRESULT lFind = SendDlgItemMessage(IDC_VALUE_LIST, 
                                       LB_FINDSTRING, 
                                       (WPARAM)-1, 
                                       (LPARAM)(PCWSTR)szNewValue);
    if (lFind != LB_ERR)
    {
      //
      // Ask them if they really want to add the duplicate value
      //
      UINT nResult = ADSIEditMessageBox(IDS_ATTREDIT_DUPLICATE_VALUE, MB_YESNO);
      lFind = (nResult == IDYES) ? LB_ERR : 1;
    }

    if (lFind == LB_ERR)
    {
      SendDlgItemMessage(IDC_VALUE_LIST, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)szNewValue);
    }
  }

  SetDlgItemText(IDC_VALUE_EDIT, L"");

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();
}

void CMultiStringEditor::OnRemoveButton()
{
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
    int iCurSel = pListBox->GetCurSel();
    if (iCurSel != LB_ERR)
    {
      //
      // Put the old value into the edit box
      //
      CString szOldValue;
      pListBox->GetText(iCurSel, szOldValue);
      SetDlgItemText(IDC_VALUE_EDIT, szOldValue);

      //
      // Delete the item from the list box
      //
      pListBox->DeleteString(iCurSel);
    }
  }

  //
  // Manage Button States
  //
  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();
}

void CMultiStringEditor::ManageButtonStates()
{
  //
  // Change the default button to the Add button
  //
  CString szValue;
  GetDlgItemText(IDC_VALUE_EDIT, szValue);

  if (szValue.IsEmpty())
  {
    //
    // Set the default button to OK
    //
    SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
    SendDlgItemMessage(IDC_ATTR_ADD_BUTTON, 
                       BM_SETSTYLE, 
                       BS_PUSHBUTTON, 
                       MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDOK,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       MAKELPARAM(TRUE, 0));
  }
  else
  {
    //
    // Set the default button to the Add button
    //
    SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_ADD_BUTTON, 0);
    SendDlgItemMessage(IDOK, 
                       BM_SETSTYLE, 
                       BS_PUSHBUTTON, 
                       MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDC_ATTR_ADD_BUTTON,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       MAKELPARAM(TRUE, 0));
  }

  LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
  if (lSelection != LB_ERR)
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
  }
  else
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
  }
}

void CMultiStringEditor::OnListSelChange()
{
  ManageButtonStates();
}

void CMultiStringEditor::OnEditChange()
{
  ManageButtonStates();
}

void CMultiStringEditor::UpdateListboxHorizontalExtent()
{
	int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
	  CClientDC dc(pListBox);
	  int nItems = pListBox->GetCount();
	  for	(int i=0; i < nItems; i++)
	  {
		  TEXTMETRIC tm;
		  VERIFY(dc.GetTextMetrics(&tm));
		  CString szBuffer;
		  pListBox->GetText(i, szBuffer);
		  CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
		  nHorzExtent = max(ext.cx ,nHorzExtent); 
	  }
	  pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_CASE_IGNORE_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].CaseIgnoreString);
            break;

          case ADSTYPE_CASE_EXACT_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].CaseExactString);
            break;

          case ADSTYPE_PRINTABLE_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].PrintableString);
            break;

          case ADSTYPE_DN_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].DNString);
            break;
            
          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}

HRESULT CMultiStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_szNewValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_szNewValueList.GetHeadPosition();
      while (pos != NULL)
      {
        CString szNewValue = m_szNewValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_CASE_IGNORE_STRING:
            (*ppADsValue)[idx].CaseIgnoreString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].CaseIgnoreString != NULL)
            {
              wcscpy((*ppADsValue)[idx].CaseIgnoreString, szNewValue);
            }
            else
            {
              delete[] *ppADsValue;
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_CASE_EXACT_STRING:
            (*ppADsValue)[idx].CaseExactString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].CaseExactString != NULL)
            {
              wcscpy((*ppADsValue)[idx].CaseExactString, szNewValue);
            }
            else
            {
              delete[] *ppADsValue;
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_PRINTABLE_STRING:
            (*ppADsValue)[idx].PrintableString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].PrintableString != NULL)
            {
              wcscpy((*ppADsValue)[idx].PrintableString, szNewValue);
            }
            else
            {
              delete[] *ppADsValue;
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_DN_STRING:
            (*ppADsValue)[idx].DNString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].DNString != NULL)
            {
              wcscpy((*ppADsValue)[idx].DNString, szNewValue);
            }
            else
            {
              delete[] *ppADsValue;
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          default:
            ASSERT(FALSE);
            delete[] *ppADsValue;
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleIntEditor

CValueEditDialog* CreateSingleIntEditor(PCWSTR pszClass,
                                        PCWSTR pszAttribute,
                                        ADSTYPE adsType,
                                        BOOL bMultivalued)
{
  return new CSingleIntEditor;
}

BEGIN_MESSAGE_MAP(CSingleIntEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CSingleIntEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (!m_bValueSet)
  {
    CString szNotSet;
    VERIFY(szNotSet.LoadString(IDS_NOTSET));
    SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  }
  else
  {
    SetDlgItemInt(IDC_VALUE_EDIT, m_dwOldValue, FALSE);
  }

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  //
  // Disable IME support on the edit box
  //
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_VALUE_EDIT), NULL);

  return CDialog::OnInitDialog();
}

void CSingleIntEditor::OnOK()
{
  m_dwNewValue = GetDlgItemInt(IDC_VALUE_EDIT, &m_bValueSet, FALSE);

  CDialog::OnOK();
}

HRESULT CSingleIntEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_INTEGER:
          m_dwOldValue = pAttributeEditorInfo->pADsValue->Integer;
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
  }
  return hr;
}

void CSingleIntEditor::OnClear()
{
  //
  // Change the text in the edit box to "<not set>"
  //
  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));
  SetDlgItemText(IDC_VALUE_EDIT, szNotSet);

  //
  // Change the focus to the edit box
  //
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  m_bValueSet = FALSE;
}

HRESULT CSingleIntEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));

  if (!m_bValueSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_INTEGER:
          (*ppADsValue)->Integer = m_dwNewValue;
          break;

        default:
          ASSERT(FALSE);
          delete *ppADsValue;
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleLargeIntEditor

CValueEditDialog* CreateSingleLargeIntEditor(PCWSTR pszClass,
                                             PCWSTR pszAttribute,
                                             ADSTYPE adsType,
                                             BOOL bMultivalued)
{
  return new CSingleLargeIntEditor;
}

BEGIN_MESSAGE_MAP(CSingleLargeIntEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CSingleLargeIntEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (!m_bValueSet)
  {
    CString szNotSet;
    VERIFY(szNotSet.LoadString(IDS_NOTSET));
    SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  }
  else
  {
    CString szOldValue;
    litow(m_liOldValue, szOldValue);
    SetDlgItemText(IDC_VALUE_EDIT, szOldValue);
  }

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  //
  // Disable IME support on the edit box
  //
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_VALUE_EDIT), NULL);

  return CDialog::OnInitDialog();
}

void CSingleLargeIntEditor::OnOK()
{
  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));

  CString szNewValue;
  GetDlgItemText(IDC_VALUE_EDIT, szNewValue);

  if (szNewValue == szNotSet)
  {
    m_bValueSet = FALSE;
  }
  else
  {
    wtoli(szNewValue, m_liNewValue);
    m_bValueSet = TRUE;
  }
  CDialog::OnOK();
}

HRESULT CSingleLargeIntEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_LARGE_INTEGER:
          m_liOldValue = pAttributeEditorInfo->pADsValue->LargeInteger;
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}

void CSingleLargeIntEditor::OnClear()
{
  //
  // Change the text in the edit box to "<not set>"
  //
  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));
  SetDlgItemText(IDC_VALUE_EDIT, szNotSet);

  //
  // Change the focus to the edit box
  //
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  m_bValueSet = FALSE;
}

HRESULT CSingleLargeIntEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  if (!m_bValueSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_LARGE_INTEGER:
          (*ppADsValue)->LargeInteger = m_liNewValue;
          break;

        default:
          ASSERT(FALSE);
          delete *ppADsValue;
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleBooleanEditor

CValueEditDialog* CreateSingleBooleanEditor(PCWSTR pszClass,
                                            PCWSTR pszAttribute,
                                            ADSTYPE adsType,
                                            BOOL bMultivalued)
{
  return new CSingleBooleanEditor;
}

BEGIN_MESSAGE_MAP(CSingleBooleanEditor, CValueEditDialog)
END_MESSAGE_MAP()

BOOL CSingleBooleanEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (!m_bValueSet)
  {
    SendDlgItemMessage(IDC_NOTSET_RADIO, BM_SETCHECK, BST_CHECKED, 0);
  }
  else
  {
    if (m_bOldValue)
    {
      SendDlgItemMessage(IDC_TRUE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    }
    else
    {
      SendDlgItemMessage(IDC_FALSE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    }
  }

  return CDialog::OnInitDialog();
}

void CSingleBooleanEditor::OnOK()
{
  LRESULT lTrueCheck = SendDlgItemMessage(IDC_TRUE_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lFalseCheck = SendDlgItemMessage(IDC_FALSE_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lNotSetCheck = SendDlgItemMessage(IDC_NOTSET_RADIO, BM_GETCHECK, 0, 0);

  if (lTrueCheck == BST_CHECKED)
  {
    m_bNewValue = TRUE;
    m_bValueSet = TRUE;
  }

  if (lFalseCheck == BST_CHECKED)
  {
    m_bNewValue = FALSE;
    m_bValueSet = TRUE;
  }

  if (lNotSetCheck == BST_CHECKED)
  {
    m_bValueSet = FALSE;
  }
  CDialog::OnOK();
}

HRESULT CSingleBooleanEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_BOOLEAN:
          m_bOldValue = pAttributeEditorInfo->pADsValue->Boolean;
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}


HRESULT CSingleBooleanEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  if (!m_bValueSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_BOOLEAN:
          (*ppADsValue)->Boolean = m_bNewValue;
          break;

        default:
          ASSERT(FALSE);
          delete *ppADsValue;
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleBooleanEditor

CValueEditDialog* CreateSingleTimeEditor(PCWSTR pszClass,
                                            PCWSTR pszAttribute,
                                            ADSTYPE adsType,
                                            BOOL bMultivalued)
{
  return new CSingleTimeEditor;
}

BEGIN_MESSAGE_MAP(CSingleTimeEditor, CValueEditDialog)
END_MESSAGE_MAP()

BOOL CSingleTimeEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  if (m_bValueSet)
  {
    SendDlgItemMessage(IDC_DATE_PICKER, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&m_stOldValue);
    SendDlgItemMessage(IDC_TIME_PICKER, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&m_stOldValue);
  }
  else
  {
    SendDlgItemMessage(IDC_DATE_PICKER, DTM_SETSYSTEMTIME, GDT_NONE, (LPARAM)&m_stOldValue);
    SendDlgItemMessage(IDC_TIME_PICKER, DTM_SETSYSTEMTIME, GDT_NONE, (LPARAM)&m_stOldValue);
  }


  return CDialog::OnInitDialog();
}

void CSingleTimeEditor::OnOK()
{
  SYSTEMTIME stDateResult = {0};
  SYSTEMTIME stTimeResult = {0};

  LRESULT lDateRes = SendDlgItemMessage(IDC_DATE_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stDateResult);
  LRESULT lTimeRes = SendDlgItemMessage(IDC_TIME_PICKER, DTM_SETSYSTEMTIME, 0, (LPARAM)&stTimeResult);

  if (lDateRes == GDT_VALID &&
      lTimeRes == GDT_VALID)
  {
    memcpy(&m_stNewValue, &stDateResult, sizeof(SYSTEMTIME));
    m_stNewValue.wHour = stTimeResult.wHour;
    m_stNewValue.wMinute = stTimeResult.wMinute;
    m_stNewValue.wSecond = stTimeResult.wSecond;
    m_stNewValue.wMilliseconds = stTimeResult.wMilliseconds;
  }
  CDialog::OnOK();
}

HRESULT CSingleTimeEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_UTC_TIME:
          memcpy(&m_stOldValue, &(pAttributeEditorInfo->pADsValue->UTCTime), sizeof(SYSTEMTIME));
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}


HRESULT CSingleTimeEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  *ppADsValue = new ADSVALUE;
  if (*ppADsValue != NULL)
  {
    *pdwNumValues = 1;
    (*ppADsValue)->dwType = m_pOldADsValue->dwType;
    switch (m_pOldADsValue->dwType)
    {
      case ADSTYPE_UTC_TIME:
        memcpy(&((*ppADsValue)->UTCTime), &m_stNewValue, sizeof(SYSTEMTIME));
        break;

      default:
        ASSERT(FALSE);
        delete *ppADsValue;
        *ppADsValue = NULL;
        *pdwNumValues = 0;
        hr = E_FAIL;
        break;
    }
  }
  else
  {
    *pdwNumValues = 0;
    hr = E_OUTOFMEMORY;
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// COctetStringEditor

CValueEditDialog* CreateSingleOctetStringEditor(PCWSTR pszClass,
                                                PCWSTR pszAttribute,
                                                ADSTYPE adsType,
                                                BOOL bMultivalued)
{
  return new COctetStringEditor;
}

BEGIN_MESSAGE_MAP(COctetStringEditor, CValueEditDialog)
  ON_EN_CHANGE(IDC_PROCESS_EDIT, OnProcessEdit)
  ON_BN_CLICKED(IDC_ATTR_EDIT_BUTTON, OnEditButton)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClearButton)
END_MESSAGE_MAP()

BOOL COctetStringEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  DWORD dwDisplayFlags = BYTE_ARRAY_DISPLAY_HEX   |
                         BYTE_ARRAY_DISPLAY_DEC   |
                         BYTE_ARRAY_DISPLAY_OCT   |
                         BYTE_ARRAY_DISPLAY_BIN;

  VERIFY(m_display.Initialize(IDC_VALUE_EDIT, 
                              IDC_VIEW_TYPE_COMBO,
                              dwDisplayFlags,
                              BYTE_ARRAY_DISPLAY_HEX,   // default display
                              this,
                              1024,
                              IDS_OCTET_DISPLAY_SIZE_EXCEEDED));                   // Only show 1K of data in the edit box

  m_display.SetData(m_pOldValue, m_dwOldLength);
  return CDialog::OnInitDialog();
}

void COctetStringEditor::OnOK()
{
  //
  // Retrieve the new values from the control
  //
  if (m_pNewValue)
  {
    delete[] m_pNewValue;
    m_pNewValue = 0;
    m_dwNewLength = 0;
  }
  m_dwNewLength = m_display.GetData(&m_pNewValue);

  CDialog::OnOK();
}

void COctetStringEditor::OnProcessEdit()
{
  CString szProcess;
  GetDlgItemText(IDC_PROCESS_EDIT, szProcess);
  if (szProcess.IsEmpty())
  {
    GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(FALSE);

    //
    // Set the default button to OK
    //
    SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
    SendDlgItemMessage(IDC_ATTR_EDIT_BUTTON, 
                       BM_SETSTYLE, 
                       BS_PUSHBUTTON, 
                       MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDOK,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       MAKELPARAM(TRUE, 0));
  }
  else
  {
    GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(TRUE);

    //
    // Set the default button to the Edit button
    //
    SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_EDIT_BUTTON, 0);
    SendDlgItemMessage(IDOK, 
                       BM_SETSTYLE, 
                       BS_PUSHBUTTON, 
                       MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDC_ATTR_EDIT_BUTTON,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       MAKELPARAM(TRUE, 0));
  }
}

void COctetStringEditor::OnEditButton()
{
  CString szProcess;
  GetDlgItemText(IDC_PROCESS_EDIT, szProcess);

  //
  // Create a temp file and write out the contents of the octet string
  //
  WCHAR szTempPath[MAX_PATH];
  if (!::GetTempPath(MAX_PATH, szTempPath))
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_CREATE_TEMPFILE, MB_OK);
    return;
  }
  
  CString szDataPath;
  if (!::GetTempFileName(szTempPath, _T("attredit"), 0x0, szDataPath.GetBuffer(MAX_PATH)))
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_CREATE_TEMPFILE, MB_OK);
    return;
  }
  szDataPath.ReleaseBuffer();

  //
  // Open the temp file so we can write out the data
  //
  CFile tempDataFile;
  if (!tempDataFile.Open(szDataPath, 
      CFile::modeCreate | CFile::modeReadWrite |CFile::shareExclusive | CFile::typeBinary))
  {
    //
    // Failed to open temp file, display error message
    //
    ADSIEditMessageBox(IDS_MSG_FAIL_CREATE_TEMPFILE, MB_OK);
    return;
  }

  //
  // Write the byte array to a temp file
  //
  BYTE* pData = 0;
  DWORD dwDataLength = m_display.GetData(&pData);
  if (dwDataLength != 0 && pData)
  {
    tempDataFile.Write(pData, dwDataLength);
  }
  tempDataFile.Close();

  if (pData)
  {
    delete[] pData;
    pData = 0;
  }
  dwDataLength = 0;

  //
  // Construct the command line from the executable and the temp file
  //
  CString szCommandLine = szProcess + L" " + szDataPath;

  //
  // Launch the process with the temp file as an argument
  //
	STARTUPINFO				si;
	PROCESS_INFORMATION		pi;

  ::ZeroMemory(&pi,sizeof(PROCESS_INFORMATION));
  ::ZeroMemory(&si,sizeof(STARTUPINFO));
	si.cb			= sizeof (STARTUPINFO);

  if(CreateProcess(	NULL,					
						        (LPWSTR)(LPCWSTR)szCommandLine,			
						        NULL,					
						        NULL,					
						        FALSE,				
						        0,					
						        NULL,				
						        NULL,				
						        &si,                
						        &pi) )             
	{
		// wait to finish the runing setup process
		WaitForSingleObject(pi.hProcess,INFINITE);
	
		// close process handle
		if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hProcess) ;
		}
		if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE)
		{
			CloseHandle (pi.hThread) ;
		}
  }
  else
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_LAUNCH_PROCESS, MB_OK);
    return;
  }

  //
  // Load the data from the saved temp file
  //
  if (!LoadFileAsByteArray(szDataPath, &pData, &dwDataLength))
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_RETRIEVE_SAVED_DATA, MB_OK);
    return;
  }

  //
  // Delete temp file after picture is displayed
  //
  CFile::Remove(szDataPath);

  //
  // Update the UI with the new data
  //
  m_display.SetData(pData, dwDataLength);
}


void COctetStringEditor::OnClearButton()
{
  m_display.ClearData();
}

HRESULT COctetStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_OCTET_STRING:
          m_dwOldLength = pAttributeEditorInfo->pADsValue->OctetString.dwLength;
          m_pOldValue = new BYTE[m_dwOldLength];
          if (m_pOldValue)
          { 
            memcpy(m_pOldValue, pAttributeEditorInfo->pADsValue->OctetString.lpValue, m_dwOldLength);
          }
          else
          {
            hr = E_OUTOFMEMORY;
          }

          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}


HRESULT COctetStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  if (m_dwNewLength > 0 && m_pNewValue)
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_OCTET_STRING:
          (*ppADsValue)->OctetString.dwLength = m_dwNewLength;
          (*ppADsValue)->OctetString.lpValue = new BYTE[m_dwNewLength];
          if ((*ppADsValue)->OctetString.lpValue)
          {
            memcpy((*ppADsValue)->OctetString.lpValue, m_pNewValue, m_dwNewLength);
          }
          else
          {
            hr = E_OUTOFMEMORY;
          }
          break;

        default:
          ASSERT(FALSE);
          delete *ppADsValue;
          *ppADsValue = 0;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    *ppADsValue = 0;
    *pdwNumValues = 0;
  }
  return hr;
}

CValueEditDialog* CreateMultiOctetStringEditor(PCWSTR pszClass,
                                               PCWSTR pszAttribute,
                                               ADSTYPE adsType,
                                               BOOL bMultivalued)
{
  return new CMultiOctetStringEditor;
}


BEGIN_MESSAGE_MAP(CMultiOctetStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_BN_CLICKED(IDC_EDIT_BUTTON, OnEditButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
END_MESSAGE_MAP()

BOOL CMultiOctetStringEditor::OnInitDialog()
{
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Fill the list box with the current values
  //
  POSITION pos = m_OldValueList.GetHeadPosition();
  while (pos)
  {
    PADSVALUE pADsValue = m_OldValueList.GetNext(pos);
    if (pADsValue)
    {
      CString szValue;
      GetStringFromADsValue(pADsValue, szValue, MAX_OCTET_STRING_VALUE_LENGTH);
      LRESULT lIdx = SendDlgItemMessage(IDC_VALUE_LIST, 
                                        LB_ADDSTRING, 
                                        0, 
                                        (LPARAM)(LPCWSTR)szValue);
      if (lIdx != LB_ERR ||
          lIdx != LB_ERRSPACE)
      {
        LRESULT lSetData = SendDlgItemMessage(IDC_VALUE_LIST, 
                                              LB_SETITEMDATA, 
                                              (WPARAM)lIdx, 
                                              (LPARAM)pADsValue);
        if (lSetData == LB_ERR)
        {
          ASSERT(lSetData != LB_ERR);
          continue;
        }
      }
    }
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
  SendDlgItemMessage(IDC_VALUE_LIST, LB_SETCURSEL, 0, 0);

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiOctetStringEditor::OnOK()
{
  //
  // Get the values out of the list box
  //
  m_NewValueList.RemoveAll();

  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
    int iCount = pListBox->GetCount();
    for (int idx = 0; idx < iCount; idx++)
    {
      CString szNewValue;
      LRESULT lData = SendDlgItemMessage(IDC_VALUE_LIST, 
                                         LB_GETITEMDATA, 
                                         (WPARAM)idx, 
                                         0);
      if (lData == LB_ERR)
      {
        ASSERT(lData != LB_ERR);
        continue;
      }

      m_NewValueList.AddTail(reinterpret_cast<PADSVALUE>(lData));
    }
  }
  CDialog::OnOK();
}

void CMultiOctetStringEditor::OnEditButton()
{
  LRESULT lIdx = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
  if (lIdx == LB_ERR)
  {
    ASSERT(lIdx != LB_ERR);
    return;
  }

  LRESULT lData = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETITEMDATA, (WPARAM)lIdx, 0);
  if (lData == LB_ERR)
  {
    ASSERT(lIdx != LB_ERR);
    return;
  }

  PADSVALUE pADsValue = reinterpret_cast<PADSVALUE>(lData);
  if (!pADsValue)
  {
    ASSERT(pADsValue);
    return;
  }

  DS_ATTRIBUTE_EDITORINFO attrEditInfo;
  ::ZeroMemory(&attrEditInfo, sizeof(DS_ATTRIBUTE_EDITORINFO));

  attrEditInfo.pADsValue = pADsValue;
  attrEditInfo.dwNumValues = 1;
  attrEditInfo.lpszClass = (PWSTR)(PCWSTR)m_szClass;
  attrEditInfo.lpszAttribute = (PWSTR)(PCWSTR)m_szAttribute;
  attrEditInfo.bMultivalued = FALSE;
  attrEditInfo.lpfnBind = m_pfnBindingFunction;
  attrEditInfo.lParam = m_lParam;

  COctetStringEditor dlg;
  HRESULT hr = dlg.Initialize(&attrEditInfo);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr, IDS_FAILED_INITIALIZE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
    return;
  }

  if (dlg.DoModal() == IDOK)
  {
    PADSVALUE pNewADsValue = 0;
    DWORD dwNumNewValues = 0;
    hr = dlg.GetNewValue(&pNewADsValue, &dwNumNewValues);
    if (FAILED(hr))
    {
      ADSIEditErrorMessage(hr, IDS_FAILED_GET_NEW_VALUE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
      return;
    }
    
    ASSERT(pNewADsValue);
    ASSERT(dwNumNewValues == 1);

    CString szNewValue;
    GetStringFromADsValue(pNewADsValue, szNewValue, MAX_OCTET_STRING_VALUE_LENGTH);
    ASSERT(!szNewValue.IsEmpty());

    LRESULT lNewIdx = SendDlgItemMessage(IDC_VALUE_LIST,
                                         LB_INSERTSTRING,
                                         lIdx + 1,
                                         (LPARAM)(PCWSTR)szNewValue);
    if (lNewIdx != LB_ERR)
    {
      //
      // Update the new item and delete the old
      //
      SendDlgItemMessage(IDC_VALUE_LIST, LB_SETITEMDATA, (WPARAM)lNewIdx, (LPARAM)pNewADsValue);
      SendDlgItemMessage(IDC_VALUE_LIST, LB_DELETESTRING, (WPARAM)lIdx, 0);
    }
    else
    {
      //
      // Since we had trouble adding the new item just update the old one.  The string
      // will be incorrect but the value will be fine.
      //
      SendDlgItemMessage(IDC_VALUE_LIST, LB_SETITEMDATA, (WPARAM)lIdx, (LPARAM)pNewADsValue);
    }
  }
}

void CMultiOctetStringEditor::OnRemoveButton()
{
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
    int iCurSel = pListBox->GetCurSel();
    if (iCurSel != LB_ERR)
    {
      //
      // Delete the item from the list box
      //
      pListBox->DeleteString(iCurSel);
    }
  }

  //
  // Manage Button States
  //
  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();
}

void CMultiOctetStringEditor::OnAddButton()
{
  DS_ATTRIBUTE_EDITORINFO attrEditInfo;
  ZeroMemory(&attrEditInfo, sizeof(DS_ATTRIBUTE_EDITORINFO));

  attrEditInfo.pADsValue = new ADSVALUE;
  if (attrEditInfo.pADsValue)
  {
    ::ZeroMemory(attrEditInfo.pADsValue, sizeof(ADSVALUE));
  }
  attrEditInfo.pADsValue->dwType = ADSTYPE_OCTET_STRING;
  attrEditInfo.dwNumValues = 0;
  attrEditInfo.lpszClass = (PWSTR)(PCWSTR)m_szClass;
  attrEditInfo.lpszAttribute = (PWSTR)(PCWSTR)m_szAttribute;
  attrEditInfo.bMultivalued = FALSE;
  attrEditInfo.lpfnBind = m_pfnBindingFunction;
  attrEditInfo.lParam = m_lParam;

  COctetStringEditor dlg;
  HRESULT hr = dlg.Initialize(&attrEditInfo);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr, IDS_FAILED_INITIALIZE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
    return;
  }

  if (dlg.DoModal() == IDOK)
  {
    PADSVALUE pNewADsValue = 0;
    DWORD dwNumNewValues = 0;
    hr = dlg.GetNewValue(&pNewADsValue, &dwNumNewValues);
    if (FAILED(hr))
    {
      ADSIEditErrorMessage(hr, IDS_FAILED_GET_NEW_VALUE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
      return;
    }
    
    ASSERT(pNewADsValue);
    ASSERT(dwNumNewValues == 1);

    CString szNewValue;
    GetStringFromADsValue(pNewADsValue, 
                          szNewValue, 
                          MAX_OCTET_STRING_VALUE_LENGTH);

    if (!szNewValue.IsEmpty())
    {
      LRESULT lNewIdx = SendDlgItemMessage(IDC_VALUE_LIST, 
                                           LB_ADDSTRING, 
                                           0, 
                                           (WPARAM)(PCWSTR)szNewValue);
      if (lNewIdx != LB_ERR)
      {
        SendDlgItemMessage(IDC_VALUE_LIST, LB_SETITEMDATA, (WPARAM)lNewIdx, (LPARAM)pNewADsValue);
      }
    }
  }

}

void CMultiOctetStringEditor::ManageButtonStates()
{
  LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
  if (lSelection != LB_ERR)
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
    GetDlgItem(IDC_EDIT_BUTTON)->EnableWindow(TRUE);
  }
  else
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_EDIT_BUTTON)->EnableWindow(FALSE);
  }
}

void CMultiOctetStringEditor::OnListSelChange()
{
  ManageButtonStates();
}

void CMultiOctetStringEditor::UpdateListboxHorizontalExtent()
{
  //
  // Note if the size passed to SetHorizontalExtent is less than the width of the control
  // then the scroll bar will be removed
  //
	int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
	  CClientDC dc(pListBox);
	  int nItems = pListBox->GetCount();
	  for	(int i=0; i < nItems; i++)
	  {
		  TEXTMETRIC tm;
		  VERIFY(dc.GetTextMetrics(&tm));
		  CString szBuffer;
		  pListBox->GetText(i, szBuffer);
		  CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
		  nHorzExtent = max(ext.cx ,nHorzExtent); 
	  }
	  pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiOctetStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_OCTET_STRING:
            m_OldValueList.AddTail(&(pAttributeEditorInfo->pADsValue[idx]));
            break;

          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}

HRESULT CMultiOctetStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (!ppADsValue ||
      !pdwNumValues)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_NewValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = 0;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_NewValueList.GetHeadPosition();
      while (pos)
      {
        PADSVALUE pADsValue = m_NewValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_OCTET_STRING:
            (*ppADsValue)[idx].OctetString.dwLength = pADsValue->OctetString.dwLength;
            (*ppADsValue)[idx].OctetString.lpValue = new BYTE[pADsValue->OctetString.dwLength];
            if ((*ppADsValue)[idx].OctetString.lpValue)
            {
              memcpy((*ppADsValue)[idx].OctetString.lpValue, 
                     pADsValue->OctetString.lpValue,
                     pADsValue->OctetString.dwLength);
            }
            else
            {
              for (int i = 0; i < idx; i++)
              {
                if ((*ppADsValue)[i].OctetString.lpValue)
                {
                  delete[] (*ppADsValue)[i].OctetString.lpValue;
                  (*ppADsValue)[i].OctetString.lpValue = 0;
                }
              }
              delete[] *ppADsValue;
              *ppADsValue = 0;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }

            break;

          default:
            ASSERT(FALSE);
            for (int i = 0; i < idx; i++)
            {
              if ((*ppADsValue)[i].OctetString.lpValue)
              {
                delete[] (*ppADsValue)[i].OctetString.lpValue;
                (*ppADsValue)[i].OctetString.lpValue = 0;
              }
            }
            delete[] *ppADsValue;
            *ppADsValue = 0;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        if (FAILED(hr))
        {
          return hr;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CAttributeEditorPropertyPage

BEGIN_MESSAGE_MAP(CAttributeEditorPropertyPage, CPropertyPage)
  ON_BN_CLICKED(IDC_MANDATORY_CHECK, OnMandatoryCheck)
  ON_BN_CLICKED(IDC_OPTIONAL_CHECK,  OnOptionalCheck)
  ON_BN_CLICKED(IDC_SET_CHECK,       OnValueSetCheck)
  ON_BN_CLICKED(IDC_ATTR_EDIT_BUTTON,OnEditAttribute)
  ON_NOTIFY(LVN_ITEMACTIVATE, IDC_ATTRIBUTE_LIST, OnNotifyEditAttribute)
  ON_NOTIFY(LVN_ITEMCHANGED, IDC_ATTRIBUTE_LIST, OnListItemChanged)
  ON_NOTIFY(LVN_COLUMNCLICK, IDC_ATTRIBUTE_LIST, OnSortList)
END_MESSAGE_MAP()

CAttributeEditorPropertyPage::CAttributeEditorPropertyPage(IADs* pIADs, 
                                                           IADsClass* pIADsClass,
                                                           LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
                                                           CADSIEditPropertyPageHolder* pHolder)
  : CPropertyPage(IDD_ATTRIBUTE_EDITOR_DIALOG)
{
  m_spIADs      = pIADs;
  m_spIADsClass = pIADsClass;

  m_bMandatory  = TRUE;
  m_bOptional   = TRUE;
  m_bSet        = FALSE;

  m_nSortColumn = 0;

  ASSERT(pBindingInfo != NULL);
  ASSERT(pBindingInfo->dwSize == sizeof(DS_ATTREDITOR_BINDINGINFO));
  ASSERT(pBindingInfo->lpfnBind != NULL);
  ASSERT(pBindingInfo->lpszProviderServer != NULL);

  m_szPrefix = pBindingInfo->lpszProviderServer;
  m_pfnBind  = pBindingInfo->lpfnBind;
  m_BindLPARAM = pBindingInfo->lParam;
  m_dwBindFlags = pBindingInfo->dwFlags;

  m_pHolder = pHolder;
  ASSERT(m_pHolder);
}

CAttributeEditorPropertyPage::~CAttributeEditorPropertyPage()
{

}

BOOL CAttributeEditorPropertyPage::OnInitDialog()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CWaitCursor cursor;

  // Set the hwnd in the property page holder so that we can
  // be activated when necessary

  m_pHolder->SetSheetWindow(GetParent()->GetSafeHwnd());


  ((CButton*)GetDlgItem(IDC_MANDATORY_CHECK))->SetCheck(TRUE);
  ((CButton*)GetDlgItem(IDC_OPTIONAL_CHECK))->SetCheck(TRUE);
  ((CButton*)GetDlgItem(IDC_SET_CHECK))->SetCheck(FALSE);

  GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(FALSE);

  HRESULT hr = GetSchemaNamingContext();
  ShowListCtrl();

  hr = RetrieveAttributes();
  if (FAILED(hr))
  {
    TRACE(_T("OnInitDialog() : error returned from RetrieveAttributes() = 0x%x\n"), hr);
  }

  CComBSTR bstr;
  hr = m_spIADs->get_Class(&bstr);
  if (FAILED(hr))
  {
    TRACE(_T("OnInitDialog() : error returned from m_pIADs->get_Class() = 0x%x\n"), hr);
  }
  else
  {
    m_szClass = bstr;
  }

  FillListControl();
  return FALSE;
}

HRESULT CAttributeEditorPropertyPage::GetSchemaNamingContext()
{
  HRESULT hr = S_OK;
  CComPtr<IADs> spIADs;

  CString m_szPath = m_szPrefix + _T("RootDSE");
  hr = m_pfnBind(m_szPath, 
                 ADS_SECURE_AUTHENTICATION,
                 IID_IADs,
                 (PVOID*)&spIADs,
                 m_BindLPARAM);
  if (SUCCEEDED(hr))
  {
    CComVariant var;
    hr = spIADs->Get(L"schemaNamingContext", &var);
    if (SUCCEEDED(hr))
    {
      m_szSchemaNamingContext = var.bstrVal;
    }
  }
  m_szSchemaNamingContext = m_szPrefix + m_szSchemaNamingContext;
  return hr;
}

BOOL CAttributeEditorPropertyPage::OnApply()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_AttrList.HasDirty())
	{
		CComPtr<IDirectoryObject> spDirObject;

		// bind to object with authentication
		//
		HRESULT hr = S_OK;
		hr = m_spIADs->QueryInterface(IID_IDirectoryObject, (PVOID*) &spDirObject);

		if (FAILED(hr))
		{
			AfxMessageBox(L"Failed to QI the IDirectoryObject from the IADs.");
      return FALSE;
		}

		// Change or add values to ADSI cache that have changed
		//
		hr = CADSIAttribute::SetValuesInDS(&m_AttrList, spDirObject);

		if (FAILED(hr))
		{
  		ADSIEditErrorMessage(hr);

      //
      // Instead of removing all the attributes we need to query for the ones that failed
      // or something to that effect.
      //
//			m_AttrList.RemoveAllAttr();
      return FALSE;
		}
	}
  return TRUE;
}

void CAttributeEditorPropertyPage::OnMandatoryCheck()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnMandatoryCheck()\n"));
  m_bMandatory = ((CButton*)GetDlgItem(IDC_MANDATORY_CHECK))->GetCheck();

  FillListControl();
}

void CAttributeEditorPropertyPage::OnOptionalCheck()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnOptionalCheck()\n"));
  m_bOptional = ((CButton*)GetDlgItem(IDC_OPTIONAL_CHECK))->GetCheck();

  FillListControl();
}

void CAttributeEditorPropertyPage::OnValueSetCheck()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnValueSetCheck()\n"));
  m_bSet = ((CButton*)GetDlgItem(IDC_SET_CHECK))->GetCheck();

  FillListControl();
}

//
// Callback function used by CListCtrl::SortItems the items by the column that was clicked
//
static int CALLBACK CompareAttrColumns(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
  CAttributeEditorPropertyPage* pProppage = reinterpret_cast<CAttributeEditorPropertyPage*>(lParamSort);
  if (!pProppage)
  {
    ASSERT(pProppage);
    return 0;
  }

  UINT nColumn = pProppage->GetSortColumn();
  CListCtrl* pListCtrl = (CListCtrl*)pProppage->GetDlgItem(IDC_ATTRIBUTE_LIST);
  if (!pListCtrl)
  {
    ASSERT(pListCtrl);
    return 0;
  }

  //
  // Since lParam1 and lParam2 are pointers to the data we have to search for each item
  // in the list and remember their index
  //
  int iItem1 = -1;
  int iItem2 = -1;

  LVFINDINFO findInfo;
  ZeroMemory(&findInfo, sizeof(LVFINDINFO));
  findInfo.flags = LVFI_PARAM;
  findInfo.lParam = lParam1;
  iItem1 = pListCtrl->FindItem(&findInfo);

  findInfo.lParam = lParam2;
  iItem2 = pListCtrl->FindItem(&findInfo);

  //
  // Put any items with values above those that don't have values
  //
  int iRetVal = 0;
  if (iItem1 != -1 &&
      iItem2 == -1)
  {
    iRetVal = -1;
  }
  else if (iItem1 == -1 &&
           iItem2 != -1)
  {
    iRetVal = 1;
  }
  else if (iItem1 == -1 &&
           iItem2 == -1)
  {
    iRetVal = 0;
  }
  else
  {
    CString szItem1 = pListCtrl->GetItemText(iItem1, nColumn);
    CString szItem2 = pListCtrl->GetItemText(iItem2, nColumn);

    //
    // Have to put this in so that empty strings end up at the bottom
    //
    if (szItem1.IsEmpty() && !szItem2.IsEmpty())
    {
      iRetVal = 1;
    }
    else if (!szItem1.IsEmpty() && szItem2.IsEmpty())
    {
      iRetVal = -1;
    }
    else
    {
      iRetVal = _wcsicmp(szItem1, szItem2);
    }
  }
  return iRetVal;
}

void CAttributeEditorPropertyPage::OnSortList(NMHDR* pNotifyStruct, LRESULT* result)
{
  if (!result ||
      !pNotifyStruct)
  {
    return;
  }

  *result = 0;

  //
  // Get the list view notify struct
  //
  LPNMLISTVIEW pnmv = (LPNMLISTVIEW)pNotifyStruct;
  if (!pnmv)
  {
    return;
  }

  //
  // Right now I only have 3 columns
  //
  if (pnmv->iSubItem < 0 ||
      pnmv->iSubItem >= 3)
  {
    return;
  }

  //
  // Store the sort column
  //
  m_nSortColumn = pnmv->iSubItem;

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl);
  pAttrListCtrl->SortItems(CompareAttrColumns, reinterpret_cast<LPARAM>(this));
}
  
void CAttributeEditorPropertyPage::OnListItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* result)
{
  if (!result)
  {
    return;
  }
  *result = 0;
  SetEditButton();
}

void CAttributeEditorPropertyPage::SetEditButton()
{
  //
  // Enable the edit button if something is selected in the ListCtrl
  //
  BOOL bEnableEdit = FALSE;
  if (!(m_dwBindFlags & DSATTR_EDITOR_ROOTDSE))
  {
    CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
    ASSERT(pAttrListCtrl != NULL);
	  int nSelectedItem = pAttrListCtrl->GetNextItem(-1, LVIS_SELECTED);

    if (nSelectedItem != -1)
    {
      bEnableEdit = TRUE;
    }
  }
  GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(bEnableEdit);
}

void CAttributeEditorPropertyPage::OnNotifyEditAttribute(NMHDR* pNotifyStruct, LRESULT* result)
{
  if (result == NULL ||
      pNotifyStruct == NULL)
  {
    return;
  }

  //
  // Don't allow editing on the RootDSE
  //
  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
    *result = 0;
    return;
  }

  LPNMITEMACTIVATE pnmia = (LPNMITEMACTIVATE)pNotifyStruct;
  ASSERT(pnmia != NULL);
  if (pnmia != NULL)
  {
    int iSelectedItem = pnmia->iItem;
    if (iSelectedItem != -1)
    {
      CADSIAttribute* pSelectedAttr = GetAttributeFromList(iSelectedItem);
      if (pSelectedAttr != NULL)
      {
        EditAttribute(pSelectedAttr);
      }
      else
      {
        //
        // REVIEW_JEFFJON : display an appropriate error message
        //
      }
    }
  }
  *result = 0;
}

void CAttributeEditorPropertyPage::OnEditAttribute()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnEditAttribute()\n"));

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);
	int nSelectedItem = pAttrListCtrl->GetNextItem(-1, LVIS_SELECTED);

  if (nSelectedItem == -1)
  {
    return;
  }

  CADSIAttribute* pSelectedAttr = GetAttributeFromList(nSelectedItem);
  ASSERT(pSelectedAttr != NULL);

  EditAttribute(pSelectedAttr);
}

void CAttributeEditorPropertyPage::EditAttribute(CADSIAttribute* pSelectedAttr)
{
  HRESULT hr = S_OK;

  //
  // Retrieve all necessary info for initializing the appropriate editor
  //
  LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo = NULL;
  BOOL bOwnValueMemory = FALSE;
  GetAttributeInfo(pSelectedAttr, &pAttributeEditorInfo, &bOwnValueMemory);
  if (pAttributeEditorInfo == NULL)
  {
    ADSIEditMessageBox(IDS_NO_ATTRIBUTE_INFO, MB_OK);
    return;
  }
  
  //
  // Obtain the editor from the attribute and syntax map
  //
  CValueEditDialog* pEditorDialog = RetrieveEditor(pAttributeEditorInfo);
  if (pEditorDialog)
  {
    hr = pEditorDialog->Initialize(pAttributeEditorInfo);
    if (SUCCEEDED(hr))
    {
      if (pEditorDialog->DoModal() == IDOK)
      {
        PADSVALUE pNewValue = 0;
        DWORD dwNumValues   = 0;
        hr = pEditorDialog->GetNewValue(&pNewValue, &dwNumValues);
        if (SUCCEEDED(hr))
        {
          //
          // Do what ever needs done with the new value
          //
          hr = pSelectedAttr->SetValues(pNewValue, dwNumValues);
          //
          // REVIEW_JEFFJON : what should be done here if that failed?
          //
          pSelectedAttr->SetDirty(TRUE);

          CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
          ASSERT(pAttrListCtrl != NULL);
	        int nSelectedItem = pAttrListCtrl->GetNextItem(-1, LVIS_SELECTED);

          if (nSelectedItem != -1)
          {
            if (dwNumValues > 0)
            {
              //
              // Get the new values (limit each individual value to MAX_OCTET_STRING_VALUE_LENGTH characters)
              //
              CStringList szValuesList;
              pSelectedAttr->GetValues(szValuesList, MAX_OCTET_STRING_VALUE_LENGTH);
            
              CString szCombinedString;
              POSITION pos = szValuesList.GetHeadPosition();
              while (pos != NULL)
              {
                CString szTemp = szValuesList.GetNext(pos);
                szCombinedString += szTemp;
                if (pos != NULL)
                {
                  szCombinedString += L";";
                }
              }

              VERIFY(-1 != pAttrListCtrl->SetItemText(nSelectedItem, 2, szCombinedString));
            }
            else
            {
              CString szNotSet;
              VERIFY(szNotSet.LoadString(IDS_ATTR_NOTSET));

              VERIFY(-1 != pAttrListCtrl->SetItemText(nSelectedItem, 2, szNotSet));
            }
          }
          SetModified();
        }
        else
        {
          //
          // REVIEW_JEFFJON : handle the GetNewValue() failure
          //
          ASSERT(FALSE);
  		    ADSIEditErrorMessage(hr);
        }
      }
    }
    else
    {
      //
      // REVIEW_JEFFJON : Handle the error Initialize
      //
      ASSERT(FALSE);
  		ADSIEditErrorMessage(hr);
    }
    if (pEditorDialog)
    {
      delete pEditorDialog;
      pEditorDialog = 0;
    }
  }
  else
  {
    //
    // Unable to retrieve an appropriate editor for this attribute
    //
    ADSIEditMessageBox(IDS_NO_EDITOR, MB_OK);
  }

  if (pAttributeEditorInfo)
  {
    if (pAttributeEditorInfo->lpszAttribute)
    {
      delete[] pAttributeEditorInfo->lpszAttribute;
    }

    if (pAttributeEditorInfo->lpszClass)
    {
      delete[] pAttributeEditorInfo->lpszClass;
    }

    if (pAttributeEditorInfo->pADsValue && bOwnValueMemory)
    {
       delete pAttributeEditorInfo->pADsValue;
       pAttributeEditorInfo->pADsValue = 0;
    }

    delete pAttributeEditorInfo;
    pAttributeEditorInfo = 0;
  }
}

CADSIAttribute* CAttributeEditorPropertyPage::GetAttributeFromList(int iSelectedItem)
{
  if (iSelectedItem == -1)
  {
    return NULL;
  }

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);
  return (CADSIAttribute*)pAttrListCtrl->GetItemData(iSelectedItem);
}

void CAttributeEditorPropertyPage::GetAttributeInfo(CADSIAttribute* pAttr, 
                                                    LPDS_ATTRIBUTE_EDITORINFO* ppAttributeEditorInfo,
                                                    BOOL* pbOwnValueMemory)
{
  //
  // Get the attribute to be edited
  //
  CString szAttribute = _T("");
  pAttr->GetProperty(szAttribute);

  //
  // Get the type and whether it is multi-valued or not by the syntax
  // of the attribute
  //
  CString szSyntax;
  BOOL bMultiValued = FALSE;
  ADSTYPE adsType = RetrieveADsTypeFromSyntax(szAttribute, &bMultiValued, szSyntax);

  *pbOwnValueMemory = FALSE;
  DWORD dwNumValues = 0;
  PADSVALUE pADsValue = pAttr->GetADsValues();
  if (!pADsValue)
  {
    //
    // Value for attribute was not set so we have to 
    // create an empty ADSVALUE to pass the type
    //
    pADsValue = new ADSVALUE;
    ASSERT(pADsValue != NULL);
    pADsValue->dwType = adsType;
    dwNumValues = 0;
    *pbOwnValueMemory = TRUE;
  }
  else
  {
    //
    // Get the number of values in the attribute
    //
    dwNumValues = pAttr->GetNumValues();
  }

  //
  // Figure out how much space we need
  //
  DWORD dwStructSize = sizeof(DS_ATTRIBUTE_EDITORINFO);
  DWORD dwClassSize  = m_szClass.GetLength() + 1;
  DWORD dwAttrSize   = szAttribute.GetLength() + 1;

  try
  {
     *ppAttributeEditorInfo = new DS_ATTRIBUTE_EDITORINFO;
     ASSERT(*ppAttributeEditorInfo != NULL);
     if (*ppAttributeEditorInfo != NULL)
     {
        (*ppAttributeEditorInfo)->lpszClass = new WCHAR[dwClassSize];
        if (m_szClass != _T(""))
        {
          wcscpy((*ppAttributeEditorInfo)->lpszClass, m_szClass);
        }

        (*ppAttributeEditorInfo)->lpszAttribute = new WCHAR[dwAttrSize]; 
        if (szAttribute != _T(""))
        {
          wcscpy((*ppAttributeEditorInfo)->lpszAttribute, szAttribute);
        }

        (*ppAttributeEditorInfo)->adsType      = adsType;
        (*ppAttributeEditorInfo)->bMultivalued = bMultiValued;
        (*ppAttributeEditorInfo)->dwNumValues  = dwNumValues;
        (*ppAttributeEditorInfo)->pADsValue    = pADsValue;
        (*ppAttributeEditorInfo)->dwSize       = sizeof(DS_ATTRIBUTE_EDITORINFO);
     }
     else
     {
         delete pADsValue;
         pADsValue = 0;
     }
  }
  catch (...)
  {
     if (pADsValue)
     {
        delete pADsValue;
        pADsValue = 0;
     }
  }
}

void CAttributeEditorPropertyPage::ShowListCtrl()
{
  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);

  // Set full row select

  ListView_SetExtendedListViewStyle(
     pAttrListCtrl->GetSafeHwnd(), 
     LVS_EX_FULLROWSELECT);

  //
  // Insert the Attribute column
  //
  CString szAttribute;
  VERIFY(szAttribute.LoadString(IDS_ATTR_COL_ATTRIBUTE));
  int iRet = pAttrListCtrl->InsertColumn(0, szAttribute, LVCFMT_LEFT, 120);
  if (iRet == -1)
  {
    TRACE(_T("Failed to insert the \"Attribute\" column.\n"));
  }

  //
  // Insert the Syntax column
  // This column will be hidden by default
  //
  CString szSyntax;
  VERIFY(szSyntax.LoadString(IDS_ATTR_COL_SYNTAX));
  iRet = pAttrListCtrl->InsertColumn(1, szSyntax, LVCFMT_LEFT, 90);
  if (iRet == -1)
  {
    TRACE(_T("Failed to insert the \"Syntax\" column.\n"));
  }

  //
  // Insert the Value column
  //
  CString szValue;
  VERIFY(szValue.LoadString(IDS_ATTR_COL_VALUE));
  iRet = pAttrListCtrl->InsertColumn(2, szValue, LVCFMT_LEFT, 400);
  if (iRet == -1)
  {
    TRACE(_T("Failed to insert the \"Value\" column.\n"));
  }

}

void CAttributeEditorPropertyPage::FillListControl()
{
  TRACE(_T("FillListControl()\n"));

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_ATTR_NOTSET));

  //
  // Clear the list control
  //
  pAttrListCtrl->DeleteAllItems();

  //
  // Add the attributes and their values into the list control
  //
  UINT nState = 0;
  int nIndex = 0;

  POSITION pos = m_AttrList.GetHeadPosition();
  while (pos != NULL)
  {
    CADSIAttribute* pAttr = m_AttrList.GetNext(pos);
    ASSERT(pAttr != NULL);

    CString szProperty;
    pAttr->GetProperty(szProperty);

    //
    // Don't add the nTSecurityDescriptor, we use the ACL UI instead
    //
    if (szProperty.CompareNoCase(L"nTSecurityDescriptor") == 0)
    {
      continue;
    }

    if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
    {
	    int iNewIndex = pAttrListCtrl->InsertItem(LVIF_TEXT | LVIF_PARAM, nIndex, 
			    szProperty, nState, 0, 0, (LPARAM)pAttr); 
      if (iNewIndex != -1)
      {
        CString szValue;
        szValue = m_RootDSEValueList.GetAt(m_RootDSEValueList.FindIndex(nIndex));
        if (!szValue.IsEmpty())
        {
          VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szValue));
        }
        else
        {
          VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szNotSet));
        }
      }
      nIndex++;
    }
    else // not RootDSE
    {
      if ((m_bMandatory && pAttr->IsMandatory()) || (m_bOptional && !pAttr->IsMandatory()))
      {
        if (!m_bSet || (m_bSet && pAttr->IsValueSet()))
        {
	        int iNewIndex = pAttrListCtrl->InsertItem(LVIF_TEXT | LVIF_PARAM, nIndex, 
			        szProperty, nState, 0, 0, (LPARAM)pAttr); 
          if (iNewIndex != -1)
          {
            // Insert the syntax
            
            VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 1, pAttr->GetSyntax()));

            // Insert the value

            if (pAttr->IsValueSet())
            {
              //
              // Retrieve the values
              //
              CStringList szValuesList;
              pAttr->GetValues(szValuesList);
            
              CString szCombinedString;
              POSITION posList = szValuesList.GetHeadPosition();
              while (posList)
              {
                CString szTemp = szValuesList.GetNext(posList);
                szCombinedString += szTemp;
                if (posList)
                {
                  szCombinedString += L";";
                }
              }

              VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szCombinedString));
            }
            else
            {
              VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szNotSet));
            }
          }
          nIndex++;
        }
      }
    }
  }  
  TRACE(_T("Added %u properties\n"), nIndex);

  //
  // Select the first attribute in the list
  //
  pAttrListCtrl->SetItemState(0, 1, LVIS_SELECTED);
  SetEditButton();
}


HRESULT CAttributeEditorPropertyPage::RetrieveAttributes()
{
  TRACE(_T("RetrieveAttributes()\n"));
  HRESULT hr = S_OK;

  CWaitCursor cursor;

  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
    CStringList sMandList;

    m_spIADs->GetInfo();

    CComPtr<IADsPropertyList> spPropList;
    hr = m_spIADs->QueryInterface(IID_IADsPropertyList, (PVOID*)&spPropList);
    if (SUCCEEDED(hr))
    {
      LONG lCount = 0;
      hr = spPropList->get_PropertyCount(&lCount);
      if (SUCCEEDED(hr) && lCount > 0)
      {
        CComVariant var;
        while (hr == S_OK)
        {
          hr = spPropList->Next(&var);
          if (hr == S_OK)
          {
            ASSERT(var.vt == VT_DISPATCH);
            CComPtr<IADsPropertyEntry> spEntry;
            
            hr = V_DISPATCH(&var)->QueryInterface(IID_IADsPropertyEntry,
                                                 (PVOID*)&spEntry);
            if (SUCCEEDED(hr))
            {
              CComBSTR bstrName;
              hr = spEntry->get_Name(&bstrName);
              if (SUCCEEDED(hr))
              {
                sMandList.AddTail(bstrName);
              }
            }
          }
        }
      }
    }
        
    hr = CreateAttributeList(sMandList, TRUE);
  }
  else
  {
    //
    // Retrieve mandatory properties
    //
    CStringList sMandList;

	  VARIANT varMand;
	  VariantInit(&varMand);

    hr = m_spIADsClass->get_MandatoryProperties(&varMand);
    if (SUCCEEDED(hr))
    {
	    VariantToStringList( varMand, sMandList );
    }
	  VariantClear(&varMand);	

    //
    // Retrieve optional properties
    //
    CStringList sOptionalList;

    VARIANT varOpt;
    VariantInit(&varOpt);
    hr = m_spIADsClass->get_OptionalProperties(&varOpt);
    if (SUCCEEDED(hr))
    {
	    VariantToStringList( varOpt, sOptionalList );
    }
	  VariantClear(&varOpt);	

    hr = CreateAttributeList(sMandList, TRUE);
    if (FAILED(hr))
    {
      return hr;
    }

    hr = CreateAttributeList(sOptionalList, FALSE);
    if (FAILED(hr))
    {
      return hr;
    }
  }
  return hr;
}

HRESULT CAttributeEditorPropertyPage::CreateAttributeList(CStringList& sAttrList, BOOL bMandatory)
{
  HRESULT hr = S_OK;
  LPWSTR* lpszAttrArray;
  UINT nCount = 0;
  GetStringArrayFromStringList(sAttrList, &lpszAttrArray, &nCount);
  TRACE(_T("There are %u properties to add\n"), nCount);

  for (UINT idx = 0; idx < nCount; idx++)
  {
    CADSIAttribute* pNewAttr = new CADSIAttribute(lpszAttrArray[idx]);
    ASSERT(pNewAttr != NULL);

    pNewAttr->SetMandatory(bMandatory);

    // Get the syntax

    BOOL bMultivalued = FALSE;
    CString szSyntax;
    ADSTYPE adstype = RetrieveADsTypeFromSyntax(lpszAttrArray[idx], &bMultivalued, szSyntax);
    pNewAttr->SetADsType(adstype);
    pNewAttr->SetMultivalued(bMultivalued);
    pNewAttr->SetSyntax(szSyntax);

    m_AttrList.AddTail(pNewAttr);
  }

  //
  // Retrieve the values that are set
  //
#define RETRIEVESET
#ifdef  RETRIEVESET

  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
    //
    // Special case RootDSE because it does not support IDirectoryObject
    //
    hr = m_spIADs->GetInfo();
    for (UINT idx = 0; idx < nCount; idx++)
    {

	    VARIANT var;
	    hr = m_spIADs->GetEx( lpszAttrArray[idx] , &var );
	    if ( FAILED(hr) )
	    {
        m_RootDSEValueList.AddTail(L" ");
  	    continue;
	    }

	    /////////////////////////////////////////
	    //	Convert and populate
	    ///////////////////////////////////////////
	    CStringList sList;
	    hr = VariantToStringList( var, sList );
      if (SUCCEEDED(hr))
      {
        CString szTempValue;
        POSITION pos = sList.GetHeadPosition();
        while (pos != NULL)
        {
          CString szValue = sList.GetNext(pos);

          if (szTempValue.IsEmpty())
          {
            szTempValue += szValue;
          }
          else
          {
            szTempValue += L";" + szValue;
          }
        }
        m_RootDSEValueList.AddTail(szTempValue);
      }
    }
  }
  else
  {
    CComPtr<IDirectoryObject> spDirObject;

    hr = m_spIADs->QueryInterface(IID_IDirectoryObject, (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      return hr;
    }

    PADS_ATTR_INFO pAttrInfo = NULL;
    DWORD dwReturned = 0;

    hr = spDirObject->GetObjectAttributes(lpszAttrArray, nCount, &pAttrInfo, &dwReturned);
    if (SUCCEEDED(hr))
    {
      //
      // Save the attribute info pointer for later deletion
      //
      if (bMandatory)
      {
        m_AttrList.SaveMandatoryValuesPointer(pAttrInfo);
      }
      else
      {
        m_AttrList.SaveOptionalValuesPointer(pAttrInfo);
      }

      for (DWORD idx = 0; idx < dwReturned; idx++)
      {
        POSITION pos = m_AttrList.FindProperty(pAttrInfo[idx].pszAttrName);

        CADSIAttribute* pNewAttr = m_AttrList.GetAt(pos);
        ASSERT(pNewAttr != NULL);

        pNewAttr->SetValueSet(TRUE);
        pNewAttr->SetAttrInfo(&(pAttrInfo[idx]));
      }
      TRACE(_T("Added %u properties to the list\nThe list has %u total properties\n"), dwReturned, m_AttrList.GetCount());
    }
    else
    {
      ADSIEditErrorMessage(hr, IDS_MSG_FAIL_LOAD_VALUES, MB_OK);
    }

    for (UINT nIndex = 0; nIndex < nCount; nIndex++)
    {
      delete lpszAttrArray[nIndex];
      lpszAttrArray[nIndex] = NULL;
    }
    delete[] lpszAttrArray;
    lpszAttrArray = NULL;
  }
#endif //RETRIEVESET

  return hr;
}

ATTR_EDITOR_MAP g_attrEditorMap[] = {
//  Class,  Attribute,  ADSTYPE,                    Multivalued,  Creation function
  { NULL,   NULL,       ADSTYPE_DN_STRING,          FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_DN_STRING,          TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_CASE_IGNORE_STRING, FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_CASE_IGNORE_STRING, TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_CASE_EXACT_STRING,  FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_CASE_EXACT_STRING,  TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_PRINTABLE_STRING,   FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_PRINTABLE_STRING,   TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_NUMERIC_STRING,     FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_NUMERIC_STRING,     TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_OBJECT_CLASS,       FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_OBJECT_CLASS,       TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_INTEGER,            FALSE,        CreateSingleIntEditor         },
  { NULL,   NULL,       ADSTYPE_LARGE_INTEGER,      FALSE,        CreateSingleLargeIntEditor    },
  { NULL,   NULL,       ADSTYPE_BOOLEAN,            FALSE,        CreateSingleBooleanEditor     },
  { NULL,   NULL,       ADSTYPE_UTC_TIME,           FALSE,        CreateSingleTimeEditor        },
  { NULL,   NULL,       ADSTYPE_TIMESTAMP,          FALSE,        CreateSingleTimeEditor        },
  { NULL,   NULL,       ADSTYPE_OCTET_STRING,       FALSE,        CreateSingleOctetStringEditor },
  { NULL,   NULL,       ADSTYPE_OCTET_STRING,       TRUE,         CreateMultiOctetStringEditor  },
};

size_t g_attrEditMapCount = sizeof(g_attrEditorMap)/sizeof(ATTR_EDITOR_MAP);

CValueEditDialog* CAttributeEditorPropertyPage::RetrieveEditor(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  CValueEditDialog* pNewDialog = NULL;

  if (pAttributeEditorInfo != NULL)
  {
    int iMultivalued = 0;
    CString szSyntax;
    ADSTYPE adsType = RetrieveADsTypeFromSyntax(pAttributeEditorInfo->lpszAttribute, &iMultivalued, szSyntax);

    for (size_t idx = 0; idx < g_attrEditMapCount; idx++)
    {
      //
      // REVIEW_JEFFJON : for now I am just looking at ADSTYPE and single/multivalued
      //
      if (g_attrEditorMap[idx].adsType == adsType &&
          g_attrEditorMap[idx].bMultivalued == pAttributeEditorInfo->bMultivalued)
      {
        pNewDialog = g_attrEditorMap[idx].pfnCreateFunc(pAttributeEditorInfo->lpszClass,
                                                        pAttributeEditorInfo->lpszAttribute,
                                                        adsType,
                                                        pAttributeEditorInfo->bMultivalued);
        break;
      }
    }
  }

  return pNewDialog;
}


ADSTYPE CAttributeEditorPropertyPage::RetrieveADsTypeFromSyntax(LPCWSTR lpszAttribute, BOOL* pbMulti, CString& szSyntax)
{
  ADSTYPE adsType = ADSTYPE_INVALID;
	CADSIQueryObject schemaSearch;

  HRESULT hr = S_OK;
  CComPtr<IDirectorySearch> spDirSearch;

  // REVIEW_JEFFJON : this needs to be replaced with proper binding calls
  // REVIEW_JEFFJON : maybe this interface pointer should be retained for future use
  hr = m_pfnBind(m_szSchemaNamingContext,
                 ADS_SECURE_AUTHENTICATION,
                 IID_IDirectorySearch,
                 (PVOID*)&spDirSearch,
                 m_BindLPARAM);
  if (FAILED(hr))
  {
    return ADSTYPE_INVALID;
  }
  //
	// Initialize search object with IDirectorySearch
	//
	hr = schemaSearch.Init(spDirSearch);
	if (FAILED(hr))
	{
		return ADSTYPE_INVALID;
	}

	int cCols = 2;
  LPWSTR pszAttributes[] = {L"isSingleValued", L"attributeSyntax"};
	ADS_SEARCH_COLUMN ColumnData;
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
	if (FAILED(hr))
	{
		return ADSTYPE_INVALID;
	}

  CString csFilter;
	csFilter.Format(L"(&(objectClass=attributeSchema)(lDAPDisplayName=%s))", lpszAttribute);
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  if (SUCCEEDED(hr)) 
	{
    hr = schemaSearch.GetNextRow();
    if (SUCCEEDED(hr)) 
		{
			hr = schemaSearch.GetColumn(pszAttributes[0], &ColumnData);
			if (SUCCEEDED(hr))
			{
				TRACE(_T("\t\tisSingleValued: %d\n"), 
				     ColumnData.pADsValues->Boolean);
        *pbMulti = !ColumnData.pADsValues->Boolean;
        schemaSearch.FreeColumn(&ColumnData);
			}

      hr = schemaSearch.GetColumn(pszAttributes[1], &ColumnData);
      if (SUCCEEDED(hr))
      {
        TRACE(_T("\t\tattributeSyntax: %s\n"), 
              ColumnData.pADsValues->CaseIgnoreString);

        adsType = GetADsTypeFromString(ColumnData.pADsValues->CaseIgnoreString, szSyntax);
        schemaSearch.FreeColumn(&ColumnData);
      }
		}
	}
	return adsType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editorui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editorui.h
//
//--------------------------------------------------------------------------

#ifndef _EDITORUI_H
#define _EDITORUI_H

#include "attredit.h"
#include "snapdata.h"
#include "aclpage.h"

#include <initguid.h>

#include "IAttrEdt.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditPropertyPage

class CADSIEditPropertyPage : public CPropertyPageBase
{

// Construction
public:
  CADSIEditPropertyPage();
  CADSIEditPropertyPage(CAttrList* pAttrList);
	virtual ~CADSIEditPropertyPage() 
  {
  }

	// Used to initialize data that is needed in the UI
	//
	void SetClass(LPCWSTR sClass) { m_sClass = sClass; }
	void SetServer(LPCWSTR sServer) { m_sServer = sServer; }
	void SetPath(LPCWSTR sPath) { m_sPath = sPath; }
  void SetConnectionData(CConnectionData* pConnectData) { m_pConnectData = pConnectData; }

  void SetAttrList(CAttrList* pAttrList);
  void CopyAttrList(CAttrList* pAttrList);
  CAttrList* GetAttrList() { return m_pOldAttrList; }

	// Implementation
protected:
	
	// Message map functions
	//
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
  virtual void OnCancel();
	afx_msg void OnSelChangeAttrList();
	afx_msg void OnSelChangePropList();

	// Helper functions
	//
	void FillAttrList();
	void AddPropertiesToBox(BOOL bMand, BOOL bOpt);
	BOOL GetProperties();

// Member data

	CString m_sPath;
	CString m_sClass;
	CString m_sServer;
  CConnectionData* m_pConnectData;
	CStringList m_sMandatoryAttrList;
	CStringList m_sOptionalAttrList;
	CAttrEditor m_attrEditor;
  CAttrList* m_pOldAttrList;

  // REVIEW_JEFFJON : since this is an imbedded member and its destructor deletes everything in the list,
  //                  we have to remove everything in the list that is also in m_pOldAttrList so that it
  //                  doesn't get deleted.
  CAttrList m_AttrList;
  BOOL m_bExisting;

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// CADSIEditPropertyPageHolder

class CADSIEditPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CADSIEditPropertyPageHolder(CADSIEditContainerNode* pRootDataNode, CTreeNode* pContainerNode,
			CComponentDataObject* pComponentData, LPCWSTR lpszClass, LPCWSTR lpszServer, LPCWSTR lpszPath); 
	~CADSIEditPropertyPageHolder()
	{
		if (m_pAclEditorPage != NULL)
    {
			delete m_pAclEditorPage;
      m_pAclEditorPage = NULL;
    }
	}

	HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);

	virtual CADSIEditContainerNode* GetContainerNode() { return m_pContainer; }

private:
	CAclEditorPage*					    m_pAclEditorPage;

  CComPtr<IDsAttributeEditor> m_spIDsAttributeEditor;

  CString                     m_sPath;

	CComPtr<IADs>               m_pADs;
	CADSIEditContainerNode*     m_pContainer;
};

/////////////////////////////////////////////////////////////////////////////////////
// CCreateWizPropertyPageHolder

class CCreateWizPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CCreateWizPropertyPageHolder(CADSIEditContainerNode* pRootDataNode,	
                               CComponentDataObject* pComponentData, 
                               LPCWSTR lpszClass, 
                               LPCWSTR lpszServer,
                               CAttrList* pAttrList); 
	~CCreateWizPropertyPageHolder()
	{
	}

	virtual CADSIEditContainerNode* GetContainerNode() { return m_pContainer; }

private:
	CADSIEditPropertyPage m_propPage;

	CADSIEditContainerNode* m_pContainer;
};


#endif _EDITORUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editui.h ===
#ifndef __ATTRIBUTE_EDITOR_UI_H
#define __ATTRIBUTE_EDITOR_UI_H

#include "resource.h"

#include "attr.h"
#include "IAttrEdt.h"

////////////////////////////////////////////////////////////////////
// CValueEditDialog - base class for creating syntax specific editors

class CValueEditDialog : public CDialog
{
public:
  virtual ~CValueEditDialog() {}

protected:
  //
  // Force subclassing of this class
  //
  CValueEditDialog(UINT nDlgID) : CDialog(nDlgID) {}

private:
  CValueEditDialog() {}
  CValueEditDialog(const CValueEditDialog& copyref) {}
  CValueEditDialog& operator=(const CValueEditDialog& copyref) {}

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

  DECLARE_MESSAGE_MAP();

protected:
  void GetClass(CString& szClassRef) { szClassRef = m_szClass; }
  void GetAttribute(CString& szAttributeRef) { szAttributeRef = m_szAttribute; }
  BOOL IsMultivalued() { return m_bMultivalued; }
  LPBINDINGFUNC GetBindingFunction() { return m_pfnBindingFunction; }
  LPARAM GetLParam() { return m_lParam; }

  PADSVALUE     m_pOldADsValue;
  DWORD         m_dwOldNumValues;

  CString       m_szClass;
  CString       m_szAttribute;
  BOOL          m_bMultivalued;
  ADSTYPE       m_adsType;
  LPBINDINGFUNC m_pfnBindingFunction;
  LPARAM        m_lParam;
};

////////////////////////////////////////////////////////////////////
// LPEDITORDIALOGFUNC - editor creation function definition

typedef CValueEditDialog* (*LPEDITORDIALOGFUNC)(PCWSTR pszClass,
                                                PCWSTR pszAttribute,
                                                ADSTYPE adsType,
                                                BOOL   bMultivalued);

////////////////////////////////////////////////////////////////////
// ATTR_EDITOR_MAP - struct used to map a specific attribute and
//                   syntax to an editor

typedef struct _attr_editor_map
{
  PCWSTR  pszClass;
  PCWSTR  pszAttribute;
  ADSTYPE adsType;
  BOOL    bMultivalued;
  LPEDITORDIALOGFUNC pfnCreateFunc;
} ATTR_EDITOR_MAP, *PATTR_EDITOR_MAP;


////////////////////////////////////////////////////////////////////
// CSingleStringEditor - string editor implementation for single valued
//                       ADSTYPE_CASE_IGNORE_STRING, 
//                       ADSTYPE_CASE_EXACT_STRING,
//                       ADSTYPE_PRINTABLE_STRING
//

class CSingleStringEditor : public CValueEditDialog
{
public:
  CSingleStringEditor() : CValueEditDialog(IDD_STRING_EDITOR_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  CString   m_szOldValue;
  CString   m_szNewValue;
};

CValueEditDialog* CreateSingleStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CMultiStringEditor - string editor implementation for multivalued
//                      ADSTYPE_CASE_IGNORE_STRING, 
//                      ADSTYPE_CASE_EXACT_STRING,
//                      ADSTYPE_PRINTABLE_STRING
//

class CMultiStringEditor : public CValueEditDialog
{
public:
  CMultiStringEditor() : CValueEditDialog(IDD_STRING_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnListSelChange();
  afx_msg void OnEditChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CStringList   m_szOldValueList;
  CStringList   m_szNewValueList;
};

CValueEditDialog* CreateMultiStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleIntEditor - string editor implementation for single valued
//                    ADSTYPE_INTEGER
//

class CSingleIntEditor : public CValueEditDialog
{
public:
  CSingleIntEditor() : CValueEditDialog(IDD_INT_EDITOR_DIALOG)
  {
    m_bValueSet = FALSE;
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  DWORD   m_dwOldValue;
  DWORD   m_dwNewValue;
  BOOL    m_bValueSet;
};

CValueEditDialog* CreateSingleIntEditor(PCWSTR pszClass,
                                        PCWSTR pszAttribute,
                                        ADSTYPE adsType,
                                        BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleLargeIntEditor - string editor implementation for single valued
//                         ADSTYPE_LARGE_INTEGER
//

class CSingleLargeIntEditor : public CValueEditDialog
{
public:
  CSingleLargeIntEditor() : CValueEditDialog(IDD_LARGEINT_EDITOR_DIALOG)
  {
    m_bValueSet = FALSE;
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  LARGE_INTEGER   m_liOldValue;
  LARGE_INTEGER   m_liNewValue;
  BOOL            m_bValueSet;
};

CValueEditDialog* CreateSingleLargeIntEditor(PCWSTR pszClass,
                                             PCWSTR pszAttribute,
                                             ADSTYPE adsType,
                                             BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleBooleanEditor - editor implementation for single valued
//                        ADSTYPE_BOOLEAN
//

class CSingleBooleanEditor : public CValueEditDialog
{
public:
  CSingleBooleanEditor() : CValueEditDialog(IDD_BOOLEAN_EDITOR_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  BOOL  m_bOldValue;
  BOOL  m_bNewValue;
  BOOL  m_bValueSet;
};

CValueEditDialog* CreateSingleBooleanEditor(PCWSTR pszClass,
                                            PCWSTR pszAttribute,
                                            ADSTYPE adsType,
                                            BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleTimeEditor - editor implementation for single valued
//                     ADSTYPE_UTC_TIME
//

class CSingleTimeEditor : public CValueEditDialog
{
public:
  CSingleTimeEditor() : CValueEditDialog(IDD_TIME_EDITOR_DIALOG)
  {
    memset(&m_stOldValue, 0, sizeof(SYSTEMTIME));
    memset(&m_stNewValue, 0, sizeof(SYSTEMTIME));
    m_bValueSet = FALSE;
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  SYSTEMTIME    m_stOldValue;
  SYSTEMTIME    m_stNewValue;
  BOOL          m_bValueSet;
};

CValueEditDialog* CreateSingleTimeEditor(PCWSTR pszClass,
                                         PCWSTR pszAttribute,
                                         ADSTYPE adsType,
                                         BOOL bMultivalued);



////////////////////////////////////////////////////////////////////
// COctetStringEditor - editor implementation for single valued
//                      ADSTYPE_OCTET_STRING
//

#define MAX_OCTET_STRING_VALUE_LENGTH 200

class COctetStringEditor : public CValueEditDialog
{
public:
  COctetStringEditor() : CValueEditDialog(IDD_OCTET_STRING_EDITOR_DIALOG)
  {
    m_dwOldLength = 0;
    m_pOldValue   = NULL;
    m_dwNewLength = 0;
    m_pNewValue   = NULL;

    m_bValueSet = FALSE;
  }

  ~COctetStringEditor()
  {
    if (m_pOldValue)
    {
      delete[] m_pOldValue;
      m_pOldValue = 0;
    }

    if (m_pNewValue)
    {
      delete[] m_pNewValue;
      m_pNewValue = 0;
    }
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnProcessEdit();
  afx_msg void OnEditButton();
  afx_msg void OnClearButton();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  DWORD         m_dwOldLength;
  BYTE*         m_pOldValue;
  DWORD         m_dwNewLength;
  BYTE*         m_pNewValue;
  BOOL          m_bValueSet;

  CByteArrayDisplay m_display;
};

CValueEditDialog* CreateSingleOctetStringEditor(PCWSTR pszClass,
                                                 PCWSTR pszAttribute,
                                                 ADSTYPE adsType,
                                                 BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CMultiOctetStringEditor - octet string editor for multivalued
//                           ADSTYPE_OCTET_STRING, 
//

class CMultiOctetStringEditor : public CValueEditDialog
{
public:
  CMultiOctetStringEditor() : CValueEditDialog(IDD_OCTET_STRING_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnEditButton();
  afx_msg void OnListSelChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CList<PADSVALUE, PADSVALUE>   m_OldValueList;
  CList<PADSVALUE, PADSVALUE>   m_NewValueList;
};

CValueEditDialog* CreateMultiOctetStringEditor(PCWSTR pszClass,
                                               PCWSTR pszAttribute,
                                               ADSTYPE adsType,
                                               BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CAttributeEditorPropertyPage - attribute editor property pages

class CAttributeEditorPropertyPage : public CPropertyPage
{
public:
  CAttributeEditorPropertyPage(IADs* pIADs, 
                         IADsClass* pIADsClass, 
                         LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
                         CADSIEditPropertyPageHolder* pHolder);
  ~CAttributeEditorPropertyPage();

  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();

  afx_msg void OnMandatoryCheck();
  afx_msg void OnOptionalCheck();
  afx_msg void OnValueSetCheck();
  afx_msg void OnEditAttribute();
  afx_msg void OnSortList(NMHDR* pNotifyStruct, LRESULT* result);
  afx_msg void OnNotifyEditAttribute(NMHDR* pNotifyStruct, LRESULT* result);
  afx_msg void OnListItemChanged(NMHDR* pNotifyStruct, LRESULT* result);

  CADSIAttribute* GetAttributeFromList(int iSelectedItem);
  void    GetAttributeInfo(CADSIAttribute* pAttr, 
                           LPDS_ATTRIBUTE_EDITORINFO* ppAttributeEditorInfo,
                           BOOL* pbOwnValueMemory);
  void    EditAttribute(CADSIAttribute* pSelectedAttr);
  void    ShowListCtrl();
  HRESULT GetSchemaNamingContext();
  HRESULT RetrieveAttributes();
  void    FillListControl();
  void    SetEditButton();
  HRESULT CreateAttributeList(CStringList& sList, BOOL bMandatory);
  ADSTYPE RetrieveADsTypeFromSyntax(LPCWSTR lpszAttribute, BOOL* pbMultivalued, CString& szSyntax);

  CValueEditDialog* RetrieveEditor(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);

  UINT    GetSortColumn() { return m_nSortColumn; }

  DECLARE_MESSAGE_MAP()

private:
  CComPtr<IADs>      m_spIADs;
  CComPtr<IADsClass> m_spIADsClass;

  BOOL    m_bMandatory;
  BOOL    m_bOptional;
  BOOL    m_bSet;

  UINT    m_nSortColumn;

  CAttrList2 m_AttrList;
  CStringList m_RootDSEValueList;

  CString m_szClass;
  CString m_szPrefix;
  CString m_szSchemaNamingContext;

  LPARAM  m_BindLPARAM;
  LPBINDINGFUNC m_pfnBind;
  DWORD   m_dwBindFlags;

  CADSIEditPropertyPageHolder* m_pHolder;
};

#endif //__ATTRIBUTE_EDITOR_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\editorui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editorui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "attredit.h"
#include "adsiedit.h"
#include "editor.h"
#include "editorui.h"
#include "snapdata.h"
#include "common.h"
#include <aclpage.h>
#include <dssec.h>	// For AclEditor flags
#include "connection.h"


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////////
// this is used to fill in the attributes for RootDSE
//
typedef struct tagRootDSEAttr
{
	LPCWSTR	lpszAttr;
	LPCWSTR	lpszSyntax;
	BOOL		bMulti;		
} SYNTAXMAP;
	
SYNTAXMAP g_ldapRootDSESyntax[] = 
{
	_T("currentTime"),						_T("UTCTime"),		FALSE,
	_T("subschemaSubentry"),				_T("String"),		FALSE,
	_T("serverName"),							_T("String"),		FALSE,
	_T("namingContexts"),					_T("String"),		TRUE,
	_T("defaultNamingContext"),			_T("String"),		FALSE,
	_T("schemaNamingContext"),				_T("String"),		FALSE,
	_T("configurationNamingContext"),	_T("String"),		FALSE,
	_T("rootDomainNamingContext"),		_T("String"),		FALSE,
	_T("supportedControl"),					_T("String"),		TRUE,
	_T("supportedLDAPVersion"),			_T("Integer"),		TRUE,
	_T("supportedLDAPPolicies"),			_T("String"),		TRUE,
	_T("supportedSASLMechanisms"),		_T("String"),		TRUE,
	_T("dsServiceName"),						_T("String"),		FALSE,
	_T("dnsHostName"),						_T("String"),		FALSE,
	_T("supportedCapabilities"),			_T("String"),		TRUE,
	_T("ldapServiceName"),					_T("String"),		FALSE,
	_T("highestCommittedUsn"),				_T("String"),		FALSE, // this should be an integer but after investigation I found it was a string
	NULL,	  0,
};

extern LPCWSTR g_lpszGC;

/////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CADSIEditPropertyPage, CPropertyPageBase)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_CBN_SELCHANGE(IDC_PROP_BOX, OnSelChangeAttrList)	
	ON_CBN_SELCHANGE(IDC_PROPTYPES_BOX, OnSelChangePropList)	
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CADSIEditPropertyPage::CADSIEditPropertyPage() 
				: CPropertyPageBase(IDD_PROPERTY_PAGE)
{
  m_bExisting = TRUE;
}

CADSIEditPropertyPage::CADSIEditPropertyPage(CAttrList* pAttrs)
        : CPropertyPageBase(IDD_PROPERTY_PAGE)
{
  ASSERT(pAttrs != NULL);
  m_pOldAttrList = pAttrs;
  m_bExisting = FALSE;
  CopyAttrList(pAttrs);
}

void CADSIEditPropertyPage::CopyAttrList(CAttrList* pAttrList)
{
  m_AttrList.RemoveAll();
  POSITION pos = pAttrList->GetHeadPosition();
  while (pos != NULL)
  {
    m_AttrList.AddHead(pAttrList->GetNext(pos));
  }
}

BOOL CADSIEditPropertyPage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();

	// Get the dialog items
	//
	CEdit* pPathBox = (CEdit*)GetDlgItem(IDC_PATH_BOX);
	CEdit* pClassBox = (CEdit*)GetDlgItem(IDC_CLASS_BOX);
	CComboBox* pPropSelectBox = (CComboBox*)GetDlgItem(IDC_PROPTYPES_BOX);
	CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);
	CStatic* pPathLabel = (CStatic*)GetDlgItem(IDC_PATH_LABEL);
	CStatic* pClassLabel = (CStatic*)GetDlgItem(IDC_CLASS_LABEL);
	CStatic* pFilterLabel = (CStatic*)GetDlgItem(IDC_FILTER_LABEL);
	CStatic* pPropertyLabel = (CStatic*)GetDlgItem(IDC_PROPERTY_LABEL);
	CStatic* pSyntaxLabel = (CStatic*)GetDlgItem(IDC_SYNTAX_LABEL);
	CStatic* pEditLabel = (CStatic*)GetDlgItem(IDC_EDIT_LABEL);
	CStatic* pValueLabel = (CStatic*)GetDlgItem(IDC_VALUE_LABEL);
	CButton* pAttrGroup = (CButton*)GetDlgItem(IDC_ATTR_GROUP);
	CStatic* pNoInfoLabel = (CStatic*)GetDlgItem(IDC_NO_INFO);


  if (m_bExisting)
  {
    // This determines whether the node is complete with data or not.  If not we won't enable
	  //   the UI
	  //
	  BOOL bComplete = TRUE;
	  CADsObject* pADsObject = NULL;
	  CTreeNode* pTreeNode = GetHolder()->GetTreeNode();
	  CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pTreeNode);
	  if (pContNode == NULL)
	  {
		  CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(pTreeNode);
		  ASSERT(pLeafNode != NULL);
		  pADsObject = pLeafNode->GetADsObject();
      m_pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
		  bComplete = pADsObject->IsComplete();
	  }
	  else
	  {
		  pADsObject = pContNode->GetADsObject();
      m_pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
		  bComplete = pADsObject->IsComplete();
	  }

	  
	  // Initialize the attribute editor 
	  //
	  m_attrEditor.Initialize(this, pTreeNode, m_sServer,
									  IDC_EDITVALUE_BOX, IDC_SYNTAX_BOX,
									  IDC_VALUE_EDITBOX,	IDC_VALUE_LISTBOX,
									  IDC_ADD_BUTTON,	IDC_REMOVE_BUTTON,
									  bComplete);


	  // Get the UI to reflect the data
	  //
	  if ( bComplete)
	  {
		  pPathBox->SetWindowText(m_sPath);

		  GetProperties();

		  pClassBox->SetWindowText(m_sClass);

		  CString sMand, sOpt, sBoth;
		  if (!sMand.LoadString(IDS_MANDATORY) ||
				  !sOpt.LoadString(IDS_OPTIONAL) ||
				  !sBoth.LoadString(IDS_BOTH))
		  {
			  ADSIEditMessageBox(IDS_MSG_FAIL_TO_LOAD, MB_OK);
		  }

		  if (m_pConnectData->IsRootDSE())
		  {
			  pPropSelectBox->AddString(sMand);
			  pPropSelectBox->SetCurSel(0);
		  }
		  else
		  {
			  pPropSelectBox->AddString(sMand);
			  pPropSelectBox->AddString(sOpt);
			  pPropSelectBox->AddString(sBoth);

			  pPropSelectBox->SetCurSel(1);
		  }

		  OnSelChangePropList();
		  pPropertyBox->SetCurSel(0);
	  }
	  else
	  {
		  pClassBox->ShowWindow(SW_HIDE);
		  pPropSelectBox->ShowWindow(SW_HIDE);
		  pPropertyBox->ShowWindow(SW_HIDE);
		  pPathLabel->ShowWindow(SW_HIDE);
		  pClassLabel->ShowWindow(SW_HIDE);
		  pFilterLabel->ShowWindow(SW_HIDE);
		  pPropertyLabel->ShowWindow(SW_HIDE);
		  pSyntaxLabel->ShowWindow(SW_HIDE);
		  pEditLabel->ShowWindow(SW_HIDE);
		  pValueLabel->ShowWindow(SW_HIDE);
		  pAttrGroup->ShowWindow(SW_HIDE);

		  pNoInfoLabel->ShowWindow(SW_SHOW);
	  }
  }
  else
  {
	  // Initialize the attribute editor 
	  //
	  m_attrEditor.Initialize(this, m_pConnectData, m_sServer,
									  IDC_EDITVALUE_BOX, IDC_SYNTAX_BOX,
									  IDC_VALUE_EDITBOX,	IDC_VALUE_LISTBOX,
									  IDC_ADD_BUTTON,	IDC_REMOVE_BUTTON,
									  TRUE, &m_AttrList);

    pPathBox->SetWindowText(m_sPath);

		GetProperties();

		pClassBox->SetWindowText(m_sClass);

		CString sMand, sOpt, sBoth;
		if (!sMand.LoadString(IDS_MANDATORY) ||
				!sOpt.LoadString(IDS_OPTIONAL) ||
				!sBoth.LoadString(IDS_BOTH))
		{
			ADSIEditMessageBox(IDS_MSG_FAIL_TO_LOAD, MB_OK);
		}

		if (m_pConnectData->IsRootDSE())
		{
			pPropSelectBox->AddString(sMand);
			pPropSelectBox->SetCurSel(0);
		}
		else
		{
			pPropSelectBox->AddString(sMand);
			pPropSelectBox->AddString(sOpt);
			pPropSelectBox->AddString(sBoth);

			pPropSelectBox->SetCurSel(1);
		}

		OnSelChangePropList();
		pPropertyBox->SetCurSel(0);

  }
	return TRUE;
}

BOOL CADSIEditPropertyPage::OnApply()
{
	if( m_attrEditor.OnApply())
  {
    if (!m_bExisting)
    {
      m_pOldAttrList->RemoveAll();
      while (!m_AttrList.IsEmpty())
      {
        m_pOldAttrList->AddTail(m_AttrList.RemoveTail());
      }
    }
  }
  else
  {
    return FALSE;
  }
  return TRUE;
}

void CADSIEditPropertyPage::OnCancel()
{
  if (!m_bExisting)
  {
    while (!m_AttrList.IsEmpty())
    {
      CADSIAttr* pAttr = m_AttrList.RemoveTail();
      ASSERT(pAttr != NULL);

      CString szProp;
      pAttr->GetProperty(szProp);
      if (!m_pOldAttrList->HasProperty(szProp))
      {
        delete pAttr;
      }
    }
  }
}

void CADSIEditPropertyPage::SetAttrList(CAttrList* pAttrList)
{
  ASSERT(pAttrList != NULL);
  m_pOldAttrList = pAttrList;
}

void CADSIEditPropertyPage::OnSelChangePropList()
{
	// Filter the properties list
	//
	FillAttrList();
	OnSelChangeAttrList();
}

void CADSIEditPropertyPage::OnSelChangeAttrList()
{
	CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);

	int idx, iCount;
	CString s;
	HRESULT hr;

  idx = pPropertyBox->GetCurSel();
	
	// Make sure a property was selected
	//
	if ( idx == LB_ERR )
	{
		return;
	}

	pPropertyBox->GetLBText( idx, s );

	// Have the attribute editor display the values for the new property
	//
	m_attrEditor.SetAttribute(s, m_sPath);
}

BOOL CADSIEditPropertyPage::GetProperties()
{
	CString schema;

	//Get the class object so that we can get the properties
	//
	if (!m_pConnectData->IsRootDSE()) // Not RootDSE
	{
		m_pConnectData->GetAbstractSchemaPath(schema);
		schema += m_sClass;

		// bind to object with authentication
		//
		CComPtr<IADsClass> pClass;
		HRESULT	hr, hCredResult;
		hr = OpenObjectWithCredentials(
												 m_pConnectData, 
												 m_pConnectData->GetCredentialObject()->UseCredentials(),
												 (LPWSTR)(LPCWSTR)schema,
												 IID_IADsClass, 
												 (LPVOID*) &pClass,
												 GetSafeHwnd(),
												 hCredResult
												);
		if ( FAILED(hr) )
		{
			if (SUCCEEDED(hCredResult))
			{
				ADSIEditErrorMessage(hr);
			}
			return FALSE;
		}

		// Get the Mandatory Properties
		//
		VARIANT var;
		VariantInit(&var);
		hr = pClass->get_MandatoryProperties(&var);
		if ( FAILED(hr) )
		{
			ADSIEditErrorMessage(hr);
			return FALSE;
		}
		VariantToStringList( var, m_sMandatoryAttrList );
		VariantClear(&var);	

		// Remove the nTSecurityDescriptor from the list because the aclEditor replaces it for ui purposes
		//
		m_sMandatoryAttrList.RemoveAt(m_sMandatoryAttrList.Find(_T("nTSecurityDescriptor")));

		// Get the Optional Properties
		//
		VariantInit(&var);
		hr = pClass->get_OptionalProperties(&var);
		if ( FAILED(hr) )
		{
			ADSIEditErrorMessage(hr);
			return FALSE;
		}
		VariantToStringList( var, m_sOptionalAttrList );
		VariantClear(&var);
	}
	else		// RootDSE
	{
		int idx=0;

		// Add in the predefined attributes for the RootDSE
		//
		while( g_ldapRootDSESyntax[idx].lpszAttr )
		{
			m_sMandatoryAttrList.AddTail(g_ldapRootDSESyntax[idx].lpszAttr);
			idx++;
		}
	}
	return TRUE;
}

void CADSIEditPropertyPage::FillAttrList()
{
	CComboBox* pPropSelectBox = (CComboBox*)GetDlgItem(IDC_PROPTYPES_BOX);
	CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);
	POSITION pos;
	CString s;

	// Clean out the property box
	//
	int iCount = pPropertyBox->GetCount();
	while (iCount > 0)
	{
		pPropertyBox->DeleteString(0);
		iCount--;
	}

	// Get the filter to use
	//
  int idx = pPropSelectBox->GetCurSel();
	if ( idx == LB_ERR )
	{
		return;
	}

	// Fill in the property box using the filter
	//
	if (idx == IDS_BOTH - IDS_MANDATORY)
	{
		AddPropertiesToBox(TRUE, TRUE);
	}
	else if (idx == IDS_MANDATORY - IDS_MANDATORY)
	{
		AddPropertiesToBox(TRUE, FALSE);
	}
	else
	{
		AddPropertiesToBox(FALSE, TRUE);
	}
	pPropertyBox->SetCurSel(0);
}

void CADSIEditPropertyPage::AddPropertiesToBox(BOOL bMand, BOOL bOpt)
{
	CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);

	POSITION pos;

	if (bMand)
	{
		// Add Mandatory Properties
		//
		pos = m_sMandatoryAttrList.GetHeadPosition();
		while( pos != NULL )
		{
			CString s = m_sMandatoryAttrList.GetNext(pos);
		
			if ( !s.IsEmpty())
			{
				pPropertyBox->AddString( s );
			}
		}
	}

	if (bOpt)
	{
		// Add Optional Properties
		//
		pos = m_sOptionalAttrList.GetHeadPosition();
		while( pos != NULL )
		{
			CString s = m_sOptionalAttrList.GetNext(pos);
		
			if ( !s.IsEmpty())
			{
				pPropertyBox->AddString( s );
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////

CADSIEditPropertyPageHolder::CADSIEditPropertyPageHolder(CADSIEditContainerNode* pContainerNode, 
			CTreeNode* pThisNode,	CComponentDataObject* pComponentData, 
			LPCWSTR lpszClass, LPCWSTR lpszServer, LPCWSTR lpszPath) 
			: CPropertyPageHolderBase(pContainerNode, pThisNode, pComponentData)
{
	ASSERT(pComponentData != NULL);
	ASSERT(pContainerNode != NULL);

	m_pContainer = pContainerNode;
	ASSERT(pContainerNode == GetContainerNode());
	ASSERT(pThisNode != NULL);
	m_pAclEditorPage = NULL;
	m_bAutoDeletePages = FALSE; // we have the page as embedded member

	m_sPath = lpszPath;
	m_pADs = NULL;

  //
	// This gets the CConnectionData from the ConnectionNode by finding a valid treenode and using its
	//   CADsObject to get the ConnectionNode and then the CConnectionData
	//
	CADSIEditContainerNode* pNode = GetContainerNode();
	CADSIEditConnectionNode* pConnectNode = pNode->GetADsObject()->GetConnectionNode();
	CConnectionData* pConnectData = pConnectNode->GetConnectionData();

	CCredentialObject* pCredObject = pConnectData->GetCredentialObject();

	HRESULT hr, hCredResult;
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)m_sPath,
											 IID_IADs, 
											 (LPVOID*) &m_pADs,
											 NULL,
											 hCredResult
											 );

  if (SUCCEEDED(hr))
  {
    //
    // Create the advanced attribute editor
    //
    hr = ::CoCreateInstance(CLSID_DsAttributeEditor, NULL, CLSCTX_INPROC_SERVER,
                            IID_IDsAttributeEditor, (void**)&m_spIDsAttributeEditor);

    if (SUCCEEDED(hr))
    {
      CString szLDAP;
      pConnectData->GetLDAP(szLDAP);
      CString szServer;
      pConnectData->GetDomainServer(szServer);
      CString szProviderServer = szLDAP + szServer + _T("/");

      DS_ATTREDITOR_BINDINGINFO attrInfo = {0};
      attrInfo.dwSize = sizeof(DS_ATTREDITOR_BINDINGINFO);
      attrInfo.lpfnBind = BindingCallbackFunction;
      attrInfo.lParam = (LPARAM)pCredObject;
      attrInfo.lpszProviderServer = const_cast<LPWSTR>((LPCWSTR)szProviderServer);

      if (pConnectData->IsRootDSE())
      {
        attrInfo.dwFlags = DSATTR_EDITOR_ROOTDSE;
      }

      hr = m_spIDsAttributeEditor->Initialize(m_pADs, &attrInfo, this);
    }

	  if (!pConnectData->IsRootDSE() && !pConnectData->IsGC())
	  {
      CString szUsername;
		  WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];
		  pCredObject->GetUsername(szUsername);
		  pCredObject->GetPassword(szPassword);

		  if (pCredObject->UseCredentials())
		  {
			  m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
										  lpszServer,
										  szUsername,
										  szPassword,
										  DSSI_NO_FILTER,
										  this);
		  }
		  else
		  {
			  m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
										  NULL,
										  NULL,
										  NULL,
										  DSSI_NO_FILTER,
										  this);
		  }
    }
  }
  else
  {
	  if (!pConnectData->IsRootDSE() && !pConnectData->IsGC())
	  {
		  if (SUCCEEDED(hCredResult))
		  {
		    CString szUsername;
		    WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];
		    pCredObject->GetUsername(szUsername);
		    pCredObject->GetPassword(szPassword);

        ADSIEditErrorMessage(hr);

        // Create the acl editor even if we were not successful binding, because 
        // the object may be deny read and we would still want the acl editor
			  if (pCredObject->UseCredentials())
			  {
				  m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
											  lpszServer,
											  szUsername,
											  szPassword,
											  DSSI_NO_FILTER,
											  this);
			  }
			  else
			  {
				  m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
											  NULL,
											  NULL,
											  NULL,
											  DSSI_NO_FILTER,
											  this);
			  }

			  return;
		  }
    }
  }
}

HRESULT CADSIEditPropertyPageHolder::OnAddPage(int nPage, CPropertyPageBase* pPage)
{
  HRESULT hr = S_OK;

	if (nPage == 0)
  {
    //
    // Add the advanced editor page
    //
    HPROPSHEETPAGE hAttrPage = NULL;

    if (m_spIDsAttributeEditor != NULL)
    {
      hr = m_spIDsAttributeEditor->GetPage(&hAttrPage);
      if (SUCCEEDED(hr))
      {
        hr = AddPageToSheetRaw(hAttrPage);
      }
    }
  }
  else if ( nPage == -1)
  {
    if (m_pAclEditorPage != NULL)
    {
      //
	    // add the ACL editor page after the last, if present
      //
	    HPROPSHEETPAGE  hPage = m_pAclEditorPage->CreatePage();
	    if (hPage == NULL)
      {
		    return E_FAIL;
      }
      //
	    // add the raw HPROPSHEETPAGE to sheet, not in the list
      //
	    hr = AddPageToSheetRaw(hPage);
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

CCreateWizPropertyPageHolder::CCreateWizPropertyPageHolder(CADSIEditContainerNode* pContainerNode, 
			CComponentDataObject* pComponentData,	LPCWSTR lpszClass, LPCWSTR lpszServer, CAttrList* pAttrList) 
			: CPropertyPageHolderBase(pContainerNode, NULL, pComponentData), m_propPage(pAttrList)
{
	ASSERT(pComponentData != NULL);
	ASSERT(pContainerNode != NULL);

	m_pContainer = pContainerNode;
	ASSERT(pContainerNode == GetContainerNode());
	m_bAutoDeletePages = FALSE; // we have the page as embedded member

	m_propPage.SetClass(lpszClass);
	m_propPage.SetServer(lpszServer);
  m_propPage.SetConnectionData(pContainerNode->GetADsObject()->GetConnectionNode()->GetConnectionData());
	AddPageToList((CPropertyPageBase*)&m_propPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\filterui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       filterui.h
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
// filterui.h

#ifndef _FILTERUI_H
#define _FILTERUI_H

#include "common.h"
//#include "editor.h"
#include "resource.h"

class CConnectionData;
class CADSIFilterObject;

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterDialog

class CADSIFilterDialog : public CDialog
{
public :
	CADSIFilterDialog(CConnectionData* pConnectData) : CDialog(IDD_FILTER_DIALOG)
	{	
		m_pConnectData = pConnectData;
		m_sUserFilter = _T("");
	}
	~CADSIFilterDialog() {};

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnEditFilter();
	void OnSelFilterRadio();
	void OnSelShowAllRadio();


private :
	CADSIFilterObject* m_pFilterObject;

	CString m_sUserFilter;
	CStringList m_sContainerList;

	CConnectionData* m_pConnectData;
	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CContainerCheckListBox

class CContainerCheckListBox : public CCheckListBox
{
public :
	CContainerCheckListBox() {}
	~CContainerCheckListBox(){}

	BOOL Initialize(UINT nID, const CStringList& sContainerList, 
									const CStringList& sFilterList, CWnd* pParentWnd);
};

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterEditDialog

class CADSIFilterEditDialog : public CDialog
{
public :
	CADSIFilterEditDialog(CConnectionData* pConnectData,
												CString* psFilter,
												CStringList* psContList);
	~CADSIFilterEditDialog() {};

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	void GetContainersFromSchema(CStringList& sContainerList);

private :
	CContainerCheckListBox m_ContainerBox;

	CConnectionData* m_pConnectData;
	CADSIFilterObject* m_pFilterObject;

	CString* m_psFilter;
	CStringList* m_psContList;

	DECLARE_MESSAGE_MAP()
};

#endif //_FILTERUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\iattredt.h ===
#ifndef __ATTRINTERFACE_H
#define __ATTRINTERFACE_H


// {C7436F12-A27F-4cab-AACA-2BD27ED1B773}
DEFINE_GUID(CLSID_DsAttributeEditor, 
0xc7436f12, 0xa27f, 0x4cab, 0xaa, 0xca, 0x2b, 0xd2, 0x7e, 0xd1, 0xb7, 0x73);

//
// Interface GUIDs
//

// {A9948091-69FF-4c00-BE92-925D42E0AD39}
DEFINE_GUID(IID_IDsAttributeEditor, 
0xa9948091, 0x69ff, 0x4c00, 0xbe, 0x92, 0x92, 0x5d, 0x42, 0xe0, 0xad, 0x39);

// {A9948091-69FF-4c00-BE93-925D42E0AD39}
DEFINE_GUID(IID_IDsAttributeEditorExt, 
0xa9948091, 0x69ff, 0x4c00, 0xbe, 0x93, 0x92, 0x5d, 0x42, 0xe0, 0xad, 0x39);

// {5828DF66-95FB-4afa-8F8E-EA0B7D302FB5}
DEFINE_GUID(IID_IDsBindingInfo, 
0x5828df66, 0x95fb, 0x4afa, 0x8f, 0x8e, 0xea, 0xb, 0x7d, 0x30, 0x2f, 0xb5);

// ----------------------------------------------------------------------------
// 
// Interface: IDsBindingInfo
//  
// Implemented by any client needing to invoke the attribute editor UI
//
// Used by: the attribute editor UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsBindingInfo

interface __declspec(uuid("{5828DF66-95FB-4afa-8F8E-EA0B7D302FB5}")) IDsBindingInfo : public IUnknown
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsBindingInfo methods ***
  STDMETHOD(DoBind)(THIS_ /*IN*/ LPCWSTR lpszPathName,
                          /*IN*/ DWORD  dwReserved,
                          /*IN*/ REFIID riid,
                          /*IN*/ void FAR * FAR * ppObject) PURE;
};

// ----------------------------------------------------------------------------
// 
// Interface: IDsAttributeEditor
//  
// Implemented by the object (implemented by the system) CLSID_DsAttributeEditor
//
// Used by: any client needing to invoke the attribute editor UI
//

//
// Function definition for the binding callback function
//
typedef HRESULT (*LPBINDINGFUNC)(/*IN*/ LPCWSTR lpszPathName,
                                 /*IN*/ DWORD  dwReserved,
                                 /*IN*/ REFIID riid,
                                 /*IN*/ void FAR * FAR * ppObject,
                                 /*IN*/ LPARAM lParam);

//
// struct passed to IDsAttributeEditor::Initialize()
//
// it contains information regarding the binding function
//

typedef struct
{
    DWORD     dwSize;             // size of struct, for versioning
    DWORD     dwFlags;            // flags defined below
    LPBINDINGFUNC lpfnBind;       // the callback function used to bind to Active Directory
    LPARAM    lParam;             // an optional property that is passed back to lpfnBind
    LPWSTR    lpszProviderServer; // the provider and server that will be used to perform binds
                                  // in the form <Provider>://<server>/
} DS_ATTREDITOR_BINDINGINFO, * LPDS_ATTREDITOR_BINDINGINFO;
  
//
// Forward declaration
//
class CADSIEditPropertyPageHolder;

//
// Flags used in the DS_ATTREDITOR_BINDINGINFO struct above
//
#define DSATTR_EDITOR_ROOTDSE   0x00000001  // Connection is being made to the RootDSE (don't do schema checks)

#undef  INTERFACE
#define INTERFACE   IDsAttributeEditor

interface __declspec(uuid("{A9948091-69FF-4c00-BE92-925D42E0AD39}")) IDsAttributeEditor : public IUnknown
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAttributeEditor methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADs* pADsObj, 
                              /*IN*/ LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
                              /*IN*/ CADSIEditPropertyPageHolder* pHolder) PURE;
  STDMETHOD(CreateModal)() PURE;
  STDMETHOD(GetPage)(THIS_ /*OUT*/ HPROPSHEETPAGE* phPropSheetPage) PURE;
};

// ----------------------------------------------------------------------------
// 
// Interface: IDsAttributeEditorExt
//  
// Implemented by any client needing to provide a custom editor for any DS attribute or syntax
//
// Used by: the system to provide editing capabilities for attributes
//

//
// struct passed to IDsAttributeEditorExt::Initialize()
//
// it contains information regarding the attribute type and values
//

typedef struct
{
    DWORD     dwSize;             // size of struct, for versioning
    LPWSTR    lpszClass;          // pointer to a wide character string containing the class name
    LPWSTR    lpszAttribute;      // pointer to a wide character string containing the attribute name
    ADSTYPE   adsType;            // the ADSTYPE of the attribute
    PADSVALUE pADsValue;          // pointer to the ADSVALUE struct that holds the current values
    DWORD     dwNumValues;        // the number of values pointed to by pADsValue
    BOOL      bMultivalued;       // TRUE if the attribute is multivalued, FALSE if it is not.
    LPBINDINGFUNC lpfnBind;       // the callback function used to bind to Active Directory
    LPARAM    lParam;             // an optional property that is passed back to lpfnBind
} DS_ATTRIBUTE_EDITORINFO, * LPDS_ATTRIBUTE_EDITORINFO;
  
#undef  INTERFACE
#define INTERFACE   IDsAttributeEditorExt

interface __declspec(uuid("{A9948091-69FF-4c00-BE93-925D42E0AD39}")) IDsAttributeEditorExt : public IUnknown
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAttributeEditor methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ LPDS_ATTRIBUTE_EDITORINFO) PURE;
  STDMETHOD(GetNewValue)(THIS_ /*OUT*/ PADSVALUE* ppADsValue, 
                               /*OUT*/ DWORD*     dwNumValues) PURE;
  STDMETHOD(CreateModal)(THIS_ ) PURE;
};

#endif //__ATTRINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\pch.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1998
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "pch.h"

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\filterui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       filterui.cpp
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
// filterui.cpp

#include "pch.h"
#include <SnapBase.h>

#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>

#include "common.h"
#include "resource.h"
#include "filterui.h"
#include "editor.h"
#include "query.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MESSAGE_MAP(CADSIFilterDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_BN_CLICKED(IDC_EDIT_BUTTON, OnEditFilter)
	ON_BN_CLICKED(IDC_FILTER_RADIO, OnSelFilterRadio)
	ON_BN_CLICKED(IDC_SHOWALL_RADIO, OnSelShowAllRadio)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CADSIFilterDialog

BOOL CADSIFilterDialog::OnInitDialog()
{
	CButton* pShowAllButton	= (CButton*)GetDlgItem(IDC_SHOWALL_RADIO);
	CButton* pFilterButton		= (CButton*)GetDlgItem(IDC_FILTER_RADIO);
	CButton* pEditButton			= (CButton*)GetDlgItem(IDC_EDIT_BUTTON);
	CEdit* pMaxNumBox			= (CEdit*)GetDlgItem(IDC_MAX_NUMBER_BOX);

	m_pFilterObject = m_pConnectData->GetFilter();

  // disable IME support on numeric edit fields
  ImmAssociateContext(pMaxNumBox->GetSafeHwnd(), NULL);

	if (m_pFilterObject->InUse())
	{
		pFilterButton->SetCheck(TRUE);
		pEditButton->EnableWindow(TRUE);
	}
	else
	{
		pShowAllButton->SetCheck(TRUE);
		pEditButton->EnableWindow(FALSE);
	}
	m_pFilterObject->GetUserDefinedFilter(m_sUserFilter);
	m_pFilterObject->GetContainerList(&m_sContainerList);

	ULONG nMaxNum = m_pConnectData->GetMaxObjectCount();
	CString sMaxNum;
	ultow(nMaxNum, sMaxNum);
	pMaxNumBox->SetLimitText(ADSIEDIT_QUERY_OBJ_TEXT_COUNT_MAX);
	pMaxNumBox->SetWindowText(sMaxNum);

	return CDialog::OnInitDialog();
}

void CADSIFilterDialog::OnSelFilterRadio()
{
	CButton* pFilterButton		= (CButton*)GetDlgItem(IDC_FILTER_RADIO);
	CButton* pEditButton			= (CButton*)GetDlgItem(IDC_EDIT_BUTTON);

	if (pFilterButton->GetCheck())
	{
		pEditButton->EnableWindow(TRUE);
	}
}

void CADSIFilterDialog::OnSelShowAllRadio()
{
	CButton* pShowAllButton	= (CButton*)GetDlgItem(IDC_SHOWALL_RADIO);
	CButton* pEditButton			= (CButton*)GetDlgItem(IDC_EDIT_BUTTON);

	if (pShowAllButton->GetCheck())
	{
		pEditButton->EnableWindow(FALSE);
	}
}

void CADSIFilterDialog::OnEditFilter()
{
	CADSIFilterEditDialog editDialog(m_pConnectData,
																	 &m_sUserFilter, 
																	 &m_sContainerList);
	editDialog.DoModal();
}

void CADSIFilterDialog::OnOK()
{
	CButton* pShowAllButton	= (CButton*)GetDlgItem(IDC_SHOWALL_RADIO);
	CEdit* pMaxNumBox			= (CEdit*)GetDlgItem(IDC_MAX_NUMBER_BOX);

	m_pFilterObject->SetInUse(!pShowAllButton->GetCheck());
	m_pFilterObject->SetUserDefinedFilter(m_sUserFilter);
	m_pFilterObject->SetContainerList(&m_sContainerList);

	CString sMaxNum;
	pMaxNumBox->GetWindowText(sMaxNum);
	ULONG nMaxNum = _wtol((LPWSTR)(LPCWSTR)sMaxNum);

	if (nMaxNum >= ADSIEDIT_QUERY_OBJ_COUNT_MIN && nMaxNum <= ADSIEDIT_QUERY_OBJ_COUNT_MAX)
	{
		m_pConnectData->SetMaxObjectCount(nMaxNum);
	}
	else if (nMaxNum < ADSIEDIT_QUERY_OBJ_COUNT_MIN)
	{
		m_pConnectData->SetMaxObjectCount(ADSIEDIT_QUERY_OBJ_COUNT_MIN);
	}
	else
	{
		m_pConnectData->SetMaxObjectCount(ADSIEDIT_QUERY_OBJ_COUNT_MAX);
	}

	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////////
// CContainerCheckListBox

BOOL CContainerCheckListBox::Initialize(UINT nCtrlID, const CStringList& sContainerList, 
																				const CStringList& sFilterList, CWnd* pParentWnd)
{
	if (!SubclassDlgItem(nCtrlID, pParentWnd))
		return FALSE;
	SetCheckStyle(BS_AUTOCHECKBOX);

	POSITION pos = sContainerList.GetHeadPosition();
	while (pos != NULL)
	{
		CString sContainer = sContainerList.GetNext(pos);
		AddString((LPWSTR)(LPCWSTR)sContainer);
	}

	pos = sFilterList.GetHeadPosition();
	while (pos != NULL)
	{
		CString sFilter = sFilterList.GetNext(pos);
		int idx = FindStringExact(-1, sFilter);
		if (idx != LB_ERR)
		{
			SetCheck(idx, 1);
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// CADSIFilterEditDialog

BEGIN_MESSAGE_MAP(CADSIFilterEditDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
//	ON_CBN_EDITCHANGE(IDC_FILTER_BOX, OnEditChangeDSList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIFilterEditDialog::CADSIFilterEditDialog(CConnectionData* pConnectData, 
																						 CString* psFilter, 
																						 CStringList* psContList) 
																						: CDialog(IDD_EDIT_FILTER_DIALOG)
{ 
	m_pConnectData = pConnectData;
	m_pFilterObject = pConnectData->GetFilter();

	ASSERT(psFilter != NULL);
	m_psFilter = psFilter;

	ASSERT(psContList != NULL);
	m_psContList = psContList;
}

BOOL CADSIFilterEditDialog::OnInitDialog()
{
	CWaitCursor hourGlass;

	CStringList sContainerList;
	GetContainersFromSchema(sContainerList);

	VERIFY(m_ContainerBox.Initialize(IDC_CONTAINER_LIST, sContainerList, *m_psContList, this));
	CEdit* pFilterBox	= (CEdit*)GetDlgItem(IDC_FILTER_BOX);

	pFilterBox->SetWindowText(*m_psFilter);

	return CDialog::OnInitDialog();
}


void CADSIFilterEditDialog::GetContainersFromSchema(CStringList& sContainerList)
{
	CString sSchemaPath;
	HRESULT hr = m_pConnectData->GetSchemaPath(sSchemaPath);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return;
  }

	CADSIQueryObject schemaSearch;

	// Initialize search object with path, username and password
	//
	hr = schemaSearch.Init(sSchemaPath, m_pConnectData->GetCredentialObject());
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	int cCols = 2;
  LPWSTR pszAttributes[] = {L"possibleInferiors", L"lDAPDisplayName"};
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	BOOL bContainer = FALSE;

  CString csFilter = _T("(objectClass=classSchema)");
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  while (SUCCEEDED(hr))
  {
    hr = schemaSearch.GetNextRow();
    if (hr == S_ADS_NOMORE_ROWS)
		{
      break;
    }

		if (SUCCEEDED(hr)) 
		{
			CString sContainer, sInferiors;

			ADS_SEARCH_COLUMN ColumnData0, ColumnData1;
			hr = schemaSearch.GetColumn(pszAttributes[1], &ColumnData1);
			if (SUCCEEDED(hr))
			{
				TRACE(_T("\t\tlDAPDisplayName: %s\n"),
							ColumnData1.pADsValues->CaseIgnoreString);

				hr = schemaSearch.GetColumn(pszAttributes[0], &ColumnData0);
				if (SUCCEEDED(hr) && ColumnData0.dwNumValues > 0)
				{
					TRACE(_T("\t\tpossibleInferiors: %s\n"), 
							 ColumnData0.pADsValues->CaseIgnoreString);
					sContainerList.AddTail(ColumnData1.pADsValues->CaseIgnoreString);
				}
			}
			schemaSearch.FreeColumn(&ColumnData1);
			schemaSearch.FreeColumn(&ColumnData0);
		}
	}
}


void CADSIFilterEditDialog::OnOK()
{
	CEdit* pFilterBox	= (CEdit*)GetDlgItem(IDC_FILTER_BOX);

	CString sUserFilter;
	pFilterBox->GetWindowText(sUserFilter);
	*m_psFilter = sUserFilter;

	CString sContainer;

	m_psContList->RemoveAll();

	int iCount = m_ContainerBox.GetCount();
	for (int idx = 0; idx < iCount; idx++)
	{
		if (m_ContainerBox.GetCheck(idx) == 1)
		{
			m_ContainerBox.GetText(idx, sContainer);
			m_psContList->AddTail(sContainer);
		}
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\pch.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// pch.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//#define _DEBUG_REFCOUNT
// #define _ATL_DEBUG_QI
//#define DEBUG_ALLOCATOR 

// C++ RTTI
#include <typeinfo.h>
#define IS_CLASS(x,y) (typeid(x) == typeid(y))

// MFC Headers

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <imagehlp.h>
//#include <stdio.h>
//#include <stdlib.h>
}

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxcmn.h>
#include <afxtempl.h> 
#include <prsht.h>  

///////////////////////////////////////////////////////////////////
// miscellanea heades
#include <winsock.h>
#include <aclui.h>

///////////////////////////////////////////////////////////////////
// DNS headers
// DNSRPC.H: nonstandard extension used : zero-sized array in struct/union
//#pragma warning( disable : 4200) // disable zero-sized array


///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_MTFRMWK_TRACE
    #define _USE_MTFRMWK_ASSERT
    #define _MTFRMWK_INI_FILE (L"\\system32\\adsiedit.ini")
  #endif
#endif

#include <dbg.h> // from framework


///////////////////////////////////////////////////////////////////
// ATL Headers
#include <atlbase.h>


///////////////////////////////////////////////////////////////////
// CADSIEditModule
class CADSIEditModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID() \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister); \
}


extern CADSIEditModule _Module;


#include <atlcom.h>
#include <atlwin.h>


///////////////////////////////////////////////////////////////////
// Console Headers
#include <mmc.h>
#include <activeds.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

#ifndef _ADSIQUERY_H
#define _ADSIQUERY_H

#define QUERY_PAGESIZE 256

class CConnectionData;
class CCredentialObject;

////////////////////////////////////////////////////////////////////////
// CADSIQueryObject

class CADSIQueryObject
{
public:
  CADSIQueryObject();
  ~CADSIQueryObject();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(CString csObjectPath, CCredentialObject* pCredentialObject);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
	{
    return m_pObj->FreeColumn(pColumnData);
  };

  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);
  HRESULT SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount = 0);
  HRESULT SetFilterString (LPWSTR pszFilter)
	{
    m_pwszFilter = pszFilter;
    return S_OK;
  }

  //Attributes
public:
  CComPtr<IDirectorySearch> m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR            m_pwszFilter;
  LPWSTR          * m_pszAttribs;
  ULONG             m_nAttrs;
  BOOL							m_bInitialized;

	ADS_SEARCHPREF_INFO* aSearchPref;
};
        
#endif //_ADSIQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\query.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "query.h"
#include "editor.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

	///////////////////////////////////////////////////////////////////////////////
CADSIQueryObject::CADSIQueryObject()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
  aSearchPref = NULL;
}

CADSIQueryObject::~CADSIQueryObject()
{
  if (m_SearchHandle) 
  {
    m_pObj->CloseSearchHandle (m_SearchHandle);
  }
  if (aSearchPref != NULL)
  {
    delete aSearchPref;
    aSearchPref = NULL;
  }
}


HRESULT CADSIQueryObject::Init(IDirectorySearch * pObj)
{
  HRESULT hr = S_OK;
  
  m_pObj = pObj;
  m_bInitialized = TRUE;
  
  return hr;
}

HRESULT CADSIQueryObject::Init(CString ObjPath, CCredentialObject* pCredObject)
{
  HRESULT hr, hCredResult;

	hr = OpenObjectWithCredentials(
																 pCredObject, 
																 (LPWSTR)(LPCWSTR)ObjPath,
																 IID_IDirectorySearch, 
																 (LPVOID*) &m_pObj
																 );
  if (SUCCEEDED(hr)) 
	{
    m_bInitialized = TRUE;
  } 
	else 
	{
    m_bInitialized = FALSE;
    m_pObj = NULL;
  }
  return hr;
}

HRESULT CADSIQueryObject::SetAttributeList (LPTSTR *pszAttribs, INT cAttrs)
{

  m_pszAttribs = pszAttribs;
  m_nAttrs = cAttrs;
  return S_OK;
}

const int nSearchPrefs = 4;
HRESULT CADSIQueryObject::SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount)
{
  HRESULT hr;
	int nNumPrefs = nSearchPrefs;
	if (nMaxObjectCount == 0)
	{
		nNumPrefs--;
	}
  aSearchPref = new ADS_SEARCHPREF_INFO[nNumPrefs];

  if (m_bInitialized) 
	{
    aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[0].vValue.Integer = scope;
    aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    aSearchPref[1].vValue.dwType = ADSTYPE_BOOLEAN;
    aSearchPref[1].vValue.Boolean = TRUE;
    aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    aSearchPref[2].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[2].vValue.Integer = QUERY_PAGESIZE;
		
		if (nMaxObjectCount > 0)
		{
			aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
			aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
			aSearchPref[3].vValue.Integer = nMaxObjectCount;
		}
		hr = m_pObj->SetSearchPreference (aSearchPref, nNumPrefs);
    delete aSearchPref;
    aSearchPref = NULL;
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}


const int NUM_PREFS=3;
HRESULT CADSIQueryObject::DoQuery()
{
  HRESULT hr;
  if (m_bInitialized) 
	{
     hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                 m_pszAttribs,
                                 m_nAttrs,
                                 &m_SearchHandle);
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}

HRESULT CADSIQueryObject::GetNextRow()
{
  if (m_bInitialized) 
	{
    return m_pObj->GetNextRow (m_SearchHandle);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT CADSIQueryObject::GetColumn(LPWSTR Attribute, PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) 
	{
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\querynode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       querynode.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "connection.h"
#include "querynode.h"
#include "queryui.h"
#include "editor.h"
#include <aclpage.h>


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////
// CADSIEditQueryData

void CADSIEditQueryData::SetRootPath(LPCWSTR lpszRootPath)
{
	m_sRootPath = lpszRootPath;

	GetDisplayPath(m_sDN);
}

void CADSIEditQueryData::GetDisplayPath(CString& sDisplayPath)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	hr = pIADsPathname->Set((LPWSTR)(LPCWSTR)m_sRootPath, ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
		TRACE(_T("Set failed. %s"), hr);
	}

	// Get the leaf name
	CString sDN;
	BSTR bstrPath = NULL;
	hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDisplayPath = L"";
	}
	else
	{
		sDisplayPath = bstrPath;
	}
}

void CADSIEditQueryData::GetDisplayName(CString& sDisplayName)
{
	CString sDisplayPath;
	GetDisplayPath(sDisplayPath);
	
	sDisplayName = m_sName + _T(" [") + sDisplayPath + _T("]");
}

////////////////////////////////////////////////////////////////////////
// CADSIEditQueryNode
//

// {072B64B7-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditQueryNode::NodeTypeGUID = 
{ 0x72b64b7, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };


CADSIEditQueryNode::CADSIEditQueryNode(CADsObject* pADsObject,
													CADSIEditQueryData* pQueryData)
{	
	m_pADsObject = pADsObject;
	m_pQueryData = pQueryData;
	m_nState = notLoaded; 
	m_sType.LoadString(IDS_QUERY_STRING);
}

HRESULT CADSIEditQueryNode::OnCommand(long nCommandID, 
												  DATA_OBJECT_TYPES type, 
												  CComponentDataObject* pComponentData,
                          CNodeList* pNodeList)
{
  ASSERT (pNodeList->GetCount() == 1); // not allowing multiple selection on any of these yet

	switch (nCommandID)
	{
	case IDM_SETTINGS_QUERY :
		{
			OnSettings(pComponentData);
			break;
		}
	case IDM_REMOVE_QUERY :
		{
			OnRemove(pComponentData);
			break;
		}
  default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
  return S_OK;
}

BOOL CADSIEditQueryNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                              BOOL* pbHideVerb, 
                                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
	  *pbHideVerb = TRUE; // always hide the verb
	  return FALSE;
  }

  //
  // Multiple selection
  //
  *pbHideVerb = FALSE;
  return TRUE;
}

void CADSIEditQueryNode::OnRemove(CComponentDataObject* pComponentData)
{
	if (ADSIEditMessageBox(IDS_MSG_REMOVE_QUERY, MB_OKCANCEL) == IDOK)
	{
		BOOL bLocked = IsThreadLocked();
		ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
		if (bLocked)
			return; 
		if (IsSheetLocked())
		{
			if (!CanCloseSheets())
				return;
		// Do deletion stuff
			pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
		}
		ASSERT(!IsSheetLocked());

		// Remove query data from connection node's list
		GetADsObject()->GetConnectionNode()->RemoveQueryFromList(GetQueryData());

		// now remove from the UI
		DeleteHelper(pComponentData);
    pComponentData->SetDescriptionBarText(GetContainer());
		delete this; // gone
	}
}

void CADSIEditQueryNode::OnSettings(CComponentDataObject* pComponentData)
{
	// Get the data from the existing query node data
	BOOL bOneLevel;
	bOneLevel = (GetQueryData()->GetScope() == ADS_SCOPE_ONELEVEL);
	CString sFilter, sName, sPath, sConnectPath;
	GetQueryData()->GetName(sName);
	GetQueryData()->GetFilter(sFilter);
	GetQueryData()->GetRootPath(sPath);

	GetADsObject()->GetConnectionNode()->GetADsObject()->GetPath(sConnectPath);

	CCredentialObject* pCredObject = 
		GetADsObject()->GetConnectionNode()->GetConnectionData()->GetCredentialObject();

	// Initialize dialog with data
	CADSIEditQueryDialog queryDialog(sName, sFilter, sPath, sConnectPath, bOneLevel, pCredObject);

	if (queryDialog.DoModal() == IDOK)
	{
		// If OK
		CString sNewPath;
		queryDialog.GetResults(sName, sFilter, sNewPath, &bOneLevel);
		GetQueryData()->SetName(sName);
		GetQueryData()->SetFilter(sFilter);
		GetQueryData()->SetRootPath(sNewPath);
		GetADsObject()->SetPath(sNewPath);
		ADS_SCOPEENUM scope = (bOneLevel) ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE;
		GetQueryData()->SetScope(scope);

		// Make changes take effect
		CString sDisplayName;
		GetQueryData()->GetDisplayName(sDisplayName);
		SetDisplayName(sDisplayName);

    CNodeList nodeList;
    nodeList.AddTail(this);
		OnRefresh(pComponentData, &nodeList);
	}
}

LPCWSTR CADSIEditQueryNode::GetString(int nCol) 
{ 
	switch(nCol)
	{
		case N_HEADER_NAME :
			return GetDisplayName();
		case N_HEADER_TYPE :
			return m_sType;
		case N_HEADER_DN :
			return m_pQueryData->GetDNString();
		default :
			return NULL;
	}
}

BOOL CADSIEditQueryNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                          BOOL* pbHideVerb, 
                                          CNodeList* pNodeList)
{
  *pbHideVerb = TRUE; // always hide the verb
  return FALSE;
}


BOOL CADSIEditQueryNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
													             long *pInsertionAllowed)
{

	if (pContextMenuItem->lCommandID == IDM_SETTINGS_QUERY)
	{
		return TRUE;
	}
	else if (pContextMenuItem->lCommandID == IDM_REMOVE_QUERY)
	{
		return TRUE;
	}
	return FALSE;
}

CQueryObj* CADSIEditQueryNode::OnCreateQuery()
{
	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	CADSIEditRootData* pRootData = static_cast<CADSIEditRootData*>(GetRootContainer());
	CComponentDataObject* pComponentData = pRootData->GetComponentDataObject();
	RemoveAllChildrenHelper(pComponentData);

	CString sPath;
	GetADsObject()->GetPath(sPath);

	CString sFilter;
	GetQueryData()->GetFilter(sFilter);
	ADS_SCOPEENUM scope;
	scope = GetQueryData()->GetScope();

	CADSIEditQueryObject* pQuery = new CADSIEditQueryObject(sPath, sFilter, scope,
																				  pConnectData->GetMaxObjectCount(),
																				  pConnectData->GetCredentialObject(),
                                          pConnectData->IsGC(),
																				  pConnectData->GetConnectionNode());
	return pQuery;
}

BOOL CADSIEditQueryNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                               BOOL* pbHide, 
                                               CNodeList* pNodeList)
{
	*pbHide = FALSE;

	if (m_nState == loading)
	{
		return FALSE;
	}

	return !IsThreadLocked();
}

void CADSIEditQueryNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
	switch (m_nState)
	{
	case notLoaded:
	case loaded:
	case unableToLoad:
	case accessDenied:
	{
		m_nState = loading;
		m_dwErr = 0;
	}
	break;
	case loading:
	{
		if (m_dwErr == 0)
			m_nState = loaded;
		else if (m_dwErr == ERROR_ACCESS_DENIED)
			m_nState = accessDenied;
		else 
			m_nState = unableToLoad;
	}
	break;
	default:
		ASSERT(FALSE);
	}
	VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
	VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
}

int CADSIEditQueryNode::GetImageIndex(BOOL bOpenImage) 
{
	int nIndex = 0;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = ZONE_IMAGE_1;
		break;
	case loading:
		nIndex = ZONE_IMAGE_LOADING_1;
		break;
	case loaded:
		nIndex = ZONE_IMAGE_1;
		break;
	case unableToLoad:
		nIndex = ZONE_IMAGE_UNABLE_TO_LOAD_1;
		break;
	case accessDenied:
		nIndex = ZONE_IMAGE_ACCESS_DENIED_1;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}


BOOL CADSIEditQueryNode::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
	//return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}

void CADSIEditQueryNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	CTreeNode* p = dynamic_cast<CTreeNode*>(pObj);
	ASSERT(p != NULL);
	if (p != NULL)
	{
		AddChildToListAndUI(p, pComponentDataObject);
    pComponentDataObject->SetDescriptionBarText(this);
	}
}


void CADSIEditQueryNode::OnError(DWORD dwerr) 
{
	if (dwerr == ERROR_TOO_MANY_NODES)
	{
	  // need to pop message
	 AFX_MANAGE_STATE(AfxGetStaticModuleState());
	 CString szFmt;
	 szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
	 CString szMsg;
	 szMsg.Format(szFmt, GetDisplayName()); 
	 AfxMessageBox(szMsg);
	}
	else
	{
		ADSIEditErrorMessage(dwerr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\renameui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       renameui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "renameui.h"
#include "editor.h"
#include "connection.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MESSAGE_MAP(CADSIEditRenameDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
//	ON_CBN_EDITCHANGE(IDC_NEW_NAME_BOX, OnEditChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIEditRenameDialog::CADSIEditRenameDialog(CTreeNode* pCurrentNode, 
                                             CADsObject* pADsObject,
																						 CString sPath,
                                             LPWSTR lpszNewName) 
				: CDialog(IDD_RENAME_PAGE)
{
	m_pCurrentNode = pCurrentNode;
	m_pADsObject = pADsObject;
	m_sCurrentPath = sPath;
  m_sNewName = lpszNewName;
}

CADSIEditRenameDialog::~CADSIEditRenameDialog()
{
}


BOOL CADSIEditRenameDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CEdit* pNameBox = (CEdit*)GetDlgItem(IDC_NEW_NAME_BOX);
  pNameBox->SetWindowText(m_sNewName);
	
	return TRUE;
}


void CADSIEditRenameDialog::OnOK()
{
	CEdit* pNameBox = (CEdit*)GetDlgItem(IDC_NEW_NAME_BOX);

	CString sOldPath, sNewPath;
	sOldPath = m_sCurrentPath;

	CString sNewName, sFullName;
	pNameBox->GetWindowText(sNewName);
	sFullName = m_sPrefix + sNewName;

	CComPtr<IADsContainer> pDestination;
	CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(m_pCurrentNode->GetContainer());
	ASSERT(pContNode != NULL);

	// Get the username and password from the connection node
	//
	CADSIEditConnectionNode* pConnectionNode = pContNode->GetADsObject()->GetConnectionNode();
	CConnectionData* pConnectData = pConnectionNode->GetConnectionData();

	HRESULT hr, hCredResult;
	CComPtr<IADs> pParentIADs;
	hr = OpenObjectWithCredentials(
											 pConnectData,
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)m_sCurrentPath,
											 IID_IADs, 
											 (LPVOID*) &pParentIADs,
											 GetSafeHwnd(),
											 hCredResult
											 );
	if (FAILED(hr))
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

	CComBSTR bstrParentPath;
	hr = pParentIADs->get_Parent(&bstrParentPath);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CString sContPath(bstrParentPath);
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 (LPWSTR)(LPCWSTR)sContPath,
											 IID_IADsContainer, 
											 (LPVOID*) &pDestination,
											 GetSafeHwnd(),
											 hCredResult
											 );
	if (FAILED(hr)) 
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

	CString sEscapedName;
	hr = EscapePath(sEscapedName, sFullName);

	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}


	IDispatch* pObject;
	hr = pDestination->MoveHere((LPWSTR)(LPCWSTR)sOldPath,
                                (LPWSTR)(LPCWSTR)sEscapedName,
                                &pObject);
  if (FAILED(hr)) 
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CComPtr<IADs> pIADs;
	hr = pObject->QueryInterface(IID_IADs, (LPVOID*)&pIADs);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CComBSTR bstrPath;
	hr = pIADs->get_ADsPath(&bstrPath);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CString szDN, szPath;
	szPath = bstrPath;
	CrackPath(szPath, szDN);
	m_pADsObject->SetPath(bstrPath);
	m_pADsObject->SetName(sFullName + m_sPostfix);
	m_pADsObject->SetDN(szDN);

	m_pCurrentNode->SetDisplayName(sFullName);

	CDialog::OnOK();
	return;
}

HRESULT CADSIEditRenameDialog::EscapePath(CString& sEscapedName, const CString& sName)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	CComBSTR bstrEscaped;
	hr = pIADsPathname->GetEscapedElement(0, //reserved
														(BSTR)(LPCWSTR)sName,
														&bstrEscaped);
	sEscapedName = bstrEscaped;
	return hr;
}

void CADSIEditRenameDialog::CrackPath(const CString& szPath, CString& sDN)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	hr = pIADsPathname->Set((LPWSTR)(LPCWSTR)szPath, ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
		TRACE(_T("Set failed. %s"), hr);
	}

	// Get the leaf DN
	CComBSTR bstrDN;
	hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDN = L"";
	}
	else
	{
		sDN = bstrDN;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\querynode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       querynode.h
//
//--------------------------------------------------------------------------

#ifndef _QUERYNODE_H
#define _QUERYNODE_H

#include "editor.h"
//#include "connection.h"
//#include "resource.h"
//#include "snapdata.h"

//////////////////////////////////////////////////////////////////////////////////
// CADSIEditQueryData :

class CADSIEditQueryData
{
public :
	CADSIEditQueryData() {} 
	~CADSIEditQueryData() {}


	void SetName(LPCWSTR lpszName) { m_sName = lpszName; }
	void GetName(CString& sName) { sName = m_sName; }
	void SetDN(LPCWSTR lpszDN) { m_sDN = lpszDN; }
	void GetDN(CString& szDN) { szDN = m_sDN; }
  PCWSTR GetDNString() { return m_sDN; }
	void SetFilter(LPCWSTR lpszFilter) { m_sFilter = lpszFilter; }
	void GetFilter(CString& sFilter) { sFilter = m_sFilter; }
	void SetRootPath(LPCWSTR lpszRootPath);
	void GetRootPath(CString& sRootPath) { sRootPath = m_sRootPath; }
	void SetScope(ADS_SCOPEENUM scope) { m_scope = scope; }
	ADS_SCOPEENUM GetScope() { return m_scope; }

	void GetDisplayPath(CString& sDisplayPath);
	void GetDisplayName(CString& sDisplayName);

private :
	CString m_sName;
	CString m_sDN;
	CString m_sFilter;
	CString m_sRootPath;
	ADS_SCOPEENUM m_scope;
};

//////////////////////////////////////////////////////////////////////////////////
// CADSIEditQueryNode :

class CADSIEditQueryNode : public CADSIEditContainerNode
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;


public:
	CADSIEditQueryNode() : m_pQueryData(NULL)
	{
		m_sType.LoadString(IDS_QUERY_STRING);
	}

	CADSIEditQueryNode(CADsObject* pADsObject, CADSIEditQueryData* pQueryData);

	~CADSIEditQueryNode()
	{
	}

	// node info
	DECLARE_NODE_GUID()

	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
							               long *pInsertionAllowed);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList) { ASSERT(FALSE); }
	virtual CQueryObj* OnCreateQuery();
	virtual LPCWSTR GetString(int nCol);

	void OnSettings(CComponentDataObject* pComponentData);
	void OnRemove(CComponentDataObject* pComponentData);

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);
	virtual int GetImageIndex(BOOL bOpenImage);

	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);


	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
		{ return CADSIEditQueryMenuHolder::GetContextMenuItem(); }

	virtual CBackgroundThread* CreateThreadObject() 
	{ 
		return new CADSIEditBackgroundThread(); // override if need derived type of object
	} 

	virtual BOOL CanCloseSheets();
	virtual void OnChangeState(CComponentDataObject* pComponentDataObject);
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);
  virtual void OnError(DWORD dwErr);

  void SetQueryData(CADSIEditQueryData* pQueryData) { m_pQueryData = pQueryData; }
  CADSIEditQueryData* GetQueryData() { return m_pQueryData; }

  //
  // Allow multiple selection
  //
  virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    return S_FALSE;
  }

private:
	CADSIEditQueryData* m_pQueryData;
	CString m_sType;
};


#endif _QUERYNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adsiedit.rc
//
#define IDS_SNAPIN_VERSION              1
#define IDS_SNAPIN_PROVIDER             10
#define IDS_SNAPIN_NAME                 11
#define IDS_SNAPINABOUT_DESCRIPTION     12
#define IDS_MOVE_TITLE                  34
#define IDS_HEADER_NCNAME               99
#define IDS_HEADER_NAME                 100
#define IDS_HEADER_TYPE                 101
#define IDS_HEADER_DATA                 102
#define IDB_16x16                       102
#define IDS_HEADER_DN                   102
#define IDS_PROP_CONTAINER_TITLE        103
#define IDB_32x32                       104
#define IDS_CONNECT_TO                  104
#define IDI_ADSIEDIT_SNAPIN             105
#define IDS_REMOVE_CONNECTION           105
#define IDD_ADSIEDIT_PAGE               106
#define IDS_RENAME                      106
#define IDD_OPTIONAL_PROP               107
#define IDS_DELETE                      107
#define IDD_CREATE_CLASS_PAGE           107
#define IDD_CONNECTION_DIALOG           108
#define IDS_MOVE                        108
#define IDS_CREATE                      109
#define IDD_CONNECTION_PROPPAGE         109
#define IDD_CONNECTION_ADVANCED         110
#define IDS_SETTINGS_CONNECTION         110
#define IDD_PROPERTY_PAGE               111
#define IDS_FILTER                      111
#define IDD_DIALOG1                     112
#define IDD_CREATE_EMPTY_PAGE           112
#define IDS_NEW_OBJECT                  112
#define IDD_CREATE_LAST_PAGE            113
#define IDS_CONNECTION_TITLE            113
#define IDD_RENAME_PAGE                 114
#define IDS_NOT_SET                     114
#define IDS_MY_CONNECTION               115
#define IDS_DOMAIN_NC                   116
#define IDS_SCHEMA                      117
#define IDS_CONFIG_CONTAINER            118
#define IDD_FILTER_DIALOG               119
#define IDS_ROOTDSE                     119
#define IDS_REMOVE_QUERY                120
#define IDD_EDIT_FILTER_DIALOG          121
#define IDS_SETTINGS_QUERY              121
#define IDD_CREDENTIAL_DIALOG           122
#define IDS_NEW_QUERY                   122
#define IDS_QUERY_STRING                123
#define IDS_UPDATE_SCHEMA               124
#define IDS_NEW_CONNECT_FROM_HERE       125
#define IDS_NEW_CONNECT_TO_NC_FROM_HERE 126
#define IDD_QUERY_DIALOG                127
#define IDB_ABOUT_16x16                 129
#define IDB_ABOUT_32x32                 130
#define IDS_MOVE_TARGET                 249
#define IDS_MANDATORY                   250
#define IDS_OPTIONAL                    251
#define IDS_BOTH                        252
#define IDS_BUTTON_TEXT_ADD             253
#define IDS_BUTTON_TEXT_SET             254
#define IDS_BUTTON_TEXT_REMOVE          255
#define IDS_BUTTON_TEXT_CLEAR           256
#define IDS_MESSAGE_VIEW_NO_CONNECTIONS_TITLE 500
#define IDS_MESSAGE_VIEW_NO_CONNECTIONS_MESSAGE 501
#define IDS_SYNTAX_DN                   600
#define IDS_SYNTAX_OID                  601
#define IDS_SYNTAX_NOCASE_STR           602
#define IDS_SYNTAX_PRCS_STR             603
#define IDS_SYNTAX_I5_STR               604
#define IDS_SYNTAX_NUMSTR               605
#define IDS_SYNTAX_DN_BINARY            606
#define IDS_SYNTAX_BOOLEAN              607
#define IDS_SYNTAX_INTEGER              608
#define IDS_SYNTAX_OCTET                609
#define IDS_SYNTAX_UTC                  610
#define IDS_SYNTAX_UNICODE              611
#define IDS_SYNTAX_ADDRESS              612
#define IDS_SYNTAX_DNSTRING             613
#define IDS_SYNTAX_SEC_DESC             614
#define IDS_SYNTAX_LINT                 615
#define IDS_SYNTAX_SID                  616
#define IDS_SYNTAX_UNKNOWN              617
#define IDC_VALUEBOX                    1001
#define IDC_PROPBOX                     1003
#define IDC_OPT_VALUEBOX                1005
#define IDC_OPT_PROPBOX                 1006
#define IDC_ADSPATH_OPT                 1010
#define IDC_ADSPATH_MAND                1011
#define IDC_LDAPPATH_BOX                1012
#define IDC_SERVERPATH_BOX              1013
#define IDC_LDAP_PATH_BOX               1014
#define IDC_NAMING_CONTEXT_BOX          1015
#define IDC_SERVER_BOX                  1016
#define IDC_FULLPATH_BOX                1017
#define IDC_DN_RADIO                    1018
#define IDC_NC_RADIO                    1019
#define IDC_DN_BOX                      1020
#define IDC_NC_BOX                      1021
#define IDC_DOMAIN_SERVER_RADIO         1022
#define IDC_DEFAULT_RADIO               1024
#define IDC_DOMAIN_SERVER_BOX           1025
#define IDC_CONNECTION_NAME             1027
#define IDC_ADVANCED_BUTTON             1028
#define IDC_USERNAME                    1029
#define IDC_PASSWORD                    1030
#define IDC_CREDENTIALS                 1031
#define IDC_CREDENTIALS_CHECK           1031
#define IDC_PORT                        1032
#define IDC_LDAP_RADIO                  1033
#define IDC_GC_RADIO                    1034
#define IDC_PROPTYPES_BOX               1037
#define IDC_PROP_BOX                    1038
#define IDC_EDITVALUE_BOX               1039
#define IDC_VALUE_LISTBOX               1040
#define IDC_VALUE_EDITBOX               1041
#define IDC_ADD_BUTTON                  1042
#define IDC_REMOVE_BUTTON               1043
#define IDC_PATH_BOX                    1046
#define IDC_SYNTAX_BOX                  1047
#define IDC_CLASS_LIST                  1048
#define IDC_ATTR_BOX                    1049
#define IDC_ATTR_VALUE_BOX              1050
#define IDC_NUMBER_VALUE_BOX            1052
#define IDC_NEW_NAME_BOX                1056
#define IDC_CREDENTIALS_GROUP           1057
#define IDC_CREDENTIALS_USER            1058
#define IDC_CREDENTIALS_PASSWORD        1059
#define IDC_CLASS_BOX                   1062
#define IDC_SHOWALL_RADIO               1063
#define IDC_FILTER_RADIO                1064
#define IDC_FILTER_BOX                  1065
#define IDC_MAX_NUMBER_BOX              1066
#define IDC_EDIT_BUTTON                 1072
#define IDC_SHOW_FILTER_BOX             1074
#define IDC_NAME_BOX                    1075
#define IDC_EDIT_FILTER_BOX             1076
#define IDC_CONTAINER_LIST              1085
#define IDC_CONNECTION_STATIC           1088
#define IDC_NO_INFO                     1090
#define IDC_PATH_LABEL                  1091
#define IDC_CLASS_LABEL                 1092
#define IDC_FILTER_LABEL                1093
#define IDC_PROPERTY_LABEL              1094
#define IDC_ATTR_GROUP                  1095
#define IDC_SYNTAX_LABEL                1096
#define IDC_EDIT_LABEL                  1097
#define IDC_VALUE_LABEL                 1098
#define IDC_EDIT_QUERY_STRING           1099
#define IDC_RADIO_ONELEVEL              1101
#define IDC_RADIO_SUBTREE               1102
#define IDC_EDIT_QUERY_NAME             1103
#define IDC_EDIT_ROOT_PATH              1105
#define IDC_BUTTON_BROWSE_CONTAINER     1106
#define IDC_BUTTON_EDIT_QUERY           1107
#define IDC_BUTTON_MORE                 1108
#define IDS_PROJNAME                    5000
#define IDD_ATTRIBUTE_EDITOR_DIALOG     5001
#define IDS_NOTSET                      5001
#define IDC_MANDATORY_CHECK             5002
#define IDD_STRING_EDITOR_DIALOG        5002
#define IDS_NO_EDITOR                   5002
#define IDC_OPTIONAL_CHECK              5003
#define IDD_STRING_EDITOR_MULTI_DIALOG  5003
#define IDS_NO_ATTRIBUTE_INFO           5003
#define IDC_SET_CHECK                   5004
#define IDC_ATTRIBUTE_LIST              5006
#define IDC_VALUE_EDIT                  5008
#define IDC_VALUE_LIST                  5010
#define IDC_CLEAR_BUTTON                5014
#define IDD_INT_EDITOR_DIALOG           5020
#define IDD_LARGEINT_EDITOR_DIALOG      5021
#define IDD_BOOLEAN_EDITOR_DIALOG       5022
#define IDD_TIME_EDITOR_DIALOG          5023
#define IDD_OCTET_STRING_EDITOR_DIALOG  5024
#define IDC_ATTRIBUTE_STATIC            6000
#define IDS_ATTR_COL_ATTRIBUTE          6000
#define IDS_ATTR_COL_SETNOTSET          6001
#define IDC_TRUE_RADIO                  6002
#define IDS_ATTR_COL_VALUE              6002
#define IDC_FALSE_RADIO                 6003
#define IDS_ATTR_SET                    6003
#define IDC_NOTSET_RADIO                6004
#define IDS_ATTR_NOTSET                 6004
#define IDC_DATE_PICKER                 6005
#define IDC_TIME_PICKER                 6006
#define IDC_EDIT2                       6008
#define IDC_VIEW_TYPE_COMBO             6010
#define IDS_HEXADECIMAL                 6050
#define IDS_DECIMAL                     6051
#define IDS_BINARY                      6052
#define IDS_WCHAR                       6053
#define IDS_CHAR                        6054
#define IDS_OCTAL                       6055
#define IDC_ATTR_EDIT_BUTTON            10015
#define IDC_ATTR_ADD_BUTTON             10016
#define IDC_ATTR_REMOVE_BUTTON          10017
#define IDC_PROCESS_EDIT                10018
#define IDD_OCTET_STRING_EDITOR_MULTI_DIALOG 10025
#define IDS_FORMAT_OCTAL_ERROR          11056
#define IDS_FORMAT_HEX_ERROR            11057
#define IDS_FORMAT_DECIMAL_ERROR        11058
#define IDS_FORMAT_BINARY_ERROR         11059
#define IDS_MSG_FAIL_CREATE_TEMPFILE    11100
#define IDS_MSG_FAIL_LAUNCH_PROCESS     11101
#define IDS_MSG_FAIL_RETRIEVE_SAVED_DATA 11102
#define IDS_OCTET_DISPLAY_SIZE_EXCEEDED 11103
#define IDS_MSG_FAIL_LOAD_VALUES        11104
#define IDS_ATTREDIT_DUPLICATE_VALUE    11105
#define IDS_ATTREDITOR_CAPTION          11106
#define IDS_MSG_CONT_CLOSE_SHEET        42980
#define IDS_MSG_RECORD_CLOSE_SHEET      42981
#define IDS_MSG_QUERY_TOO_MANY_ITEMS    42982
#define IDS_MSG_INCORRECT_FORMAT        42983
#define IDS_MSG_CONNECTION_NAME         42984
#define IDS_MSG_ROOTDSE_ERROR           42985
#define IDS_MSG_DELETE_OBJECT           42986
#define IDS_MSG_DELETE_CONTAINER        42987
#define IDS_MSG_FAIL_TO_LOAD            42988
#define IDS_MSG_NOT_X500_PATH           42989
#define IDS_MSG_REMOVE_CONNECTION       42990
#define IDS_MSG_INCORRECT_FORMAT_OCTET  42991
#define IDS_MSG_INCORRECT_FORMAT_DN     42992
#define IDS_MSG_INCORRECT_FORMAT_BOOLEAN 42994
#define IDS_MSG_INCORRECT_FORMAT_TIME   42995
#define IDS_MSG_REMOVE_QUERY            42996
#define IDS_MSG_EXISTING_QUERIES        42997
#define IDS_SCHEMA_UPDATE_SUCCESSFUL    42998
#define IDS_QUERY_BROWSE_TITLE          42999
#define IDS_EDIT_OBJECT                 43000
#define IDS_MSG_RECORD_SHEET_LOCKED     43001
#define IDS_ERRMSG_FAILED_CONNECTION    43002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1109
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\queryui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       queryui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>
#include <shlobj.h>
#include <dsclient.h> // Browse for container dialog

#include <cmnquery.h> // IPersistQuery
#include <dsquery.h> // DSFind dialog

#include "resource.h"
#include "editor.h"
#include "queryui.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MESSAGE_MAP(CADSIEditQueryDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_EN_CHANGE(IDC_EDIT_QUERY_STRING, OnEditQueryString)
	ON_EN_CHANGE(IDC_EDIT_QUERY_NAME, OnEditNameString)
	ON_BN_CLICKED(IDC_RADIO_ONELEVEL, OnOneLevel)
	ON_BN_CLICKED(IDC_RADIO_SUBTREE, OnSubtree)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE_CONTAINER, OnBrowse)
	ON_BN_CLICKED(IDC_BUTTON_EDIT_QUERY, OnEditQuery)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIEditQueryDialog::CADSIEditQueryDialog(CString& sName, 
														 CString& sFilter, 
														 CString& sPath,
														 CString& sConnectPath,
														 BOOL bOneLevel,
														 CCredentialObject* pCredObject)
				: CDialog(IDD_QUERY_DIALOG)

{
	m_bOneLevel = bOneLevel;
	m_sFilter = sFilter;
	m_sName = sName;
	m_sRootPath = sPath;
	m_sConnectPath = sConnectPath;

	m_pCredObject = pCredObject;
}

CADSIEditQueryDialog::CADSIEditQueryDialog(CString& sConnectPath, CCredentialObject* pCredObject)
				: CDialog(IDD_QUERY_DIALOG)
{
	m_bOneLevel = FALSE;
	m_sConnectPath = sConnectPath;

	m_pCredObject = pCredObject;
}

CADSIEditQueryDialog::~CADSIEditQueryDialog()
{
}


BOOL CADSIEditQueryDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CEdit* pEditName = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_NAME);
	CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
	CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);
	CButton* pOneLevelButton = (CButton*)GetDlgItem(IDC_RADIO_ONELEVEL);
	CButton* pSubtreeButton = (CButton*)GetDlgItem(IDC_RADIO_SUBTREE);
	CButton* pOkButton = (CButton*)GetDlgItem(IDOK);

	if (m_sRootPath != L"")
	{
		CString sDisplayPath;
		GetDisplayPath(sDisplayPath);
		pEditPath->SetWindowText(sDisplayPath);
	}

	pEditName->SetWindowText(m_sName);
	pEditName->SetLimitText(256);	// REVEIW_JEFFJON : Hardcoded length
	pEditQueryString->SetWindowText(m_sFilter);
	pEditQueryString->FmtLines(FALSE);
	pEditQueryString->SetLimitText(256); // REVIEW_JEFFJON : Hardcoded length
	if (pEditQueryString->GetWindowTextLength() > 0 && pEditName->GetWindowTextLength() > 0)
	{
		pOkButton->EnableWindow(TRUE);
	}
	else
	{
		pOkButton->EnableWindow(FALSE);
	}
	pOneLevelButton->SetCheck(m_bOneLevel);
	pSubtreeButton->SetCheck(!m_bOneLevel);
	
	return TRUE;
}

void CADSIEditQueryDialog::OnEditQueryString()
{
	CEdit* pEditName = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_NAME);
	CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
	CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);
	CButton* pOkButton = (CButton*)GetDlgItem(IDOK);

	if (pEditQueryString->GetWindowTextLength() > 0 && 
			pEditName->GetWindowTextLength() > 0 &&
			pEditPath->GetWindowTextLength() > 0)
	{
		pEditQueryString->GetWindowText(m_sFilter);
		pOkButton->EnableWindow(TRUE);
	}
	else
	{
		pEditQueryString->GetWindowText(m_sFilter);
		pOkButton->EnableWindow(FALSE);
	}
}

void CADSIEditQueryDialog::OnEditNameString()
{
	CEdit* pEditName = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_NAME);
	CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
	CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);
	CButton* pOkButton = (CButton*)GetDlgItem(IDOK);

	if (pEditQueryString->GetWindowTextLength() > 0 && 
			pEditName->GetWindowTextLength() > 0 &&
			pEditPath->GetWindowTextLength() > 0)
	{
		pEditName->GetWindowText(m_sName);
		pOkButton->EnableWindow(TRUE);
	}
	else
	{
		pEditName->GetWindowText(m_sName);
		pOkButton->EnableWindow(FALSE);
	}
}
		
void CADSIEditQueryDialog::OnOneLevel()
{
	CButton* pOneLevelButton = (CButton*)GetDlgItem(IDC_RADIO_ONELEVEL);

	m_bOneLevel = pOneLevelButton->GetCheck();
}

void CADSIEditQueryDialog::OnSubtree()
{
	CButton* pOneLevelButton = (CButton*)GetDlgItem(IDC_RADIO_ONELEVEL);

	m_bOneLevel = pOneLevelButton->GetCheck();
}

void CADSIEditQueryDialog::OnBrowse()
{
	HRESULT hr = S_OK, hCredResult;
	DWORD result;
	CString strTitle;
	strTitle.LoadString (IDS_QUERY_BROWSE_TITLE);

	DSBROWSEINFO dsbi;
	::ZeroMemory( &dsbi, sizeof(dsbi) );

	TCHAR szPath[2 * MAX_PATH+1];
	CString str;
	str.LoadString(IDS_MOVE_TARGET);

	dsbi.hwndOwner = GetSafeHwnd();
	dsbi.cbStruct = sizeof (DSBROWSEINFO);
	dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
	dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
	dsbi.pszRoot = m_sConnectPath;
	dsbi.pszPath = szPath;
	dsbi.cchPath = ((2 * MAX_PATH + 1) / sizeof(TCHAR));
	dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
	dsbi.pfnCallback = NULL;
	dsbi.lParam = 0;
  dsbi.dwReturnFormat = ADS_FORMAT_X500;

	// Specify credentials
	CString sUserName;
	WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];
	if (m_pCredObject->UseCredentials())
	{
		m_pCredObject->GetUsername(sUserName);
		m_pCredObject->GetPassword(szPassword);
		dsbi.dwFlags |= DSBI_HASCREDENTIALS;
		dsbi.pUserName = sUserName;
		dsbi.pPassword = szPassword;
	}

	result = DsBrowseForContainer( &dsbi );

	if ( result == IDOK ) 
	{ // returns -1, 0, IDOK or IDCANCEL
		// get path from BROWSEINFO struct, put in text edit field
		TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
		dsbi.pszPath);
		m_sRootPath = dsbi.pszPath;

		CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);

		CString sDisplay;
		GetDisplayPath(sDisplay);
		pEditPath->SetWindowText(sDisplay);
	}

	OnEditNameString(); // to check to see if the ok button should be enabled

}

void CADSIEditQueryDialog::GetDisplayPath(CString& sDisplay)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	hr = pIADsPathname->Set((LPWSTR)(LPCWSTR)m_sRootPath, ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
		TRACE(_T("Set failed. %s"), hr);
	}

	// Get the leaf name
	CString sDN;
	BSTR bstrPath = NULL;
	hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDN = L"";
	}
	else
	{
		sDN = bstrPath;
	}

	sDisplay = sDN;

}

// respone to the Edit Query... button
void CADSIEditQueryDialog::OnEditQuery()
{
	CLIPFORMAT cfDsQueryParams = (CLIPFORMAT)::RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);

	// create a query object
	HRESULT hr;
	CComPtr<ICommonQuery> spCommonQuery;
    hr = ::CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
                          IID_ICommonQuery, (PVOID *)&spCommonQuery);
    if (FAILED(hr))
		return;
	
	// setup structs to make the query
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW oqw;
	ZeroMemory(&dqip, sizeof(DSQUERYINITPARAMS));
	ZeroMemory(&oqw, sizeof(OPENQUERYWINDOW));

	// Get the username and password if we are impersonating credentials
	if (m_pCredObject->UseCredentials())
	{
		CString szUsername;
		WCHAR szPassword[MAX_PASSWORD_LENGTH + 1];
		m_pCredObject->GetUsername(szUsername);
		m_pCredObject->GetPassword(szPassword);

		dqip.pUserName = (LPWSTR)(LPCWSTR)szUsername;
		dqip.pPassword = szPassword;
	}

  dqip.cbStruct = sizeof(dqip);
  dqip.dwFlags = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS |
                 DSQPF_ENABLEADMINFEATURES;
  dqip.pDefaultScope = NULL;

  oqw.cbStruct = sizeof(oqw);
  oqw.dwFlags = OQWF_OKCANCEL | OQWF_DEFAULTFORM | OQWF_REMOVEFORMS |
		OQWF_REMOVESCOPES | OQWF_SAVEQUERYONOK | OQWF_HIDEMENUS | OQWF_HIDESEARCHUI;

  oqw.clsidHandler = CLSID_DsQuery;
  oqw.pHandlerParameters = &dqip;
  oqw.clsidDefaultForm = CLSID_DsFindAdvanced;

	// Get the HWND of the current dialog
  HWND hWnd = GetSafeHwnd();

	// make the call to get the query displayed
	CComPtr<IDataObject> spQueryResultDataObject;
    hr = spCommonQuery->OpenQueryWindow(hWnd, &oqw, &spQueryResultDataObject);

	if (spQueryResultDataObject == NULL)
	{
		if (FAILED(hr))
		{
			// no query available, reset to no data
			m_sFilter = L"";
			return;
		}
		// user hit cancel
		return;
	}

	// retrieve the query string from the data object
	FORMATETC fmte = {cfDsQueryParams, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
	hr = spQueryResultDataObject->GetData(&fmte, &medium);

	if (SUCCEEDED(hr)) // we have data
	{
		// get the query string
		LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)medium.hGlobal;
		LPWSTR pwszFilter = (LPWSTR)ByteOffset(pDsQueryParams, pDsQueryParams->offsetQuery);
		m_sFilter = pwszFilter;
		::ReleaseStgMedium(&medium);

		// REVIEW_MARCOC: this is a hack waiting for Diz to fix it...
		// the query string should be a well formed expression. Period
		// the query string is in the form (<foo>)(<bar>)...
		// if more of one token, need to wrap as (& (<foo>)(<bar>)...)
		WCHAR* pChar = (WCHAR*)(LPCWSTR)m_sFilter;
		int nLeftPar = 0;
		while (*pChar != NULL)
		{
			if (*pChar == TEXT('('))
			{
				nLeftPar++;
				if (nLeftPar > 1)
					break;
			}
			pChar++;
		}
		if (nLeftPar > 1)
		{
			CString s;
			s.Format(_T("(&%s)"), (LPCTSTR)m_sFilter);
			m_sFilter = s;
		}
		TRACE(_T("m_sFilter = %s\n"), (LPCTSTR)m_sFilter);
		CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
		pEditQueryString->SetWindowText(m_sFilter);
		OnEditQueryString();
	}

	return;
}

void CADSIEditQueryDialog::GetResults(CString& sName, 
												  CString& sFilter, 
												  CString& sPath,
												  BOOL* pOneLevel)
{
	sName = m_sName;
	sFilter = m_sFilter;
	sPath = m_sRootPath;
	*pOneLevel = m_bOneLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\queryui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       queryui.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// queryui.h

#ifndef _QUERYUI_H
#define _QUERYUI_H

#include "editor.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditConnectPropertyPage

class CADSIEditQueryDialog : public CDialog
{

// Construction
public:
  CADSIEditQueryDialog(CString& sName, 
								CString& sFilter, 
								CString& sPath, 
								CString& sConnectPath,
								BOOL bOneLevel,
								CCredentialObject* pCredObject);
  CADSIEditQueryDialog(CString& sConnectPath, CCredentialObject* pCredObject);
	~CADSIEditQueryDialog();

	void GetResults(CString& sName, CString& sFilter, CString& sPath, BOOL* pbOneLevel);

protected:

	virtual BOOL OnInitDialog();
	void OnEditQueryString();
	void OnEditNameString();
	void OnOneLevel();
	void OnSubtree();
	void OnBrowse();
	void OnEditQuery();

	void GetDisplayPath(CString& sDisplay);

	DECLARE_MESSAGE_MAP()

private:
	CString m_sName;
	CString m_sFilter;
	CString m_sRootPath;
	CString m_sConnectPath;
	BOOL m_bOneLevel;

	CCredentialObject* m_pCredObject;
};


#endif _QUERYUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\renameui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       renameui.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// renameui.h

#ifndef _RENAMEUI_H
#define _RENAMEUI_H

#include "editor.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditConnectPropertyPage

class CADSIEditRenameDialog : public CDialog
{

// Construction
public:
  CADSIEditRenameDialog(CTreeNode* pCurrentNode, 
                        CADsObject* pADsObject, 
                        CString sCurrentPath,
                        LPWSTR lpszNewName);
	~CADSIEditRenameDialog();

protected:

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	HRESULT EscapePath(CString& sEscapedName, const CString& sName);
	void CrackPath(const CString& szPath, CString& sDN);

	CString m_sPrefix;
	CString m_sPostfix;

	CADsObject* m_pADsObject;
	CString m_sCurrentPath;
  CString m_sNewName;
	CTreeNode* m_pCurrentNode;
	
	DECLARE_MESSAGE_MAP()
};


#endif _RENAMEUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\schemacache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       schemacache.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "schemacache.h"


//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Lookup
//
//  Synopsis:   Gets the cache item identified by the given class name
//
//  Arguments:  [pszClass - IN]  : the name of the class to retrieve the
//                                 cache information for
//              [refpItem - OUT] : reference to a pointer that will receive
//                                 the cached item
//
//  Returns:    bool : true if the cache contained the item
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CADSIEditClassCacheItemBase* CADSIEditSchemaCache::FindClassCacheItem(CCredentialObject* pCredObject,
                                                                      PCWSTR pszClass,
                                                                      PCWSTR pszSchemaPath)
{
  _Lock();
  CADSIEditClassCacheItemBase* pCacheSchemaItem = 0;

  do // false while
  {
    BOOL bFound = m_Map.Lookup(pszClass, pCacheSchemaItem);
    if (!bFound)
    {
      TRACE(_T("Cache miss: %s\n"), pszClass);

	    HRESULT hr = S_OK;
      CComPtr<IADsClass> spClass;

	    hr = OpenObjectWithCredentials(pCredObject,
											               pszSchemaPath,
											               IID_IADsClass, 
											               (void**)&spClass);
	    if ( FAILED(hr) )
	    {
        TRACE(_T("Bind failed in IsContainer() because hr=0x%x\n"), hr);
		    break;
	    }

      short bContainer = 0;
	    hr = spClass->get_Container( &bContainer );
      if (FAILED(hr))
      {
        TRACE(_T("IADsClass::get_Container() failed. hr=0x%x\n"), hr);
      }

      pCacheSchemaItem = new CADSIEditClassCacheItemBase(pszClass, bContainer ? true : false);
      if (pCacheSchemaItem)
      {
        //
        // set in the cache
        //
        m_Map.SetAt(pszClass, pCacheSchemaItem);
      }
      else
      {
        ASSERT(pCacheSchemaItem);
        break;
      }
    }
  } while (false);

  _Unlock();
  return pCacheSchemaItem;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Lookup
//
//  Synopsis:   Gets the cache item identified by the given class name
//
//  Arguments:  [pszClass - IN]  : the name of the class to retrieve the
//                                 cache information for
//              [refpItem - OUT] : reference to a pointer that will receive
//                                 the cached item
//
//  Returns:    bool : true if the cache contained the item
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
BOOL CADSIEditSchemaCache::Lookup(PCWSTR pszClass, CADSIEditClassCacheItemBase*& refpItem)
{
  _Lock();
  BOOL b = m_Map.Lookup(pszClass, refpItem);
  _Unlock();
  return b;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Initialize
//
//  Synopsis:   Initializes the critical section and cleans out the cache
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if initialization succeeded
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CADSIEditSchemaCache::Initialize() 
{ 
  HRESULT hr = S_OK;

  ExceptionPropagatingInitializeCriticalSection(&m_cs);

  _Lock();
  _Cleanup();
  _Unlock();

  return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Destroy
//
//  Synopsis:   Cleans out the cache and deletes the critical section
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if everything was deleted successfully
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CADSIEditSchemaCache::Destroy()
{
  HRESULT hr = S_OK;

  _Lock();
  _Cleanup();
  _Unlock();

  //
  // REVIEW_JEFFJON : need to add exception handling here
  //
  ::DeleteCriticalSection(&m_cs);

  return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Clear
//
//  Synopsis:   Cleans out the cache
//
//  Arguments:  
//
//  Returns:    
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CADSIEditSchemaCache::Clear()
{
  _Lock();
  _Cleanup();
  _Unlock();
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::_Cleanup
//
//  Synopsis:   Removes all entries from the map and deletes them
//
//  Arguments:  
//
//  Returns:    
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CADSIEditSchemaCache::_Cleanup()
{
  CString Key;
  CADSIEditClassCacheItemBase* pCacheItem = NULL;
  POSITION pos = m_Map.GetStartPosition();
  while (!m_Map.IsEmpty()) 
  {
    m_Map.GetNextAssoc (pos, Key, pCacheItem);
    m_Map.RemoveKey (Key);
    delete pCacheItem;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\snapbase.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       snapbase.cpp
//
//--------------------------------------------------------------------------


// SNAPBASE.CPP
#include "pch.h"
#include <snapbase.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

#include <dbg_.cpp>

#include <stdabou_.cpp>

#include <compbas_.cpp>
#include <proppag_.cpp>
#include <dataobj_.cpp>
#include <treedat_.cpp>

#include <aclpag_.cpp>

//////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\schemacache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       schemacache.h
//
//--------------------------------------------------------------------------

#ifndef _SCHEMA_CACHE_H_
#define _SCHEMA_CACHE_H_

#include <SnapBase.h>
#include "adsiedit.h"
#include "editor.h"

//+--------------------------------------------------------------------------
//
//  Class:      CADSIEditClassCacheItemBase
//
//  Purpose:    Object for storing and retrieving schema class information
//
//  History:    27-Nov-2000 JeffJon  Created
//
//---------------------------------------------------------------------------

class CADSIEditClassCacheItemBase
{
public:
  CADSIEditClassCacheItemBase(PCWSTR pszClass,
                              bool bIsContainer)
    : m_bIsContainer(bIsContainer),
      m_szClass(pszClass)
  {}

  ~CADSIEditClassCacheItemBase() {}

  bool    IsContainer() { return m_bIsContainer; }
  PCWSTR  GetClass() { return m_szClass; } 

private:
  bool    m_bIsContainer;
  CString m_szClass;
};

//+--------------------------------------------------------------------------
//
//  Class:      CADSIEditSchemaCache
//
//  Purpose:    Object for caching the schema information keyed by the
//              objectClass
//
//  History:    27-Nov-2000 JeffJon  Created
//
//---------------------------------------------------------------------------

typedef CMap <CString, PCWSTR, CADSIEditClassCacheItemBase*, CADSIEditClassCacheItemBase*> CADSIEditSchemaCacheMap;

class CADSIEditSchemaCache
{
public:
  CADSIEditSchemaCache()  {}
  ~CADSIEditSchemaCache() {}

  CADSIEditClassCacheItemBase* FindClassCacheItem(CCredentialObject* pCredObject,
                                                  PCWSTR pszClass,
                                                  PCWSTR pszSchemaPath);
  BOOL    Lookup(PCWSTR pszClass, CADSIEditClassCacheItemBase*& refpItem);
  HRESULT Initialize();
  HRESULT Destroy();
  void    Clear();

private:
  void _Cleanup();
  void _Lock()   { ::EnterCriticalSection(&m_cs);}
  void _Unlock() { ::LeaveCriticalSection(&m_cs);}

  CRITICAL_SECTION        m_cs;
  CADSIEditSchemaCacheMap m_Map;
};

#endif // _SCHEMA_CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\snapdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       snapdata.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "adsiedit.h"
#include "editor.h"
#include "connection.h"
#include "connectionui.h"
#include "snapdata.h"


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MENU(CADSIEditRootMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_TOP(IDM_CONNECT_TO, L"_ADSIEDIT_CONNECTTO")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_CONNECT_TO)
	END_RES
END_MENU


BEGIN_MENU(CADSIEditConnectMenuHolder)
	BEGIN_CTX
	   CTX_ENTRY_VIEW(IDM_FILTER, L"_ADSIEDIT_FILTER")
		CTX_ENTRY_TOP(IDM_SETTINGS_CONNECTION, L"_ADSIEDIT_SETTINGS")
		CTX_ENTRY_TOP(IDM_REMOVE_CONNECTION, L"_ADSIEDIT_REMOVE")
    CTX_ENTRY_TOP(IDM_UPDATE_SCHEMA, L"_ADSIEDIT_UPDATE")
		CTX_ENTRY_NEW(IDM_NEW_QUERY, L"_ADSIEDIT_NEWQUERY")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_FILTER)
		RES_ENTRY(IDS_SETTINGS_CONNECTION)
		RES_ENTRY(IDS_REMOVE_CONNECTION)
    RES_ENTRY(IDS_UPDATE_SCHEMA)
		RES_ENTRY(IDS_NEW_QUERY)
	END_RES
END_MENU

BEGIN_MENU(CADSIEditContainerMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_NEW(IDM_NEW_OBJECT, L"_ADSIEDIT_NEWOBJECT")
		CTX_ENTRY_TOP(IDM_MOVE, L"_ADSIEDIT_MOVE")
    CTX_ENTRY_TOP(IDM_NEW_CONNECT_FROM_HERE, L"_ADSIEDIT_CONNECTFROMHERE")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_NEW_OBJECT)
		RES_ENTRY(IDS_MOVE)
    RES_ENTRY(IDS_NEW_CONNECT_FROM_HERE)
	END_RES
END_MENU

BEGIN_MENU(CADSIEditLeafMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_TOP(IDM_MOVE, L"_ADSIEDIT_MOVE")
    CTX_ENTRY_TOP(IDM_NEW_NC_CONNECT_FROM_HERE, L"_ADSIEDIT_CONNECTTONCFROMHERE")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_MOVE)
    RES_ENTRY(IDS_NEW_CONNECT_TO_NC_FROM_HERE)
	END_RES
END_MENU

BEGIN_MENU(CADSIEditQueryMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_TOP(IDM_SETTINGS_QUERY, L"_ADSIEDIT_QUERYSETTINGS")
		CTX_ENTRY_TOP(IDM_REMOVE_QUERY, L"_ADSIEDIT_REMOVE")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_SETTINGS_QUERY)
		RES_ENTRY(IDS_REMOVE_QUERY)
	END_RES
END_MENU
	
//////////////////////////////////////////////////////////////////////
// CADSIEditRootData

// {D4F3374F-052F-11d2-97B0-00A0C9A06D2D}
const GUID CADSIEditRootData::NodeTypeGUID = 
{ 0xd4f3374f, 0x52f, 0x11d2, { 0x97, 0xb0, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


CADSIEditRootData::CADSIEditRootData(CComponentDataObject* pComponentData) 
      : CRootData(pComponentData) 
{
  m_szDescriptionText = L"";
}

CADSIEditRootData::~CADSIEditRootData()
{
	TRACE(_T("~CADSIEditRootData(), name <%s>\n"),GetDisplayName());
}

HRESULT CADSIEditRootData::LoadMRUs(IStream* pStm)
{
	HRESULT hr = LoadStringListFromStream(pStm, m_sDNMRU);
	if (FAILED(hr))
	{
		return hr;
	}
	hr = LoadStringListFromStream(pStm, m_sServerMRU);
	return hr;
}

HRESULT CADSIEditRootData::SaveMRUs(IStream* pStm)
{
	HRESULT hr = SaveStringListToStream(pStm, m_sDNMRU);
	if (FAILED(hr))
	{
		return hr;
	}
	hr = SaveStringListToStream(pStm, m_sServerMRU);
	return hr;
}

BOOL CADSIEditRootData::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& nodeList)
{
	BOOL bFound = FALSE;
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		CADSIEditConnectionNode* pConnectNode = dynamic_cast<CADSIEditConnectionNode*>(pNode);
		ASSERT(pConnectNode != NULL);

		CTreeNode* pFoundNode;
		BOOL bTemp;
		bTemp = pConnectNode->FindNode(lpszPath, nodeList);
		if (!bFound)
		{
			bFound = bTemp;
		}
	}
	return bFound;
}

BOOL CADSIEditRootData::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem, 
                                      long *pInsertionAllowed)
{
  //
  // Single selection
  //
  if (pContextMenuItem->lCommandID == IDM_CONNECT_TO)
  {
    return TRUE;
  }
	return FALSE;
}

BOOL CADSIEditRootData::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                              BOOL* pbHide,
                                              CNodeList* pNodeList)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}


HRESULT CADSIEditRootData::OnCommand(long nCommandID, 
                                     DATA_OBJECT_TYPES type, 
								                     CComponentDataObject* pComponentData,
                                     CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
	  switch (nCommandID)
	  {
		  case IDM_CONNECT_TO :
			  OnConnectTo(pComponentData);
			  break;
		  default:
			  ASSERT(FALSE); // Unknown command!
			  return E_FAIL;
	  }
  }
  else if (pNodeList->GetCount() > 1) // multiple selection
  {
    switch (nCommandID)
    {
      case IDM_REMOVE_CONNECTION :
        {
          POSITION pos = pNodeList->GetHeadPosition();
          while (pos != NULL)
          {
            CTreeNode* pNode = pNodeList->GetNext(pos);
            ASSERT(pNode != NULL);

            CADSIEditConnectionNode* pConnectionNode = dynamic_cast<CADSIEditConnectionNode*>(pNode);
            ASSERT(pConnectionNode != NULL);

            pConnectionNode->OnRemove(pComponentData);
          }
          break;
        }
      default :
        ASSERT(FALSE);
        return E_FAIL;
    }
  }

  return S_OK;
}

void CADSIEditRootData::OnConnectTo(CComponentDataObject* pComponentData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString s, sPath;
	BSTR bstrPath;
	CConnectionData* pConnectData = NULL;

	CADSIEditConnectDialog pConnectDialog(NULL,
																				this,
																				pComponentData, 
																				pConnectData);
	pConnectDialog.DoModal();

  //Change the result pane if this is the first child being added
  pComponentData->UpdateResultPaneView(this);
}


HRESULT CADSIEditRootData::GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
  HRESULT hr = S_FALSE;

  if (m_containerChildList.IsEmpty() && m_leafChildList.IsEmpty())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CADSIEditRootData::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    CString szTitle, szMessage;
    IconIdentifier iconID;

    VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NO_CONNECTIONS_TITLE));
    VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NO_CONNECTIONS_MESSAGE));
    iconID = Icon_Information;

    spMessageView->SetTitleText(szTitle);
    spMessageView->SetBodyText(szMessage);
    spMessageView->SetIcon(iconID);
  }
  return S_OK;
}


#define ADSIEDIT_STREAM_VERSION (12)

// IStream manipulation helpers overrides
HRESULT CADSIEditRootData::Load(IStream* pStm)
{
  //
	// assume never get multiple loads
  //
	if(!m_containerChildList.IsEmpty() || !m_leafChildList.IsEmpty())
		return E_FAIL;

	WCHAR szBuffer[256]; // REVIEW_MARCOC: hardcoded
	ULONG nLen; // WCHAR counting NULL

	UINT nCount;
	ULONG cbRead;
	// read the version ##
	DWORD dwVersion;
	VERIFY(SUCCEEDED(pStm->Read((void*)&dwVersion,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(DWORD));
	if (dwVersion != ADSIEDIT_STREAM_VERSION)
		return E_FAIL;

	HRESULT hr = LoadMRUs(pStm);
	if (FAILED(hr))
	{
		return hr;
	}

	// load the list of connections
	VERIFY(SUCCEEDED(pStm->Read((void*)&nCount,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));

	CComponentDataObject* pComponentData = GetComponentDataObject();
	for (int k=0; k< (int)nCount; k++)
	{
		CADSIEditConnectionNode* p = NULL;
		VERIFY(SUCCEEDED(CADSIEditConnectionNode::CreateFromStream(pStm, &p)));
		ASSERT(p != NULL);
		VERIFY(AddChildToList(p));
	}
	if (nCount > 0)
		MarkEnumerated();
	ASSERT(m_containerChildList.GetCount() == (int)nCount);

  return S_OK;
}

HRESULT CADSIEditRootData::Save(IStream* pStm, BOOL fClearDirty)
{
	UINT nCount;
	ULONG cbWrite;
	// write the version ##
	DWORD dwVersion = ADSIEDIT_STREAM_VERSION;
	VERIFY(SUCCEEDED(pStm->Write((void*)&dwVersion, sizeof(DWORD),&cbWrite)));
	ASSERT(cbWrite == sizeof(DWORD));

	HRESULT hr = SaveMRUs(pStm);
	if (FAILED(hr))
	{
		return hr;
	}

	// write # of servers 
	nCount = (UINT)m_containerChildList.GetCount();
	VERIFY(SUCCEEDED(pStm->Write((void*)&nCount, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));

	// loop through the list of connections and serialize them
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CADSIEditConnectionNode* pConnectNode = dynamic_cast<CADSIEditConnectionNode*>(m_containerChildList.GetNext(pos));
		ASSERT(pConnectNode != NULL);
		VERIFY(SUCCEEDED(pConnectNode->SaveToStream(pStm)));
	}

	if (fClearDirty)
		SetDirtyFlag(FALSE);
	return S_OK;
}


HRESULT CADSIEditRootData::IsDirty()
{
  return CRootData::IsDirty();
}



BOOL CADSIEditRootData::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
	//return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}

BOOL CADSIEditRootData::OnRefresh(CComponentDataObject* pComponentData,
                                  CNodeList* pNodeList)
{
  BOOL bRet = TRUE;
  if (pNodeList->GetCount() > 1) //multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
	  if (IsSheetLocked())
	  {
		  if (!CanCloseSheets())
			  return FALSE;
		  pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	  }
	  ASSERT(!IsSheetLocked());

	  POSITION pos;
	  for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	  {
		  CTreeNode* pNode = m_containerChildList.GetNext(pos);
		  CADSIEditConnectionNode* pConnectNode = dynamic_cast<CADSIEditConnectionNode*>(pNode);
		  ASSERT(pConnectNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
		  pConnectNode->OnRefresh(pComponentData, &nodeList);
	  }
    bRet = TRUE;
  }
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__


//	About for "Certificate Templates" snapin
class CCertTemplatesAbout :
	public CSnapinAbout,
	public CComCoClass<CCertTemplatesAbout, &CLSID_CertTemplatesAbout>

{
public:
DECLARE_REGISTRY(CCertTemplatesAbout, _T("CERTTMPL.CertTemplatesAboutObject.1"), _T("CERTTMPL.CertTemplatesAboutObject.1"), IDS_CERTTMPL_DESC, THREADFLAGS_BOTH)
	CCertTemplatesAbout();
};


#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\adsiedit\snapdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       snapdata.h
//
//--------------------------------------------------------------------------


#ifndef _SNAPDATA_H
#define _SNAPDATA_H

#include "adsiedit.h"
#include "common.h"

enum
{
	//Root node verbs
	IDM_CONNECT_TO,
	IDM_SETTINGS_CONNECTION,
	IDM_REMOVE_CONNECTION,
  IDM_UPDATE_SCHEMA,
	IDM_FILTER,

	//Container node verbs
	IDM_RENAME,
	IDM_MOVE,
	IDM_NEW_OBJECT,
	IDM_NEW_QUERY,
  IDM_NEW_CONNECT_FROM_HERE,
  IDM_NEW_NC_CONNECT_FROM_HERE,

	//Query node verbs
	IDM_REMOVE_QUERY,
	IDM_SETTINGS_QUERY
};

DECLARE_MENU(CADSIEditRootMenuHolder)
DECLARE_MENU(CADSIEditConnectMenuHolder)
DECLARE_MENU(CADSIEditContainerMenuHolder)
DECLARE_MENU(CADSIEditLeafMenuHolder)
DECLARE_MENU(CADSIEditQueryMenuHolder)

//  # of items per folder: must be >=0  and <= 0xFFFFFFFF (DWORD) to serialize
#define ADSIEDIT_QUERY_OBJ_COUNT_DEFAULT 10000   // default value
#define ADSIEDIT_QUERY_OBJ_COUNT_MIN 10      // min value
#define ADSIEDIT_QUERY_OBJ_COUNT_MAX 100000  // max value
#define ADSIEDIT_QUERY_OBJ_TEXT_COUNT_MAX 6 // max # of bytes in text

///////////////////////////////////////////////////////////////////
// CADSIEditRootData



class CADSIEditRootData : public CRootData
{
public:

	CADSIEditRootData(CComponentDataObject* pComponentData);
	virtual ~CADSIEditRootData();

	// node info
	DECLARE_NODE_GUID()

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList) { ASSERT(FALSE);}
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);

  virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
  virtual HRESULT OnShow(LPCONSOLE lpConsole);
  
  virtual int GetImageIndex(BOOL bOpenImage) { return ROOT_IMAGE;}

	void OnConnectTo(CComponentDataObject* pComponentData);

	// IStream manipulation helpers overrides
  virtual HRESULT IsDirty();
	virtual HRESULT Load(IStream* pStm);
	virtual HRESULT Save(IStream* pStm, BOOL fClearDirty);

	// Accessors for the Connect to... MRUs
	void GetDNMRU(CStringList* psDNList) { CopyStringList(psDNList, &m_sDNMRU); }
	void SetDNMRU(CStringList* psDNList) { CopyStringList(&m_sDNMRU, psDNList); }
	void GetServerMRU(CStringList* psServerList) { CopyStringList(psServerList, &m_sServerMRU); }
	void SetServerMRU(CStringList* psServerList) { CopyStringList(&m_sServerMRU, psServerList); }
	HRESULT LoadMRUs(IStream* pStm);
	HRESULT SaveMRUs(IStream* pStm);

	BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);

  CColumnSet* GetColumnSet() { return ((CADSIEditComponentDataObject*)GetComponentDataObject())->GetColumnSet(); }
  LPCWSTR GetColumnID() { return ((CADSIEditComponentDataObject*)GetComponentDataObject())->GetColumnSet()->GetColumnID(); }

  virtual LPWSTR GetDescriptionBarText()
  {
    LPWSTR lpszFormat = L"%d Connection(s)";
    int iCount = m_containerChildList.GetCount() + m_leafChildList.GetCount();

    m_szDescriptionText.Format(lpszFormat, iCount);
    return (LPWSTR)(LPCWSTR)m_szDescriptionText;
  }

protected:
	virtual BOOL CanCloseSheets();
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
								             long *pInsertionAllowed);
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
				{ return CADSIEditRootMenuHolder::GetContextMenuItem(); }

private:
	CStringList m_sDNMRU;
	CStringList m_sServerMRU;
  CString m_szDescriptionText;
};

#endif // _SNAPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "about.h"

#include "stdabout.cpp" 

/////////////////////////////////////////////////////////////////////
CCertTemplatesAbout::CCertTemplatesAbout()
{
	m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
	m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CERT_TEMPLATEV2;
	m_uIdBitmapSmallImage = IDB_CERTTMPL_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTTMPL_SMALL;
	m_uIdBitmapLargeImage = IDB_CERTTMPL_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\addapprovaldlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       AddApprovalDlg.h
//
//  Contents:   Definition of CAddApprovalDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_ADDAPPROVALDLG_H__1BB4F754_0009_4237_A82A_B533CB46C543__INCLUDED_)
#define AFX_ADDAPPROVALDLG_H__1BB4F754_0009_4237_A82A_B533CB46C543__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AddApprovalDlg.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CAddApprovalDlg dialog

class CAddApprovalDlg : public CHelpDialog
{
// Construction
public:
	virtual  ~CAddApprovalDlg();
	PSTR* m_paszReturnedApprovals;
    void EnableControls ();
	CAddApprovalDlg(CWnd* pParent, const PSTR* paszUsedApprovals);


// Dialog Data
	//{{AFX_DATA(CAddApprovalDlg)
	enum { IDD = IDD_ADD_APPROVAL };
	CListBox	m_issuanceList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddApprovalDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	bool ApprovalAlreadyUsed (PCSTR pszOID) const;

	// Generated message map functions
	//{{AFX_MSG(CAddApprovalDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelchangeApprovalList();
	afx_msg void OnDblclkApprovalList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    const PSTR*     m_paszUsedApprovals;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDAPPROVALDLG_H__1BB4F754_0009_4237_A82A_B533CB46C543__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\basicconstraintsdlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       BasicConstraintsDlg.h
//
//  Contents:   Implementation of CBasicConstraintsDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_BASICCONSTRAINTSDLG_H__DE830A13_21AB_489A_B899_57560400C11B__INCLUDED_)
#define AFX_BASICCONSTRAINTSDLG_H__DE830A13_21AB_489A_B899_57560400C11B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// BasicConstraintsDlg.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CBasicConstraintsDlg dialog

class CBasicConstraintsDlg : public CHelpDialog
{
// Construction
public:
	void EnableControls();
	CBasicConstraintsDlg(CWnd* pParent, 
            CCertTemplate& rCertTemplate, 
            PCERT_EXTENSION pCertExtension);
	~CBasicConstraintsDlg();

// Dialog Data
	//{{AFX_DATA(CBasicConstraintsDlg)
	enum { IDD = IDD_BASIC_CONSTRAINTS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasicConstraintsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	// Generated message map functions
	//{{AFX_MSG(CBasicConstraintsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnBasicConstraintsCritical();
	afx_msg void OnOnlyIssueEndEntities();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool                            m_bModified;
    CCertTemplate&                  m_rCertTemplate;
    PCERT_EXTENSION                 m_pCertExtension;
    PCERT_BASIC_CONSTRAINTS2_INFO   m_pBCInfo;   
    DWORD                           m_cbInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BASICCONSTRAINTSDLG_H__DE830A13_21AB_489A_B899_57560400C11B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\addapprovaldlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       AddApprovalDlg.cpp
//
//  Contents:   Implementation of CAddApprovalDlg
//
//----------------------------------------------------------------------------
// AddApprovalDlg.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "AddApprovalDlg.h"
#include "PolicyOID.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern POLICY_OID_LIST	    g_policyOIDList;

/////////////////////////////////////////////////////////////////////////////
// CAddApprovalDlg dialog

CAddApprovalDlg::CAddApprovalDlg(CWnd* pParent, const PSTR* paszUsedApprovals)
	: CHelpDialog(CAddApprovalDlg::IDD, pParent),
    m_paszReturnedApprovals (0),
    m_paszUsedApprovals (paszUsedApprovals)
{
	//{{AFX_DATA_INIT(CAddApprovalDlg)
	//}}AFX_DATA_INIT
}

CAddApprovalDlg::~CAddApprovalDlg()
{
    if ( m_paszReturnedApprovals )
    {
        for (int nIndex = 0; m_paszReturnedApprovals[nIndex]; nIndex++)
            delete [] m_paszReturnedApprovals[nIndex];
        delete [] m_paszReturnedApprovals;
    }
}

void CAddApprovalDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddApprovalDlg)
	DDX_Control(pDX, IDC_APPROVAL_LIST, m_issuanceList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddApprovalDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CAddApprovalDlg)
	ON_LBN_SELCHANGE(IDC_APPROVAL_LIST, OnSelchangeApprovalList)
	ON_LBN_DBLCLK(IDC_APPROVAL_LIST, OnDblclkApprovalList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddApprovalDlg message handlers


BOOL CAddApprovalDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	
    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            // If this is the Application OID dialog, show only application 
            // OIDS, otherwise if this is the Issuance OID dialog, show only
            // issuance OIDs
            if ( pPolicyOID->IsIssuanceOID () )
            {
                bool bFound = false;

                // Don't display an approval that's already been used
                if ( m_paszUsedApprovals )
                {
                    for (int nIndex = 0; m_paszUsedApprovals[nIndex]; nIndex++)
                    {
                        if ( !strcmp (pPolicyOID->GetOIDA (), m_paszUsedApprovals[nIndex]) )
                        {
                            bFound = true;
                            break;
                        }
                    }
                }

                if ( !bFound )
                {
                    int nIndex = m_issuanceList.AddString (pPolicyOID->GetDisplayName ());
                    if ( nIndex >= 0 )
                    {
                        LPSTR   pszOID = new CHAR[strlen (pPolicyOID->GetOIDA ())+1];
                        if ( pszOID )
                        {
                            strcpy (pszOID, pPolicyOID->GetOIDA ());
                            m_issuanceList.SetItemDataPtr (nIndex, pszOID);
                        }
                    }
                }
            }
        }
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddApprovalDlg::EnableControls()
{
    GetDlgItem (IDOK)->EnableWindow (m_issuanceList.GetSelCount () > 0);
}

void CAddApprovalDlg::OnOK() 
{
    int     nSelectedCnt = m_issuanceList.GetSelCount ();

	
    // allocate an array of PSTR pointers and set each item to an approval.
    // Set the last to NULL
    if ( nSelectedCnt )
    {
        int* pnSelItems = new int[nSelectedCnt];
        if ( pnSelItems )
        {
            if ( LB_ERR != m_issuanceList.GetSelItems (nSelectedCnt, pnSelItems) )
            {
                m_paszReturnedApprovals = new PSTR[nSelectedCnt+1];
                if ( m_paszReturnedApprovals )
                {
                    ::ZeroMemory (m_paszReturnedApprovals, sizeof (PSTR) * (nSelectedCnt+1));
	                for (int nIndex = 0; nIndex < nSelectedCnt; nIndex++)
	                {
                        PSTR pszPolicyOID = (PSTR) m_issuanceList.GetItemData (pnSelItems[nIndex]);
                        if ( pszPolicyOID )
                        {
                            PSTR pNewStr = new CHAR[strlen (pszPolicyOID) + 1];
                            if ( pNewStr )
                            {
                                strcpy (pNewStr, pszPolicyOID);
                                m_paszReturnedApprovals[nIndex] = pNewStr;
                            }
                            else
                                break;
                        }
                    }
                }
            }
            delete [] pnSelItems;
        }
    }

    CHelpDialog::OnOK();
}

bool CAddApprovalDlg::ApprovalAlreadyUsed(PCSTR pszOID) const
{
    bool    bResult = false;

    if ( m_paszUsedApprovals )
    {
        for (int nIndex = 0; m_paszUsedApprovals[nIndex]; nIndex++)
        {
            if ( !strcmp (m_paszUsedApprovals[nIndex], pszOID) )
            {
                bResult = true;
                break;
            }
        }
    }

    return bResult;
}

void CAddApprovalDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CAddApprovalDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_ADD_APPROVAL) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CAddApprovalDlg::DoContextHelp\n");
}

void CAddApprovalDlg::OnSelchangeApprovalList() 
{
	EnableControls ();
}

void CAddApprovalDlg::OnDblclkApprovalList() 
{
    OnOK ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\basicconstraintsdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       BasicConstraintsDlg.cpp
//
//  Contents:   Implementation of CBasicConstraintsDlg
//
//----------------------------------------------------------------------------
// BasicConstraintsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "BasicConstraintsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasicConstraintsDlg property page


CBasicConstraintsDlg::CBasicConstraintsDlg(CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension) 
    : CHelpDialog(CBasicConstraintsDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension),
    m_bModified (false),
    m_pBCInfo (0),
    m_cbInfo (0)
{
	//{{AFX_DATA_INIT(CBasicConstraintsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CBasicConstraintsDlg::~CBasicConstraintsDlg()
{
    if ( m_pBCInfo )
        LocalFree (m_pBCInfo);
    m_rCertTemplate.Release ();
}

void CBasicConstraintsDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBasicConstraintsDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBasicConstraintsDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CBasicConstraintsDlg)
	ON_WM_CANCELMODE()
	ON_BN_CLICKED(IDC_BASIC_CONSTRAINTS_CRITICAL, OnBasicConstraintsCritical)
	ON_BN_CLICKED(IDC_ONLY_ISSUE_END_ENTITIES, OnOnlyIssueEndEntities)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBasicConstraintsDlg message handlers

BOOL CBasicConstraintsDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CBasicConstraintsDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	
    if ( m_pCertExtension->fCritical )
        SendDlgItemMessage (IDC_BASIC_CONSTRAINTS_CRITICAL, BM_SETCHECK, BST_CHECKED);
	
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_BASIC_CONSTRAINTS_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_ONLY_ISSUE_END_ENTITIES)->EnableWindow (FALSE);
    }

     

    if ( CryptDecodeObject (
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            szOID_BASIC_CONSTRAINTS2, 
            m_pCertExtension->Value.pbData,
            m_pCertExtension->Value.cbData,
            0,
            0,
            &m_cbInfo) )
    {
        m_pBCInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) ::LocalAlloc (
                LPTR, m_cbInfo);
        if ( m_pBCInfo )
        {
            if ( CryptDecodeObject (
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                szOID_BASIC_CONSTRAINTS2, 
                m_pCertExtension->Value.pbData,
                m_pCertExtension->Value.cbData,
                0,
                m_pBCInfo,
                &m_cbInfo) )
            {
                if ( m_pBCInfo->fPathLenConstraint )
                    SendDlgItemMessage (IDC_ONLY_ISSUE_END_ENTITIES, BM_SETCHECK, BST_CHECKED);
            }
            else
            {
                _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", GetLastError ());
            }
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        CString text;
        CString caption;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        text.FormatMessage (IDS_CANNOT_READ_BASIC_CONSTRAINTS, GetSystemMessage (dwErr));
        MessageBox (text, caption, MB_ICONWARNING);

        _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", dwErr);
    }
    EnableControls ();

    _TRACE (-1, L"Leaving CBasicConstraintsDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CBasicConstraintsDlg::OnBasicConstraintsCritical() 
{
    m_pCertExtension->fCritical = BST_CHECKED == SendDlgItemMessage (IDC_BASIC_CONSTRAINTS_CRITICAL, BM_GETCHECK);
    m_bModified = true;
    EnableControls ();
}

void CBasicConstraintsDlg::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        GetDlgItem (IDC_BASIC_CONSTRAINTS_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_ONLY_ISSUE_END_ENTITIES)->EnableWindow (FALSE);
    }
    else
    {
        GetDlgItem (IDOK)->EnableWindow (m_bModified && !m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_BASIC_CONSTRAINTS_CRITICAL)->EnableWindow (!m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_ONLY_ISSUE_END_ENTITIES)->EnableWindow (!m_rCertTemplate.ReadOnly ());
    }
}

void CBasicConstraintsDlg::OnOnlyIssueEndEntities() 
{
    m_bModified = true;
    EnableControls ();
}

void CBasicConstraintsDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CBasicConstraintsDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_BASIC_CONSTRAINTS) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CBasicConstraintsDlg::DoContextHelp\n");
}

void CBasicConstraintsDlg::OnOK() 
{
    if ( m_pBCInfo )
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_ONLY_ISSUE_END_ENTITIES, BM_GETCHECK) )
        {
            m_pBCInfo->dwPathLenConstraint = 0;
            m_pBCInfo->fPathLenConstraint = TRUE;
        }
        else
        {
            m_pBCInfo->dwPathLenConstraint = (DWORD) -1;
            m_pBCInfo->fPathLenConstraint = FALSE;
        }

        bool    bCritical = BST_CHECKED == SendDlgItemMessage (
                    IDC_BASIC_CONSTRAINTS_CRITICAL, BM_GETCHECK);
        HRESULT hr = m_rCertTemplate.SetBasicConstraints (m_pBCInfo, bCritical);
        if ( FAILED (hr) )
            return;
    }
    else
        return;

	CHelpDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\cmponent.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cmponent.cpp
//
//  Contents:   Implementation of CCertTmplComponent
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "dbg.h"
#include "compdata.h" // CCertTmplComponentData
#include "dataobj.h"
#include "cmponent.h" // CCertTmplComponent
#include "utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DECLARE_INFOLEVEL(CertTmplSnapin)

USE_HANDLE_MACROS ("CERTTMPL (cmponent.cpp)")

#pragma warning(push,3)
#include "stdcmpnt.cpp" // CComponent
#pragma warning(pop)

UINT m_aColumnsSnapinSelected[CERT_TEMPLATES_NUM_COLS+1] =
	{IDS_COLUMN_CERT_TEMPLATE_OBJECT,
        IDS_COLUMN_CERT_TEMPLATE_TYPE,
        IDS_COLUMN_CERT_TEMPLATE_VERSION,
        IDS_COLUMN_CERT_TEMPLATE_AUTOENROLLMENT,
		0};

UINT* m_Columns[CERTTMPL_NUMTYPES] =
	{	
		m_aColumnsSnapinSelected,   // CERTTMPL_SNAPIN (displays certificate templates in the result pane)
        0
	};



UINT** g_aColumns = 0;	// for framework
int** g_aColumnWidths = 0;  // for framework
const int SINGLE_COL_WIDTH = 300;

CCertTmplComponent::CCertTmplComponent ()
	: m_pViewedCookie (NULL),
	m_currResultNodeType (CERTTMPL_INVALID)
{
	_TRACE (1, L"Entering CCertTmplComponent::CCertTmplComponent\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));

    ::ZeroMemory (m_ColumnWidths, (sizeof (UINT*) * CERTTMPL_NUMTYPES));

	m_ColumnWidths[CERTTMPL_SNAPIN] = new UINT[CERT_TEMPLATES_NUM_COLS];
	if ( m_ColumnWidths[CERTTMPL_SNAPIN] )
	{
		m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_OBJECT] = 250;
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_TYPE] = 150;
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_VERSION] = 50;
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS] = 100;
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::CCertTmplComponent\n");
}

CCertTmplComponent::~CCertTmplComponent ()
{
	_TRACE (1, L"Entering CCertTmplComponent::~CCertTmplComponent\n");
	VERIFY ( SUCCEEDED (ReleaseAll ()) );

	for (int i = 0; i < CERTTMPL_NUMTYPES; i++)
	{
        if ( m_ColumnWidths[i] )
		    delete [] m_ColumnWidths[i];
	}
	_TRACE (-1, L"Leaving CCertTmplComponent::~CCertTmplComponent\n");
}

HRESULT CCertTmplComponent::ReleaseAll ()
{
	return CComponent::ReleaseAll ();
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation

HRESULT CCertTmplComponent::LoadStrings ()
{
	return S_OK;
}

HRESULT CCertTmplComponent::LoadColumns ( CCertTmplCookie* pcookie )
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	_TRACE (1, L"Entering CCertTmplComponent::LoadColumns\n");
	HRESULT	hr = S_OK;


	hr = LoadColumnsFromArrays (pcookie->m_objecttype);

	_TRACE (-1, L"Leaving CCertTmplComponent::LoadColumns\n");
	return hr;
}


/* This is generated by UpdateAllViews () */
HRESULT CCertTmplComponent::OnViewChange (LPDATAOBJECT pDataObject, LPARAM /*data*/, LPARAM hint)
{
	_TRACE (1, L"Entering CCertTmplComponent::OnViewChange\n");
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	CCertTmplComponentData&	compData = QueryComponentDataRef ();
	HRESULT					hr = S_OK;

	if ( hint & UPDATE_HINT_ENUM_CERT_TEMPLATES )
	{
		hr = RefreshResultPane (false);
		return hr;
	}
    
	hr = RefreshResultPane (false);


	CCertTmplCookie* pCookie = compData.ConvertCookie (pDataObject);
	if ( pCookie )
	{
		switch (pCookie->m_objecttype)
		{
        case CERTTMPL_CERT_TEMPLATE:
            break;

		case CERTTMPL_SNAPIN:
			break;

		default:
			{
				IConsole2*	pConsole2 = 0;
				hr = m_pConsole->QueryInterface (
						IID_PPV_ARG(IConsole2, &pConsole2));
				if (SUCCEEDED (hr))
				{
					hr = pConsole2->SetStatusText (L"");
					if ( !SUCCEEDED (hr) )
					{
						_TRACE (0, L"IConsole2::SetStatusText () failed: %x", hr);
					}
					pConsole2->Release ();
				}
			}
			break;
		}
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::OnViewChange\n");
	return hr;
}

HRESULT CCertTmplComponent::Show (
        CCookie* pcookie, 
        LPARAM arg, 
        HSCOPEITEM /*hScopeItem*/, 
        LPDATAOBJECT /*pDataObject*/)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;

	if ( !arg )
	{
		if ( !m_pResultData )
		{
			ASSERT ( FALSE );
			return E_UNEXPECTED;
		}

		m_pViewedCookie = dynamic_cast <CCertTmplCookie*> (pcookie);
		ASSERT (m_pViewedCookie);
		if ( m_pViewedCookie )
			hr = SaveWidths (m_pViewedCookie);
		m_pViewedCookie = 0;
		return S_OK;
	}

	m_pViewedCookie = dynamic_cast <CCertTmplCookie*> (pcookie);
	ASSERT (m_pViewedCookie);
	if ( m_pViewedCookie )
	{
		// Load default columns and widths
		LoadColumns (m_pViewedCookie);

		// Restore persisted column widths
		switch (m_pViewedCookie->m_objecttype)
		{
		case CERTTMPL_SNAPIN:
			break;

        case CERTTMPL_CERT_TEMPLATE:  // not a scope pane item
            ASSERT (0);
            break;

		default:
			ASSERT (0);
			break;
		}

		hr = PopulateListbox (m_pViewedCookie);
		if ( FAILED (hr) )
		{
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CERTTMPL));

            text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES, GetSystemMessage (hr));

		    int		iRetVal = 0;
		    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
			    MB_ICONWARNING | MB_OK, &iRetVal)));
		}
	}

	return hr;
}

HRESULT CCertTmplComponent::Show ( CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem)
{
	ASSERT (0);
	return Show (pcookie, arg, hScopeItem, 0);
}


HRESULT CCertTmplComponent::OnNotifyAddImages (LPDATAOBJECT /*pDataObject*/,
	                                             LPIMAGELIST lpImageList,
	                                             HSCOPEITEM /*hSelectedItem*/)
{
	long	lViewMode = 0;

	ASSERT (m_pResultData);
	QueryComponentDataRef ().SetResultData (m_pResultData);

	HRESULT	hr = m_pResultData->GetViewMode (&lViewMode);	
	ASSERT (SUCCEEDED (hr));
	BOOL	bLoadLargeIcons = (LVS_ICON == lViewMode);

	return QueryComponentDataRef ().LoadIcons (lpImageList, bLoadLargeIcons);
}


HRESULT CCertTmplComponent::PopulateListbox (CCertTmplCookie* pCookie)
{
	_TRACE (1, L"Entering CCertTmplComponent::PopulateListbox\n");
	HRESULT		hr = S_OK;

	
	switch ( pCookie->m_objecttype )
	{
	case CERTTMPL_SNAPIN:
		hr = AddEnterpriseTemplates ();
		if ( SUCCEEDED (hr) )
		{
        	m_currResultNodeType = CERTTMPL_CERT_TEMPLATE;
        }
        break;

    case CERTTMPL_CERT_TEMPLATE:
        ASSERT (0);
        break;

	default:
        ASSERT (0);
		break;
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::PopulateListbox\n");
	return hr;
}

HRESULT CCertTmplComponent::RefreshResultPane (const bool bSilent)
{
	_TRACE (1, L"Entering CCertTmplComponent::RefreshResultPane\n");
	HRESULT hr = S_OK;

	ASSERT (NULL != m_pResultData);
	if ( m_pResultData )
	{
		m_pResultData->DeleteAllRsltItems ();
	}
	else
		hr = E_UNEXPECTED;

	if ( m_pViewedCookie )
	{
		hr = PopulateListbox (m_pViewedCookie);
		if ( FAILED (hr) && !bSilent )
		{
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CERTTMPL));

            text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES, GetSystemMessage (hr));

		    int		iRetVal = 0;
		    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
			    MB_ICONWARNING | MB_OK, &iRetVal)));
		}
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::RefreshResultPane\n");
	return hr;
}

STDMETHODIMP CCertTmplComponent::GetDisplayInfo (RESULTDATAITEM * pResult)
{	
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pResult);
	HRESULT hr = S_OK;


	if ( pResult && !pResult->bScopeItem ) //&& (pResult->mask & RDI_PARAM) )
	{
		CCookie* pResultCookie = reinterpret_cast<CCookie*> (pResult->lParam);
		ASSERT (pResultCookie);
		if ( !pResultCookie || IsBadWritePtr ((LPVOID) pResultCookie, sizeof (CCookie)) )
			return E_UNEXPECTED;

		CCookie* pActiveCookie = ActiveBaseCookie (pResultCookie);
		ASSERT (pActiveCookie);
		if ( !pActiveCookie || IsBadWritePtr ((LPVOID) pActiveCookie, sizeof (CCookie)) )
			return E_UNEXPECTED;

		CCertTmplCookie* pCookie = dynamic_cast <CCertTmplCookie*>(pActiveCookie);
		ASSERT (pCookie);
		switch (pCookie->m_objecttype)
		{
        case CERTTMPL_CERT_TEMPLATE:
			{
				CCertTemplate* pCertTemplate = reinterpret_cast <CCertTemplate*> (pCookie);
				ASSERT (pCertTemplate);
				if ( pCertTemplate )
				{
					if (pResult->mask & RDI_STR)
					{
						// Note:  text is first stored in class variable so that the buffer is
						// somewhat persistent.  Copying the buffer pointer directly to the
						// pResult->str would result in the buffer being freed before the pointer
						// is used.
						switch (pResult->nCol)
						{
						case COLNUM_CERT_TEMPLATE_OBJECT:
							m_szDisplayInfoResult = pCertTemplate->GetDisplayName ();
							break;

                        case COLNUM_CERT_TEMPLATE_TYPE:
                            {
                                DWORD   dwVersion = pCertTemplate->GetType ();
                                switch (dwVersion)
                                {
                                case 1:
                                    VERIFY (m_szDisplayInfoResult.LoadString (IDS_WINDOWS_2000_AND_LATER));
                                    break;

                                case 2:
                                    VERIFY (m_szDisplayInfoResult.LoadString (IDS_WINDOWS_2002_AND_LATER));
                                    break;

                                default:
                                    break;
                                }
                            }
                            break;

                        case COLNUM_CERT_TEMPLATE_VERSION:
                            {
                                DWORD   dwMajorVersion = 0;
                                DWORD   dwMinorVersion = 0;

                                hr = pCertTemplate->GetMajorVersion (dwMajorVersion);
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = pCertTemplate->GetMinorVersion (dwMinorVersion);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        WCHAR   str[32];
                                        m_szDisplayInfoResult = _ultow (dwMajorVersion, str, 10);
                                        m_szDisplayInfoResult += L".";
                                        m_szDisplayInfoResult += _ultow (dwMinorVersion, str, 10);
                                    }
                                }
                            }
                            break;

                        case COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS:
                            if ( pCertTemplate->GoodForAutoEnrollment () )
                                VERIFY (m_szDisplayInfoResult.LoadString (IDS_VALID_FOR_AUTOENROLLMENT));
                            else
                                VERIFY (m_szDisplayInfoResult.LoadString (IDS_INVALID_FOR_AUTOENROLLMENT));
                            break;

                        default:
							ASSERT (0);
							break;
						}

						pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
					}
					if (pResult->mask & RDI_IMAGE)
                    {
                        if ( 1 == pCertTemplate->GetType () )
                            pResult->nImage = iIconCertTemplateV1;
                        else
                            pResult->nImage = iIconCertTemplateV2;
                    }
				}
			}
			break;

        default:
            ASSERT (0);
            break;
		}
    }
	else
		hr = CComponent::GetDisplayInfo (pResult);

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertTmplComponent::AddMenuItems (LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
	return QueryComponentDataRef ().AddMenuItems (pDataObject,
			pContextMenuCallback, pInsertionAllowed);
}


STDMETHODIMP CCertTmplComponent::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
	HRESULT	hr = S_OK;

	hr = QueryComponentDataRef ().Command (nCommandID, pDataObject);

	return hr;
}


HRESULT CCertTmplComponent::OnNotifyDblClick (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertTmplComponent::OnNotifyDblClick\n");
	HRESULT	hr = S_OK;
	ASSERT (pDataObject);

	CCertTmplCookie* pParentCookie =
			QueryComponentDataRef ().ConvertCookie (pDataObject);
	if ( pParentCookie )
	{
		switch ( pParentCookie->m_objecttype )
		{
			case CERTTMPL_SNAPIN:
				hr = S_FALSE;
				break;

            case CERTTMPL_CERT_TEMPLATE:
                hr = S_FALSE;
                break;

			default:
				_TRACE (0, L"CCertTmplComponentData::OnNotifyDblClick bad parent type\n");
				ASSERT (FALSE);
				hr = S_OK;
				break;
		}
	}
	else
		hr =  E_UNEXPECTED;


	_TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyDblClick\n");
	return hr;
}


HRESULT CCertTmplComponent::OnNotifySelect (LPDATAOBJECT pDataObject, BOOL /*fSelected*/)
{
	ASSERT (m_pConsoleVerb && 0xdddddddd != (UINT_PTR) m_pConsoleVerb);
	if ( !m_pConsoleVerb || 0xdddddddd == (UINT_PTR) m_pConsoleVerb )
		return E_FAIL;


	HRESULT	hr = S_OK;
	CCertTmplComponentData& compData = QueryComponentDataRef ();


	switch (compData.GetObjectType (pDataObject))
	{
	case CERTTMPL_SNAPIN:
   		m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
        DisplayRootNodeStatusBarText (m_pConsole);
		break;

    case CERTTMPL_CERT_TEMPLATE:
        {
			CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
				if ( pCertTemplate )
				{
                    if ( !pCertTemplate->IsDefault () )
                        m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);

                    // #NTRAID 360650: Cert Server: Cannot rename cert templates
                    //if ( 1 != pCertTemplate->GetType () && !pCertTemplate->IsDefault () )
                	//	m_pConsoleVerb->SetVerbState (MMC_VERB_RENAME, ENABLED, TRUE);
                }
            }
        }
	    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
		m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
		m_currResultNodeType = CERTTMPL_CERT_TEMPLATE;
	    DisplayObjectCountInStatusBar (m_pConsole, 
			    QueryComponentDataRef ().m_dwNumCertTemplates);
        break;

	case CERTTMPL_MULTISEL:
    	m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
		m_currResultNodeType = CERTTMPL_MULTISEL;
	    DisplayObjectCountInStatusBar (m_pConsole, 
			    QueryComponentDataRef ().m_dwNumCertTemplates);
		break;

	default:
		m_currResultNodeType = CERTTMPL_INVALID;
		hr = E_UNEXPECTED;
		break;
	}

	return hr;
}

STDMETHODIMP CCertTmplComponent::CreatePropertyPages (
	LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR handle,		// This handle must be saved in the property page object to notify the parent when modified
	LPDATAOBJECT pDataObject)
{
	return QueryComponentDataRef ().CreatePropertyPages (pCallBack, handle, pDataObject);
}

STDMETHODIMP CCertTmplComponent::QueryPagesFor (LPDATAOBJECT pDataObject)
{
	return QueryComponentDataRef ().QueryPagesFor (pDataObject);
}


HRESULT CCertTmplComponent::OnNotifyRefresh (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertTmplComponent::OnNotifyRefresh\n");
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT	    hr = S_OK;
    CWaitCursor	waitCursor;

	CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
	if ( !pCookie )
		return E_UNEXPECTED;

	CCertTmplComponentData&	dataRef = QueryComponentDataRef ();

	switch (pCookie->m_objecttype)
	{
	case CERTTMPL_SNAPIN:
		{
			// Delete all the scope items and force a reexpansion
			hr = dataRef.DeleteScopeItems ();
	        hr = PopulateListbox (m_pViewedCookie);
	        if ( FAILED (hr) )
	        {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));

                text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES, GetSystemMessage (hr));

		        int		iRetVal = 0;
		        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
			        MB_ICONWARNING | MB_OK, &iRetVal)));
	        }
		}
		break;

    case CERTTMPL_CERT_TEMPLATE:
        ASSERT (0);
        break;

	default:
		ASSERT (0);
		hr = E_UNEXPECTED;
		break;
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyRefresh\n");
	return hr;
}

void CCertTmplComponent::SetTextNotAvailable ()
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	m_szDisplayInfoResult.LoadString (IDS_NOT_AVAILABLE);
}


HRESULT	CCertTmplComponent::DeleteCookie (CCertTmplCookie* pCookie, LPDATAOBJECT pDataObject, bool bRequestConfirmation, bool bIsMultipleSelect)
{
	_TRACE (1, L"Entering CCertTmplComponent::DeleteCookie\n");
	HRESULT			hr = S_OK;
	CString			text;
	CString			caption;
	int				iRetVal = IDYES;
	CWaitCursor		waitCursor;

	switch (pCookie->m_objecttype)
	{
    case CERTTMPL_CERT_TEMPLATE:
		{
			CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
			ASSERT (pCertTemplate);
			if ( pCertTemplate )
			{
				if ( bRequestConfirmation )
				{
					if ( bIsMultipleSelect )
					{
						VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CERT_TEMPLATE_MULTI));
					}
					else
						VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CERT_TEMPLATE));
					VERIFY (caption.LoadString (IDS_CERTTMPL));
					hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
					ASSERT (SUCCEEDED (hr));
				}

				if ( IDYES == iRetVal )
				{
					hr = DeleteCertTemplateFromResultPane (pCertTemplate, pDataObject);
				}
				else
					hr = E_FAIL;
			}
		}
        break;

	default:
		ASSERT (0);
		hr = E_UNEXPECTED;
		break;
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::DeleteCookie\n");
	return hr;
}



HRESULT CCertTmplComponent::DeleteCertTemplateFromResultPane (CCertTemplate* pCertTemplate, LPDATAOBJECT /*pDataObject*/)
{
	_TRACE (1, L"Entering CCertTmplComponent::DeleteCertTemplateFromResultPane\n");
	HRESULT			hr = S_OK;
    hr = pCertTemplate->Delete ();

    if ( SUCCEEDED (hr) )
    {
        CCertTmplComponentData& dataref = QueryComponentDataRef ();

        POSITION    prevPos = 0;
        POSITION pos = 0;
        for (pos = dataref.m_globalFriendlyNameList.GetHeadPosition (); pos;)
        {
            prevPos = pos;
            if ( pCertTemplate->GetDisplayName () == 
                    dataref.m_globalFriendlyNameList.GetNext (pos) )
            {
                dataref.m_globalFriendlyNameList.RemoveAt (prevPos);
                break;
            }
        }

        for (pos = dataref.m_globalTemplateNameList.GetHeadPosition (); pos;)
        {
            prevPos = pos;
            if ( pCertTemplate->GetTemplateName () == 
                    dataref.m_globalTemplateNameList.GetNext (pos) )
            {
                dataref.m_globalTemplateNameList.RemoveAt (prevPos);
                break;
            }
        }

    }
    else
    {
        CString caption;
        CString text;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        text.FormatMessage (IDS_CANNOT_DELETE_CERT_TEMPLATE, GetSystemMessage (hr));

		int		iRetVal = 0;
		VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
			MB_ICONWARNING | MB_OK, &iRetVal)));
    }
	_TRACE (-1, L"Leaving CCertTmplComponent::DeleteCertTemplateFromResultPane\n");
	return hr;
}


HRESULT CCertTmplComponent::OnNotifyDelete (LPDATAOBJECT pDataObject)
{
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	long			hint = 0;
	CWaitCursor		waitCursor;

	CCertTmplCookie* pCookie =
			QueryComponentDataRef ().ConvertCookie (pDataObject);
	if ( pCookie )
	{
		if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
		{

			// Is multiple select, get all selected items and paste each one
			CCertTemplatesDataObject* pDO = dynamic_cast <CCertTemplatesDataObject*>(pDataObject);
			ASSERT (pDO);
			if ( pDO )
			{
				// Is multiple select, get all selected items and delete - confirm
				// first deletion only.
				bool	bRequestConfirmation = true;
				pDO->Reset();
				while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE &&
						SUCCEEDED (hr) )
				{
					hr = DeleteCookie (pCookie, pDataObject, bRequestConfirmation, true);
					bRequestConfirmation = false;
				}

                hr = m_pConsole->UpdateAllViews (pDataObject, 0, hint);
			}

		}
		else
		{
			// In that event, we don't want a confirmation message.
			hr = DeleteCookie (pCookie, pDataObject, true, false);
			if ( SUCCEEDED (hr) )
				hr = m_pConsole->UpdateAllViews (pDataObject, 0, hint);
		}
	}

	return hr;
}



// This compare is used to sort the items in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort () was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing.

STDMETHODIMP CCertTmplComponent::Compare (RDCOMPARE* prdc, int* pnResult)
{
//	_TRACE (1, L"Entering CCertTmplComponent::Compare\n");
	if ( !prdc || !pnResult )
		return E_POINTER;

	HRESULT						hr = S_OK;

	if ( RDCI_ScopeItem & prdc->prdch1->dwFlags )
	{
	}
	else
	{
        CCertTmplCookie* pCookie = reinterpret_cast <CCertTmplCookie*> (prdc->prdch1->cookie);
        ASSERT (pCookie);
        if ( !pCookie )
            return E_UNEXPECTED;

        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            {
	            CCertTemplate* pCertTemplateA = reinterpret_cast <CCertTemplate*> (prdc->prdch1->cookie);
	            CCertTemplate* pCertTemplateB = reinterpret_cast <CCertTemplate*> (prdc->prdch2->cookie);
	            switch ( prdc->nColumn )
	            {
	            case COLNUM_CERT_TEMPLATE_OBJECT:
		            *pnResult = LocaleStrCmp (pCertTemplateA->GetDisplayName (), pCertTemplateB->GetDisplayName ());
		            break;

	            case COLNUM_CERT_TEMPLATE_TYPE:
		            if ( pCertTemplateA->GetType () == pCertTemplateB->GetType () )
                        *pnResult = 0;
                    else if ( pCertTemplateA->GetType () > pCertTemplateB->GetType () )
                        *pnResult = 1;
                    else
                        *pnResult = -1;
		            break;

	            case COLNUM_CERT_TEMPLATE_VERSION:
                    {
                        // Sort first on major version, then on minor version
                        *pnResult = 0;
                        DWORD dwMajorVersionA = 0;
                        hr = pCertTemplateA->GetMajorVersion (dwMajorVersionA);
                        if ( SUCCEEDED (hr) )
                        {
                            DWORD dwMajorVersionB = 0;
                            hr = pCertTemplateB->GetMajorVersion (dwMajorVersionB);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( dwMajorVersionA == dwMajorVersionB )
                                {
                                    DWORD dwMinorVersionA = 0;
                                    hr = pCertTemplateA->GetMinorVersion (dwMinorVersionA);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        DWORD dwMinorVersionB = 0;
                                        hr = pCertTemplateB->GetMinorVersion (dwMinorVersionB);
                                        if ( SUCCEEDED (hr) )
                                        {
                                            if ( dwMinorVersionA == dwMinorVersionB )
                                                *pnResult = 0;
                                            else if ( dwMinorVersionA > dwMinorVersionB )
                                                *pnResult = 1;
                                            else
                                                *pnResult = -1;
                                        }
                                    }
                                }
                                else if ( dwMajorVersionA > dwMajorVersionB )
                                    *pnResult = 1;
                                else
                                    *pnResult = -1;
                            }
                        }
                    }
                    break;

                case COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS:
                    if ( pCertTemplateA->GoodForAutoEnrollment () && 
                            pCertTemplateB->GoodForAutoEnrollment () )
                    {
                        *pnResult = 0;
                    }
                    else if ( pCertTemplateA->GoodForAutoEnrollment () && 
                            !pCertTemplateB->GoodForAutoEnrollment () )
                    {
                        *pnResult = 1;
                    }
                    else
                        *pnResult = 0;
                    break;

                default:
                    ASSERT (0);
                    break;
	            }
            }
            break;

		default:
			ASSERT (0);
			break;
		}
	}

//	_TRACE (-1, L"Leaving CCertTmplComponent::Compare\n");
	return hr;
}


/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify (MMCN_COLUMN_CLICK)
HRESULT CCertTmplComponent::OnNotifyColumnClick (LPDATAOBJECT /*pDataObject*/, LPARAM iColumn, LPARAM uFlags)
{
	_TRACE (1, L"Entering CCertTmplComponent::OnNotifyColumnClick\n");

	IResultData*	pResultData = 0;
	HRESULT			hr = m_pConsole->QueryInterface (
			IID_PPV_ARG (IResultData, &pResultData));
	if ( SUCCEEDED (hr) )
	{
		hr = pResultData->Sort ((DWORD)iColumn, (DWORD)uFlags, 0);
        _TRACE (0, L"IResultData::Sort () returned: 0x%x\n", hr);

		pResultData->Release ();
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyColumnClick\n");
	return hr;
}


STDMETHODIMP CCertTmplComponent::Notify (LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch (event)
    {
		case MMCN_CUTORMOVE:
			hr = OnNotifyCutOrMove (arg);
			break;

		case MMCN_QUERY_PASTE:
			hr = OnNotifyQueryPaste (pDataObject, arg, param);
			break;

		case MMCN_PASTE:
			hr = OnNotifyPaste (pDataObject, arg, param);
			break;

	    case MMCN_SHOW:
			{
				CCookie* pCookie = NULL;
				hr = ::ExtractData (pDataObject,
								  CDataObject::m_CFRawCookie,
								  &pCookie,
								  sizeof(pCookie));
				if ( SUCCEEDED (hr) )
				{
					hr = Show (ActiveBaseCookie (pCookie), arg,
							(HSCOPEITEM) param, pDataObject);
				}
			}
			break;

        case MMCN_RENAME:
            hr = OnNotifyRename (pDataObject, arg, param);
            break;

        default:
			hr = CComponent::Notify (pDataObject, event, arg, param);
			break;
	}

	return hr;
}


HRESULT CCertTmplComponent::OnNotifySnapinHelp (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertTmplComponent::OnNotifySnapinHelp\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));

	CComQIPtr<IDisplayHelp,&IID_IDisplayHelp>	spDisplayHelp = m_pConsole;
	if ( !spDisplayHelp )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	CString strHelpTopic;

    UINT nLen = ::GetSystemWindowsDirectory (strHelpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
    strHelpTopic.ReleaseBuffer();
    if (0 == nLen)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    strHelpTopic += CERTTMPL_HELP_PATH;
    strHelpTopic += CERTTMPL_HTML_HELP_FILE;
    strHelpTopic += L"::/";

    CCertTmplComponentData&	compData = QueryComponentDataRef ();
	CCertTmplCookie* pCookie = compData.ConvertCookie (pDataObject);
	if ( pCookie )
	{
		switch (pCookie->m_objecttype)
		{
        case CERTTMPL_SNAPIN:
        case CERTTMPL_CERT_TEMPLATE:
        default:
            strHelpTopic += CERTTMPL_HTML_TOP_NODE;
            break;
        }
    }

 	HRESULT hr = spDisplayHelp->ShowTopic (T2OLE ((PWSTR)(PCWSTR) strHelpTopic));
	if ( FAILED (hr) )
	{
        CString caption;
        CString text;

        VERIFY (caption.LoadString (IDS_CERTTMPL));

        text.FormatMessage (IDS_CANT_DISPLAY_SNAPIN_HELP_TOPIC, strHelpTopic, 
				GetSystemMessage (hr));

		int		iRetVal = 0;
		VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
			MB_ICONWARNING | MB_OK, &iRetVal)));
	}


	_TRACE (-1, L"Leaving CCertTmplComponent::OnNotifySnapinHelp\n");
	return hr;
}

void CCertTmplComponent::DisplayAccessDenied ()
{
	DWORD	dwErr = GetLastError ();
	ASSERT (E_ACCESSDENIED == dwErr);
	if ( E_ACCESSDENIED == dwErr )
	{
		LPVOID lpMsgBuf;
			
		FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				NULL,
				GetLastError (),
				MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				 (PWSTR) &lpMsgBuf,    0,    NULL );
			
		// Display the string.
		CString	caption;
		VERIFY (caption.LoadString (IDS_CERTTMPL));
		int		iRetVal = 0;
		VERIFY (SUCCEEDED (m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
			MB_ICONWARNING | MB_OK, &iRetVal)));

		// Free the buffer.
		LocalFree (lpMsgBuf);
	}
}

HRESULT CCertTmplComponent::OnNotifyPaste (LPDATAOBJECT /*pDataObject*/, LPARAM /*arg*/, LPARAM /*param*/)
{
	return E_NOTIMPL;
}


HRESULT CCertTmplComponent::OnNotifyQueryPaste(LPDATAOBJECT /*pDataObject*/, LPARAM /*arg*/, LPARAM /*param*/)
{
	return E_NOTIMPL;
}


STDMETHODIMP CCertTmplComponent::GetResultViewType(MMC_COOKIE cookie,
		BSTR* ppViewType,
		long* pViewOptions) 
{
	CCertTmplCookie* pScopeCookie = reinterpret_cast <CCertTmplCookie*> (cookie);
	if ( pScopeCookie )
	{
		switch (pScopeCookie->m_objecttype)
		{
        case CERTTMPL_SNAPIN:
			*pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
			break;

        case CERTTMPL_CERT_TEMPLATE:
		default:
			break;
		}
	}
    else
        *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;

    *ppViewType = NULL;
    return S_FALSE;
}


STDMETHODIMP CCertTmplComponent::Initialize(LPCONSOLE lpConsole)
{
	_TRACE (1, L"Entering CCertTmplComponent::Initialize\n");
	HRESULT	 hr = CComponent::Initialize (lpConsole);
	if ( SUCCEEDED (hr) )
	{
		ASSERT (m_pHeader);
		QueryComponentDataRef ().m_pHeader = m_pHeader;

		if ( lpConsole )
		{
			if ( QueryComponentDataRef ().m_pComponentConsole )
				SAFE_RELEASE (QueryComponentDataRef ().m_pComponentConsole);
			QueryComponentDataRef ().m_pComponentConsole = m_pConsole;
			QueryComponentDataRef ().m_pComponentConsole->AddRef ();
		}
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::Initialize\n");
	return hr;
}


HRESULT CCertTmplComponent::LoadColumnsFromArrays (CertTmplObjectType objecttype )
{
	_TRACE (1, L"Entering CCertTmplComponent::LoadColumnsFromArrays\n");
    ASSERT (m_pHeader);

	CString str;
	for ( INT i = 0; 0 != m_Columns[objecttype][i]; i++)
	{
		VERIFY(str.LoadString (m_Columns[objecttype][i]));
		m_pHeader->InsertColumn(i, const_cast<PWSTR>((PCWSTR)str), LVCFMT_LEFT,
			m_ColumnWidths[objecttype][i]);
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::LoadColumnsFromArrays\n");
	return S_OK;
}

HRESULT CCertTmplComponent::SaveWidths(CCertTmplCookie * pCookie)
{
	_TRACE (1, L"Entering CCertTmplComponent::SaveWidths\n");
	HRESULT	hr = S_OK;

	m_fDirty = TRUE;

	ASSERT (pCookie);
	if ( pCookie )
	{
		switch (m_pViewedCookie->m_objecttype)
		{
		case CERTTMPL_SNAPIN:
			{
				const UINT* pColumns = m_Columns[m_pViewedCookie->m_objecttype];
				ASSERT(pColumns);
				int    nWidth = 0;

				for (UINT iIndex = 0; iIndex < pColumns[iIndex]; iIndex++)
				{
					hr = m_pHeader->GetColumnWidth ((int) iIndex, &nWidth);
					if ( SUCCEEDED (hr) )
					{
						m_ColumnWidths[m_pViewedCookie->m_objecttype][iIndex] =
								(UINT) nWidth;
					}
					else
						break;
				}
			}
			break;

		default:
			ASSERT (0);
			break;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertTmplComponent::SaveWidths\n");
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
#define _dwMagicword	10000  // Internal version number
STDMETHODIMP CCertTmplComponent::Load(IStream __RPC_FAR *pIStream)
{
	_TRACE (1, L"Entering CCertTmplComponent::Load\n");
	HRESULT hr = S_OK;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword = 0;
	hr = pIStream->Read (&dwMagicword, sizeof(dwMagicword), NULL);
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		_TRACE(0, L"INFO: CCertTmplComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	int	numCols = 0;

	for (int iIndex = 0; iIndex < CERTTMPL_NUMTYPES && SUCCEEDED (hr); iIndex++)
	{
		switch (iIndex)
		{
		case CERTTMPL_SNAPIN:
            numCols = CERT_TEMPLATES_NUM_COLS;
			break;;

        case CERTTMPL_CERT_TEMPLATE:
            continue;

		default:
			ASSERT (0);
			break;
		}

		for (int colNum = 0; colNum < numCols; colNum++)
		{
			hr = pIStream->Read (&(m_ColumnWidths[iIndex][colNum]),
					sizeof (UINT), NULL);
			ASSERT (SUCCEEDED (hr));
			if ( FAILED(hr) )
			{
				break;
			}
		}
	}
#endif
	_TRACE (-1, L"Leaving CCertTmplComponent::Load\n");
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCertTmplComponent::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	_TRACE (1, L"Entering CCertTmplComponent::Save\n");
	HRESULT hr = S_OK;


#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr (pIStream);

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write (&dwMagicword, sizeof(dwMagicword), NULL);
	ASSERT (SUCCEEDED (hr));
	if ( FAILED (hr) )
		return hr;


	int	numCols = 0;

	for (int iIndex = 0; iIndex < CERTTMPL_NUMTYPES && SUCCEEDED (hr); iIndex++)
	{
		switch (iIndex)
		{
		case CERTTMPL_SNAPIN:
            numCols = CERT_TEMPLATES_NUM_COLS;
			break;;

        case CERTTMPL_CERT_TEMPLATE:
            continue;

		default:
			ASSERT (0);
			break;
		}

		for (int colNum = 0; colNum < numCols; colNum++)
		{
			hr = pIStream->Write (&(m_ColumnWidths[iIndex][colNum]),
					sizeof (UINT), NULL);
			ASSERT (SUCCEEDED (hr));
			if ( FAILED(hr) )
			{
				ASSERT (FALSE);
				break;
			}
		}
	}
#endif

	_TRACE (-1, L"Leaving CCertTmplComponent::Save\n");
	return S_OK;
}

HRESULT CCertTmplComponent::OnNotifyCutOrMove(LPARAM arg)
{
	_TRACE (1, L"Entering CCertTmplComponent::OnNotifyCutOrMove\n");
	if ( !arg )
		return E_POINTER;

	LPDATAOBJECT pDataObject = reinterpret_cast <IDataObject*> (arg);
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_UNEXPECTED;


	HRESULT			hr = S_OK;

	CCertTmplCookie* pCookie =
			QueryComponentDataRef ().ConvertCookie (pDataObject);
	if ( pCookie )
	{
		if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
		{
			CCertTemplatesDataObject* pDO = dynamic_cast <CCertTemplatesDataObject*>(pDataObject);
			ASSERT (pDO);
			if ( pDO )
			{
				pDO->Reset();
				while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
				{
					hr = DeleteCookie (pCookie, pDataObject, false, true);
				}
			}
			else
				hr = E_FAIL;
		}
		else
		{
			hr = DeleteCookie (pCookie, pDataObject, false, false);
		}
		if ( SUCCEEDED (hr) )
			RefreshResultPane (false);
	}

	_TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyCutOrMove\n");
	return hr;
}



CCertTmplCookie* CCertTmplComponent::ConvertCookie(LPDATAOBJECT pDataObject)
{
	return QueryComponentDataRef ().ConvertCookie (pDataObject);
}



HRESULT CCertTmplComponent::RefreshResultItem (CCertTmplCookie* pCookie)
{
	_TRACE (1, L"Entering CCertTmplComponent::RefreshResultItem\n");
	ASSERT (pCookie);
	if ( !pCookie )
		return E_POINTER;

	HRESULT	hr = S_OK;
	HRESULTITEM	itemID = 0;

	ASSERT (m_pResultData);
	if ( m_pResultData )
	{
		pCookie->Refresh ();
		hr = m_pResultData->FindItemByLParam ( (LPARAM) pCookie, &itemID);
		ASSERT (SUCCEEDED (hr));
		if ( SUCCEEDED (hr) )
		{
			hr = m_pResultData->UpdateItem (itemID);
			ASSERT (SUCCEEDED (hr));
		}
	}
	else
		hr = E_FAIL;

	_TRACE (-1, L"Leaving CCertTmplComponent::RefreshResultItem\n");
	return hr;
}


/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CCertTmplComponent::OnPropertyChange (LPARAM param)
{
	return  QueryComponentDataRef ().OnPropertyChange (param);
}

HRESULT CCertTmplComponent::AddEnterpriseTemplates ()
{
	_TRACE (1, L"Entering CCertTmplComponent::AddEnterpriseTemplates\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    HRESULT	                hr = S_OK;
    CWaitCursor	            cursor;
	CComPtr<IADsPathname>   spPathname;

	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);
		hr = spPathname->Set(const_cast <PWSTR> (CERTTMPL_LDAP),
							ADS_SETTYPE_PROVIDER);
		if ( SUCCEEDED (hr) )
		{
			//
			// Open the root DSE object
			//
			hr = spPathname->AddLeafElement(const_cast <PWSTR> (CERTTMPL_ROOTDSE));
			if ( SUCCEEDED (hr) )
			{
				BSTR bstrFullPath = 0;
				hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				if ( SUCCEEDED (hr) )
				{
					CComPtr<IADs> spRootDSEObject;
					VARIANT varNamingContext;


					hr = ADsGetObject (
			              bstrFullPath,
						  IID_PPV_ARG (IADs, &spRootDSEObject));
					if ( SUCCEEDED (hr) )
					{
                        ASSERT (!!spRootDSEObject);
						//
						// Get the configuration naming context from the root DSE
						//
						hr = spRootDSEObject->Get(const_cast <PWSTR> (CERTTMPL_CONFIG_NAMING_CONTEXT),
											 &varNamingContext);
						if ( SUCCEEDED (hr) )
						{
							hr = spPathname->Set(V_BSTR(&varNamingContext),
												ADS_SETTYPE_DN);
							if ( SUCCEEDED (hr) )
							{
                                hr = spPathname->AddLeafElement (L"CN=Services");
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = spPathname->AddLeafElement (L"CN=Public Key Services");
                                    if ( SUCCEEDED (hr) )
                                    {
                                        hr = spPathname->AddLeafElement (L"CN=Certificate Templates");
                                        if ( SUCCEEDED (hr) )
                                        {
				                            BSTR bstrCertTemplatePath = 0;
				                            hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrCertTemplatePath);
				                            if ( SUCCEEDED (hr) )
				                            {
					                            CComPtr<IDirectoryObject> spTemplateContObj;

					                            hr = ADsGetObject (
			                                          bstrCertTemplatePath,
						                              IID_PPV_ARG (IDirectoryObject, &spTemplateContObj));
					                            if ( SUCCEEDED (hr) )
					                            {
                                                    hr = EnumerateTemplates (spTemplateContObj, bstrCertTemplatePath);
                                                    if ( SUCCEEDED (hr) )
                                                    {
					                                    m_currResultNodeType = CERTTMPL_CERT_TEMPLATE;
					                                    hr = m_pResultData->Sort (COLNUM_CERT_TEMPLATE_OBJECT, 0, 0);
                                                    }
                                                }
                                                else
                                                {
                                                    _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrCertTemplatePath, hr);
                                                }

                                                SysFreeString (bstrCertTemplatePath);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADs::Get (%s) failed: 0x%x\n", CERTTMPL_CONFIG_NAMING_CONTEXT, hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath, hr);
                    }
                }
            }
        }
    }
    else
        hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertTmplComponent::AddEnterpriseTemplates\n");
	return hr;
}


HRESULT CCertTmplComponent::EnumerateTemplates (
        IDirectoryObject* pTemplateContObj, 
        const BSTR bszTemplateContainerPath)
{
    _TRACE (1, L"Entering CCertTmplComponent::EnumerateTemplates\n");
    CCertTmplComponentData& dataRef = QueryComponentDataRef ();
	CWaitCursor	            cursor;

    dataRef.m_fUseCache = false;

    // Bug 243609	CertServer: Wrong count of templates displayed in the MMC
    dataRef.m_dwNumCertTemplates = 0;
    dataRef.m_globalTemplateNameList.RemoveAll ();
    dataRef.m_globalFriendlyNameList.RemoveAll ();
	CComPtr<IDirectorySearch>   spDsSearch;
	HRESULT hr = pTemplateContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spDsSearch);
		ADS_SEARCHPREF_INFO pSearchPref[1];
		DWORD dwNumPref = 1;

		pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
		pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

		hr = spDsSearch->SetSearchPreference(
				 pSearchPref,
				 dwNumPref
				 );
		if ( SUCCEEDED (hr) )
		{
			static const DWORD	cAttrs = 2;
            static PWSTR	    rgszAttrList[cAttrs] = {L"displayName", L"cn"};
			ADS_SEARCH_HANDLE	hSearchHandle = 0;
            wstring             strQuery;
            ADS_SEARCH_COLUMN   Column;

            Column.pszAttrName = 0;
            strQuery = L"objectClass=pKICertificateTemplate";

			hr = spDsSearch->ExecuteSearch(
								 const_cast <PWSTR>(strQuery.c_str ()),
								 rgszAttrList,
								 cAttrs,
								 &hSearchHandle
								 );
			if ( SUCCEEDED (hr) )
			{
                CCookie&	rootCookie = dataRef.QueryBaseRootCookie ();

				while ((hr = spDsSearch->GetNextRow (hSearchHandle)) != S_ADS_NOMORE_ROWS )
				{
                    if (FAILED(hr))
                        continue;

					//
					// Getting current row's information
					//
					hr = spDsSearch->GetColumn(
							 hSearchHandle,
							 rgszAttrList[0],
							 &Column
							 );
					if ( SUCCEEDED (hr) )
					{
                        CString strDisplayName = Column.pADsValues->CaseIgnoreString;

						spDsSearch->FreeColumn (&Column);
						Column.pszAttrName = NULL;

					    hr = spDsSearch->GetColumn(
							     hSearchHandle,
							     rgszAttrList[1],
							     &Column
							     );
					    if ( SUCCEEDED (hr) )
					    {
                            CString strTemplateName = Column.pADsValues->CaseIgnoreString;

						    spDsSearch->FreeColumn (&Column);
						    Column.pszAttrName = NULL;


	                        CComPtr<IADsPathname> spPathname;
	                        //
	                        // Constructing the directory paths
	                        //
	                        hr = CoCreateInstance(
				                        CLSID_Pathname,
				                        NULL,
				                        CLSCTX_ALL,
				                        IID_PPV_ARG (IADsPathname, &spPathname));
	                        if ( SUCCEEDED (hr) )
	                        {
                                ASSERT (!!spPathname);
		                        hr = spPathname->Set(const_cast <PWSTR> (bszTemplateContainerPath),
							                        ADS_SETTYPE_FULL);
		                        if ( SUCCEEDED (hr) )
		                        {
			                        //
			                        // Open the root DSE object
			                        //
			                        hr = spPathname->AddLeafElement(const_cast <PWSTR> ((PCWSTR) strTemplateName));
			                        if ( SUCCEEDED (hr) )
			                        {
				                        BSTR bstrFullPath = 0;
				                        hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				                        if ( SUCCEEDED (hr) )
				                        {
						                    CCertTemplate* pCertTemplate = 
								                    new CCertTemplate (strDisplayName, strTemplateName,
                                                            bstrFullPath, false,
                                                            dataRef.m_fUseCache);
						                    if ( pCertTemplate )
						                    {
                                                dataRef.m_fUseCache = true;                                    

							                    rootCookie.m_listResultCookieBlocks.AddHead (pCertTemplate);

							                    RESULTDATAITEM			rdItem;
							                    ::ZeroMemory (&rdItem, sizeof (rdItem));
							                    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
							                    rdItem.nCol = 0;
							                    rdItem.str = MMC_CALLBACK;
                                                if ( 1 == pCertTemplate->GetType () )
							                        rdItem.nImage = iIconCertTemplateV1;
                                                else
							                        rdItem.nImage = iIconCertTemplateV2;
							                    rdItem.lParam = (LPARAM) pCertTemplate;
							                    pCertTemplate->m_resultDataID = m_pResultData;
							                    hr = m_pResultData->InsertItem (&rdItem);
							                    if ( FAILED (hr) )
							                    {
								                    _TRACE (0, L"IResultData::InsertItem failed: 0x%x\n", hr);
								                    hr = S_OK;
								                    break;
							                    }
							                    else
                                                {
                                                    dataRef.m_dwNumCertTemplates++;
                                                    dataRef.m_globalTemplateNameList.AddTail (strTemplateName);
                                                    dataRef.m_globalFriendlyNameList.AddHead (
                                                        pCertTemplate->GetDisplayName ());    
                                                }
						                    }
						                    else
						                    {
							                    hr = E_OUTOFMEMORY;
							                    break;
						                    }

                                            SysFreeString (bstrFullPath);
                                        }
                                    }
                                }
                            }

                        }
					}
					else if ( hr != E_ADS_COLUMN_NOT_SET )
					{
						break;
					}
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::GetColumn () failed: 0x%x\n", hr);
                    }
                }
			}
            else
            {
                _TRACE (0, L"IDirectorySearch::ExecuteSearch () failed: 0x%x\n", hr);
            }

            spDsSearch->CloseSearchHandle(hSearchHandle);
		}
        else
        {
            _TRACE (0, L"IDirectorySearch::SetSearchPreference () failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::EnumerateTemplates: 0x%x\n", hr);
    dataRef.m_fUseCache = false;

    return hr;
}


HRESULT CCertTmplComponent::OnNotifyRename(LPDATAOBJECT pDataObject, LPARAM /*arg*/, LPARAM param)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifyRename\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_FALSE;

    CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            {
                CString newName = (LPOLESTR) param;

                newName.TrimLeft ();
                newName.TrimRight ();

                if ( !newName.IsEmpty () )
                {
                    CCertTmplComponentData& dataref = QueryComponentDataRef ();
                    POSITION                pos = 0;
                    bool                    bFound = false;
                    for (pos = dataref.m_globalFriendlyNameList.GetHeadPosition (); pos;)
                    {
                        if ( !_wcsicmp (newName, dataref.m_globalFriendlyNameList.GetNext (pos)) )
                        {
                            CString caption;
                            CString text;

                            VERIFY (caption.LoadString (IDS_CERTTMPL));
                            text.FormatMessage (IDS_FRIENDLY_NAME_ALREADY_USED, newName);

                            int     iRetVal = 0;
                            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                    MB_OK, &iRetVal)));
                            bFound = true;
                            break;
                        }
                    }

                    if ( !bFound )
                    {
                        CCertTemplate* pCertTemplate = dynamic_cast<CCertTemplate*> (pCookie);
                        if ( pCertTemplate )
                        {
                            hr = pCertTemplate->SetDisplayName (newName);
                            if ( SUCCEEDED (hr) )
                            {
                                hr = pCertTemplate->SaveChanges ();
                                if ( FAILED (hr) )
                                {
                                    CString caption;
                                    CString text;

                                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                                    text.FormatMessage (IDS_UNABLE_TO_SAVE_CERT_TEMPLATE_CHANGES, GetSystemMessage (hr));

                                    int     iRetVal = 0;
                                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                            MB_ICONWARNING | MB_OK, &iRetVal)));
                                }
                            }
                            else
                            {
                                CString caption;
                                CString text;

                                VERIFY (caption.LoadString (IDS_CERTTMPL));
                                text.FormatMessage (IDS_CANNOT_CHANGE_DISPLAY_NAME, hr);

                                int     iRetVal = 0;
                                VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                        MB_ICONWARNING | MB_OK, &iRetVal)));
                            }
                        }
                    }
                }
                else
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    VERIFY (text.LoadString (IDS_MUST_TYPE_TEMPLATE_DISPLAY_NAME));
                    int     iRetVal = 0;
                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                            MB_ICONWARNING | MB_OK, &iRetVal)));
                    hr = S_FALSE;
                }
            }
            break;

        default:
            break;
        }
    }

	if ( !SUCCEEDED (hr) )
		hr = S_FALSE;

    _TRACE(-1, L"Leaving CCertTmplComponent::OnNotifyRename: 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\certtmpl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       CertTmpl.cpp
//
//  Contents:   Implementation of DLL Exports
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#define INITGUID
#pragma warning(push,3)
#include <initguid.h>
#pragma warning(pop)
#include "CertTmpl_i.c"
#include "about.h"      // CCertTemplatesAbout
#include "compdata.h" // CCertTmplSnapin
#include "uuids.h"

#pragma warning(push,3)
#include <ntverp.h>     // VER_PRODUCTVERSION_STR
#include <typeinfo.h>

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <svcguid.h>
#include <winldap.h>



#pragma warning(pop)
#include "chooser.cpp"

#include "ShellExt.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST	    g_policyOIDList;
USE_HANDLE_MACROS ("CERTTMPL (CertTmpl.cpp)")


//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[CERTTMPL_NUMTYPES] =
{
    { // CERTTMPL_SNAPIN
        structuuidNodetypeSnapin,
        lstruuidNodetypeSnapin    },
    {  // CERT_TEMPLATE
        structuuidNodetypeCertTemplate,
        lstruuidNodetypeCertTemplate  }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = CERTTMPL_NUMTYPES;

const CLSID CLSID_CertTemplateShellExt = /* {11BDCE06-D55C-44e9-BC0B-8655F89E8CC5} */
{ 0x11bdce06, 0xd55c, 0x44e9, { 0xbc, 0xb, 0x86, 0x55, 0xf8, 0x9e, 0x8c, 0xc5 } };


HINSTANCE   g_hInstance = 0;
CComModule  _Module;

BEGIN_OBJECT_MAP (ObjectMap)
    OBJECT_ENTRY (CLSID_CertTemplatesSnapin, CCertTmplSnapin)
    OBJECT_ENTRY (CLSID_CertTemplatesAbout, CCertTemplatesAbout)
	OBJECT_ENTRY(CLSID_CertTemplateShellExt, CCertTemplateShellExt)
END_OBJECT_MAP ()

class CCertTmplApp : public CWinApp
{
public:
    CCertTmplApp ();
    virtual ~CCertTmplApp ();
    virtual BOOL InitInstance ();
    virtual int ExitInstance ();
private:
};

CCertTmplApp theApp;

CCertTmplApp::CCertTmplApp ()
{
}

CCertTmplApp::~CCertTmplApp ()
{
}

BOOL CCertTmplApp::InitInstance ()
{
#ifdef _MERGE_PROXYSTUB
    hProxyDll = m_hInstance;

#endif
    g_hInstance = m_hInstance;
    AfxSetResourceHandle (m_hInstance);
    _Module.Init (ObjectMap, m_hInstance);

    AfxInitRichEdit();

#if DBG
    CheckDebugOutputLevel ();
#endif

    SHFusionInitializeFromModuleID (m_hInstance, 2);

    return CWinApp::InitInstance ();
}

int CCertTmplApp::ExitInstance ()
{
    SHFusionUninitialize();

    while ( !g_policyOIDList.IsEmpty () )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.RemoveHead ();
        if ( pPolicyOID )
            delete pPolicyOID;
    }

    _Module.Term ();
    return CWinApp::ExitInstance ();
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    return (AfxDllCanUnloadNow ()==S_OK && _Module.GetLockCount ()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject (rclsid, riid, ppv);
}





/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer (TRUE);
    ASSERT (SUCCEEDED (hr));
    if ( E_ACCESSDENIED == hr )
    {
        CString caption;
        CString text;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_REGISTER_CERTTMPL));
        VERIFY (text.LoadString (IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTTMPL));

        MessageBox (NULL, text, caption, MB_OK);
        return hr;
    }
    try
    {
        CString         strGUID;
        CString         snapinName;
        AMC::CRegKey    rkSnapins;
        BOOL            fFound = rkSnapins.OpenKeyEx (HKEY_LOCAL_MACHINE, SNAPINS_KEY);
        ASSERT (fFound);
        if ( fFound )
        {
            {
                AMC::CRegKey    rkCertTmplSnapin;
                hr = GuidToCString (&strGUID, CLSID_CertTemplatesSnapin);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }
                rkCertTmplSnapin.CreateKeyEx (rkSnapins, strGUID);
                ASSERT (rkCertTmplSnapin.GetLastError () == ERROR_SUCCESS);
                rkCertTmplSnapin.SetString (g_szNodeType, g_aNodetypeGuids[CERTTMPL_SNAPIN].bstr);
                VERIFY (snapinName.LoadString (IDS_CERTTMPL_REGISTRY));
                rkCertTmplSnapin.SetString (g_szNameString, (PCWSTR) snapinName);
                hr = GuidToCString (&strGUID, CLSID_CertTemplatesAbout);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }
                rkCertTmplSnapin.SetString (L"About", strGUID);
                rkCertTmplSnapin.SetString (L"Provider", L"Microsoft");
                size_t  len = strlen (VER_PRODUCTVERSION_STR);
                PWSTR   pszVer = new WCHAR[(len+1) * sizeof (WCHAR)];
                if ( pszVer )
                {
                    ::ZeroMemory (pszVer, (len+1) * sizeof (WCHAR));
                    len = mbstowcs (pszVer, VER_PRODUCTVERSION_STR, len);

                    rkCertTmplSnapin.SetString (L"Version", pszVer);
                    delete [] pszVer;
                }


                AMC::CRegKey rkCertTmplMgrStandalone;
                rkCertTmplMgrStandalone.CreateKeyEx (rkCertTmplSnapin, g_szStandAlone);
                ASSERT (rkCertTmplMgrStandalone.GetLastError () == ERROR_SUCCESS);


                AMC::CRegKey rkMyNodeTypes;
                rkMyNodeTypes.CreateKeyEx (rkCertTmplSnapin, g_szNodeTypes);
                ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
                AMC::CRegKey rkMyNodeType;

                for (int i = CERTTMPL_SNAPIN; i < CERTTMPL_NUMTYPES; i++)
                {
                    rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
                    ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
                    rkMyNodeType.CloseKey ();
                }

				//
				// BryanWal 5/18/00
				// 94793: MUI: MMC: Certificates snap-in stores its display 
				//				information in the registry
				//
				// MMC now supports NameStringIndirect
				//
				TCHAR achModuleFileName[MAX_PATH+20];
				if (0 < ::GetModuleFileName(
							 AfxGetInstanceHandle(),
							 achModuleFileName,
							 sizeof(achModuleFileName)/sizeof(TCHAR) ))
				{
					CString strNameIndirect;
					strNameIndirect.Format( L"@%s,-%d",
											achModuleFileName,
											IDS_CERTTMPL_REGISTRY);
					rkCertTmplSnapin.SetString( L"NameStringIndirect",
											strNameIndirect );
				}

                rkCertTmplSnapin.CloseKey ();
            }

            AMC::CRegKey rkNodeTypes;
            fFound = rkNodeTypes.OpenKeyEx (HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
            ASSERT (fFound);
            if ( fFound )
            {
                AMC::CRegKey rkNodeType;

                for (int i = CERTTMPL_SNAPIN; i < CERTTMPL_NUMTYPES; i++)
                {
                    rkNodeType.CreateKeyEx (rkNodeTypes, g_aNodetypeGuids[i].bstr);
                    ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
                    rkNodeType.CloseKey ();
                }


                rkNodeTypes.CloseKey ();
            }
            else
                return SELFREG_E_CLASS;
        }
        else
            return SELFREG_E_CLASS;
    }
    catch (COleException* e)
    {
        ASSERT (FALSE);
        e->Delete ();
        return SELFREG_E_CLASS;
    }

    ASSERT (SUCCEEDED (hr));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer (void)
{
    try
    {
        LRESULT         lResult = 0;
        CString         strGUID;
        CString         snapinName;
        AMC::CRegKey    rkSnapins;
        BOOL            fFound = rkSnapins.OpenKeyEx (HKEY_LOCAL_MACHINE, SNAPINS_KEY);
        ASSERT (fFound);
        if ( fFound )
        {
            {
                AMC::CRegKey    rkCertTmplSnapin;
                HRESULT         hr = GuidToCString (&strGUID, CLSID_CertTemplatesSnapin);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }

                lResult = RegDelnode (rkSnapins, (PCWSTR) strGUID);
            }

            AMC::CRegKey rkNodeTypes;
            fFound = rkNodeTypes.OpenKeyEx (HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
            ASSERT (fFound);
            if ( fFound )
            {
                for (int i = CERTTMPL_SNAPIN; i < CERTTMPL_NUMTYPES; i++)
                {
                    lResult = RegDelnode (rkNodeTypes, g_aNodetypeGuids[i].bstr);
                }


                rkNodeTypes.CloseKey ();
            }
            else
                return SELFREG_E_CLASS;
        }
        else
            return SELFREG_E_CLASS;
    }
    catch (COleException* e)
    {
        ASSERT (FALSE);
        e->Delete ();
        return SELFREG_E_CLASS;
    }

    _Module.UnregisterServer ();

    return S_OK;
}

STDAPI DllInstall(BOOL /*bInstall*/, PCWSTR /*pszCmdLine*/)
{
    return S_OK;
}





///////////////////////////////////////////////////////////////////////////////
//  FormatDate ()
//
//  utcDateTime (IN)    -   A FILETIME in UTC format.
//  pszDateTime (OUT)   -   A string containing the local date and time
//                          formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime)
{
    //  Time is returned as UTC, will be displayed as local.
    //  Use FileTimeToLocalFileTime () to make it local,
    //  then call FileTimeToSystemTime () to convert to system time, then
    //  format with GetDateFormat () and GetTimeFormat () to display
    //  according to user and locale preferences
    HRESULT     hr = S_OK;
    FILETIME    localDateTime;

    BOOL bResult = FileTimeToLocalFileTime (&utcDateTime, // pointer to UTC file time to convert
            &localDateTime); // pointer to converted file time
    ASSERT (bResult);
    if ( bResult )
    {
        SYSTEMTIME  sysTime;

        bResult = FileTimeToSystemTime (
                &localDateTime, // pointer to file time to convert
                &sysTime); // pointer to structure to receive system time
        if ( bResult )
        {
            CString date;
            CString time;

            // Get date
            // Get length to allocate buffer of sufficient size
            int iLen = GetDateFormat (
                    LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                    0, // flags specifying function options
                    &sysTime, // date to be formatted
                    0, // date format string
                    0, // buffer for storing formatted string
                    0); // size of buffer
            ASSERT (iLen > 0);
            if ( iLen > 0 )
            {
                int iResult = GetDateFormat (
                        LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                        0, // flags specifying function options
                        &sysTime, // date to be formatted
                        0, // date format string
                        date.GetBufferSetLength (iLen), // buffer for storing formatted string
                        iLen); // size of buffer
                ASSERT (iResult);
                date.ReleaseBuffer ();
                if ( iResult )
                    pszDateTime = date;
                else
                    hr = HRESULT_FROM_WIN32 (GetLastError ());

                if ( iResult )
                {
                    // Get time
                    // Get length to allocate buffer of sufficient size
                    iLen = GetTimeFormat (
                            LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                            0, // flags specifying function options
                            &sysTime, // date to be formatted
                            0, // date format string
                            0, // buffer for storing formatted string
                            0); // size of buffer
                    ASSERT (iLen > 0);
                    if ( iLen > 0 )
                    {
                        iResult = GetTimeFormat (
                                LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                                0, // flags specifying function options
                                &sysTime, // date to be formatted
                                0, // date format string
                                time.GetBufferSetLength (iLen), // buffer for storing formatted string
                                iLen); // size of buffer
                        ASSERT (iResult);
                        time.ReleaseBuffer ();
                        if ( iResult )
                        {
                            pszDateTime = date + L"  " + time;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                else
                    hr = E_UNEXPECTED;
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (GetLastError ());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
    }

    return hr;
}


void DisplaySystemError (HWND hParent, DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID  lpMsgBuf;

    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL);

    // Display the string.
    CThemeContextActivator activator;
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTTMPL));
    ::MessageBox (hParent, (PWSTR) lpMsgBuf, (PCWSTR) caption, MB_OK);
    // Free the buffer.
    LocalFree (lpMsgBuf);
}


void TraceSystemError (DWORD dwErr)
{
//#ifdef _DEBUG
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID  lpMsgBuf = 0;

    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL);

    // Display the string.
    AfxTrace ((PCWSTR) lpMsgBuf);

    // Free the buffer.
    LocalFree (lpMsgBuf);
//#endif // _DEBUG
}

bool IsWindowsNT()
{
    OSVERSIONINFO   versionInfo;

    ::ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    BOOL    bResult = ::GetVersionEx (&versionInfo);
    ASSERT (bResult);
    if ( bResult )
    {
        if ( VER_PLATFORM_WIN32_NT == versionInfo.dwPlatformId )
            bResult = TRUE;
    }

    return bResult ? true : false;
}





////// This stuff was stolen from windows\gina\snapins\gpedit (eric flo's stuff) //////

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
PWSTR CheckSlash (PWSTR lpDir)
{
    PWSTR  lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\'))
    {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              5/13/98     BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnodeRecurse (HKEY hKeyRoot, PWSTR lpSubKey)
{
    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    LONG    lResult = RegDeleteKey(hKeyRoot, lpSubKey);
    if (lResult == ERROR_SUCCESS)
    {
        return lResult;
    }


    HKEY    hKey = 0;
    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }


    PWSTR  lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    DWORD       dwSize = MAX_PATH;
    FILETIME    ftWrite;
    WCHAR       szName[MAX_PATH];
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);
    if (lResult == ERROR_SUCCESS)
    {
        do {

            lstrcpy (lpEnd, szName);

            if ( ERROR_SUCCESS != RegDelnodeRecurse(hKeyRoot, lpSubKey) )
            {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);
    if (lResult == ERROR_SUCCESS)
    {
        return lResult;
    }

    return lResult;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              5/13/98     BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnode (HKEY hKeyRoot, PCWSTR lpSubKey)
{
    const size_t    BUF_LEN = 2 * MAX_PATH;
    WCHAR szDelKey[BUF_LEN];

    ::ZeroMemory (szDelKey, BUF_LEN * sizeof (WCHAR));
    wcsncpy (szDelKey, lpSubKey, BUF_LEN - 1);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForDomainComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT InitObjectPickerForDomainComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
/*
                           | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
*/
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}


CString GetSystemMessage (DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CString message;

    LPVOID lpMsgBuf;

    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL );
    message = (PWSTR) lpMsgBuf;

    // Remove white space (including new line characters)
    message.TrimRight ();

    // Free the buffer.
    LocalFree (lpMsgBuf);

    return message;
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int LocaleStrCmp(LPCWSTR ptsz1, LPCWSTR ptsz2)
{
    int iRet = 0;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1

        if ( 0 == iRet )
        {
            UNICODE_STRING unistr1;
            unistr1.Length = (USHORT)(::wcslen(ptsz1)*sizeof(WCHAR));
            unistr1.MaximumLength = unistr1.Length;
            unistr1.Buffer = (PWSTR)ptsz1;
            UNICODE_STRING unistr2;
            unistr2.Length = (USHORT)(::wcslen(ptsz2)*sizeof(WCHAR));
            unistr2.MaximumLength = unistr2.Length;
            unistr2.Buffer = (PWSTR)ptsz2;
            iRet = ::RtlCompareUnicodeString(
                &unistr1,
                &unistr2,
                FALSE );
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CompareString (%s, %s) failed: 0x%x\n", ptsz1, ptsz2, dwErr);
    }
    return iRet;
}


void FreeStringArray (PWSTR* rgpszStrings, DWORD dwAddCount)
{
    if ( rgpszStrings )
    {
        for (DWORD dwIndex = 0; dwIndex < dwAddCount; dwIndex++)
        {
            if ( rgpszStrings[dwIndex] )
                CoTaskMemFree (rgpszStrings[dwIndex]);
        }

        CoTaskMemFree (rgpszStrings);
    }
}

HRESULT DisplayRootNodeStatusBarText (LPCONSOLE pConsole)
{
    if ( !pConsole )
        return E_POINTER;

    _TRACE (1, L"Entering DisplayRootNodeStatusBarText\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    CComPtr<IConsole2>  spConsole2;
    HRESULT     hr = pConsole->QueryInterface (IID_PPV_ARG (IConsole2, &spConsole2));
    if (SUCCEEDED (hr))
    {
        CString statusText;
        VERIFY (statusText.LoadString (IDS_ROOTNODE_STATUSBAR_TEXT));
        hr = spConsole2->SetStatusText ((PWSTR)(PCWSTR) statusText);
    }

    _TRACE (-1, L"Leaving DisplayRootNodeStatusBarText: 0x%x\n", hr);
    return hr;
}

HRESULT DisplayObjectCountInStatusBar (LPCONSOLE pConsole, DWORD dwCnt)
{
    if ( !pConsole )
        return E_POINTER;

    _TRACE (1, L"Entering DisplayObjectCountInStatusBar- %d, %s\n",
            dwCnt, L"Certificate Templates");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    CComPtr<IConsole2>  spConsole2;
    HRESULT     hr = pConsole->QueryInterface (IID_PPV_ARG (IConsole2, &spConsole2));
    if (SUCCEEDED (hr))
    {
        CString statusText;
        UINT    formatID = 0;

        switch (dwCnt)
        {
        case -1:
            statusText = L"";
            break;

        case 1:
            VERIFY (statusText.LoadString (IDS_CERT_TEMPLATE_COUNT_SINGLE));
            break;

        default:
            formatID = IDS_CERT_TEMPLATE_COUNT;
            break;
        }

        if ( formatID )
        {
            statusText.FormatMessage (formatID, dwCnt);
        }

        hr = spConsole2->SetStatusText ((PWSTR)(PCWSTR) statusText);
    }

    _TRACE (-1, L"Leaving DisplayObjectCountInStatusBar: 0x%x\n", hr);
    return hr;
}

const int MAX_PASSWORD_LENGTH = 256;

////////////////////////////////////////////////////////////////////////
// CCredentialObject

CCredentialObject::CCredentialObject(CCredentialObject* pCredObject)
{
    m_sUsername = pCredObject->m_sUsername;
    if (pCredObject->m_pszPassword != NULL)
    {
        m_pszPassword = (PWSTR)malloc(sizeof(WCHAR[MAX_PASSWORD_LENGTH + 1]));
        wcscpy(m_pszPassword, pCredObject->m_pszPassword);
    }
    else
    {
        m_pszPassword = NULL;
    }

    m_bUseCredentials = pCredObject->m_bUseCredentials;
}

// A prime number used to seed the encoding and decoding
//
#define NW_ENCODE_SEED3  0x83

HRESULT CCredentialObject::SetPasswordFromHwnd(HWND hWnd)
{
    UNICODE_STRING Password;

    if (m_pszPassword)
    {
        free(m_pszPassword);
        m_pszPassword = NULL;
    }

    UCHAR Seed = NW_ENCODE_SEED3;
    Password.Length = 0;

    WCHAR szBuffer[MAX_PASSWORD_LENGTH + 1];
    ::GetWindowText(hWnd, szBuffer, MAX_PASSWORD_LENGTH + 1);
    if (!szBuffer)
    {
        return S_OK;
    }

    RtlInitUnicodeString(&Password, szBuffer);
    RtlRunEncodeUnicodeString(&Seed, &Password);

    m_pszPassword = (PWSTR)malloc(sizeof(WCHAR[MAX_PASSWORD_LENGTH + 1]));
    if(!m_pszPassword)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_pszPassword, szBuffer);

    return S_OK;
}

HRESULT CCredentialObject::GetPassword(PWSTR pszBuffer, int bufLen) const
{
    UNICODE_STRING Password;
    UCHAR Seed = NW_ENCODE_SEED3;

    Password.Length = 0;

    if (!pszBuffer)
    {
        return E_FAIL;
    }

    if (!m_pszPassword)
    {
        return E_FAIL;
    }

    wcsncpy(pszBuffer, m_pszPassword, bufLen);

    RtlInitUnicodeString(&Password, pszBuffer);
    RtlRunDecodeUnicodeString(Seed, &Password);

    return S_OK;
}



PCWSTR GetContextHelpFile ()
{
	static CString strHelpTopic;

	if ( strHelpTopic.IsEmpty () )
	{
		UINT nLen = ::GetSystemWindowsDirectory (strHelpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
		strHelpTopic.ReleaseBuffer();
		if (0 == nLen)
		{
			ASSERT(FALSE);
			return 0;
		}

		strHelpTopic += CERTTMPL_HELP_PATH; 
		strHelpTopic += CERTTMPL_CONTEXT_HELP_FILE;
	}

	return (PCWSTR) strHelpTopic;
}

bool MyGetOIDInfoA (CString & string, LPCSTR pszObjId)
{   
	ASSERT (pszObjId);
    PCCRYPT_OID_INFO	pOIDInfo;  // This points to a constant data structure and must not be freed.
	bool				bResult = false;

    string = L"";
    pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

    if ( pOIDInfo )
    {
		string = pOIDInfo->pwszName;
        bResult = true;
    }
    else
    {
        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( !strcmp (pPolicyOID->GetOIDA (), pszObjId) )
                {
                    string = pPolicyOID->GetDisplayName ();
                    bResult = true;
                    break;
                }
            }
        }

        if ( !bResult )
        {
            int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
		    ASSERT (nLen);
		    if ( nLen )
		    {
			    nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
					    string.GetBufferSetLength (nLen), nLen);
			    ASSERT (nLen);
			    string.ReleaseBuffer ();
		    }
		    bResult = (nLen > 0) ? true : false;
        }
    }
    return bResult;
}

#define REGSZ_ENABLE_CERTTYPE_EDITING L"EnableCertTypeEditing"

bool IsCerttypeEditingAllowed()
{
    DWORD   lResult;
    HKEY    hKey = NULL;
    DWORD   dwType;
    DWORD   dwEnabled = 0;
    DWORD   cbEnabled = sizeof(dwEnabled);
    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, 
                            L"Software\\Microsoft\\Cryptography\\CertificateTemplateCache", 
                            0, 
                            KEY_READ,
                            &hKey);

    if (lResult == ERROR_SUCCESS) 
    {
        lResult = RegQueryValueEx(hKey, 
                  REGSZ_ENABLE_CERTTYPE_EDITING,  
                  NULL,
                  &dwType,
                  (PBYTE)&dwEnabled,
                  &cbEnabled);
        if(lResult == ERROR_SUCCESS)
        {
            if(dwType != REG_DWORD)
            {
                dwEnabled = 0;
            }
        }
        RegCloseKey (hKey);
    }


    return (dwEnabled != 0);
}

BOOL EnumOIDInfo (PCCRYPT_OID_INFO pInfo, void* /*pvArg*/)
{
    BOOL    bRVal = TRUE;

    if ( pInfo )
    {
        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( !strcmp (pPolicyOID->GetOIDA (), pInfo->pszOID) )
                    return TRUE; // duplicate found, get next
            }
        }

        int flags = 0;
        if ( CRYPT_ENHKEY_USAGE_OID_GROUP_ID == pInfo->dwGroupId )
            flags = CERT_OID_TYPE_APPLICATION_POLICY;
        else if ( CRYPT_POLICY_OID_GROUP_ID == pInfo->dwGroupId )
            flags = CERT_OID_TYPE_ISSUER_POLICY;
        else
        {
            ASSERT (0);
            return TRUE;
        }

        CPolicyOID* pPolicyOID = new CPolicyOID (pInfo->pszOID, pInfo->pwszName,
                flags, false);
        if ( pPolicyOID )
        {
            g_policyOIDList.AddTail (pPolicyOID);
        }
        else
            bRVal = FALSE;
    }
    else
        bRVal = FALSE;

    return bRVal;
}
 

HRESULT GetBuiltInOIDs ()
{
    HRESULT hr = S_OK;

    CryptEnumOIDInfo (
            CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
            0,
            0,
            EnumOIDInfo);

    CryptEnumOIDInfo (
            CRYPT_POLICY_OID_GROUP_ID,
            0,
            0,
            EnumOIDInfo);

    return hr;
}

HRESULT EnumerateOIDs (
        IDirectoryObject* pOIDContObj)
{
    _TRACE (1, L"Entering EnumerateOIDs\n");

	CComPtr<IDirectorySearch>   spDsSearch;
	HRESULT hr = pOIDContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spDsSearch);
		ADS_SEARCHPREF_INFO pSearchPref[1];
		DWORD dwNumPref = 1;

		pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
		pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

		hr = spDsSearch->SetSearchPreference(
				 pSearchPref,
				 dwNumPref
				 );
		if ( SUCCEEDED (hr) )
		{
			static const DWORD	cAttrs = 3;
            static PWSTR	    rgszAttrList[cAttrs] = {OID_PROP_DISPLAY_NAME, OID_PROP_OID, OID_PROP_TYPE};
			ADS_SEARCH_HANDLE	hSearchHandle = 0;
            wstring             strQuery;
            ADS_SEARCH_COLUMN   Column;

            Column.pszAttrName = 0;
            strQuery = L"objectClass=msPKI-Enterprise-Oid";

			hr = spDsSearch->ExecuteSearch(
								 const_cast <PWSTR>(strQuery.c_str ()),
								 rgszAttrList,
								 cAttrs,
								 &hSearchHandle
								 );
			if ( SUCCEEDED (hr) )
			{
				while ((hr = spDsSearch->GetNextRow (hSearchHandle)) != S_ADS_NOMORE_ROWS )
				{
                    if (FAILED(hr))
                        continue;

					//
					// Getting current row's information
					//
					hr = spDsSearch->GetColumn(
							 hSearchHandle,
							 rgszAttrList[0],
							 &Column
							 );
					if ( SUCCEEDED (hr) )
					{
                        CString strDisplayName = Column.pADsValues->CaseIgnoreString;

						spDsSearch->FreeColumn (&Column);
						Column.pszAttrName = NULL;

					    hr = spDsSearch->GetColumn(
							     hSearchHandle,
							     rgszAttrList[1],
							     &Column
							     );
					    if ( SUCCEEDED (hr) )
					    {
                            bool    bOIDFound = false;
                            CString strOID = Column.pADsValues->CaseIgnoreString;
						    spDsSearch->FreeColumn (&Column);

                            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
                            {
                                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                                if ( pPolicyOID )
                                {
                                    if ( pPolicyOID->GetOIDW () == strOID )
                                    {
                                        bOIDFound = true;
                                        break;
                                    }
                                }
                            }

                            if ( !bOIDFound )
                            {
						        Column.pszAttrName = NULL;

					            hr = spDsSearch->GetColumn(
							             hSearchHandle,
							             rgszAttrList[2],
							             &Column
							             );
					            if ( SUCCEEDED (hr) )
					            {
                                    ADS_INTEGER flags = Column.pADsValues->Integer;
						            spDsSearch->FreeColumn (&Column);
						            Column.pszAttrName = NULL;

                                    // Only add issuance and application OIDs to the list
                                    if ( CERT_OID_TYPE_ISSUER_POLICY == flags || 
                                        CERT_OID_TYPE_APPLICATION_POLICY == flags )
                                    {
                                        CPolicyOID* pPolicyOID = new CPolicyOID (strOID, strDisplayName, flags);
                                        if ( pPolicyOID )
                                        {
                                            g_policyOIDList.AddTail (pPolicyOID);
                                        }
                                        else
                                            break;
                                    }
                                }
                            }
                        }
					}
					else if ( hr != E_ADS_COLUMN_NOT_SET )
					{
						break;
					}
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::GetColumn () failed: 0x%x\n", hr);
                    }
                }
			}
            else
            {
                _TRACE (0, L"IDirectorySearch::ExecuteSearch () failed: 0x%x\n", hr);
            }

            spDsSearch->CloseSearchHandle(hSearchHandle);
		}
        else
        {
            _TRACE (0, L"IDirectorySearch::SetSearchPreference () failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving EnumerateOIDs: 0x%x\n", hr);
    return hr;
}


HRESULT GetEnterpriseOIDs ()
{
	_TRACE (1, L"Entering GetEnterpriseOIDs\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    HRESULT	hr = S_OK;

    // Empty the list first
    while ( !g_policyOIDList.IsEmpty () )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.RemoveHead ();
        if ( pPolicyOID )
            delete pPolicyOID;
    }

    hr = GetBuiltInOIDs ();
    
    if ( SUCCEEDED (hr) )
    {
	    CComPtr<IADsPathname> spPathname;
	    //
	    // Constructing the directory paths
	    //
	    hr = CoCreateInstance(
				    CLSID_Pathname,
				    NULL,
				    CLSCTX_ALL,
				    IID_PPV_ARG (IADsPathname, &spPathname));
	    if ( SUCCEEDED (hr) )
	    {
            ASSERT (!!spPathname);
		    hr = spPathname->Set(const_cast <PWSTR> (CERTTMPL_LDAP),
							    ADS_SETTYPE_PROVIDER);
		    if ( SUCCEEDED (hr) )
		    {
			    //
			    // Open the root DSE object
			    //
			    hr = spPathname->AddLeafElement(const_cast <PWSTR> (CERTTMPL_ROOTDSE));
			    if ( SUCCEEDED (hr) )
			    {
				    BSTR bstrFullPath = 0;
				    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				    if ( SUCCEEDED (hr) )
				    {
					    CComPtr<IADs> spRootDSEObject;
					    VARIANT varNamingContext;


					    hr = ADsGetObject (
			                  bstrFullPath,
						      IID_PPV_ARG (IADs, &spRootDSEObject));
					    if ( SUCCEEDED (hr) )
					    {
                            ASSERT (!!spRootDSEObject);
						    //
						    // Get the configuration naming context from the root DSE
						    //
						    hr = spRootDSEObject->Get(const_cast <PWSTR> (CERTTMPL_CONFIG_NAMING_CONTEXT),
											     &varNamingContext);
						    if ( SUCCEEDED (hr) )
						    {
							    hr = spPathname->Set(V_BSTR(&varNamingContext),
												    ADS_SETTYPE_DN);
							    if ( SUCCEEDED (hr) )
							    {
                                    hr = spPathname->AddLeafElement (L"CN=Services");
                                    if ( SUCCEEDED (hr) )
                                    {
                                        hr = spPathname->AddLeafElement (L"CN=Public Key Services");
                                        if ( SUCCEEDED (hr) )
                                        {
                                            hr = spPathname->AddLeafElement (L"CN=OID");
                                            if ( SUCCEEDED (hr) )
                                            {
				                                BSTR bstrOIDPath = 0;
				                                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrOIDPath);
				                                if ( SUCCEEDED (hr) )
				                                {
					                                CComPtr<IDirectoryObject> spOIDContObj;

					                                hr = ADsGetObject (
			                                              bstrOIDPath,
						                                  IID_PPV_ARG (IDirectoryObject, &spOIDContObj));
					                                if ( SUCCEEDED (hr) )
					                                {
                                                        hr = EnumerateOIDs (spOIDContObj);
                                                    }
                                                    else
                                                    {
                                                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrOIDPath, hr);
                                                    }

                                                    SysFreeString (bstrOIDPath);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                _TRACE (0, L"IADs::Get (%s) failed: 0x%x\n", CERTTMPL_CONFIG_NAMING_CONTEXT, hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath, hr);
                        }
                    }
                }
            }
        }
        else
            hr = E_POINTER;
    }

	_TRACE (-1, L"Leaving GetEnterpriseOIDs: 0x%x\n", hr);
	return hr;
}


bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID)
{
    _TRACE (1, L"Entering OIDHasValidFormat (%s)\n", pszOidValue);
    rErrorTypeStrID = 0;

    bool    bFormatIsValid = false;
    int     nLen = WideCharToMultiByte(
          CP_ACP,                   // code page
          0,                        // performance and mapping flags
          pszOidValue,              // wide-character string
          (int) wcslen (pszOidValue),  // number of chars in string
          0,                        // buffer for new string
          0,                        // size of buffer
          0,                        // default for unmappable chars
          0);                       // set when default char used
    if ( nLen > 0 )
    {
        nLen++; // account for Null terminator
        PSTR    pszAnsiBuf = new CHAR[nLen];
        if ( pszAnsiBuf )
        {
            ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
            nLen = WideCharToMultiByte(
                    CP_ACP,                 // code page
                    0,                      // performance and mapping flags
                    pszOidValue,            // wide-character string
                    (int) wcslen (pszOidValue),   // number of chars in string
                    pszAnsiBuf,             // buffer for new string
                    nLen,                   // size of buffer
                    0,                      // default for unmappable chars
                    0);                     // set when default char used
            if ( nLen )
            {
                // According to PhilH:
                // The first number is limited to 
                // 0,1 or 2. The second number is 
                // limited to 0 - 39 when the first 
                // number is 0 or 1. Otherwise, any 
                // number.
                // Also, according to X.208, there 
                // must be at least 2 numbers.
                bFormatIsValid = true;
                size_t cbAnsiBufLen = strlen (pszAnsiBuf);

                // check for only digits and "."
                size_t nIdx = strspn (pszAnsiBuf, "0123456789.\0");
                if ( nIdx > 0 && nIdx < cbAnsiBufLen )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_NON_DIGITS;
                }

                // check for consecutive "."s - string not valid if present
                if ( bFormatIsValid && strstr (pszAnsiBuf, "..") )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_CONSECUTIVE_DOTS;
                }
                

                // must begin with "0." or "1." or "2."
                bool bFirstNumberIs0 = false;
                bool bFirstNumberIs1 = false;
                bool bFirstNumberIs2 = false;
                if ( bFormatIsValid )
                {
                    if ( !strncmp (pszAnsiBuf, "0.", 2) )
                        bFirstNumberIs0 = true;
                    else if ( !strncmp (pszAnsiBuf, "1.", 2) )
                        bFirstNumberIs1 = true;
                    else if ( !strncmp (pszAnsiBuf, "2.", 2) )
                        bFirstNumberIs2 = true;
                    
                    if ( !bFirstNumberIs0 && !bFirstNumberIs1 && !bFirstNumberIs2 )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_START_WITH_0_1_2;
                    }
                }

                if ( bFormatIsValid && ( bFirstNumberIs0 || bFirstNumberIs1 ) )
                {
                    PSTR pszBuf = pszAnsiBuf;
                    pszBuf += 2;

                    // there must be a number after the dot
                    if ( strlen (pszBuf) )
                    {
                        // truncate the string at the next dot, if any
                        PSTR pszDot = strstr (pszBuf, ".");
                        if ( pszDot )
                            pszDot[0] = 0;

                        // convert the string to a number and check for range 0-39
                        int nValue = atoi (pszBuf);
                        if ( nValue < 0 || nValue > 39 )
                        {
                            bFormatIsValid = false;
                            rErrorTypeStrID = IDS_OID_0_1_MUST_BE_0_TO_39;
                        }
                    }
                    else
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_HAVE_TWO_NUMBERS;
                    }
                }

                // ensure no trailing "."
                if ( bFormatIsValid )
                {
                    if ( '.' == pszAnsiBuf[cbAnsiBufLen - 1] )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_CANNOT_END_WITH_DOT;
                    }
                }

                if ( bFormatIsValid )
                {
                    bFormatIsValid = false;
                    CRYPT_ATTRIBUTE cryptAttr;
                    ::ZeroMemory (&cryptAttr, sizeof (CRYPT_ATTRIBUTE));

                    cryptAttr.cValue = 0;
                    cryptAttr.pszObjId = pszAnsiBuf;
                    cryptAttr.rgValue = 0;

                    DWORD   cbEncoded = 0;
                    BOOL bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            PKCS_ATTRIBUTE,
                            &cryptAttr,
                            NULL,
                            &cbEncoded);
                    if ( cbEncoded > 0 )
                    {
                        BYTE* pBuffer = new BYTE[cbEncoded];
                        if ( pBuffer )
                        {
                            bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    PKCS_ATTRIBUTE,
                                    &cryptAttr,
                                    pBuffer,
                                    &cbEncoded);
                            if ( bResult )
                            {   
                                DWORD   cbStructInfo = 0;
                                bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        PKCS_ATTRIBUTE,
                                        pBuffer,
                                        cbEncoded,
                                        0,
                                        0,
                                        &cbStructInfo);
                                if ( cbStructInfo > 0 )
                                {
                                    BYTE* pStructBuf = new BYTE[cbStructInfo];
                                    if ( pStructBuf )
                                    {
                                        bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                PKCS_ATTRIBUTE,
                                                pBuffer,
                                                cbEncoded,
                                                0,
                                                pStructBuf,
                                                &cbStructInfo);
                                        if ( bResult )
                                        {
                                            CRYPT_ATTRIBUTE* pCryptAttr = (CRYPT_ATTRIBUTE*) pStructBuf;
                                            if ( !strcmp (pszAnsiBuf, pCryptAttr->pszObjId) )
                                            {
                                                bFormatIsValid = true;
                                            }
                                        }
                                        delete [] pStructBuf;
                                    }
                                }
                            }
                            delete [] pBuffer;
                        }
                    }
                }
            }
            else
            {
                _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                        GetLastError ());
            }

            delete [] pszAnsiBuf;
        }
    }
    else
    {
        _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                GetLastError ());
    }

    _TRACE (-1, L"Leaving EnumerateOIDs: %s\n", bFormatIsValid ? L"true" : L"false");
    return bFormatIsValid;
}

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\certtemplate.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       CertTemplate.cpp
//
//  Contents:   CCertTemplate
//
//----------------------------------------------------------------------------
/// CertTemplate.cpp: implementation of the CCertTemplate class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CertTemplate.h"

#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)

CERT_EXTENSION  g_EKUCertExtension = {szOID_ENHANCED_KEY_USAGE, 0, {0, 0}};
CERT_EXTENSION  g_certPolCertExtension = {szOID_CERT_POLICIES, 0, {0, 0}};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CCertTemplate::CCertTemplate(
        PCWSTR pszObjectName, 
        PCWSTR pszTemplateName, 
        const CString& szLDAPPath, 
        bool fIsReadOnly,
        const bool fUseCache) :
    CCertTmplCookie (CERTTMPL_CERT_TEMPLATE, pszObjectName),
    m_strTemplateName (pszTemplateName),
    m_hCertType (0),
    m_dwVersion (0),
    m_dwEnrollmentFlags (0),
    m_dwSubjectNameFlags (0),
    m_dwPrivateKeyFlags (0),
    m_dwGeneralFlags (0),
    m_dwKeySpec (0),
    m_bIsClone (false),
    m_bCanBeDeletedOnCancel (false),
    m_bGoodForAutoenrollmentFlagPendingSave (false),
    m_szLDAPPath (szLDAPPath),
    m_fIsReadOnly (fIsReadOnly),
    m_nOriginalValidityDays (-1),
    m_nNewValidityDays (-1),
    m_nOriginalRenewalDays (-1),
    m_nNewRenewalDays (-1),
    m_pCertExtensions (0),
    m_fUseCache (fUseCache),
    m_bIssuancePoliciesRequired (false)
{
//    _TRACE (1, L"Entering CCertTemplate::CCertTemplate\n");

    m_strOriginalTemplateName = pszTemplateName;

    Initialize ();
//    _TRACE (-1, L"Leaving CCertTemplate::CCertTemplate\n");
}

CCertTemplate::CCertTemplate(
        const CCertTemplate &rTemplate, 
        bool bIsClone, 
        bool fIsReadOnly, 
        const bool fUseCache)
 : CCertTmplCookie (CERTTMPL_CERT_TEMPLATE),
    m_hCertType (0),
    m_dwVersion (0),
    m_dwEnrollmentFlags (0),
    m_dwSubjectNameFlags (0),
    m_dwPrivateKeyFlags (0),
    m_dwGeneralFlags (0),
    m_dwKeySpec (0),
    m_bIsClone (bIsClone),
    m_bCanBeDeletedOnCancel (true),
    m_bGoodForAutoenrollmentFlagPendingSave (false),
    m_fIsReadOnly (fIsReadOnly),
    m_szLDAPPath (rTemplate.GetLDAPPath ()),
    m_nOriginalValidityDays (-1),
    m_nNewValidityDays (-1),
    m_nOriginalRenewalDays (-1),
    m_nNewRenewalDays (-1),
    m_pCertExtensions (0),
    m_fUseCache (fUseCache),
    m_bIssuancePoliciesRequired (false)
{
//    _TRACE (1, L"Entering CCertTemplate::CCertTemplate (copy constructor)\n");
//    _TRACE (-1, L"Leaving CCertTemplate::CCertTemplate (copy constructor)\n");
}

CCertTemplate::~CCertTemplate()
{
//    _TRACE (1, L"Entering CCertTemplate::~CCertTemplate - m_hCertType = 0x%x\n", m_hCertType);
    if ( m_hCertType )
    {
        FreeCertExtensions ();

        HRESULT hr = CACloseCertType (m_hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( !SUCCEEDED (hr) )
        {
            _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
        }
    }
//    _TRACE (-1, L"Leaving CCertTemplate::~CCertTemplate\n");
}

HRESULT CCertTemplate::Initialize()
{
//    _TRACE (1, L"Entering CCertTemplate::Initialize - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    
    
    if ( !m_hCertType )
    {
        DWORD dwFlags = CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES;

        if ( !m_fUseCache )
        {
            dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
        }

        hr = CAFindCertTypeByName (m_strTemplateName,
                NULL,
                dwFlags,
                &m_hCertType);
        _ASSERT (SUCCEEDED (hr));
    }
    if ( SUCCEEDED (hr) )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_SCHEMA_VERSION,
                &m_dwVersion);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
        }

        // Get enrollment flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_ENROLLMENT_FLAG, 
                    &m_dwEnrollmentFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_ENROLLMENT_FLAG) failed: 0x%x\n", hr);
            }
        }

        // Get subject name flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_SUBJECT_NAME_FLAG, 
                    &m_dwSubjectNameFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_SUBJECT_NAME_FLAG) failed: 0x%x\n", hr);
            }
        }

        // Get private key flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_PRIVATE_KEY_FLAG, 
                    &m_dwPrivateKeyFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_PRIVATE_KEY_FLAG) failed: 0x%x\n", hr);
            }
        }

        // Get general flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_GENERAL_FLAG, 
                    &m_dwGeneralFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_GENERAL_FLAG) failed: 0x%x\n", hr);
            }
        }

        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeKeySpec (m_hCertType, &m_dwKeySpec);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeKeySpec () failed: 0x%x\n", hr);
            }
        }
    }
    else
    {
        _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", (PCWSTR) m_strTemplateName, hr);
    }

//    _TRACE (-1, L"Leaving CCertTemplate::Initialize: 0x%x\n", hr);
    return hr;
}

DWORD CCertTemplate::GetType() const
{
    return m_dwVersion;
}

CString CCertTemplate::GetDisplayName ()
{
//    _TRACE (1, L"Entering CCertTemplate::GetDisplayName - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    if ( m_szDisplayName.IsEmpty () )
    {
        if ( m_hCertType )
        {
            PWSTR* rgwszProp = 0;

            hr = CAGetCertTypePropertyEx (m_hCertType, 
                CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
            if ( SUCCEEDED (hr) && rgwszProp )
            {
                m_szDisplayName = *rgwszProp;
                CAFreeCertTypeProperty (m_hCertType, rgwszProp);
            }
            else
            {
                _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
                m_szDisplayName = GetObjectName ();
            }
        }
        else
            m_szDisplayName = GetObjectName ();
    }

//    _TRACE (-1, L"Leaving CCertTemplate::GetDisplayName: %s, 0x%x\n", (PCWSTR) m_szDisplayName, hr);
   return m_szDisplayName;
}

CString CCertTemplate::GetTemplateName() const
{
    return m_strTemplateName;
}

bool CCertTemplate::SubjectIsCA() const
{
    return (m_dwGeneralFlags & CT_FLAG_IS_CA) ? true : false;
}

bool CCertTemplate::SubjectIsCrossCA() const
{
    return (m_dwGeneralFlags & CT_FLAG_IS_CROSS_CA) ? true : false;
}

bool CCertTemplate::IsMachineType() const
{
    return (m_dwGeneralFlags & CT_FLAG_MACHINE_TYPE) ? true : false;
}

bool CCertTemplate::PublishToDS() const
{
    return (m_dwEnrollmentFlags & CT_FLAG_PUBLISH_TO_DS) ? true : false;
}

DWORD CCertTemplate::GetCertExtensionCount()
{
    DWORD               dwCnt = 0;
    PCERT_EXTENSIONS    pCertExtensions = 0;
    
    HRESULT hr = CAGetCertTypeExtensions (m_hCertType, &pCertExtensions);
    if ( SUCCEEDED (hr) )
    {
        if ( pCertExtensions )
        {
            dwCnt = pCertExtensions->cExtension;
            CAFreeCertTypeExtensions (m_hCertType, pCertExtensions);
        }
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeExtensions () failed: 0x%x\n", hr);
    }

    return dwCnt;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method: GetCertExtension
//
//  Note: The pointer returned through ppCertExtension must not be freed.  The
//          caller must call FreeCertExtensions () when done with it.
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertTemplate::GetCertExtension (PSTR pszOID, PCERT_EXTENSION* ppCertExtension)
{
    HRESULT hr = S_OK;
    if ( ppCertExtension )
    {
        hr = CAGetCertTypeExtensions (m_hCertType, &m_pCertExtensions);
        if ( SUCCEEDED (hr) )
        {
            if ( m_pCertExtensions )
            {
                *ppCertExtension = CertFindExtension(pszOID,
                        m_pCertExtensions->cExtension,
                        m_pCertExtensions->rgExtension);
                if ( ! (*ppCertExtension) )
                {
                    if ( SubjectIsCA () )
                    {
                        if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszOID) )
                            *ppCertExtension = &g_EKUCertExtension;
                        else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                            *ppCertExtension = &g_certPolCertExtension;
                    }
                }
            }
            else
                hr = E_FAIL;
        }
        else
        {
            _TRACE (0, L"CAGetCertTypeExtensions () failed: 0x%x\n", hr);
        }
    }
    else
        return E_POINTER;

    return hr;
}

HRESULT CCertTemplate::GetCertExtension(DWORD dwIndex, PSTR* ppszObjId, BOOL& fCritical)
{
    if ( !ppszObjId )
        return E_POINTER;

    PCERT_EXTENSIONS pCertExtensions = 0;
    HRESULT hr = CAGetCertTypeExtensions (m_hCertType, &pCertExtensions);
    if ( SUCCEEDED (hr) )
    {
        if ( pCertExtensions )
        {
            if ( dwIndex >= pCertExtensions->cExtension )
                hr = E_INVALIDARG;
            else
            {
                PCERT_EXTENSION pExtension = &pCertExtensions->rgExtension[dwIndex];
                PSTR    pszOID = new CHAR[strlen (pExtension->pszObjId)+1];
                if ( pszOID )
                {
                    strcpy (pszOID, pExtension->pszObjId);
                    *ppszObjId = pszOID;
                    fCritical = pExtension->fCritical;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            CAFreeCertTypeExtensions (m_hCertType, pCertExtensions);
        }
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeExtensions () failed: 0x%x\n", hr);
    }


    return hr;
}

bool CCertTemplate::HasKeySpecSignature() const
{
    return m_dwKeySpec & AT_SIGNATURE ? true : false;
}

bool CCertTemplate::HasEncryptionSignature() const
{
    return m_dwKeySpec & AT_KEYEXCHANGE ? true : false;
}

bool CCertTemplate::RequireSubjectInRequest() const
{
    return m_dwSubjectNameFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT ? true : false;
}

#define CVT_BASE	(1000 * 1000 * 10)

HRESULT CCertTemplate::ConvertCertTypeFileTimeToDays (FILETIME const *pftCertType, int& nDays)
{
    HRESULT     hr = S_OK;
    if ( !pftCertType )
        return E_POINTER;

    LONGLONG ll = *(LONGLONG *) pftCertType;	// Signed 64 bit scalar!
    if (0 > ll)
    {
        ll = -ll;
        ll /= CVT_BASE; // now in seconds

        nDays = (int) (ll / (60 * 60 * 24));
    }
    else
        nDays = 0;

    return hr;
}

HRESULT CCertTemplate::GetValidityPeriod(int& nValidityDays)
{
    HRESULT hr = S_OK;

    FILETIME    ftValidity;
    hr = CAGetCertTypeExpiration (m_hCertType, &ftValidity, 0);
    if ( SUCCEEDED (hr) )
    {
        hr = ConvertCertTypeFileTimeToDays (&ftValidity, nValidityDays);
        if ( SUCCEEDED (hr) )
            m_nOriginalValidityDays = nValidityDays;
    }

    return hr;
}

HRESULT CCertTemplate::GetRenewalPeriod(int& nRenewalDays)
{
    HRESULT hr = S_OK;

    FILETIME    ftRenewal;
    hr = CAGetCertTypeExpiration (m_hCertType, 0, &ftRenewal);
    if ( SUCCEEDED (hr) )
    {
        hr = ConvertCertTypeFileTimeToDays (&ftRenewal, nRenewalDays);
        if ( SUCCEEDED (hr) )
            m_nOriginalRenewalDays = nRenewalDays;
    }

    return hr;
}

// NEW CLONE
HRESULT CCertTemplate::Clone (
        const CCertTemplate& rTemplate, 
        const CString& strTemplateName, 
        const CString& strDisplayName)
{
    _TRACE (1, L"Entering CCertTemplate::Clone (%s, %s)\n", (PCWSTR) strTemplateName, (PCWSTR) strDisplayName);
    HRESULT hr = S_OK;

    _ASSERT (m_bIsClone);
    if ( m_bIsClone )
    {
        m_strTemplateName = strTemplateName;

        // Set the originalTemplateName so that we can tell later if the
        // user has renamed the template.  This is important because renaming
        // a template creates a brand new template and the old one must then
        // be deleted.
        m_strOriginalTemplateName = strTemplateName;

        SetObjectName (strDisplayName);

        if ( SUCCEEDED (hr) )
        {
            hr = CAFindCertTypeByName (rTemplate.GetTemplateName (), 
                    NULL,
                    CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                    &m_hCertType);
            if ( SUCCEEDED (hr) )
            {
                HCERTTYPE   hNewCertType = 0;
                hr = CACloneCertType (
                        m_hCertType,
                        strTemplateName,
                        strDisplayName,
                        0,
                        (GetType () > 1 ) ? 
                            (CT_CLONE_KEEP_SUBJECT_NAME_SETTING | CT_CLONE_KEEP_AUTOENROLLMENT_SETTING): 0, 
                        &hNewCertType);
                if ( SUCCEEDED (hr) )
                {
                    CACloseCertType (m_hCertType);
                    
                    m_hCertType = hNewCertType;
                    hr = Initialize ();
                }
                else
                {
                    _TRACE (0, L"CACloneCertType (%s, %s) failed: 0x%d\n",
                            (PCWSTR) strTemplateName, (PCWSTR) strDisplayName,
                            hr);
                }
            }
            else
            {
                _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x", 
                        (PCWSTR) rTemplate.GetTemplateName (), hr);
            }
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::Clone: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTemplate::Delete()
{
    _TRACE (1, L"Entering CCertTemplate::Delete - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;

    if ( !(m_dwGeneralFlags & CT_FLAG_IS_DEFAULT) )
    {
        if ( m_hCertType )
        {
            hr = CADeleteCertType (m_hCertType);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CADeleteCertType failed: 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"m_hCertType was unexpectedly NULL\n");
            hr = E_UNEXPECTED;
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::Delete: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::IsDefault() const
{
    return m_dwGeneralFlags & CT_FLAG_IS_DEFAULT ? true : false;
}

bool CCertTemplate::IsClone() const
{
    return m_bIsClone;
}

HRESULT CCertTemplate::SetTemplateName(const CString &strTemplateName)
{
    _TRACE (1, L"Entering CCertTemplate::SetTemplateName (%s) - m_hCertType = 0x%x\n", 
            strTemplateName, m_hCertType);
    HRESULT hr = S_OK;

    if ( LocaleStrCmp (m_strTemplateName, strTemplateName) )
    {
        PWSTR   rgwszProp[2];
        rgwszProp[0] = (PWSTR)(PCWSTR) strTemplateName;
        rgwszProp[1] = 0;;

        hr = CASetCertTypePropertyEx (m_hCertType, 
                CERTTYPE_PROP_CN, rgwszProp);
        if ( SUCCEEDED (hr) )
        {
            m_strTemplateName = strTemplateName;
        }
        else
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_CN, %s) failed: 0x%x",
                    rgwszProp[0], hr);
        }
    }
    _TRACE (-1, L"Leaving CCertTemplate::SetTemplateName: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetDisplayName(const CString &strDisplayName, bool bForce)
{
    _TRACE (1, L"Entering CCertTemplate::SetDisplayName (%s) - m_hCertType = 0x%x\n", 
            strDisplayName, m_hCertType);
    HRESULT hr = S_OK;

    if ( bForce || LocaleStrCmp (GetDisplayName (), strDisplayName) )
    {
        PWSTR   rgwszProp[2];
        rgwszProp[0] = (PWSTR)(PCWSTR) strDisplayName;
        rgwszProp[1] = 0;

        hr = CASetCertTypePropertyEx (m_hCertType, 
                CERTTYPE_PROP_FRIENDLY_NAME, rgwszProp);
        if ( SUCCEEDED (hr) )
        {
            m_szDisplayName = L"";
            m_szDisplayName = GetDisplayName ();
            SetObjectName (m_szDisplayName);
        }
        else
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME, %s) failed: 0x%x",
                    rgwszProp[0], hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetDisplayName: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SaveChanges(bool bIncrementMinorVersion /*=true*/)
{
    _TRACE (1, L"Entering CCertTemplate::SaveChanges - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;

    m_bCanBeDeletedOnCancel = false;

    if ( m_hCertType )
    {
        // Save validity period 
        if ( -1 != m_nNewValidityDays && m_nOriginalValidityDays != m_nNewValidityDays )
        {
            LONGLONG ll = (LONGLONG) m_nNewValidityDays * (60 * 60 * 24); // seconds
            ll *= CVT_BASE;
            ll = -ll;

            FILETIME    ftValidity;
            ftValidity.dwLowDateTime = (DWORD) (ll & 0xFFFFFFFF);
            ftValidity.dwHighDateTime = (DWORD) (ll >> 32);

            // save the new value back to the cert template
            hr = CASetCertTypeExpiration (m_hCertType, &ftValidity, 0);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CASetCertTypeExpiration (validity) failed: 0x%x\n", hr);
            }
        }

        // Save renewal period 
        if ( -1 != m_nNewRenewalDays && m_nOriginalRenewalDays != m_nNewRenewalDays )
        {
            LONGLONG ll = (LONGLONG) m_nNewRenewalDays * (60 * 60 * 24); // seconds
            ll *= CVT_BASE;
            ll = -ll;

            // get the original value
            FILETIME    ftRenewal;
            ftRenewal.dwLowDateTime = (DWORD) (ll & 0xFFFFFFFF);
            ftRenewal.dwHighDateTime = (DWORD) (ll >> 32);

            // save the new value back to the cert template
            hr = CASetCertTypeExpiration (m_hCertType, 0, &ftRenewal);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CASetCertTypeExpiration (renewal) failed: 0x%x\n", hr);
            }
        }

        if ( SUCCEEDED (hr) )
        {
            if ( bIncrementMinorVersion )
                hr = IncrementMinorVersion ();
            if ( SUCCEEDED (hr) )
            {
                hr = CAUpdateCertType (m_hCertType);
                if ( SUCCEEDED (hr) )
                {
                    // If the name was changed a new template was created and the old one needs to be deleted
                    if ( LocaleStrCmp (m_strOriginalTemplateName, m_strTemplateName) )
                    {
                        HCERTTYPE   hCertType = 0;
                        HRESULT     hr1 = CAFindCertTypeByName (m_strOriginalTemplateName, 
                                NULL,
                                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                                &hCertType);
                        if ( SUCCEEDED (hr1) )
                        {
                            hr1 = CADeleteCertType (hCertType);
                            if (FAILED (hr1) )
                            {
                                _TRACE (0, L"Cert Template was renamed. Original cert template %s was found but could not be deleted: 0x%x\n", 
                                        m_strOriginalTemplateName, hr);
                            }

                            m_strOriginalTemplateName = m_strTemplateName;

                            hr1 = CACloseCertType (hCertType);
                            if ( FAILED (hr1) )
                            {
                                _TRACE (0, L"CACloseCertType () failed: 0x%x", hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"Cert Template was renamed. Unable to find original cert template %s. 0x%x\n",
                                        m_strOriginalTemplateName, hr);
                        }
                    }
                    else
                    {
                        m_bIsClone = false;
                        Cancel (); // cause all settings to be refreshed
                    }
                }
                else
                {
                    _TRACE (0, L"CAUpdateCertType () failed: 0x%x", hr);
                }
            }
        }
    }
    else
        hr = E_FAIL;

    if ( SUCCEEDED (hr) )
        m_bIsClone = false;

    _TRACE (-1, L"Leaving CCertTemplate::SaveChanges: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetSubjectIsCA(bool bSubjectIsCA)
{
    _TRACE (1, L"Entering CCertTemplate::SetSubjectIsCA - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_GENERAL_FLAG, CT_FLAG_IS_CA, bSubjectIsCA);


    _TRACE (-1, L"Leaving CCertTemplate::SetSubjectIsCA: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetKeySpecSignature(bool bHasKeySpecSignature)
{
    _TRACE (1, L"Entering CCertTemplate::SetKeySpecSignature - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK; 

    if ( m_hCertType )
    {
        if ( bHasKeySpecSignature )
            m_dwKeySpec |= AT_SIGNATURE;
        else
            m_dwKeySpec &= ~AT_SIGNATURE;

        hr = CASetCertTypeKeySpec (m_hCertType, m_dwKeySpec);
        if ( SUCCEEDED (hr) )
        {
            PCERT_EXTENSION pCertExtension = 0;
            hr = GetCertExtension (szOID_KEY_USAGE, &pCertExtension);
            if ( SUCCEEDED (hr) && pCertExtension )
            {
                DWORD   cbKeyUsage = 0;
		        if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				        szOID_KEY_USAGE, 
				        pCertExtension->Value.pbData,
				        pCertExtension->Value.cbData,
				        0, NULL, &cbKeyUsage) )
		        {
			        CRYPT_BIT_BLOB* pKeyUsage = (CRYPT_BIT_BLOB*)
					        ::LocalAlloc (LPTR, cbKeyUsage);
			        if ( pKeyUsage )
			        {
				        if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						        szOID_KEY_USAGE, 
						        pCertExtension->Value.pbData,
						        pCertExtension->Value.cbData,
						        0, pKeyUsage, &cbKeyUsage) )
				        {
                            if (pKeyUsage->cbData >= 1)
                            {
                                if ( bHasKeySpecSignature )
                                {
                                    pKeyUsage->pbData[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;

                                    // NTRAID# 312946 Cert Template Snap-in: 
                                    // Should clear up the Key Encipherment 
                                    // bit for signature certificate
                                    pKeyUsage->pbData[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;
                                    pKeyUsage->pbData[0] &= ~CERT_KEY_ENCIPHERMENT_KEY_USAGE;
                                    pKeyUsage->pbData[0] &= ~CERT_DATA_ENCIPHERMENT_KEY_USAGE;
                                }
                                else
                                {
                                    pKeyUsage->pbData[0] &= ~CERT_DIGITAL_SIGNATURE_KEY_USAGE;
                                    if ( !(CERT_KEY_AGREEMENT_KEY_USAGE & pKeyUsage->pbData[0]) )
                                        pKeyUsage->pbData[0] |= CERT_KEY_ENCIPHERMENT_KEY_USAGE;
                                }

                                pKeyUsage->cUnusedBits = 0;                
                                SetKeyUsage (pKeyUsage, 
                                        pCertExtension->fCritical ? true : false);
                                FreeCertExtensions ();
                            }
				        }
				        else
                        {
                            DWORD   dwErr = GetLastError ();
                            _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			                DisplaySystemError (NULL, dwErr);
                        }

                        ::LocalFree (pKeyUsage);
			        }
		        }
		        else
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			        DisplaySystemError (NULL, dwErr);
                }
            }
        }
        else
        {
            _TRACE (0, L"CASetCertTypeKeySpec() failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CCertTemplate::SetKeySpecSignature: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTemplate::SetFlag (DWORD dwFlagType, DWORD dwFlag, bool bValue)
{
    _TRACE (1, L"Entering CCertTemplate::SetFlag - m_hCertType = 0x%x\n", m_hCertType);;
    HRESULT hr = S_OK;
    
    DWORD*  pdwFlags = 0;

    switch (dwFlagType)
    {
    case CERTTYPE_ENROLLMENT_FLAG:
        pdwFlags = &m_dwEnrollmentFlags;
        break;

    case CERTTYPE_SUBJECT_NAME_FLAG:
        pdwFlags = &m_dwSubjectNameFlags;
        break;

    case CERTTYPE_PRIVATE_KEY_FLAG:
        pdwFlags = &m_dwPrivateKeyFlags;
        break;

    case CERTTYPE_GENERAL_FLAG:
        pdwFlags = &m_dwGeneralFlags;
        break;

    default:
        _ASSERT (0);
        hr = E_FAIL;
        break;
    }

    if ( pdwFlags )
    {
        if ( bValue )
            *pdwFlags |= dwFlag;
        else
            *pdwFlags &= ~dwFlag;

        hr = CASetCertTypeFlagsEx (m_hCertType, dwFlagType, *pdwFlags);
        _ASSERT (SUCCEEDED (hr));
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeFlagsEx () failed: 0x%x\n", hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetFlag: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetEncryptionSignature(bool bHasEncryptionSignature)
{
    _TRACE (1, L"Entering CCertTemplate::SetEncryptionSignature - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        if ( bHasEncryptionSignature )
            m_dwKeySpec |= AT_KEYEXCHANGE;
        else
            m_dwKeySpec &= ~AT_KEYEXCHANGE;

        hr = CASetCertTypeKeySpec (m_hCertType, m_dwKeySpec);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeKeySpec() failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_UNEXPECTED;


    _TRACE (-1, L"Leaving CCertTemplate::SetEncryptionSignature: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::CanBeDeletedOnCancel() const
{
    return m_bCanBeDeletedOnCancel;
}

HRESULT CCertTemplate::SetAutoEnrollment(bool bSuitableForAutoEnrollment)
{
    HRESULT hr = S_OK;

    if ( IsClone () )
    {
        // If this is a clone, the autoenrollment flag has already been turned 
        // off.  Here we wish only to keep track of what the user's 
        // preferences are so that we can turn it on, if desired, at the
        // final save.
        m_bGoodForAutoenrollmentFlagPendingSave = bSuitableForAutoEnrollment;
    }
    else
        hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_AUTO_ENROLLMENT, 
                bSuitableForAutoEnrollment);

    return hr;
}

HRESULT CCertTemplate::GetMinimumKeySize(DWORD &dwMinKeySize) const
{
    _TRACE (1, L"Entering CCertTemplate::GetMinimumKeySize - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MIN_KEY_SIZE,
                &dwMinKeySize);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_MIN_KEY_SIZE) failed: 0x%x\n", hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::GetMinimumKeySize (%d): 0x%x\n", dwMinKeySize, hr);
   return hr;
}

bool CCertTemplate::PrivateKeyIsExportable() const
{
    return (m_dwPrivateKeyFlags & CT_FLAG_EXPORTABLE_KEY) ? true : false;
}

HRESULT CCertTemplate::MakePrivateKeyExportable(bool bMakeExportable)
{
    return SetFlag (CERTTYPE_PRIVATE_KEY_FLAG, CT_FLAG_EXPORTABLE_KEY, 
            bMakeExportable);
}

bool CCertTemplate::AllowPrivateKeyArchival() const
{
    return (m_dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL) ? true : false;
}

HRESULT CCertTemplate::AllowPrivateKeyArchival(bool bAllowArchival)
{
    return SetFlag (CERTTYPE_PRIVATE_KEY_FLAG, 
            CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL, bAllowArchival);
}


bool CCertTemplate::IncludeSymmetricAlgorithms() const
{
    return (m_dwEnrollmentFlags & CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS) ? true : false;
}

HRESULT CCertTemplate::IncludeSymmetricAlgorithems(bool bInclude)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS, bInclude);
}

HRESULT CCertTemplate::DoAutoEnrollmentPendingSave()
{
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        if ( IsClone () && m_bGoodForAutoenrollmentFlagPendingSave )
        {
            // Set the flag for real
            hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_AUTO_ENROLLMENT, 
                    true);
        
            // Save changes
            if ( SUCCEEDED (hr) )
                hr = SaveChanges ();
        }
    }
    else
        hr = E_FAIL;

    return hr;
}

bool CCertTemplate::AltNameIncludesDNS() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_DNS) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesDNS(bool fIncludeDNS)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_DNS, fIncludeDNS);
}

bool CCertTemplate::AltNameIncludesEMail() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesEMail(bool bIncludesEMail)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL, bIncludesEMail);
}

bool CCertTemplate::AltNameIncludesUPN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_UPN) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesUPN(bool bIncludesUPN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_UPN, bIncludesUPN);
}

bool CCertTemplate::SubjectNameIncludesEMail() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_REQUIRE_EMAIL) ? true : false;
}

HRESULT CCertTemplate::SubjectNameIncludesEMail(bool bIncludesEMail)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_REQUIRE_EMAIL, bIncludesEMail);
}

bool CCertTemplate::SubjectNameMustBeFullDN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH) ? true : false;
}

HRESULT CCertTemplate::SubjectNameMustBeFullDN(bool bMustBeDN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH, bMustBeDN);
}

bool CCertTemplate::SubjectNameMustBeCN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME) ? true : false;
}

HRESULT CCertTemplate::SubjectNameMustBeCN(bool bMustBeCN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME, bMustBeCN);
}

HRESULT CCertTemplate::RequireSubjectInRequest(bool bRequire)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT, bRequire);
}

bool CCertTemplate::AltNameIncludesSPN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_SPN) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesSPN(bool bIncludesSPN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_SPN, bIncludesSPN);
}

HRESULT CCertTemplate::SetMinimumKeySizeValue(DWORD dwMinKeySize)
{
    _TRACE (1, L"Entering CCertTemplate::SetMinimumKeySizeValue (%d)- m_hCertType = 0x%x\n", 
            dwMinKeySize, m_hCertType);
    HRESULT hr = S_OK;
    if ( m_hCertType )
    {
        hr = CASetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MIN_KEY_SIZE,
                &dwMinKeySize);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_MIN_KEY_SIZE) failed: 0x%x\n", hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetMinimumKeySizeValue (%d): 0x%x\n", dwMinKeySize, hr);
   return hr;

}


HRESULT CCertTemplate::ModifyCriticalExtensions (const CString &szExtension, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyCriticalExtensions (%s, bAdd=%s)\n", 
            (PCWSTR) szExtension, bAdd ? L"true" : L"false");
    PWSTR*   pawszCriticalExtensions = 0;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                &pawszCriticalExtensions);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszCriticalExtensions )
            pawszCriticalExtensions = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR));
        if ( pawszCriticalExtensions )
        {
            hr = ModifyStringList (CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                    &pawszCriticalExtensions, szExtension, bAdd);
            LocalFree (pawszCriticalExtensions);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CRITICAL_EXTENSIONS) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyCriticalExtensions: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifyCSPList(const CString &szCSPName, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyCSPList (%s, bAdd=%s)\n", 
            (PCWSTR) szCSPName, bAdd ? L"true" : L"false");
    PWSTR*   pawszCSPList = 0;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CSP_LIST,
                &pawszCSPList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszCSPList )
            pawszCSPList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszCSPList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_CSP_LIST,
                    &pawszCSPList, szCSPName, bAdd);
            LocalFree (pawszCSPList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CSP_LIST) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyCSPList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifyRAIssuancePolicyList(const CString &szRAPolicyOID, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyRAIssuancePolicyList (%s, bAdd=%s)\n", 
            (PCWSTR) szRAPolicyOID, bAdd ? L"true" : L"false");
    PWSTR*   pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszRAPolicyList )
            pawszRAPolicyList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszRAPolicyList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_RA_POLICY,
                    &pawszRAPolicyList, szRAPolicyOID, bAdd);
            LocalFree (pawszRAPolicyList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_POLICY) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyRAIssuancePolicyList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifyRAApplicationPolicyList(const CString &szRAPolicyOID, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyRAApplicationPolicyList (%s, bAdd=%s)\n", 
            (PCWSTR) szRAPolicyOID, bAdd ? L"true" : L"false");
    PWSTR*   pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_APPLICATION_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszRAPolicyList )
            pawszRAPolicyList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszRAPolicyList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_RA_APPLICATION_POLICY,
                    &pawszRAPolicyList, szRAPolicyOID, bAdd);
            LocalFree (pawszRAPolicyList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_APPLICATION_POLICY) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyRAApplicationPolicyList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifySupercededTemplateList(
        const CString &szSupercededTemplateName, 
        bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifySupercededTemplateList (%s, bAdd=%s)\n", 
            (PCWSTR) szSupercededTemplateName, bAdd ? L"true" : L"false");

    PWSTR*  pawszSupercededTemplateList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_SUPERSEDE,
            &pawszSupercededTemplateList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszSupercededTemplateList )
            pawszSupercededTemplateList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszSupercededTemplateList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_SUPERSEDE,
                    &pawszSupercededTemplateList, szSupercededTemplateName, bAdd);
            LocalFree (pawszSupercededTemplateList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_SUPERSEDE) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifySupercededTemplateList: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTemplate::ModifyStringList(const CString& szPropertyName, 
                                        PWSTR** ppStringList, 
                                        const CString &szValue, 
                                        bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyStringList (%s, bAdd=%s)\n", 
            (PCWSTR) szValue, bAdd ? L"true" : L"false");
    HRESULT hr = S_OK;
    if ( !szValue.IsEmpty () )
    {
        bool    bFound = false;
        int     nCnt = 0;
        size_t  cbNameBytes = 0;
        int     nDeleteIndex = -1;

        // count the number of items we already have and get the string lengths
        for (int nIndex = 0; (*ppStringList)[nIndex]; nIndex++)
        {
            nCnt++;
            cbNameBytes += (wcslen ((*ppStringList)[nIndex]) + 1) * sizeof (WCHAR);
            if ( !LocaleStrCmp (szValue, (*ppStringList)[nIndex]) )
            {
                bFound = true;
                if ( !bAdd )
                    nDeleteIndex = nIndex;
            }
        }

        // Adding a name: If the name was found, nothing needs to be done,
        // otherwise, increment the count and rebuild the list.
        // Removing a name: If the name was not found, nothing needs to be 
        // done, otherwise, decrement the count and rebuild the list.
        if ( (bAdd && !bFound) || (!bAdd && bFound) )
        {
            PWSTR *awszResult = 0;
            if ( bAdd )
                nCnt++;
            else
                nCnt--;

            if ( bAdd )
                cbNameBytes += (wcslen (szValue) + 1 ) * sizeof (WCHAR);
            size_t cbBuf = sizeof (WCHAR*) * (nCnt + 1) + // the WCHAR pointers
                    cbNameBytes;                          // the strings themselves
            awszResult = (WCHAR**) LocalAlloc (LPTR, cbBuf); 
            if ( awszResult )
            {
                // set the ptr to the space after the last valid index (
                // including the NULL terminator
                PWSTR   ptr = (WCHAR*) &awszResult[nCnt+1];
                int     nTgtIndex = 0;
                for (int nSrcIndex = 0; (*ppStringList)[nSrcIndex]; nSrcIndex++)
                {
                    // If we are removing the name, and this is the item to be
                    // removed, then skip this name and go to the next
                    if ( !bAdd && nSrcIndex == nDeleteIndex )
                        continue;

                    awszResult[nTgtIndex] = ptr;
                    ptr += wcslen ((*ppStringList)[nSrcIndex]) + 1; // ptr arithmetic - increments by sizeof (WCHAR)
                    wcscpy (awszResult[nTgtIndex], (*ppStringList)[nSrcIndex]);
                    nTgtIndex++;
                }

                // If we are adding, append the name here
                if ( bAdd )
                {
                    awszResult[nTgtIndex] = ptr;
                    ptr += wcslen (szValue) + 1; // ptr arithmetic - increments by sizeof (WCHAR)
                    wcscpy (awszResult[nTgtIndex], szValue);
                    nTgtIndex++;
                }

                _ASSERT (nTgtIndex == nCnt);
                awszResult[nTgtIndex] = 0;

                LocalFree (*ppStringList);
                (*ppStringList) = awszResult;
                hr = CASetCertTypePropertyEx (m_hCertType,
                        szPropertyName,
                        (*ppStringList));
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"CASetCertTypePropertyEx (%s) failed: 0x%x\n", 
                            szPropertyName, hr);
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = E_INVALIDARG;

    _TRACE (-1, L"Leaving CCertTemplate::ModifyStringList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::IsExtensionCritical (PCWSTR szExtension, bool& bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::IsExtensionCritical (szExtension=%s\n", szExtension);

    // Get Cryptographic Service Providers
    PWSTR*   pawszCriticalExtensionList = 0;
    bCritical = false;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                &pawszCriticalExtensionList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszCriticalExtensionList )
        {
            for (int nIndex = 0; pawszCriticalExtensionList[nIndex]; nIndex++)
            {
                if ( !wcscmp (szExtension, pawszCriticalExtensionList[nIndex]) )
                {
                    bCritical = true;
                    break;
                }
            }

            LocalFree (pawszCriticalExtensionList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CRITICAL_EXTENSIONS) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::GeIsExtensionCriticaltCSP (szCSP=%s, bCritical=%s): 0x%x\n", 
            szExtension, bCritical ? L"true" : L"false", hr);
    return hr;
}


HRESULT CCertTemplate::GetCSP(int nIndex, CString &szCSP)
{
    _TRACE (1, L"Entering CCertTemplate::GetCSP (nIndex=%d\n", nIndex);

    // Get Cryptographic Service Providers
    PWSTR*   pawszCSPList = 0;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CSP_LIST,
                &pawszCSPList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszCSPList )
        {
            int     nCnt = 0;
            while ( pawszCSPList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szCSP = pawszCSPList[nIndex];
            else
                hr = E_INVALIDARG;

            LocalFree (pawszCSPList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CSP_LIST) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::GetCSP (szCSP=%s): 0x%x\n", 
            (PCWSTR) szCSP, hr);
    return hr;
}

HRESULT CCertTemplate::GetCertPolicy (int nIndex, CString &szCertPolicy)
{
    _TRACE (1, L"Entering CCertTemplate::GetCertPolicy (nIndex=%d\n", nIndex);
    HRESULT hr = S_OK;
    PWSTR*  pawszCertPolicyList = 0;

    hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_POLICY,
            &pawszCertPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszCertPolicyList )
        {
            int nCnt = 0;
            while ( pawszCertPolicyList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szCertPolicy = pawszCertPolicyList[nIndex];
            else
                hr = E_FAIL;

            LocalFree (pawszCertPolicyList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetCertPolicy (szCSP=%s): 0x%x\n", 
            (PCWSTR) szCertPolicy, hr);
    return hr;
}

HRESULT CCertTemplate::GetRAIssuancePolicy (int nIndex, CString &szRAPolicyOID)
{
    _TRACE (1, L"Entering CCertTemplate::GetRAIssuancePolicy (nIndex=%d\n", nIndex);
    
    PWSTR*  pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszRAPolicyList )
        {
            int     nCnt = 0;

            while ( pawszRAPolicyList[nCnt] )
                nCnt++;

             if ( nIndex < nCnt )
                szRAPolicyOID = pawszRAPolicyList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszRAPolicyList);
       }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetRAIssuancePolicy (szRAPolicyOID=%s): 0x%x\n", 
            (PCWSTR) szRAPolicyOID, hr);
    return hr;
}

HRESULT CCertTemplate::GetRAApplicationPolicy (int nIndex, CString &szRAPolicyOID)
{
    _TRACE (1, L"Entering CCertTemplate::GetRAApplicationPolicy (nIndex=%d\n", nIndex);
    
    PWSTR*  pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_APPLICATION_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszRAPolicyList )
        {
            int     nCnt = 0;

            while ( pawszRAPolicyList[nCnt] )
                nCnt++;

             if ( nIndex < nCnt )
                szRAPolicyOID = pawszRAPolicyList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszRAPolicyList);
       }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_APPLICATION_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetRAApplicationPolicy (szRAPolicyOID=%s): 0x%x\n", 
            (PCWSTR) szRAPolicyOID, hr);
    return hr;
}
HRESULT CCertTemplate::GetSupercededTemplate(int nIndex, CString &szSupercededTemplate)
{
    _TRACE (1, L"Entering CCertTemplate::GetSupercededTemplate (nIndex=%d\n", nIndex);
    PWSTR*  pawszSupercededTemplateList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_SUPERSEDE,
            &pawszSupercededTemplateList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszSupercededTemplateList )
        {
            int     nCnt = 0;
            while ( pawszSupercededTemplateList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szSupercededTemplate = pawszSupercededTemplateList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszSupercededTemplateList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_SUPERSEDE) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetSupercededTemplate (szSupercededTemplate=%s): 0x%x\n", 
            (PCWSTR) szSupercededTemplate, hr);
    return hr;
}

bool CCertTemplate::ReadOnly() const
{
    return m_fIsReadOnly;
}

HRESULT CCertTemplate::SetSecurity(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = CACertTypeSetSecurity (m_hCertType, pSD);
    if (S_OK != hr)
	    return hr;

    hr = CAUpdateCertType(m_hCertType);
    if ( FAILED (hr) )
        Cancel ();

    return hr;
}

HRESULT CCertTemplate::GetSecurity(PSECURITY_DESCRIPTOR *ppSD) const
{
    return CACertTypeGetSecurity (m_hCertType, ppSD);
}

CString CCertTemplate::GetLDAPPath() const
{
    return m_szLDAPPath;
}

HRESULT CCertTemplate::SetValidityPeriod(int nDays)
{
    HRESULT hr = S_OK;

    if ( nDays >= 0 )
        this->m_nNewValidityDays = nDays;
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CCertTemplate::SetRenewalPeriod(int nDays)
{
    HRESULT hr = S_OK;

    if ( nDays >= 0 )
        this->m_nNewRenewalDays = nDays;
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CCertTemplate::SetPublishToDS(bool bPublish)
{
    _TRACE (1, L"Entering CCertTemplate::SetPublishToDS - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_PUBLISH_TO_DS, bPublish);


    _TRACE (-1, L"Leaving CCertTemplate::SetPublishToDS: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::GetRANumSignaturesRequired(DWORD &dwNumSignatures)
{
    _TRACE (1, L"Entering CCertTemplate::GetRANumSignaturesRequired - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    
    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_RA_SIGNATURE,
            &dwNumSignatures);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_RA_SIGNATURE) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::GetRANumSignaturesRequired: 0x%x\n", hr);

    return hr;
}

HRESULT CCertTemplate::SetRANumSignaturesRequired(DWORD dwNumSignaturesRequired)
{
    _TRACE (1, L"Entering CCertTemplate::SetRANumSignaturesRequired (%d)- m_hCertType = 0x%x\n", 
            dwNumSignaturesRequired, m_hCertType);
    HRESULT hr = S_OK;
    if ( m_hCertType )
    {
        hr = CASetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_RA_SIGNATURE,
                &dwNumSignaturesRequired);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_RA_SIGNATURE) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;


    _TRACE (-1, L"Leaving CCertTemplate::SetRANumSignaturesRequired (): 0x%x\n", hr);

   return hr;
}

bool CCertTemplate::ReenrollmentValidWithPreviousApproval() const
{
    return m_dwEnrollmentFlags & CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT ? true : false;
}

HRESULT CCertTemplate::SetReenrollmentValidWithPreviousApproval(bool bValid)
{
    _TRACE (1, L"Entering CCertTemplate::SetReenrollmentValidWithPreviousApproval - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT, bValid);


    _TRACE (-1, L"Leaving CCertTemplate::SetReenrollmentValidWithPreviousApproval: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::PendAllRequests() const
{
    return m_dwEnrollmentFlags & CT_FLAG_PEND_ALL_REQUESTS ? true : false;
}

HRESULT CCertTemplate::SetPendAllRequests(bool bPend)
{
    _TRACE (1, L"Entering CCertTemplate::SetPendAllRequests - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_PEND_ALL_REQUESTS, bPend);


    _TRACE (-1, L"Leaving CCertTemplate::SetPendAllRequests: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::GetMajorVersion(DWORD &dwMajorVersion) const
{
//    _TRACE (1, L"Entering CCertTemplate::GetMajorVersion\n");
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_REVISION,
                &dwMajorVersion);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

//    _TRACE (-1, L"Leaving CCertTemplate::GetMajorVersion (dwMajorVersion = %d) : 0x%x\n", 
//            dwMajorVersion, hr);
    return hr;
}

HRESULT CCertTemplate::GetMinorVersion(DWORD &dwMinorVersion) const
{
//    _TRACE (1, L"Entering CCertTemplate::GetMinorVersion\n");
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MINOR_REVISION,
                &dwMinorVersion);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

//    _TRACE (-1, L"Leaving CCertTemplate::GetMinorVersion (dwMinorVersion = %d) : 0x%x\n", 
//            dwMinorVersion, hr);
    return hr;
}

HRESULT CCertTemplate::IncrementMajorVersion()
{
   _TRACE (1, L"Entering CCertTemplate::IncrementMajorVersion\n");
    HRESULT hr = S_OK;
    DWORD   dwMajorVersion = 0;

    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_REVISION,
                &dwMajorVersion);
        if ( SUCCEEDED (hr) )
        {
            dwMajorVersion++;
            hr = CASetCertTypePropertyEx (m_hCertType,
                    CERTTYPE_PROP_REVISION,
                    &dwMajorVersion);
            if ( SUCCEEDED (hr) )
            {
                DWORD dwMinorVersion = 0;
                hr = CASetCertTypePropertyEx (m_hCertType,
                        CERTTYPE_PROP_MINOR_REVISION,
                        &dwMinorVersion);
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION, %d) failed: 0x%x\n", 
                            dwMinorVersion, hr);
                }
            }
            else
            {
                _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_REVISION, %d) failed: 0x%x\n", 
                        dwMajorVersion, hr);
            }
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::IncrementMajorVersion (dwMajorVersion = %d) : 0x%x\n", 
            dwMajorVersion, hr);
    return hr;
}

HRESULT CCertTemplate::IncrementMinorVersion()
{
   _TRACE (1, L"Entering CCertTemplate::IncrementMinorVersion\n");
    HRESULT hr = S_OK;
    DWORD   dwMinorVersion = 0;

    if ( m_hCertType )
    {
        
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MINOR_REVISION,
                &dwMinorVersion);
        if ( SUCCEEDED (hr) )
        {
            dwMinorVersion++;
            hr = CASetCertTypePropertyEx (m_hCertType,
                    CERTTYPE_PROP_MINOR_REVISION,
                    &dwMinorVersion);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION, %d) failed: 0x%x\n", 
                        dwMinorVersion, hr);
            }
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::IncrementMinorVersion (dwMinorVersion = %d) : 0x%x\n", 
            dwMinorVersion, hr);
    return hr;
}

bool CCertTemplate::GoodForAutoEnrollment() const
{
    bool    bGoodForAutoEnrollment = false;

    // Bug 175912 Version 1 type templates not good for autoenrollment    
    if ( (GetType () > 1) && (m_dwEnrollmentFlags & CT_FLAG_AUTO_ENROLLMENT) )
        bGoodForAutoEnrollment = true;

    return bGoodForAutoEnrollment;
}

HRESULT CCertTemplate::SetKeyUsage(CRYPT_BIT_BLOB* pKeyUsage, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetKeyUsage\n");
    HRESULT hr = S_OK;
    if ( pKeyUsage )
    {
        hr = CASetCertTypeExtension(
                m_hCertType,
                TEXT (szOID_KEY_USAGE),
                bCritical ? CA_EXT_FLAG_CRITICAL : 0,
                pKeyUsage);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeExtension (szOID_KEY_USAGE) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTemplate::SetKeyUsage: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetBasicConstraints(PCERT_BASIC_CONSTRAINTS2_INFO pBCInfo, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetBasicConstraints\n");
    HRESULT hr = S_OK;
    if ( pBCInfo )
    {
        hr = CASetCertTypeExtension(
                m_hCertType,
                TEXT (szOID_BASIC_CONSTRAINTS2), 
                bCritical ? CA_EXT_FLAG_CRITICAL : 0,
                pBCInfo);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeExtension (X509_BASIC_CONSTRAINTS2) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTemplate::SetBasicConstraints: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::CheckDSCert() const
{
    return (m_dwEnrollmentFlags & CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE) ? true : false;
}

HRESULT CCertTemplate::SetCheckDSCert(bool bCheck)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE, bCheck);
}

bool CCertTemplate::RemoveInvalidCertFromPersonalStore () const
{
    return (m_dwEnrollmentFlags & CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE) ? true : false;
}


HRESULT CCertTemplate::SetRemoveInvalidCertFromPersonalStore(bool bRemove)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE, bRemove);
}

bool CCertTemplate::UserInteractionRequired () const
{
    return (m_dwEnrollmentFlags & CT_FLAG_USER_INTERACTION_REQUIRED) ? true : false;
}


HRESULT CCertTemplate::SetUserInteractionRequired(bool bSet)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_USER_INTERACTION_REQUIRED, bSet);
}


HRESULT CCertTemplate::GetEnhancedKeyUsage (int nIndex, CString &szEKU)
{
    _TRACE (1, L"Entering CCertTemplate::GetEnhancedKeyUsage (nIndex=%d\n", nIndex);
    HRESULT hr = S_OK;
    PWSTR*  pawszEKU = 0;

    hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_EXTENDED_KEY_USAGE,
            &pawszEKU);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszEKU )
        {
            int nCnt = 0;

            while ( pawszEKU[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szEKU = pawszEKU[nIndex];
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

        LocalFree (pawszEKU);
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_EXTENDED_KEY_USAGE) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetEnhancedKeyUsage (szEKU=%s): 0x%x\n", 
            (PCWSTR) szEKU, hr);
    return hr;
}

HRESULT CCertTemplate::GetApplicationPolicy (int nIndex, CString &szAppPolicy)
{
    _TRACE (1, L"Entering CCertTemplate::GetApplicationPolicy (nIndex=%d\n", nIndex);
    HRESULT hr = S_OK;
    PWSTR*  pawszAppPolicy = 0;

    hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_APPLICATION_POLICY,
            &pawszAppPolicy);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszAppPolicy )
        {
            int nCnt = 0;

            while ( pawszAppPolicy[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szAppPolicy = pawszAppPolicy[nIndex];
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

        LocalFree (pawszAppPolicy);
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_APPLICATION_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetApplicationPolicy (szAppPolicy=%s): 0x%x\n", 
            (PCWSTR) szAppPolicy, hr);
    return hr;
}

HRESULT CCertTemplate::SetEnhancedKeyUsage (const PWSTR* pawszEKU, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetEnhancedKeyUsage ()\n");
    HRESULT hr = S_OK;

    hr = CASetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_EXTENDED_KEY_USAGE,
            (PVOID) pawszEKU);
    if ( SUCCEEDED (hr) )
    {
         hr = ModifyCriticalExtensions (szOID_ENHANCED_KEY_USAGE, bCritical);
    }
    else
    {
        _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_EXTENDED_KEY_USAGE) failed: 0x%x\n", 
                hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetEnhancedKeyUsage: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetApplicationPolicy (const PWSTR* pawszAppPolicy, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetApplicationPolicy ()\n");
    HRESULT hr = S_OK;

    hr = CASetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_APPLICATION_POLICY,
            (PVOID) pawszAppPolicy);
    if ( SUCCEEDED (hr) )
    {
         hr = ModifyCriticalExtensions (szOID_APPLICATION_CERT_POLICIES, bCritical);
    }
    else
    {
        _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_APPLICATION_POLICY) failed: 0x%x\n", 
                hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetApplicationPolicy: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetCertPolicy (const PWSTR* pawszCertPolicy, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetCertPolicy ()\n");
    HRESULT hr = S_OK;

    hr = CASetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_POLICY,
            (PVOID) pawszCertPolicy);
    if ( SUCCEEDED (hr) )
    {
         hr = ModifyCriticalExtensions (szOID_CERT_POLICIES, bCritical);
    }
    else
    {
        _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_POLICY) failed: 0x%x\n", 
                hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetCertPolicy: 0x%x\n", hr);
    return hr;
}
void CCertTemplate::FreeCertExtensions()
{
    if ( m_pCertExtensions )
    {
        CAFreeCertTypeExtensions (m_hCertType, m_pCertExtensions);
        m_pCertExtensions = 0;
    }
}

HRESULT CCertTemplate::Cancel()
{
    _TRACE (1, L"Entering CCertTemplate::Cancel\n");
    HRESULT hr = S_OK;

    // Close and re-open cert template without saving.
    if ( m_hCertType )
    {
        FreeCertExtensions ();

        hr = CACloseCertType (m_hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            m_hCertType = 0;

            // Reinitialize the cert template
            if ( !m_bIsClone )
                hr = Initialize ();
        }
        else
        {
            _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L":Leaving CCertTemplate::Cancel: 0x%x\n", hr);
    return hr;
}

/*  NO LONGER NEEDED  NTRAID# 321742
bool CCertTemplate::AllowAutoenrollment()
{
    // Bug 251388 "There are templates that should never be allowed to set 
    // autoenrollment flag (CT_FLAG_AUTO_ENROLLMENT).   The "Allow 
    // Autoenrollment" task for those templates should be disabled if one of 
    // the following three conditions is true:
    //
    // templates whose subject name flag has CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT  
    // set; 	
	// templates whose subject name flag has 
    // CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME set; 
	// templates whose CERTTYPE_PROP_RA_SIGNATURE is greater than 1 and 
    // CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT is not set in the 
    // enrollment flag."
    bool    bResult = true;
    DWORD   dwNumSignatures = 0;
    
    GetRANumSignaturesRequired (dwNumSignatures);

    // NTRAID# 175912 Version 1 type templates not good for autoenrollment
    if ( 1 == GetType () ||
        (m_dwSubjectNameFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT) ||
            (m_dwSubjectNameFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME) ||
            ( dwNumSignatures > 1 &&
                !(m_dwEnrollmentFlags & CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT)) )
    {
        bResult = false;
    }

    // NTRAID# 276180 Certificate Template Snap-in: Grey out "Allow 
    // Autoenrollment" context menu based on properties of the template
    if ( RequireSubjectInRequest () ||
            dwNumSignatures >= 2 && !ReenrollmentValidWithPreviousApproval () )
    {
        bResult = false;
    }

    return bResult;
}
*/

HRESULT CCertTemplate::GetSubjectTypeDescription (int nIndex, CString &szSubjectTypeDescription)
{
    _TRACE (1, L"Entering CCertTemplate::GetSubjectTypeDescription (nIndex=%d\n", nIndex);
    
    PWSTR*  pawszSubjectTypeDescriptionList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_DESCRIPTION,
            &pawszSubjectTypeDescriptionList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszSubjectTypeDescriptionList )
        {
            int     nCnt = 0;

            while ( pawszSubjectTypeDescriptionList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szSubjectTypeDescription = pawszSubjectTypeDescriptionList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszSubjectTypeDescriptionList);
       }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_DESCRIPTION) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetSubjectTypeDescription (szRAPolicyOID=%s): 0x%x\n", 
            (PCWSTR) szSubjectTypeDescription, hr);
    return hr;
}

// NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
// option list with v2 templates that have ENC and SIG as purpose.
HRESULT CCertTemplate::SetDigitalSignature(bool bSet)
{
    _TRACE (1, L"Entering CCertTemplate::SetDigitalSignature (bSet = %s)\n", bSet ? L"true" : L"false");
    PCERT_EXTENSION pCertExtension = 0;
    HRESULT hr = GetCertExtension (szOID_KEY_USAGE, &pCertExtension);
    if ( SUCCEEDED (hr) )
    {
	    ASSERT (pCertExtension);
	    if ( pCertExtension )
	    {
            DWORD   cbKeyUsage = 0;
		    if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				    szOID_KEY_USAGE, 
				    pCertExtension->Value.pbData,
				    pCertExtension->Value.cbData,
				    0, NULL, &cbKeyUsage) )
		    {
                CRYPT_BIT_BLOB* pKeyUsage = (CRYPT_BIT_BLOB*)
					    ::LocalAlloc (LPTR, cbKeyUsage);
			    if ( pKeyUsage )
			    {
				    if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						    szOID_KEY_USAGE, 
						    pCertExtension->Value.pbData,
						    pCertExtension->Value.cbData,
						    0, pKeyUsage, &cbKeyUsage) )
				    {
                        if (pKeyUsage->cbData >= 1)
                        {
                            pKeyUsage->cUnusedBits = 0;

                            if ( bSet )
                                pKeyUsage->pbData[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;
                            else
                                pKeyUsage->pbData[0] &= ~CERT_DIGITAL_SIGNATURE_KEY_USAGE;

                            hr = SetKeyUsage (pKeyUsage, pCertExtension->fCritical ? true : false);
                        }
                        else
                            hr = E_FAIL;
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
                    }
                    LocalFree (pKeyUsage);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
            }
        }

        FreeCertExtensions ();
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetDigitalSignature (bSet = %s): 0x%x\n", 
            bSet ? L"true" : L"false", hr);
    return hr;
}

HRESULT CCertTemplate::GetDigitalSignature(bool &bHasDigitalSignature)
{
    _TRACE (1, L"Entering CCertTemplate::GetDigitalSignature ()\n");
    PCERT_EXTENSION pCertExtension = 0;
    HRESULT hr = GetCertExtension (szOID_KEY_USAGE, &pCertExtension);
    if ( SUCCEEDED (hr) )
    {
	    ASSERT (pCertExtension);
	    if ( pCertExtension )
	    {
            DWORD   cbKeyUsage = 0;
		    if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				    szOID_KEY_USAGE, 
				    pCertExtension->Value.pbData,
				    pCertExtension->Value.cbData,
				    0, NULL, &cbKeyUsage) )
		    {
                CRYPT_BIT_BLOB* pKeyUsage = (CRYPT_BIT_BLOB*)
					    ::LocalAlloc (LPTR, cbKeyUsage);
			    if ( pKeyUsage )
			    {
				    if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						    szOID_KEY_USAGE, 
						    pCertExtension->Value.pbData,
						    pCertExtension->Value.cbData,
						    0, pKeyUsage, &cbKeyUsage) )
				    {
                        if (pKeyUsage->cbData >= 1)
                        {
                            pKeyUsage->cUnusedBits = 0;

                            if ( pKeyUsage->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                                bHasDigitalSignature = true;
                            else
                                bHasDigitalSignature = false;
                        }
                        else
                            hr = E_FAIL;
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
                    }
                    LocalFree (pKeyUsage);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
            }
        }

        FreeCertExtensions ();
    }

    _TRACE (-1, L"Leaving CCertTemplate::GetDigitalSignature (bHasDigitalSignature = %s): 0x%x\n", 
            bHasDigitalSignature ? L"true" : L"false", hr);
    return hr;
}

void CCertTemplate::IssuancePoliciesRequired(bool bRequired)
{
    m_bIssuancePoliciesRequired = bRequired;
}

bool CCertTemplate::IssuancePoliciesRequired() const
{
    return m_bIssuancePoliciesRequired;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\compdata.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       compdata.cpp
//
//  Contents:   Implementation of CCertTmplComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTTMPL (compdata.cpp)")
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "uuids.h"
#include "TemplateGeneralPropertyPage.h"
#include "TemplateV1RequestPropertyPage.h"
#include "TemplateV2RequestPropertyPage.h"
#include "TemplateV1SubjectNamePropertyPage.h"
#include "TemplateV2SubjectNamePropertyPage.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "TemplateExtensionsPropertyPage.h"
#include "SecurityPropertyPage.h"
#include "TemplatePropertySheet.h"
#include "ViewOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "dbg.h"
#include "stdcdata.cpp" // CComponentData implementation

extern  HINSTANCE   g_hInstance;
POLICY_OID_LIST	    g_policyOIDList;

BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall);

extern bool g_bSchemaIsW2K;

//
// CCertTmplComponentData
//

CCertTmplComponentData::CCertTmplComponentData ()
    : m_RootCookie (CERTTMPL_SNAPIN),
    m_hRootScopeItem (0),
    m_pResultData (0),
    m_bIsUserAdministrator (FALSE),
    m_pHeader (0),
    m_bMultipleObjectsSelected (false),
	m_dwNumCertTemplates (0),
	m_pComponentConsole (0),
    m_fUseCache (false),
    m_bSchemaChecked (false)
{
    _TRACE (1, L"Entering CCertTmplComponentData::CCertTmplComponentData\n");

    // Get name of logged-in user
    DWORD   dwSize = 0;
    ::GetUserName (0, &dwSize);
    BOOL bRet = ::GetUserName (m_szLoggedInUser.GetBufferSetLength (dwSize), &dwSize);
    _ASSERT (bRet);
    m_szLoggedInUser.ReleaseBuffer ();

    // Get name of this computer
    dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
    bRet = ::GetComputerName (m_szThisComputer.GetBufferSetLength (MAX_COMPUTERNAME_LENGTH + 1 ), &dwSize);
    _ASSERT (bRet);
    m_szThisComputer.ReleaseBuffer ();

    // Find out if logged-in users is an Administrator
    HRESULT hr = IsUserAdministrator (m_bIsUserAdministrator);
    _ASSERT (SUCCEEDED (hr));

    // default help file name.
    SetHtmlHelpFileName (CERTTMPL_HTML_HELP_FILE);

    // Find out if we're joined to a domain.
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pInfo = 0;
    DWORD dwErr = ::DsRoleGetPrimaryDomainInformation (
            0,
            DsRolePrimaryDomainInfoBasic, 
            (PBYTE*) &pInfo);
    if ( ERROR_SUCCESS == dwErr )
    {
        if ( pInfo->Flags & DSROLE_PRIMARY_DS_RUNNING ||
				pInfo->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT )
		{
			m_szThisDomainDns = pInfo->DomainNameDns;
			m_RootCookie.SetManagedDomainDNSName (m_szThisDomainDns);
			m_szThisDomainFlat = pInfo->DomainNameFlat;
		}
    }
    else
    {
        _TRACE (0, L"DsRoleGetPrimaryDomainInformation () failed: 0x%x\n", dwErr);
    }

    NetApiBufferFree (pInfo);

    _TRACE (-1, L"Leaving CCertTmplComponentData::CCertTmplComponentData\n");
}

CCertTmplComponentData::~CCertTmplComponentData ()
{
    _TRACE (1, L"Entering CCertTmplComponentData::~CCertTmplComponentData\n");
    CCookie& rootCookie = QueryBaseRootCookie ();
    while ( !rootCookie.m_listResultCookieBlocks.IsEmpty() )
    {
        (rootCookie.m_listResultCookieBlocks.RemoveHead())->Release();
    }

    if ( m_pResultData )
    {
        m_pResultData->Release ();
        m_pResultData = 0;
    }

    if ( m_pComponentConsole )
    {
        SAFE_RELEASE (m_pComponentConsole);
        m_pComponentConsole = 0;
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::~CCertTmplComponentData\n");
}

DEFINE_FORWARDS_MACHINE_NAME ( CCertTmplComponentData, (&m_RootCookie) )

CCookie& CCertTmplComponentData::QueryBaseRootCookie ()
{
    return (CCookie&) m_RootCookie;
}


STDMETHODIMP CCertTmplComponentData::CreateComponent (LPCOMPONENT* ppComponent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::CreateComponent\n");
    _ASSERT (ppComponent);

    CComObject<CCertTmplComponent>* pObject = 0;
    CComObject<CCertTmplComponent>::CreateInstance (&pObject);
    _ASSERT (pObject);
    pObject->SetComponentDataPtr ( (CCertTmplComponentData*) this);

    _TRACE (-1, L"Leaving CCertTmplComponentData::CreateComponent\n");
    return pObject->QueryInterface (IID_PPV_ARG (IComponent, ppComponent));
}

HRESULT CCertTmplComponentData::LoadIcons (LPIMAGELIST pImageList, BOOL /*fLoadLargeIcons*/)
{
    _TRACE (1, L"Entering CCertTmplComponentData::LoadIcons\n");
    // Structure to map a Resource ID to an index of icon
    struct RESID2IICON
    {
        UINT uIconId;   // Icon resource ID
        int iIcon;      // Index of the icon in the image list
    };
    const static RESID2IICON rgzLoadIconList[] =
    {
        // Misc icons
        { IDI_CERT_TEMPLATEV1, iIconCertTemplateV1 },
        { IDI_CERT_TEMPLATEV2, iIconCertTemplateV2 },
        { 0, 0} // Must be last
    };


    for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
    {
        HICON hIcon = ::LoadIcon (AfxGetInstanceHandle (),
                MAKEINTRESOURCE (rgzLoadIconList[i].uIconId));
        _ASSERT (hIcon && "Icon ID not found in resources");
        HRESULT hr = pImageList->ImageListSetIcon ( (PLONG_PTR) hIcon,
                rgzLoadIconList[i].iIcon);
        _ASSERT (SUCCEEDED (hr) && "Unable to add icon to ImageList");
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::LoadIcons\n");

    return S_OK;
}


HRESULT CCertTmplComponentData::OnNotifyExpand (LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnNotifyExpand\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT     hr = S_OK;
    CWaitCursor waitCursor;

    _ASSERT (pDataObject && hParent && m_pConsoleNameSpace);
    if ( bExpanding )
    {
        // Need to check schema first before getting OIDs (sets g_bSchemaIsW2K)
        if ( !m_bSchemaChecked )
        {
            InstallWindows2002CertTemplates ();
            m_bSchemaChecked = true;
        }

        if ( 0 == g_policyOIDList.GetCount () )
        {
            hr = GetEnterpriseOIDs ();
            if ( FAILED (hr) )
            {
                if ( HRESULT_FROM_WIN32 (ERROR_DS_NO_SUCH_OBJECT) == hr )
                    g_bSchemaIsW2K = true;

                if ( !g_bSchemaIsW2K )
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    text.FormatMessage (IDS_CANNOT_LOAD_OID_LIST, GetSystemMessage (hr));

                    int     iRetVal = 0;
                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                            MB_ICONWARNING | MB_OK, &iRetVal)));
                }
                else
                    hr = S_OK;
            }
        }


        GUID guidObjectType;
        hr = ExtractObjectTypeGUID (pDataObject, &guidObjectType);
        _ASSERT (SUCCEEDED (hr));

        // Beyond this point we are not dealing with extension node types.
        {
            CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
            if ( pParentCookie )
            {
                hr = ExpandScopeNodes (pParentCookie, hParent, guidObjectType, pDataObject);
            }
            else
                hr = E_UNEXPECTED;
        }
    }
    else
        hr = S_OK;


    _TRACE (-1, L"Leaving CCertTmplComponentData::OnNotifyExpand: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::OnNotifyRelease (LPDATAOBJECT /*pDataObject*/, HSCOPEITEM hItem)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnNotifyRelease\n");
    // _ASSERT ( IsExtensionSnapin () );
    // This might also happen if I expand a node and then remove
    // the snapin via Snapin Manager
    HRESULT hr = DeleteChildren (hItem);

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnNotifyRelease: 0x%x\n", hr);
    return hr;
}

// global space to store the string handed back to GetDisplayInfo ()
// CODEWORK should use "bstr" for ANSI-ization
CString g_strResultColumnText;

BSTR CCertTmplComponentData::QueryResultColumnText (CCookie& basecookie, int /*nCol*/)
{
    BSTR    strResult = L"";

    CCertTmplCookie& cookie = (CCertTmplCookie&) basecookie;
#ifndef UNICODE
#error not ANSI-enabled
#endif
    switch ( cookie.m_objecttype )
    {
        case CERTTMPL_SNAPIN:
            break;

        case CERTTMPL_CERT_TEMPLATE:
            _ASSERT (0);
            break;

        default:
            break;
    }

    return strResult;
}

int CCertTmplComponentData::QueryImage (CCookie& basecookie, BOOL /*fOpenImage*/)
{
    int             nIcon = 0;

    CCertTmplCookie& cookie = (CCertTmplCookie&)basecookie;
    switch ( cookie.m_objecttype )
    {
        case CERTTMPL_SNAPIN:
            nIcon = iIconCertTemplateV2;
            break;

        case CERTTMPL_CERT_TEMPLATE:
            {
                CCertTemplate& rCertTemplate = (CCertTemplate&) cookie;

                if ( 1 == rCertTemplate.GetType () )
                    nIcon = iIconCertTemplateV1;
                else
                    nIcon = iIconCertTemplateV2;
            }
            break;

        default:
            _TRACE (0, L"CCertTmplComponentData::QueryImage bad parent type\n");
            break;
    }
    return nIcon;
}


///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CCertTmplComponentData::QueryPagesFor (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::QueryPagesFor\n");
    HRESULT hr = S_OK;
    _ASSERT (pDataObject);

    if ( pDataObject )
    {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ::ExtractData (pDataObject,
                CCertTemplatesDataObject::m_CFDataObjectType,
                 &dataobjecttype, sizeof (dataobjecttype));
        if ( SUCCEEDED (hr) )
        {
            switch (dataobjecttype)
            {
            case CCT_SNAPIN_MANAGER:
                hr = S_FALSE;
                break;

            case CCT_RESULT:
                {
                    hr = S_FALSE;
                    CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
                    if ( pParentCookie )
                    {
                        switch (pParentCookie->m_objecttype)
                        {
                        case CERTTMPL_CERT_TEMPLATE:
                            hr = S_OK;
                            break;

                        default:
                            break;
                        }
                    }
                }
                break;

            case CCT_SCOPE:
                hr = S_FALSE;
                break;

            default:
                hr = S_FALSE;
                break;
            }
        }
    }
    else
        hr = E_POINTER;


    _TRACE (-1, L"Leaving CCertTmplComponentData::QueryPagesFor: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertTmplComponentData::CreatePropertyPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    LONG_PTR lNotifyHandle,        // This handle must be saved in the property page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _TRACE (1, L"Entering CCertTmplComponentData::CreatePropertyPages\n");
    HRESULT hr = S_OK;


    _ASSERT (pCallback && pDataObject);
    if ( pCallback && pDataObject )
    {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ::ExtractData (pDataObject,
                CCertTemplatesDataObject::m_CFDataObjectType,
                 &dataobjecttype, sizeof (dataobjecttype));
        switch (dataobjecttype)
        {
        case CCT_SNAPIN_MANAGER:
            break;

        case CCT_RESULT:
            {
                CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
                if ( pParentCookie )
                {
                    switch (pParentCookie->m_objecttype)
                    {
                    case CERTTMPL_CERT_TEMPLATE:
                        {
                            CCertTemplate* pCertTemplate = 
                                    dynamic_cast <CCertTemplate*> (pParentCookie);
                            _ASSERT (pCertTemplate);
                            if ( pCertTemplate )
                            {
                                hr = AddCertTemplatePropPages (pCertTemplate, 
                                        pCallback, lNotifyHandle);
                            }
                            else
                                hr = E_FAIL;
                        }
                        break;

                    default:
                        _ASSERT (0);
                        break;
                    }
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CCT_SCOPE:
            {
                CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
                if ( pParentCookie )
                {
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;


        default:
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::CreatePropertyPages: 0x%x\n", hr);
    return hr;
}




BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static UINT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertTmplComponentData::AddMenuItems (LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddMenuItems\n");
    HRESULT                         hr = S_OK;

    CCertTmplCookie*                 pCookie = 0;

    LPDATAOBJECT    pMSDO = ExtractMultiSelect (pDataObject);
    m_bMultipleObjectsSelected = false;

    if ( pMSDO )
    {
        m_bMultipleObjectsSelected = true;

        CCertTemplatesDataObject* pDO = dynamic_cast <CCertTemplatesDataObject*>(pMSDO);
        _ASSERT (pDO);
        if ( pDO )
        {
            // Get first cookie - all items should be the same?
            // Is this a valid assumption?
            // TODO: Verify
            pDO->Reset();
            if ( pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) == S_FALSE )
                return S_FALSE;
        }
        else
            return E_UNEXPECTED;

    }
    else
        pCookie = ConvertCookie (pDataObject);
    _ASSERT (pCookie);
    if ( !pCookie )
        return E_UNEXPECTED;

    CertTmplObjectType    objType = pCookie->m_objecttype;


    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
    {
        switch (objType)
        {
        case CERTTMPL_CERT_TEMPLATE:
            if ( !m_bMultipleObjectsSelected )
            {
                CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
                _ASSERT (pCertTemplate);
                if ( pCertTemplate )
                {
                    if ( !g_bSchemaIsW2K )
                    {
                        hr = AddCloneTemplateMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TOP);
                        if ( SUCCEEDED (hr) )
                        {
                            hr = AddReEnrollAllCertsMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TOP);
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;

        case CERTTMPL_SNAPIN:
            _ASSERT (!m_bMultipleObjectsSelected);
            hr = AddViewOIDsMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TOP);
            break;


        default:
            break;
        }
    }
    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_NEW  )
    {
    }
    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
    {
        switch (objType)
        {
        case CERTTMPL_CERT_TEMPLATE:
            if ( !m_bMultipleObjectsSelected )
            {
                CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
                _ASSERT (pCertTemplate);
                if ( pCertTemplate )
                {
                    if ( !g_bSchemaIsW2K )
                    {
                        hr = AddCloneTemplateMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
                        if ( SUCCEEDED (hr) )
                        {
                            hr = AddReEnrollAllCertsMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;

        case CERTTMPL_SNAPIN:
            _ASSERT (!m_bMultipleObjectsSelected);
            hr = AddViewOIDsMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
            break;
        }
    }
    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW )
    {
        switch (objType)
        {
        case CERTTMPL_SNAPIN:
            _ASSERT (!m_bMultipleObjectsSelected);
            break;

        case CERTTMPL_CERT_TEMPLATE:
            _ASSERT (0);
            break;

        default:
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddMenuItems: 0x%x\n", hr);
    return hr;
}


STDMETHODIMP CCertTmplComponentData::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    switch (nCommandID)
    {
    case IDM_CLONE_TEMPLATE:
        hr = OnCloneTemplate (pDataObject);
        break;

    case IDM_REENROLL_ALL_CERTS:
        hr = OnReEnrollAllCerts (pDataObject);
        break;

    case IDM_VIEW_OIDS:
        OnViewOIDs ();
        break;

    case -1:    // Received on forward/back buttons from toolbar
        break;

    default:
        _ASSERT (0);
        break;
    }

    return hr;
}




HRESULT CCertTmplComponentData::RefreshScopePane (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::RefreshScopePane\n");
    HRESULT hr = S_OK;
    CCertTmplCookie* pCookie = 0;

    if ( pDataObject )
        pCookie = ConvertCookie (pDataObject);
    if ( !pDataObject || pCookie )
    {
        hr = DeleteScopeItems ();
        _ASSERT (SUCCEEDED (hr));
        GUID    guid;
        hr = ExpandScopeNodes (&m_RootCookie, m_hRootScopeItem, guid, pDataObject);
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::RefreshScopePane: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTmplComponentData::ExpandScopeNodes (
        CCertTmplCookie* pParentCookie,
        HSCOPEITEM      hParent,
        const GUID&     /*guidObjectType*/,
        LPDATAOBJECT    /*pDataObject*/)
{
    _TRACE (1, L"Entering CCertTmplComponentData::ExpandScopeNodes\n");
    _ASSERT (hParent);
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CWaitCursor waitCursor;
    HRESULT     hr = S_OK;

    if ( pParentCookie )
    {
        CString     objectName;

        switch ( pParentCookie->m_objecttype )
        {
            // These node types have no children yet
            case CERTTMPL_SNAPIN:
                // We don't expect the handle of the root scope item to change, ever!
                _ASSERT ( m_hRootScopeItem ? (m_hRootScopeItem == hParent) : 1);
                if ( !m_hRootScopeItem )
                    m_hRootScopeItem = hParent;
                break;

            case CERTTMPL_CERT_TEMPLATE:
                _ASSERT (0);
                break;

            // This node type has no children
            default:
                _TRACE (0, L"CCertTmplComponentData::EnumerateScopeChildren bad parent type\n");
                hr = S_OK;
                break;
        }
    }
    else
    {
        // If parentCookie not passed in, then this is an extension snap-in
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::ExpandScopeNodes: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::DeleteScopeItems ()
{
    _TRACE (1, L"Entering CCertTmplComponentData::DeleteScopeItems\n");
    HRESULT hr = S_OK;

    hr = DeleteChildren (m_hRootScopeItem);

    _TRACE (-1, L"Leaving CCertTmplComponentData::DeleteScopeItems: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTmplComponentData::DeleteChildren (HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::DeleteChildren\n");
    HRESULT         hr = S_OK;
    if ( hParent )
    {
        HSCOPEITEM      hChild = 0;
        HSCOPEITEM      hNextChild = 0;
        MMC_COOKIE      lCookie = 0;

        // Optimization:  If we're deleting everything below the root, free all
        // the result items here so we don't have to go looking for them later by
        // store
        if ( hParent == m_hRootScopeItem )
        {
            LPRESULTDATA    pResultData = 0;
			hr = GetResultData (&pResultData);
            if ( SUCCEEDED (hr) )
            {
                hr = pResultData->DeleteAllRsltItems ();
                if ( SUCCEEDED (hr) || E_UNEXPECTED == hr ) // returns E_UNEXPECTED if console shutting down
                {
                    RemoveResultCookies (pResultData);
                }
				pResultData->Release ();
            }
        }


        hr = m_pConsoleNameSpace->GetChildItem (hParent, &hChild, &lCookie);
        _ASSERT (SUCCEEDED (hr) || E_FAIL == hr);    // appears to return E_FAIL when there are no children
        while ( SUCCEEDED (hr) && hChild )
        {
            hr = m_pConsoleNameSpace->GetNextItem (hChild, &hNextChild, &lCookie);
            _ASSERT (SUCCEEDED (hr));

            hr = DeleteChildren (hChild);
            _ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
            }
            hChild = hNextChild;
        }
   }


    _TRACE (-1, L"Leaving CCertTmplComponentData::DeleteChildren: 0x%x\n", hr);
    return hr;
}


CertTmplObjectType CCertTmplComponentData::GetObjectType (LPDATAOBJECT pDataObject)
{
    _ASSERT (pDataObject);
    CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
    if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        return CERTTMPL_MULTISEL;
    else if ( pCookie )
        return pCookie->m_objecttype;

    return CERTTMPL_INVALID;
}


HRESULT CCertTmplComponentData::IsUserAdministrator (BOOL & bIsAdministrator)
{
    HRESULT hr = S_OK;
    DWORD   dwErr = 0;

    bIsAdministrator = FALSE;
    if ( IsWindowsNT () )
    {
        PSID                        psidAdministrators;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &psidAdministrators);
        _ASSERT (bResult);
        if ( bResult )
        {
            bResult = CheckTokenMembership (0, psidAdministrators,
                    &bIsAdministrator);
            _ASSERT (bResult);
            if ( !bResult )
            {
                dwErr = GetLastError ();
                DisplaySystemError (dwErr);
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
            FreeSid (psidAdministrators);
        }
        else
        {
            dwErr = GetLastError ();
            DisplaySystemError (dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    return hr;
}


void CCertTmplComponentData::DisplaySystemError (DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID lpMsgBuf;

    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL );

    // Display the string.
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTTMPL));
    int     iRetVal = 0;
    if ( m_pConsole )
    {
        HRESULT hr = m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
            MB_ICONWARNING | MB_OK, &iRetVal);
        _ASSERT (SUCCEEDED (hr));
    }
    else
    {
        CThemeContextActivator activator;
        ::MessageBox (NULL, (PWSTR) lpMsgBuf, caption, MB_ICONWARNING | MB_OK);
    }
    // Free the buffer.
    LocalFree (lpMsgBuf);
}

HRESULT CCertTmplComponentData::AddSeparator (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    CONTEXTMENUITEM menuItem;

    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
    menuItem.fSpecialFlags = 0;
    menuItem.strName = _T ("Separator");            // Dummy name
    menuItem.strStatusBarText = _T ("Separator");// Dummy status text
    menuItem.lCommandID = ID_SEPARATOR;         // Command ID
    menuItem.fFlags = MF_SEPARATOR;             // most important the flag
    HRESULT hr = pContextMenuCallback->AddItem (&menuItem);
//  _ASSERT (SUCCEEDED (hr));

    return hr;
}

LPCONSOLENAMESPACE CCertTmplComponentData::GetConsoleNameSpace () const
{
    return m_pConsoleNameSpace;
}

CCertTmplCookie* CCertTmplComponentData::ConvertCookie (LPDATAOBJECT pDataObject)
{
    CCertTmplCookie* pParentCookie = 0;
    CCookie*        pBaseParentCookie = 0;
    HRESULT         hr = ::ExtractData (pDataObject,
            CCertTemplatesDataObject::m_CFRawCookie,
             &pBaseParentCookie,
             sizeof (pBaseParentCookie) );
    if ( SUCCEEDED (hr) )
    {
        pParentCookie = ActiveCookie (pBaseParentCookie);
        _ASSERT (pParentCookie);
    }
    return pParentCookie;
}




HRESULT CCertTmplComponentData::AddScopeNode(CCertTmplCookie * pNewCookie, HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddScopeNode\n");
    _ASSERT (pNewCookie);
    HRESULT hr = S_OK;
    if ( pNewCookie )
    {
        SCOPEDATAITEM tSDItem;

        ::ZeroMemory (&tSDItem,sizeof (tSDItem));
        tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE |
            SDI_STATE | SDI_PARAM | SDI_PARENT | SDI_CHILDREN;
        tSDItem.displayname = MMC_CALLBACK;
        tSDItem.relativeID = hParent;
        tSDItem.nState = 0;
        tSDItem.cChildren = 0;

        if ( pNewCookie != &m_RootCookie )
            m_RootCookie.m_listScopeCookieBlocks.AddHead ( (CBaseCookieBlock*) pNewCookie);
        tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
        tSDItem.nImage = QueryImage (*pNewCookie, FALSE);
        tSDItem.nOpenImage = QueryImage (*pNewCookie, FALSE);
        hr = m_pConsoleNameSpace->InsertItem (&tSDItem);
        if ( SUCCEEDED (hr) )
            pNewCookie->m_hScopeItem = tSDItem.ID;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddScopeNode: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::ReleaseResultCookie (
        CBaseCookieBlock *  pResultCookie,
        CCookie&            /*rootCookie*/,
        POSITION            /*pos2*/)
{
    _TRACE (1, L"Entering CCertTmplComponentData::ReleaseResultCookie\n");
    CCertTmplCookie* pCookie = dynamic_cast <CCertTmplCookie*> (pResultCookie);
    _ASSERT (pCookie);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            _ASSERT (0);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::ReleaseResultCookie\n");
    return S_OK;
}

void CCertTmplComponentData::SetResultData(LPRESULTDATA pResultData)
{
    _ASSERT (pResultData);
    if ( pResultData && !m_pResultData )
    {
        m_pResultData = pResultData;
        m_pResultData->AddRef ();
    }
}

HRESULT CCertTmplComponentData::GetResultData(LPRESULTDATA* ppResultData)
{
	HRESULT	hr = S_OK;

	if ( !ppResultData )
		hr = E_POINTER;
	else if ( !m_pResultData )
    {
        if ( m_pConsole )
        {
            hr = m_pConsole->QueryInterface(IID_PPV_ARG (IResultData, &m_pResultData));
            _ASSERT (SUCCEEDED (hr));
        }
        else
            hr = E_FAIL;
    }
	
    if ( SUCCEEDED (hr) && m_pResultData )
	{
		*ppResultData = m_pResultData;
		m_pResultData->AddRef ();
	}

    return hr;
}


void CCertTmplComponentData::DisplayAccessDenied ()
{
    DWORD   dwErr = GetLastError ();
    _ASSERT (E_ACCESSDENIED == dwErr);
    if ( E_ACCESSDENIED == dwErr )
    {
        LPVOID lpMsgBuf;

        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                GetLastError (),
                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                 (PWSTR) &lpMsgBuf,    0,    NULL );

        // Display the string.
        CString caption;
        VERIFY (caption.LoadString (IDS_CERTTMPL));
        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
            MB_ICONWARNING | MB_OK, &iRetVal)));

        // Free the buffer.
        LocalFree (lpMsgBuf);
    }
}



CString CCertTmplComponentData::GetThisComputer() const
{
    return m_szThisComputer;
}

HRESULT CCertTmplComponentData::OnPropertyChange (LPARAM param)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnPropertyChange\n");
    _ASSERT (param);
    HRESULT         hr = S_OK;
    if ( param )
    {
        CCertTmplCookie* pCookie = reinterpret_cast<CCertTmplCookie*> (param);
        if ( pCookie )
        {
            switch (pCookie->m_objecttype)
            {
            case CERTTMPL_CERT_TEMPLATE:
                {
                    HRESULTITEM	itemID = 0;
		            hr = pCookie->m_resultDataID->FindItemByLParam ((LPARAM) pCookie, &itemID);
		            _ASSERT (SUCCEEDED (hr));
		            if ( SUCCEEDED (hr) )
		            {
			            hr = m_pResultData->UpdateItem (itemID);
			            _ASSERT (SUCCEEDED (hr));
    	            }
                }
                break;

            default:
                break;
            }
        }
    }
    else
        hr = E_FAIL;


    _TRACE (-1, L"Leaving CCertTmplComponentData::OnPropertyChange: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CCertTmplComponentData::RemoveResultCookies
//
// Remove and delete all the result cookies corresponding to the LPRESULTDATA
// object passed in.  Thus all cookies added to pResultData are released and
// removed from the master list.
//
///////////////////////////////////////////////////////////////////////////////
void CCertTmplComponentData::RemoveResultCookies(LPRESULTDATA pResultData)
{
    _TRACE (1, L"Entering CCertTmplComponentData::RemoveResultCookies\n");
    CCertTmplCookie* pCookie = 0;

    CCookie& rootCookie = QueryBaseRootCookie ();

    POSITION        curPos = 0;

    for (POSITION nextPos = rootCookie.m_listResultCookieBlocks.GetHeadPosition (); nextPos; )
    {
        curPos = nextPos;
        pCookie = dynamic_cast <CCertTmplCookie*> (rootCookie.m_listResultCookieBlocks.GetNext (nextPos));
        _ASSERT (pCookie);
        if ( pCookie )
        {
            if ( pCookie->m_resultDataID == pResultData )
            {
                pCookie->Release ();
                rootCookie.m_listResultCookieBlocks.RemoveAt (curPos);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::RemoveResultCookies\n");
}

HRESULT CCertTmplComponentData::AddVersion1CertTemplatePropPages (CCertTemplate* pCertTemplate, LPPROPERTYSHEETCALLBACK pCallback)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddVersion1CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && pCallback);
    if ( pCertTemplate && pCallback )
    {
        _ASSERT (1 == pCertTemplate->GetType ());

        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, this);
        if ( pGeneralPage )
        {
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            hr = pCallback->AddPage (hPage);
            _ASSERT (SUCCEEDED (hr));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1RequestPropertyPage * pRequestPage = 
                    new CTemplateV1RequestPropertyPage (*pCertTemplate);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV1SubjectNamePropertyPage (*pCertTemplate);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page - always add this page last (except for security)
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCASecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::AddVersion1CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::AddVersion2CertTemplatePropPages (CCertTemplate* pCertTemplate, LPPROPERTYSHEETCALLBACK pCallback, LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddVersion2CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && pCallback);
    if ( pCertTemplate && pCallback )
    {
        _ASSERT (2 == pCertTemplate->GetType ());
        int nPage = 0;

        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, this);
        if ( pGeneralPage )
        {
   			pGeneralPage->m_lNotifyHandle = lNotifyHandle;
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            hr = pCallback->AddPage (hPage);
            _ASSERT (SUCCEEDED (hr));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2RequestPropertyPage * pRequestPage = 
                    new CTemplateV2RequestPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    nPage++;
                    pGeneralPage->SetV2RequestPageNumber (nPage);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV2SubjectNamePropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                    nPage++;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add Authentication Name page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2AuthenticationPropertyPage * pAuthenticationPage = 
                    new CTemplateV2AuthenticationPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pAuthenticationPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAuthenticationPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    nPage++;
                    pGeneralPage->SetV2AuthPageNumber (nPage);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add Superceded page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2SupercedesPropertyPage * pSupercededPage = 
                    new CTemplateV2SupercedesPropertyPage (*pCertTemplate, 
                            pGeneralPage->m_bIsDirty,
                            this);
            if ( pSupercededPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSupercededPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page - always add this page last (except for security)
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCertTemplateSecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::AddVersion2CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::AddCertTemplatePropPages (
            CCertTemplate* pCertTemplate, 
            LPPROPERTYSHEETCALLBACK pCallback,
            LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddCertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && pCallback);
    if ( pCertTemplate && pCallback )
    {
        switch (pCertTemplate->GetType ())
        {
        case 1:
            hr = AddVersion1CertTemplatePropPages (pCertTemplate, pCallback);
            break;

        case 2:
            hr = AddVersion2CertTemplatePropPages (pCertTemplate, pCallback, lNotifyHandle);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE(-1, L"Leaving CCertTmplComponentData::AddCertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
{
    TRACE(_T("xx.%03x> AddPageProc()\n"), GetCurrentThreadId());

    HRESULT hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

    return hr == S_OK;
}


HRESULT CCertTmplComponentData::AddCloneTemplateMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddCloneTemplateMenuItem\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM menuItem;
    CString         szMenu;
    CString         szHint;

    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = lInsertionPointID;
    menuItem.fFlags = 0;
    menuItem.fSpecialFlags = 0;
    VERIFY (szMenu.LoadString (IDS_CLONE_TEMPLATE));
    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
    VERIFY (szHint.LoadString (IDS_CLONE_TEMPLATE_HINT));
    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
    menuItem.lCommandID = IDM_CLONE_TEMPLATE;

    hr = pContextMenuCallback->AddItem (&menuItem);
    _ASSERT (SUCCEEDED (hr));

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddCloneTemplateMenuItem\n");
    return hr;
}

HRESULT CCertTmplComponentData::AddReEnrollAllCertsMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddReEnrollAllCertsMenuItem\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM menuItem;
    CString         szMenu;
    CString         szHint;

    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = lInsertionPointID;
    menuItem.fFlags = 0;
    menuItem.fSpecialFlags = 0;
    VERIFY (szMenu.LoadString (IDS_REENROLL_ALL_CERTS));
    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
    VERIFY (szHint.LoadString (IDS_REENROLL_ALL_CERTS_HINT));
    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
    menuItem.lCommandID = IDM_REENROLL_ALL_CERTS;

    hr = pContextMenuCallback->AddItem (&menuItem);
    _ASSERT (SUCCEEDED (hr));

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddReEnrollAllCertsMenuItem\n");
    return hr;
}

HRESULT CCertTmplComponentData::RefreshServer()
{
    //  Delete all the scope items and result items, attempt recreate the
    // server and force a reexpansion
    HRESULT hr = DeleteScopeItems ();
    if ( m_pResultData )
    {
        m_pResultData->DeleteAllRsltItems ();
    }

    HWND    hWndConsole = 0;

    m_pConsole->GetMainWindow (&hWndConsole);
    GUID    guid;
    hr = ExpandScopeNodes (
            &(m_RootCookie), m_hRootScopeItem,
            guid);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//	ChangeRootNodeName ()
//
//  Purpose:	Change the text of the root node
//
//	Input:		newName - the new machine name that the snapin manages
//  Output:		Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertTmplComponentData::ChangeRootNodeName()
{
	_TRACE (1, L"Entering CCertTmplComponentData::ChangeRootNodeName\n");

    if ( !QueryBaseRootCookie ().m_hScopeItem )
    {
        if ( m_hRootScopeItem )
            QueryBaseRootCookie ().m_hScopeItem = m_hRootScopeItem;
        else
		    return E_UNEXPECTED;
    }

	CString		formattedName;

	if ( m_szManagedDomain.IsEmpty () )
		formattedName.FormatMessage (IDS_CERTTMPL_ROOT_NODE_NAME, m_szThisDomainDns);
	else
		formattedName.FormatMessage (IDS_CERTTMPL_ROOT_NODE_NAME, m_szManagedDomain);

	SCOPEDATAITEM	item;
	::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
	item.mask = SDI_STR;
	item.displayname = (PWSTR) (PCWSTR) formattedName;
	item.ID = QueryBaseRootCookie ().m_hScopeItem;

	HRESULT	hr = m_pConsoleNameSpace->SetItem (&item);
    if ( FAILED (hr) )
    {
        _TRACE (0, L"IConsoleNameSpace2::SetItem () failed: 0x%x\n", hr);        
    }
	_TRACE (-1, L"Leaving CCertTmplComponentData::ChangeRootNodeName: 0x%x\n", hr);
	return hr;
}

HRESULT CCertTmplComponentData::OnNotifyPreload(LPDATAOBJECT /*pDataObject*/, HSCOPEITEM hRootScopeItem)
{
	_TRACE (1, L"Entering CCertTmplComponentData::OnNotifyPreload\n");
	HRESULT	hr = S_OK;

	QueryBaseRootCookie ().m_hScopeItem = hRootScopeItem;
	hr = ChangeRootNodeName ();

	_TRACE (-1, L"Leaving CCertTmplComponentData::OnNotifyPreload: 0x%x\n", hr);
	return hr;
}

// Help on IComponentData just returns the file and no particular topic
STDMETHODIMP CCertTmplComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
      return E_INVALIDARG;

  CString szHelpFilePath;
  HRESULT hr = GetHtmlHelpFilePath( szHelpFilePath );
  if ( FAILED(hr) )
    return hr;

  *lpCompiledHelpFile = reinterpret_cast <LPOLESTR> (
      CoTaskMemAlloc ((szHelpFilePath.GetLength () + 1) * sizeof (wchar_t)));
  if ( NULL == *lpCompiledHelpFile )
    return E_OUTOFMEMORY;
  USES_CONVERSION;
  wcscpy (*lpCompiledHelpFile, T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
  
  return S_OK;
}

HRESULT CCertTmplComponentData::GetHtmlHelpFilePath( CString& strref ) const
{
  UINT nLen = ::GetSystemWindowsDirectory (strref.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
  strref.ReleaseBuffer();
  if (0 == nLen)
  {
    _ASSERT(FALSE);
    return E_FAIL;
  }

  strref += CERTTMPL_HELP_PATH;
  strref += CERTTMPL_HTML_HELP_FILE;
  
  return S_OK;
}


HRESULT CCertTmplComponentData::OnReEnrollAllCerts (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnReEnrollAllCerts");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    if ( pDataObject )
    {
        CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
        if ( pCookie )
        {
            _ASSERT (CERTTMPL_CERT_TEMPLATE == pCookie->m_objecttype);
            CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
            if ( pCertTemplate )
            {
                hr = pCertTemplate->IncrementMajorVersion ();
                if ( SUCCEEDED (hr) )
                {
                    // Don't increment minor version - was set to 0 in 
                    // IncrementMajorVersion
                    hr = pCertTemplate->SaveChanges (false);
                    if ( SUCCEEDED (hr) )
                    {
                        HRESULTITEM	itemID = 0;
		                hr = pCookie->m_resultDataID->FindItemByLParam ((LPARAM) pCookie, &itemID);
		                _ASSERT (SUCCEEDED (hr));
		                if ( SUCCEEDED (hr) )
		                {
			                hr = m_pResultData->UpdateItem (itemID);
			                _ASSERT (SUCCEEDED (hr));
    	                }
                    }
                }
            }    
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnReEnrollAllCerts");
    return hr;
}

HRESULT CCertTmplComponentData::OnCloneTemplate (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnCloneTemplate");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT     hr = S_OK;
    CWaitCursor waitCursor;

    if ( pDataObject )
    {
        CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
        if ( pCookie )
        {
            _ASSERT (CERTTMPL_CERT_TEMPLATE == pCookie->m_objecttype);
            CCertTemplate* pOldTemplate = dynamic_cast <CCertTemplate*> (pCookie);
            if ( pOldTemplate )
            {
                static  PCWSTR  pszDomainController = L"DomainController";
                static  PCWSTR  pszComputer = L"Machine";
                bool    bIsComputerOrDC = pOldTemplate->GetTemplateName () == pszDomainController ||
                                    pOldTemplate->GetTemplateName () == pszComputer;

                HWND    hWndConsole = 0;

                m_pConsole->GetMainWindow (&hWndConsole);
                CWnd    mainWindow;
                mainWindow.Attach (hWndConsole);

                CCertTemplate* pNewTemplate = new CCertTemplate (*pOldTemplate, 
                        true, false, m_fUseCache);
                if ( pNewTemplate )
                {
                    // Generate a unique name for the new template
                    int     nCopy = 1;
                    CString newName;

                    while ( 1 )
                    {
                        if ( 1 == nCopy )
                        {
                            newName.FormatMessage (IDS_COPY_OF_TEMPLATE, 
                                    (PCWSTR) pOldTemplate->GetDisplayName ());
                        }
                        else
                        {
                            newName.FormatMessage (IDS_COPY_X_OF_TEMPLATE, nCopy, 
                                    (PCWSTR) pOldTemplate->GetDisplayName ());
                        }

                        HCERTTYPE   hCertType = 0;
                        HRESULT     hr1 = CAFindCertTypeByName (newName, 
                                NULL,
                                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                                &hCertType);
                        _TRACE (0, L"checking to see if %s exists: %s\n", 
                                (PCWSTR) newName,
                                SUCCEEDED (hr) ? L"was found" : L"was not found");
                        if ( SUCCEEDED (hr1) )
                        {
                            hr1 = CACloseCertType (hCertType);
                            if ( FAILED (hr1) )
                            {
                                _TRACE (0, L"CACloseCertType () failed: 0x%x", hr);
                            }

                            // This one exists, try another.
                            nCopy++;
                            continue;
                        }
                        else
                        {
                            // This one does not exist.  Use it as the new name.
                            break;
                        }
                    }
                    
                    if ( SUCCEEDED (hr) )
                    {
                        hr = pNewTemplate->Clone (*pOldTemplate, 
                                newName, newName);
                        if ( SUCCEEDED (hr) )
                        {

                            CString title;

                            VERIFY (title.LoadString (IDS_PROPERTIES_OF_NEW_TEMPLATE));
                            CTemplatePropertySheet  propSheet (title, *pNewTemplate, &mainWindow);

                            CTemplateGeneralPropertyPage* pGeneralPage = 
                                    new CTemplateGeneralPropertyPage (
                                            *pNewTemplate,
                                            this);

                            if ( pGeneralPage )
                            {
                                propSheet.AddPage (pGeneralPage);
                                int nPage = 0;


                                // Add Request and Subject pages if subject is not a CA
                                if ( !pNewTemplate->SubjectIsCA () )
                                {
                                    propSheet.AddPage (new CTemplateV2RequestPropertyPage (
                                            *pNewTemplate, pGeneralPage->m_bIsDirty));
                                    nPage++;
                                    pGeneralPage->SetV2RequestPageNumber (nPage);
                                    propSheet.AddPage (new CTemplateV2SubjectNamePropertyPage (
                                            *pNewTemplate, pGeneralPage->m_bIsDirty,
                                            bIsComputerOrDC));
                                    nPage++;
                                }

                                propSheet.AddPage (new CTemplateV2AuthenticationPropertyPage ( 
                                        *pNewTemplate, pGeneralPage->m_bIsDirty));
                                nPage++;
                                pGeneralPage->SetV2AuthPageNumber (nPage);

                                propSheet.AddPage (new CTemplateV2SupercedesPropertyPage (
                                        *pNewTemplate, pGeneralPage->m_bIsDirty,
                                        this));

                                // Add template extension page - always add this page last (except for security)
                                propSheet.AddPage (new CTemplateExtensionsPropertyPage (
                                        *pNewTemplate, pGeneralPage->m_bIsDirty));


                                CThemeContextActivator activator;
                                INT_PTR iResult = propSheet.DoModal ();
                                switch (iResult)
                                {
                                case IDOK:
                                    {
                                        hr = pNewTemplate->DoAutoEnrollmentPendingSave ();

                                        // unselect old template
	                                    HRESULTITEM	itemID = 0;

	                                    ASSERT (m_pResultData);
	                                    if ( m_pResultData )
	                                    {
		                                    hr = m_pResultData->FindItemByLParam (
                                                    (LPARAM) pCookie, &itemID);
		                                    ASSERT (SUCCEEDED (hr));
		                                    if ( SUCCEEDED (hr) )
		                                    {
                                                RESULTDATAITEM  rdItem;
                                                ::ZeroMemory (&rdItem, sizeof (RESULTDATAITEM));
                                                rdItem.itemID = itemID;

                                                rdItem.mask = RDI_STATE;
                                                rdItem.nState &= ~(LVIS_FOCUSED | LVIS_SELECTED);
                                                hr = m_pResultData->SetItem (&rdItem);
                                                if ( SUCCEEDED (hr) )
                                                {
			                                        hr = m_pResultData->UpdateItem (itemID);
			                                        ASSERT (SUCCEEDED (hr));
                                                }
		                                    }
	                                    }
	                                    else
		                                    hr = E_FAIL;


                                        // Add certificate template to result pane
	                                    RESULTDATAITEM			rdItem;
	                                    CCookie&				rootCookie = QueryBaseRootCookie ();

	                                    ::ZeroMemory (&rdItem, sizeof (rdItem));
	                                    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
	                                    rdItem.nImage = iIconCertTemplateV2;
	                                    rdItem.nCol = 0;
                                        rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
	                                    rdItem.str = MMC_TEXTCALLBACK;

		                                rootCookie.m_listResultCookieBlocks.AddHead (pNewTemplate);
		                                rdItem.lParam = (LPARAM) pNewTemplate;
		                                pNewTemplate->m_resultDataID = m_pResultData;
		                                hr = m_pResultData->InsertItem (&rdItem);
                                        if ( FAILED (hr) )
                                        {
                                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                        }
                                        else
                                        {
                                            m_dwNumCertTemplates++;
                                            DisplayObjectCountInStatusBar (
                                                    m_pConsole, 
                                                    m_dwNumCertTemplates);
                                            pNewTemplate = 0;
                                        }
                                    }
                                    break;

                                case IDCANCEL:
                                    // Delete cloned template
                                    if ( pNewTemplate->CanBeDeletedOnCancel () )
                                        hr = pNewTemplate->Delete ();
                                    else   // was created - let's update
                                    {
                                        hr = pNewTemplate->DoAutoEnrollmentPendingSave ();

                                        // Add certificate template to result pane
	                                    RESULTDATAITEM			rdItem;
	                                    CCookie&				rootCookie = QueryBaseRootCookie ();

	                                    ::ZeroMemory (&rdItem, sizeof (rdItem));
	                                    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
	                                    rdItem.nImage = iIconCertTemplateV2;
	                                    rdItem.nCol = 0;
                                        rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
	                                    rdItem.str = MMC_TEXTCALLBACK;

		                                rootCookie.m_listResultCookieBlocks.AddHead (pNewTemplate);
		                                rdItem.lParam = (LPARAM) pNewTemplate;
		                                pNewTemplate->m_resultDataID = m_pResultData;
		                                hr = m_pResultData->InsertItem (&rdItem);
                                        if ( FAILED (hr) )
                                        {
                                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                        }
                                        else
                                        {
                                            m_dwNumCertTemplates++;
                                            DisplayObjectCountInStatusBar (
                                                    m_pConsole, 
                                                    m_dwNumCertTemplates);
                                            pNewTemplate = 0;
                                        }
                                    }
                                    break;
                                }
                            }
                            else
                                hr = E_OUTOFMEMORY;

                        }
                        else
                        {
                            CString caption;
                            CString text;

                            VERIFY (caption.LoadString (IDS_CERTTMPL));
                            text.FormatMessage (IDS_UNABLE_TO_CLONE_TEMPLATE, 
                                    pOldTemplate->GetDisplayName (), 
                                    GetSystemMessage (hr));

                            int     iRetVal = 0;
                            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                    MB_ICONWARNING | MB_OK, &iRetVal)));
                        }
                    }

                    if ( pNewTemplate )
                        delete pNewTemplate;
                }
                else
                    hr = E_OUTOFMEMORY;

                mainWindow.Detach ();
            }
            else
                hr = E_UNEXPECTED;
        }
        else
            hr = E_FAIL;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnCloneTemplate");
    return hr;
}
    
HRESULT CCertTmplComponentData::AddViewOIDsMenuItem (
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddViewOIDsMenuItem\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM menuItem;
    CString         szMenu;
    CString         szHint;

    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = lInsertionPointID;
    menuItem.fFlags = 0;
    menuItem.fSpecialFlags = 0;
    VERIFY (szMenu.LoadString (IDS_VIEW_OIDS));
    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
    VERIFY (szHint.LoadString (IDS_VIEW_OIDS_HINT));
    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
    menuItem.lCommandID = IDM_VIEW_OIDS;

    hr = pContextMenuCallback->AddItem (&menuItem);
    _ASSERT (SUCCEEDED (hr));

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddViewOIDsMenuItem\n");
    return hr;

}

void CCertTmplComponentData::OnViewOIDs ()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HWND    hWndConsole = 0;

    m_pConsole->GetMainWindow (&hWndConsole);
    CWnd    mainWindow;
    mainWindow.Attach (hWndConsole);

    CViewOIDDlg dlg (&mainWindow);

    CThemeContextActivator activator;
    dlg.DoModal ();

    mainWindow.Detach ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\cmponent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cmponent.h
//
//  Contents:   CCertTmplComponent
//
//----------------------------------------------------------------------------
// cmponent.h : Declaration of CCertTmplComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "cookie.h"     // CCertTmplCookie
#include "CertTemplate.h"   // CCertTemplate

#define UPDATE_HINT_ENUM_CERT_TEMPLATES	    0x01

enum {
    IDM_CLONE_TEMPLATE = 101,
    IDM_REENROLL_ALL_CERTS,
    IDM_VIEW_OIDS
};

// forward declarations
class CCertTmplComponentData;

class CCertTmplComponent :
	public CComponent,
	public IExtendContextMenu,
	public ICertTemplatesSnapin,
	public IExtendPropertySheet,
	public IResultDataCompareEx,
	public PersistStream
{
public:
	CCertTmplComponent();
	virtual ~CCertTmplComponent();
BEGIN_COM_MAP(CCertTmplComponent)
	COM_INTERFACE_ENTRY(ICertTemplatesSnapin)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IResultDataCompareEx)
	COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1



// IExtendContextMenu
public:
  STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
  STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);


// IResultDataCompareEx
    STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

// IComponent implemented in CComponent
	// support methods for IComponent
	virtual HRESULT ReleaseAll();
	virtual HRESULT OnPropertyChange( LPARAM param );
	virtual HRESULT OnViewChange (LPDATAOBJECT pDataObject, LPARAM data, LPARAM hint);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem, LPDATAOBJECT pDataObject);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT pDataObject,
	                                   LPIMAGELIST lpImageList,
	                                   HSCOPEITEM hSelectedItem );
	virtual HRESULT OnNotifyColumnClick (LPDATAOBJECT pDataObject,
										LPARAM iColumn,
										LPARAM uFlags);

	HRESULT PopulateListbox(CCertTmplCookie* pcookie);
	HRESULT RefreshResultPane(const bool bSilent);

	static HRESULT LoadStrings();
    HRESULT LoadColumns( CCertTmplCookie* pcookie );

	CCertTmplComponentData& QueryComponentDataRef()
	{
		return (CCertTmplComponentData&)QueryBaseComponentDataRef();
	}

public:
	STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
	CCertTmplCookie* m_pViewedCookie; // CODEWORK I hate to have to do this...

	inline CCertTmplCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertTmplCookie*)ActiveBaseCookie( pBaseCookie );
	}

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

	// PersistStream
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);


private:
	CertTmplObjectType		m_currResultNodeType;
	CString							m_szDisplayInfoResult;
	UINT*							m_ColumnWidths[CERTTMPL_NUMTYPES];

	void SetTextNotAvailable ();

protected:
    virtual HRESULT		OnNotifyRename(
							LPDATAOBJECT lpDataObject, 
							LPARAM arg, 
							LPARAM param);
    HRESULT EnumerateTemplates (IDirectoryObject* pTemplateContObj,
                const BSTR bszTemplateContainerPath);
	HRESULT AddEnterpriseTemplates ();
	HRESULT DeleteCertTemplateFromResultPane (
                CCertTemplate* pCertTemplate, 
                LPDATAOBJECT pDataObject);
	HRESULT	DeleteCookie (
				CCertTmplCookie* pCookie,
				LPDATAOBJECT pDataObject,
				bool bRequestConfirmation,
				bool bIsMultipleSelect);
	HRESULT RefreshResultItem (CCertTmplCookie* pCookie);
	CCertTmplCookie* ConvertCookie (LPDATAOBJECT pDataObject);
	HRESULT OnNotifyCutOrMove (LPARAM arg);
	HRESULT SaveWidths (CCertTmplCookie* pCookie);
	HRESULT LoadColumnsFromArrays (CertTmplObjectType objecttype);
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, BSTR* ppViewType, long* pViewOptions);
	HRESULT OnNotifyQueryPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	HRESULT OnNotifyPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	void DisplayAccessDenied();
    STDMETHOD(Notify)(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	virtual HRESULT OnNotifyDelete (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyRefresh (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifySelect( LPDATAOBJECT pDataObject, BOOL fSelected);
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyDblClick( LPDATAOBJECT pDataObject );

}; // class CCertTmplComponent


// Enumeration for the icons used
enum
{
	iIconDefault = 0,
    iIconCertTemplateV1,
    iIconCertTemplateV2,
	iIconLast		// Must be last
};


typedef enum _COLNUM_CERT_TEMPLATES {
    COLNUM_CERT_TEMPLATE_OBJECT = 0,
    COLNUM_CERT_TEMPLATE_TYPE,
    COLNUM_CERT_TEMPLATE_VERSION,
    COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS,
    CERT_TEMPLATES_NUM_COLS      // always last
} COLNUM_CERT_TEMPLATES;


#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\compdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       compdata.h
//
//  Contents:   CCertTmplComponentData
//
//----------------------------------------------------------------------------

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "cmponent.h" // LoadIconsIntoImageList
#include "cookie.h"	// Added by ClassView
#include "PolicyOID.h"

class CCertTmplComponentData:
	public CComponentData,
	public IExtendContextMenu,
	public IExtendPropertySheet,
	public PersistStream,
	public CHasMachineName
{
friend CCertTmplComponent;

public:
	CertTmplObjectType GetObjectType (LPDATAOBJECT pDataObject);

// Use DECLARE_NOT_AGGREGATABLE(CCertTmplComponentData)
// if you don't want your object to support aggregation
//DECLARE_AGGREGATABLE(CCertTmplComponentData)
//DECLARE_REGISTRY(CCertTmplComponentData, _T("CERTTMPL.CertTemplatesSnapinObject.1"), _T("CERTTMPL.CertTemplatesSnapinObject.1"), IDS_CERTTMPL_DESC , THREADFLAGS_BOTH)

	CCertTmplComponentData();
	virtual ~CCertTmplComponentData();
BEGIN_COM_MAP(CCertTmplComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IExtendContextMenu
public:
	CString				m_szManagedDomain;
    CString             m_szPreviousManagedDomain;
	CCredentialObject	m_credentials;
	CString				m_szThisDomainDns;
	CString				m_szThisDomainFlat;
	CString				m_szManagedServerName;
	DWORD				m_dwNumCertTemplates;
    bool        m_fUseCache;
	

	HRESULT RefreshServer ();
	void RemoveResultCookies (LPRESULTDATA pResultData);
	CString GetThisComputer() const;
	void SetResultData (LPRESULTDATA pResultData);
	LPCONSOLENAMESPACE GetConsoleNameSpace () const;
	HRESULT RefreshScopePane (LPDATAOBJECT pDataObject);
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent);

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

	virtual CCookie& QueryBaseRootCookie();

	inline CCertTmplCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertTmplCookie*)ActiveBaseCookie( pBaseCookie );
	}

	inline CCertTmplCookie& QueryRootCookie()
	{
		return m_RootCookie;
	}

	virtual HRESULT OnNotifyRelease(LPDATAOBJECT pDataObject, HSCOPEITEM hItem);

	// CHasMachineName
	DECLARE_FORWARDS_MACHINE_NAME( (&m_RootCookie) )

    CStringList m_globalFriendlyNameList;
	CStringList m_globalTemplateNameList;

protected:
    LPCONSOLE m_pComponentConsole;

    void OnViewOIDs ();
    HRESULT AddViewOIDsMenuItem (
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID);
	HRESULT ChangeRootNodeName();
	HRESULT AddCloneTemplateMenuItem(
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID);
    HRESULT AddReEnrollAllCertsMenuItem(
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID);
	HRESULT OnCloneTemplate (LPDATAOBJECT pDataObject);
    HRESULT OnReEnrollAllCerts (LPDATAOBJECT pDataObject);
    HRESULT AddCertTemplatePropPages (
                CCertTemplate* pCertTemplate, 
                LPPROPERTYSHEETCALLBACK pCallback,
                LONG_PTR lNotifyHandle);
	HRESULT AddVersion1CertTemplatePropPages (CCertTemplate* pCertTemplate, LPPROPERTYSHEETCALLBACK pCallback);
	HRESULT AddVersion2CertTemplatePropPages (
                CCertTemplate* pCertTemplate, 
                LPPROPERTYSHEETCALLBACK pCallback,
                LONG_PTR lNotifyHandle);
	HRESULT				AddScopeNode (
								CCertTmplCookie*		pCookie,
								HSCOPEITEM			hParent);
	HRESULT				AddSeparator (
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	CCertTmplCookie*    ConvertCookie (
								LPDATAOBJECT		pDataObject);
	HRESULT				DeleteChildren (
								HSCOPEITEM			hParent);
	HRESULT				DeleteScopeItems ();
	void				DisplayAccessDenied();
	void				DisplaySystemError (
								DWORD				dwErr);
	HRESULT				ExpandScopeNodes (
								CCertTmplCookie*		pParentCookie,
								HSCOPEITEM			hParent,
								const GUID&			guidObjectType,
                                LPDATAOBJECT        pDataObject = 0);
	HRESULT				GetResultData (LPRESULTDATA* ppResultData);
	HRESULT				IsUserAdministrator (
								BOOL&				bIsAdministrator);
	virtual HRESULT		OnPropertyChange (LPARAM param);
	HRESULT				QueryMultiSelectDataObject(
								MMC_COOKIE			cookie,
								DATA_OBJECT_TYPES	type,
                                   LPDATAOBJECT*		ppDataObject);
	HRESULT				ReleaseResultCookie (
								CBaseCookieBlock *	pResultCookie,
								CCookie&			rootCookie,
								POSITION			pos2);
	HRESULT				OnNotifyPreload(
								LPDATAOBJECT		pDataObject,
								HSCOPEITEM			hRootScopeItem);
	STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
	HRESULT GetHtmlHelpFilePath( CString& strref ) const;

    LPHEADERCTRL					m_pHeader;

private:
	CString							m_serverName;
	bool							m_bMultipleObjectsSelected;
	BOOL							m_bIsUserAdministrator;
	CString							m_szThisComputer;
	CString							m_szLoggedInUser;
	HSCOPEITEM						m_hRootScopeItem;
	CCertTmplCookie					m_RootCookie;
	LPRESULTDATA					m_pResultData;
    bool                            m_bSchemaChecked;
}; // CCertTmplComponentData


/////////////////////////////////////////////////////////////////////
class CCertTmplSnapin: public CCertTmplComponentData,
	public CComCoClass<CCertTmplSnapin, &CLSID_CertTemplatesSnapin>
{
public:
	CCertTmplSnapin() : CCertTmplComponentData () {};
	virtual ~CCertTmplSnapin() {};

// Use DECLARE_NOT_AGGREGATABLE(CCertTmplSnapin) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CCertTmplSnapin)
DECLARE_REGISTRY(CCertTmplSnapin, _T("CERTTMPL.CertTemplatesSnapinObject.1"), _T("CERTTMPL.CertTemplatesSnapinObject.1"), IDS_CERTTMPL_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_CertTemplatesSnapin;
		return S_OK;
	}
};


#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\certtemplate.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       CertTemplate.h
//
//  Contents:   CCertTemplate
//
//----------------------------------------------------------------------------
/// CertTemplate.h: interface for the CCertTemplate class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CERTTEMPLATE_H__2562C528_F60F_4F4B_9E2A_FBD96732369C__INCLUDED_)
#define AFX_CERTTEMPLATE_H__2562C528_F60F_4F4B_9E2A_FBD96732369C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "cookie.h"

typedef enum {
    PERIOD_TYPE_NONE = -1,
    PERIOD_TYPE_DAY = 0,
    PERIOD_TYPE_WEEK,
    PERIOD_TYPE_MONTH,
    PERIOD_TYPE_YEAR
} PERIOD_TYPE;

class CCertTemplate : public CCertTmplCookie  
{
public:
	CCertTemplate(
            PCWSTR pszObjectName, 
            PCWSTR pszTemplateName, 
            const CString& szLDAPPath,
            bool fIsReadOnly,
            const bool fUseCache);
	CCertTemplate (
            const CCertTemplate& rTemplate, 
            bool bIsClone, 
            bool fIsReadOnly, 
            const bool fUseCache);
	virtual ~CCertTemplate();

public:
	bool IssuancePoliciesRequired () const;
	void IssuancePoliciesRequired (bool bRequired);
    HRESULT GetDigitalSignature(bool &bHasDigitalSignature);
	HRESULT SetDigitalSignature (bool bSet);
	HRESULT GetSubjectTypeDescription (int nIndex, CString &szSubjectTypeDescription);
//	bool AllowAutoenrollment (); /*  NO LONGER NEEDED  NTRAID# 321742 */
    bool UserInteractionRequired () const;
    HRESULT SetUserInteractionRequired(bool bSet);
    bool RemoveInvalidCertFromPersonalStore () const;
    HRESULT SetRemoveInvalidCertFromPersonalStore(bool bRemove);
    HRESULT IsExtensionCritical (PCWSTR szExtension, bool& bCritical);
    HRESULT ModifyCriticalExtensions (const CString &szExtension, bool bAdd);
	HRESULT Cancel();
	void FreeCertExtensions ();
    HRESULT GetEnhancedKeyUsage (int nIndex, CString &szEKU);
    HRESULT SetEnhancedKeyUsage (const PWSTR* pawszEKU, bool bCritical);
    HRESULT GetApplicationPolicy (int nIndex, CString &szAppPolicy);
    HRESULT SetApplicationPolicy (const PWSTR* pawszAppPolicy, bool bCritical);
    HRESULT SetCertPolicy (const PWSTR* pawszCertPolicy, bool bCritical);
	HRESULT SetCheckDSCert (bool bIgnore);
	bool CheckDSCert () const;
    HRESULT SetBasicConstraints(PCERT_BASIC_CONSTRAINTS2_INFO pBCInfo, 
                bool bCritical);
	HRESULT SetKeyUsage (CRYPT_BIT_BLOB* pKeyUsage, bool bCritical);
	bool GoodForAutoEnrollment () const;
	HRESULT IncrementMinorVersion ();
	HRESULT IncrementMajorVersion ();
	HRESULT GetMinorVersion (DWORD& dwMinorVersion) const;
	HRESULT GetMajorVersion (DWORD& dwMajorVersion) const;
	HRESULT SetPendAllRequests (bool bPend);
	bool PendAllRequests () const;
	HRESULT SetReenrollmentValidWithPreviousApproval (bool bValid);
	bool ReenrollmentValidWithPreviousApproval () const;
	HRESULT SetRANumSignaturesRequired (DWORD dwNumSignaturesRequired);
	HRESULT GetRANumSignaturesRequired (DWORD& dwNumSignatures);
	HRESULT SetPublishToDS (bool bPublish);
	HRESULT SetRenewalPeriod (int nDays);
	HRESULT SetValidityPeriod (int nDays);
	CString GetLDAPPath () const;
	HRESULT GetSecurity (PSECURITY_DESCRIPTOR* ppSD) const;
	HRESULT SetSecurity (PSECURITY_DESCRIPTOR pSD);
	bool ReadOnly () const;
	HRESULT GetSupercededTemplate (int nIndex, CString& szSupercededTemplate);
	HRESULT ModifySupercededTemplateList(const CString &szSupercededTemplateName, 
                bool bAdd);
	HRESULT GetCSP (int nIndex, CString& szCSP);
    HRESULT GetCertPolicy (int nIndex, CString& szCertPolicy);
	HRESULT ModifyCSPList(const CString &szCSPName, bool bAdd);
	HRESULT GetRAIssuancePolicy(int nIndex, CString& szRAPolicyOID);
	HRESULT GetRAApplicationPolicy(int nIndex, CString& szRAPolicyOID);
	HRESULT ModifyRAIssuancePolicyList(const CString &szRAPolicyOID, bool bAdd);
	HRESULT ModifyRAApplicationPolicyList(const CString &szRAPolicyOID, bool bAdd);
    HRESULT SetMinimumKeySizeValue (DWORD dwMinKeySize);
	HRESULT AltNameIncludesSPN (bool bIncludesSPN);
	bool AltNameIncludesSPN () const;
	HRESULT RequireSubjectInRequest (bool bRequire);
	HRESULT SubjectNameMustBeCN (bool bMustBeCN);
	bool SubjectNameMustBeCN () const;
	HRESULT SubjectNameMustBeFullDN (bool bMustBeDN);
	bool SubjectNameMustBeFullDN () const;
	HRESULT SubjectNameIncludesEMail (bool bIncludesEMail);
	bool SubjectNameIncludesEMail () const;
	HRESULT AltNameIncludesUPN (bool bIncludesUPN);
	bool AltNameIncludesUPN () const;
	HRESULT AltNameIncludesEMail (bool bIncludesEMail);
	bool AltNameIncludesEMail () const;
	HRESULT AltNameIncludesDNS (bool fIncludeDNS);
	bool AltNameIncludesDNS () const;
	HRESULT DoAutoEnrollmentPendingSave ();
	HRESULT IncludeSymmetricAlgorithems (bool bInclude);
	bool IncludeSymmetricAlgorithms () const;
	HRESULT AllowPrivateKeyArchival (bool bAllowArchival);
	bool AllowPrivateKeyArchival () const;
	HRESULT MakePrivateKeyExportable (bool bMakeExportable);
	bool PrivateKeyIsExportable () const;
	HRESULT GetMinimumKeySize (DWORD& dwMinKeySize) const;
	HRESULT SetAutoEnrollment (bool bSuitableForAutoEnrollment);
	bool CanBeDeletedOnCancel () const;
	HRESULT SetEncryptionSignature (bool bHasEncryptionSignature);
	HRESULT SetKeySpecSignature (bool bHasKeySpecSignature);
	HRESULT SetSubjectIsCA (bool bSubjectIsCA);
	HRESULT SaveChanges (bool bIncrementMinorVersion = true);
	HRESULT SetDisplayName (const CString& strDisplayName, bool bForce = false);
	HRESULT SetTemplateName (const CString& strTemplateName);
	bool IsClone () const;
	bool IsDefault () const;
	HRESULT Delete ();
	HRESULT Clone (
            const CCertTemplate& rTemplate, 
            const CString& strTemplateName, 
            const CString& strDisplayName);
	HRESULT GetValidityPeriod (int& nValidityDays);
	HRESULT GetRenewalPeriod (int& nRenewalDays);
	bool RequireSubjectInRequest () const;
	bool HasEncryptionSignature () const;
	bool HasKeySpecSignature () const;
	HRESULT GetCertExtension (DWORD dwIndex, PSTR* ppszObjId, BOOL& fCritical);
	HRESULT GetCertExtension (PSTR pszOID, PCERT_EXTENSION* ppCertExtension);
	DWORD GetCertExtensionCount ();
	bool PublishToDS () const;
	bool IsMachineType () const;
	bool SubjectIsCA() const;
	bool SubjectIsCrossCA() const;
	CString GetTemplateName() const;
    CString GetDisplayName ();
	DWORD GetType() const;

protected:
    HRESULT ConvertCertTypeFileTimeToDays (FILETIME const *pftCertType, int& nDays);

private:
	bool m_bIssuancePoliciesRequired;
    PCERT_EXTENSIONS m_pCertExtensions; 
	int     m_nNewRenewalDays;
	int     m_nOriginalRenewalDays;
	int     m_nNewValidityDays;
	int     m_nOriginalValidityDays;
	const bool m_fIsReadOnly;
	bool m_bGoodForAutoenrollmentFlagPendingSave;
	bool m_bCanBeDeletedOnCancel;
    HRESULT SetFlag (DWORD dwFlagType, DWORD dwFlag, bool bValue);

	CString     m_strOriginalTemplateName;
	bool        m_bIsClone;
	DWORD       m_dwKeySpec;
	DWORD       m_dwEnrollmentFlags;
    DWORD       m_dwSubjectNameFlags;
    DWORD       m_dwPrivateKeyFlags;
    DWORD       m_dwGeneralFlags;

    DWORD       m_dwVersion;
	HCERTTYPE   m_hCertType;
	CString     m_strTemplateName;
    const CString m_szLDAPPath;
    CString     m_szDisplayName;
    const bool  m_fUseCache;

protected:
    HRESULT ModifyStringList(const CString& szPropertyName, 
                            PWSTR** ppStringList, 
                            const CString &szCSPName, 
                            bool bAdd);
	HRESULT Initialize ();
};

#endif // !defined(AFX_CERTTEMPLATE_H__2562C528_F60F_4F4B_9E2A_FBD96732369C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\cookie.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Cookie.cpp
//
//  Contents:   Implementation of CCertTmplCookie and related classes
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#pragma warning(push,3)
#pragma warning (disable : 4702)
#include "atlimpl.cpp"
#pragma warning (default : 4702)
#pragma warning(pop)
#include "stdcooki.cpp"
#include "stdutils.cpp"


//
// CCertTmplCookie
//

// returns <0, 0 or >0


CCertTmplCookie::CCertTmplCookie (CertTmplObjectType objecttype,
		PCWSTR objectName)
	: m_objecttype (objecttype),
	m_objectName (objectName),
	m_resultDataID (0)
{
	_ASSERT (IsValidObjectType (m_objecttype));
	if ( m_objectName.IsEmpty () )
	{
		AFX_MANAGE_STATE (AfxGetStaticModuleState ());
		VERIFY (m_objectName.LoadString (IDS_CERTTMPL));
	}
}

CCertTmplCookie::~CCertTmplCookie ()
{
}


HRESULT CCertTmplCookie::CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult )
{
	_ASSERT (pOtherCookie);

	CCertTmplCookie* pcookie = dynamic_cast <CCertTmplCookie*>(pOtherCookie);
	_ASSERT (pcookie);
	if ( pcookie && m_objecttype != pcookie->m_objecttype )
	{
		*pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype); // arbitrary ordering
		return S_OK;
	}

	return E_UNEXPECTED;
}

CCookie* CCertTmplCookie::QueryBaseCookie(int i)
{
	_ASSERT(!i);
	return (CCookie*)this;
}

int CCertTmplCookie::QueryNumCookies()
{
	return 1;
}

PCWSTR CCertTmplCookie::GetObjectName() const
{
	return m_objectName;
}

HRESULT CCertTmplCookie::Commit()
{
	return S_OK;
}


CString CCertTmplCookie::GetManagedDomainDNSName() const
{
	return m_szManagedDomainDNSName;
}

void CCertTmplCookie::SetManagedDomainDNSName(const CString &szManagedDomainDNSName)
{
	m_szManagedDomainDNSName = szManagedDomainDNSName;
}

void CCertTmplCookie::SetObjectName(const CString& strObjectName)
{
    m_objectName = strObjectName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Cert Template Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Cert Template Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

    void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)

#endif



#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\cookie.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cookie.h
//
//  Contents:   CCertTmplCookie
//
//----------------------------------------------------------------------------

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

extern HINSTANCE g_hInstanceSave;   // Instance handle of the DLL (initialized 
                                    //during CCertTmplComponent::Initialize)


#include "nodetype.h"

/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CCertTmplCookie : public CCookie,
                        public CBaseCookieBlock
{
public:
	CCertTmplCookie (CertTmplObjectType objecttype,
			PCWSTR objectName = 0);

	virtual ~CCertTmplCookie ();

	// returns <0, 0 or >0
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult );
	
// CBaseCookieBlock
	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();

public:
	void SetManagedDomainDNSName (const CString& szManagedDomainDNSName);
	CString GetManagedDomainDNSName() const;
	virtual CString GetClass () { return L"";}
	LPRESULTDATA m_resultDataID;
	virtual void Refresh () {};
	virtual HRESULT Commit ();
	CString GetServiceName () const;
	void SetServiceName (CString &szManagedService);
	PCWSTR GetObjectName () const;
	const CertTmplObjectType m_objecttype;

private:
	CString m_szManagedDomainDNSName;
	CString m_objectName;
protected:
	void SetObjectName (const CString& strObjectName);
};


#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\dataobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       dataobj.h
//
//  Contents:   CCertTemplatesDataObject
//
//----------------------------------------------------------------------------

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__


// For use in multiple selection.
LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject);


class CCertTemplatesDataObject : public CDataObject
{
	DECLARE_NOT_AGGREGATABLE(CCertTemplatesDataObject)

public:

// debug refcount
#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

	CCertTemplatesDataObject();

	virtual ~CCertTemplatesDataObject();

	STDMETHODIMP Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched);
	STDMETHODIMP Skip(ULONG celt);
	STDMETHODIMP Reset(void);
	void AddCookie(CCertTmplCookie* pCookie);
	virtual HRESULT Initialize (
			CCertTmplCookie* pcookie,
			DATA_OBJECT_TYPES type,
			CCertTmplComponentData& refComponentData);

	// IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

	void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData);
	STDMETHODIMP GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(IsMultiSelect)(void)
    {
        return (m_rgCookies.GetSize() > 1) ? S_OK : S_FALSE;
    }

protected:
	HRESULT PutDisplayName(STGMEDIUM* pMedium);
	HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);
	HRESULT Create (const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
	CCertTmplCookie* m_pCookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
	CertTmplObjectType m_objecttype;
	DATA_OBJECT_TYPES m_dataobjecttype;
	GUID m_SnapInCLSID;

public:

	// Clipboard formats
	static CLIPFORMAT m_CFDisplayName;
    static CLIPFORMAT m_CFMultiSel;        // Required for multiple selection
    static CLIPFORMAT m_CFMultiSelDobj;    // Required for multiple selection
	static CLIPFORMAT m_CFMultiSelDataObjs;// for Multiple selection
	static CLIPFORMAT m_CFDsObjectNames;	 // For DS object property pages

private:
    // data member used by IEnumCookies
    ULONG							m_iCurr;
	CCookiePtrArray					m_rgCookies;
	bool							m_bMultiSelDobj;
    BYTE*							m_pbMultiSelData;
    UINT							m_cbMultiSelData;

public:
    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = true;
    }
}; // CCertTemplatesDataObject

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\dataobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       DataObj.cpp
//
//  Contents:   Implementation of data object classes: CCertTemplatesDataObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS("CERTTMPL(dataobj.cpp)")

#include "compdata.h"
#include "dataobj.h"

#include "uuids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"

// IDataObject interface implementation

CCertTemplatesDataObject::CCertTemplatesDataObject()
		: m_pCookie (0),
		m_objecttype (CERTTMPL_SNAPIN),
		m_dataobjecttype (CCT_UNINITIALIZED),
        m_pbMultiSelData(NULL),
        m_cbMultiSelData(0),
		m_bMultiSelDobj(false),
		m_iCurr(0)
{
}

HRESULT CCertTemplatesDataObject::GetDataHere(
	FORMATETC __RPC_FAR *pFormatEtcIn,
	STGMEDIUM __RPC_FAR *pMedium)
{
	const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
	if (cf == m_CFNodeType)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const GUID* pguid = GetObjectTypeGUID( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			return s.Write(pguid, sizeof(GUID));
		}
		else
			return E_UNEXPECTED;
	}
	else if (cf == m_CFSnapInCLSID)
	{
		stream_ptr s(pMedium);
		return s.Write(&m_SnapInCLSID, sizeof(GUID));
	}
	else if (cf == m_CFNodeTypeString)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const BSTR strGUID = GetObjectTypeString( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			return s.Write(strGUID);
		}
		else
			return E_UNEXPECTED;
	}
	else if (cf == m_CFDisplayName)
	{
		return PutDisplayName(pMedium);
	}
	else if (cf == m_CFDataObjectType)
	{
		stream_ptr s(pMedium);
		return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
	}
	else if (cf == m_CFRawCookie)
	{
		stream_ptr s(pMedium);


		if ( m_pCookie )
		{
			// CODEWORK This cast ensures that the data format is
			// always a CCookie*, even for derived subclasses
			if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie ||
					IsValidObjectType (m_pCookie->m_objecttype) )
			{
				CCookie* pcookie = (CCookie*) m_pCookie;
				return s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pCookie));
			}
			else
				return E_UNEXPECTED;
		}
	}
	else if ( cf == m_CFMultiSel )
	{
		return CreateMultiSelectObject (pMedium);
	}
	else if (cf == m_CFSnapinPreloads)
	{
		stream_ptr s(pMedium);
		// If this is TRUE, then the next time this snapin is loaded, it will
		// be preloaded to give us the opportunity to change the root node
		// name before the user sees it.
		BOOL	x = 1;

		return s.Write (reinterpret_cast<PBYTE>(&x), sizeof (BOOL));
	}

	return DV_E_FORMATETC;
}

HRESULT CCertTemplatesDataObject::Initialize(
	CCertTmplCookie*			pcookie,
	DATA_OBJECT_TYPES		type,
	CCertTmplComponentData&	refComponentData)
{
	if ( !pcookie || m_pCookie )
	{
		ASSERT(FALSE);
		return S_OK;	// Initialize must not fail
	}

	m_dataobjecttype = type;
	m_pCookie = pcookie;

	if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie )
		((CRefcountedObject*)m_pCookie)->AddRef();
	VERIFY( SUCCEEDED(refComponentData.GetClassID(&m_SnapInCLSID)) );
	return S_OK;
}


CCertTemplatesDataObject::~CCertTemplatesDataObject()
{
	if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie &&
			m_pCookie && IsValidObjectType (m_pCookie->m_objecttype) )
	{
		((CRefcountedObject*)m_pCookie)->Release();
	}
    if (m_pbMultiSelData)
        delete m_pbMultiSelData;

    for (int i=0; i < m_rgCookies.GetSize(); ++i)
    {
        m_rgCookies[i]->Release();
        m_rgCookies[i] = 0;
    }
}

void CCertTemplatesDataObject::AddCookie(CCertTmplCookie* pCookie)
{
    m_rgCookies.Add(pCookie);
    pCookie->AddRef();
}

HRESULT CCertTemplatesDataObject::PutDisplayName(STGMEDIUM* pMedium)
	// Writes the "friendly name" to the provided storage medium
	// Returns the result of the write operation
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CString strDomainName = m_pCookie->GetManagedDomainDNSName();

	stream_ptr s (pMedium);
	CString		snapinName;
	snapinName.FormatMessage (IDS_CERTTMPL_ROOT_NODE_NAME, strDomainName);
	return s.Write ((PCWSTR) snapinName);
}

// Register the clipboard formats
CLIPFORMAT CCertTemplatesDataObject::m_CFDisplayName =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CDataObject::m_CFRawCookie =
								(CLIPFORMAT)RegisterClipboardFormat(L"CERTTMPL_SNAPIN_RAW_COOKIE");
CLIPFORMAT CCertTemplatesDataObject::m_CFMultiSel =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
CLIPFORMAT CCertTemplatesDataObject::m_CFMultiSelDobj =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
CLIPFORMAT CCertTemplatesDataObject::m_CFMultiSelDataObjs =
							    (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
CLIPFORMAT CCertTemplatesDataObject::m_CFDsObjectNames =
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);


void CCertTemplatesDataObject::SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
{
    m_pbMultiSelData = pbMultiSelData;
    m_cbMultiSelData = cbMultiSelData;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertTmplComponentData::QueryDataObject (
		MMC_COOKIE cookie,
		DATA_OBJECT_TYPES type,
		LPDATAOBJECT* ppDataObject)
{
	if ( MMC_MULTI_SELECT_COOKIE == cookie )
	{
		return QueryMultiSelectDataObject (cookie, type, ppDataObject);
	}
	CCertTmplCookie* pUseThisCookie =
			(CCertTmplCookie*) ActiveBaseCookie (
			reinterpret_cast<CCookie*> (cookie));

	CComObject<CCertTemplatesDataObject>* pDataObject = 0;
	HRESULT hRes = CComObject<CCertTemplatesDataObject>::CreateInstance(&pDataObject);
	if ( FAILED(hRes) )
		return hRes;

	HRESULT hr = pDataObject->Initialize (
			pUseThisCookie,
			type,
			*this);
	if ( FAILED(hr) )
	{
		delete pDataObject;
		return hr;
	}

    pDataObject->AddRef();
	*ppDataObject = pDataObject;
	return hr;
}

typedef CArray<GUID, const GUID&> CGUIDArray;

void GuidArray_Add(CGUIDArray& rgGuids, const GUID& guid)
{
    for (INT_PTR i=rgGuids.GetUpperBound(); i >= 0; --i)
    {
        if (rgGuids[i] == guid)
            break;
    }

    if (i < 0)
        rgGuids.Add(guid);
}

HRESULT CCertTmplComponentData::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

	HRESULT		hr = S_OK;
    CGUIDArray	rgGuids;

    // Determine the items selected
    ASSERT(m_pResultData != NULL);
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = TVIS_SELECTED;

	CCookiePtrArray	rgCookiesSelected;
    while (m_pResultData->GetNextItem (&rdi) == S_OK)
    {
        const GUID* pguid;
        CCertTmplCookie* pCookie = reinterpret_cast <CCertTmplCookie*> (rdi.lParam);
        if ( pCookie )
        {
			rgCookiesSelected.Add (pCookie);
			switch (pCookie->m_objecttype)
			{
            case CERTTMPL_CERT_TEMPLATE:
                pguid = &NODEID_CertTmpl_CERT_TEMPLATE;
                break;

			default:
				ASSERT (0);
				continue;
			}
        }
        else
        {
			hr = E_INVALIDARG;
			break;
        }

        GuidArray_Add(rgGuids, *pguid);
    }

    CComObject<CCertTemplatesDataObject>* pObject;
    CComObject<CCertTemplatesDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
	pObject->Initialize ((CCertTmplCookie*) cookie,
				type,
				*this);
    pObject->SetMultiSelDobj();



    // Store the coclass with the data object
    UINT cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
    GUID* pGuid = new GUID[(UINT)rgGuids.GetSize()];
    CopyMemory(pGuid, rgGuids.GetData(), cb);
    pObject->SetMultiSelData((BYTE*)pGuid, cb);
	for (int i=0; i < rgCookiesSelected.GetSize(); ++i)
	{
		pObject->AddCookie(rgCookiesSelected[i]);
	}

    return  pObject->QueryInterface(
			IID_PPV_ARG (IDataObject, ppDataObject));
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::Create
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the data in pBuffer
//
//  Arguments:  [pBuffer]  - [in] the data to be written
//              [len]      - [in] the length of that data
//              [pMedium] - [in,out] where to store the data
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertTemplatesDataObject::Create (const void* pBuffer, int len, LPSTGMEDIUM pMedium)
{
   HRESULT hr = DV_E_TYMED;

   //
   // Do some simple validation
   //
   if (pBuffer == NULL || pMedium == NULL)
      return E_POINTER;

   //
   // Make sure the type medium is HGLOBAL
   //
   if (pMedium->tymed == TYMED_HGLOBAL) {
      //
      // Create the stream on the hGlobal passed in
      //
      LPSTREAM lpStream = 0;
      hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &lpStream);

	  ASSERT (SUCCEEDED (hr));
      if (SUCCEEDED(hr))
	  {
         //
         // Write to the stream the number of bytes
         //
         ULONG written = 0;
         hr = lpStream->Write(pBuffer, len, &written);
		 ASSERT (SUCCEEDED (hr));

         //
         // Because we told CreateStreamOnHGlobal with 'FALSE',
         // only the stream is released here.
         // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
         // at the correct time.  This is according to the IDataObject specification.
         //
         lpStream->Release();
      }
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CCertTemplatesDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT CCertTemplatesDataObject::CreateMultiSelectObject(LPSTGMEDIUM pMedium)
{
    ASSERT(m_pbMultiSelData != 0);
    ASSERT(m_cbMultiSelData != 0);

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                                      (m_cbMultiSelData + sizeof(DWORD)));
    if (pMedium->hGlobal == NULL)
        return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(pMedium->hGlobal));
    *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID);
    pb += sizeof(DWORD);
    CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

    ::GlobalUnlock(pMedium->hGlobal);

	return S_OK;
}




LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject)
{
	if (lpDataObject == NULL)
		return NULL;

	SMMCDataObjects * pDO = NULL;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { CCertTemplatesDataObject::m_CFMultiSelDataObjs, NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	if ( FAILED (lpDataObject->GetData (&formatetc, &stgmedium)) )
	{
		return NULL;
	}
	else
	{
		pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
		return pDO->lpDataObject[0]; //assume that ours is the 1st
	}
}

STDMETHODIMP CCertTemplatesDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM pMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetc->cfFormat == m_CFMultiSel)
    {
        ASSERT(((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie);
        if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie )
            return E_FAIL;

        hr = CreateMultiSelectObject (pMedium);
    }
	else if ( lpFormatetc->cfFormat == m_CFDsObjectNames )
	{
		switch (m_pCookie->m_objecttype)
		{
        case CERTTMPL_CERT_TEMPLATE:
			{
				CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (m_pCookie);
				ASSERT (pCertTemplate);
				if ( pCertTemplate )
				{
					// figure out how much storage we need
                    CString adsiPath;
                    adsiPath = pCertTemplate->GetLDAPPath ();
					int cbPath = sizeof (WCHAR) * (adsiPath.GetLength() + 1);
					int cbClass = sizeof (WCHAR) * (pCertTemplate->GetClass ().GetLength() + 1);;
					int cbStruct = sizeof(DSOBJECTNAMES); //contains already a DSOBJECT embedded struct

					LPDSOBJECTNAMES pDSObj = 0;

					pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
							cbStruct + cbPath + cbClass);

					if ( pDSObj )
					{
						// write the info
						pDSObj->clsidNamespace = CLSID_CertTemplatesSnapin;
						pDSObj->cItems = 1;

						pDSObj->aObjects[0].dwFlags = 0;
						pDSObj->aObjects[0].dwProviderFlags = 0;

						pDSObj->aObjects[0].offsetName = cbStruct;
						pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;

						wcscpy((LPWSTR)((BYTE *)pDSObj + (pDSObj->aObjects[0].offsetName)),
								(LPCWSTR) adsiPath);

						wcscpy((LPWSTR)((BYTE *)pDSObj + (pDSObj->aObjects[0].offsetClass)),
								(LPCWSTR) pCertTemplate->GetClass ());

						pMedium->hGlobal = (HGLOBAL)pDSObj;
						pMedium->tymed = TYMED_HGLOBAL;
						pMedium->pUnkForRelease = NULL;
						hr = S_OK;
					}
					else
						hr = STG_E_MEDIUMFULL;
				}
			}
			break;

		default:
			break;
		}
	}

    return hr;
}

STDMETHODIMP CCertTemplatesDataObject::Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;

    if ((rgelt == NULL) ||
        ((celt > 1) && (pceltFetched == NULL)))
    {
        hr = E_INVALIDARG;
        return hr;
    }

    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    if (pceltFetched)
        *pceltFetched = celtTemp;

    if (celtTemp == 0)
        return S_FALSE;

    for (ULONG i=0; i < celtTemp; ++i)
    {
        rgelt[i] = reinterpret_cast<MMC_COOKIE>(m_rgCookies[m_iCurr++]);
    }

    return (celtTemp < celt) ? S_FALSE : S_OK;
}

STDMETHODIMP CCertTemplatesDataObject::Skip(ULONG celt)
{
    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    m_iCurr += celtTemp;

    return (celtTemp < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CCertTemplatesDataObject::Reset(void)
{
    m_iCurr = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dbg.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#include <StdDbg.h>

#if DBG==1
    DECLARE_DEBUG(CertTmplSnapin)
    #define DBG_COMP    CertTmplSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\disabledwarnings.h ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// pragma warnings
//
// 8 Feb 2000 sburns



// disable "symbols too long for debugger" warning: it happens a lot w/ STL

#pragma warning (disable: 4786)

// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)

// who cares about unreferenced inline removal?

#pragma warning (disable: 4514)
#pragma warning (disable : 4505)

// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)

// some stl templates are lousy signed/unsigned mismatches

#pragma warning (disable: 4018 4146)

// we like this extension

#pragma warning (disable: 4239)

// we don't always want copy constructors

#pragma warning (disable: 4511)

// we don't always want assignment operators

#pragma warning (disable: 4512)

// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#if DBG == 1
static int indentLevel = 0;

#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\CertTmpl"
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;

void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const size_t DEBUG_BUF_LEN = 512;
        WCHAR Buffer[DEBUG_BUF_LEN];
        int cb;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        cb = _vsnwprintf (Buffer, DEBUG_BUF_LEN, format, arglist);
        if ( cb )
        {
            OutputDebugStringW (Buffer);
        }

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckDebugOutputLevel
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, NULL,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\dynamlnk.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       DynamLnk.cpp
//
//  Contents:   base class for DLLs which are loaded only when needed
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "DynamLnk.h"

USE_HANDLE_MACROS("CERTTMPL(DynamLnk.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DynamicDLL::DynamicDLL(PCWSTR ptchLibraryName, LPCSTR* apchFunctionNames)
: m_hLibrary( (HMODULE)-1 ),
  m_apfFunctions( NULL ),
  m_ptchLibraryName( ptchLibraryName ),
  m_apchFunctionNames( apchFunctionNames ),
  m_nNumFunctions( 0 )
{
	ASSERT( !IsBadStringPtr(m_ptchLibraryName,MAX_PATH) );
	ASSERT (apchFunctionNames);
	for (LPCSTR pchFunctionName = *apchFunctionNames;
	     pchFunctionName;
		 pchFunctionName = *(++apchFunctionNames) )
	{
		m_nNumFunctions++;
		ASSERT( !IsBadStringPtrA(pchFunctionName,MAX_PATH) );
	}
}

DynamicDLL::~DynamicDLL()
{
	if ( m_apfFunctions )
	{
		delete m_apfFunctions;
		m_apfFunctions = NULL;
	}
	if ((HMODULE)-1 != m_hLibrary && NULL != m_hLibrary)
	{
		VERIFY( ::FreeLibrary( m_hLibrary ) );
		m_hLibrary = NULL;
	}
}

BOOL DynamicDLL::LoadFunctionPointers()
{
	if ((HMODULE)-1 != m_hLibrary)
		return (NULL != m_hLibrary);

	m_hLibrary = ::LoadLibrary( m_ptchLibraryName );
	if ( !m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}

	// let this throw an exception
	m_apfFunctions = new FARPROC[m_nNumFunctions];

	for (INT i = 0; i < m_nNumFunctions; i++)
	{
		m_apfFunctions[i] = ::GetProcAddress( m_hLibrary, m_apchFunctionNames[i] );
		if ( NULL == m_apfFunctions[i] )
		{
			// The library is present but does not have all of the entrypoints
			VERIFY( ::FreeLibrary( m_hLibrary ) );
			m_hLibrary = NULL;
			return FALSE;
		}
	}

	return TRUE;
}


FARPROC DynamicDLL::QueryFunctionPtr(INT i) const
{
	if ( 0 > i || m_nNumFunctions <= i || !m_apfFunctions || !m_apfFunctions[i] )
	{
		ASSERT( FALSE );
		return NULL;
	}
	return m_apfFunctions[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\extendedkeyusagepropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ExtendedKeyUsagePropertyPage.cpp
//
//  Contents:   Implementation of CExtendedKeyUsagePropertyPage
//
//----------------------------------------------------------------------------
// ExtendedKeyUsagePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "ExtendedKeyUsagePropertyPage.h"
#include "NewOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExtendedKeyUsagePropertyPage dialog


CExtendedKeyUsagePropertyPage::CExtendedKeyUsagePropertyPage(
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension)
	: CPropertyPage(CExtendedKeyUsagePropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension)
{
	//{{AFX_DATA_INIT(CExtendedKeyUsagePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CExtendedKeyUsagePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExtendedKeyUsagePropertyPage)
	DDX_Control(pDX, IDC_EKU_LIST, m_EKUList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExtendedKeyUsagePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CExtendedKeyUsagePropertyPage)
	ON_BN_CLICKED(IDC_NEW_EKU, OnNewEku)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExtendedKeyUsagePropertyPage message handlers

void CExtendedKeyUsagePropertyPage::OnNewEku() 
{
	CNewOIDDlg  oidDlg;


    CThemeContextActivator activator;
    oidDlg.DoModal ();
}

BOOL CExtendedKeyUsagePropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CExtendedKeyUsagePropertyPage::OnInitDialog ()\n");
	CPropertyPage::OnInitDialog();
	
	ASSERT (m_pCertExtension);
	if ( m_pCertExtension )
	{
		DWORD	cbEnhKeyUsage = 0;


		if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				szOID_ENHANCED_KEY_USAGE, 
				m_pCertExtension->Value.pbData,
				m_pCertExtension->Value.cbData,
				0, NULL, &cbEnhKeyUsage) )
		{
			PCERT_ENHKEY_USAGE	pEnhKeyUsage = (PCERT_ENHKEY_USAGE)
					::LocalAlloc (LPTR, cbEnhKeyUsage);
			if ( pEnhKeyUsage )
			{
				if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						szOID_ENHANCED_KEY_USAGE, 
						m_pCertExtension->Value.pbData,
						m_pCertExtension->Value.cbData,
						0, pEnhKeyUsage, &cbEnhKeyUsage) )
				{
					CString	usageName;

					for (DWORD dwIndex = 0; 
							dwIndex < pEnhKeyUsage->cUsageIdentifier; 
							dwIndex++)
					{
						if ( MyGetOIDInfoA (usageName, 
								pEnhKeyUsage->rgpszUsageIdentifier[dwIndex]) )
						{
                            int nIndex = m_EKUList.AddString (usageName);
                            if ( nIndex >= 0 )
                            {
                                m_EKUList.SetCheck (nIndex, BST_CHECKED);
                                m_EKUList.SetItemDataPtr (nIndex, 
                                        pEnhKeyUsage->rgpszUsageIdentifier[dwIndex]);
                            }
						}
					}
				}
				else
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptDecodeObject (szOID_ENHANCED_KEY_USAGE) failed: 0x%x\n", dwErr);
			        DisplaySystemError (NULL, dwErr);
                }
				::LocalFree (pEnhKeyUsage);
			}
		}
		else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CryptDecodeObject (szOID_ENHANCED_KEY_USAGE) failed: 0x%x\n", dwErr);
			DisplaySystemError (NULL, dwErr);
        }
	}
	
    if ( 1 == m_rCertTemplate.GetType () )
    {
        int nCnt = m_EKUList.GetCount ();
        for (int nIndex = 0; nIndex < nCnt; nIndex++)
            m_EKUList.Enable (nIndex, FALSE);

        GetDlgItem (IDC_NEW_EKU)->EnableWindow (FALSE);
    }
    _TRACE (-1, L"Leaving CExtendedKeyUsagePropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\extendedkeyusagepropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ExtendedKeyUsagePropertyPage.h
//
//  Contents:   Definition of CExtendedKeyUsagePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_EXTENDEDKEYUSAGEPROPERTYPAGE_H__71F4BE79_981E_4D84_BE10_3BA145D665E3__INCLUDED_)
#define AFX_EXTENDEDKEYUSAGEPROPERTYPAGE_H__71F4BE79_981E_4D84_BE10_3BA145D665E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ExtendedKeyUsagePropertyPage.h : header file
//
#include "CertTemplate.h"

class EKUCheckListBox : public CCheckListBox
{
public:
	EKUCheckListBox () : CCheckListBox () {};
	virtual ~EKUCheckListBox () {};
	virtual BOOL Create (DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
	{
        CThemeContextActivator activator;
		return CCheckListBox::Create (dwStyle, rect, pParentWnd, nID);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CExtendedKeyUsagePropertyPage dialog

class CExtendedKeyUsagePropertyPage : public CPropertyPage
{
// Construction
public:
	CExtendedKeyUsagePropertyPage(
            CCertTemplate& rCertTemplate, 
            PCERT_EXTENSION pCertExtension);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CExtendedKeyUsagePropertyPage)
	enum { IDD = IDD_EXTENDED_KEY_USAGE };
	EKUCheckListBox	m_EKUList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExtendedKeyUsagePropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CExtendedKeyUsagePropertyPage)
	afx_msg void OnNewEku();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CCertTemplate&  m_rCertTemplate;
    PCERT_EXTENSION m_pCertExtension;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXTENDEDKEYUSAGEPROPERTYPAGE_H__71F4BE79_981E_4D84_BE10_3BA145D665E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\dynamlnk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-1999.
//
//  File:       dynamlnk.h
//
//  Contents:   DynamicDLL
//
//----------------------------------------------------------------------------
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DynamLnk.h
//
//  Contents:   Base class for DLLs which are loaded only when needed
//
//----------------------------------------------------------------------------
 

#ifndef __DYNAMLNK_H_INCLUDED__
#define __DYNAMLNK_H_INCLUDED__

class DynamicDLL
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	DynamicDLL(LPCWSTR ptchLibraryName, LPCSTR* apchFunctionNames);
	virtual ~DynamicDLL();

	BOOL LoadFunctionPointers();

	FARPROC QueryFunctionPtr(INT i) const;
	inline FARPROC operator[] (INT i) const
		{ return QueryFunctionPtr(i); }

private:
	HMODULE m_hLibrary;
	FARPROC* m_apfFunctions;
	LPCWSTR m_ptchLibraryName;
	LPCSTR* m_apchFunctionNames;
	INT m_nNumFunctions;
};
#endif // ~__DYNAMLNK_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\helpmap.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       helpmap.h
//
//  Contents:   Help Identifiers mapped with control IDs for CertTmpl.DLL
//
//----------------------------------------------------------------------------
#ifndef __CERTTMPL_HELPMAP_H
#define __CERTTMPL_HELPMAP_H
#include "resource.h"

const DWORD g_aHelpIDs_IDD_NEW_APPLICATION_OID[]=
{
	IDC_NEW_APPLICATION_OID_NAME,IDH_NEW_APPLICATION_OID_NAME,
	IDC_NEW_APPLICATION_OID_VALUE,IDH_NEW_APPLICATION_OID_VALUE,
	0,0
};


const DWORD g_aHelpIDs_IDD_NEW_ISSUANCE_OID[]=
{
	IDC_NEW_ISSUANCE_OID_NAME,IDH_NEW_ISSUANCE_OID_NAME,
	IDC_NEW_ISSUANCE_OID_VALUE,IDH_NEW_ISSUANCE_OID_VALUE,
    IDC_CPS_EDIT, IDH_CPS_EDIT, 
	0,0
};

const DWORD g_aHelpIDs_IDD_ADD_APPROVAL[]=
{
    IDC_APPROVAL_LIST, IDH_APPROVAL_LIST,
    0, 0
};

const DWORD g_aHelpIDs_IDD_BASIC_CONSTRAINTS[]=
{
    IDC_BASIC_CONSTRAINTS_CRITICAL, IDH_BASIC_CONSTRAINTS_CRITICAL,
    IDC_ONLY_ISSUE_END_ENTITIES, IDH_ONLY_ISSUE_END_ENTITIES,
    0, 0
};

const DWORD g_aHelpIDs_IDD_KEY_USAGE[]=
{
    IDC_KEY_USAGE_CRITICAL, IDH_KEY_USAGE_CRITICAL,
    IDC_CHECK_DIGITAL_SIGNATURE, IDH_CHECK_DIGITAL_SIGNATURE,
    IDC_CHECK_NON_REPUDIATION, IDH_CHECK_NON_REPUDIATION,
    IDC_CHECK_CERT_SIGNING, IDH_CHECK_CERT_SIGNING,
    IDC_CRL_SIGNING, IDH_CRL_SIGNING,
    IDC_CHECK_KEY_AGREEMENT, IDH_CHECK_KEY_AGREEMENT,
    IDC_CHECK_KEY_ENCIPHERMENT, IDH_CHECK_KEY_ENCIPHERMENT,
    IDC_CHECK_DATA_ENCIPHERMENT, IDH_CHECK_DATA_ENCIPHERMENT,
    0, 0
};


const DWORD g_aHelpIDs_IDD_POLICY[]=
{
    IDC_POLICY_CRITICAL, IDH_POLICY_CRITICAL,
    IDC_POLICIES_LIST, IDH_POLICIES_LIST,
    IDC_ADD_POLICY, IDH_ADD_POLICY,
    IDC_REMOVE_POLICY, IDH_REMOVE_POLICY,
    IDC_EDIT_POLICY, IDH_EDIT_POLICY,
    0, 0
};


const DWORD g_aHelpIDs_IDD_SELECT_OIDS[]=
{
    IDC_OID_LIST, IDH_OID_LIST,
    IDC_NEW_OID, IDH_NEW_OID,
    0, 0
};


const DWORD g_aHelpIDs_IDD_SELECT_TEMPLATE[]=
{
    IDC_TEMPLATE_LIST, IDH_TEMPLATE_LIST,
    IDC_TEMPLATE_PROPERTIES, IDH_TEMPLATE_PROPERTIES,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_EXTENSIONS[]=
{
    IDC_EXTENSION_LIST, IDH_EXTENSION_LIST,
    IDC_SHOW_DETAILS, IDH_SHOW_DETAILS,
    IDC_EXTENSION_DESCRIPTION, IDH_EXTENSION_DESCRIPTION,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_GENERAL[]=
{
    IDC_DISPLAY_NAME, IDH_DISPLAY_NAME,
    IDC_TEMPLATE_NAME, IDH_TEMPLATE_NAME,
    IDC_VALIDITY_EDIT, IDH_VALIDITY_EDIT,
    IDC_VALIDITY_UNITS, IDH_VALIDITY_UNITS, 
    IDC_RENEWAL_EDIT, IDH_RENEWAL_EDIT,
    IDC_RENEWAL_UNITS, IDH_RENEWAL_UNITS, 
    IDC_PUBLISH_TO_AD, IDH_PUBLISH_TO_AD,
    IDC_TEMPLATE_VERSION, IDH_TEMPLATE_VERSION,
    IDC_USE_AD_CERT_FOR_REENROLLMENT, IDH_USE_AD_CERT_FOR_REENROLLMENT,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V1_REQUEST[]=
{
    IDC_PURPOSE_COMBO, IDH_V1_PURPOSE_COMBO,
    IDC_EXPORT_PRIVATE_KEY, IDH_V1_EXPORT_PRIVATE_KEY,
    IDC_CSP_LIST, IDH_V1_CSP_LIST, 
    0, 0
};

const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_REQUEST[]=
{
    IDC_PURPOSE_COMBO, IDH_V2_PURPOSE_COMBO,
    IDC_ARCHIVE_KEY_CHECK, IDH_V2_ARCHIVE_KEY_CHECK,
    IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, IDH_V2_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK,
    IDC_MINIMUM_KEYSIZE_VALUE, IDH_V2_MINIMUM_KEYSIZE_VALUE, 
    IDC_EXPORT_PRIVATE_KEY, IDH_V2_EXPORT_PRIVATE_KEY,
    IDC_CSP_LIST, IDH_V2_CSP_LIST, 
    IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT, IDH_V2_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT,
	IDC_DELETE_PERMANENTLY, IDH_V2_DELETE_PERMANENTLY,
    0, 0
};

const DWORD g_aHelpIDs_IDD_TEMPLATE_V1_SUBJECT_NAME[]=
{
    IDC_REQUIRE_SUBJECT, IDH_REQUIRE_SUBJECT,
    IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA, IDH_SUBJECT_AND_BUILD_SUBJECT_BY_CA,
    IDC_EMAIL_NAME, IDH_EMAIL_NAME, 
    IDC_SUBJECT_MUST_BE_MACHINE, IDH_SUBJECT_MUST_BE_MACHINE,
    IDC_SUBJECT_MUST_BE_USER, IDH_SUBJECT_MUST_BE_USER, 
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_AUTHENTICATION[]=
{
    IDC_ISSUANCE_POLICIES, IDH_ISSUANCE_POLICIES,
    IDC_ADD_APPROVAL, IDH_ADD_APPROVAL,
    IDC_REMOVE_APPROVAL, IDH_REMOVE_APPROVAL,
    IDC_NUM_SIG_REQUIRED_EDIT, IDH_NUM_SIG_REQUIRED_EDIT, 
    IDC_REENROLLMENT_REQUIRES_VALID_CERT, IDH_REENROLLMENT_REQUIRES_VALID_CERT,
    IDC_REENROLLMENT_SAME_AS_ENROLLMENT, IDH_REENROLLMENT_SAME_AS_ENROLLMENT,
    IDC_NUM_SIG_REQUIRED_CHECK, IDH_NUM_SIG_REQUIRED_CHECK,
    IDC_PEND_ALL_REQUESTS, IDH_PEND_ALL_REQUESTS,
    IDC_POLICY_TYPES, IDH_POLICY_TYPES,
    IDC_APPLICATION_POLICIES, IDH_APPLICATION_POLICIES,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_SUBJECT_NAME[]=
{
    IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, IDH_SUBJECT_NAME_SUPPLIED_IN_REQUEST,
    IDC_SUBJECT_NAME_BUILT_BY_CA, IDH_SUBJECT_NAME_BUILT_BY_CA,
    IDC_SUBJECT_NAME_NAME_LABEL, IDH_SUBJECT_NAME_NAME_LABEL,
    IDC_SUBJECT_NAME_NAME_COMBO, IDH_SUBJECT_NAME_NAME_COMBO, 
    IDC_EMAIL_IN_SUB, IDH_EMAIL_IN_SUB,
    IDC_EMAIL_IN_ALT, IDH_EMAIL_IN_ALT,
    IDC_DNS_NAME, IDH_DNS_NAME,
    IDC_UPN, IDH_UPN,
    IDC_SPN, IDH_SPN,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_SUPERCEDES[]=
{
    IDC_SUPERCEDED_TEMPLATES_LIST, IDH_SUPERCEDED_TEMPLATES_LIST,
    IDC_ADD_SUPERCEDED_TEMPLATE, IDH_ADD_SUPERCEDED_TEMPLATE,
    IDC_REMOVE_SUPERCEDED_TEMPLATE, IDH_REMOVE_SUPERCEDED_TEMPLATE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_VIEW_OIDS[]=
{
    IDC_OID_LIST, IDH_VIEW_OIDS_OID_LIST,
    IDC_COPY_OID, IDH_COPY_OID,
    0, 0
};

#endif // __CERTTMPL_HELPMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\helppropertypage.cpp ===
// HelpPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "HelpPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage property page


CHelpPropertyPage::CHelpPropertyPage(UINT uIDD) : 
    CAutoDeletePropPage(uIDD),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpPropertyPage::~CHelpPropertyPage()
{
}

void CHelpPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpPropertyPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CHelpPropertyPage)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage message handlers
void CHelpPropertyPage::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpPropertyPage::OnWhatsThis\n");
}

BOOL CHelpPropertyPage::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnHelp\n");
    return TRUE;
}

void CHelpPropertyPage::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpPropertyPage::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpPropertyPage::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnContextMenu\n");
}


/////////////////////////////////////////////////////////////////////////////
// CHelpDialog property page


CHelpDialog::CHelpDialog(UINT uIDD, CWnd* pParentWnd) : 
    CDialog(uIDD, pParentWnd),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpDialog::~CHelpDialog()
{
}

void CHelpDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog message handlers
void CHelpDialog::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpDialog::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpDialog::OnWhatsThis\n");
}

BOOL CHelpDialog::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpDialog::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpDialog::OnHelp\n");
    return TRUE;
}

void CHelpDialog::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpDialog::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpDialog::OnContextMenu\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\helppropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       HelpPropertyPage.h
//
//  Contents:   Declaration of CHelpPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
#define AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HelpPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpPropertyPage : public CAutoDeletePropPage
{
// Construction
public:
	CHelpPropertyPage(UINT uIDD);
	~CHelpPropertyPage();

// Dialog Data
	//{{AFX_DATA(CHelpPropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpPropertyPage)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

private:
    HWND            m_hWndWhatsThis;
};


/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpDialog : public CDialog
{
// Construction
public:
	CHelpDialog(UINT uIDD, CWnd* pParentWnd);
	~CHelpDialog();

// Dialog Data
	//{{AFX_DATA(CHelpDialog)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpDialog)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

private:
    HWND            m_hWndWhatsThis;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\helpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       helpids.h
//
//  Contents:   Help Identifiers for the entire UI project
//
//----------------------------------------------------------------------------
#ifndef __CERTTMPL_HELPIDS_H
#define __CERTTMPL_HELPIDS_H

// IDD_NEW_APPLICATION_OID
#define IDH_NEW_APPLICATION_OID_NAME    1500
#define IDH_NEW_APPLICATION_OID_VALUE   1501

// IDD_NEW_ISSUANCE_OID
#define IDH_NEW_ISSUANCE_OID_NAME    1505
#define IDH_NEW_ISSUANCE_OID_VALUE   1506
#define IDH_CPS_EDIT                 1507

// IDD_ADD_APPROVAL
#define IDH_APPROVAL_LIST   1510

// IDD_BASIC_CONSTRAINTS
#define IDH_BASIC_CONSTRAINTS_CRITICAL  1520
#define IDH_ONLY_ISSUE_END_ENTITIES     1521

// IDD_KEY_USAGE
#define IDH_KEY_USAGE_CRITICAL          1530
#define IDH_CHECK_DIGITAL_SIGNATURE     1531
#define IDH_CHECK_NON_REPUDIATION       1532
#define IDH_CHECK_CERT_SIGNING          1533
#define IDH_CRL_SIGNING                 1534
#define IDH_CHECK_KEY_AGREEMENT         1535
#define IDH_CHECK_KEY_ENCIPHERMENT      1536
#define IDH_CHECK_DATA_ENCIPHERMENT     1537

// IDD_POLICY
#define IDH_POLICY_CRITICAL             1550
#define IDH_POLICIES_LIST               1551
#define IDH_ADD_POLICY                  1552
#define IDH_REMOVE_POLICY               1553
#define IDH_EDIT_POLICY                 1554

// IDD_SELECT_OIDS
#define IDH_OID_LIST                    1560
#define IDH_NEW_OID                     1561

// IDD_SELECT_TEMPLATE
#define IDH_TEMPLATE_LIST               1570
#define IDH_TEMPLATE_PROPERTIES         1571

// IDD_TEMPLATE_EXTENSIONS
#define IDH_EXTENSION_LIST              1580
#define IDH_SHOW_DETAILS                1581
#define IDH_EXTENSION_DESCRIPTION       1582

// IDD_TEMPLATE_GENERAL
#define IDH_DISPLAY_NAME                1600
#define IDH_TEMPLATE_NAME               1601
#define IDH_VALIDITY_EDIT               1602
#define IDH_VALIDITY_UNITS              1603
#define IDH_RENEWAL_EDIT                1604
#define IDH_RENEWAL_UNITS               1605
#define IDH_PUBLISH_TO_AD               1606
#define IDH_TEMPLATE_VERSION            1607
#define IDH_USE_AD_CERT_FOR_REENROLLMENT 1608

// IDD_TEMPLATE_V1_REQUEST
#define IDH_V1_PURPOSE_COMBO            1610
#define IDH_V1_EXPORT_PRIVATE_KEY       1611
#define IDH_V1_CSP_LIST                 1612

// IDD_TEMPLATE_V2_REQUEST
#define IDH_V2_PURPOSE_COMBO            1620
#define IDH_V2_ARCHIVE_KEY_CHECK        1621
#define IDH_V2_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK  1622
#define IDH_V2_MINIMUM_KEYSIZE_VALUE    1623
#define IDH_V2_EXPORT_PRIVATE_KEY       1624
#define IDH_V2_CSP_LIST                 1625
#define IDH_V2_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT   1626
#define IDH_V2_DELETE_PERMANENTLY           1627


// IDD_TEMPLATE_V1_SUBJECT_NAME
#define IDH_REQUIRE_SUBJECT             1630
#define IDH_SUBJECT_AND_BUILD_SUBJECT_BY_CA 1631
#define IDH_EMAIL_NAME                  1633
#define IDH_SUBJECT_MUST_BE_MACHINE     1634
#define IDH_SUBJECT_MUST_BE_USER        1635

// IDD_TEMPLATE_V2_AUTHENTICATION
#define IDH_ISSUANCE_POLICIES           1640
#define IDH_ADD_APPROVAL                1641
#define IDH_REMOVE_APPROVAL             1642
#define IDH_NUM_SIG_REQUIRED_EDIT       1643
#define IDH_REENROLLMENT_REQUIRES_VALID_CERT    1644
#define IDH_REENROLLMENT_SAME_AS_ENROLLMENT     1645
#define IDH_NUM_SIG_REQUIRED_CHECK      1646
#define IDH_PEND_ALL_REQUESTS           1647
#define IDH_POLICY_TYPES                1648
#define IDH_APPLICATION_POLICIES        1649

// IDD_TEMPLATE_V2_SUBJECT_NAME
#define IDH_SUBJECT_NAME_SUPPLIED_IN_REQUEST    1650
#define IDH_SUBJECT_NAME_BUILT_BY_CA    1651
#define IDH_SUBJECT_NAME_NAME_LABEL     1652
#define IDH_SUBJECT_NAME_NAME_COMBO     1653
#define IDH_EMAIL_IN_SUB                1654
#define IDH_EMAIL_IN_ALT                1655
#define IDH_DNS_NAME                    1656
#define IDH_UPN                         1657
#define IDH_SPN                         1658

// IDD_TEMPLATE_V2_SUPERCEDES
#define IDH_SUPERCEDED_TEMPLATES_LIST   1680
#define IDH_ADD_SUPERCEDED_TEMPLATE     1681
#define IDH_REMOVE_SUPERCEDED_TEMPLATE  1682

// IDD_VIEW_OIDS
#define IDH_VIEW_OIDS_OID_LIST          1690
#define IDH_COPY_OID                    1691

#endif // __CERTTMPL_HELPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\keyusagedlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       KeyUsageDlg.h
//
//  Contents:   Definition of CKeyUsageDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_KEYUSAGEDLG_H__18ABC4AB_A46B_46A9_B1BA_888CE7C5C782__INCLUDED_)
#define AFX_KEYUSAGEDKG_H__18ABC4AB_A46B_46A9_B1BA_888CE7C5C782__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// KeyUsageDlg.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CKeyUsageDlg dialog

class CKeyUsageDlg : public CHelpDialog
{
// Construction
public:
	CKeyUsageDlg(CWnd* pParent, CCertTemplate& rCertTemplate, PCERT_EXTENSION pCertExtension);
	~CKeyUsageDlg();

// Dialog Data
	//{{AFX_DATA(CKeyUsageDlg)
	enum { IDD = IDD_KEY_USAGE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CKeyUsageDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CKeyUsageDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckCertSigning();
	afx_msg void OnCheckDataEncipherment();
	afx_msg void OnCheckDigitalSignature();
	afx_msg void OnCheckKeyAgreement();
	afx_msg void OnCheckKeyEncipherment();
	afx_msg void OnCheckNonRepudiation();
	afx_msg void OnCrlSigning();
	afx_msg void OnKeyUsageCritical();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    afx_msg LRESULT OnInitializationComplete (WPARAM, LPARAM);

    bool            m_bInitializationComplete;
	DWORD           m_cbKeyUsage;
	CRYPT_BIT_BLOB* m_pKeyUsage;
	bool            m_bModified;
    CCertTemplate&  m_rCertTemplate;
    PCERT_EXTENSION m_pCertExtension;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEKEYUSAGEDLG_H__18ABC4AB_A46B_46A9_B1BA_888CE7C5C782__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\makefile.inc ===
!include ..\..\makefile.inc

$(O)\CERTTMPL.res: resource.h certtmpl.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\newapplicationoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       NewApplicationOIDDlg.cpp
//
//  Contents:   Implementation of CNewApplicationOIDDlg
//
//----------------------------------------------------------------------------
// NewApplicationOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NewApplicationOIDDlg.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST	    g_policyOIDList;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewApplicationOIDDlg dialog


CNewApplicationOIDDlg::CNewApplicationOIDDlg(CWnd* pParent)
	: CHelpDialog(CNewApplicationOIDDlg::IDD, pParent),
    m_bEdit (false),
    m_bDirty (false)
{
	//{{AFX_DATA_INIT(CNewApplicationOIDDlg)
	m_oidFriendlyName = _T("");
	m_oidValue = _T("");
	//}}AFX_DATA_INIT
}


CNewApplicationOIDDlg::CNewApplicationOIDDlg(CWnd* pParent, 
        const CString& szDisplayName,
        const CString& szOID)
	: CHelpDialog(CNewApplicationOIDDlg::IDD, pParent),
    m_bEdit (true),
    m_bDirty (false),
    m_originalOidFriendlyName (szDisplayName),
	m_oidFriendlyName (szDisplayName),
	m_oidValue (szOID)
{
}


void CNewApplicationOIDDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewApplicationOIDDlg)
	DDX_Control(pDX, IDC_NEW_APPLICATION_OID_VALUE, m_oidValueEdit);
	DDX_Text(pDX, IDC_NEW_APPLICATION_OID_NAME, m_oidFriendlyName);
	DDX_Text(pDX, IDC_NEW_APPLICATION_OID_VALUE, m_oidValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewApplicationOIDDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CNewApplicationOIDDlg)
	ON_EN_CHANGE(IDC_NEW_APPLICATION_OID_NAME, OnChangeNewOidName)
	ON_EN_CHANGE(IDC_NEW_APPLICATION_OID_VALUE, OnChangeNewOidValue)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewApplicationOIDDlg message handlers

BOOL CNewApplicationOIDDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CNewApplicationOIDDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	
	    
    PWSTR   pwszOID = 0;
    if ( m_bEdit )
    {
        CString text;

        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICY));
        SetWindowText (text);
        m_oidValueEdit.SetReadOnly ();

        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICY_HINT));
        SetDlgItemText (IDC_NEW_APPLICATION_OID_HINT, text);
    }
    else
    {
        HRESULT hr = CAOIDCreateNew
                (CERT_OID_TYPE_APPLICATION_POLICY,
                0,
                &pwszOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            m_szOriginalOID = pwszOID;
            m_oidValue = pwszOID;
            LocalFree (pwszOID);
        }
        else
        {
            _TRACE (0, L"CAOIDCreateNew (CERT_OID_TYPE_APPLICATION_POLICY) failed: 0x%x\n",
                    hr);
        }
    }

    UpdateData (FALSE);

    // Don't allow rename for OIDS returned by CryptoAPI
    if ( m_bEdit )
    {
        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( pPolicyOID->GetOIDW () == m_oidValue )
                {
                    if ( !pPolicyOID->CanRename () )
                    {
                        GetDlgItem (IDC_NEW_APPLICATION_OID_NAME)->EnableWindow (FALSE);
                    }
                    break;
                }
            }
        }
    }

    EnableControls ();

    _TRACE (-1, L"Leaving CNewApplicationOIDDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewApplicationOIDDlg::EnableControls()
{
    UpdateData (TRUE);
    if ( m_oidFriendlyName.IsEmpty () || m_oidValue.IsEmpty () || !m_bDirty )
        GetDlgItem (IDOK)->EnableWindow (FALSE);
    else
        GetDlgItem (IDOK)->EnableWindow (TRUE);
}

void CNewApplicationOIDDlg::OnChangeNewOidName() 
{
    m_bDirty = true;
    EnableControls ();
}

void CNewApplicationOIDDlg::OnChangeNewOidValue() 
{
    m_bDirty = true;
    EnableControls ();
}

void CNewApplicationOIDDlg::OnCancel() 
{
	if ( !m_bEdit )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
        }
    }
	
	CHelpDialog::OnCancel();
}

void CNewApplicationOIDDlg::OnOK() 
{
    UpdateData (TRUE);

    int errorTypeStrID = 0;
    if ( !OIDHasValidFormat (m_oidValue, errorTypeStrID) )
    {
        CString text;
        CString caption;
        CString errorType;
        CThemeContextActivator activator;


        VERIFY (caption.LoadString (IDS_CERTTMPL));
        VERIFY (errorType.LoadString (errorTypeStrID));
        text.FormatMessage (IDS_OID_FORMAT_INVALID, m_oidValue, errorType);

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        m_oidValueEdit.SetFocus ();
        return;
    }

    if ( !m_bEdit && m_szOriginalOID != m_oidValue )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            hr = CAOIDAdd (CERT_OID_TYPE_APPLICATION_POLICY,
                    0,
                    m_oidValue);
            if ( FAILED (hr) )
            {
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                text.FormatMessage (IDS_OID_ALREADY_EXISTS, m_oidValue);

                MessageBox (text, caption, MB_OK);
                GetDlgItem (IDOK)->EnableWindow (FALSE);
                m_oidValueEdit.SetFocus ();
 
                _TRACE (0, L"CAOIDAdd (%s) failed: 0x%x\n",
                        (PCWSTR) m_oidValue, hr);
                return;
            }
        }
        else
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
            return;
        }
    }

    HRESULT hr = S_OK;
    // If we're editing, don't save the value if it hasn't changed
    if ( (m_bEdit && m_originalOidFriendlyName != m_oidFriendlyName) || !m_bEdit )
    {
        hr = CAOIDSetProperty (m_oidValue, CERT_OID_PROPERTY_DISPLAY_NAME,
                m_oidFriendlyName.IsEmpty () ? 0 : ((LPVOID) (LPCWSTR) m_oidFriendlyName));
        if ( SUCCEEDED (hr) )
        {
            // Update the OID list
            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
            {
                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                if ( pPolicyOID && 
                        pPolicyOID->IsApplicationOID () && 
                        m_oidValue == pPolicyOID->GetOIDW ())
                {
                    pPolicyOID->SetDisplayName (m_oidFriendlyName);
                }
            }
        }
    }
    _ASSERT (SUCCEEDED(hr));
    if ( FAILED (hr) )
    {
        _TRACE (0, L"CAOIDSetProperty (%s, CERT_OID_PROPERTY_DISPLAY_NAME, %s) failed: 0x%x\n",
                (PCWSTR) m_oidValue, (PCWSTR) m_oidFriendlyName, hr);
        return;
    }

    
	CHelpDialog::OnOK();
}

void CNewApplicationOIDDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CNewApplicationOIDDlg::DoContextHelp\n");
    
	// Display context help for a control
	if ( !::WinHelp (
			hWndControl,
			GetContextHelpFile (),
			HELP_WM_HELP,
			(DWORD_PTR) g_aHelpIDs_IDD_NEW_APPLICATION_OID) )
	{
		_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
	}
    _TRACE(-1, L"Leaving CNewApplicationOIDDlg::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\nodetype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001
//
//  File:       nodetype.h
//
//  Contents:   Declaration of CertTmplObjectType
//
//----------------------------------------------------------------------------

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _CertTmplObjectType {
	CERTTMPL_MULTISEL = MMC_MULTI_SELECT_COOKIE,
	CERTTMPL_INVALID = -1,
	CERTTMPL_SNAPIN = 0,
    CERTTMPL_CERT_TEMPLATE,
	CERTTMPL_NUMTYPES		//must be last
} CertTmplObjectType, *PCertTmplObjectType;

inline bool IsValidObjectType (CertTmplObjectType objecttype)
{ 
	return ((objecttype >= CERTTMPL_SNAPIN && objecttype < CERTTMPL_NUMTYPES)); 
}



#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\keyusagedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       KeyUsageDlg.cpp
//
//  Contents:   Implementation of CKeyUsageDlg
//
//----------------------------------------------------------------------------
// KeyUsageDlg.cpp : implementation file
//

#include "stdafx.h"
#include "KeyUsageDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_INITIALIZATION_COMPLETE  WM_APP + 2002

/////////////////////////////////////////////////////////////////////////////
// CKeyUsageDlg property page

CKeyUsageDlg::CKeyUsageDlg(CWnd* pParent, CCertTemplate& rCertTemplate, PCERT_EXTENSION pCertExtension) : 
    CHelpDialog(CKeyUsageDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension),
    m_bModified (false),
    m_pKeyUsage (0),
    m_cbKeyUsage (0),
    m_bInitializationComplete (false)
{
	//{{AFX_DATA_INIT(CKeyUsageDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CKeyUsageDlg::~CKeyUsageDlg()
{
    if ( m_pKeyUsage )
        LocalFree (m_pKeyUsage);
    m_rCertTemplate.Release ();
}

void CKeyUsageDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyUsageDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CKeyUsageDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CKeyUsageDlg)
	ON_BN_CLICKED(IDC_CHECK_CERT_SIGNING, OnCheckCertSigning)
	ON_BN_CLICKED(IDC_CHECK_DATA_ENCIPHERMENT, OnCheckDataEncipherment)
	ON_BN_CLICKED(IDC_CHECK_DIGITAL_SIGNATURE, OnCheckDigitalSignature)
	ON_BN_CLICKED(IDC_CHECK_KEY_AGREEMENT, OnCheckKeyAgreement)
	ON_BN_CLICKED(IDC_CHECK_KEY_ENCIPHERMENT, OnCheckKeyEncipherment)
	ON_BN_CLICKED(IDC_CHECK_NON_REPUDIATION, OnCheckNonRepudiation)
	ON_BN_CLICKED(IDC_CRL_SIGNING, OnCrlSigning)
	ON_BN_CLICKED(IDC_KEY_USAGE_CRITICAL, OnKeyUsageCritical)
	//}}AFX_MSG_MAP
    ON_MESSAGE (WM_INITIALIZATION_COMPLETE, OnInitializationComplete)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyUsageDlg message handlers

BOOL CKeyUsageDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CKeyUsageDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	

	ASSERT (m_pCertExtension);
	if ( m_pCertExtension )
	{

        if ( m_pCertExtension->fCritical )
            SendDlgItemMessage (IDC_KEY_USAGE_CRITICAL, BM_SETCHECK, BST_CHECKED);

		if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				szOID_KEY_USAGE, 
				m_pCertExtension->Value.pbData,
				m_pCertExtension->Value.cbData,
				0, NULL, &m_cbKeyUsage) )
		{
			m_pKeyUsage = (CRYPT_BIT_BLOB*)
					::LocalAlloc (LPTR, m_cbKeyUsage);
			if ( m_pKeyUsage )
			{
				if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						szOID_KEY_USAGE, 
						m_pCertExtension->Value.pbData,
						m_pCertExtension->Value.cbData,
						0, m_pKeyUsage, &m_cbKeyUsage) )
				{
                    if (m_pKeyUsage->cbData >= 1)
                    {
                        if ( m_pKeyUsage->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_DIGITAL_SIGNATURE, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_NON_REPUDIATION, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_KEY_ENCIPHERMENT, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_DATA_ENCIPHERMENT, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_KEY_AGREEMENT, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_CERT_SIGNING, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
                            SendDlgItemMessage (IDC_CRL_SIGNING, BM_SETCHECK, BST_CHECKED);
                    }

                    if (m_pKeyUsage->cbData >= 2)
                    {
//                        if ( m_pKeyUsage->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE )
//                            SendDlgItemMessage (IDC_CHECK_DECIPHERMENT_ONLY, BM_SETCHECK, BST_CHECKED);
                    }
				}
				else
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			        DisplaySystemError (NULL, dwErr);
                }
			}
		}
		else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			DisplaySystemError (NULL, dwErr);
        }
	}

    // Digital Signature is always disabled
    GetDlgItem (IDC_CHECK_DIGITAL_SIGNATURE)->EnableWindow (FALSE);

	if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_KEY_USAGE_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_NON_REPUDIATION)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_DATA_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_AGREEMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_CERT_SIGNING)->EnableWindow (FALSE);
    }
	
    EnableControls ();

    PostMessage (WM_INITIALIZATION_COMPLETE);

    _TRACE (-1, L"Leaving CKeyUsageDlg::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CKeyUsageDlg::OnCheckCertSigning() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckDataEncipherment() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckDigitalSignature() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckKeyAgreement() 
{
    if ( m_bInitializationComplete )
    {
        SendDlgItemMessage (IDC_CHECK_DATA_ENCIPHERMENT, BM_SETCHECK, BST_UNCHECKED);
    
        m_bModified = true;
        EnableControls ();
    }
}

void CKeyUsageDlg::OnCheckKeyEncipherment() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckNonRepudiation() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCrlSigning() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_SIGNATURE_OPTIONS)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_NON_REPUDIATION)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_CERT_SIGNING)->EnableWindow (FALSE);
        GetDlgItem (IDC_CRL_SIGNING)->EnableWindow (FALSE);
        GetDlgItem (IDC_ENCRYPTION_OPTIONS)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_AGREEMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_DATA_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        GetDlgItem (IDC_KEY_USAGE_CRITICAL)->EnableWindow (FALSE);
    }
    else
    {
        BOOL bKeyEnc = (BST_CHECKED == SendDlgItemMessage (IDC_CHECK_KEY_ENCIPHERMENT, BM_GETCHECK));
        bool bEncryption = m_rCertTemplate.HasEncryptionSignature () && !m_rCertTemplate.ReadOnly ();
        bool bSignature = m_rCertTemplate.HasKeySpecSignature () && !m_rCertTemplate.ReadOnly ();

        // Enable Signature group
        GetDlgItem (IDC_SIGNATURE_OPTIONS)->EnableWindow (bSignature);
        GetDlgItem (IDC_CHECK_NON_REPUDIATION)->EnableWindow (bSignature);
        GetDlgItem (IDC_CHECK_CERT_SIGNING)->EnableWindow (bSignature);
        GetDlgItem (IDC_CRL_SIGNING)->EnableWindow (bSignature);

        // Enable Encryption group
        GetDlgItem (IDC_ENCRYPTION_OPTIONS)->EnableWindow (bEncryption);
        GetDlgItem (IDC_CHECK_KEY_AGREEMENT)->EnableWindow (bEncryption);
        GetDlgItem (IDC_CHECK_KEY_ENCIPHERMENT)->EnableWindow (bEncryption);
        GetDlgItem (IDC_CHECK_DATA_ENCIPHERMENT)->EnableWindow (bKeyEnc && bEncryption);

        GetDlgItem (IDOK)->EnableWindow (m_bModified);

        GetDlgItem (IDC_KEY_USAGE_CRITICAL)->EnableWindow (!m_rCertTemplate.ReadOnly ());
    }
}

void CKeyUsageDlg::OnKeyUsageCritical() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CKeyUsageDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_SIGNATURE_OPTIONS:
    case IDC_ENCRYPTION_OPTIONS:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_KEY_USAGE) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CKeyUsageDlg::DoContextHelp\n");
}

void CKeyUsageDlg::OnOK() 
{
    if (m_pKeyUsage->cbData >= 1)
    {
        m_pKeyUsage->pbData[0] = 0;
        m_pKeyUsage->cUnusedBits = 0;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_DIGITAL_SIGNATURE, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_NON_REPUDIATION, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_NON_REPUDIATION_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_KEY_ENCIPHERMENT, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_KEY_ENCIPHERMENT_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_DATA_ENCIPHERMENT, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_DATA_ENCIPHERMENT_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_KEY_AGREEMENT, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_KEY_AGREEMENT_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_CERT_SIGNING, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_KEY_CERT_SIGN_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CRL_SIGNING, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_OFFLINE_CRL_SIGN_KEY_USAGE;
    }

    bool    bCritical = BST_CHECKED == SendDlgItemMessage (
                IDC_KEY_USAGE_CRITICAL, BM_GETCHECK);
    HRESULT hr = m_rCertTemplate.SetKeyUsage (m_pKeyUsage, bCritical);
    if ( FAILED (hr) )
        return;
	CHelpDialog::OnOK();
}

LRESULT CKeyUsageDlg::OnInitializationComplete (WPARAM, LPARAM)
{
    m_bInitializationComplete = true;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\newapplicationoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       NewApplicationOIDDlg.h
//
//  Contents:   Definition of CNewApplicationOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_NEWAPPLICATIONOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
#define AFX_NEWAPPICATIONOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewApplicationOIDDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewApplicationOIDDlg dialog

class CNewApplicationOIDDlg : public CHelpDialog
{
// Construction
public:
	CNewApplicationOIDDlg(CWnd* pParent);   // standard constructor
    CNewApplicationOIDDlg(CWnd* pParent, 
            const CString& szDisplayName,
            const CString& szOID);
    virtual ~CNewApplicationOIDDlg () {}

// Dialog Data
	//{{AFX_DATA(CNewApplicationOIDDlg)
	enum { IDD = IDD_NEW_APPLICATION_OID };
	CEdit	m_oidValueEdit;
	CString	m_oidFriendlyName;
	CString	m_oidValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewApplicationOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls ();

	// Generated message map functions
	//{{AFX_MSG(CNewApplicationOIDDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewOidName();
	afx_msg void OnChangeNewOidValue();
	virtual void OnCancel();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   	const CString m_originalOidFriendlyName;
    CString     m_szOriginalOID;
    const bool  m_bEdit;
    bool        m_bDirty;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWAPPLICATIONOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\newissuanceoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       NewIssuanceOIDDlg.cpp
//
//  Contents:   Implementation of CNewIssuanceOIDDlg
//
//----------------------------------------------------------------------------
// NewIssuanceOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NewIssuanceOIDDlg.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST	    g_policyOIDList;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewIssuanceOIDDlg dialog


CNewIssuanceOIDDlg::CNewIssuanceOIDDlg(CWnd* pParent)
	: CHelpDialog(CNewIssuanceOIDDlg::IDD, pParent),
    m_bEdit (false),
    m_bDirty (false)
{
	//{{AFX_DATA_INIT(CNewIssuanceOIDDlg)
	m_oidFriendlyName = _T("");
	m_oidValue = _T("");
	m_CPSValue = _T("");
	//}}AFX_DATA_INIT
}

CNewIssuanceOIDDlg::CNewIssuanceOIDDlg(CWnd* pParent, 
        const CString& szDisplayName,
        const CString& szOID,
        const CString& szCPS)
	: CHelpDialog(CNewIssuanceOIDDlg::IDD, pParent),
    m_bEdit (true),
    m_bDirty (false),
    m_originalOidFriendlyName (szDisplayName),
	m_oidFriendlyName (szDisplayName),
	m_oidValue (szOID),
    m_CPSValue (szCPS),
    m_originalCPSValue (szCPS)
{
}

void CNewIssuanceOIDDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewIssuanceOIDDlg)
	DDX_Control(pDX, IDC_NEW_ISSUANCE_OID_VALUE, m_oidValueEdit);
	DDX_Control(pDX, IDC_CPS_EDIT, m_CPSEdit);
	DDX_Text(pDX, IDC_NEW_ISSUANCE_OID_NAME, m_oidFriendlyName);
	DDX_Text(pDX, IDC_NEW_ISSUANCE_OID_VALUE, m_oidValue);
	DDX_Text(pDX, IDC_CPS_EDIT, m_CPSValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewIssuanceOIDDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CNewIssuanceOIDDlg)
	ON_EN_CHANGE(IDC_NEW_ISSUANCE_OID_NAME, OnChangeNewOidName)
	ON_EN_CHANGE(IDC_NEW_ISSUANCE_OID_VALUE, OnChangeNewOidValue)
    ON_NOTIFY(EN_LINK, IDC_CPS_EDIT, OnClickedURL )
	ON_EN_CHANGE(IDC_CPS_EDIT, OnChangeCpsEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewIssuanceOIDDlg message handlers

BOOL CNewIssuanceOIDDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CNewIssuanceOIDDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	
    m_CPSEdit.SendMessage (EM_AUTOURLDETECT, TRUE);
    m_CPSEdit.SetEventMask (ENM_CHANGE | ENM_LINK);
	    
    PWSTR   pwszOID = 0;
    if ( m_bEdit )
    {
        CString text;

        VERIFY (text.LoadString (IDS_EDIT_ISSUANCE_POLICY));
        SetWindowText (text);
        m_oidValueEdit.SetReadOnly ();

        VERIFY (text.LoadString (IDS_NEW_ISSUANCE_POLICY_HINT));
        SetDlgItemText (IDC_NEW_ISSUANCE_POLICY_HINT, text);
    }
    else
    {
        HRESULT hr = CAOIDCreateNew
                (CERT_OID_TYPE_ISSUER_POLICY,
                0,
                &pwszOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            m_szOriginalOID = pwszOID;
            m_oidValue = pwszOID;
            LocalFree (pwszOID);
        }
        else
        {
            _TRACE (0, L"CAOIDCreateNew (CERT_OID_TYPE_ISSUER_POLICY) failed: 0x%x\n",
                    hr);
        }
    }


    UpdateData (FALSE);

    // Don't allow rename for OIDS returned by CryptoAPI
    if ( m_bEdit )
    {
        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( pPolicyOID->GetOIDW () == m_oidValue )
                {
                    if ( !pPolicyOID->CanRename () )
                    {
                        GetDlgItem (IDC_NEW_ISSUANCE_OID_NAME)->EnableWindow (FALSE);
                    }
                    break;
                }
            }
        }
    }
    EnableControls ();

    _TRACE (-1, L"Leaving CNewIssuanceOIDDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewIssuanceOIDDlg::EnableControls()
{
    UpdateData (TRUE);
    if ( m_oidFriendlyName.IsEmpty () || m_oidValue.IsEmpty () || !m_bDirty )
        GetDlgItem (IDOK)->EnableWindow (FALSE);
    else
        GetDlgItem (IDOK)->EnableWindow (TRUE);
}

void CNewIssuanceOIDDlg::OnChangeNewOidName() 
{
    m_bDirty = true;
    EnableControls ();
}

void CNewIssuanceOIDDlg::OnChangeNewOidValue() 
{
    m_bDirty = true;
    EnableControls ();
}

void CNewIssuanceOIDDlg::OnCancel() 
{
	if ( !m_bEdit )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
        }
    }
	
	CHelpDialog::OnCancel();
}

void CNewIssuanceOIDDlg::OnOK() 
{
    CThemeContextActivator activator;
    UpdateData (TRUE);

    int errorTypeStrID = 0;
    if ( !OIDHasValidFormat (m_oidValue, errorTypeStrID) )
    {
        CString text;
        CString caption;
        CString errorType;


        VERIFY (caption.LoadString (IDS_CERTTMPL));
        if ( errorTypeStrID )
            VERIFY (errorType.LoadString (errorTypeStrID));
        text.FormatMessage (IDS_OID_FORMAT_INVALID, m_oidValue, errorType);

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        m_oidValueEdit.SetFocus ();
        return;
    }

    if ( !m_bEdit && m_szOriginalOID != m_oidValue )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            hr = CAOIDAdd (CERT_OID_TYPE_ISSUER_POLICY,
                    0,
                    m_oidValue);
            if ( FAILED (hr) )
            {
                CString text;
                CString caption;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                text.FormatMessage (IDS_CANNOT_ADD_ISSUANCE_OID, GetSystemMessage (hr));

                MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                _TRACE (0, L"CAOIDAdd (%s) failed: 0x%x\n",
                        (PCWSTR) m_oidValue, hr);
                return;
            }
        }
        else
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
            return;
        }
    }

    HRESULT hr = S_OK;
    // If we're editing, don't save the value if it hasn't changed
    if ( (m_bEdit && m_originalOidFriendlyName != m_oidFriendlyName) || !m_bEdit )
        hr = CAOIDSetProperty (m_oidValue, CERT_OID_PROPERTY_DISPLAY_NAME,
                m_oidFriendlyName.IsEmpty () ? 0 : ((LPVOID) (LPCWSTR) m_oidFriendlyName));
    if ( SUCCEEDED (hr) )
    {
        if ( SUCCEEDED (hr) )
        {
            // Update the OID list
            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
            {
                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                if ( pPolicyOID && 
                        pPolicyOID->IsIssuanceOID () && 
                        m_oidValue == pPolicyOID->GetOIDW ())
                {
                    pPolicyOID->SetDisplayName (m_oidFriendlyName);
                }
            }
        }

        if ( (m_bEdit && m_originalCPSValue != m_CPSValue) || !m_bEdit )
            hr = CAOIDSetProperty (m_oidValue, CERT_OID_PROPERTY_CPS,
                    m_CPSValue.IsEmpty () ? 0 : ((LPVOID) (LPCWSTR) m_CPSValue));
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_CANNOT_WRITE_CPS, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK | MB_ICONWARNING);
            _TRACE (0, L"CAOIDSetProperty (%s, CERT_OID_PROPERTY_CPS, %s) failed: 0x%x\n",
                    (PCWSTR) m_oidValue, (PCWSTR) m_CPSValue, hr);
            return;
        }
    }
    else
    {
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        text.FormatMessage (IDS_CANNOT_WRITE_DISPLAY_NAME, GetSystemMessage (hr));

        MessageBox (text, caption, MB_OK | MB_ICONWARNING);
        _TRACE (0, L"CAOIDSetProperty (%s, CERT_OID_PROPERTY_DISPLAY_NAME, %s) failed: 0x%x\n",
                (PCWSTR) m_oidValue, (PCWSTR) m_oidFriendlyName, hr);
        return;
    }

    
	CHelpDialog::OnOK();
}

void CNewIssuanceOIDDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(-1, L"Entering CNewIssuanceOIDDlg::DoContextHelp\n");
    
	// Display context help for a control
	if ( !::WinHelp (
			hWndControl,
			GetContextHelpFile (),
			HELP_WM_HELP,
			(DWORD_PTR) g_aHelpIDs_IDD_NEW_ISSUANCE_OID) )
	{
		_TRACE(-1, L"WinHelp () failed: 0x%x\n", GetLastError ());        
	}
    _TRACE(-1, L"Leaving CNewIssuanceOIDDlg::DoContextHelp\n");
}

void CNewIssuanceOIDDlg::OnClickedURL( NMHDR * pNMHDR, LRESULT * pResult )
{
   ENLINK *pEnlink = reinterpret_cast< ENLINK * >( pNMHDR );

   if ( pEnlink->msg == WM_LBUTTONUP )
   {
       UpdateData (TRUE);
      CString strCPSText;
      CString strURL;


      // pEnlink->chrg.cpMin and pEnlink->chrg.cpMax delimit the URL string.
      strURL = m_CPSValue.Mid (pEnlink->chrg.cpMin, pEnlink->chrg.cpMax - pEnlink->chrg.cpMin);

      // Displaying the URL may take time, so show the hourglass cursor.
      CWaitCursor waitCursor;

      if ( ShellExecute( this->m_hWnd, _T("open"), strURL, NULL, NULL, SW_SHOWDEFAULT ) <= (HINSTANCE) 32 )
      {
          CThemeContextActivator activator;
         AfxMessageBox( IDS_BROWSER_ERROR );
      }
   }

   *pResult = 0;
}


void CNewIssuanceOIDDlg::OnChangeCpsEdit() 
{
	m_bDirty = true;
    EnableControls ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\newissuanceoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       NewIssuanceOIDDlg.h
//
//  Contents:   Definition of CNewIssuanceOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_NEWISSUANCEOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
#define AFX_NEWISSUANCEOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewIssuanceOIDDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewIssuanceOIDDlg dialog

class CNewIssuanceOIDDlg : public CHelpDialog
{
// Construction
public:
	CNewIssuanceOIDDlg(CWnd* pParent);   // standard constructor
    CNewIssuanceOIDDlg(CWnd* pParent, 
            const CString& szDisplayName,
            const CString& szOID,
            const CString& szCPS);
    virtual ~CNewIssuanceOIDDlg () {};

// Dialog Data
	//{{AFX_DATA(CNewIssuanceOIDDlg)
	enum { IDD = IDD_NEW_ISSUANCE_OID };
	CEdit	m_oidValueEdit;
	CRichEditCtrl	m_CPSEdit;
	CString	m_oidFriendlyName;
	CString	m_oidValue;
	CString	m_CPSValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewIssuanceOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls ();

	// Generated message map functions
	//{{AFX_MSG(CNewIssuanceOIDDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewOidName();
	afx_msg void OnChangeNewOidValue();
	virtual void OnCancel();
	virtual void OnOK();
    afx_msg void OnClickedURL (NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeCpsEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const CString m_originalCPSValue;
	const CString m_originalOidFriendlyName;
    CString     m_szOriginalOID;
    const bool  m_bEdit;
    bool        m_bDirty;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWISSUANCEOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\persist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       Persist.cpp
//
//  Contents:   Implementation of persistence
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "compdata.h"

USE_HANDLE_MACROS("CERTTMPL(persist.cpp)")


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

PCWSTR PchGetMachineNameOverride();	// Defined in chooser.cpp

/////////////////////////////////////////////////
//	The _dwMagicword is the internal version number.
//	Increment this number if you make a file format change.
#define _dwMagicword	10002


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertTmplComponentData::Load(IStream __RPC_FAR *pIStream)
{
	HRESULT hr = S_OK;;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		_TRACE(0, L"INFO: CCertTmplComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read domain name from stream
	DWORD dwLen = 0;
	hr = pIStream->Read (&dwLen, 4, NULL);
	if ( FAILED (hr) )
	{
		ASSERT (FALSE);
		return hr;
	}
	ASSERT (dwLen <= MAX_PATH * sizeof (WCHAR));
	PCWSTR wcszDomainName = (PCWSTR) alloca (dwLen);

	hr = pIStream->Read ((PVOID) wcszDomainName, dwLen, NULL);
	if ( FAILED (hr) )
	{
		ASSERT (FALSE);
		return hr;
	}

	m_szManagedDomain = wcszDomainName;

#endif
	return S_OK;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertTmplComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	HRESULT hr = S_OK;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	// Persist m_szManagedDomain length and m_szManagedDomain
	PCWSTR wcszDomainName = m_szManagedDomain;
	size_t dwLen = (::wcslen (wcszDomainName) + 1) * sizeof (WCHAR);
	ASSERT( 4 == sizeof(DWORD) );
	hr = pIStream->Write (&dwLen, 4, NULL);
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = pIStream->Write (wcszDomainName, (ULONG) dwLen, NULL);
	if ( FAILED (hr) )
	{
		ASSERT (FALSE);
		return hr;
	}

#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\securitypropertypage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998-2001
//
//  File:       SecurityPropertyPage.h
//
//--------------------------------------------------------------------------
#ifndef _CERTTMPL_SECURITYPROPERTYPAGE_H
#define _CERTTMPL_SECURITYPROPERTYPAGE_H

#include <aclui.h>
#include "CertTemplate.h"

HRESULT CreateCertTemplateSecurityInfo (
            CCertTemplate *pCertTemplate, 
            LPSECURITYINFO *ppObjSI);



















#endif // _CERTTMPL_SECURITYPROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\policyoid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyOID.cpp
//
//  Contents:   CPolicyOID
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "PolicyOID.h"

CPolicyOID::CPolicyOID (const CString& szOID, const CString& szDisplayName, ADS_INTEGER flags, bool bCanRename)
    : m_szOIDW (szOID),
    m_szDisplayName (szDisplayName),
    m_pszOIDA (0),
    m_flags (flags),
    m_bCanRename (bCanRename)
{
    int nLen = WideCharToMultiByte(
          CP_ACP,                   // code page
          0,                        // performance and mapping flags
          (PCWSTR) m_szOIDW,  // wide-character string
          (int) wcslen (m_szOIDW),  // number of chars in string
          0,                        // buffer for new string
          0,                        // size of buffer
          0,                    // default for unmappable chars
          0);                   // set when default char used
    if ( nLen > 0 )
    {
        m_pszOIDA = new CHAR[nLen+1];
        if ( m_pszOIDA )
        {
            ZeroMemory (m_pszOIDA, (nLen + 1) *sizeof(CHAR));
            nLen = WideCharToMultiByte(
                    CP_ACP,                 // code page
                    0,                      // performance and mapping flags
                    (PCWSTR) m_szOIDW, // wide-character string
                    (int) wcslen (m_szOIDW), // number of chars in string
                    m_pszOIDA,             // buffer for new string
                    nLen,                   // size of buffer
                    0,                      // default for unmappable chars
                    0);                     // set when default char used
            if ( !nLen )
            {
                _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                        (PCWSTR) m_szOIDW, GetLastError ());
            }
        }
    }
    else
    {
        _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                (PCWSTR) m_szOIDW, GetLastError ());
    }
}

CPolicyOID::~CPolicyOID ()
{
    if ( m_pszOIDA )
        delete [] m_pszOIDA;
}

bool CPolicyOID::IsIssuanceOID() const
{
    return (m_flags == CERT_OID_TYPE_ISSUER_POLICY) ? true : false;
}

bool CPolicyOID::IsApplicationOID() const
{
    return (m_flags == CERT_OID_TYPE_APPLICATION_POLICY) ? true : false;
}

void CPolicyOID::SetDisplayName(const CString &szDisplayName)
{
    m_szDisplayName = szDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\policyoid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyOID.h
//
//  Contents:   CPolicyOID
//
//----------------------------------------------------------------------------

#ifndef __POLICYOID_H_INCLUDED__
#define __POLICYOID_H_INCLUDED__

class CPolicyOID {
public:
	void SetDisplayName (const CString& szDisplayName);
	bool IsApplicationOID () const;
	bool IsIssuanceOID () const;
    CPolicyOID (const CString& szOID, const CString& szDisplayName, 
            ADS_INTEGER flags, bool bCanRename = true);
    virtual ~CPolicyOID ();

    CString GetOIDW () const
    {
        return m_szOIDW;
    }

    PCSTR GetOIDA () const
    {
        return m_pszOIDA;
    }

    CString GetDisplayName () const
    {
        return m_szDisplayName;
    }

    bool CanRename () const
    {
        return m_bCanRename;
    }

private:
	const ADS_INTEGER   m_flags;
    CString             m_szOIDW;
    CString             m_szDisplayName;
    PSTR                m_pszOIDA;
    const bool          m_bCanRename;
};

typedef CTypedPtrList<CPtrList, CPolicyOID*> POLICY_OID_LIST;

#endif // __POLICYOID_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\securitypropertypage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998-2001
//
//  File:       SecurityPropertyPage.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	casec.cpp
//
//	ISecurityInformation implementation for CA objects
//  and the new acl editor
//
//	PURPOSE

//
//
//  DYNALOADED LIBRARIES
//
//	HISTORY
//	5-Nov-1998		petesk		Copied template from privobsi.cpp sample.
//  6-Mar-2000      bryanwal    Modified to support cert templates
//
/////////////////////////////////////////////////////////////////////


#include <stdafx.h>
#include <accctrl.h>
//#include <certca.h>
#include <sddl.h>
#include "CertTemplate.h"

// Important, keep enroll GUID in sync with string define in certacl.h
const GUID GUID_ENROLL = { /* 0e10c968-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c968,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

const GUID GUID_AUTOENROLL = { /* a05b8cc2-17bc-4802-a710-e7c15ab866a2 */
    0xa05b8cc2,
    0x17bc,
    0x4802,
    {0xa7, 0x10, 0xe7, 0xc1, 0x5a, 0xb8, 0x66, 0xa2} };

//
// defined in Security.cpp 
//
// // define our generic mapping structure for our private objects // 


#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

#define ACTRL_CERTSRV_ENROLL       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    ACTRL_DS_CONTROL_ACCESS)

#define ACTRL_CERTSRV_MANAGE       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    READ_CONTROL | \
                                    DELETE | \
                                    WRITE_DAC | \
                                    WRITE_OWNER | \
                                    ACTRL_DS_CONTROL_ACCESS | \
                                    ACTRL_DS_CREATE_CHILD | \
                                    ACTRL_DS_DELETE_CHILD | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_SELF | \
                                    ACTRL_DS_DELETE_TREE | \
                                    ACTRL_DS_LIST_OBJECT)

#define ACTRL_CERTSRV_READ           ( READ_CONTROL | \
                                       ACTRL_DS_READ_PROP | \
                                       ACTRL_DS_LIST | \
                                       ACTRL_DS_LIST_OBJECT )
#define ACTRL_CERTSRV_WRITE         ( WRITE_DAC | \
                                        WRITE_OWNER | \
                                        ACTRL_DS_WRITE_PROP )

GENERIC_MAPPING ObjMap = 
{     
    ACTRL_CERTSRV_READ,
    DELETE | WRITE_DAC | WRITE_OWNER | ACTRL_DS_WRITE_PROP,     
    0, 
    ACTRL_CERTSRV_MANAGE 
}; 


//
// DESCRIPTION OF ACCESS FLAG AFFECTS
//
// SI_ACCESS_GENERAL shows up on general properties page
// SI_ACCESS_SPECIFIC shows up on advanced page 
// SI_ACCESS_CONTAINER shows on general page IF object is a container
//
SI_ACCESS g_siV1ObjAccesses[] =
{
  { &GUID_NULL, 
    ACTRL_CERTSRV_MANAGE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_MANAGE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_READ, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_READ), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_WRITE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_WRITE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_ENROLL, 
    ACTRL_CERTSRV_ENROLL, 
    MAKEINTRESOURCE(IDS_ACTRL_ENROLL), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC }
};

SI_ACCESS g_siV2ObjAccesses[] =
{
  { &GUID_NULL, 
    ACTRL_CERTSRV_MANAGE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_MANAGE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_READ, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_READ), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_WRITE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_WRITE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_ENROLL, 
    ACTRL_CERTSRV_ENROLL, 
    MAKEINTRESOURCE(IDS_ACTRL_ENROLL), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_AUTOENROLL,
    ACTRL_CERTSRV_ENROLL, 
    MAKEINTRESOURCE(IDS_ACTRL_AUTOENROLL), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC }
};


#define g_iObjDefAccess    1   // DS_GENERIC_READ

// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0,                                            MAKEINTRESOURCE(IDS_INH_NONE),
};


HRESULT
LocalAllocString(LPWSTR* ppResult, LPCWSTR pString)
{
    if (!ppResult || !pString)
        return E_INVALIDARG;

    *ppResult = (LPWSTR)LocalAlloc(LPTR, (lstrlen(pString) + 1) * sizeof(WCHAR));

    if (!*ppResult)
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;
}

void
LocalFreeString(LPWSTR* ppString)
{
    if (ppString)
    {
        if (*ppString)
            LocalFree(*ppString);
        *ppString = NULL;
    }   
}

class CCertTemplateSecurityObject : public ISecurityInformation
{
protected:
    ULONG                   m_cRef;
    CCertTemplate *         m_pCertTemplate;
    PSECURITY_DESCRIPTOR    m_pSD;

public:
    CCertTemplateSecurityObject() : m_cRef(1),
        m_pCertTemplate (0),
        m_pSD (0)
    { 
    }
    virtual ~CCertTemplateSecurityObject();

    STDMETHOD(Initialize)(CCertTemplate *pCertTemplate);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};

///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code that establishes
//  what the ACLUI interface is going to need to know.
//
//
///////////////////////////////////////////////////////////////////////////////


HRESULT CreateCertTemplateSecurityInfo (
                        CCertTemplate *pCertTemplate,
                        LPSECURITYINFO *ppObjSI)
{
    _TRACE (1, L"Entering CreateCertTemplateSecurityInfo\n");
    ASSERT (pCertTemplate && ppObjSI);
    if ( !pCertTemplate || !ppObjSI )
        return E_POINTER;

    HRESULT                     hr = S_OK;
    CCertTemplateSecurityObject *psi = new CCertTemplateSecurityObject;
    if ( psi)
    {
        *ppObjSI = NULL;

        hr = psi->Initialize (pCertTemplate);
        if ( SUCCEEDED (hr) )
            *ppObjSI = psi;
        else
            delete psi;
    }
    else 
        hr = E_OUTOFMEMORY;;


    _TRACE (-1, L"Leaving CreateCertTemplateSecurityInfo: 0x%x\n", hr);
    return hr;
}


CCertTemplateSecurityObject::~CCertTemplateSecurityObject()
{
    if ( m_pSD )
    {
        LocalFree (m_pSD);
    }
    if ( m_pCertTemplate )
        m_pCertTemplate->Release ();
}

STDMETHODIMP
CCertTemplateSecurityObject::Initialize(CCertTemplate *pCertTemplate)
{
    _TRACE (1, L"Entering CCertTemplateSecurityObject::Initialize\n");
    HRESULT hr = S_OK;

    if ( pCertTemplate )
    {
        m_pCertTemplate = pCertTemplate;
        m_pCertTemplate->AddRef ();

        hr = pCertTemplate->GetSecurity (&m_pSD);
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTemplateSecurityObject::Initialize: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CCertTemplateSecurityObject::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CCertTemplateSecurityObject::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CCertTemplateSecurityObject::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CCertTemplateSecurityObject::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    if ( pObjectInfo == NULL )
    {
        return E_POINTER;
    }
    if ( m_pCertTemplate == NULL )
    {
        return E_POINTER;
    }

    ZeroMemory(pObjectInfo, sizeof(SI_OBJECT_INFO));
    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT | SI_ADVANCED | SI_NO_ADDITIONAL_PERMISSION; 
    if ( m_pCertTemplate->ReadOnly () )
        pObjectInfo->dwFlags |= SI_READONLY;

    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    pObjectInfo->hInstance = AfxGetResourceHandle (); //AfxGetInstanceHandle ();

//    if(m_pCertTemplate->m_pParentMachine)
//    {
//        pObjectInfo->pszServerName = const_cast<WCHAR *>((LPCTSTR)m_pCertTemplate->m_pParentMachine->m_strMachineName);
//    }

    pObjectInfo->pszObjectName = const_cast<WCHAR *>((LPCTSTR)m_pCertTemplate->GetLDAPPath ());
    //pObjectInfo->pszPageTitle = NULL;	// already zeroed above
    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    _TRACE (1, L"Entering CCertTemplateSecurityObject::GetSecurity\n");
    HRESULT                     hr = S_OK;
    DWORD                       dwLength = 0;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD                       dwRevision = 0;

    *ppSD = NULL;

    if (fDefault)
        return E_NOTIMPL;

    //
    // Assume that required privileges have already been enabled
    //


    hr = S_OK;

    // find out out much to allocate
    if ( !GetPrivateObjectSecurity(m_pSD, si, NULL, 0, &dwLength) )
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        if ( hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) && dwLength )
        {
            hr = S_OK;
            // allocate and
            *ppSD = LocalAlloc(LPTR, dwLength);
            if (*ppSD )
            {
                // retrieve
                if ( GetPrivateObjectSecurity (m_pSD, si, *ppSD, dwLength, &dwLength) )
                {
                    if ( GetSecurityDescriptorControl(m_pSD, &Control, &dwRevision))
                    {
                        Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
                        SetSecurityDescriptorControl (*ppSD, 
                                SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                                Control);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32 (GetLastError ());
                        _TRACE (0, L"GetSecurityDescriptorControl failed: 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"GetPrivateObjectSecurity failed: 0x%x\n", hr);
                    hr = GetLastError();
                    LocalFree(*ppSD);
                    *ppSD = NULL;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else if ( FAILED (hr) )
        {
            _TRACE (0, L"GetPrivateObjectSecurity failed: 0x%x\n", hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
    }

    _TRACE (-1, L"Leaving CCertTemplateSecurityObject::GetSecurity: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP
CCertTemplateSecurityObject::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT                     hr = S_OK;
    HANDLE                      hClientToken = NULL;
    HANDLE                      hHandle = NULL;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD                       dwRevision = 0;


    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
    }
    else
    {
        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32 (GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }

    if ( SUCCEEDED (hr) )
    {
        //
        // Assume that required privileges have already been enabled
        //
        if ( SetPrivateObjectSecurityEx (si, pSD, &m_pSD, SEF_DACL_AUTO_INHERIT, &ObjMap, hClientToken) )
        {
            if ( si & DACL_SECURITY_INFORMATION )
            {
                if ( GetSecurityDescriptorControl (pSD, &Control, &dwRevision) )
                {
                    Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
                    SetSecurityDescriptorControl(m_pSD, 
                            SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                            Control);
                }
            }

            hr = m_pCertTemplate->SetSecurity (m_pSD);
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            _TRACE (0, L"SetPrivateObjectSecurityEx () failed: 0x%x\n", hr);
        }
    }


    if ( hClientToken )
    {
        CloseHandle (hClientToken);
    }
    if ( hHandle )
    {
        CloseHandle (hHandle);
    }

    return hr;
}

STDMETHODIMP
CCertTemplateSecurityObject::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    if ( !ppAccesses || !pcAccesses || !piDefaultAccess )
        return E_POINTER;

    if ( 1 == m_pCertTemplate->GetType () )
    {
        *ppAccesses = g_siV1ObjAccesses;
        *pcAccesses = sizeof(g_siV1ObjAccesses)/sizeof(g_siV1ObjAccesses[0]);
    }
    else
    {
        *ppAccesses = g_siV2ObjAccesses;
        *pcAccesses = sizeof(g_siV2ObjAccesses)/sizeof(g_siV2ObjAccesses[0]);
    }
    *piDefaultAccess = g_iObjDefAccess;

    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::PropertySheetPageCallback(HWND /*hwnd*/,
                                         UINT uMsg,
                                         SI_PAGE_TYPE /*uPage*/)
{
    if ( PSPCB_CREATE == uMsg )
        return E_NOTIMPL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\policydlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyDlg.cpp
//
//  Contents:   Implementation of CPolicyDlg
//
//----------------------------------------------------------------------------
// PolicyDlg.cpp : implementation file
//

#include "stdafx.h"
#include "PolicyDlg.h"
#include "SelectOIDDlg.h"
#include "NewApplicationOIDDlg.h"
#include "NewIssuanceOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPolicyDlg property page

CPolicyDlg::CPolicyDlg(CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension) 
 : CHelpDialog(CPolicyDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension),
    m_bIsEKU ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pCertExtension->pszObjId) ? true : false),
    m_bIsApplicationPolicy ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pCertExtension->pszObjId) ? true : false),
    m_bModified (false)
{
	//{{AFX_DATA_INIT(CPolicyDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPolicyDlg::~CPolicyDlg()
{
}

void CPolicyDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPolicyDlg)
	DDX_Control(pDX, IDC_POLICIES_LIST, m_policyList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPolicyDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CPolicyDlg)
	ON_WM_CANCELMODE()
	ON_BN_CLICKED(IDC_ADD_POLICY, OnAddPolicy)
	ON_BN_CLICKED(IDC_REMOVE_POLICY, OnRemovePolicy)
	ON_BN_CLICKED(IDC_POLICY_CRITICAL, OnPolicyCritical)
	ON_WM_DESTROY()
	ON_LBN_SELCHANGE(IDC_POLICIES_LIST, OnSelchangePoliciesList)
	ON_BN_CLICKED(IDC_EDIT_POLICY, OnEditPolicy)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPolicyDlg message handlers

BOOL CPolicyDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CPolicyDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	
    CString text;
	if ( m_bIsEKU )
    {
        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICIES_EXTENSION));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_EFFECTIVE_APPLICATION_POLICIES));

        int     nEKUIndex = 0;
        CString szEKU;
        while ( SUCCEEDED (m_rCertTemplate.GetEnhancedKeyUsage (nEKUIndex, szEKU)) )
        {
            int nLen = WideCharToMultiByte(
                  CP_ACP,                   // code page
                  0,                        // performance and mapping flags
                  (PCWSTR) szEKU,  // wide-character string
                  (int) wcslen (szEKU),  // number of chars in string
                  0,                        // buffer for new string
                  0,                        // size of buffer
                  0,                    // default for unmappable chars
                  0);                   // set when default char used
            if ( nLen > 0 )
            {
                nLen++; // account for Null terminator
                PSTR    pszAnsiBuf = new CHAR[nLen];
                if ( pszAnsiBuf )
                {
                    ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                    nLen = WideCharToMultiByte(
                            CP_ACP,                 // code page
                            0,                      // performance and mapping flags
                            (PCWSTR) szEKU, // wide-character string
                            (int) wcslen (szEKU), // number of chars in string
                            pszAnsiBuf,             // buffer for new string
                            nLen,                   // size of buffer
                            0,                      // default for unmappable chars
                            0);                     // set when default char used
                    if ( nLen )
                    {
                        CString szEKUName;
                        if ( MyGetOIDInfoA (szEKUName, pszAnsiBuf) )
                        {
                            int nIndex = m_policyList.AddString (szEKUName);
                            if ( nIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nIndex, pszAnsiBuf);
                            }
                        }
                    }
                }
            }
            nEKUIndex++;
        }
    }
    else if ( m_bIsApplicationPolicy )
    {
        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICIES_EXTENSION));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_EFFECTIVE_APPLICATION_POLICIES));

        int     nAppPolicyIndex = 0;
        CString szAppPolicy;
        while ( SUCCEEDED (m_rCertTemplate.GetApplicationPolicy (nAppPolicyIndex, szAppPolicy)) )
        {
            int nLen = WideCharToMultiByte(
                  CP_ACP,                   // code page
                  0,                        // performance and mapping flags
                  (PCWSTR) szAppPolicy,  // wide-character string
                  (int) wcslen (szAppPolicy),  // number of chars in string
                  0,                        // buffer for new string
                  0,                        // size of buffer
                  0,                    // default for unmappable chars
                  0);                   // set when default char used
            if ( nLen > 0 )
            {
                nLen++; // account for Null terminator
                PSTR    pszAnsiBuf = new CHAR[nLen];
                if ( pszAnsiBuf )
                {
                    ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                    nLen = WideCharToMultiByte(
                            CP_ACP,                 // code page
                            0,                      // performance and mapping flags
                            (PCWSTR) szAppPolicy, // wide-character string
                            (int) wcslen (szAppPolicy), // number of chars in string
                            pszAnsiBuf,             // buffer for new string
                            nLen,                   // size of buffer
                            0,                      // default for unmappable chars
                            0);                     // set when default char used
                    if ( nLen )
                    {
                        CString szAppPolicyName;
                        if ( MyGetOIDInfoA (szAppPolicyName, pszAnsiBuf) )
                        {
                            int nIndex = m_policyList.AddString (szAppPolicyName);
                            if ( nIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nIndex, pszAnsiBuf);
                            }
                        }
                    }
                }
            }
            nAppPolicyIndex++;
        }
    }
    else
    {
        VERIFY (text.LoadString (IDS_EDIT_ISSUANCE_POLICIES_EXTENSION));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_ISSUANCE_POLICIES_HINT));
        SetDlgItemText (IDC_POLICIES_HINT, text);
        VERIFY (text.LoadString (IDS_EFFECTIVE_ISSUANCE_POLICIES));

        int     nCertPolicyIndex = 0;
        CString szCertPolicy;
        while ( SUCCEEDED (m_rCertTemplate.GetCertPolicy (nCertPolicyIndex, szCertPolicy)) )
        {
            int nLen = WideCharToMultiByte(
                  CP_ACP,                   // code page
                  0,                        // performance and mapping flags
                  (PCWSTR) szCertPolicy,  // wide-character string
                  (int) wcslen (szCertPolicy),  // number of chars in string
                  0,                        // buffer for new string
                  0,                        // size of buffer
                  0,                    // default for unmappable chars
                  0);                   // set when default char used
            if ( nLen > 0 )
            {
                nLen++; // account for Null terminator
                PSTR    pszAnsiBuf = new CHAR[nLen];
                if ( pszAnsiBuf )
                {
                    ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                    nLen = WideCharToMultiByte(
                            CP_ACP,                 // code page
                            0,                      // performance and mapping flags
                            (PCWSTR) szCertPolicy, // wide-character string
                            (int) wcslen (szCertPolicy), // number of chars in string
                            pszAnsiBuf,             // buffer for new string
                            nLen,                   // size of buffer
                            0,                      // default for unmappable chars
                            0);                     // set when default char used
                    if ( nLen )
                    {
                        CString szPolicyName;
                        if ( MyGetOIDInfoA (szPolicyName, pszAnsiBuf) )
                        {
                            int nIndex = m_policyList.AddString (szPolicyName);
                            if ( nIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nIndex, pszAnsiBuf);
                            }
                        }
                    }
                }
            }
            nCertPolicyIndex++;
        }
    }
	SetDlgItemText (IDD_POLICIES_LABEL, text);

    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_POLICY_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDD_POLICIES_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_POLICIES_LIST)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_POLICY)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_POLICY)->EnableWindow (FALSE);
    }

    bool    bCritical = false;
    PWSTR   pszOID = 0;
    if ( m_bIsEKU )
        pszOID = TEXT (szOID_ENHANCED_KEY_USAGE);
    else if ( m_bIsApplicationPolicy )
        pszOID = TEXT (szOID_APPLICATION_CERT_POLICIES);
    else
        pszOID = TEXT (szOID_CERT_POLICIES);

    if ( SUCCEEDED (m_rCertTemplate.IsExtensionCritical (
            pszOID, 
            bCritical)) && bCritical )
    {
        SendDlgItemMessage (IDC_POLICY_CRITICAL, BM_SETCHECK, BST_CHECKED);
    }

    EnableControls ();

    _TRACE (-1, L"Leaving CPolicyDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPolicyDlg::OnCancelMode() 
{
	CHelpDialog::OnCancelMode();
	
    if ( m_pCertExtension->fCritical )
        SendDlgItemMessage (IDC_POLICY_CRITICAL, BM_SETCHECK, BST_CHECKED);
	
}

void CPolicyDlg::OnAddPolicy() 
{
    // Create the list of already added OIDs.  These will not be displayed
    // in the Select OID dialog.
	int		nCnt = m_policyList.GetCount ();
    PSTR*   paszUsedOIDs = 0;

	
    // allocate an array of PSTR pointers and add each item.
    // Set the last to NULL
    if ( nCnt )
    {
        paszUsedOIDs = new PSTR[nCnt+1];
        if ( paszUsedOIDs )
        {
            ::ZeroMemory (paszUsedOIDs, sizeof (PSTR) * (nCnt+1));
	        while (--nCnt >= 0)
	        {
                PSTR pszOID = (PSTR) m_policyList.GetItemData (nCnt);
                if ( pszOID )
                {
                    PSTR pNewStr = new CHAR[strlen (pszOID) + 1];
                    if ( pNewStr )
                    {
                        strcpy (pNewStr, pszOID);
                        paszUsedOIDs[nCnt] = pNewStr;
                    }
                    else
                        break;
                }
            }
        }
    }

	CSelectOIDDlg  dlg (this, m_pCertExtension, m_bIsEKU || m_bIsApplicationPolicy, 
            paszUsedOIDs);

    CThemeContextActivator activator;
    if ( IDOK == dlg.DoModal () )
    {
        if ( dlg.m_paszReturnedOIDs && dlg.m_paszReturnedFriendlyNames )
        {
            for (int nIndex = 0; !dlg.m_paszReturnedOIDs[nIndex].IsEmpty (); nIndex++)
            {
                int nLen = WideCharToMultiByte(
                      CP_ACP,                   // code page
                      0,                        // performance and mapping flags
                      (PCWSTR) dlg.m_paszReturnedOIDs[nIndex],  // wide-character string
                      (int) wcslen (dlg.m_paszReturnedOIDs[nIndex]),  // number of chars in string
                      0,                        // buffer for new string
                      0,                        // size of buffer
                      0,                    // default for unmappable chars
                      0);                   // set when default char used
                if ( nLen > 0 )
                {
                    nLen++; // account for Null terminator
                    PSTR    pszAnsiBuf = new CHAR[nLen];
                    if ( pszAnsiBuf )
                    {
                        ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                        nLen = WideCharToMultiByte(
                                CP_ACP,                 // code page
                                0,                      // performance and mapping flags
                                (PCWSTR) dlg.m_paszReturnedOIDs[nIndex], // wide-character string
                                (int) wcslen (dlg.m_paszReturnedOIDs[nIndex]), // number of chars in string
                                pszAnsiBuf,             // buffer for new string
                                nLen,                   // size of buffer
                                0,                      // default for unmappable chars
                                0);                     // set when default char used
                        if ( nLen )
                        {
                            int nAddedIndex = m_policyList.AddString (dlg.m_paszReturnedFriendlyNames[nIndex]);
                            if ( nAddedIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nAddedIndex, pszAnsiBuf);
                                m_policyList.SetSel (nAddedIndex, TRUE);
                                m_bModified = true;
                                EnableControls ();
                            }
                        }
                        else
                        {
                            _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                                    (PCWSTR) dlg.m_paszReturnedOIDs[nIndex], GetLastError ());
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                            (PCWSTR) dlg.m_paszReturnedOIDs[nIndex], GetLastError ());
                }
            }
        }
    }

    // clean up
    if ( paszUsedOIDs )
    {
        for (int nIndex = 0; paszUsedOIDs[nIndex]; nIndex++)
            delete [] paszUsedOIDs[nIndex];
        delete [] paszUsedOIDs;
    }
}

void CPolicyDlg::OnRemovePolicy() 
{
    int nSelCnt = m_policyList.GetSelCount ();
    if ( nSelCnt > 0 )
    {
        int* pnSelIndexes = new int[nSelCnt];
        if ( pnSelIndexes )
        {
            if ( LB_ERR != m_policyList.GetSelItems (nSelCnt, pnSelIndexes) )
            {
                for (int nIndex = nSelCnt - 1; nIndex >= 0; nIndex--)
                {
                    PSTR pszOID = (PSTR) m_policyList.GetItemDataPtr (pnSelIndexes[nIndex]);
                    if ( pszOID )
                        delete [] pszOID;
                    m_policyList.DeleteString (pnSelIndexes[nIndex]);
                }
                m_bModified = true;
            }
            delete [] pnSelIndexes;
        }
    }

    EnableControls ();
}

void CPolicyDlg::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_POLICY)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_POLICY)->EnableWindow (FALSE);
        GetDlgItem (IDC_POLICY_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_EDIT_POLICY)->EnableWindow (FALSE);
    }
    else
    {
        GetDlgItem (IDOK)->EnableWindow (m_bModified && !m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_REMOVE_POLICY)->EnableWindow (
                m_policyList.GetSelCount () > 0 && !m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_ADD_POLICY)->EnableWindow (!m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_POLICY_CRITICAL)->EnableWindow (!m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_EDIT_POLICY)->EnableWindow (
                m_policyList.GetSelCount () == 1 && !m_rCertTemplate.ReadOnly ());
    }
}

void CPolicyDlg::OnPolicyCritical() 
{
    m_bModified = true;
    EnableControls ();	
}

void CPolicyDlg::OnDestroy() 
{
	CHelpDialog::OnDestroy();
	
    int nCnt = m_policyList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        PSTR pszOID = (PSTR) m_policyList.GetItemDataPtr (nIndex);
        if ( pszOID )
            delete [] pszOID;
    }
}

void CPolicyDlg::OnSelchangePoliciesList() 
{
    EnableControls ();	
}

void CPolicyDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CPolicyDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDD_POLICIES_LABEL:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_POLICY) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CPolicyDlg::DoContextHelp\n");
}

void CPolicyDlg::OnEditPolicy() 
{
    int nSel = this->m_policyList.GetCurSel ();
    if ( nSel >= 0 )
    {
        CString szDisplayName;
        m_policyList.GetText (nSel, szDisplayName);
        PSTR pszOID = (PSTR) m_policyList.GetItemDataPtr (nSel);
        if ( pszOID )
        {
            CString newDisplayName;
            INT_PTR iRet = 0;
	        if ( m_bIsEKU || m_bIsApplicationPolicy)
            {
                CNewApplicationOIDDlg   dlg (this, szDisplayName, pszOID);

                CThemeContextActivator activator;
                iRet = dlg.DoModal ();
                if ( IDOK == iRet )
                    newDisplayName = dlg.m_oidFriendlyName;
            }
            else
            {
                PWSTR   pszCPS = 0;
                CString strOID = pszOID;
                HRESULT hr = CAOIDGetProperty(
                            strOID,
                            CERT_OID_PROPERTY_CPS,
                            &pszCPS);
                if ( SUCCEEDED (hr) || 
                        HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ||
                        HRESULT_FROM_WIN32 (ERROR_DS_OBJ_NOT_FOUND) == hr ||
                        HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER) == hr )
                {
                    CNewIssuanceOIDDlg   dlg (this, szDisplayName, pszOID, 
                            pszCPS);

                    CThemeContextActivator activator;
                    iRet = dlg.DoModal ();
                    if ( IDOK == iRet )
                        newDisplayName = dlg.m_oidFriendlyName;
                }
                else 
                {
                    DWORD   dwErr = HRESULT_CODE (hr);
                    if ( ERROR_INVALID_PARAMETER != dwErr )
                    {
                        CString text;
                        CString caption;
                        CThemeContextActivator activator;

                        VERIFY (caption.LoadString (IDS_CERTTMPL));
                        text.FormatMessage (IDS_CANNOT_READ_CPS, GetSystemMessage (hr));

                        MessageBox (text, caption, MB_OK);

                        _TRACE (0, L"CAOIDGetProperty (CERT_OID_PROPERTY_CPS) failed: 0x%x\n", hr);
                    }
                }
            }
            if ( IDOK == iRet )
            {
                if ( szDisplayName != newDisplayName )
                {
                    m_policyList.DeleteString (nSel);
                    int nIndex = m_policyList.AddString (newDisplayName);
                    if ( nIndex >= 0 )
                        m_policyList.SetItemDataPtr (nIndex, pszOID);
                }
            }
        }
    }
}

void CPolicyDlg::OnOK() 
{
    // Create the list of OIDs.
	int		nCnt = m_policyList.GetCount ();
    PWSTR*   paszEKUs = 0;

	
    // allocate an array of PSTR pointers and add each item.
    // Set the last to NULL
    if ( nCnt )
    {
        paszEKUs = new PWSTR[nCnt+1];
        if ( paszEKUs )
        {
            ::ZeroMemory (paszEKUs, sizeof (PWSTR) * (nCnt+1));
	        while (--nCnt >= 0)
	        {
                PSTR pszOID = (PSTR) m_policyList.GetItemData (nCnt);
                if ( pszOID )
                {
                    PWSTR   pNewStr = 0;
                    int     nLen = ::MultiByteToWideChar (CP_ACP, 0, pszOID, -1, NULL, 0);
		            ASSERT (nLen);
		            if ( nLen )
		            {
                        pNewStr = new WCHAR[nLen];
                        if ( pNewStr )
                        {
			                nLen = ::MultiByteToWideChar (CP_ACP, 0, pszOID, -1, 
					                pNewStr, nLen);
			                ASSERT (nLen);
                            if ( nLen )
                            {
                                paszEKUs[nCnt] = pNewStr;
                            }
                        }
		            }
                }
            }
        }
    }

    CThemeContextActivator activator;
    bool    bCritical = BST_CHECKED == SendDlgItemMessage (
                IDC_POLICY_CRITICAL, BM_GETCHECK);
    
    HRESULT hr = S_OK;
    if ( m_bIsEKU )
    {
        hr = m_rCertTemplate.SetEnhancedKeyUsage (paszEKUs, bCritical);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_CANNOT_SAVE_EKU_EXTENSION, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
        }
    }
    else if ( m_bIsApplicationPolicy )
    {
        hr = m_rCertTemplate.SetApplicationPolicy (paszEKUs, bCritical);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_CANNOT_SAVE_APPLICATION_POLICY_EXTENSION, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
        }
    }
    else
    {
        hr = m_rCertTemplate.SetCertPolicy (paszEKUs, bCritical);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_CANNOT_SAVE_CERT_POLICY_EXTENSION, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
        }
    }

    // clean up
    if ( paszEKUs )
    {
        for (int nIndex = 0; paszEKUs[nIndex]; nIndex++)
            delete [] paszEKUs[nIndex];
        delete [] paszEKUs;
    }

    if ( SUCCEEDED (hr) )
	    CHelpDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certtmpl.rc
//
#define IDS_CERTTMPL_DESC               101
#define IDD_BASIC_CONSTRAINTS           102
#define IDS_NOT_AVAILABLE               103
#define IDS_SNAPINABOUT_PROVIDER        104
#define IDS_SNAPINABOUT_VERSION         105
#define IDS_SNAPINABOUT_DESCRIPTION     106
#define IDS_CERTTMPL_REGISTRY           107
#define IDD_TEMPLATE_GENERAL            107
#define IDD_TEMPLATE_V1_REQUEST         108
#define IDS_SMALLFONTNAME               109
#define IDD_KEY_USAGE                   109
#define IDS_SMALLFONTSIZE               110
#define IDD_TEMPLATE_V1_SUBJECT_NAME    110
#define IDS_REGISTER_CERTTMPL           111
#define IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTTMPL 112
#define IDB_CERTTMPL_LARGE              114
#define IDB_CERTTMPL_SMALL              115
#define IDS_LARGEFONTNAME               117
#define IDS_LARGEFONTSIZE               118
#define IDS_CANNOT_SAVE_CERT_POLICY_EXTENSION 119
#define IDS_CERTTMPL                    120
#define IDS_CANNOT_DELETE_CERT_TEMPLATE 121
#define IDS_WINDOWS_2000_AND_LATER      122
#define IDS_CONFIRM_DELETE_CERT_TEMPLATE_MULTI 123
#define IDS_CONFIRM_DELETE_CERT_TEMPLATE 124
#define IDS_INH_NONE                    125
#define IDS_ACTRL_ENROLL                126
#define IDS_ACTRL_AUTOENROLL            127
#define IDS_ACTRL_CERTSRV_MANAGE        128
#define IDS_SNAPIN_NAME                 129
#define IDS_CERTTEMPLATESHELLEXT_DESC   130
#define IDS_EDIT                        131
#define IDS_EDIT_HINT                   132
#define IDS_ACTRL_CERTSRV_READ          133
#define IDS_CANNOT_READ_BASIC_CONSTRAINTS 134
#define IDS_WINDOWS_2002_AND_LATER      135
#define IDS_ADD_ISSUANCE_POLICY         136
#define IDS_ACTRL_CERTSRV_WRITE         137
#define IDS_BROWSER_ERROR               138
#define IDS_ISSUANCE_POLICIES_HINT      139
#define IDS_CANNOT_SAVE_EKU_EXTENSION   140
#define IDS_ISSUANCE_POLICY             141
#define IDS_APPLICATION_POLICY          142
#define IDS_APPLICATION_AND_ISSUANCE_POLICY 143
#define IDI_CERT_TEMPLATEV1             144
#define IDS_MUST_ADD_RA_ISSUANCE_POLICY 144
#define IDI_CERT_TEMPLATEV2             145
#define IDS_RENEWAL_MUST_BE_LESS_THAN_VALIDITY 145
#define IDS_OID_FORMAT_INVALID          146
#define IDS_OID_CONTAINS_NON_DIGITS     147
#define IDS_OID_CONTAINS_CONSECUTIVE_DOTS 148
#define IDD_EXTENDED_KEY_USAGE          149
#define IDS_OID_MUST_START_WITH_0_1_2   149
#define IDD_NEW_APPLICATION_OID         150
#define IDS_OID_0_1_MUST_BE_0_TO_39     150
#define IDD_SELECT_TEMPLATE             151
#define IDS_OID_MUST_HAVE_TWO_NUMBERS   151
#define IDD_POLICY                      152
#define IDS_OID_CANNOT_END_WITH_DOT     152
#define IDD_TEMPLATE_V2_SUBJECT_NAME    153
#define IDS_EDIT_ISSUANCE_POLICY        153
#define IDS_EDIT_APPLICATION_POLICY     154
#define IDD_TEMPLATE_V2_AUTHENTICATION  155
#define IDS_EXTENSION_NAME              155
#define IDD_CLONE_TEMPLATE              156
#define IDD_TEMPLATE_V2_SUPERCEDES      156
#define IDS_SUBJECT_IS_CA               156
#define IDD_TEMPLATE_EXTENSIONS         157
#define IDS_CRITICAL_EXTENSION          157
#define IDD_SELECT_OIDS                 158
#define IDS_ONLY_ISSUE_END_ENTITIES     158
#define IDD_ADD_APPROVAL                159
#define IDS_SIGNATURE_REQUIREMENTS      159
#define IDB_TEMPLATES                   160
#define IDS_CERTIFICATE_TEMPLATES       160
#define IDS_PROPERTIES_OF_TEMPLATE_X    161
#define IDD_NEW_ISSUANCE_OID            162
#define IDS_DIGITAL_SIGNATURE           162
#define IDD_TEMPLATE_V2_REQUEST         163
#define IDS_NON_REPUDIATION             163
#define IDS_CERTIFICATE_SIGNING         164
#define IDD_VIEW_OIDS                   164
#define IDS_CRL_SIGNING                 165
#define IDS_ALLOW_KEY_EXCHANGE_ONLY_WITH_KEY_ENCRYPTION 166
#define IDS_ALLOW_KEY_EXCHANGE_WITHOUT_KEY_ENCRYPTION 167
#define IDS_ALLOW_ENCRYPTION_OF_USER_DATA 168
#define IDS_MAJOR_VERSION_NUMBER        169
#define IDS_MINOR_VERSION_NUMBER        170
#define IDS_TEMPLATE_NAME               171
#define IDS_VIEW_OIDS                   172
#define IDS_VIEW_OIDS_HINT              173
#define IDS_POLICY_NAME                 174
#define IDS_OID                         175
#define IDS_POLICY_TYPE                 176
#define IDS_CPS_LOCATION                177
#define IDS_UNABLE_TO_CLONE_TEMPLATE    178
#define IDS_CANNOT_ENUM_CERT_TEMPLATES  179
#define IDS_APPLICATION                 180
#define IDS_ISSUANCE                    181
#define IDS_INSTALL_WINDOWS2002_CERT_TEMPLATES 182
#define IDS_INSTALL_FAILURE_WINDOWS2002_CERT_TEMPLATES 183
#define IDS_INSTALL_SUCCESS_WINDOWS2002_CERT_TEMPLATES 184
#define IDS_NONE                        185
#define IDS_CANNOT_LOAD_OID_LIST        186
#define IDS_FRIENDLY_NAME_ALREADY_USED  187
#define IDS_COLUMN_CERT_TEMPLATE_OBJECT 190
#define IDS_COLUMN_CERT_TEMPLATE_TYPE   193
#define IDC_VALIDITY_UNITS              252
#define IDC_VALIDITY_EDIT               254
#define IDC_RENEWAL_UNITS               255
#define IDC_RENEWAL_EDIT                256
#define IDC_TEMPLATE_VERSION            258
#define IDC_SIGNATURE                   260
#define IDC_CSP_LIST                    262
#define IDC_CHECK4                      264
#define IDC_EXPORT_PRIVATE_KEY          264
#define IDC_UPN                         264
#define IDC_EXTENSION_LIST              265
#define IDC_SHOW_DETAILS                267
#define IDC_BUTTON2                     268
#define IDC_REMOVE_ISSUANCE_POLICY      268
#define IDC_ADD_APPROVAL                268
#define IDC_BUTTON3                     269
#define IDC_REMOVE_APPLICATION_POLICY   269
#define IDC_REMOVE_POLICY               269
#define IDC_CHECK_DIGITAL_SIGNATURE     270
#define IDC_CHECK_NON_REPUDIATION       271
#define IDC_CHECK_KEY_ENCIPHERMENT      272
#define IDC_CHECK_DATA_ENCIPHERMENT     273
#define IDC_CHECK_KEY_AGREEMENT         274
#define IDC_CHECK_CERT_SIGNING          275
#define IDC_CHECK_ENCIPHERMENT_ONLY     276
#define IDC_CHECK8                      277
#define IDC_CHECK_DECIPHERMENT_ONLY     277
#define IDS_CANT_DISPLAY_SNAPIN_HELP_TOPIC 278
#define IDC_NEW_EKU                     278
#define IDC_EKU_LIST                    279
#define IDC_OID_LIST                    280
#define IDC_NEW_APPLICATION_OID_NAME    281
#define IDC_NEW_APPLICATION_OID_VALUE   282
#define IDC_TEMPLATE_NAME               283
#define IDC_DISPLAY_NAME                284
#define IDC_SUPERCEDES_LABEL            285
#define IDC_SUPERCEDED_TEMPLATES_LIST   286
#define IDC_ADD_SUPERCEDED_TEMPLATE     287
#define IDC_REMOVE_SUPERCEDED_TEMPLATE  288
#define IDC_MINIMUM_KEYSIZE_VALUE       289
#define IDC_MINIMUM_KEYSIZE_LABEL       291
#define IDC_ARCHIVE_KEY_CHECK           292
#define IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK 293
#define IDC_TEMPLATE_LIST               294
#define IDC_TEMPLATE_PROPERTIES         295
#define IDC_ONLY_ISSUE_END_ENTITIES     297
#define IDC_POLICIES_LIST               298
#define IDC_POLICY_OIDS_LIST            299
#define IDC_REQUIRE_SUBJECT             300
#define IDC_USE_ONLY_SUBJECT_ALT_NAME   301
#define IDC_SUBJECT_AND_SUBJECT_ALT_NAME 302
#define IDC_FULL_DN                     303
#define IDS_CERTTMPL_ROOT_NODE_NAME     304
#define IDC_COMMON_NAME                 304
#define IDC_EMAIL_NAME                  305
#define IDC_PUBLISH_TO_AD               306
#define IDB_EXTENSIONS                  308
#define IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA 311
#define IDC_SUBJECT_MUST_BE_MACHINE     312
#define IDC_SUBJECT_MUST_BE_USER        313
#define IDC_REQUIRE_SIGNATURE           315
#define IDS_CERT_TEMPLATE_COUNT         316
#define IDC_AUTHENTICATION_APPROVAL_LIST 316
#define IDC_ISSUANCE_POLICIES           316
#define IDC_NUM_SIG_REQUIRED_EDIT       317
#define IDS_CERT_TEMPLATE_COUNT_SINGLE  318
#define IDC_NUM_SIG_REQUIRED_SPIN       318
#define IDC_ADMIN_APPROVAL_REQUIRED     319
#define IDC_CLONE_TEMPLATE_NAME         320
#define IDC_CLONE_DISPLAY_NAME          321
#define IDS_PROPERTIES                  323
#define IDC_CERT_PURPOSE_GROUPBOX       323
#define IDS_DAYS                        324
#define IDC_BASIC_CONSTRAINTS_CRITICAL  324
#define IDS_WEEKS                       325
#define IDC_KEY_USAGE_CRITICAL          325
#define IDS_MONTHS                      326
#define IDC_POLICY_CRITICAL             326
#define IDS_YEARS                       327
#define IDC_ADD_ISSUANCE_POLICY         327
#define IDS_CLONE_TEMPLATE              328
#define IDC_ADD_APPLICATION_POLICY      328
#define IDC_ADD_POLICY                  328
#define IDS_CLONE_TEMPLATE_HINT         329
#define IDC_ISSUANCE_POLICIES_LABEL     329
#define IDS_ENTER_UNIQUE_DISPLAY_NAME   330
#define IDS_VALID_FOR_AUTOENROLLMENT    330
#define IDS_ENTER_UNIQUE_TEMPLATE_NAME  331
#define IDC_NEW_OID                     331
#define IDS_UNABLE_TO_SAVE_CERT_TEMPLATE_CHANGES 332
#define IDC_OID_TYPE                    332
#define IDS_CANNOT_CHANGE_DISPLAY_NAME  333
#define IDS_CANNOT_CHANGE_TEMPLATE_NAME 334
#define IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST 334
#define IDS_MUST_TYPE_TEMPLATE_DISPLAY_NAME 335
#define IDC_SUBJECT_NAME_BUILT_BY_CA    335
#define IDS_COPY_OF_TEMPLATE            336
#define IDC_SUBJECT_NAME_NAME_COMBO     336
#define IDS_COPY_X_OF_TEMPLATE          337
#define IDC_EMAIL_IN_SUB                337
#define IDS_CERTIFICATE_EXTENSION       338
#define IDC_EMAIL_IN_ALT                338
#define IDC_DNS_NAME                    339
#define IDS_INVALID_FOR_AUTOENROLLMENT  339
#define IDC_SPN                         340
#define IDS_COLUMN_CERT_TEMPLATE_AUTOENROLLMENT 340
#define IDC_SUBJECT_NAME_NAME_LABEL     341
#define IDS_REENROLL_ALL_CERTS          341
#define IDS_REENROLL_ALL_CERTS_HINT     342
#define IDS_ALL_APPLICATION_OIDS        343
#define IDC_ALLOW_REENROLLMENT          343
#define IDS_ALL_ISSUANCE_OIDS           344
#define IDD_POLICIES_LABEL              344
#define IDS_CANNOT_WRITE_MINKEYSIZE     345
#define IDC_PURPOSE_COMBO               346
#define IDS_SUBJECT_NAME_NONE           347
#define IDS_FULL_DN                     348
#define IDC_REMOVE_APPROVAL             348
#define IDC_APPROVAL_LIST               349
#define IDS_CN_ONLY                     350
#define IDC_SIGNATURE_OPTIONS           350
#define IDS_PROPERTIES_OF_NEW_TEMPLATE  351
#define IDC_CRL_SIGNING                 351
#define IDS_SIGNATURE                   352
#define IDC_ENCRYPTION_OPTIONS          352
#define IDS_ENCRYPTION                  353
#define IDC_BUTTON1                     353
#define IDC_EDIT_POLICY                 353
#define IDC_COPY_OID                    353
#define IDS_SIGNATURE_AND_ENCRYPTION    354
#define IDC_BUTTON4                     354
#define IDS_COLUMN_CERT_TEMPLATE_VERSION 355
#define IDS_AT_LEAST_1_NAME_OPTION_MUST_BE_CHECKED 356
#define IDS_CANNOT_WRITE_DISPLAY_NAME   357
#define IDS_CANNOT_WRITE_CPS            358
#define IDS_EFFECTIVE_APPLICATION_POLICIES 359
#define IDC_USE_AD_CERT_FOR_REENROLLMENT 359
#define IDS_EFFECTIVE_ISSUANCE_POLICIES 360
#define IDC_NEW_ISSUANCE_OID_NAME       360
#define IDC_NEW_ISSUANCE_OID_VALUE      361
#define IDS_CANNOT_DELETE_ISSUANCE_RA   361
#define IDC_CPS_EDIT                    362
#define IDC_TEMPLATE_NAME_LABEL         365
#define IDS_CANNOT_READ_CPS             365
#define IDS_OID_ALREADY_EXISTS          366
#define IDC_POLICIES_HINT               367
#define IDS_CANNOT_ADD_ISSUANCE_OID     367
#define IDC_PEND_ALL_REQUESTS           368
#define IDS_NO_EXTENSION_SELECTED       368
#define IDC_CHECK2                      369
#define IDS_CANNOT_SAVE_APPLICATION_POLICY_EXTENSION 369
#define IDC_POLICY_TYPES                370
#define IDS_V2_EXTENSIONS_HELP_HINT     370
#define IDC_APPLICATION_POLICIES        371
#define IDS_EDIT_APPLICATION_POLICIES_EXTENSION 371
#define IDS_EDIT_ISSUANCE_POLICIES_EXTENSION 372
#define IDS_EDIT_APPLICATION_POLICY_HINT 373
#define IDC_APP_POLICY_LABEL            374
#define IDS_ADD_ISSUANCE_POLICY_HINT    374
#define IDC_ISSUANCE_POLICY_LABEL       375
#define IDS_NEW_ISSUANCE_POLICY_HINT    375
#define IDC_EXTENSION_DESCRIPTION       376
#define IDS_SUPERSEDED_CERTIFICATE_TEMPLATES 376
#define IDS_SUBJECT_TYPE_DESCRIPTION    376
#define IDC_EXTENSION_NAME              377
#define IDS_COLUMN_CERT_TEMPLATE_SUPPORTED_CAS 377
#define IDS_TEMPLATE_OID                377
#define IDS_TEMPLATE_INTERNAL_NAME      378
#define IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT 379
#define IDS_CERT_POLICY_KNOWN_AS_ISSUANCE_POLICY 379
#define IDS_COLUMN_SUPPORTED_CAS        380
#define IDC_DELETE_PERMANENTLY          381
#define IDS_DAY                         381
#define IDS_WEEK                        382
#define IDR_WHATS_THIS_CONTEXT_MENU1    383
#define IDS_MONTH                       383
#define IDC_CANT_CHANGE_TEMPLATE_NAME   384
#define IDS_YEAR                        384
#define IDC_NUM_SIG_REQUIRED_CHECK      385
#define IDS_MUST_HAVE_DOMAIN_ADMIN_RIGHTS_TO_INSTALL_CERT_TEMPLATES 385
#define IDC_RADIO1                      386
#define IDC_REENROLLMENT_SAME_AS_ENROLLMENT 386
#define IDS_2_DAY_SMALLEST_VALIDITY     386
#define IDC_RADIO2                      387
#define IDC_REENROLLMENT_REQUIRES_VALID_CERT 387
#define IDS_TEMPLATE_NAME_CONTAINS_INVALID_CHARS 387
#define IDC_POLICY_TYPES_LABEL          388
#define IDS_ROOTNODE_STATUSBAR_TEXT     388
#define IDC_EXTENSIONS_HELP_HINT        390
#define IDC_NEW_APPLICATION_OID_HINT    391
#define IDC_ADD_POLICY_HINT             392
#define IDC_NEW_ISSUANCE_POLICY_HINT    393
#define IDC_DISPLAY_NAME_LABEL          394
#define IDM_WHATS_THIS                  430

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         121
#define _APS_NEXT_CONTROL_VALUE         395
#define _APS_NEXT_SYMED_VALUE           121
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\policydlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyDlg.h
//
//  Contents:   Definition of CPolicyDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_POLICYDLG_H__824C478F_445C_44A8_8FC1_67A91BED283F__INCLUDED_)
#define AFX_POLICYDLG_H__824C478F_445C_44A8_8FC1_67A91BED283F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PolicyDlg.h : header file
//
#include "CertTemplate.h"
#include "PolicyOID.h"

/////////////////////////////////////////////////////////////////////////////
// CPolicyDlg dialog

class CPolicyDlg : public CHelpDialog
{
// Construction
public:
	CPolicyDlg(CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension);
	~CPolicyDlg();

// Dialog Data
	//{{AFX_DATA(CPolicyDlg)
	enum { IDD = IDD_POLICY };
	CListBox	m_policyList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPolicyDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls();
	// Generated message map functions
	//{{AFX_MSG(CPolicyDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnCancelMode();
	afx_msg void OnAddPolicy();
	afx_msg void OnRemovePolicy();
	afx_msg void OnPolicyCritical();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangePoliciesList();
	afx_msg void OnEditPolicy();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    bool m_bModified;
	const bool m_bIsEKU;
    const bool m_bIsApplicationPolicy;
    CCertTemplate&      m_rCertTemplate;
    PCERT_EXTENSION     m_pCertExtension;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_POLICYDLG_H__824C478F_445C_44A8_8FC1_67A91BED283F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\selectoiddlg.cpp ===
// SelectOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "SelectOIDDlg.h"
#include "NewApplicationOIDDlg.h"
#include "NewIssuanceOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectOIDDlg dialog

extern POLICY_OID_LIST	    g_policyOIDList;

CSelectOIDDlg::CSelectOIDDlg(CWnd* pParent, PCERT_EXTENSION pCertExtension, 
        const bool bIsEKU,
        const PSTR* paszUsedOIDs)
	: CHelpDialog(CSelectOIDDlg::IDD, pParent),
    m_pCertExtension (pCertExtension),
    m_bIsEKU (bIsEKU),
    m_paszUsedOIDs (paszUsedOIDs),
    m_paszReturnedOIDs (0),
    m_paszReturnedFriendlyNames (0)
{
	//{{AFX_DATA_INIT(CSelectOIDDlg)
	//}}AFX_DATA_INIT
}

CSelectOIDDlg::~CSelectOIDDlg()
{
    if ( m_paszReturnedOIDs )
        delete [] m_paszReturnedOIDs;

    if ( m_paszReturnedFriendlyNames )
        delete [] m_paszReturnedFriendlyNames;
}


void CSelectOIDDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectOIDDlg)
	DDX_Control(pDX, IDC_OID_LIST, m_oidList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectOIDDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CSelectOIDDlg)
	ON_BN_CLICKED(IDC_NEW_OID, OnNewOid)
	ON_LBN_SELCHANGE(IDC_OID_LIST, OnSelchangeOidList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectOIDDlg message handlers

void CSelectOIDDlg::OnNewOid() 
{
    INT_PTR iRet = 0;
    CString szFriendlyName;
    CString szOID;

    if ( m_bIsEKU )
    {
    	CNewApplicationOIDDlg  dlg (this);

        CThemeContextActivator activator;
        iRet = dlg.DoModal ();
        if (IDOK == iRet )
        {
            szFriendlyName = dlg.m_oidFriendlyName;
            szOID = dlg.m_oidValue;
        }
    }
    else
    {
    	CNewIssuanceOIDDlg  dlg (this);

        CThemeContextActivator activator;
        iRet = dlg.DoModal ();
        if (IDOK == iRet )
        {
            szFriendlyName = dlg.m_oidFriendlyName;
            szOID = dlg.m_oidValue;
        }
    }
    if ( IDOK == iRet )
    {
        CPolicyOID* pPolicyOID = new CPolicyOID (szOID, szFriendlyName,
            m_bIsEKU ? CERT_OID_TYPE_APPLICATION_POLICY : CERT_OID_TYPE_ISSUER_POLICY);
        if ( pPolicyOID )
        {
            g_policyOIDList.AddTail (pPolicyOID);
            int nIndex = m_oidList.AddString (szFriendlyName);
            if ( nIndex >= 0 )
            {
                m_oidList.SetItemData (nIndex, (DWORD_PTR) new CString (szOID));
                VERIFY (LB_ERR != m_oidList.SetSel (nIndex, TRUE));
                EnableControls ();
            }
        }
    }
}

BOOL CSelectOIDDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	
    CString text;

    if ( m_bIsEKU )
        VERIFY (text.LoadString (IDS_ALL_APPLICATION_OIDS));
    else
    {
        VERIFY (text.LoadString (IDS_ADD_ISSUANCE_POLICY));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_ADD_ISSUANCE_POLICY_HINT));
        SetDlgItemText (IDC_ADD_POLICY_HINT, text);

        VERIFY (text.LoadString (IDS_ALL_ISSUANCE_OIDS));
    }

    SetDlgItemText (IDC_OID_TYPE, text);

    

    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            // If this is the Application OID dialog, show only application 
            // OIDS, otherwise if this is the Issuance OID dialog, show only
            // issuance OIDs
            if ( (m_bIsEKU && pPolicyOID->IsApplicationOID ()) ||
                 (!m_bIsEKU && pPolicyOID->IsIssuanceOID ()) )
            {
                bool bFound = false;

                // Don't display an OID that's already been used
                if ( m_paszUsedOIDs )
                {
                    for (int nIndex = 0; m_paszUsedOIDs[nIndex]; nIndex++)
                    {
                        if ( !strcmp (pPolicyOID->GetOIDA (), m_paszUsedOIDs[nIndex]) )
                        {
                            bFound = true;
                            break;
                        }
                    }
                }

                if ( !bFound )
                {
                    int nIndex = m_oidList.AddString (pPolicyOID->GetDisplayName ());
                    if ( nIndex >= 0 )
                    {
                        m_oidList.SetItemData (nIndex, 
                                (DWORD_PTR) new CString (pPolicyOID->GetOIDW ()));
                    }
                }
            }
        }
    }

    EnableControls ();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectOIDDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CSelectOIDDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_OID_TYPE:
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_SELECT_OIDS) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CSelectOIDDlg::DoContextHelp\n");
}


void CSelectOIDDlg::OnOK() 
{
	UpdateData (TRUE);
	
    int nSelCnt = m_oidList.GetSelCount ();
    if ( nSelCnt > 0 )
    {
        int* pnSelItems = new int[nSelCnt];
        if ( pnSelItems )
        {
            if ( LB_ERR != m_oidList.GetSelItems (nSelCnt, pnSelItems) )
            {
                m_paszReturnedOIDs = new CString[nSelCnt+1];
                if ( m_paszReturnedOIDs )
                {
                    m_paszReturnedFriendlyNames = new CString[nSelCnt+1];
                    if ( m_paszReturnedFriendlyNames )
                    {
	                    for (int nIndex = 0; nIndex < nSelCnt; nIndex++)
	                    {
                            m_paszReturnedOIDs[nIndex] = *(CString*) m_oidList.GetItemData (pnSelItems[nIndex]);
                            m_oidList.GetText (pnSelItems[nIndex], m_paszReturnedFriendlyNames[nIndex]);
                        }
                    }
                }
            }
            delete [] pnSelItems;
        }
    }

	CHelpDialog::OnOK();
}

void CSelectOIDDlg::EnableControls ()
{
    int nSel = m_oidList.GetSelCount ();
    GetDlgItem (IDOK)->EnableWindow (nSel >= 0);
}

void CSelectOIDDlg::OnSelchangeOidList() 
{
    EnableControls ();	
}

void CSelectOIDDlg::OnDestroy() 
{
	CHelpDialog::OnDestroy();
	
    int nCnt = m_oidList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        CString* pszOID = (CString*) m_oidList.GetItemData (nIndex);
        if ( pszOID )
            delete pszOID;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\selectoiddlg.h ===
#if !defined(AFX_SELECTOIDDLG_H__519FA306_5A24_4A7D_B37C_7D1715742911__INCLUDED_)
#define AFX_SELECTOIDDLG_H__519FA306_5A24_4A7D_B37C_7D1715742911__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SelectOIDDlg.h : header file
//
#include "PolicyOID.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectOIDDlg dialog

class CSelectOIDDlg : public CHelpDialog
{
// Construction
public:
	~CSelectOIDDlg();
	CSelectOIDDlg(CWnd* pParent, PCERT_EXTENSION pCertExtension, 
            const bool bIsEKU,
            const PSTR* paszUsedOIDs);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectOIDDlg)
	enum { IDD = IDD_SELECT_OIDS };
	CListBox	m_oidList;
	//}}AFX_DATA
    CString*            m_paszReturnedOIDs;
    CString*            m_paszReturnedFriendlyNames;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void EnableControls ();
	virtual void DoContextHelp (HWND hWndControl);

	// Generated message map functions
	//{{AFX_MSG(CSelectOIDDlg)
	afx_msg void OnNewOid();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelchangeOidList();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const bool          m_bIsEKU;
    PCERT_EXTENSION     m_pCertExtension;
    const PSTR*         m_paszUsedOIDs;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTOIDDLG_H__519FA306_5A24_4A7D_B37C_7D1715742911__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\selecttemplatedlg.cpp ===
// SelectTemplateDlg.cpp : implementation file
//

#include "stdafx.h"
#include "CompData.h"
#include "SelectTemplateDlg.h"
#include "CertTemplate.h"
#include "TemplateGeneralPropertyPage.h"
#include "TemplateV1RequestPropertyPage.h"
#include "TemplateV2RequestPropertyPage.h"
#include "TemplateV1SubjectNamePropertyPage.h"
#include "TemplateV2SubjectNamePropertyPage.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "TemplateExtensionsPropertyPage.h"
#include "PolicyOID.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectTemplateDlg dialog


CSelectTemplateDlg::CSelectTemplateDlg(CWnd* pParent, 
        const CCertTmplComponentData* pCompData,
        const CStringList& supercededNameList)
	: CHelpDialog(CSelectTemplateDlg::IDD, pParent),
    m_supercededTemplateNameList (supercededNameList),
    m_pCompData (pCompData)
{
	//{{AFX_DATA_INIT(CSelectTemplateDlg)
	//}}AFX_DATA_INIT
}


void CSelectTemplateDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectTemplateDlg)
	DDX_Control(pDX, IDC_TEMPLATE_LIST, m_templateList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectTemplateDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CSelectTemplateDlg)
	ON_BN_CLICKED(IDC_TEMPLATE_PROPERTIES, OnTemplateProperties)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_TEMPLATE_LIST, OnItemchangedTemplateList)
	ON_NOTIFY(NM_DBLCLK, IDC_TEMPLATE_LIST, OnDblclkTemplateList)
	ON_NOTIFY(LVN_DELETEITEM, IDC_TEMPLATE_LIST, OnDeleteitemTemplateList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectTemplateDlg message handlers
BOOL CSelectTemplateDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CSelectTemplateDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
    CWaitCursor cursor;
	
    // Set up list controls
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_TEMPLATES, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_TEMPLATES, 16, 0, cr));
    m_templateList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_templateList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

	int	colWidths[NUM_COLS] = {200, 200};

	// Add "Certificate Extension" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_CERTIFICATE_TEMPLATES));
	VERIFY (m_templateList.InsertColumn (COL_CERT_TEMPLATE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_TEMPLATE], COL_CERT_TEMPLATE) != -1);

	VERIFY (szText.LoadString (IDS_COLUMN_SUPPORTED_CAS));
	VERIFY (m_templateList.InsertColumn (COL_CERT_VERSION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_VERSION], COL_CERT_VERSION) != -1);

    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        POSITION    pos = m_pCompData->m_globalTemplateNameList.GetHeadPosition ();
        CString     szTemplateName;

	    for (; pos; )
	    {
	        szTemplateName = m_pCompData->m_globalTemplateNameList.GetNext (pos);

            // #NTRAID 363879 Certtmpl: Certificate Template Snapin must not 
            // allow the Subordinate CA template to be Superceded
            if ( wszCERTTYPE_SUBORDINATE_CA == szTemplateName )
                continue;

            // Only add those templates which are not already superceded
            if ( !m_supercededTemplateNameList.Find (szTemplateName) )
            {
                HCERTTYPE   hCertType = 0;
                HRESULT     hr = CAFindCertTypeByName (szTemplateName,
                        NULL,
                        CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                        &hCertType);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    PWSTR* rgwszProp = 0;

                    hr = CAGetCertTypePropertyEx (hCertType, 
                        CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
                    if ( SUCCEEDED (hr) )
                    {
                        DWORD   dwVersion = 0;
                        hr = CAGetCertTypePropertyEx (hCertType,
                                CERTTYPE_PROP_SCHEMA_VERSION,
                                &dwVersion);
                        if ( SUCCEEDED (hr) )
                        {
	                        LV_ITEM	lvItem;
	                        int		iItem = m_templateList.GetItemCount ();
	                        int iResult = 0;

	                        ::ZeroMemory (&lvItem, sizeof (lvItem));
	                        lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	                        lvItem.iItem = iItem;
                            lvItem.iSubItem = COL_CERT_TEMPLATE;
	                        lvItem.pszText = rgwszProp[0];
                            if ( 1 == dwVersion )
                                lvItem.iImage = 0;  // version is 1
                            else
                                lvItem.iImage = 1;  // version is 2
                            lvItem.lParam = (LPARAM) new CString (szTemplateName);
	                        iItem = m_templateList.InsertItem (&lvItem);
	                        ASSERT (-1 != iItem);
	                        if ( -1 == iItem )
		                        break;
                            else
                            {
	                            ::ZeroMemory (&lvItem, sizeof (lvItem));
	                            lvItem.mask = LVIF_TEXT;
	                            lvItem.iItem = iItem;
                                lvItem.iSubItem = COL_CERT_VERSION;
                                CString text;
                                if ( 1 == dwVersion )
                                    VERIFY (text.LoadString (IDS_WINDOWS_2000_AND_LATER));
                                else
                                    VERIFY (text.LoadString (IDS_WINDOWS_2002_AND_LATER));
                                lvItem.pszText = (PWSTR)(PCWSTR) text;
	                            iResult = m_templateList.SetItem (&lvItem);
	                            ASSERT (-1 != iResult);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
                        }

                        CAFreeCertTypeProperty (hCertType, rgwszProp);
                    }
                    else
                    {
                        _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
                    }

                    hr = CACloseCertType (hCertType);
                    _ASSERT (SUCCEEDED (hr));
                    if ( !SUCCEEDED (hr) )
                    {
                        _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", 
                            (PCWSTR) szTemplateName, hr);
                }
            }
        }	
    }

    EnableControls ();

    _TRACE (-1, L"Leaving CSelectTemplateDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectTemplateDlg::OnTemplateProperties() 
{
    int     nSelCnt = m_templateList.GetSelectedCount ();
    int     nSelItem = GetSelectedListItem ();

    if ( 1 == nSelCnt )
    {
        CString szFriendlyName = m_templateList.GetItemText (nSelItem, 
                COL_CERT_TEMPLATE);
        CString* pszTemplateName = (CString*) m_templateList.GetItemData (nSelItem); 
        HCERTTYPE   hCertType = 0;
        HRESULT     hr = CAFindCertTypeByName (*pszTemplateName,
                NULL,
                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                &hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            CCertTemplate   certTemplate (szFriendlyName, *pszTemplateName, 
                    L"", true, m_pCompData->m_fUseCache);
            CString         title;

            title.FormatMessage (IDS_PROPERTIES_OF_TEMPLATE_X, szFriendlyName);
            CTemplatePropertySheet  propSheet (title, certTemplate, this);


            if ( 1 == certTemplate.GetType () )
            {
                CTemplateGeneralPropertyPage* pGeneralPage = 
                        new CTemplateGeneralPropertyPage (certTemplate, 
                                m_pCompData);
                if ( pGeneralPage )
                {
                    // Add General page
                    propSheet.AddPage (pGeneralPage);

                    // Add Request and Subject Name page only if subject is not a CA
                    if ( !certTemplate.SubjectIsCA () )
                    {
                        propSheet.AddPage (new CTemplateV1RequestPropertyPage (
                                certTemplate));
                        propSheet.AddPage (new CTemplateV1SubjectNamePropertyPage (
                                certTemplate));
                    }

                    // Add extensions page
                    propSheet.AddPage (new CTemplateExtensionsPropertyPage (
                            certTemplate, pGeneralPage->m_bIsDirty));
                }
            }
            else    // version is 2
            {
                CTemplateGeneralPropertyPage* pGeneralPage = 
                        new CTemplateGeneralPropertyPage (certTemplate,
                                m_pCompData);
                if ( pGeneralPage )
                {
                    propSheet.AddPage (pGeneralPage);

                    // Add Request and Subject pages if subject is not a CA
                    if ( !certTemplate.SubjectIsCA () )
                    {
                        propSheet.AddPage (new CTemplateV2RequestPropertyPage (
                                certTemplate, pGeneralPage->m_bIsDirty));
                        propSheet.AddPage (new CTemplateV2SubjectNamePropertyPage (
                                certTemplate, pGeneralPage->m_bIsDirty));
                    }
                    propSheet.AddPage (new CTemplateV2AuthenticationPropertyPage ( 
                            certTemplate, pGeneralPage->m_bIsDirty));
                    propSheet.AddPage (new CTemplateV2SupercedesPropertyPage (
                            certTemplate, 
                            pGeneralPage->m_bIsDirty, 
                            m_pCompData));
                    propSheet.AddPage (new CTemplateExtensionsPropertyPage (
                            certTemplate, pGeneralPage->m_bIsDirty));
                }
            }

            CThemeContextActivator activator;
            propSheet.DoModal ();

            hr = CACloseCertType (hCertType);
            _ASSERT (SUCCEEDED (hr));
            if ( !SUCCEEDED (hr) )
            {
                _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", 
                    (PCWSTR) pszTemplateName, hr);
        }
    }
}


void CSelectTemplateDlg::OnOK() 
{
	int		nCnt = m_templateList.GetItemCount ();
	ASSERT (nCnt >= 1);
	UINT	flag = 0;
	while (--nCnt >= 0)
	{
		flag = ListView_GetItemState (m_templateList.m_hWnd, nCnt, LVIS_SELECTED);
		if ( flag & LVNI_SELECTED )
		{
            CString* pszTemplateName = (CString*) m_templateList.GetItemData (nCnt);
            if ( pszTemplateName )
                m_returnedTemplates.AddTail (*pszTemplateName);
        }
    }
	
	CHelpDialog::OnOK();
}

void CSelectTemplateDlg::EnableControls()
{
    int nSelCnt = m_templateList.GetSelectedCount ();

    GetDlgItem (IDC_TEMPLATE_PROPERTIES)->EnableWindow (1 == nSelCnt);
    GetDlgItem (IDOK)->EnableWindow (nSelCnt > 0);
}

void CSelectTemplateDlg::OnItemchangedTemplateList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
    EnableControls ();
	
	*pResult = 0;
}

int CSelectTemplateDlg::GetSelectedListItem()
{
    int nSelItem = -1;

	if ( m_templateList.m_hWnd && m_templateList.GetSelectedCount () > 0 )
	{
		int		nCnt = m_templateList.GetItemCount ();
		ASSERT (nCnt >= 1);
		UINT	flag = 0;
		while (--nCnt >= 0)
		{
			flag = ListView_GetItemState (m_templateList.m_hWnd, nCnt, LVIS_SELECTED);
			if ( flag & LVNI_SELECTED )
			{
                nSelItem = nCnt;
                break;
            }
        }
    }

    return nSelItem;
}


void CSelectTemplateDlg::OnDblclkTemplateList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	OnTemplateProperties ();
	
	*pResult = 0;
}

void CSelectTemplateDlg::OnDeleteitemTemplateList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    CString* pszTemplateName = (CString*) m_templateList.GetItemData (pNMListView->iItem);
    if ( pszTemplateName )
        delete pszTemplateName;
	
	*pResult = 0;
}

void CSelectTemplateDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CSelectTemplateDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_SELECT_TEMPLATE) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CSelectTemplateDlg::DoContextHelp\n");
}

void CSelectTemplateDlg::OnDestroy() 
{
	CHelpDialog::OnDestroy();
	
    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\selecttemplatedlg.h ===
#if !defined(AFX_SELECTTEMPLATEDLG_H__3974984C_4767_407B_ADE4_0017F635E553__INCLUDED_)
#define AFX_SELECTTEMPLATEDLG_H__3974984C_4767_407B_ADE4_0017F635E553__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SelectTemplateDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectTemplateDlg dialog

class CSelectTemplateDlg : public CHelpDialog
{
// Construction
public:
	CStringList m_returnedTemplates;
	CSelectTemplateDlg(CWnd* pParent, 
            const CCertTmplComponentData* pCompData,
            const CStringList& supercededNameList);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectTemplateDlg)
	enum { IDD = IDD_SELECT_TEMPLATE };
	CListCtrl	m_templateList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectTemplateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
    int GetSelectedListItem();
	void EnableControls();

	// Generated message map functions
	//{{AFX_MSG(CSelectTemplateDlg)
	afx_msg void OnTemplateProperties();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnItemchangedTemplateList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkTemplateList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitemTemplateList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    const CStringList& m_supercededTemplateNameList;
    WTL::CImageList m_imageListSmall;
	WTL::CImageList m_imageListNormal;
    const CCertTmplComponentData* m_pCompData;

	enum {
		COL_CERT_TEMPLATE = 0,
        COL_CERT_VERSION, 
		NUM_COLS	// must be last
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTTEMPLATEDLG_H__3974984C_4767_407B_ADE4_0017F635E553__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\shellext.h ===
/*++

Copyright (C) Microsoft Corporation, 1998-2001

Module Name:

    ShellExt.h

Abstract:
    This is the header for the Cert Type shell extension object.

Author:

    petesk 27-aug-98

Environment:
	
	 NT only.
--*/


#ifndef __CTSHLEXT_H_
#define __CTSHLEXT_H_


#include <shlobj.h>
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CDfsShell
class ATL_NO_VTABLE CCertTemplateShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCertTemplateShellExt, &CLSID_CertTemplateShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public IContextMenu
{
public:
	CCertTemplateShellExt();
	virtual ~CCertTemplateShellExt();

    //Simple ALL 1.0 based registry entry
    DECLARE_REGISTRY(   CCertTemplateShellExt,
                        _T("CERTTMPL.CCertTemplateShellExt.1"),
                        _T("CERTTMPL.CCertTemplateShellExt"),
                        IDS_CERTTEMPLATESHELLEXT_DESC,
                        THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CCertTemplateShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

// IDfsShell
public:


// IShellExtInit Methods

	STDMETHOD (Initialize)
	(
		IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
		IN LPDATAOBJECT	lpdobj,			// Points to an IDataObject interface
		IN HKEY			hkeyProgID		// Registry key for the file object or folder type
	);	

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages
	(
		IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
		IN LPARAM lParam
	);
    
    STDMETHODIMP ReplacePage
	(
		IN UINT uPageID, 
		IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
		IN LPARAM lParam
	);

    // IContextMenu methods
    STDMETHODIMP GetCommandString
    (    
        UINT_PTR idCmd,    
        UINT uFlags,    
        UINT *pwReserved,
        LPSTR pszName,    
        UINT cchMax   
    );

    STDMETHODIMP InvokeCommand
    (    
        LPCMINVOKECOMMANDINFO lpici   
    );	



    STDMETHODIMP QueryContextMenu
    (
        HMENU hmenu,
        UINT indexMenu,
        UINT idCmdFirst,
        UINT idCmdLast,
        UINT uFlags
    );

protected:
    HRESULT AddVersion1CertTemplatePropPages (
            CCertTemplate* pCertTemplate, 
            LPFNADDPROPSHEETPAGE lpfnAddPage, 
            LPARAM lParam);
    HRESULT AddVersion2CertTemplatePropPages (
            CCertTemplate* pCertTemplate, 
            LPFNADDPROPSHEETPAGE lpfnAddPage, 
            LPARAM lParam);

private:

    DWORD           m_Count;
    CCertTemplate** m_apCertTemplates;
    UINT            m_uiEditId;


};

#endif //__CTSHLEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once 
#endif // _MSC_VER >= 1000

#define STRICT

#pragma warning(push,3)

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage
#include <afxcmn.h>     // CSpinButtonCtrl

//#define _WIN32_WINNT 0x0500
#define _ATL_APARTMENT_THREADED

#include <mmc.h>
#include "certtmpl.h"

EXTERN_C const CLSID CLSID_CertTemplatesSnapin;
EXTERN_C const CLSID CLSID_CertTemplateShellExt;

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlapp.h>
#include <atlwin.h>

#include <atlctrls.h>

#include <iads.h>
#include <adserr.h>
#include <adshlp.h>
#include <lmcons.h>

#include "stdcooki.h" // from ..\framewrk
#include "stdcmpnt.h" // from ..\framewrk
#include "stdcdata.h" // from ..\framewrk
#include "persist.h" // PersistStream   from ..\framewrk
#include "stdutils.h" // GetObjectType() utility routines from ..\corecopy
#include "stddtobj.h" // class DataObject   from ..\framewrk
#include "stdabout.h" // from ..\framewrk


#include "chooser.h" //                 from ..\chooser
#include "regkey.h" // AMC::CRegKey     from ..\corecopy
#include "safetemp.h"   // from ..\corecopy
#include "macros.h"
#include "guidhelp.h" // GuidToCString

#include <comstrm.h>

#include <strings.h>
#include <dssec.h>
#include <dsrole.h>
#include <lmapibuf.h>

#include <prsht.h>
#include <shlobj.h>
#include <dsclient.h>
#include <objsel.h>

#include <CertCA.h>
#include <wincrypt.h>

#include <shfusion.h>

#pragma warning(pop)


#include "DisabledWarnings.h"
#include "helpids.h"
#include "utils.h"
#include "resource.h"
#include "strconst.h"
#include "debug.h"
#include "helpmap.h"
#include "HelpPropertyPage.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\shellext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997-2001

Module Name:

ShellExt.cpp

Abstract:
	This is the implementation file for Dfs Shell Extension object which implements
	IShellIExtInit and IShellPropSheetExt.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
	
	 NT only.
*/
    
#include "stdafx.h"
#include <dsclient.h>
#include "ShellExt.h"	
#include "TemplateGeneralPropertyPage.h"
#include "TemplateV1RequestPropertyPage.h"
#include "TemplateV2RequestPropertyPage.h"
#include "TemplateV1SubjectNamePropertyPage.h"
#include "TemplateV2SubjectNamePropertyPage.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "TemplateExtensionsPropertyPage.h"
#include "SecurityPropertyPage.h"
#include "PolicyOID.h"

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

/*----------------------------------------------------------------------
					IShellExtInit Implementation.
------------------------------------------------------------------------*/
CCertTemplateShellExt::CCertTemplateShellExt()
    : m_Count (0),
    m_apCertTemplates (0),
    m_uiEditId (0)
{
}

CCertTemplateShellExt::~CCertTemplateShellExt()
{	
    if ( m_apCertTemplates )
    {
        for (int nIndex = 0; nIndex < m_Count; nIndex++)
        {
            if ( m_apCertTemplates[nIndex] )
                m_apCertTemplates[nIndex]->Release ();
        }
    }
}

STDMETHODIMP CCertTemplateShellExt::Initialize
(
	IN LPCITEMIDLIST	/*pidlFolder*/,		// Points to an ITEMIDLIST structure
	IN LPDATAOBJECT	    pDataObj,		// Points to an IDataObject interface
	IN HKEY			    /*hkeyProgID*/		// Registry key for the file object or folder type
)
{

  HRESULT hr = 0;
  FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM medium = { TYMED_NULL };
  LPDSOBJECTNAMES pDsObjects;
  CString csClass, csPath;
  USES_CONVERSION;

  PWSTR wszTypeDN = 0;
  PWSTR wszTemplateName = 0;
  PWSTR wszType = 0;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // if we have a pDataObj then try and get the first name from it

  if ( pDataObj ) 
  {
    // get path and class

    fmte.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    if ( SUCCEEDED(pDataObj->GetData(&fmte, &medium)) ) 
    {
        pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;
        m_Count = pDsObjects->cItems;

        if(m_Count > 0)
        {

            m_apCertTemplates = (CCertTemplate **)LocalAlloc(LMEM_FIXED, sizeof(CCertTemplate*)*m_Count);
            if(m_apCertTemplates == NULL)
            {
              hr = E_OUTOFMEMORY;
              goto error;
            }
            ZeroMemory(m_apCertTemplates, sizeof(CCertTemplate*)*m_Count);

            for (UINT index = 0; index < m_Count ; index++) 
            {
                LPWSTR wszEnd = NULL;
                wszTypeDN = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[index].offsetName);
                if(wszTypeDN == NULL)
                {
                    continue;
                }
                wszTemplateName = wcsstr(wszTypeDN, L"CN=");
                if(wszTemplateName == NULL)
                {
                    continue;
                }
                wszTemplateName += 3;


                wszType = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(wszTemplateName)+1));
                if(wszType == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                wcscpy(wszType, wszTemplateName);
                wszEnd = wcschr(wszType, L',');
                if(wszEnd)
                {
                    *wszEnd = 0;
                }

                m_apCertTemplates[index] = new CCertTemplate (0, wszType, wszTypeDN, false, true);
//                hr = CAFindCertTypeByName(wszType, NULL, CT_ENUM_MACHINE_TYPES | 
//                                                         CT_ENUM_USER_TYPES | 
//                                                         CT_FLAG_NO_CACHE_LOOKUP, 
//                                                         &m_apCertTemplates[index]);
                LocalFree(wszType);
                wszType = NULL;
            }

        }
        ReleaseStgMedium(&medium);
    }
  }
  hr = S_OK;                  // success
  
error:
  
  return hr;

}


STDMETHODIMP CCertTemplateShellExt::AddPages
(
	IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
	IN LPARAM lParam
)

{
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if(m_apCertTemplates[0] == NULL)
    {
        return E_UNEXPECTED;
    }

    DWORD dwType = m_apCertTemplates[0]->GetType ();
    switch (dwType)
    {
    case 1:
        hr = AddVersion1CertTemplatePropPages (m_apCertTemplates[0], lpfnAddPage, lParam);
        break;

    case 2:
        hr = AddVersion2CertTemplatePropPages (m_apCertTemplates[0], lpfnAddPage, lParam);
        break;

    default:
        _ASSERT (0);
        break;
    }

/*
    CCertTemplateGeneralPage* pControlPage = new CCertTemplateGeneralPage(m_apCertTemplates[0]);
    if(pControlPage)
    {
        pBasePage = pControlPage;
        HPROPSHEETPAGE hPage = MyCreatePropertySheetPage(&pBasePage->m_psp);
        if (hPage == NULL)
        {
            delete (pControlPage);
            return E_UNEXPECTED;
        }
        lpfnAddPage(hPage, lParam);                          
    }
*/                                                                         
    return hr;                                                            
}

HRESULT CCertTemplateShellExt::AddVersion1CertTemplatePropPages (CCertTemplate* pCertTemplate, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    _TRACE (1, L"Entering CCertTemplateShellExt::AddVersion1CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && lpfnAddPage);
    if ( pCertTemplate && lpfnAddPage )
    {
        BOOL    bResult = FALSE;

        _ASSERT (1 == pCertTemplate->GetType ());

        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, 0);
        if ( pGeneralPage )
        {
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            if ( hPage )
            {
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
                if ( !bResult )
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1RequestPropertyPage * pRequestPage = new CTemplateV1RequestPropertyPage (*pCertTemplate);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV1SubjectNamePropertyPage (*pCertTemplate);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCASecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTemplateShellExt::AddVersion1CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplateShellExt::AddVersion2CertTemplatePropPages (CCertTemplate* pCertTemplate, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    _TRACE (1, L"Entering CCertTemplateShellExt::AddVersion1CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;
    _ASSERT (pCertTemplate && lpfnAddPage);
    if ( pCertTemplate && lpfnAddPage )
    {
        _ASSERT (2 == pCertTemplate->GetType ());
        
        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, 0);
        if ( pGeneralPage )
        {
			pGeneralPage->m_lNotifyHandle = 0; //lNotifyHandle;
            //m_lNotifyHandle = lNotifyHandle;
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            if ( hPage )
            {
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
                if ( !bResult )
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2RequestPropertyPage * pRequestPage = 
                    new CTemplateV2RequestPropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV2SubjectNamePropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add Authentication Name page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2AuthenticationPropertyPage * pAuthenticationPage = 
                    new CTemplateV2AuthenticationPropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty);
            if ( pAuthenticationPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAuthenticationPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add Superceded page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2SupercedesPropertyPage * pSupercededPage = 
                    new CTemplateV2SupercedesPropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty, 0);
            if ( pSupercededPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSupercededPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCertTemplateSecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTemplateShellExt::AddVersion1CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertTemplateShellExt::ReplacePage
(
	IN UINT /*uPageID*/, 
    IN LPFNADDPROPSHEETPAGE /*lpfnReplaceWith*/, 
    IN LPARAM /*lParam*/
)
{
    return E_FAIL;
}


// IContextMenu methods
STDMETHODIMP CCertTemplateShellExt::GetCommandString
(    
    UINT_PTR idCmd,    
    UINT uFlags,    
    UINT*   /*pwReserved*/,
    LPSTR pszName,    
    UINT cchMax   
)
{
    if((idCmd == m_uiEditId) && (m_uiEditId != 0))
    {
        if (uFlags == GCS_HELPTEXT)    
        {
            LoadString(AfxGetResourceHandle( ), IDS_EDIT_HINT, (LPTSTR)pszName, cchMax);
            return S_OK;    
        }    
    }
    return E_NOTIMPL;
}


STDMETHODIMP CCertTemplateShellExt::InvokeCommand
(    
    LPCMINVOKECOMMANDINFO lpici   
)
{
    if (!HIWORD(lpici->lpVerb))    
    {        
        UINT idCmd = LOWORD(lpici->lpVerb);
        switch(idCmd)
        {
        case 0: // Edit 
//            InvokeCertTypeWizard(m_ahCertTemplates[0],
//                             lpici->hwnd);
            return S_OK;

        }
    }

    return E_NOTIMPL;
}



STDMETHODIMP CCertTemplateShellExt::QueryContextMenu
(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT /*idCmdLast*/,
    UINT /*uFlags*/
)
{

    CString szEdit;
    MENUITEMINFO mii;
    UINT idLastUsedCmd = idCmdFirst;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ZeroMemory(&mii, sizeof(mii));
    
    if(IsCerttypeEditingAllowed())
    {

        mii.cbSize = sizeof(mii);   
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;    
        mii.wID = idCmdFirst; 

        szEdit.LoadString(IDS_EDIT);

        mii.dwTypeData = (LPTSTR)(LPCTSTR)szEdit;
        mii.cch = szEdit.GetLength();


        // Add new menu items to the context menu.    //
        ::InsertMenuItem(hmenu, 
                     indexMenu++, 
                     TRUE,
                     &mii);

    }

    return ResultFromScode (MAKE_SCODE (SEVERITY_SUCCESS, 0,
                            USHORT (idLastUsedCmd  + 1)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\strconst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001!_wcsicmp (AUTO_ENROLLMENT_KEY, bstrKey).
//
//  File:       strconst.h
//
//  Contents:   Definition of string constants for Certificate Templates
//
//----------------------------------------------------------------------------
#ifndef __STRCONST_H
#define __STRCONST_H

#define CERTTMPL_LDAP                   L"LDAP"
#define CERTTMPL_ROOTDSE                L"RootDSE"

#define CERTTMPL_DEFAULT_NAMING_CONTEXT  L"defaultNamingContext"
#define CERTTMPL_SYSTEM_RDN             L"CN=System"
#define CERTTMPL_CONFIG_NAMING_CONTEXT  L"configurationNamingContext"

#define CERTTMPL_CONTEXT_HELP_FILE	L"CapeSnpn.hlp"
#define CERTTMPL_HTML_HELP_FILE		L"CTConcepts.chm"
#define CERTTMPL_HTML_TOP_NODE		L"sag_CT_topnode.htm"
#define CERTTMPL_HELP_PATH			L"\\help\\"

#endif // __STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templateextensionspropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateExtensionsPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateExtensionsPropertyPage
//
//----------------------------------------------------------------------------
// TemplateExtensionsPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "TemplateExtensionsPropertyPage.h"
#include "KeyUsageDlg.h"
#include "BasicConstraintsDlg.h"
#include "PolicyDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PCWSTR pcszNEWLINE = L"\r\n";

#define IDI_CRITICAL_EXTENSION  2
#define IDI_EXTENSION           3
/////////////////////////////////////////////////////////////////////////////
// CTemplateExtensionsPropertyPage property page

CTemplateExtensionsPropertyPage::CTemplateExtensionsPropertyPage(
        CCertTemplate& rCertTemplate, 
        bool& rbIsDirty) 
    : CHelpPropertyPage(CTemplateExtensionsPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_rbIsDirty (rbIsDirty)
{
	//{{AFX_DATA_INIT(CTemplateExtensionsPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CTemplateExtensionsPropertyPage::~CTemplateExtensionsPropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateExtensionsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateExtensionsPropertyPage)
	DDX_Control(pDX, IDC_EXTENSION_LIST, m_extensionList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateExtensionsPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateExtensionsPropertyPage)
	ON_BN_CLICKED(IDC_SHOW_DETAILS, OnShowDetails)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_EXTENSION_LIST, OnItemchangedExtensionList)
	ON_NOTIFY(NM_DBLCLK, IDC_EXTENSION_LIST, OnDblclkExtensionList)
	ON_NOTIFY(LVN_DELETEITEM, IDC_EXTENSION_LIST, OnDeleteitemExtensionList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateExtensionsPropertyPage message handlers

BOOL CTemplateExtensionsPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();

    if ( m_rCertTemplate.GetType () > 1 )
    {
        CString szText;
        VERIFY (szText.LoadString (IDS_V2_EXTENSIONS_HELP_HINT));
        SetDlgItemText (IDC_EXTENSIONS_HELP_HINT, szText);
    }

    // Set up list controls
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_EXTENSIONS, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_EXTENSIONS, 16, 0, cr));
	m_extensionList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_extensionList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

	int	colWidths[NUM_COLS] = {400};

	// Add "Certificate Extension" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_CERTIFICATE_EXTENSION));
	VERIFY (m_extensionList.InsertColumn (COL_CERT_EXTENSION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_EXTENSION], COL_CERT_EXTENSION) != -1);

    // Add extensions
    bool    bEKUExtensionFound = false;
    bool    bCertPoliciesExtensionFound = false;
    bool    bApplicationPoliciesExtensionFound = false;
    HRESULT hr = S_OK;
    DWORD   dwExtensionCnt = m_rCertTemplate.GetCertExtensionCount ();
    for (DWORD dwIndex = 0; dwIndex < dwExtensionCnt; dwIndex++)
    {
        PSTR            pszObjId = 0;
        BOOL            fCritical = FALSE;

        hr = m_rCertTemplate.GetCertExtension (dwIndex, &pszObjId, fCritical);
        if ( SUCCEEDED (hr) )
        {
            if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszObjId) )
                bEKUExtensionFound = true;
            else if ( !_stricmp (szOID_CERT_POLICIES, pszObjId) )
                bCertPoliciesExtensionFound = true;
            else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszObjId) )
                bApplicationPoliciesExtensionFound = true;

            // Don't add EKU except for version 1
            if ( m_rCertTemplate.GetType () > 1 && !_stricmp (szOID_ENHANCED_KEY_USAGE, pszObjId) )
                continue; 

            // Don't add Application Policies for version 1
            if ( m_rCertTemplate.GetType () == 1 && !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszObjId) )
                continue;

            InsertListItem (pszObjId, fCritical);
            delete [] pszObjId;
        }
    }

    if ( !bEKUExtensionFound && 1 == m_rCertTemplate.GetType () )   // only version 1
    {
        InsertListItem (szOID_ENHANCED_KEY_USAGE, FALSE);
    }
    if ( !bCertPoliciesExtensionFound && m_rCertTemplate.GetType ()  > 1 )   // not version 1
    {
        InsertListItem (szOID_CERT_POLICIES, FALSE);
    }

    // Fixes 228146: CERTTMPL:The default "Cross Certification Authority" template does not have the application Policy extension item
    if ( !bApplicationPoliciesExtensionFound && m_rCertTemplate.GetType () > 1 )    // version 2 or greater
    {
        InsertListItem (szOID_APPLICATION_CERT_POLICIES, FALSE);
    }

    EnableControls ();	

    if ( 1 == m_rCertTemplate.GetType () )
        GetDlgItem (IDC_SHOW_DETAILS)->ShowWindow (SW_HIDE);

   	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CTemplateExtensionsPropertyPage::InsertListItem (LPSTR pszExtensionOid, BOOL fCritical)
{
    if ( !pszExtensionOid )
        return E_POINTER;

    HRESULT hr = S_OK;

    CString friendlyName;
    if ( MyGetOIDInfoA (friendlyName, pszExtensionOid) )
    {
	    LV_ITEM	lvItem;
	    int		iItem = m_extensionList.GetItemCount ();

	    ::ZeroMemory (&lvItem, sizeof (lvItem));
	    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	    lvItem.iItem = iItem;
        lvItem.iSubItem = COL_CERT_EXTENSION;
	    lvItem.pszText = (LPWSTR)(LPCWSTR) friendlyName;
        if ( fCritical )
            lvItem.iImage = IDI_CRITICAL_EXTENSION;
        else
            lvItem.iImage = IDI_EXTENSION;
        PSTR    pszOID = new CHAR[strlen (pszExtensionOid)+1];
        if ( pszOID )
        {
            strcpy (pszOID, pszExtensionOid);
            lvItem.lParam = (LPARAM) pszOID;

	        iItem = m_extensionList.InsertItem (&lvItem);
	        ASSERT (-1 != iItem);
            if ( -1 != iItem )
                hr = E_FAIL;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_FAIL;

    return hr;
}

void CTemplateExtensionsPropertyPage::EnableControls()
{
    int     nSelCnt = m_extensionList.GetSelectedCount ();
    BOOL    bEnableDetails = TRUE;
    int     nSelIndex = GetSelectedListItem ();


    if ( 1 == nSelCnt )
    {
        PSTR pszOID = (PSTR) m_extensionList.GetItemData (nSelIndex);
        _ASSERT (pszOID);
        if ( pszOID )
        {
            if ( !_stricmp (szOID_ENROLL_CERTTYPE_EXTENSION, pszOID) )
                bEnableDetails = FALSE;
            else if ( !_stricmp (szOID_BASIC_CONSTRAINTS, pszOID) )
                bEnableDetails = FALSE;
            else if ( !_stricmp (szOID_CERTIFICATE_TEMPLATE, pszOID) )
                bEnableDetails = FALSE;
        }
    }
    else
        bEnableDetails = FALSE;
    GetDlgItem (IDC_SHOW_DETAILS)->EnableWindow (bEnableDetails);
}

void CTemplateExtensionsPropertyPage::OnOK() 
{
	CDialog::OnOK();
}

void CTemplateExtensionsPropertyPage::OnShowDetails() 
{
	int nSelCnt = m_extensionList.GetSelectedCount ();
    _ASSERT (1 == nSelCnt);
    int nSelIndex = GetSelectedListItem ();
    if ( 1 == nSelCnt )
    {
        PSTR    pszOID = (PSTR) m_extensionList.GetItemData (nSelIndex);
        if ( pszOID )
        {
            PCERT_EXTENSION pCertExtension = 0;
            HRESULT hr = m_rCertTemplate.GetCertExtension (pszOID, &pCertExtension);
            if ( SUCCEEDED (hr) )
            {
                bool bExtensionAllocedLocally = false;
                if ( !pCertExtension )
                {
                    pCertExtension = new CERT_EXTENSION;
                    if ( pCertExtension )
                    {
                        ::ZeroMemory (pCertExtension, sizeof (CERT_EXTENSION));
                        pCertExtension->pszObjId = pszOID;
                        bExtensionAllocedLocally = true;
                    }
                    else
                        return;
                }
                CDialog* pDlg = 0;

                if ( !_stricmp (szOID_ENROLL_CERTTYPE_EXTENSION, pszOID) )
                {
                    return;
                }
                else if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszOID) )
                {
                    if ( m_rCertTemplate.GetType () == 1 )
                    {
                        pDlg = new CPolicyDlg (this, m_rCertTemplate, pCertExtension);
                    }
                }
                else if ( !_stricmp (szOID_KEY_USAGE, pszOID) )
                {
                    pDlg = new CKeyUsageDlg (this, m_rCertTemplate, pCertExtension);
                }
                else if ( !_stricmp (szOID_BASIC_CONSTRAINTS, pszOID) )
                {
                    return;
                }
                else if ( !_stricmp (szOID_BASIC_CONSTRAINTS2, pszOID) )
                {
                    pDlg = new CBasicConstraintsDlg (this, m_rCertTemplate, pCertExtension);
                }
                else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                {
                    pDlg = new CPolicyDlg (this, m_rCertTemplate, pCertExtension);
                }
                else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszOID) )
                {
                    if ( m_rCertTemplate.GetType () > 1 )
                    {
                        pDlg = new CPolicyDlg (this, m_rCertTemplate, pCertExtension);
                    }
                }
                else
                {
                    ASSERT (0);
                }

                bool bRefresh = false;

                if ( pDlg )
                {
                    CThemeContextActivator activator;
                    if ( IDOK == pDlg->DoModal () )
                        bRefresh = true;

                    delete pDlg;
                }

                if ( bExtensionAllocedLocally )
                    delete pCertExtension;
                m_rCertTemplate.FreeCertExtensions ();

                if ( bRefresh )
                {
                    hr = m_rCertTemplate.GetCertExtension (pszOID, &pCertExtension);
                    if ( SUCCEEDED (hr)  )
                    {
                        SetModified ();
                        m_rbIsDirty = true;
                        int nImage = 0;
                        if ( pCertExtension && pCertExtension->fCritical )
                            nImage = IDI_CRITICAL_EXTENSION;
                        else
                            nImage = IDI_EXTENSION;

                        VERIFY (m_extensionList.SetItem (nSelIndex, 0, LVIF_IMAGE, 0, 
                                nImage, 0, 0, 0));

                        ShowDescription ();

                        VERIFY (m_extensionList.SetItem (nSelIndex, 0, LVIF_IMAGE, 0, 
                                nImage, 0, 0, 0));

                        m_rCertTemplate.FreeCertExtensions ();
                    }
                }
            }
        }
    }
}


int CTemplateExtensionsPropertyPage::GetSelectedListItem()
{
    int nSelItem = -1;

	if ( m_extensionList.m_hWnd && m_extensionList.GetSelectedCount () > 0 )
	{
		int		nCnt = m_extensionList.GetItemCount ();
		ASSERT (nCnt >= 1);
		UINT	flag = 0;
		while (--nCnt >= 0)
		{
			flag = ListView_GetItemState (m_extensionList.m_hWnd, nCnt, LVIS_SELECTED);
			if ( flag & LVNI_SELECTED )
			{
                nSelItem = nCnt;
                break;
            }
        }
    }

    return nSelItem;
}

void CTemplateExtensionsPropertyPage::OnItemchangedExtensionList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LPNMLISTVIEW pNMListView = (LPNMLISTVIEW) pNMHDR;
    ASSERT (pNMListView);
    if ( !pNMListView )
    {
        *pResult = 0;
        return;
    }

    if ( !(LVIS_SELECTED & pNMListView->uNewState) )
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_NO_EXTENSION_SELECTED));
        SetDlgItemText (IDC_EXTENSION_NAME, szText);
        VERIFY (szText.LoadString (IDS_NONE));
        SetDlgItemText (IDC_EXTENSION_DESCRIPTION, szText);
        *pResult = 0;
        return;
    }

    EnableControls ();
	
    ShowDescription ();

	*pResult = 0;
}

void CTemplateExtensionsPropertyPage::SetCertTemplateExtension (PCERT_EXTENSION pCertExtension)
{
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    DWORD   cbData = 0;
       
    if ( CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_CERTIFICATE_TEMPLATE,
                          pCertExtension->Value.pbData,
                          pCertExtension->Value.cbData,
                          0,
                          NULL,
                          &cbData) )
    {
        CERT_TEMPLATE_EXT* pbTemplate = (CERT_TEMPLATE_EXT*) LocalAlloc(LPTR, cbData);
        if ( pbTemplate )
        {
            if ( CryptDecodeObject(X509_ASN_ENCODING,
                                  szOID_CERTIFICATE_TEMPLATE,
                                  pCertExtension->Value.pbData,
                                  pCertExtension->Value.cbData,
                                  0,
                                  pbTemplate,
                                  &cbData) )
            {
                CString text;
                CString description;

                //copy the extension oid
                if ( pbTemplate->pszObjId )
                {
                    CString templateName;
                    if ( MyGetOIDInfoA (templateName, pbTemplate->pszObjId) )
                    {
                        CString szOID;

                        int nLen = ::MultiByteToWideChar (CP_ACP, 0, 
                                pbTemplate->pszObjId, -1, NULL, 0);
		                ASSERT (nLen);
		                if ( nLen )
		                {
			                nLen = ::MultiByteToWideChar (CP_ACP, 0, 
                                    pbTemplate->pszObjId, -1, 
					                szOID.GetBufferSetLength (nLen), nLen);
			                ASSERT (nLen);
			                szOID.ReleaseBuffer ();
		                }

                        if ( !wcscmp (templateName, szOID) )
                        {
                            // Bug 213073 CryptFormatObject: Need to include 
                            // the cert temp OID in the Certificate Template 
                            // Information extension
                            // When the template is cloned, the oid-name pair
                            // is not in the global list.  Just use the
                            // template display name the user provided
                            templateName = m_rCertTemplate.GetDisplayName ();
                        }

                        text.FormatMessage (IDS_TEMPLATE_NAME, templateName);
                        description += text;
                        description += pcszNEWLINE;

                        // Copy the template OID
                        text.FormatMessage (IDS_TEMPLATE_OID, szOID);
                        description += text;
                        description += pcszNEWLINE;
                    }
                }

                // copy the subject type description
                CString szSubjectTypeDescription;
                if ( SUCCEEDED (m_rCertTemplate.GetSubjectTypeDescription (
                        0, szSubjectTypeDescription)) )
                {
                    text.FormatMessage (IDS_SUBJECT_TYPE_DESCRIPTION, szSubjectTypeDescription);
                    description += text;
                    description += pcszNEWLINE;
                }

                //copy the version
                WCHAR   str[32];
                _ultow (pbTemplate->dwMajorVersion, str, 10);
                text.FormatMessage (IDS_MAJOR_VERSION_NUMBER, str);
                description += text;
                description += pcszNEWLINE;

                _ultow (pbTemplate->dwMinorVersion, str, 10);
                text.FormatMessage (IDS_MINOR_VERSION_NUMBER, str);
                description += text;
                description += pcszNEWLINE;

                if ( description.IsEmpty () )
                    VERIFY (description.LoadString (IDS_NONE));
                SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);

            }
            LocalFree (pbTemplate);
        }
    }
}

void CTemplateExtensionsPropertyPage::SetCertTypeDescription (PCERT_EXTENSION pCertExtension)
{
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    DWORD	cbValue = 0;

	if ( ::CryptDecodeObject(
			CRYPT_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pCertExtension->Value.pbData,
			pCertExtension->Value.cbData,
			0,
			0,
			&cbValue) )
	{
		CERT_NAME_VALUE* pCNValue = (CERT_NAME_VALUE*) 
			::LocalAlloc(LPTR, cbValue);
		if ( pCNValue )
		{
			if ( ::CryptDecodeObject(
					CRYPT_ASN_ENCODING,
					X509_UNICODE_ANY_STRING,
					pCertExtension->Value.pbData,
					pCertExtension->Value.cbData,
					0,
					pCNValue,
					&cbValue) )
			{
				CString text = (LPWSTR) pCNValue->Value.pbData;
                CString description;
                
                if ( text.IsEmpty () )
                    VERIFY (text.LoadString (IDS_NONE));
                description.FormatMessage (IDS_TEMPLATE_INTERNAL_NAME, text);
                description += pcszNEWLINE;

                // copy the subject type description
                CString szSubjectTypeDescription;
                if ( SUCCEEDED (m_rCertTemplate.GetSubjectTypeDescription (
                        0, szSubjectTypeDescription)) )
                {
                    text.FormatMessage (IDS_SUBJECT_TYPE_DESCRIPTION, szSubjectTypeDescription);
                    description += text;
                    description += pcszNEWLINE;
                }

                SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
			}
			::LocalFree (pCNValue);
		}
	    else
	    {
            _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                    GetLastError ());
	    }
	}
	else
	{
        _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                GetLastError ());
	}
}


void CTemplateExtensionsPropertyPage::SetKeyUsageDescription (PCERT_EXTENSION pCertExtension)
{ 
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    CString description;
    CString text;

	DWORD           cbKeyUsage = 0;
	CRYPT_BIT_BLOB* pKeyUsage = 0;

	if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
			szOID_KEY_USAGE, 
			pCertExtension->Value.pbData,
			pCertExtension->Value.cbData,
			0, NULL, &cbKeyUsage) )
	{
		pKeyUsage = (CRYPT_BIT_BLOB*)
				::LocalAlloc (LPTR, cbKeyUsage);
		if ( pKeyUsage )
		{
			if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
					szOID_KEY_USAGE, 
					pCertExtension->Value.pbData,
					pCertExtension->Value.cbData,
					0, pKeyUsage, &cbKeyUsage) )
			{
                if (pKeyUsage->cbData >= 1)
                {
                    if ( pKeyUsage->pbData[0] & 
                            (CERT_DIGITAL_SIGNATURE_KEY_USAGE | 
                            CERT_NON_REPUDIATION_KEY_USAGE | 
                            CERT_KEY_CERT_SIGN_KEY_USAGE | 
                            CERT_OFFLINE_CRL_SIGN_KEY_USAGE) )
                    {
                        VERIFY (text.LoadString (IDS_SIGNATURE_REQUIREMENTS));
                        description += text;
                        description += pcszNEWLINE;

                        if ( pKeyUsage->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_DIGITAL_SIGNATURE));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_NON_REPUDIATION));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_CERTIFICATE_SIGNING));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_CRL_SIGNING));
                            description += text;
                            description += pcszNEWLINE;
                        }
                    }

                    if ( pKeyUsage->pbData[0] & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                            CERT_DATA_ENCIPHERMENT_KEY_USAGE |
                            CERT_KEY_AGREEMENT_KEY_USAGE) )
                    {
                        if ( !description.IsEmpty () )
                            description += pcszNEWLINE;

                        if ( pKeyUsage->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_ALLOW_KEY_EXCHANGE_ONLY_WITH_KEY_ENCRYPTION));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_ALLOW_KEY_EXCHANGE_WITHOUT_KEY_ENCRYPTION));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_ALLOW_ENCRYPTION_OF_USER_DATA));
                            description += text;
                            description += pcszNEWLINE;
                        }

                    }
                }

//                if (pKeyUsage->cbData >= 2)
//                {
//                    if ( pKeyUsage->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE )
//                        SendDlgItemMessage (IDC_CHECK_DECIPHERMENT_ONLY, BM_SETCHECK, BST_CHECKED);
//                }
			}
			else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			    DisplaySystemError (NULL, dwErr);
            }

            LocalFree (pKeyUsage);
		}
	}
	else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
		DisplaySystemError (NULL, dwErr);
    }

    if ( pCertExtension->fCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}


void CTemplateExtensionsPropertyPage::SetEnhancedKeyUsageDescription (bool bCritical)
{ 
    CString description;
    CString text;

    int     nEKUIndex = 0;
    CString szEKU;
    while ( SUCCEEDED (m_rCertTemplate.GetEnhancedKeyUsage (nEKUIndex, szEKU)) )
    {
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szEKU,  // wide-character string
              (int) wcslen (szEKU),  // number of chars in string
              0,                        // buffer for new string
              0,                        // size of buffer
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            nLen++; // account for Null terminator
            PSTR    pszAnsiBuf = new CHAR[nLen];
            if ( pszAnsiBuf )
            {
                ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szEKU, // wide-character string
                        (int) wcslen (szEKU), // number of chars in string
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
                    CString szEKUName;
                    if ( MyGetOIDInfoA (szEKUName, pszAnsiBuf) )
                    {
                        description += szEKUName;
                        description += pcszNEWLINE;
                    }
                }
                delete [] pszAnsiBuf;
            }
        }
        nEKUIndex++;
    }

    if ( bCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}

void CTemplateExtensionsPropertyPage::SetApplicationPoliciesDescription (bool bCritical)
{ 
    CString description;
    CString text;

    int     nAppPolicyIndex = 0;
    CString szAppPolicy;
    while ( SUCCEEDED (m_rCertTemplate.GetApplicationPolicy (nAppPolicyIndex, szAppPolicy)) )
    {
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szAppPolicy,  // wide-character string
              (int) wcslen (szAppPolicy),  // number of chars in string
              0,                        // buffer for new string
              0,                        // size of buffer
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            nLen++; // account for Null terminator
            PSTR    pszAnsiBuf = new CHAR[nLen];
            if ( pszAnsiBuf )
            {
                ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szAppPolicy, // wide-character string
                        (int) wcslen (szAppPolicy), // number of chars in string
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
                    CString szAppPolicyName;
                    if ( MyGetOIDInfoA (szAppPolicyName, pszAnsiBuf) )
                    {
                        description += szAppPolicyName;
                        description += pcszNEWLINE;
                    }
                }
                delete [] pszAnsiBuf;
            }
        }
        nAppPolicyIndex++;
    }

    if ( bCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}


void CTemplateExtensionsPropertyPage::SetCertPoliciesDescription (bool bCritical)
{ 
    CString description;
    CString text;

    VERIFY (text.LoadString (IDS_CERT_POLICY_KNOWN_AS_ISSUANCE_POLICY));
    description += text;
    description += pcszNEWLINE;
    description += pcszNEWLINE;

    int     nCertPolicyIndex = 0;
    CString szCertPolicy;
    while ( SUCCEEDED (m_rCertTemplate.GetCertPolicy (nCertPolicyIndex, szCertPolicy)) )
    {
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szCertPolicy,  // wide-character string
              (int) wcslen (szCertPolicy),  // number of chars in string
              0,                        // buffer for new string
              0,                        // size of buffer
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            nLen++; // account for Null terminator
            PSTR    pszAnsiBuf = new CHAR[nLen];
            if ( pszAnsiBuf )
            {
                ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szCertPolicy, // wide-character string
                        (int) wcslen (szCertPolicy), // number of chars in string
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
                    CString szPolicyName;
                    if ( MyGetOIDInfoA (szPolicyName, pszAnsiBuf) )
                    {
                        description += szPolicyName;
                        description += pcszNEWLINE;
                    }
                }

                delete [] pszAnsiBuf;
            }
        }
        nCertPolicyIndex++;
    }

    if ( bCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}

void CTemplateExtensionsPropertyPage::SetBasicConstraintsDescription (PCERT_EXTENSION pCertExtension)
{
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    CString description;
    CString text;

    VERIFY (text.LoadString (IDS_SUBJECT_IS_CA));
    description += text;
    description += pcszNEWLINE;

    PCERT_BASIC_CONSTRAINTS2_INFO   pBCInfo = 0;   
    DWORD                           cbInfo = 0;

    if ( CryptDecodeObject (
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            //X509_BASIC_CONSTRAINTS2, 
            szOID_BASIC_CONSTRAINTS2, 
            pCertExtension->Value.pbData,
            pCertExtension->Value.cbData,
            0,
            0,
            &cbInfo) )
    {
        pBCInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) ::LocalAlloc (
                LPTR, cbInfo);
        if ( pBCInfo )
        {
            if ( CryptDecodeObject (
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                //X509_BASIC_CONSTRAINTS2, 
                szOID_BASIC_CONSTRAINTS2, 
                pCertExtension->Value.pbData,
                pCertExtension->Value.cbData,
                0,
                pBCInfo,
                &cbInfo) )
            {
                if ( pBCInfo->fPathLenConstraint )
                {
                    VERIFY (text.LoadString (IDS_ONLY_ISSUE_END_ENTITIES));
                    description += text;
                    description += pcszNEWLINE;
                }
            }
            else
            {
                _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", GetLastError ());
            }
            LocalFree (pBCInfo);
        }
    }
    else
    {
        _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", GetLastError ());
    }

    if ( pCertExtension->fCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}

void CTemplateExtensionsPropertyPage::OnDblclkExtensionList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	OnShowDetails ();
	
	*pResult = 0;
}

void CTemplateExtensionsPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateExtensionsPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_EXTENSIONS) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateExtensionsPropertyPage::DoContextHelp\n");
}

void CTemplateExtensionsPropertyPage::OnDeleteitemExtensionList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    PSTR pszOID = (PSTR) m_extensionList.GetItemData (pNMListView->iItem);
    if ( pszOID )
    {
        delete [] pszOID;
    }
	
	*pResult = 0;
}

BOOL CTemplateExtensionsPropertyPage::OnSetActive() 
{
    BOOL  bRVal = CHelpPropertyPage::OnSetActive();
    	
    ShowDescription ();

    return bRVal;
}

void CTemplateExtensionsPropertyPage::ShowDescription ()
{
	int nSelCnt = m_extensionList.GetSelectedCount ();
    int nSelIndex = GetSelectedListItem ();
    if ( 1 == nSelCnt )
    {
        PSTR    pszOID = (PSTR) m_extensionList.GetItemData (nSelIndex);
        if ( pszOID )
        {
            CString friendlyName;
            if ( MyGetOIDInfoA (friendlyName, pszOID) )
            {
                CString text;

                text.FormatMessage (IDS_EXTENSION_NAME, friendlyName);
                SetDlgItemText (IDC_EXTENSION_NAME, text);
            }
            else
                SetDlgItemText (IDC_EXTENSION_NAME, L"");

            PCERT_EXTENSION pCertExtension = 0;
            HRESULT hr = m_rCertTemplate.GetCertExtension (pszOID, &pCertExtension);
            if ( SUCCEEDED (hr) )
            {
                if ( pCertExtension )
                {
                    if ( !_stricmp (szOID_BASIC_CONSTRAINTS2, pszOID) )
                    {
                        SetBasicConstraintsDescription (pCertExtension);
                    }
                    else if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszOID) )
                    {
                        bool bCritical = false;
                        m_rCertTemplate.IsExtensionCritical (TEXT (szOID_ENHANCED_KEY_USAGE), 
                                bCritical);

                        SetEnhancedKeyUsageDescription (bCritical);
                    }
                    else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszOID) )
                    {
                        bool bCritical = false;
                        m_rCertTemplate.IsExtensionCritical (TEXT (szOID_APPLICATION_CERT_POLICIES), 
                                bCritical);

                        SetApplicationPoliciesDescription (bCritical);
                    }
                    else if ( !_stricmp (szOID_KEY_USAGE, pszOID) )
                    {
                        SetKeyUsageDescription (pCertExtension);
                    }
                    else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                    {
                        bool bCritical = false;
                        m_rCertTemplate.IsExtensionCritical (TEXT (szOID_CERT_POLICIES), 
                                bCritical);
                        SetCertPoliciesDescription (bCritical);
                    }
                    else if ( !_stricmp (szOID_ENROLL_CERTTYPE_EXTENSION, pszOID) )
                    {
                        SetCertTypeDescription (pCertExtension);
                    }
                    else if ( !_stricmp (szOID_CERTIFICATE_TEMPLATE, pszOID) )
                    {
                        SetCertTemplateExtension (pCertExtension);
                    }
                    else
                    {
                        CString szText;

                        VERIFY (szText.LoadString (IDS_NONE));
                        SetDlgItemText (IDC_EXTENSION_DESCRIPTION, szText);
                    }
                }
                else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                {
                    SetCertPoliciesDescription (false);
                }
                else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszOID) )
                {
                    SetApplicationPoliciesDescription (false);
                }
            }
        }
    }
    else
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_NO_EXTENSION_SELECTED));
        SetDlgItemText (IDC_EXTENSION_NAME, szText);
        VERIFY (szText.LoadString (IDS_NONE));
        SetDlgItemText (IDC_EXTENSION_DESCRIPTION, szText);
    }
}

void CTemplateExtensionsPropertyPage::OnDestroy() 
{
	CHelpPropertyPage::OnDestroy();
	
    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templateextensionspropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateExtensionsPropertyPage.h
//
//  Contents:   Definition of CTemplateExtensionsPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEEXTENSIONSPROPERTYPAGE_H__6C588253_32DA_4E99_A714_EAECE8C81B20__INCLUDED_)
#define AFX_TEMPLATEEXTENSIONSPROPERTYPAGE_H__6C588253_32DA_4E99_A714_EAECE8C81B20__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateExtensionsPropertyPage.h : header file
//
#include "CertTemplate.h"
#include "PolicyOID.h"


/////////////////////////////////////////////////////////////////////////////
// CTemplateExtensionsPropertyPage dialog

class CTemplateExtensionsPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateExtensionsPropertyPage(CCertTemplate& rCertTemplate, 
            bool& rbIsDirty);
	~CTemplateExtensionsPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateExtensionsPropertyPage)
	enum { IDD = IDD_TEMPLATE_EXTENSIONS };
	CListCtrl	m_extensionList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateExtensionsPropertyPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void ShowDescription ();
    void SetCertTemplateExtension (PCERT_EXTENSION pCertExtension);
    void SetCertTypeDescription (PCERT_EXTENSION pCertExtension);
    void SetKeyUsageDescription (PCERT_EXTENSION pCertExtension);
    void SetEnhancedKeyUsageDescription (bool bCritical);
    void SetCertPoliciesDescription (bool bCritical);
    void SetBasicConstraintsDescription (PCERT_EXTENSION pCertExtension);
    void SetApplicationPoliciesDescription (bool bCritical);
    HRESULT InsertListItem (LPSTR pszExtensionOid, BOOL fCritical);
	virtual void DoContextHelp (HWND hWndControl);
	int GetSelectedListItem ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateExtensionsPropertyPage)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnShowDetails();
	afx_msg void OnItemchangedExtensionList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkExtensionList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitemExtensionList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void EnableControls ();

private:
	bool& m_rbIsDirty;
    CCertTemplate& m_rCertTemplate;
	WTL::CImageList		m_imageListSmall;
	WTL::CImageList		m_imageListNormal;

	enum {
		COL_CERT_EXTENSION = 0,
		NUM_COLS	// must be last
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEEXTENSIONSPROPERTYPAGE_H__6C588253_32DA_4E99_A714_EAECE8C81B20__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templategeneralpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateGeneralPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateGeneralPropertyPage
//
//----------------------------------------------------------------------------
// TemplateGeneralPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "CompData.h"
#include "TemplateGeneralPropertyPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateGeneralPropertyPage property page

CTemplateGeneralPropertyPage::CTemplateGeneralPropertyPage(
        CCertTemplate& rCertTemplate,
        const CCertTmplComponentData* pCompData) : 
    CHelpPropertyPage(CTemplateGeneralPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_strOriginalName (rCertTemplate.GetTemplateName ()),
    m_pReleaseMe (0),
    m_dwCurrentValidityUnits (PERIOD_TYPE_NONE),
    m_dwCurrentRenewalUnits (PERIOD_TYPE_NONE),
    m_lNotifyHandle (0),
    m_bIsDirty (false),
    m_nRenewalDays (0),
    m_nValidityDays (0),
    m_pCompData (pCompData),
    m_nTemplateV2AuthPageNumber (-1),
    m_nTemplateV2RequestPageNumber (-1)
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::CTemplateGeneralPropertyPage ()\n");
	//{{AFX_DATA_INIT(CTemplateGeneralPropertyPage)
	m_strDisplayName = _T("");
	m_strTemplateName = _T("");
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

   _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::CTemplateGeneralPropertyPage ()\n");
}

CTemplateGeneralPropertyPage::~CTemplateGeneralPropertyPage()
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::~CTemplateGeneralPropertyPage ()\n");
    m_rCertTemplate.Release ();

    if ( m_pReleaseMe )
    {
        m_pReleaseMe->Release ();
        m_pReleaseMe = 0;
    }

    if ( m_lNotifyHandle )
    {
        MMCFreeNotifyHandle (m_lNotifyHandle);
        m_lNotifyHandle = 0;
    }


    _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::~CTemplateGeneralPropertyPage ()\n");
}

void CTemplateGeneralPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateGeneralPropertyPage)
	DDX_Control(pDX, IDC_VALIDITY_UNITS, m_validityUnits);
	DDX_Control(pDX, IDC_RENEWAL_UNITS, m_renewalUnits);
	DDX_Text(pDX, IDC_DISPLAY_NAME, m_strDisplayName);
	DDX_Text(pDX, IDC_TEMPLATE_NAME, m_strTemplateName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateGeneralPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateGeneralPropertyPage)
	ON_EN_CHANGE(IDC_DISPLAY_NAME, OnChangeDisplayName)
	ON_CBN_SELCHANGE(IDC_RENEWAL_UNITS, OnSelchangeRenewalUnits)
	ON_CBN_SELCHANGE(IDC_VALIDITY_UNITS, OnSelchangeValidityUnits)
	ON_EN_CHANGE(IDC_RENEWAL_EDIT, OnChangeRenewalEdit)
	ON_EN_CHANGE(IDC_VALIDITY_EDIT, OnChangeValidityEdit)
	ON_BN_CLICKED(IDC_PUBLISH_TO_AD, OnPublishToAd)
	ON_BN_CLICKED(IDC_USE_AD_CERT_FOR_REENROLLMENT, OnUseADCert)
	ON_EN_CHANGE(IDC_TEMPLATE_NAME, OnChangeTemplateName)
	ON_EN_KILLFOCUS(IDC_VALIDITY_EDIT, OnKillfocusValidityEdit)
	ON_CBN_KILLFOCUS(IDC_VALIDITY_UNITS, OnKillfocusValidityUnits)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateGeneralPropertyPage message handlers


BOOL CTemplateGeneralPropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::OnInitDialog ()\n");
	CHelpPropertyPage::OnInitDialog();

    SendDlgItemMessage (IDC_VALIDITY_EDIT, EM_LIMITTEXT, 4, 0);
    SendDlgItemMessage (IDC_RENEWAL_EDIT, EM_LIMITTEXT, 4, 0);
    
    CString version;
    if ( 1 == m_rCertTemplate.GetType () )
    {
        VERIFY (version.LoadString (IDS_WINDOWS_2000_AND_LATER));
    }
    else
    {
        VERIFY (version.LoadString (IDS_WINDOWS_2002_AND_LATER));
    }
    
    SetDlgItemText (IDC_TEMPLATE_VERSION, version);
    

    if ( m_rCertTemplate.IsClone () )
    {
        GetDlgItem (IDC_CANT_CHANGE_TEMPLATE_NAME)->ShowWindow (SW_SHOW);
    }
    else
    {
        // The template name is only editable if the template is a clone. Since
        // this is not a clone, disable the template name fields.
        GetDlgItem (IDC_TEMPLATE_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_TEMPLATE_NAME_LABEL)->EnableWindow (FALSE);

        // #NTRAID 360650: Cert Server: Cannot rename cert templates
        GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_DISPLAY_NAME_LABEL)->EnableWindow (FALSE);
    }

    m_strTemplateName = m_rCertTemplate.GetTemplateName ();
    m_strOriginalDisplayName = m_strDisplayName = m_rCertTemplate.GetDisplayName ();

    // Get validity period, determine current units and then initialize drop down
    HRESULT hr = m_rCertTemplate.GetValidityPeriod (m_nValidityDays);
    if ( SUCCEEDED (hr) )
    {
        int nValue = m_nValidityDays;
        if ( nValue % 365 == 0 )
        {
            nValue /= 365;
            m_dwCurrentValidityUnits = PERIOD_TYPE_YEAR;

        }
        else if ( nValue % 30 == 0 )
        {
            nValue /= 30;
            m_dwCurrentValidityUnits = PERIOD_TYPE_MONTH;
        }
        else if ( nValue % 7 == 0 )
        {
            nValue /= 7;
            m_dwCurrentValidityUnits = PERIOD_TYPE_WEEK;
        }
        else
            m_dwCurrentValidityUnits = PERIOD_TYPE_DAY;
        SetDlgItemInt (IDC_VALIDITY_EDIT, (UINT) nValue, FALSE);
    }

    hr = m_rCertTemplate.GetRenewalPeriod (m_nRenewalDays);
    if ( SUCCEEDED (hr) )
    {
        int nValue = m_nRenewalDays;
        if ( nValue % 365 == 0 )
        {
            nValue /= 365;
            m_dwCurrentRenewalUnits = PERIOD_TYPE_YEAR;

        }
        else if ( nValue % 30 == 0 )
        {
            nValue /= 30;
            m_dwCurrentRenewalUnits = PERIOD_TYPE_MONTH;
        }
        else if ( nValue % 7 == 0 )
        {
            nValue /= 7;
            m_dwCurrentRenewalUnits = PERIOD_TYPE_WEEK;
        }
        else
            m_dwCurrentRenewalUnits = PERIOD_TYPE_DAY;
        SetDlgItemInt (IDC_RENEWAL_EDIT, (UINT) nValue, FALSE);
    }

    // Now that we know what units the validity and renewal periods are
    // to be displayed in, initialize the dropdowns and select the
    // appropriate unit
    // Initialize validity and renewal period dropdowns
    CString text;
    VERIFY (text.LoadString (IDS_DAYS));
    int nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_DAY);
        if ( PERIOD_TYPE_DAY == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }

    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_DAY);
        if ( PERIOD_TYPE_DAY == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_WEEKS));
    nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_WEEK);
        if ( PERIOD_TYPE_WEEK == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }
    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_WEEK);
        if ( PERIOD_TYPE_WEEK == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_MONTHS));
    nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_MONTH);
        if ( PERIOD_TYPE_MONTH == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }
    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_MONTH);
        if ( PERIOD_TYPE_MONTH == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_YEARS));
    nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_YEAR);
        if ( PERIOD_TYPE_YEAR == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }
    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_YEAR);
        if ( PERIOD_TYPE_YEAR == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }


    if ( m_rCertTemplate.PublishToDS () )
        SendDlgItemMessage (IDC_PUBLISH_TO_AD, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.CheckDSCert () )
        SendDlgItemMessage (IDC_USE_AD_CERT_FOR_REENROLLMENT, BM_SETCHECK, BST_CHECKED);


    EnableControls ();

    UpdateData (FALSE);


    m_bIsDirty = false;  // because SetDlgItemInt () sets it to true

    if ( m_rCertTemplate.IsClone () )
    {
        SetModified ();
        m_bIsDirty = true;
    }

    _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CTemplateGeneralPropertyPage::EnableControls ()
{
    if ( 1 == m_rCertTemplate.GetType () || m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_TEMPLATE_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_TEMPLATE_NAME_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_DISPLAY_NAME_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_VALIDITY_UNITS)->EnableWindow (FALSE);
        GetDlgItem (IDC_VALIDITY_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_RENEWAL_UNITS)->EnableWindow (FALSE);
        GetDlgItem (IDC_RENEWAL_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_PUBLISH_TO_AD)->EnableWindow (FALSE);
        GetDlgItem (IDC_USE_AD_CERT_FOR_REENROLLMENT)->EnableWindow (FALSE);
    }
    else if ( m_rCertTemplate.IsDefault () )
    {
        GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
    }
    else
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_PUBLISH_TO_AD, BM_GETCHECK) )
            GetDlgItem (IDC_USE_AD_CERT_FOR_REENROLLMENT)->EnableWindow (TRUE);
        else
            GetDlgItem (IDC_USE_AD_CERT_FOR_REENROLLMENT)->EnableWindow (FALSE);
    }
}


void CTemplateGeneralPropertyPage::OnCancel()
{
    if ( !m_rCertTemplate.IsClone () )
        m_rCertTemplate.Cancel ();


    CHelpPropertyPage::OnCancel ();
}

int CTemplateGeneralPropertyPage::SetRenewalPeriod (int nMaxRenewalDays, bool bSilent)
{
    CThemeContextActivator activator;
    CString caption;
    CString text;
    CString timeUnit;
    int     nAmount = 0;

    VERIFY (caption.LoadString (IDS_CERTTMPL));

    if ( nMaxRenewalDays % 365 == 0 )
    {
        nAmount = nMaxRenewalDays/365;
        if ( 1 == nAmount )
            VERIFY (timeUnit.LoadString (IDS_YEAR));
        else
            VERIFY (timeUnit.LoadString (IDS_YEARS));
    }
    else if ( nMaxRenewalDays % 30 == 0 )
    {
        nAmount = nMaxRenewalDays/30;
        if ( 1 == nAmount )
            VERIFY (timeUnit.LoadString (IDS_MONTH));
        else
            VERIFY (timeUnit.LoadString (IDS_MONTHS));
    }
    else if ( nMaxRenewalDays % 7 == 0 )
    {
        nAmount = nMaxRenewalDays/7;
        if ( 1 == nAmount )
            VERIFY (timeUnit.LoadString (IDS_WEEK));
        else
            VERIFY (timeUnit.LoadString (IDS_WEEKS));
    }
    else 
    {
        nAmount = nMaxRenewalDays;
        if ( 1 == nMaxRenewalDays )
            VERIFY (timeUnit.LoadString (IDS_DAY));
        else
            VERIFY (timeUnit.LoadString (IDS_DAYS));
    }
    text.FormatMessage (IDS_RENEWAL_MUST_BE_LESS_THAN_VALIDITY,
            nAmount, timeUnit);

    int nRetVal = IDOK;
    
    if ( !bSilent )
        nRetVal = MessageBox (text, caption, MB_OKCANCEL);
    if ( IDOK == nRetVal )
    {
        HRESULT hr = m_rCertTemplate.SetRenewalPeriod (nMaxRenewalDays);
        if ( SUCCEEDED (hr) )
        {
            m_nRenewalDays = nMaxRenewalDays;
            int nValue = m_nRenewalDays;
            if ( nValue % 365 == 0 )
            {
                nValue /= 365;
                m_dwCurrentRenewalUnits = PERIOD_TYPE_YEAR;

            }
            else if ( nValue % 30 == 0 )
            {
                nValue /= 30;
                m_dwCurrentRenewalUnits = PERIOD_TYPE_MONTH;
            }
            else if ( nValue % 7 == 0 )
            {
                nValue /= 7;
                m_dwCurrentRenewalUnits = PERIOD_TYPE_WEEK;
            }
            else
                m_dwCurrentRenewalUnits = PERIOD_TYPE_DAY;

            int nCnt = m_renewalUnits.GetCount ();
            while (--nCnt >= 0)
            {
                if ( m_dwCurrentRenewalUnits == (PERIOD_TYPE) m_renewalUnits.GetItemData (nCnt) )
                {
                    m_renewalUnits.SetCurSel (nCnt);
                    break;
                }
            }

            // Must set this after the units
            SetDlgItemInt (IDC_RENEWAL_EDIT, (UINT) nValue, FALSE);


            SetModified ();
            m_bIsDirty = true;
        }
    }

    return nRetVal;
}

#define ILLEGAL_FAT_CHARS   L"\"+,;<=>"

bool CTemplateGeneralPropertyPage::ValidateTemplateName(const CString& m_szTemplateName)
{
    bool    bRVal = true;

    PCWSTR szInvalidCharSet = ILLEGAL_FAT_CHARS; 


    if ( -1 != m_szTemplateName.FindOneOf (szInvalidCharSet) )
    {
        bRVal = false;
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        CString charsWithSpaces;

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        text.FormatMessage (IDS_TEMPLATE_NAME_CONTAINS_INVALID_CHARS, charsWithSpaces);

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDC_TEMPLATE_NAME)->SetFocus ();
    }

    return bRVal;
}

BOOL CTemplateGeneralPropertyPage::OnApply() 
{
    UpdateData (TRUE);

    if ( m_rCertTemplate.GetType () > 1 && m_bIsDirty )
    {
        HRESULT hr = S_OK;

        if ( m_rCertTemplate.IssuancePoliciesRequired () )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            VERIFY (text.LoadString (IDS_MUST_ADD_RA_ISSUANCE_POLICY));

            MessageBox (text, caption, MB_OK);

            if ( -1 != m_nTemplateV2AuthPageNumber )
            {
                CWnd* pParent = GetParent ();
                if ( pParent )
                {
                    pParent->SendMessage (PSM_SETCURSEL, 
                            m_nTemplateV2AuthPageNumber);
                }
            }

            return FALSE;
        }


        // NTRAID# 331178 Certtmpl: All Certificate Templates must enforce 
        // that the certificate Renewal Period < = 75% of the Validity Period
        int nMaxRenewalDays = (m_nValidityDays * 3) / 4;
        if ( nMaxRenewalDays < m_nRenewalDays )
        {
            if ( IDOK != SetRenewalPeriod (nMaxRenewalDays, false) )
            {
                CWnd* pParent = GetParent ();
                if ( pParent )
                    pParent->SendMessage (PSM_SETCURSEL, 0);
                GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
                return FALSE;
            }
        }

        // NTRAID# 353945: Certtmpl: Changing V2 certificate template validity 
        // period to 1 Day, automatically sets the renewal period to 0 years
        if ( m_nValidityDays < 2 )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            VERIFY (text.LoadString (IDS_2_DAY_SMALLEST_VALIDITY));

            MessageBox (text, caption, MB_OK);

            CWnd* pParent = GetParent ();
            if ( pParent )
                pParent->SendMessage (PSM_SETCURSEL, 0);
            GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
            return FALSE;
        }

        // Note: The CERTYPE_PROP_CN resets the CERTTYPE_PROP_FRIENDLY_NAME 
        // and so must be set before it.
        bool   bResetDisplayName = false;
        if ( LocaleStrCmp (m_strTemplateName, m_rCertTemplate.GetTemplateName ()) )
        {
            bResetDisplayName = true;

            // Check new name for invalid characters
            m_strTemplateName.TrimLeft ();
            m_strTemplateName.TrimRight ();

            if ( !ValidateTemplateName (m_strTemplateName) )
                return FALSE;

            if ( _wcsicmp (m_strOriginalName, m_strTemplateName) ) // was renamed
            {
                // Ensure that the selected name is unique
                HCERTTYPE   hCertType = 0;
                bool        bFound = false;
                hr = CAFindCertTypeByName (m_rCertTemplate.GetTemplateName (), 
                        NULL,
                        CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                        &hCertType);
                if ( SUCCEEDED (hr) )
                {
                    bFound = TRUE;
                    hr = CACloseCertType (hCertType);
                    if ( FAILED (hr) )
                    {
                        _TRACE (0, L"CACloseCertType () failed: 0x%x", hr);
                    }
                }
                else
                {
                    if ( m_pCompData )
                    {
                        POSITION                pos = 0;
                        for (pos = m_pCompData->m_globalTemplateNameList.GetHeadPosition (); pos;)
                        {
                            if ( !_wcsicmp (m_strTemplateName, 
                                    m_pCompData->m_globalTemplateNameList.GetNext (pos)) )
                            {
                                bFound = true;
                                break;
                            }
                        }
                    }
                }

                if ( bFound )
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    text.FormatMessage (IDS_ENTER_UNIQUE_TEMPLATE_NAME, 
                            m_strTemplateName);

                    MessageBox (text, caption, MB_OK);
                    GetDlgItem (IDC_TEMPLATE_NAME)->SetFocus ();

                    return FALSE;
                }
            }

            hr = m_rCertTemplate.SetTemplateName (m_strTemplateName);
            if ( FAILED (hr) )
            {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                text.FormatMessage (IDS_CANNOT_CHANGE_TEMPLATE_NAME, hr);

                MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                CWnd* pParent = GetParent ();
                if ( pParent )
                    pParent->SendMessage (PSM_SETCURSEL, 0);
                GetDlgItem (IDC_TEMPLATE_NAME)->SetFocus ();

                return FALSE;
            }
        }

        // Check if the display name has changed.  Don't allow reuse of existing names.
        if ( bResetDisplayName || _wcsicmp (m_strDisplayName, m_strOriginalDisplayName) )
        {
            bool                    bFound = false;

            if ( m_pCompData )
            {
                POSITION                pos = 0;
                for (pos = m_pCompData->m_globalFriendlyNameList.GetHeadPosition (); pos;)
                {
                    if ( !_wcsicmp (m_strDisplayName, 
                            m_pCompData->m_globalFriendlyNameList.GetNext (pos)) )
                    {
                        bFound = true;
                        break;
                    }
                }
            }
            else
            {
                // Generate list of templates and search for name.  This should only be called
                // from the shell extension because it doesn't build the list of templates
                // beforehand
                hr = FindFriendlyNameInEnterpriseTemplates (
                            m_strDisplayName, 
                            bFound);
            }

            if ( bFound )
            {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                text.FormatMessage (IDS_FRIENDLY_NAME_ALREADY_USED, m_strDisplayName);

                MessageBox (text, caption, MB_OK);
                return FALSE;
            }
            else
            {
                hr = m_rCertTemplate.SetDisplayName (m_strDisplayName, true);
                if ( FAILED (hr) )
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    text.FormatMessage (IDS_CANNOT_CHANGE_DISPLAY_NAME, hr);

                    MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                    GetDlgItem (IDC_DISPLAY_NAME)->SetFocus ();

                    return FALSE;
                }
            }
        }


//        // NTRAID# 276180 Certificate Template Snap-in: Grey out "Allow 
//        // Autoenrollment" context menu based on properties of the template
//        DWORD   dwNumSignatures = 0;
//        m_rCertTemplate.GetRANumSignaturesRequired (dwNumSignatures);
//        if ( m_rCertTemplate.RequireSubjectInRequest () ||
//                dwNumSignatures >= 2 && !m_rCertTemplate.ReenrollmentValidWithPreviousApproval () )
//        {
//            m_rCertTemplate.SetAutoEnrollment (false);
//        }

        hr = m_rCertTemplate.SaveChanges ();
        if ( SUCCEEDED (hr) )
        {
            m_strOriginalName = m_strTemplateName;
            hr = MMCPropertyChangeNotify (m_lNotifyHandle,  // handle to a notification
                    (LPARAM) &m_rCertTemplate);           // unique identifier

            // Now that the template has been saved, never allow the internal 
            // name to be edited.
            GetDlgItem (IDC_TEMPLATE_NAME)->EnableWindow (FALSE);
            GetDlgItem (IDC_TEMPLATE_NAME_LABEL)->EnableWindow (FALSE);

            // #NTRAID 360650: Cert Server: Cannot rename cert templates
            GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
            GetDlgItem (IDC_DISPLAY_NAME_LABEL)->EnableWindow (FALSE);
        }
        else
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_UNABLE_TO_SAVE_CERT_TEMPLATE_CHANGES, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK | MB_ICONWARNING);
            return FALSE;
        }

        m_bIsDirty = false;
    }


    return CHelpPropertyPage::OnApply();
}

void CTemplateGeneralPropertyPage::OnChangeDisplayName() 
{
	SetModified ();	
    m_bIsDirty = true;
    if ( m_rCertTemplate.IsClone () )
    {
        CString text;

        GetDlgItemText (IDC_DISPLAY_NAME, text);

        // strip out spaces
        PCWSTR  pszSrc = (PCWSTR) text;

        const int  LEN = text.GetLength () + 1; 
        PWSTR   pszTgt = new WCHAR[LEN];
        PWSTR   pszTgtPtr = pszTgt;
        ::ZeroMemory (pszTgt, LEN * sizeof (WCHAR));

        for (; *pszSrc; pszSrc++)
        {
            if ( !iswspace (*pszSrc) )
            {
                *pszTgtPtr = *pszSrc;
                pszTgtPtr++;
            }
        }

        SetDlgItemText (IDC_TEMPLATE_NAME, pszTgt);
        delete [] pszTgt;
    }
}

void CTemplateGeneralPropertyPage::OnChangeTemplateName() 
{
    UpdateData (TRUE);
    SetModified ();
    m_bIsDirty = true;
}


void CTemplateGeneralPropertyPage::OnSelchangeRenewalUnits() 
{
    OnChangeRenewalEdit ();
}

void CTemplateGeneralPropertyPage::OnSelchangeValidityUnits() 
{
    OnChangeValidityEdit ();
}

void CTemplateGeneralPropertyPage::OnChangeRenewalEdit() 
{
    HRESULT     hr = S_OK;
    int         nCurSel = m_renewalUnits.GetCurSel ();
    if ( nCurSel < 0 )
        return;

    int         nCurVal = GetDlgItemInt (IDC_RENEWAL_EDIT);
    DWORD dwRenewalUnits = (PERIOD_TYPE) m_renewalUnits.GetItemData (nCurSel);

    // convert to days
	switch ( dwRenewalUnits )
    {
    case PERIOD_TYPE_DAY:
        break; // do nothing - is already days

    case PERIOD_TYPE_WEEK:
        nCurVal *= 7;
        break;

    case PERIOD_TYPE_MONTH:
        nCurVal *= 30;
        break;

    case PERIOD_TYPE_YEAR:
        nCurVal *= 365;
        break;

    case PERIOD_TYPE_NONE:
    default:
        _ASSERT (0);
        hr = E_FAIL; //don't know what the units are
        break;
    }

    if ( SUCCEEDED (hr) )
    {
        hr = m_rCertTemplate.SetRenewalPeriod (nCurVal);
        if ( SUCCEEDED (hr) )
        {
            m_nRenewalDays = nCurVal;
    	    SetModified ();
            m_bIsDirty = true;
        }
    }
}

void CTemplateGeneralPropertyPage::OnChangeValidityEdit() 
{
    HRESULT     hr = S_OK;
    int         nCurSel = m_validityUnits.GetCurSel ();
    if ( nCurSel < 0 )
        return;
    
    int         nCurVal = GetDlgItemInt (IDC_VALIDITY_EDIT);
    DWORD dwValidityUnits = (PERIOD_TYPE) m_validityUnits.GetItemData (nCurSel);

    // convert to days
	switch ( dwValidityUnits )
    {
    case PERIOD_TYPE_DAY:
        break; // do nothing - is already days

    case PERIOD_TYPE_WEEK:
        nCurVal *= 7;
        break;

    case PERIOD_TYPE_MONTH:
        nCurVal *= 30;
        break;

    case PERIOD_TYPE_YEAR:
        nCurVal *= 365;
        break;

    case PERIOD_TYPE_NONE:
    default:
        _ASSERT (0);
        hr = E_FAIL; //don't know what the units are
        break;
    }

    if ( SUCCEEDED (hr) )
    {
        hr = m_rCertTemplate.SetValidityPeriod (nCurVal);
        if ( SUCCEEDED (hr) )
        {
            m_nValidityDays = nCurVal;
    	    SetModified ();
            m_bIsDirty = true;
        }
    }
}

void CTemplateGeneralPropertyPage::OnPublishToAd() 
{
    bool bPublishToAD = BST_CHECKED == SendDlgItemMessage (IDC_PUBLISH_TO_AD, BM_GETCHECK);
    m_rCertTemplate.SetPublishToDS (bPublishToAD);
    if ( !bPublishToAD )
    {
        SendDlgItemMessage (IDC_USE_AD_CERT_FOR_REENROLLMENT, BM_SETCHECK, BST_UNCHECKED);
        m_rCertTemplate.SetCheckDSCert (false);
    }
	SetModified ();
    m_bIsDirty = true;
    EnableControls ();
}

void CTemplateGeneralPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateGeneralPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_GENERAL) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateGeneralPropertyPage::DoContextHelp\n");
}

void CTemplateGeneralPropertyPage::OnUseADCert() 
{
	bool bCheck = (BST_CHECKED == SendDlgItemMessage (IDC_USE_AD_CERT_FOR_REENROLLMENT, BM_GETCHECK) );
    m_rCertTemplate.SetCheckDSCert (bCheck);
    m_bIsDirty = true;
    SetModified ();
}

HRESULT CTemplateGeneralPropertyPage::EnumerateTemplates (
        IDirectoryObject* pTemplateContObj, 
        const CString& szFriendlyName, 
        bool& bFound)
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::EnumerateTemplates\n");
	CComPtr<IDirectorySearch>   spDsSearch;
	HRESULT hr = pTemplateContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spDsSearch);
		ADS_SEARCHPREF_INFO pSearchPref[1];
		DWORD dwNumPref = 1;

		pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
		pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

		hr = spDsSearch->SetSearchPreference(
				 pSearchPref,
				 dwNumPref
				 );
		if ( SUCCEEDED (hr) )
		{
			static const DWORD	cAttrs = 1; //2;
            static PWSTR	    rgszAttrList[cAttrs] = {L"displayName"}; //, L"cn"};
			ADS_SEARCH_HANDLE	hSearchHandle = 0;
            wstring             strQuery;
            ADS_SEARCH_COLUMN   Column;

            Column.pszAttrName = 0;
            strQuery = L"objectClass=pKICertificateTemplate";

			hr = spDsSearch->ExecuteSearch(
								 const_cast <PWSTR>(strQuery.c_str ()),
								 rgszAttrList,
								 cAttrs,
								 &hSearchHandle
								 );
			if ( SUCCEEDED (hr) )
			{
				while ((hr = spDsSearch->GetNextRow (hSearchHandle)) != S_ADS_NOMORE_ROWS )
				{
                    if (FAILED(hr))
                        continue;

					//
					// Getting current row's information
					//
					hr = spDsSearch->GetColumn(
							 hSearchHandle,
							 rgszAttrList[0],
							 &Column
							 );
					if ( SUCCEEDED (hr) )
					{
                        CString strDisplayName = Column.pADsValues->CaseIgnoreString;
                        if ( !_wcsicmp (strDisplayName, szFriendlyName) )
                        {
                            bFound = true;
                        }
						spDsSearch->FreeColumn (&Column);

                        if ( bFound )
                            break;
					}
					else if ( hr != E_ADS_COLUMN_NOT_SET )
					{
						break;
					}
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::GetColumn () failed: 0x%x\n", hr);
                    }
                }
			}
            else
            {
                _TRACE (0, L"IDirectorySearch::ExecuteSearch () failed: 0x%x\n", hr);
            }

            spDsSearch->CloseSearchHandle(hSearchHandle);
		}
        else
        {
            _TRACE (0, L"IDirectorySearch::SetSearchPreference () failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::EnumerateTemplates: 0x%x\n", hr);
    return hr;
}

HRESULT CTemplateGeneralPropertyPage::FindFriendlyNameInEnterpriseTemplates (
            const CString& szFriendlyName, 
            bool& bFound)
{
	_TRACE (1, L"Entering CTemplateGeneralPropertyPage::FindFriendlyNameInEnterpriseTemplates\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    HRESULT	hr = S_OK;
	CComPtr<IADsPathname> spPathname;
	//
	// Constructing the directory paths
	//
	hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);
		hr = spPathname->Set(const_cast <PWSTR> (CERTTMPL_LDAP),
							ADS_SETTYPE_PROVIDER);
		if ( SUCCEEDED (hr) )
		{
			//
			// Open the root DSE object
			//
			hr = spPathname->AddLeafElement(const_cast <PWSTR> (CERTTMPL_ROOTDSE));
			if ( SUCCEEDED (hr) )
			{
				BSTR bstrFullPath = 0;
				hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				if ( SUCCEEDED (hr) )
				{
					CComPtr<IADs> spRootDSEObject;
					VARIANT varNamingContext;


					hr = ADsGetObject (
			              bstrFullPath,
						  IID_PPV_ARG (IADs, &spRootDSEObject));
					if ( SUCCEEDED (hr) )
					{
                        ASSERT (!!spRootDSEObject);
						//
						// Get the configuration naming context from the root DSE
						//
						hr = spRootDSEObject->Get(const_cast <PWSTR> (CERTTMPL_CONFIG_NAMING_CONTEXT),
											 &varNamingContext);
						if ( SUCCEEDED (hr) )
						{
							hr = spPathname->Set(V_BSTR(&varNamingContext),
												ADS_SETTYPE_DN);
							if ( SUCCEEDED (hr) )
							{
                                hr = spPathname->AddLeafElement (L"CN=Services");
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = spPathname->AddLeafElement (L"CN=Public Key Services");
                                    if ( SUCCEEDED (hr) )
                                    {
                                        hr = spPathname->AddLeafElement (L"CN=Certificate Templates");
                                        if ( SUCCEEDED (hr) )
                                        {
				                            BSTR bstrCertTemplatePath = 0;
				                            hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrCertTemplatePath);
				                            if ( SUCCEEDED (hr) )
				                            {
					                            CComPtr<IDirectoryObject> spTemplateContObj;

					                            hr = ADsGetObject (
			                                          bstrCertTemplatePath,
						                              IID_PPV_ARG (IDirectoryObject, &spTemplateContObj));
					                            if ( SUCCEEDED (hr) )
					                            {
                                                    hr = EnumerateTemplates (spTemplateContObj, 
                                                                szFriendlyName, bFound);
                                                }
                                                else
                                                {
                                                    _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrCertTemplatePath, hr);
                                                }

                                                SysFreeString (bstrCertTemplatePath);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADs::Get (%s) failed: 0x%x\n", CERTTMPL_CONFIG_NAMING_CONTEXT, hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath, hr);
                    }
                }
            }
        }
    }
    else
        hr = E_POINTER;


	_TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::FindFriendlyNameInEnterpriseTemplates\n");
	return hr;
}

void CTemplateGeneralPropertyPage::OnKillfocusValidityEdit() 
{
    // NTRAID# 331178 Certtmpl: All Certificate Templates must enforce 
    // that the certificate Renewal Period < = 75% of the Validity Period
    int nMaxRenewalDays = (m_nValidityDays * 3) / 4;
    if ( nMaxRenewalDays < m_nRenewalDays )
    {
        // change without confirmation
        SetRenewalPeriod (nMaxRenewalDays, true);
        GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
    }
}

void CTemplateGeneralPropertyPage::OnKillfocusValidityUnits() 
{
    // NTRAID# 331178 Certtmpl: All Certificate Templates must enforce 
    // that the certificate Renewal Period < = 75% of the Validity Period
    int nMaxRenewalDays = (m_nValidityDays * 3) / 4;
    if ( nMaxRenewalDays < m_nRenewalDays )
    {
        // change without confirmation
        SetRenewalPeriod (nMaxRenewalDays, true);
        GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templategeneralpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateGeneralPropertyPage.h
//
//  Contents:   Definition of CTemplateGeneralPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEGeneralPROPERTYPAGE_H__C483A673_05AA_4185_8F37_5CB31AA23967__INCLUDED_)
#define AFX_TEMPLATEGeneralPROPERTYPAGE_H__C483A673_05AA_4185_8F37_5CB31AA23967__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateGeneralPropertyPage.h : header file
//
#include "CertTemplate.h"
#include "TemplatePropertySheet.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateGeneralPropertyPage dialog

class CTemplateGeneralPropertyPage : public CHelpPropertyPage
{
	// Construction
public:
	bool m_bIsDirty;
	LONG_PTR m_lNotifyHandle;
	CTemplateGeneralPropertyPage(CCertTemplate& rCertTemplate, 
            const CCertTmplComponentData* pCompData);
	virtual ~CTemplateGeneralPropertyPage();

    void SetAllocedSecurityInfo(LPSECURITYINFO pToBeReleased) 
    {
        m_pReleaseMe = pToBeReleased; 
    }

    void SetV2AuthPageNumber (int nPage)
    {
        m_nTemplateV2AuthPageNumber = nPage;
    }

    void SetV2RequestPageNumber (int nPage)
    {
        m_nTemplateV2RequestPageNumber = nPage;
    }
// Dialog Data
	//{{AFX_DATA(CTemplateGeneralPropertyPage)
	enum { IDD = IDD_TEMPLATE_GENERAL };
	CComboBox	m_validityUnits;
	CComboBox	m_renewalUnits;
	CString	m_strDisplayName;
	CString	m_strTemplateName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateGeneralPropertyPage)
	public:
	virtual BOOL OnApply();
    virtual void OnCancel();
    protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    bool ValidateTemplateName(const CString& m_szTemplateName);
    int SetRenewalPeriod (int nMaxRenewalDays, bool bSilent);
    HRESULT EnumerateTemplates (
                IDirectoryObject* pTemplateContObj, 
                const CString& szFriendlyName, 
                bool& bFound);
    HRESULT FindFriendlyNameInEnterpriseTemplates (
                const CString& szFriendlyName, 
                bool& bFound);

	virtual void DoContextHelp (HWND hWndControl);
	// Generated message map functions
	//{{AFX_MSG(CTemplateGeneralPropertyPage)
	afx_msg void OnChangeDisplayName();
	afx_msg void OnSelchangeRenewalUnits();
	afx_msg void OnSelchangeValidityUnits();
	afx_msg void OnChangeRenewalEdit();
	afx_msg void OnChangeValidityEdit();
	afx_msg void OnPublishToAd();
	afx_msg void OnUseADCert();
	afx_msg void OnChangeTemplateName();
	afx_msg void OnKillfocusValidityEdit();
	afx_msg void OnKillfocusValidityUnits();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
    virtual void EnableControls ();

    CCertTemplate& m_rCertTemplate;

private:
	PERIOD_TYPE     m_dwCurrentRenewalUnits;
	PERIOD_TYPE     m_dwCurrentValidityUnits;
	CString         m_strOriginalName;
    CString         m_strOriginalDisplayName;
    LPSECURITYINFO  m_pReleaseMe;
    int             m_nRenewalDays;
    int             m_nValidityDays;
    const CCertTmplComponentData* m_pCompData;
    int             m_nTemplateV2AuthPageNumber;
    int             m_nTemplateV2RequestPageNumber;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEGeneralPROPERTYPAGE_H__C483A673_05AA_4185_8F37_5CB31AA23967__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatepropertysheet.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplatePropertySheet.cpp
//
//  Contents:   Implementation of CTemplatePropertySheet
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "TemplatePropertySheet.h"
#include "SecurityPropertyPage.h"


#define WM_ADDSECURITYPAGE  WM_APP + 2000
#define WM_SETOKDEFAULT     WM_APP + 2001


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTemplatePropertySheet::CTemplatePropertySheet(
        LPCTSTR pszCaption, 
        CCertTemplate& rCertTemplate, 
        CWnd *pParentWnd, 
        UINT iSelectPage)
: CPropertySheet (pszCaption, pParentWnd, iSelectPage),
    m_rCertTemplate (rCertTemplate),
    m_pReleaseMe (0)
{
    m_rCertTemplate.AddRef ();
}

CTemplatePropertySheet::~CTemplatePropertySheet()
{
    m_rCertTemplate.Release ();
    if ( m_pReleaseMe )
        m_pReleaseMe->Release ();
}

BEGIN_MESSAGE_MAP(CTemplatePropertySheet, CPropertySheet)
    ON_MESSAGE (WM_ADDSECURITYPAGE, OnAddSecurityPage)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE (WM_SETOKDEFAULT, OnSetOKDefault)
END_MESSAGE_MAP()

LRESULT CTemplatePropertySheet::OnAddSecurityPage (WPARAM, LPARAM)
{
    _TRACE (1, L"Entering CTemplatePropertySheet::OnAddSecurityPage\n");
    LPSECURITYINFO pCertTemplateSecurity = NULL;

    HRESULT hr = CreateCertTemplateSecurityInfo (&m_rCertTemplate, 
            &pCertTemplateSecurity);
    if ( SUCCEEDED (hr) )
    {
        HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
        if ( hPage )
        {
		    if ( !SendMessage (PSM_ADDPAGE, 0, (LPARAM) hPage) )
		    {
			    DestroyPropertySheetPage (hPage);
                pCertTemplateSecurity->Release ();
                pCertTemplateSecurity = 0;
		    }
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
            pCertTemplateSecurity->Release ();
            pCertTemplateSecurity = 0;
        }
        _ASSERT (SUCCEEDED (hr));
    }

    m_pReleaseMe = pCertTemplateSecurity;

    _TRACE (-1, L"Leaving CTemplatePropertySheet::OnAddSecurityPage\n");
    return 0;
}

BOOL CTemplatePropertySheet::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplatePropertySheet::OnInitDialog ()\n");
	CPropertySheet::OnInitDialog();
	
    LONG    dwStyle = GetWindowLong (m_hWnd, GWL_STYLE);

    dwStyle |= DS_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_STYLE, dwStyle);
    
    dwStyle = GetWindowLong (m_hWnd, GWL_EXSTYLE);
    dwStyle |= /*WS_EX_DLGMODALFRAME |*/ WS_EX_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_EXSTYLE, dwStyle);

    // Add security page
    PostMessage (WM_ADDSECURITYPAGE, 0, 0);


    // Make the OK button the default
    PostMessage (WM_SETOKDEFAULT, 0, 0);

    _TRACE (-1, L"Leaving CTemplatePropertySheet::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CTemplatePropertySheet::OnSetOKDefault (WPARAM, LPARAM)
{
    // Make the OK button the default
    SendMessage (DM_SETDEFID, MAKEWPARAM (IDOK, 0), 0);
    SendDlgItemMessage (IDOK, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    SendDlgItemMessage (IDCANCEL, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));

    return 0;
}



BOOL CTemplatePropertySheet::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE(1, L"Entering CTemplatePropertySheet::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE(-1, L"Leaving CTemplatePropertySheet::OnHelp\n");

    return TRUE;
}

void CTemplatePropertySheet::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplatePropertySheet::DoContextHelp\n");
    const int	IDC_COMM_APPLYNOW = 12321;
	const int	IDH_COMM_APPLYNOW = 28447;
    const DWORD aHelpIDs_PropSheet[]=
    {
		IDC_COMM_APPLYNOW, IDH_COMM_APPLYNOW,
        0, 0
    };

    PWSTR  pszHelpFile = 0;
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_COMM_APPLYNOW:
        pszHelpFile = L"windows.hlp";
        break;

	default:
		// Display context help for a control
        pszHelpFile = const_cast<PWSTR> (GetContextHelpFile ());
		break;
	}

	if ( !::WinHelp (
			hWndControl,
			pszHelpFile,
			HELP_WM_HELP,
			(DWORD_PTR) aHelpIDs_PropSheet) )
	{
		_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
	}

    _TRACE(-1, L"Leaving CTemplatePropertySheet::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatepropertysheet.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplatePropertySheet.h
//
//  Contents:   interface for the CTemplatePropertySheet class.
//
//----------------------------------------------------------------------------

#if !defined(AFX_TEMPLATEPROPERTYSHEET_H__E4EE749E_308A_4F88_8DA0_97E1EF292D67__INCLUDED_)
#define AFX_TEMPLATEPROPERTYSHEET_H__E4EE749E_308A_4F88_8DA0_97E1EF292D67__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "CertTemplate.h"

class CTemplatePropertySheet : public CPropertySheet  
{
public:
	CTemplatePropertySheet(
            LPCTSTR pszCaption, 
            CCertTemplate& m_rCertTemplate, 
            CWnd *pParentWnd = NULL, 
            UINT iSelectPage = 0 );
	virtual ~CTemplatePropertySheet();

protected:
    virtual BOOL OnInitDialog();

	// Generated message map functions
	//{{AFX_MSG(CTemplatePropertySheet)
	//}}AFX_MSG
    afx_msg LRESULT OnAddSecurityPage (WPARAM, LPARAM);
    afx_msg LRESULT OnSetOKDefault (WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

    BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	virtual void DoContextHelp (HWND hWndControl);

private:
    CCertTemplate&  m_rCertTemplate;
    LPSECURITYINFO  m_pReleaseMe;
};

#endif // !defined(AFX_TEMPLATEPROPERTYSHEET_H__E4EE749E_308A_4F88_8DA0_97E1EF292D67__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev1subjectnamepropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1SubjectNamePropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV1SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
// TemplateSubjectNamePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV1SubjectNamePropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1SubjectNamePropertyPage property page

CTemplateV1SubjectNamePropertyPage::CTemplateV1SubjectNamePropertyPage(CCertTemplate& rCertTemplate) : 
    CHelpPropertyPage(CTemplateV1SubjectNamePropertyPage::IDD),
    m_rCertTemplate (rCertTemplate)
{
	//{{AFX_DATA_INIT(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_rCertTemplate.AddRef ();
}

CTemplateV1SubjectNamePropertyPage::~CTemplateV1SubjectNamePropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateV1SubjectNamePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV1SubjectNamePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1SubjectNamePropertyPage message handlers


BOOL CTemplateV1SubjectNamePropertyPage::OnInitDialog ()
{
    CHelpPropertyPage::OnInitDialog ();

    if ( m_rCertTemplate.RequireSubjectInRequest () )
        SendDlgItemMessage (IDC_REQUIRE_SUBJECT, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.SubjectNameIncludesEMail () )
        SendDlgItemMessage (IDC_EMAIL_NAME, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.IsMachineType () )
        SendDlgItemMessage (IDC_SUBJECT_MUST_BE_MACHINE, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_SUBJECT_MUST_BE_USER, BM_SETCHECK, BST_CHECKED);
    
    EnableControls ();
    return TRUE;
}

void CTemplateV1SubjectNamePropertyPage::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_REQUIRE_SUBJECT)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA)->EnableWindow (FALSE);
        GetDlgItem (IDC_EMAIL_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_MUST_BE_MACHINE)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_MUST_BE_USER)->EnableWindow (FALSE);
    }
}

void CTemplateV1SubjectNamePropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV1SubjectNamePropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V1_SUBJECT_NAME) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV1SubjectNamePropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev1requestpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1RequestPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV1RequestPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV1RequestPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV1RequestPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1RequestPropertyPage property page
enum {
    REQUEST_PURPOSE_SIGNATURE = 0,
    REQUEST_PURPOSE_ENCRYPTION,
    REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION
};

CTemplateV1RequestPropertyPage::CTemplateV1RequestPropertyPage(CCertTemplate& rCertTemplate) : 
    CHelpPropertyPage(CTemplateV1RequestPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate)
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::CTemplateV1RequestPropertyPage ()\n");
	//{{AFX_DATA_INIT(CTemplateV1RequestPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

    _TRACE (-1, L"Leaving CTemplateV1RequestPropertyPage::CTemplateV1RequestPropertyPage ()\n");
}

CTemplateV1RequestPropertyPage::~CTemplateV1RequestPropertyPage()
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::~CTemplateV1RequestPropertyPage ()\n");
   m_rCertTemplate.Release ();
    _TRACE (-1, L"Leaving CTemplateV1RequestPropertyPage::~CTemplateV1RequestPropertyPage ()\n");
}

void CTemplateV1RequestPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV1RequestPropertyPage)
	DDX_Control(pDX, IDC_PURPOSE_COMBO, m_purposeCombo);
	DDX_Control(pDX, IDC_CSP_LIST, m_CSPList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV1RequestPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV1RequestPropertyPage)
	ON_CBN_SELCHANGE(IDC_PURPOSE_COMBO, OnSelchangePurposeCombo)
	ON_BN_CLICKED(IDC_EXPORT_PRIVATE_KEY, OnExportPrivateKey)
	//}}AFX_MSG_MAP
    ON_CONTROL(CLBN_CHKCHANGE, IDC_CSP_LIST, OnCheckChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1RequestPropertyPage message handlers


BOOL CTemplateV1RequestPropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::OnInitDialog ()\n");
	CHelpPropertyPage::OnInitDialog();

    CString text;

    VERIFY (text.LoadString (IDS_SIGNATURE));
    int nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE);
        if ( m_rCertTemplate.HasKeySpecSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }
    
    VERIFY (text.LoadString (IDS_SIGNATURE_AND_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        // NTRAID# 269907  Certificate Template Snap-in: Should set the 
        // purpose of the template to both signature and encryption if 
        // CERT_DIGITAL_SIGNATURE_KEY_USAGE is set
        bool bHasDigitalSignature = false;
        m_rCertTemplate.GetDigitalSignature (bHasDigitalSignature);

        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () && 
                (bHasDigitalSignature || m_rCertTemplate.HasKeySpecSignature ()) )
            m_purposeCombo.SetCurSel (nIndex);
    }


    if ( SUCCEEDED (EnumerateCSPs ()) )
    {

    }

   
    if ( m_rCertTemplate.PrivateKeyIsExportable () )
        SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    _TRACE (-1, L"Leaving CTemplateV1RequestPropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTemplateV1RequestPropertyPage::EnableControls ()
{
    GetDlgItem (IDC_PURPOSE_COMBO)->EnableWindow (FALSE);

    int nCnt = m_CSPList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
        m_CSPList.Enable (nIndex, FALSE);

    GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (FALSE);
}



HRESULT CTemplateV1RequestPropertyPage::EnumerateCSPs()
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::EnumerateCSPs\n");
    HRESULT hr = S_OK;
    for (DWORD dwIndex = 0; ;dwIndex++)
    {
        DWORD   cbName = 0;
        DWORD   dwProvType = 0;

        if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType, NULL, &cbName) )
        {
            PWSTR  pszTypeName = new WCHAR[cbName];
            if ( pszTypeName )
            {
                if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType,
                        pszTypeName, &cbName) )
                {
                    int nIndex = m_CSPList.AddString (pszTypeName);
                    if ( nIndex < 0 )
                    {
                        _TRACE (0, L"AddString (%s) failed: %d\n", nIndex);
                        break;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError ());
                    _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
                    break;
                }

                delete [] pszTypeName;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
            break;
        }
    }

    int     nCSPIndex = 0;
    CString szCSP;
    while ( SUCCEEDED (m_rCertTemplate.GetCSP (nCSPIndex, szCSP)) )
    {
        int nIndex = m_CSPList.FindString (-1, szCSP);
        if ( CB_ERR != nIndex )
            m_CSPList.SetCheck (nIndex, BST_CHECKED);
        else
        {
            // was not found - add it
            nIndex = m_CSPList.AddString (szCSP);
            if ( nIndex >= 0 )
                m_CSPList.SetCheck (nIndex, BST_CHECKED);
        }
        nCSPIndex++;
    }

    _TRACE (-1, L"Entering CTemplateV1RequestPropertyPage::EnumerateCSPs: 0x%x\n", hr);
    return hr;
}



void CTemplateV1RequestPropertyPage::OnSelchangePurposeCombo() 
{
	int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
    {
        switch (m_purposeCombo.GetItemData (nIndex))
        {
        case REQUEST_PURPOSE_SIGNATURE:
            m_rCertTemplate.SetEncryptionSignature (false);
            m_rCertTemplate.SetKeySpecSignature (true);
            break;

        case REQUEST_PURPOSE_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (false);
            break;

        case REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (true);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }
    SetModified ();
	EnableControls ();
}

void CTemplateV1RequestPropertyPage::OnExportPrivateKey() 
{
    bool bMakeExportable = (BST_CHECKED == SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_GETCHECK));
	
    m_rCertTemplate.MakePrivateKeyExportable (bMakeExportable);
    SetModified ();
}


void CTemplateV1RequestPropertyPage::OnCheckChange() 
{
    int nSel = m_CSPList.GetCurSel ();
    if ( nSel >= 0 )
    {
        CString szCSPName;

        m_CSPList.GetText (nSel, szCSPName);

        if ( !szCSPName.IsEmpty () )
        {
            HRESULT hr = S_OK;
            if ( BST_CHECKED == m_CSPList.GetCheck (nSel) )
            {
                hr = m_rCertTemplate.ModifyCSPList (szCSPName, true); // add
            }
            else
            {
                hr = m_rCertTemplate.ModifyCSPList (szCSPName, false); // remove
            }
            if ( SUCCEEDED (hr) )
                SetModified ();
        }
    }
} 

void CTemplateV1RequestPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV1RequestPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V1_REQUEST) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV1RequestPropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev1requestpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1RequestPropertyPage.h
//
//  Contents:   Definition of CTemplateV1RequestPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV1REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
#define AFX_TEMPLATEV1REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV1RequestPropertyPage.h : header file
//
#include "CertTemplate.h"

class CSPCheckListBox : public CCheckListBox
{
public:
	CSPCheckListBox () : CCheckListBox () {};
	virtual ~CSPCheckListBox () {};
	virtual BOOL Create (DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
	{
		return CCheckListBox::Create (dwStyle, rect, pParentWnd, nID);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1RequestPropertyPage dialog

class CTemplateV1RequestPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV1RequestPropertyPage(CCertTemplate& rCertTemplate);
	virtual ~CTemplateV1RequestPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV1RequestPropertyPage)
	enum { IDD = IDD_TEMPLATE_V1_REQUEST };
	CComboBox	m_purposeCombo;
	CSPCheckListBox	m_CSPList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV1RequestPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	HRESULT EnumerateCSPs();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV1RequestPropertyPage)
	afx_msg void OnSelchangePurposeCombo();
	afx_msg void OnExportPrivateKey();
	//}}AFX_MSG
    afx_msg void OnCheckChange();
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
    virtual void EnableControls ();

private:
    CCertTemplate& m_rCertTemplate;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV1REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev1subjectnamepropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1SubjectNamePropertyPage.h
//
//  Contents:   Definition of CTemplateV1SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATESUBJECTNAMEPROPERTYPAGE_H__72F0D57F_221D_4A06_9C62_1BBB5800FBD2__INCLUDED_)
#define AFX_TEMPLATESUBJECTNAMEPROPERTYPAGE_H__72F0D57F_221D_4A06_9C62_1BBB5800FBD2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateSubjectNamePropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1SubjectNamePropertyPage dialog

class CTemplateV1SubjectNamePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV1SubjectNamePropertyPage(CCertTemplate& rCertTemplate);
	~CTemplateV1SubjectNamePropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV1SubjectNamePropertyPage)
	enum { IDD = IDD_TEMPLATE_V1_SUBJECT_NAME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV1SubjectNamePropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
    virtual BOOL OnInitDialog();
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CCertTemplate& m_rCertTemplate;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATESUBJECTNAMEPROPERTYPAGE_H__72F0D57F_221D_4A06_9C62_1BBB5800FBD2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2authenticationpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2AuthenticationPropertyPage.h
//
//  Contents:   Definition of CTemplateV2AuthenticationPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2AUTHENTICATIONPROPERTYPAGE_H__FA3C2A95_B56D_4948_8BB8_F825323B8C31__INCLUDED_)
#define AFX_TEMPLATEV2AUTHENTICATIONPROPERTYPAGE_H__FA3C2A95_B56D_4948_8BB8_F825323B8C31__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2AuthenticationPropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2AuthenticationPropertyPage dialog

class CTemplateV2AuthenticationPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2AuthenticationPropertyPage(CCertTemplate& rCertTemplate,
            bool& rbIsDirty);
	~CTemplateV2AuthenticationPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2AuthenticationPropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_AUTHENTICATION };
	CComboBox	m_applicationPolicyCombo;
	CComboBox	m_policyTypeCombo;
	CListBox	m_issuanceList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2AuthenticationPropertyPage)
	public:
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void ClearIssuanceList ();
    void EnablePolicyControls (BOOL& bEnable);
	virtual void DoContextHelp (HWND hWndControl);
    virtual BOOL OnInitDialog();
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2AuthenticationPropertyPage)
	afx_msg void OnAddApproval();
	afx_msg void OnRemoveApproval();
	afx_msg void OnChangeNumSigRequiredEdit();
	afx_msg void OnAllowReenrollment();
	afx_msg void OnPendAllRequests();
	afx_msg void OnSelchangeIssuancePolicies();
	afx_msg void OnSelchangePolicyTypes();
	afx_msg void OnSelchangeApplicationPolicies();
	afx_msg void OnDestroy();
	afx_msg void OnNumSigRequiredCheck();
	afx_msg void OnReenrollmentSameAsEnrollment();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool& m_rbIsDirty;
	int m_curApplicationSel;
    CCertTemplate& m_rCertTemplate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2AUTHENTICATIONPROPERTYPAGE_H__FA3C2A95_B56D_4948_8BB8_F825323B8C31__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2authenticationpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2AuthenticationPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2AuthenticationPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2AuthenticationPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "AddApprovalDlg.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST	    g_policyOIDList;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CTemplateV2AuthenticationPropertyPage property page

CTemplateV2AuthenticationPropertyPage::CTemplateV2AuthenticationPropertyPage(
        CCertTemplate& rCertTemplate,
        bool& rbIsDirty) 
    : CHelpPropertyPage(CTemplateV2AuthenticationPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_curApplicationSel (LB_ERR),
    m_rbIsDirty (rbIsDirty)
{
	//{{AFX_DATA_INIT(CTemplateV2AuthenticationPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CTemplateV2AuthenticationPropertyPage::~CTemplateV2AuthenticationPropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateV2AuthenticationPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2AuthenticationPropertyPage)
	DDX_Control(pDX, IDC_APPLICATION_POLICIES, m_applicationPolicyCombo);
	DDX_Control(pDX, IDC_POLICY_TYPES, m_policyTypeCombo);
	DDX_Control(pDX, IDC_ISSUANCE_POLICIES, m_issuanceList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2AuthenticationPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2AuthenticationPropertyPage)
	ON_BN_CLICKED(IDC_ADD_APPROVAL, OnAddApproval)
	ON_BN_CLICKED(IDC_REMOVE_APPROVAL, OnRemoveApproval)
	ON_EN_CHANGE(IDC_NUM_SIG_REQUIRED_EDIT, OnChangeNumSigRequiredEdit)
	ON_BN_CLICKED(IDC_REENROLLMENT_REQUIRES_VALID_CERT, OnAllowReenrollment)
	ON_BN_CLICKED(IDC_PEND_ALL_REQUESTS, OnPendAllRequests)
	ON_LBN_SELCHANGE(IDC_ISSUANCE_POLICIES, OnSelchangeIssuancePolicies)
	ON_CBN_SELCHANGE(IDC_POLICY_TYPES, OnSelchangePolicyTypes)
	ON_CBN_SELCHANGE(IDC_APPLICATION_POLICIES, OnSelchangeApplicationPolicies)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_NUM_SIG_REQUIRED_CHECK, OnNumSigRequiredCheck)
	ON_BN_CLICKED(IDC_REENROLLMENT_SAME_AS_ENROLLMENT, OnReenrollmentSameAsEnrollment)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2AuthenticationPropertyPage message handlers
enum {
    POLICY_TYPE_ISSUANCE = 0,
    POLICY_TYPE_APPLICATION,
    POLICY_TYPE_APPLICATION_AND_ISSUANCE
};

BOOL CTemplateV2AuthenticationPropertyPage::OnInitDialog()
{
    _TRACE (1, L"Entering CTemplateV2AuthenticationPropertyPage::OnInitDialog\n");
    CHelpPropertyPage::OnInitDialog ();

    // Initialize Application Policy combo
    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            // If this is the Application OID dialog, show only application 
            // OIDS, otherwise if this is the Issuance OID dialog, show only
            // issuance OIDs
            if ( pPolicyOID->IsApplicationOID () )
            {
                // Bug 262925 CERTSRV: "All Application Policies should be 
                // removed from  Issuance Requirements tab for a cert template
                if ( 0 != strcmp (szOID_ANY_APPLICATION_POLICY, pPolicyOID->GetOIDA ()) )
                {
                    int nIndex = m_applicationPolicyCombo.AddString (pPolicyOID->GetDisplayName ());
                    if ( nIndex >= 0 )
                    {
                        LPSTR   pszOID = new CHAR[strlen (pPolicyOID->GetOIDA ())+1];
                        if ( pszOID )
                        {
                            strcpy (pszOID, pPolicyOID->GetOIDA ());
                            m_applicationPolicyCombo.SetItemDataPtr (nIndex, pszOID);
                        }
                    }
                }
            }
        }
    }

    // Check for and add pending requests
    if ( m_rCertTemplate.PendAllRequests () )
        SendDlgItemMessage (IDC_PEND_ALL_REQUESTS, BM_SETCHECK, BST_CHECKED);

    // Get the RA Issuance Policies and add them to the issuance list
    int     nRAPolicyIndex = 0;
    CString szRAPolicyOID;
    while ( SUCCEEDED (m_rCertTemplate.GetRAIssuancePolicy (nRAPolicyIndex, szRAPolicyOID)) )
    {
        CString policyName;
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szRAPolicyOID,  // wide-character string
              (int) wcslen (szRAPolicyOID),  // number of chars in string
              0,                        // buffer for new string
              0,                        // size of buffer
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            nLen++; // account for Null terminator
            PSTR    pszAnsiBuf = new CHAR[nLen];
            if ( pszAnsiBuf )
            {
                ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szRAPolicyOID, // wide-character string
                        (int) wcslen (szRAPolicyOID), // number of chars in string
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
		            if ( MyGetOIDInfoA (policyName, pszAnsiBuf) )
		            {
                        int nIndex = m_issuanceList.AddString (policyName);
                        if ( nIndex >= 0 )
                            m_issuanceList.SetItemData (nIndex, (DWORD_PTR) pszAnsiBuf);
		            }
                }
                else
                {
                    _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                            (PCWSTR) szRAPolicyOID, GetLastError ());
                }
            }
            else
                break;
        }
        else
        {
            _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                    (PCWSTR) szRAPolicyOID, GetLastError ());
        }

        nRAPolicyIndex++;
    }

    // Get the RA Application policy and select it
    // in the application combo
    nRAPolicyIndex = 0;
    while ( SUCCEEDED (m_rCertTemplate.GetRAApplicationPolicy (nRAPolicyIndex, szRAPolicyOID)) )
    {
        CString policyName;
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szRAPolicyOID,  // wide-character string
              (int) wcslen (szRAPolicyOID),  // number of chars in string
              0,                        // buffer for new string
              0,                        // size of buffer
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            nLen++; // account for Null terminator
            PSTR    pszAnsiBuf = new CHAR[nLen];
            if ( pszAnsiBuf )
            {
                ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szRAPolicyOID, // wide-character string
                        (int) wcslen (szRAPolicyOID), // number of chars in string
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
		            if ( MyGetOIDInfoA (policyName, pszAnsiBuf) )
		            {
                        int nIndex = m_applicationPolicyCombo.FindStringExact (-1, policyName);
                        if ( nIndex >= 0 )
                            m_applicationPolicyCombo.SetCurSel (nIndex);
                        m_curApplicationSel = nIndex;
                        break;
		            }
                }
                else
                {
                    _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                            (PCWSTR) szRAPolicyOID, GetLastError ());
                }
                delete [] pszAnsiBuf;
            }
            else
                break;
        }
        else
        {
            _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                    (PCWSTR) szRAPolicyOID, GetLastError ());
        }

        nRAPolicyIndex++;
    }

    // Initialize "Policy Type" combo box
    CString text;
    int nApplicationSel = m_applicationPolicyCombo.GetCurSel ();
    int nIssuanceCnt = m_issuanceList.GetCount ();

    VERIFY (text.LoadString (IDS_ISSUANCE_POLICY));
    int nIndex = m_policyTypeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_policyTypeCombo.SetItemData (nIndex, POLICY_TYPE_ISSUANCE);
        if ( LB_ERR == nApplicationSel && nIssuanceCnt > 0 )
            m_policyTypeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_APPLICATION_POLICY));
    nIndex = m_policyTypeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_policyTypeCombo.SetItemData (nIndex, POLICY_TYPE_APPLICATION);
        if ( nApplicationSel >= 0 && 0 == nIssuanceCnt )
            m_policyTypeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_APPLICATION_AND_ISSUANCE_POLICY));
    nIndex = m_policyTypeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_policyTypeCombo.SetItemData (nIndex, POLICY_TYPE_APPLICATION_AND_ISSUANCE);
        if ( nApplicationSel >= 0 && nIssuanceCnt > 0 )
            m_policyTypeCombo.SetCurSel (nIndex);
    }

    
    DWORD   dwNumSignatures = 0;
    if ( SUCCEEDED (m_rCertTemplate.GetRANumSignaturesRequired (dwNumSignatures)) )
        SetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT, dwNumSignatures);

    if ( dwNumSignatures > 0 )
        SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.ReenrollmentValidWithPreviousApproval () )
        SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, BM_SETCHECK, BST_CHECKED);
    else 
        SendDlgItemMessage (IDC_REENROLLMENT_SAME_AS_ENROLLMENT, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    _TRACE (-1, L"Leaving CTemplateV2AuthenticationPropertyPage::OnInitDialog\n");
    return TRUE;
}

void CTemplateV2AuthenticationPropertyPage::OnAddApproval() 
{
    // Create the list of already added approvals.  These will not be displayed
    // in the Add Approval dialog.
	int		nCnt = m_issuanceList.GetCount ();
    PSTR*   paszUsedApprovals = 0;

	
    // allocate an array of PSTR pointers and add each item.
    // Set the last to NULL
    if ( nCnt )
    {
        paszUsedApprovals = new PSTR[nCnt+1];
        if ( paszUsedApprovals )
        {
            ::ZeroMemory (paszUsedApprovals, sizeof (PSTR) * (nCnt+1));
	        while (--nCnt >= 0)
	        {
                PSTR pszPolicyOID = (PSTR) m_issuanceList.GetItemData (nCnt);
                if ( pszPolicyOID )
                {
                    PSTR pNewStr = new CHAR[strlen (pszPolicyOID) + 1];
                    if ( pNewStr )
                    {
                        strcpy (pNewStr, pszPolicyOID);
                        paszUsedApprovals[nCnt] = pNewStr;
                    }
                    else
                        break;
                }
            }
        }
    }

	CAddApprovalDlg dlg (this, paszUsedApprovals);

    CThemeContextActivator activator;
    if ( IDOK == dlg.DoModal () && dlg.m_paszReturnedApprovals )
    {
        for (int nIndex = 0; dlg.m_paszReturnedApprovals[nIndex]; nIndex++)
        {
            SetModified ();
            m_rbIsDirty = true;

            // Add to template RA list
            CString szRAPolicyOID (dlg.m_paszReturnedApprovals[nIndex]);
            HRESULT hr = m_rCertTemplate.ModifyRAIssuancePolicyList (szRAPolicyOID, true);
            ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                // Add to list
                CString  policyName;
		        if ( MyGetOIDInfoA (policyName, dlg.m_paszReturnedApprovals[nIndex]) )
		        {
                    int nAddedIndex = m_issuanceList.AddString (policyName);
                    if ( nAddedIndex >= 0 )
                    {
                        PSTR    pszAnsiBuf = new CHAR[strlen (dlg.m_paszReturnedApprovals[nIndex]) + 1];
                        if ( pszAnsiBuf )
                        {
                            strcpy (pszAnsiBuf, dlg.m_paszReturnedApprovals[nIndex]);
                            m_issuanceList.SetItemData (nAddedIndex, (DWORD_PTR) pszAnsiBuf);
                        }
                    }
		        }
            }
        }
    }

    if ( paszUsedApprovals )
    {
        for (int nIndex = 0; paszUsedApprovals[nIndex]; nIndex++)
            delete [] paszUsedApprovals[nIndex];
        delete [] paszUsedApprovals;
    }

    EnableControls ();
}


void CTemplateV2AuthenticationPropertyPage::OnRemoveApproval() 
{
    int     nSelCnt = m_issuanceList.GetSelCount ();
    int*    pnSelIndexes = new int[nSelCnt];
    if ( pnSelIndexes )
    {
        m_issuanceList.GetSelItems (nSelCnt, pnSelIndexes);
        for (int nIndex = nSelCnt-1; nIndex >= 0; nIndex--)
        {
            PSTR pszPolicyOID = (PSTR) m_issuanceList.GetItemData (pnSelIndexes[nIndex]);
            if ( pszPolicyOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAIssuancePolicyList (pszPolicyOID, false);
                if ( SUCCEEDED (hr) )
                    VERIFY (m_issuanceList.DeleteString (pnSelIndexes[nIndex]));
                else
                {
                    CString text;
                    CString caption;
                    CThemeContextActivator activator;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    text.FormatMessage (IDS_CANNOT_DELETE_ISSUANCE_RA, GetSystemMessage (hr));
                    MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                    delete [] pszPolicyOID;
                }
            }
        }

        delete [] pnSelIndexes;
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2AuthenticationPropertyPage::EnableControls()
{
    if ( m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_PEND_ALL_REQUESTS)->EnableWindow (FALSE);
        m_policyTypeCombo.EnableWindow (FALSE);
        m_issuanceList.EnableWindow (FALSE);
        m_applicationPolicyCombo.EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_NUM_SIG_REQUIRED_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_REENROLLMENT_REQUIRES_VALID_CERT)->EnableWindow (FALSE);
        GetDlgItem (IDC_REENROLLMENT_SAME_AS_ENROLLMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_REENROLLMENT_REQUIRES_VALID_CERT)->EnableWindow (FALSE);
        GetDlgItem (IDC_REENROLLMENT_SAME_AS_ENROLLMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_NUM_SIG_REQUIRED_CHECK)->EnableWindow (FALSE);
    }
    else
    {
	    BOOL bEnable = (BST_CHECKED == SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, BM_GETCHECK));

        EnablePolicyControls (bEnable);

        if ( bEnable )
        {
            int nCnt = m_issuanceList.GetCount ();
            int nSel = m_issuanceList.GetSelCount ();
    

            switch (m_policyTypeCombo.GetItemData (m_policyTypeCombo.GetCurSel ()))
            {
            case POLICY_TYPE_ISSUANCE:
                m_issuanceList.EnableWindow (TRUE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (TRUE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (TRUE);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (TRUE);
                m_applicationPolicyCombo.EnableWindow (FALSE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (FALSE);
                break;

            case POLICY_TYPE_APPLICATION:
                m_issuanceList.EnableWindow (FALSE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (FALSE);
                m_applicationPolicyCombo.EnableWindow (TRUE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (TRUE);
                break;

            case POLICY_TYPE_APPLICATION_AND_ISSUANCE:
                m_issuanceList.EnableWindow (TRUE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (TRUE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (nSel > 0 && nCnt > nSel);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (TRUE);
                m_applicationPolicyCombo.EnableWindow (TRUE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (TRUE);
                break;

            default: // nothing selected
                m_issuanceList.EnableWindow (FALSE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (FALSE);
                m_applicationPolicyCombo.EnableWindow (FALSE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (FALSE);
                break;
            }
        }
    }
}

void CTemplateV2AuthenticationPropertyPage::OnChangeNumSigRequiredEdit() 
{
    static bool bProcessingOnChangeNumSigRequiredEdit = false;

    if ( !bProcessingOnChangeNumSigRequiredEdit )
    {
        bProcessingOnChangeNumSigRequiredEdit = true;
        CString szText;
        
        if ( GetDlgItemText (IDC_NUM_SIG_REQUIRED_EDIT, szText) > 0 )
        {
            DWORD   dwNumSignatures = GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT);
            DWORD   dwFormerNumSignatures = 0;
            m_rCertTemplate.GetRANumSignaturesRequired (dwFormerNumSignatures);

            if ( dwFormerNumSignatures != dwNumSignatures )
            {
                HRESULT hr = m_rCertTemplate.SetRANumSignaturesRequired (dwNumSignatures);
                if ( SUCCEEDED (hr) )
                {
                    if ( 0 == dwFormerNumSignatures || 
                            0 == dwNumSignatures )
                    {
                        OnNumSigRequiredCheck();
                    }

                    SetModified ();
                    m_rbIsDirty = true;
                }
            }
        }

        bProcessingOnChangeNumSigRequiredEdit = false;
    }
}

void CTemplateV2AuthenticationPropertyPage::OnAllowReenrollment() 
{
    HRESULT hr = m_rCertTemplate.SetReenrollmentValidWithPreviousApproval (
            BST_CHECKED == SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, BM_GETCHECK));
    if ( SUCCEEDED (hr) )
    {
        SetModified ();
        m_rbIsDirty = true;
    }
}


void CTemplateV2AuthenticationPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2AuthenticationPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_AUTHENTICATION) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2AuthenticationPropertyPage::DoContextHelp\n");
}

void CTemplateV2AuthenticationPropertyPage::OnPendAllRequests() 
{
	m_rCertTemplate.SetPendAllRequests (
            BST_CHECKED == SendDlgItemMessage (IDC_PEND_ALL_REQUESTS, BM_GETCHECK));
	SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2AuthenticationPropertyPage::OnSelchangeIssuancePolicies() 
{
    EnableControls ();	
}

void CTemplateV2AuthenticationPropertyPage::OnSelchangePolicyTypes() 
{
    SetModified ();
    m_rbIsDirty = true;

    switch (m_policyTypeCombo.GetItemData (m_policyTypeCombo.GetCurSel ()))
    {
    case POLICY_TYPE_ISSUANCE:
        {
            // Unselect the application policy and inform the user that
            // an issuance policy must be added if there aren't any
            int nSel = m_applicationPolicyCombo.GetCurSel ();
            if ( nSel >= 0 )
            {
                PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nSel);
                if ( pszOID )
                {
                    HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, false);
                    _ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        SetModified ();
                        m_rbIsDirty = true;
                    }
                }
                m_applicationPolicyCombo.SetCurSel (LB_ERR);
                m_curApplicationSel = LB_ERR;
            }
        }
        break;

    case POLICY_TYPE_APPLICATION:
        {
            // Select an application policy, if necessary and remove
            // the issuance policies
            int nSel = m_applicationPolicyCombo.GetCurSel ();
            if ( LB_ERR == nSel )
            {
                m_applicationPolicyCombo.SetCurSel (0);
                nSel = m_applicationPolicyCombo.GetCurSel ();
                m_curApplicationSel = nSel;
                if ( nSel >= 0 )
                {
                    PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nSel);
                    if ( pszOID )
                    {
                        HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                        _ASSERT (SUCCEEDED (hr));
                        if ( SUCCEEDED (hr) )
                        {
                            SetModified ();
                            m_rbIsDirty = true;
                        }
                    }
                }
            }

            ClearIssuanceList ();
        }
        break;

    case POLICY_TYPE_APPLICATION_AND_ISSUANCE:
        {
            // Select an application policy, if necessary and inform the user
            // that an issuance policy must be added, if there aren't any.
            int nSel = m_applicationPolicyCombo.GetCurSel ();
            if ( LB_ERR == nSel )
            {
                m_applicationPolicyCombo.SetCurSel (0);
                nSel = m_applicationPolicyCombo.GetCurSel ();
                m_curApplicationSel = nSel;
                if ( nSel >= 0 )
                {
                    PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nSel);
                    if ( pszOID )
                    {
                        HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                        _ASSERT (SUCCEEDED (hr));
                        if ( SUCCEEDED (hr) )
                        {
                            SetModified ();
                            m_rbIsDirty = true;
                        }
                    }
                }
            }
        }
        break;

    default: // nothing selected
        break;
    }
    EnableControls ();	
}

void CTemplateV2AuthenticationPropertyPage::OnSelchangeApplicationPolicies() 
{
    int nNewSel = m_applicationPolicyCombo.GetCurSel ();
    
    // Remove the old application OID and add the new one
	if ( m_curApplicationSel != nNewSel )
    {
        if ( LB_ERR != m_curApplicationSel )
        {
            LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (m_curApplicationSel);
            if ( pszOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, false);
                _ASSERT (SUCCEEDED (hr));
            }
        }

        if ( LB_ERR != nNewSel )
        {
            LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (nNewSel);
            if ( pszOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                _ASSERT (SUCCEEDED (hr));
            }
        }

        SetModified ();
        m_rbIsDirty = true;

        m_curApplicationSel = nNewSel;
    }
}

void CTemplateV2AuthenticationPropertyPage::OnDestroy() 
{
    int nCnt = m_issuanceList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        PSTR pszBuf = (PSTR) m_issuanceList.GetItemData (nIndex);
        if ( pszBuf )
            delete [] pszBuf;
    }

    
    nCnt = m_applicationPolicyCombo.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nIndex);
        if ( pszOID )
            delete [] pszOID;
    }

	CHelpPropertyPage::OnDestroy();
}

void CTemplateV2AuthenticationPropertyPage::OnNumSigRequiredCheck() 
{
    static bProcessingOnNumSigRequiredCheck = false;

    if ( !bProcessingOnNumSigRequiredCheck ) // to prevent reentrancy
    {
        bProcessingOnNumSigRequiredCheck = true;
        if ( BST_UNCHECKED == SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, BM_GETCHECK) )
        {
            if ( 0 != GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) )
                SetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT, 0);

            // NTRAID# 369551 CertTmpl:UI does not clean up changed settings
            // clear out policy type combo, application policy combo and issuance
            // policy list
            m_policyTypeCombo.SetCurSel (-1);
            m_policyTypeCombo.Clear ();

            // Clear application policy
            int nCurSel = m_applicationPolicyCombo.GetCurSel ();
            if ( LB_ERR != nCurSel )
            {
                // Remove the old application OID
                LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (nCurSel);
                if ( pszOID )
                {
                    HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, false);
                    _ASSERT (SUCCEEDED (hr));
                }
            }
            m_applicationPolicyCombo.SetCurSel (-1);
            m_applicationPolicyCombo.Clear ();
    
            // Clear issuance policy
            ClearIssuanceList ();
        }
        else if ( 0 == GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) )
            SetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT, 1);

        if ( GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) > 0 )
        {
            m_policyTypeCombo.SetCurSel (0);
            m_applicationPolicyCombo.SetCurSel (0);
            LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (0);
            if ( pszOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                _ASSERT (SUCCEEDED (hr));
            }
        }

        EnableControls ();

        bProcessingOnNumSigRequiredCheck = false;
    }
}

void CTemplateV2AuthenticationPropertyPage::EnablePolicyControls (BOOL& bEnable)
{
    GetDlgItem (IDC_NUM_SIG_REQUIRED_EDIT)->EnableWindow (bEnable);

    if ( bEnable )
    {
        if ( GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) < 1 )
            bEnable = false;
    }

    GetDlgItem (IDC_POLICY_TYPES_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_POLICY_TYPES)->EnableWindow (bEnable);
    GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_APPLICATION_POLICIES)->EnableWindow (bEnable);
    GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_ISSUANCE_POLICIES)->EnableWindow (bEnable);
    GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (bEnable);
    GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (bEnable);
}


BOOL CTemplateV2AuthenticationPropertyPage::OnKillActive() 
{
    switch (m_policyTypeCombo.GetItemData (m_policyTypeCombo.GetCurSel ()))
    {
    case POLICY_TYPE_ISSUANCE:
        {
            // Inform the user that
            // an issuance policy must be added if there aren't any
            m_rCertTemplate.IssuancePoliciesRequired (
                    (0 == m_issuanceList.GetCount ()) ? true : false); 
        }
        break;

    case POLICY_TYPE_APPLICATION:
        m_rCertTemplate.IssuancePoliciesRequired (false);
        break;

    case POLICY_TYPE_APPLICATION_AND_ISSUANCE:
        {
            // Inform the user
            // that an issuance policy must be added, if there aren't any.
            m_rCertTemplate.IssuancePoliciesRequired (
                    (0 == m_issuanceList.GetCount ()) ? true : false); 
        }
        break;

    default: // nothing selected
        break;
    }
	
	return CHelpPropertyPage::OnKillActive();
}

void CTemplateV2AuthenticationPropertyPage::OnReenrollmentSameAsEnrollment() 
{
    HRESULT hr = m_rCertTemplate.SetReenrollmentValidWithPreviousApproval (
            BST_CHECKED == SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, BM_GETCHECK));
    if ( SUCCEEDED (hr) )
    {
        SetModified ();
        m_rbIsDirty = true;
    }
}

void CTemplateV2AuthenticationPropertyPage::ClearIssuanceList ()
{
    int nCnt = m_issuanceList.GetCount ();
    for (int nIndex = nCnt-1; nIndex >= 0; nIndex--)
    {
        LPSTR pszOID = (LPSTR) m_issuanceList.GetItemDataPtr (nIndex);
        if ( pszOID )
        {
            HRESULT hr = m_rCertTemplate.ModifyRAIssuancePolicyList (pszOID, false);
            if ( SUCCEEDED (hr) )
            {
                m_issuanceList.DeleteString (nIndex);
                delete [] pszOID;
                SetModified ();
                m_rbIsDirty = true;
            }
            else
            {
                _ASSERT (0);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2requestpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2RequestPropertyPage.h
//
//  Contents:   Definition of CTemplateV2RequestPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
#define AFX_TEMPLATEV2REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2RequestPropertyPage.h : header file
//
#include "CertTemplate.h"
#include "TemplateV1RequestPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2RequestPropertyPage dialog

class CTemplateV2RequestPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2RequestPropertyPage(CCertTemplate& rCertTemplate, bool& rbIsDirty);
	virtual ~CTemplateV2RequestPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2RequestPropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_REQUEST };
	CComboBox	m_minKeySizeCombo;
	CComboBox	m_purposeCombo;
	CSPCheckListBox	m_CSPListbox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2RequestPropertyPage)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void AddKeySizeToCombo (DWORD dwValue, PCWSTR strValue, DWORD dwSizeToSelect);
	HRESULT EnumerateCSPs(DWORD dwMinKeySize);
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2RequestPropertyPage)
	afx_msg void OnSelchangePurposeCombo();
	afx_msg void OnExportPrivateKey();
	afx_msg void OnArchiveKeyCheck();
	afx_msg void OnIncludeSymmetricAlgorithmsCheck();
	afx_msg void OnSelchangeMinimumKeysizeValue();
	afx_msg void OnUserInputRequiredForAutoenrollment();
	afx_msg void OnDeletePermanently();
	afx_msg void OnDestroy();
	//}}AFX_MSG
    afx_msg void OnCheckChange();
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
    virtual void EnableControls ();
    HRESULT CSPGetMaxKeySupported (
                PCWSTR pszProvider, 
                DWORD dwProvType, 
                DWORD& dwSigMaxKey, 
                DWORD& dwKeyExMaxKey);
    void NormalizeCSPListBox (DWORD dwMinKeySize, bool bSetChecks);

private:
	bool&           m_rbIsDirty;
    CCertTemplate&  m_rCertTemplate;
    int             m_nProvDSSCnt;

    class CT_CSP_DATA
    {
    public:
        CT_CSP_DATA (PCWSTR pszName, DWORD dwProvType, DWORD dwSigMaxKeySize, DWORD dwKeyExMaxKeySize)
            : m_szName (pszName),
            m_dwProvType (dwProvType),
            m_dwSigMaxKeySize (dwSigMaxKeySize),
            m_dwKeyExMaxKeySize (dwKeyExMaxKeySize)
        {
        }

        CString m_szName;
        DWORD   m_dwProvType;
        DWORD   m_dwSigMaxKeySize;
        DWORD   m_dwKeyExMaxKeySize;
    };

    typedef CTypedPtrList<CPtrList, CT_CSP_DATA*> CSP_LIST;
    CSP_LIST        m_CSPList;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2requestpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2RequestPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2RequestPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2RequestPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV2RequestPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2RequestPropertyPage property page
enum {
    REQUEST_PURPOSE_SIGNATURE = 0,
    REQUEST_PURPOSE_ENCRYPTION,
    REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION
};


CTemplateV2RequestPropertyPage::CTemplateV2RequestPropertyPage(
        CCertTemplate& rCertTemplate, bool& rbIsDirty) : 
    CHelpPropertyPage(CTemplateV2RequestPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_rbIsDirty (rbIsDirty),
    m_nProvDSSCnt (0)
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::CTemplateV2RequestPropertyPage ()\n");
	//{{AFX_DATA_INIT(CTemplateV2RequestPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::CTemplateV2RequestPropertyPage ()\n");
}

CTemplateV2RequestPropertyPage::~CTemplateV2RequestPropertyPage()
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::~CTemplateV2RequestPropertyPage ()\n");

    while ( !m_CSPList.IsEmpty () )
    {
        CT_CSP_DATA* pCSPData = m_CSPList.RemoveHead ();
        if ( pCSPData )
            delete pCSPData;
    }

   m_rCertTemplate.Release ();
    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::~CTemplateV2RequestPropertyPage ()\n");
}

void CTemplateV2RequestPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2RequestPropertyPage)
	DDX_Control(pDX, IDC_MINIMUM_KEYSIZE_VALUE, m_minKeySizeCombo);
	DDX_Control(pDX, IDC_PURPOSE_COMBO, m_purposeCombo);
	DDX_Control(pDX, IDC_CSP_LIST, m_CSPListbox);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2RequestPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2RequestPropertyPage)
	ON_CBN_SELCHANGE(IDC_PURPOSE_COMBO, OnSelchangePurposeCombo)
	ON_BN_CLICKED(IDC_EXPORT_PRIVATE_KEY, OnExportPrivateKey)
	ON_BN_CLICKED(IDC_ARCHIVE_KEY_CHECK, OnArchiveKeyCheck)
	ON_BN_CLICKED(IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, OnIncludeSymmetricAlgorithmsCheck)
	ON_CBN_SELCHANGE(IDC_MINIMUM_KEYSIZE_VALUE, OnSelchangeMinimumKeysizeValue)
	ON_BN_CLICKED(IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT, OnUserInputRequiredForAutoenrollment)
	ON_BN_CLICKED(IDC_DELETE_PERMANENTLY, OnDeletePermanently)
	//}}AFX_MSG_MAP
    ON_CONTROL(CLBN_CHKCHANGE, IDC_CSP_LIST, OnCheckChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2RequestPropertyPage message handlers


BOOL CTemplateV2RequestPropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::OnInitDialog ()\n");
	CHelpPropertyPage::OnInitDialog();

    CString text;

    VERIFY (text.LoadString (IDS_SIGNATURE));
    int nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE);
        if ( m_rCertTemplate.HasKeySpecSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }
    
    VERIFY (text.LoadString (IDS_SIGNATURE_AND_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        // NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
        // option list with v2 templates that have ENC and SIG as purpose.
        bool bHasDigitalSignature = false;

        m_rCertTemplate.GetDigitalSignature (bHasDigitalSignature);

        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () && 
                (bHasDigitalSignature || m_rCertTemplate.HasKeySpecSignature ()) )
            m_purposeCombo.SetCurSel (nIndex);
    }



    // Initialize minimum key size combo box- values in powers of 2 from 512 to 16384
    DWORD   dwMinKeySize = 0;
    m_rCertTemplate.GetMinimumKeySize (dwMinKeySize);
    AddKeySizeToCombo(512, L"512", dwMinKeySize);
    AddKeySizeToCombo(768, L"768", dwMinKeySize);
    AddKeySizeToCombo(1024, L"1024", dwMinKeySize);
    AddKeySizeToCombo(2048, L"2048", dwMinKeySize);
    AddKeySizeToCombo(4096, L"4096", dwMinKeySize);
    AddKeySizeToCombo(8192, L"8192", dwMinKeySize);
    AddKeySizeToCombo(16384, L"16384", dwMinKeySize);

    if ( SUCCEEDED (EnumerateCSPs (dwMinKeySize)) )
    {

    }

    if ( m_rCertTemplate.PrivateKeyIsExportable () )
        SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AllowPrivateKeyArchival () )
        SendDlgItemMessage (IDC_ARCHIVE_KEY_CHECK, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.IncludeSymmetricAlgorithms () )
        SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_SETCHECK, BST_CHECKED);

    GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->ShowWindow (SW_SHOW);
    GetDlgItem (IDC_MINIMUM_KEYSIZE_VALUE)->ShowWindow (SW_SHOW);
    GetDlgItem (IDC_MINIMUM_KEYSIZE_LABEL)->ShowWindow (SW_SHOW);
    GetDlgItem (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK)->ShowWindow (SW_SHOW);


    if ( m_rCertTemplate.UserInteractionRequired () )
        SendDlgItemMessage (IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT, BM_SETCHECK, BST_CHECKED);
      
    if ( m_rCertTemplate.IsMachineType () || m_rCertTemplate.SubjectIsCA () ||
            m_rCertTemplate.SubjectIsCrossCA () )
    {
        GetDlgItem (IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT)->EnableWindow (FALSE);
    }

    if ( m_rCertTemplate.RemoveInvalidCertFromPersonalStore () )
        SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTemplateV2RequestPropertyPage::EnableControls ()
{
    if (  m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_PURPOSE_COMBO)->EnableWindow (FALSE);

        int nCnt = m_CSPListbox.GetCount ();
        for (int nIndex = 0; nIndex < nCnt; nIndex++)
            m_CSPListbox.Enable (nIndex, FALSE);

        GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (FALSE);

        //version 2 fields
        GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->EnableWindow (FALSE);
        GetDlgItem (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK)->EnableWindow (FALSE);
        SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_SETCHECK, BST_UNCHECKED);
        GetDlgItem (IDC_MINIMUM_KEYSIZE_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_MINIMUM_KEYSIZE_VALUE)->EnableWindow (FALSE);
        GetDlgItem (IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_DELETE_PERMANENTLY)->EnableWindow (FALSE);
    }
    else
    {
        BOOL bEncryptionSelected = FALSE; 
	    int nIndex = m_purposeCombo.GetCurSel ();

        if ( nIndex >= 0 )
        {
            switch (m_purposeCombo.GetItemData (nIndex))
            {
            case REQUEST_PURPOSE_SIGNATURE:
                bEncryptionSelected = FALSE;
                break;

            case REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION:
            case REQUEST_PURPOSE_ENCRYPTION:
                bEncryptionSelected = TRUE;
                break;

            default:
                _ASSERT (0);
                break;
            }
        }

        GetDlgItem (IDC_DELETE_PERMANENTLY)->EnableWindow (!bEncryptionSelected);
        if ( bEncryptionSelected && 
                BST_CHECKED == SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_GETCHECK) )
        {
            SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_SETCHECK, BST_UNCHECKED);
            m_rCertTemplate.SetRemoveInvalidCertFromPersonalStore (false);
        }

        GetDlgItem (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK)->EnableWindow (bEncryptionSelected);
        if ( !bEncryptionSelected )
            SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_SETCHECK, BST_UNCHECKED);

        BOOL bEnableArchiveKeyCheck = bEncryptionSelected;

        if ( m_nProvDSSCnt > 0 )
            bEnableArchiveKeyCheck = FALSE;

        if ( bEnableArchiveKeyCheck )
        {
            GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->EnableWindow (TRUE);
        }
        else
        {
            SendDlgItemMessage (IDC_ARCHIVE_KEY_CHECK, BM_SETCHECK, BST_UNCHECKED);
            OnArchiveKeyCheck ();   // clear flag
            GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->EnableWindow (FALSE);
        }
    }
}


HRESULT CTemplateV2RequestPropertyPage::EnumerateCSPs(DWORD dwMinKeySize)
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::EnumerateCSPs\n");
    HRESULT hr = S_OK;
    for (DWORD dwIndex = 0; ;dwIndex++)
    {
        DWORD   cbName = 0;
        DWORD   dwProvType = 0;

        if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType, NULL, &cbName) )
        {
            PWSTR  pszTypeName = new WCHAR[cbName];
            if ( pszTypeName )
            {
                if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType,
                        pszTypeName, &cbName) )
                {
                    DWORD   dwSigMaxKey = (DWORD) -1;
                    DWORD   dwKeyExMaxKey = (DWORD) -1;

                    CSPGetMaxKeySupported (pszTypeName, dwProvType, dwSigMaxKey, dwKeyExMaxKey);
                    // If either of these values is still -1, then it was not 
                    // set.  Set to 0.
                    if ( -1 == dwSigMaxKey )
                        dwSigMaxKey = 0;
                    if ( -1 == dwKeyExMaxKey )
                        dwKeyExMaxKey = 0;
                    CT_CSP_DATA* pNewData = new CT_CSP_DATA (pszTypeName, 
                            dwProvType, dwSigMaxKey, dwKeyExMaxKey);
                    if ( pNewData )
                    {
                        m_CSPList.AddTail (pNewData);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError ());
                    _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
                    break;
                }

                delete [] pszTypeName;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
            break;
        }
    }


    int     nCSPIndex = 0;
    CString szCSP;

    NormalizeCSPListBox (dwMinKeySize, false);

    CStringList invalidCSPs;    // CSPs selected but not supporting the key size
    // Set the checks
    m_nProvDSSCnt = 0;
    nCSPIndex = 0;
    while ( SUCCEEDED (m_rCertTemplate.GetCSP (nCSPIndex, szCSP)) )
    {
        int nIndex = m_CSPListbox.FindString (-1, szCSP);
        if ( LB_ERR != nIndex )
        {
            m_CSPListbox.SetCheck (nIndex, BST_CHECKED);
            CT_CSP_DATA* pCSPData = (CT_CSP_DATA*) m_CSPListbox.GetItemData (nIndex);
            if ( pCSPData )
            {
                if ( PROV_DSS == pCSPData->m_dwProvType || 
                        PROV_DSS_DH == pCSPData->m_dwProvType )
                {
                    m_nProvDSSCnt++;
                }
            }
        }
        else
        {
            invalidCSPs.AddTail (szCSP);
        }
        nCSPIndex++;
    }

    for (POSITION nextPos = invalidCSPs.GetHeadPosition (); nextPos;)
    {
        CString szInvalidCSP = invalidCSPs.GetNext (nextPos);
        if ( !szInvalidCSP.IsEmpty () )
        {
            m_rCertTemplate.ModifyCSPList (szInvalidCSP, false); // remove
        }
    }

    EnableControls ();

    _TRACE (-1, L"Entering CTemplateV2RequestPropertyPage::EnumerateCSPs: 0x%x\n", hr);
    return hr;
}



void CTemplateV2RequestPropertyPage::OnSelchangePurposeCombo() 
{
	int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
    {
        // NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
        // option list with v2 templates that have ENC and SIG as purpose.
        switch (m_purposeCombo.GetItemData (nIndex))
        {
        case REQUEST_PURPOSE_SIGNATURE:
            m_rCertTemplate.SetEncryptionSignature (false);
            m_rCertTemplate.SetKeySpecSignature (true);
            break;

        case REQUEST_PURPOSE_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (false);
            m_rCertTemplate.SetDigitalSignature (false);
            break;

        case REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (false);
            m_rCertTemplate.SetDigitalSignature (true);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }

    int nSel = m_minKeySizeCombo.GetCurSel ();
    ASSERT (nSel >= 0);
    if ( nSel >= 0 )
    {
        DWORD   dwMinKeySize = (DWORD) m_minKeySizeCombo.GetItemData (nSel);
        ASSERT (dwMinKeySize > 0);

        // Clear CSP list and add only values that correspond, saving checks
        NormalizeCSPListBox (dwMinKeySize, true);
    }

    SetModified ();
    m_rbIsDirty = true;
	EnableControls ();
}

void CTemplateV2RequestPropertyPage::AddKeySizeToCombo(DWORD dwValue, PCWSTR strValue, DWORD dwSizeToSelect)
{
    int nIndex = m_minKeySizeCombo.AddString (strValue);
    if ( nIndex >= 0 )
    {
        m_minKeySizeCombo.SetItemData (nIndex, dwValue);
        if ( dwSizeToSelect == dwValue )
            m_minKeySizeCombo.SetCurSel (nIndex);
    }
}

void CTemplateV2RequestPropertyPage::OnExportPrivateKey() 
{
    bool bMakeExportable = (BST_CHECKED == SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_GETCHECK));
	
    m_rCertTemplate.MakePrivateKeyExportable (bMakeExportable);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnArchiveKeyCheck() 
{
    bool bAllowKeyArchival = (BST_CHECKED == SendDlgItemMessage (IDC_ARCHIVE_KEY_CHECK, BM_GETCHECK));
	
    m_rCertTemplate.AllowPrivateKeyArchival (bAllowKeyArchival);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnIncludeSymmetricAlgorithmsCheck() 
{
    bool bInclude = 
            (BST_CHECKED == SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_GETCHECK));
	
    m_rCertTemplate.IncludeSymmetricAlgorithems (bInclude);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnSelchangeMinimumKeysizeValue() 
{
	SetModified ();
    m_rbIsDirty = true;

    int nSel = m_minKeySizeCombo.GetCurSel ();
    ASSERT (nSel >= 0);
    if ( nSel >= 0 )
    {
        DWORD   dwMinKeySize = (DWORD) m_minKeySizeCombo.GetItemData (nSel);
        ASSERT (dwMinKeySize > 0);
        HRESULT hr = m_rCertTemplate.SetMinimumKeySizeValue (dwMinKeySize);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_CANNOT_WRITE_MINKEYSIZE, hr);

            MessageBox (text, caption, MB_OK | MB_ICONWARNING);
        }

        // Clear CSP list and add only values that correspond, saving checks
        NormalizeCSPListBox (dwMinKeySize, true);
    }
}

void CTemplateV2RequestPropertyPage::OnCheckChange() 
{
    int nSel = m_CSPListbox.GetCurSel ();
    if ( nSel >= 0 )
    {
        CString szCSPName;

        m_CSPListbox.GetText (nSel, szCSPName);

        if ( !szCSPName.IsEmpty () )
        {
            HRESULT hr = S_OK;
            if ( BST_CHECKED == m_CSPListbox.GetCheck (nSel) )
            {
                hr = m_rCertTemplate.ModifyCSPList (szCSPName, true); // add
                CT_CSP_DATA* pData = (CT_CSP_DATA*) m_CSPListbox.GetItemData (nSel);
                if ( pData )
                {
                    if ( PROV_DSS == pData->m_dwProvType || PROV_DSS_DH == pData->m_dwProvType )
                        m_nProvDSSCnt++;
                }
            }
            else
            {
                hr = m_rCertTemplate.ModifyCSPList (szCSPName, false); // remove
                CT_CSP_DATA* pData = (CT_CSP_DATA*) m_CSPListbox.GetItemData (nSel);
                if ( pData )
                {
                    if ( PROV_DSS == pData->m_dwProvType || PROV_DSS_DH == pData->m_dwProvType )
                        m_nProvDSSCnt--;
                }
            }
            if ( SUCCEEDED (hr) )
            {
                SetModified ();
                m_rbIsDirty = true;
            }
        }
    }
    EnableControls ();
} 

void CTemplateV2RequestPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2RequestPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
    case IDC_MINIMUM_KEYSIZE_LABEL:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_REQUEST) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2RequestPropertyPage::DoContextHelp\n");
}

void CTemplateV2RequestPropertyPage::OnUserInputRequiredForAutoenrollment() 
{
    bool    bSet = BST_CHECKED == SendDlgItemMessage (
                IDC_USER_INPUT_REQUIRED_FOR_AUTOENROLLMENT, BM_GETCHECK);

    m_rCertTemplate.SetUserInteractionRequired (bSet);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnDeletePermanently() 
{
    m_rCertTemplate.SetRemoveInvalidCertFromPersonalStore (
            BST_CHECKED == SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_GETCHECK));
    SetModified ();
    m_rbIsDirty = true;
}


HRESULT CTemplateV2RequestPropertyPage::CSPGetMaxKeySupported (
        PCWSTR pszProvider, 
        DWORD dwProvType, 
        DWORD& rdwSigMaxKey, 
        DWORD& rdwKeyExMaxKey)
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::CSPGetMaxKeySupported (%s)\n",
            pszProvider);
    HRESULT     hr = S_OK;
    HCRYPTPROV  hProv = 0;

    BOOL bResult = ::CryptAcquireContext (&hProv,
            NULL,
            pszProvider,
            dwProvType,
            CRYPT_VERIFYCONTEXT | CRYPT_SILENT);
    if ( bResult )
    {
        PROV_ENUMALGS_EX EnumAlgs;     //   Structure to hold information on 
                                   //   a supported algorithm
        DWORD dFlag = CRYPT_FIRST;     //   Flag indicating that the first
                                       //   supported algorithm is to be
                                       //   enumerated. Changed to 0 after the
                                       //   first call to the function.
        DWORD   cbData = sizeof(PROV_ENUMALGS_EX);

        while (CryptGetProvParam(
                hProv,              // handle to an open cryptographic provider
                PP_ENUMALGS_EX, 
                (BYTE *)&EnumAlgs,  // information on the next algorithm
                &cbData,            // number of bytes in the PROV_ENUMALGS_EX
                dFlag))             // flag to indicate whether this is a first or
                                    // subsequent algorithm supported by the
                                    // CSP.
        {
            if ( ALG_CLASS_SIGNATURE == GET_ALG_CLASS (EnumAlgs.aiAlgid) )
                rdwSigMaxKey = EnumAlgs.dwMaxLen;

            if ( ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS (EnumAlgs.aiAlgid) )
                rdwKeyExMaxKey = EnumAlgs.dwMaxLen;

            if ( -1 != rdwSigMaxKey && -1 != rdwKeyExMaxKey )
                break;  // both have been set

            dFlag = 0;          // Set to 0 after the first call,
        } //  end of while loop. When all of the supported algorithms have
          //  been enumerated, the function returns FALSE.

        ::CryptReleaseContext (hProv, 0);
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CryptAcquireContext () failed: 0x%x\n", dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::CSPGetMaxKeySupported (%s)\n",
            pszProvider);
    return hr;
}

// NTRAID# 313348 Cert Template UI: Need to warn the user if the template 
// minimum key length is not supported by the CSPs
void CTemplateV2RequestPropertyPage::NormalizeCSPListBox (DWORD dwMinKeySize, bool bSetChecks)
{
    // Save the checked CSPs 
    CStringList checkedCSPList;

    if ( bSetChecks )
    {
        int nCnt = m_CSPListbox.GetCount ();
        while (nCnt > 0)
        {
            nCnt--;
            if ( BST_CHECKED == m_CSPListbox.GetCheck (nCnt) )
            {
                CString szText;
                m_CSPListbox.GetText (nCnt, szText);
                checkedCSPList.AddTail (szText);
                m_rCertTemplate.ModifyCSPList (szText, false); // remove
            }
        }
    }

    // Remove all CSPs
    m_CSPListbox.ResetContent ();

    bool bSignatureOnly = false;
	int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
        bSignatureOnly = (REQUEST_PURPOSE_SIGNATURE == m_purposeCombo.GetItemData (nIndex));

    // Fill the listbox with conforming CSPs
    for (POSITION nextPos = m_CSPList.GetHeadPosition (); nextPos; )
    {
        CT_CSP_DATA* pCSPData = m_CSPList.GetNext (nextPos);
        if ( pCSPData )
        {
            bool bAddString = false;

            if ( bSignatureOnly && pCSPData->m_dwSigMaxKeySize >= dwMinKeySize )
                bAddString = true;
            else if ( pCSPData->m_dwKeyExMaxKeySize >= dwMinKeySize )
                bAddString = true;

            if ( bAddString )
            {
                nIndex = m_CSPListbox.AddString (pCSPData->m_szName);
                if ( nIndex < 0 )
                {
                    _TRACE (0, L"AddString (%s) failed: %d\n", nIndex);
                    break;
                }
                else
                {
                    m_CSPListbox.SetItemData (nIndex, (DWORD_PTR) pCSPData);
                }
            }
        }
    }

    if ( bSetChecks )
    {
        m_nProvDSSCnt = 0;
        // Restore saved checks, where possible
        for (POSITION nextPos = checkedCSPList.GetHeadPosition (); nextPos; )
        {
            CString szText = checkedCSPList.GetNext (nextPos);
            nIndex = m_CSPListbox.FindStringExact (-1, szText);
            if ( LB_ERR != nIndex )
            {
                m_CSPListbox.SetCheck (nIndex, BST_CHECKED);
                m_rCertTemplate.ModifyCSPList (szText, true); // add
                CT_CSP_DATA* pCSPData = (CT_CSP_DATA*) m_CSPListbox.GetItemData (nIndex);
                if ( pCSPData )
                {
                    if ( PROV_DSS == pCSPData->m_dwProvType || 
                            PROV_DSS_DH == pCSPData->m_dwProvType )
                    {
                        m_nProvDSSCnt++;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\uuids.h ===
// Nodetypes for the Certificate Templates snapin
// created by GUIDGEN 7/13/98 BryanWal

#ifndef _UUIDS_CERTTMPL_MANAGEMENT_
#define _UUIDS_CERTTMPL_MANAGEMENT_

#define struuidNodetypeSnapin			    "{C4EC3F82-0F43-4d72-B8A2-3D7A27F6D13A}"
#define struuidNodetypeCertTemplate         "{EE240DBE-9E44-4e85-AFB7-FB330048D4C7}"


#define lstruuidNodetypeSnapin				L"{C4EC3F82-0F43-4d72-B8A2-3D7A27F6D13A}"
#define lstruuidNodetypeCertTemplate        L"{EE240DBE-9E44-4e85-AFB7-FB330048D4C7}"



// {C4EC3F82-0F43-4d72-B8A2-3D7A27F6D13A}
#define structuuidNodetypeSnapin    \
    { 0xc4ec3f82, 0xf43, 0x4d72, { 0xb8, 0xa2, 0x3d, 0x7a, 0x27, 0xf6, 0xd1, 0x3a } }


// {EE240DBE-9E44-4e85-AFB7-FB330048D4C7}
#define structuuidNodetypeCertTemplate \
    { 0xee240dbe, 0x9e44, 0x4e85, { 0xaf, 0xb7, 0xfb, 0x33, 0x0, 0x48, 0xd4, 0xc7 } }



DEFINE_GUID (NODEID_CertTmpl_CERT_TEMPLATE, 0xee240dbe, 0x9e44, 0x4e85, 0xaf, 0xb7, 0xfb, 0x33, 0x0, 0x48, 0xd4, 0xc7);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2supercedespropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SupercedesPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2SupercedesPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2SupercedesPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "CompData.h"
#include "SelectTemplateDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SupercedesPropertyPage property page

CTemplateV2SupercedesPropertyPage::CTemplateV2SupercedesPropertyPage(
        CCertTemplate& rCertTemplate, 
        bool& rbIsDirty,
        const CCertTmplComponentData* pCompData) 
    : CHelpPropertyPage(CTemplateV2SupercedesPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_pGlobalTemplateNameList (0),
    m_bGlobalListCreatedByDialog (false),
    m_rbIsDirty (rbIsDirty),
    m_pCompData (pCompData)
{  
	//{{AFX_DATA_INIT(CTemplateV2SupercedesPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

    if ( m_pCompData )
        m_pGlobalTemplateNameList = &(m_pCompData->m_globalTemplateNameList);
    if ( !m_pGlobalTemplateNameList )
    {
        m_bGlobalListCreatedByDialog = true;
        m_pGlobalTemplateNameList = new CStringList;
        if ( m_pGlobalTemplateNameList )
        {
        }
    }
}

CTemplateV2SupercedesPropertyPage::~CTemplateV2SupercedesPropertyPage()
{
    m_rCertTemplate.Release ();

    if ( m_bGlobalListCreatedByDialog )
        delete m_pGlobalTemplateNameList;
}

void CTemplateV2SupercedesPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2SupercedesPropertyPage)
	DDX_Control(pDX, IDC_SUPERCEDED_TEMPLATES_LIST, m_templateList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2SupercedesPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2SupercedesPropertyPage)
	ON_BN_CLICKED(IDC_ADD_SUPERCEDED_TEMPLATE, OnAddSupercededTemplate)
	ON_BN_CLICKED(IDC_REMOVE_SUPERCEDED_TEMPLATE, OnRemoveSupercededTemplate)
	ON_NOTIFY(LVN_DELETEITEM, IDC_SUPERCEDED_TEMPLATES_LIST, OnDeleteitemSupercededTemplatesList)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_SUPERCEDED_TEMPLATES_LIST, OnItemchangedSupercededTemplatesList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SupercedesPropertyPage message handlers

void CTemplateV2SupercedesPropertyPage::OnAddSupercededTemplate() 
{
    CStringList supercededTemplateNames;

    // Add all the currently superceded templates.  These will not be displayed
    // in the popup dialog
    int nCnt = m_templateList.GetItemCount (); 
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        CString* pszTemplateName = (CString*) m_templateList.GetItemData (nIndex);
        if ( pszTemplateName )
            supercededTemplateNames.AddTail (*pszTemplateName);
    }

    // Also add this template name.  Templates can't supercede themselves.
    supercededTemplateNames.AddTail (m_rCertTemplate.GetTemplateName ());
    if ( m_pGlobalTemplateNameList )
    {
	    CSelectTemplateDlg  dlg (this, m_pCompData, 
                supercededTemplateNames);


        CThemeContextActivator activator;
        if ( IDOK == dlg.DoModal () )
        {
            POSITION    pos = dlg.m_returnedTemplates.GetHeadPosition ();
            CString     szTemplateName;

            for (; pos; )
            {
	            szTemplateName = dlg.m_returnedTemplates.GetNext (pos);
                HRESULT hr = m_rCertTemplate.ModifySupercededTemplateList (
                        szTemplateName, true);
                if ( SUCCEEDED (hr) )
                {
                    hr = AddItem (szTemplateName);
                    SetModified ();
                    m_rbIsDirty = true;
                }
            }
        }
    }
}

void CTemplateV2SupercedesPropertyPage::OnRemoveSupercededTemplate() 
{
	int		nCnt = m_templateList.GetItemCount ();
	ASSERT (nCnt >= 1);
	UINT	flag = 0;
	while (--nCnt >= 0)
	{
		flag = ListView_GetItemState (m_templateList.m_hWnd, nCnt, LVIS_SELECTED);
		if ( flag & LVNI_SELECTED )
		{
            CString* pszTemplateName = (CString*) m_templateList.GetItemData (nCnt);
            if ( pszTemplateName )
            {
                HRESULT hr = m_rCertTemplate.ModifySupercededTemplateList (
                        *pszTemplateName, false);
                if ( SUCCEEDED (hr) )
                {
                    m_templateList.DeleteItem (nCnt);
                    SetModified ();
                    m_rbIsDirty = true;
                }
            }
        }
    }
}

void CTemplateV2SupercedesPropertyPage::EnableControls()
{
    if ( m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_SUPERCEDED_TEMPLATES_LIST)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_SUPERCEDED_TEMPLATE)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_SUPERCEDED_TEMPLATE)->EnableWindow (FALSE);
    }
    else
    {
        BOOL bEnable = (m_templateList.GetSelectedCount () > 0);
    
        GetDlgItem(IDC_REMOVE_SUPERCEDED_TEMPLATE)->EnableWindow (bEnable);
    }
}


BOOL CTemplateV2SupercedesPropertyPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog ();

    // Set up list controls
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_TEMPLATES, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_TEMPLATES, 16, 0, cr));
	m_templateList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_templateList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

    // Set to full-row select
    DWORD   dwExstyle = m_templateList.GetExtendedStyle ();
	m_templateList.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT);


    int	colWidths[NUM_COLS] = {200, 200};

	// Add "Certificate Extension" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_CERTIFICATE_TEMPLATES));
	VERIFY (m_templateList.InsertColumn (COL_CERT_TEMPLATE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_TEMPLATE], COL_CERT_TEMPLATE) != -1);

	VERIFY (szText.LoadString (IDS_COLUMN_SUPPORTED_CAS));
	VERIFY (m_templateList.InsertColumn (COL_CERT_VERSION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_VERSION], COL_CERT_VERSION) != -1);
    m_templateList.SetColumnWidth (COL_CERT_VERSION, LVSCW_AUTOSIZE_USEHEADER);

    // Initialize superceded list
    int     nTemplateIndex = 0;
    CString szTemplateName;
    while ( SUCCEEDED ( m_rCertTemplate.GetSupercededTemplate (nTemplateIndex, 
            szTemplateName)) )
    {
        VERIFY (SUCCEEDED (AddItem (szTemplateName)));
        nTemplateIndex++;
    }

    EnableControls ();

    return TRUE;
}

void CTemplateV2SupercedesPropertyPage::OnDeleteitemSupercededTemplatesList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    CString* pszTemplateName = (CString*) m_templateList.GetItemData (pNMListView->iItem);
    if ( pszTemplateName )
        delete pszTemplateName;
	
	*pResult = 0;
}

HRESULT CTemplateV2SupercedesPropertyPage::AddItem(const CString &szTemplateName)
{
    HCERTTYPE   hCertType = 0;
    HRESULT     hr = CAFindCertTypeByName (szTemplateName,
            NULL,
            CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
            &hCertType);
    _ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) )
    {
        PWSTR* rgwszProp = 0;

        hr = CAGetCertTypePropertyEx (hCertType, 
            CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwVersion = 0;
            hr = CAGetCertTypePropertyEx (hCertType,
                    CERTTYPE_PROP_SCHEMA_VERSION,
                    &dwVersion);
            if ( SUCCEEDED (hr) )
            {
	            LV_ITEM	lvItem;
	            int		iItem = m_templateList.GetItemCount ();
	            int iResult = 0;

	            ::ZeroMemory (&lvItem, sizeof (lvItem));
	            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	            lvItem.iItem = iItem;
                lvItem.iSubItem = COL_CERT_TEMPLATE;
	            lvItem.pszText = rgwszProp[0];
                if ( 1 == dwVersion )
                    lvItem.iImage = 0;  // version is 1
                else
                    lvItem.iImage = 1;  // version is 2
                lvItem.lParam = (LPARAM) new CString (szTemplateName);
	            iItem = m_templateList.InsertItem (&lvItem);
	            ASSERT (-1 != iItem);
	            if ( -1 != iItem )
                {
	                ::ZeroMemory (&lvItem, sizeof (lvItem));
	                lvItem.mask = LVIF_TEXT;
	                lvItem.iItem = iItem;
                    lvItem.iSubItem = COL_CERT_VERSION;
                    CString text;
                    if ( 1 == dwVersion )
                        VERIFY (text.LoadString (IDS_WINDOWS_2000_AND_LATER));
                    else
                        VERIFY (text.LoadString (IDS_WINDOWS_2002_AND_LATER));
                    lvItem.pszText = (PWSTR)(PCWSTR) text;
	                iResult = m_templateList.SetItem (&lvItem);
	                ASSERT (-1 != iResult);
                    if ( -1 == iResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
            }

            CAFreeCertTypeProperty (hCertType, rgwszProp);
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
        }

        hr = CACloseCertType (hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( !SUCCEEDED (hr) )
        {
            _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", 
                (PCWSTR) szTemplateName, hr);
    }
    return hr;
}

void CTemplateV2SupercedesPropertyPage::OnItemchangedSupercededTemplatesList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
    EnableControls ();	

	
	*pResult = 0;
}

void CTemplateV2SupercedesPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2SupercedesPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_SUPERCEDES_LABEL:
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_SUPERCEDES) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2SupercedesPropertyPage::DoContextHelp\n");
}

void CTemplateV2SupercedesPropertyPage::OnDestroy() 
{
	CHelpPropertyPage::OnDestroy();
	
    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2supercedespropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SupercedesPropertyPage.h
//
//  Contents:   Definition of CTemplateV2SupercedesPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2SUPERCEDESPROPERTYPAGE_H__13B90B4A_2B60_492A_910F_8DA4383BDD8C__INCLUDED_)
#define AFX_TEMPLATEV2SUPERCEDESPROPERTYPAGE_H__13B90B4A_2B60_492A_910F_8DA4383BDD8C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2SupercedesPropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SupercedesPropertyPage dialog

class CTemplateV2SupercedesPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2SupercedesPropertyPage(CCertTemplate& rCertTemplate, 
            bool& rbIsDirty,
            const CCertTmplComponentData* pCompData);
	~CTemplateV2SupercedesPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2SupercedesPropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_SUPERCEDES };
	CListCtrl	m_templateList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2SupercedesPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	HRESULT AddItem (const CString& szTemplateName);
    virtual BOOL OnInitDialog();
	void EnableControls();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2SupercedesPropertyPage)
	afx_msg void OnAddSupercededTemplate();
	afx_msg void OnRemoveSupercededTemplate();
	afx_msg void OnDeleteitemSupercededTemplatesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedSupercededTemplatesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool& m_rbIsDirty;
	WTL::CImageList m_imageListSmall;
	WTL::CImageList m_imageListNormal;
    CCertTemplate& m_rCertTemplate;
    const CStringList* m_pGlobalTemplateNameList;
    bool    m_bGlobalListCreatedByDialog;
    const CCertTmplComponentData* m_pCompData;

	enum {
		COL_CERT_TEMPLATE = 0,
        COL_CERT_VERSION, 
		NUM_COLS	// must be last
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2SUPERCEDESPROPERTYPAGE_H__13B90B4A_2B60_492A_910F_8DA4383BDD8C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2subjectnamepropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SubjectNamePropertyPage.h
//
//  Contents:   Definition of CTemplateV2SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2SUBJECTNAMEPROPERTYPAGE_H__4EC37055_348A_462A_A177_286A2B0AF3F4__INCLUDED_)
#define AFX_TEMPLATEV2SUBJECTNAMEPROPERTYPAGE_H__4EC37055_348A_462A_A177_286A2B0AF3F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2SubjectNamePropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SubjectNamePropertyPage dialog

class CTemplateV2SubjectNamePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2SubjectNamePropertyPage(
            CCertTemplate& rCertTemplate, 
            bool& rbIsDirty, 
            bool bIsComputerOrDC = false);
	~CTemplateV2SubjectNamePropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2SubjectNamePropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_SUBJECT_NAME };
	CComboBox	m_nameCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2SubjectNamePropertyPage)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void SetSettingsForNameTypeNone ();
	virtual void DoContextHelp (HWND hWndControl);
	bool CanUncheckLastSetting (int ctrlID);
    virtual BOOL OnInitDialog();
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2SubjectNamePropertyPage)
	afx_msg void OnSubjectAndSubjectAltName();
	afx_msg void OnSelchangeSubjectNameNameCombo();
	afx_msg void OnSubjectNameBuiltByCa();
	afx_msg void OnSubjectNameSuppliedInRequest();
	afx_msg void OnDnsName();
	afx_msg void OnEmailInAlt();
	afx_msg void OnEmailInSub();
	afx_msg void OnSpn();
	afx_msg void OnUpn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    enum {
        NAME_TYPE_NONE = 0,
        NAME_TYPE_FULL_DN,
        NAME_TYPE_CN_ONLY
    };

private:
	bool&           m_rbIsDirty;
    CCertTemplate&  m_rCertTemplate;
    bool            m_bIsComputerOrDC;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2SUBJECTNAMEPROPERTYPAGE_H__4EC37055_348A_462A_A177_286A2B0AF3F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\utils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       utils.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __UTILS_H
#define __UTILS_H
#include "cookie.h"

typedef CArray<CCertTmplCookie*, CCertTmplCookie*> CCookiePtrArray;


// Convert win32 error code to a text message and display
void DisplaySystemError (HWND hParent, DWORD dwErr);
void TraceSystemError (DWORD dwErr);

extern PCWSTR MMC_APP;

HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime);


bool IsWindowsNT ();

LRESULT RegDelnode (HKEY hKeyRoot, PCWSTR lpSubKey);

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))


#define g_cszHideWelcomePage	L"Hide Session Wizard Welcome"

enum {
	PUBLISHER_DIRECTORY = 1,
	SUBSCRIBER_DIRECTORY
};


HRESULT InitObjectPickerForDomainComputers(IDsObjectPicker *pDsObjectPicker);
class CCertTmplComponentData; //forward declaration


// {4E40F770-369C-11d0-8922-00A024AB2DBB}
DEFINE_GUID(CLSID_DsSecurityPage,  0x4E40F770,  0x369C, 0x11d0, 0x89, 0x22, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

#define MAX_ADS_ENUM 16

void FreeStringArray (PWSTR* rgpszStrings, DWORD dwAddCount);


typedef enum {
	CERTTMPL_OBJECT_CERT_TEMPLATE
} CERTTMPL_OBJECT_TYPE;

HRESULT DisplayObjectCountInStatusBar (LPCONSOLE pConsole, DWORD dwCnt);
HRESULT DisplayRootNodeStatusBarText (LPCONSOLE pConsole);

////////////////////////////////////////////////////////////////////////////////
// CCredentialObject

class CCredentialObject
{
public :
	CCredentialObject() :
		m_pszPassword (0),
		m_bUseCredentials (false)
	{
	}

	CCredentialObject(CCredentialObject* pCredObject);

	~CCredentialObject() 
	{
		free(m_pszPassword);
	}

	CString GetUsername() const { return m_sUsername; }
	void SetUsername (PCWSTR pszUsername) { m_sUsername = pszUsername; }
	HRESULT GetPassword (PWSTR pszPassword, int bufLen) const; 
	HRESULT SetPasswordFromHwnd (HWND hWnd);
	BOOL UseCredentials () const { return m_bUseCredentials; }
	void SetUseCredentials (const bool bUseCred) { m_bUseCredentials = bUseCred; }

private :
	CString m_sUsername;
	PWSTR m_pszPassword;
	bool m_bUseCredentials;
};

//  Do a case insensitive string compare that is safe for any locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
int LocaleStrCmp (LPCWSTR ptsz1, LPCWSTR ptsz2);

CString GetSystemMessage (DWORD dwErr);


PCWSTR	GetContextHelpFile ();

///////////////////////////////////////////////////////////////////////////////
//  OID functions
///////////////////////////////////////////////////////////////////////////////
bool MyGetOIDInfoA (CString & string, LPCSTR pszObjId);
HRESULT GetEnterpriseOIDs ();
HRESULT GetBuiltInOIDS ();
bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID);

///////////////////////////////////////////////////////////////////////////////
bool IsCerttypeEditingAllowed();


void InstallWindows2002CertTemplates ();


#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\tinstall.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       tinstall.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <certca.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

//--------------------------------------------------------------------------
//
//       Defines
//
//--------------------------------------------------------------------------
#define DS_RETEST_SECONDS                   3
#define CVT_BASE	                        (1000 * 1000 * 10)
#define CVT_SECONDS	                        (1)
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define TEMPLATE_CONTAINER_NAME             L"CN=Certificate Templates,CN=Public Key Services,CN=Services,"
#define SCHEMA_CONTAINER_NAME               L"CN=Schema,"


typedef WCHAR *CERTSTR; 
bool g_bSchemaIsW2K = false;

//--------------------------------------------------------------------------
//
//
//     Helper Functions
//
//--------------------------------------------------------------------------
HANDLE GetClientIdentity()
{
    HANDLE  hHandle       = NULL;
    HANDLE  hClientToken  = NULL; 
    HANDLE  hProcessToken = NULL; 

    // Step 1: attempt to acquire the thread token.  
    hHandle = GetCurrentThread();
    if ( hHandle )
    {
        if ( OpenThreadToken(hHandle,
			     TOKEN_QUERY,
			     TRUE,           // open as self
			     &hClientToken))
        goto Exit;
    }
  
    if (hHandle != NULL)
    {
        CloseHandle(hHandle); 
        hHandle=NULL;
    }
    
    // We failed to get the thread token, now try to acquire the process token:
    hHandle = GetCurrentProcess();
    if (NULL == hHandle)
	    goto Exit; 
    
    if (!OpenProcessToken(hHandle,
			  TOKEN_DUPLICATE,
			  &hProcessToken))
	    goto Exit; 
    
    if(!DuplicateToken(hProcessToken,
		       SecurityImpersonation,
		       &hClientToken))
	    goto Exit;
    
Exit:
    if (NULL != hHandle)       
        CloseHandle(hHandle); 

    if (NULL != hProcessToken) 
        CloseHandle(hProcessToken); 
    
    return hClientToken; 
}    



HRESULT myHError(HRESULT hr)
{

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if ( SUCCEEDED (hr) )
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
    }
    return(hr);
}


HRESULT 
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    HRESULT hr = S_OK;

    size_t cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	    hr = E_OUTOFMEMORY;
	    goto error;
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


DWORD
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CString* pszDomainDn,
    OUT CString* pszConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    pszDomainDn      : a pointer to a string to be allocated in this routine

    pszConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];

    WCHAR  *DefaultNamingContext       = L"defaultNamingContext";
    WCHAR  *ConfigNamingContext       = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectClass=*";

    //
    // These must be present
    //

    //
    // Set the out parameters to null
    //

    if ( pszDomainDn )
        *pszDomainDn = L"";
    if ( pszConfigDn )
        *pszConfigDn = L"";

    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = DefaultNamingContext;
    AttrArray[1] = ConfigNamingContext;  // this is the sentinel
    AttrArray[2] = NULL;  // this is the sentinel

    __try
    {
	    LdapError = ldap_search_sW(LdapHandle,
				       NULL,
				       LDAP_SCOPE_BASE,
				       ObjectClassFilter,
				       AttrArray,
				       FALSE,
				       &SearchResult);

	    WinError = LdapMapErrorToWin32(LdapError);

	    if (ERROR_SUCCESS == WinError) {

            Entry = ldap_first_entry(LdapHandle, SearchResult);

            if (Entry)
            {

                Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

                while (Attr)
                {

                    if (!_wcsicmp(Attr, DefaultNamingContext))
                    {
                        if ( pszDomainDn )
                        {
	                        Values = ldap_get_values(LdapHandle, Entry, Attr);

	                        if (Values && Values[0])
                            {
                                *pszDomainDn = Values[0];
	                        }
	                        ldap_value_free(Values);
                        }

                    }
                    else if (!_wcsicmp(Attr, ConfigNamingContext))
                    {
                        if ( pszConfigDn )
                        {
	                        Values = ldap_get_values(LdapHandle, Entry, Attr);

	                        if (Values && Values[0])
                            {
                                *pszConfigDn = Values[0];
	                        }
	                        ldap_value_free(Values);
                        }
                    }

                    Attr = ldap_next_attribute(LdapHandle, Entry, BerElement);
                }
            }

            if ( pszDomainDn && pszDomainDn->IsEmpty () )
            {
	            //
	            // We could get the default domain - bail out
	            //
	            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }
            else if ( pszConfigDn && pszConfigDn->IsEmpty () )
            {
	            //
	            // We could get the default domain - bail out
	            //
	            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }

	    }
    }
    __except(WinError = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // make sure we free this
    if (SearchResult)
        ldap_msgfree( SearchResult );

    return WinError;
}



HRESULT
myDoesDSExist(
    IN BOOL fRetry)
{
    HRESULT hr = S_OK;

    static BOOL s_fKnowDSExists = FALSE;
    static HRESULT s_hrDSExists = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    static FILETIME s_ftNextTest = {0,0};
    
    if (s_fKnowDSExists && (s_hrDSExists != S_OK) && fRetry)
    //    s_fKnowDSExists = FALSE;	// force a retry
    {
        FILETIME ftCurrent;
        GetSystemTimeAsFileTime(&ftCurrent);

        // if Compare is < 0 (next < current), force retest
        if (0 > CompareFileTime(&s_ftNextTest, &ftCurrent))
            s_fKnowDSExists = FALSE;    
    }

    if (!s_fKnowDSExists)
    {
        GetSystemTimeAsFileTime(&s_ftNextTest);

	// set NEXT in 100ns increments

        ((LARGE_INTEGER *) &s_ftNextTest)->QuadPart +=
	    (__int64) (CVT_BASE * CVT_SECONDS * 60) * DS_RETEST_SECONDS;

        // NetApi32 is delay loaded, so wrap to catch problems when it's not available
        __try
        {
            DOMAIN_CONTROLLER_INFO *pDCI;
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRole;
        
            // ensure we're not standalone
            pDsRole = NULL;
            hr = DsRoleGetPrimaryDomainInformation(	// Delayload wrapped
				    NULL,
				    DsRolePrimaryDomainInfoBasic,
				    (BYTE **) &pDsRole);

            if (S_OK == hr &&
                (pDsRole->MachineRole == DsRole_RoleStandaloneServer ||
                 pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
            }

            if (NULL != pDsRole) 
	    {
                DsRoleFreeMemory(pDsRole);     // Delayload wrapped
	    }
            if (S_OK == hr)
            {
                // not standalone; return info on our DS

                pDCI = NULL;
                hr = DsGetDcName(    // Delayload wrapped
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    DS_DIRECTORY_SERVICE_PREFERRED,
			    &pDCI);
            
                if (S_OK == hr && 0 == (pDCI->Flags & DS_DS_FLAG))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
                }
                if (NULL != pDCI)
                {
                   NetApiBufferFree(pDCI);    // Delayload wrapped
                }
            }
            s_fKnowDSExists = TRUE;
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }

        // else just allow users without netapi flounder with timeouts
        // if ds not available...

        s_hrDSExists = myHError(hr);
    }
    return(s_hrDSExists);
}




HRESULT
myRobustLdapBindEx(
    OUT LDAP ** ppldap,
    OPTIONAL OUT LPWSTR* ppszForestDNSName,
    IN BOOL fGC)
{
    HRESULT hr = S_OK;
    BOOL fForceRediscovery = FALSE;
    DWORD dwGetDCFlags = DS_RETURN_DNS_NAME;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    LDAP *pld = NULL;
    WCHAR const *pwszDomainControllerName = NULL;
    ULONG ldaperr = 0;

    if (fGC)
    {
        dwGetDCFlags |= DS_GC_SERVER_REQUIRED;
    }

    do {
        if (fForceRediscovery)
        {
           dwGetDCFlags |= DS_FORCE_REDISCOVERY;
        }
	ldaperr = LDAP_SERVER_DOWN;

        // netapi32!DsGetDcName is delay loaded, so wrap

        __try
        {
            // Get the GC location
            hr = DsGetDcName(
			NULL,     // Delayload wrapped
			NULL, 
			NULL, 
			NULL,
			dwGetDCFlags,
			&pDomainInfo);
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        if (S_OK != hr)
        {
	    hr = HRESULT_FROM_WIN32(hr);
            if (fForceRediscovery)
            {
                goto error;
            }
	    fForceRediscovery = TRUE;
	    continue;
        }

        if (NULL == pDomainInfo ||
            (fGC && 0 == (DS_GC_FLAG & pDomainInfo->Flags)) ||
            0 == (DS_DNS_CONTROLLER_FLAG & pDomainInfo->Flags) ||
            NULL == pDomainInfo->DomainControllerName)
        {
            if (!fForceRediscovery)
            {
                fForceRediscovery = TRUE;
                continue;
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
            goto error;
        }

        pwszDomainControllerName = pDomainInfo->DomainControllerName;

        // skip past forward slashes (why are they there?)

        while (L'\\' == *pwszDomainControllerName)
        {
            pwszDomainControllerName++;
        }

        // bind to ds

        pld = ldap_init(
		    const_cast<WCHAR *>(pwszDomainControllerName),
		    fGC? LDAP_GC_PORT : LDAP_PORT);
        if (NULL == pld)
	{
            ldaperr = LdapGetLastError();
	}
        else
        {
            // do this because we're explicitly setting DC name

            ldaperr = ldap_set_option(pld, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

	    ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        }
        hr = myHError(LdapMapErrorToWin32(ldaperr));

        if (fForceRediscovery)
        {
            break;
        }
        fForceRediscovery = TRUE;

    } while (LDAP_SERVER_DOWN == ldaperr);

    // everything's cool, party down

    if (S_OK == hr)
    {
        if (NULL != ppszForestDNSName)
        {
             hr = myDupString(
			pDomainInfo->DomainControllerName,
			ppszForestDNSName);

             if(S_OK != hr)
                 goto error;
        }
        *ppldap = pld;
        pld = NULL;
    }

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

    // we know netapi32 was already loaded safely (that's where we got
    // pDomainInfo), so no need to wrap

    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);     // Delayload wrapped
    }
    return(hr);
}

HRESULT
myRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC)
{
    return(myRobustLdapBindEx(ppldap, NULL, fGC));
}

//--------------------------------------------------------------------
static HRESULT GetRootDomEntitySid(SID ** ppSid, DWORD dwEntityRid)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasError = 0;
    unsigned int nSubAuthorities = 0;
    unsigned int nSubAuthIndex = 0;

    // must be cleaned up
    SID * psidRootDomEntity=NULL;
    USER_MODALS_INFO_2 * pumi2=NULL;
    DOMAIN_CONTROLLER_INFOW * pdci=NULL;
    DOMAIN_CONTROLLER_INFOW * pdciForest=NULL;

    // initialize out params
    *ppSid=NULL;


    // get the forest name
    nasError=DsGetDcNameW(NULL, NULL, NULL, NULL, 0, &pdciForest);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    // get the top level DC name
    nasError=DsGetDcNameW(NULL, pdciForest->DnsForestName, NULL, NULL, 0, &pdci);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    // get the domain Sid on the top level DC.
    nasError=NetUserModalsGet(pdci->DomainControllerName, 2, (LPBYTE *)&pumi2);
    if(NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    nSubAuthorities=*GetSidSubAuthorityCount(pumi2->usrmod2_domain_id);

    // allocate storage for new Sid. account domain Sid + account Rid
    psidRootDomEntity=(SID *)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(nSubAuthorities+1)));

    if(NULL == psidRootDomEntity)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    // copy the first few peices into the SID
    if (!InitializeSid(psidRootDomEntity, 
            GetSidIdentifierAuthority(pumi2->usrmod2_domain_id), 
            (BYTE)(nSubAuthorities+1)))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    // copy existing subauthorities from account domain Sid into new Sid
    for (nSubAuthIndex=0; nSubAuthIndex < nSubAuthorities ; nSubAuthIndex++) {
        *GetSidSubAuthority(psidRootDomEntity, nSubAuthIndex)=
            *GetSidSubAuthority(pumi2->usrmod2_domain_id, nSubAuthIndex);
    }

    // append Rid to new Sid
    *GetSidSubAuthority(psidRootDomEntity, nSubAuthorities)=dwEntityRid;

    *ppSid=psidRootDomEntity;
    psidRootDomEntity=NULL;
    hr=S_OK;

error:
    if (NULL!=psidRootDomEntity) {
        FreeSid(psidRootDomEntity);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdci);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdciForest);
    }
    if (NULL!=pumi2) {
        NetApiBufferFree(pumi2);
    }

    return hr;
}


//--------------------------------------------------------------------
HRESULT GetRootDomAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ADMINS);
}


//***********************************************************************************
//
//
//    Main
//
//          This function will install new Windows 2002 certificate template if and onlyif
//    the following conditions are TRUE:
//
//          1. Whilster Schema
//          2. New certificate templates have not yet installed
//          3. The caller has privilege to install templates in the directory
//
//
//***********************************************************************************
void InstallWindows2002CertTemplates ()
{
    _TRACE (1, L"Entering InstallWindows2002CertTemplates()\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT             hr=S_OK;
    DWORD               dwErr=0;
    ULONG               ldaperr=0;
    struct l_timeval    timeout;
    DWORD               dwCount=0;
    LPWSTR              awszAttr[2];
    BOOL                fAccessAllowed = FALSE;
    DWORD               grantAccess=0;
    GENERIC_MAPPING     AccessMapping;
    PRIVILEGE_SET       ps;
    DWORD               dwPSSize = sizeof(ps);
    LDAPMessage         *Entry = NULL;
    CHAR                sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION };
       
    LDAPControl         se_info_control =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValue
                            },
                            TRUE
                        };

    LDAPControl         permissive_modify_control =
                        {
                            LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                            {
                                0, NULL
                            },
                            FALSE
                        };


    PLDAPControl        server_controls[3] =
                        {
                            &se_info_control,
                            &permissive_modify_control,
                            NULL
                        };



    HCERTTYPE           hCertType=NULL;      
    LDAP                *pld = NULL;
    CString             szConfig;
    CString             szDN;
    LDAPMessage         *SearchResult = NULL;
    LDAPMessage         *SDResult = NULL;
    struct berval       **apSD =NULL;
    PSECURITY_DESCRIPTOR    pSD=NULL;
    HANDLE              hClientToken=NULL;
    CString             text;
    CString             caption;
    SID                 * psidRootDomAdmins=NULL;
    BOOL                bIsRootDomAdmin=FALSE;
    CThemeContextActivator activator;



    //*************************************************************
    // 
    // check the schema version
    //
    _TRACE (0, L"Checking the schema version...\n");
    //retrieve the ldap handle and the config string
    if(S_OK != myDoesDSExist(TRUE))
    {
        _TRACE (0, L"No DS exists.\n");
        goto error;
    }

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
    {
        _TRACE (0, L"Error: Failed to bind to the DS.\n");
        goto error;
    }

	dwErr = CAGetAuthoritativeDomainDn(pld, NULL, &szConfig);
	if(ERROR_SUCCESS != dwErr)
    {
        _TRACE (0, L"Error: Failed to get the domain name.\n");
	    hr = HRESULT_FROM_WIN32(dwErr);
        goto error;
    }

    szDN = SCHEMA_CONTAINER_NAME;
    szDN += szConfig;

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

    awszAttr[0]=L"cn";
    awszAttr[1]=NULL;
    
 	ldaperr = ldap_search_stW(
              pld, 
		      const_cast <PWCHAR>((PCWSTR) szDN),
		      LDAP_SCOPE_ONELEVEL,
		      L"(cn=ms-PKI-Enrollment-Flag)",
		      awszAttr,
		      0,
              &timeout,
		      &SearchResult);

    if ( LDAP_SUCCESS != ldaperr )
    {
        _TRACE (0, L"We have W2K Schema.  Exit\n");
        g_bSchemaIsW2K = true;
        hr = S_OK;
        goto error;
    }

    dwCount = ldap_count_entries(pld, SearchResult);

    if(0 == dwCount)
    {
        _TRACE (0, L"We have W2K Schema.  Exit\n");
        hr=S_OK;
        goto error;
    }


    //*************************************************************
    // 
    //  check if keyRecoveryAgent certificate is present and
    //  and update to date
    //
    _TRACE (0, L"Checking if keyRecoveryAgent certificate is present...\n");
    hr=CAFindCertTypeByName(
                wszCERTTYPE_DS_EMAIL_REPLICATION,
                NULL,
                CT_ENUM_MACHINE_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                &hCertType);

    if((S_OK == hr) && (NULL!=hCertType))
    {
        _TRACE (0, L"Key Recovery Agent certificate template already exists.\n");	

        //check if the template is update to date
        if(CAIsCertTypeCurrent(0, wszCERTTYPE_DS_EMAIL_REPLICATION))
        {
            _TRACE (0, L"Key Recovery Agent certificate template is current.  Exit\n");	
            goto error;
        }
    }

    //*************************************************************
    // 
    //  check the write access
    //
    //
    _TRACE (0, L"Checking the write access...\n");
    if(NULL==(hClientToken=GetClientIdentity()))
    {
        TRACE (0, L"Can not retrieve client identity.\n");
        hr = myHError(GetLastError());
        goto error;
    }

    //get the SD of the certificate template container
    _TRACE (0, L"Getting the SD of the certificate template container...\n");
    szDN = TEMPLATE_CONTAINER_NAME;
    szDN += szConfig;



    awszAttr[0]=CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    awszAttr[1]=NULL;

    ldaperr = ldap_search_ext_sW(
                  pld, 
		          const_cast <PWCHAR>((PCWSTR) szDN),
		          LDAP_SCOPE_BASE,
		          L"(objectclass=*)",
		          awszAttr,
		          0,
                  (PLDAPControl *)&server_controls,
                  NULL,
                  &timeout,
                  10,
		          &SDResult);

    if(LDAP_SUCCESS != ldaperr)
    {
        _TRACE (0, L"Fail to locate the template container.\n");
        hr = myHError(LdapMapErrorToWin32(ldaperr));
        goto error;
    }

    if(NULL == (Entry = ldap_first_entry(pld, SDResult)))
    {
        _TRACE (0, L"Can not find first entry for template container.\n");
        hr = E_UNEXPECTED;
        goto error;
    }

    apSD = ldap_get_values_len(pld, Entry, CERTTYPE_SECURITY_DESCRIPTOR_NAME);
    if(apSD == NULL)
    {
        _TRACE (0, L"Can not retrieve security descriptor.\n");
        hr = E_FAIL;
        goto error;
   }

    pSD = LocalAlloc(LMEM_FIXED, (*apSD)->bv_len);
    if(pSD == NULL)
    {
        _TRACE (0, L"Error: No more memory.\n");
        hr = E_OUTOFMEMORY;
        goto error;
    }

    CopyMemory(pSD, (*apSD)->bv_val, (*apSD)->bv_len);

    //check the write access
    _TRACE (0, L"Checking the write access...\n");
    if(!AccessCheckByType(
		  pSD,                      // security descriptor
		  NULL,                     // SID of object being checked
		  hClientToken,             // handle to client access token
		  ACTRL_DS_CREATE_CHILD |
          ACTRL_DS_LIST,            // requested access rights 
		  NULL,                     // array of object types
		  0,                        // number of object type elements
		  &AccessMapping,           // map generic to specific rights
		  &ps,                      // receives privileges used
		  &dwPSSize,                // size of privilege-set buffer
		  &grantAccess,             // retrieves mask of granted rights
		  &fAccessAllowed))         // retrieves results of access check);
    {
        _TRACE (0, L"Error: Fail to check the write access.\n");
        hr = myHError(GetLastError());
        goto error;
    }

    if(!fAccessAllowed)
    {
        _TRACE (0, L"No previlege to create certificate template.  Exit\n");
        hr = S_OK;
        goto error;
    }

    //*************************************************************
    // 
    //  check the root domain admin rights
    //
    //
    hr=GetRootDomAdminSid(&psidRootDomAdmins);

    if( FAILED (hr) )
    {
        _TRACE (0, L"Error: GetRootDomAdminSid.\n");
        goto error;
    }


    // check for membership
    if (!CheckTokenMembership(NULL, psidRootDomAdmins, &bIsRootDomAdmin)) 
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _TRACE (0, L"Error: CheckTokenMembership.\n");
        goto error;
    }

    if(FALSE == bIsRootDomAdmin)
    {
        VERIFY (caption.LoadString (IDS_CERTTMPL));
        VERIFY (text.LoadString (IDS_MUST_HAVE_DOMAIN_ADMIN_RIGHTS_TO_INSTALL_CERT_TEMPLATES));
        MessageBoxW (NULL, 
                    text,
                    caption,
                    MB_ICONWARNING | MB_OK);

        _TRACE (0, L"No domain admin rights to create certificate template.  Exit\n");
        hr = S_OK;
        goto error;
    }

    //*************************************************************
    // 
    //  everything looks good.  Install the certificate templates
    //
    //
    _TRACE (0, L"Everything looks good.  Installing the certificate templates...\n");

    VERIFY (caption.LoadString (IDS_CERTTMPL));
    VERIFY (text.LoadString (IDS_INSTALL_WINDOWS2002_CERT_TEMPLATES));

    if ( IDYES == MessageBoxW (
                NULL, 
                text,
                caption,
                MB_YESNO) )
    {
        hr=CAInstallDefaultCertType(0);

        if(hr != S_OK)
        {
            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_INSTALL_FAILURE_WINDOWS2002_CERT_TEMPLATES, GetSystemMessage (hr));

            MessageBoxW(
                    NULL, 
                    text,
                    caption,
                    MB_ICONWARNING | MB_OK);
        }
        else
        {
            VERIFY (caption.LoadString (IDS_CERTTMPL));
            VERIFY (text.LoadString (IDS_INSTALL_SUCCESS_WINDOWS2002_CERT_TEMPLATES));

            MessageBoxW(
                    NULL, 
                    text,
                    caption,
                    MB_OK);
        }
    }
    else
    {
        hr=S_OK;
    }

error:

    if (psidRootDomAdmins) 
        FreeSid(psidRootDomAdmins);

    if(hClientToken)
        CloseHandle(hClientToken);

    if(pSD)
        LocalFree(pSD);

    if(apSD != NULL)
        ldap_value_free_len(apSD);

    if(SDResult)
        ldap_msgfree(SDResult);

    if(SearchResult)
        ldap_msgfree(SearchResult);


    if(hCertType)
        CACloseCertType(hCertType);


    if (pld)
        ldap_unbind(pld);
    _TRACE (1, L"Entering InstallWindows2002CertTemplates()\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\templatev2subjectnamepropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SubjectNamePropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2SubjectNamePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV2SubjectNamePropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SubjectNamePropertyPage property page

CTemplateV2SubjectNamePropertyPage::CTemplateV2SubjectNamePropertyPage(
        CCertTemplate& rCertTemplate, bool& rbIsDirty, bool bIsComputerOrDC) 
    : CHelpPropertyPage(CTemplateV2SubjectNamePropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_rbIsDirty (rbIsDirty),
    m_bIsComputerOrDC (bIsComputerOrDC)
{
	//{{AFX_DATA_INIT(CTemplateV2SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CTemplateV2SubjectNamePropertyPage::~CTemplateV2SubjectNamePropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateV2SubjectNamePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2SubjectNamePropertyPage)
	DDX_Control(pDX, IDC_SUBJECT_NAME_NAME_COMBO, m_nameCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2SubjectNamePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2SubjectNamePropertyPage)
	ON_BN_CLICKED(IDC_SUBJECT_AND_SUBJECT_ALT_NAME, OnSubjectAndSubjectAltName)
	ON_CBN_SELCHANGE(IDC_SUBJECT_NAME_NAME_COMBO, OnSelchangeSubjectNameNameCombo)
	ON_BN_CLICKED(IDC_SUBJECT_NAME_BUILT_BY_CA, OnSubjectNameBuiltByCa)
	ON_BN_CLICKED(IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, OnSubjectNameSuppliedInRequest)
	ON_BN_CLICKED(IDC_DNS_NAME, OnDnsName)
	ON_BN_CLICKED(IDC_EMAIL_IN_ALT, OnEmailInAlt)
	ON_BN_CLICKED(IDC_EMAIL_IN_SUB, OnEmailInSub)
	ON_BN_CLICKED(IDC_SPN, OnSpn)
	ON_BN_CLICKED(IDC_UPN, OnUpn)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SubjectNamePropertyPage message handlers

void CTemplateV2SubjectNamePropertyPage::OnSubjectAndSubjectAltName() 
{
    EnableControls ();	
}

void CTemplateV2SubjectNamePropertyPage::EnableControls()
{
    BOOL    bEnable = FALSE;

   
    if ( m_rCertTemplate.ReadOnly () )
    {
        bEnable = FALSE;
        GetDlgItem (IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_NAME_BUILT_BY_CA)->EnableWindow (FALSE);
    }
    else if ( BST_CHECKED == SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_GETCHECK) )
        bEnable = TRUE;

    GetDlgItem (IDC_SUBJECT_NAME_NAME_COMBO)->EnableWindow (bEnable);
    GetDlgItem (IDC_SUBJECT_NAME_NAME_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_EMAIL_IN_ALT)->EnableWindow (bEnable);
    GetDlgItem (IDC_DNS_NAME)->EnableWindow (bEnable); // removed for bug 253823 "&& !m_bIsComputerOrDC);"
    GetDlgItem (IDC_UPN)->EnableWindow (bEnable);
    GetDlgItem (IDC_SPN)->EnableWindow (bEnable);

    BOOL    bEnableEmailInSub = FALSE;
    if ( bEnable )
    {
        int nSel = m_nameCombo.GetCurSel ();
        if ( nSel >= 0 )
        {
            if ( NAME_TYPE_NONE != m_nameCombo.GetItemData (nSel) )
                bEnableEmailInSub = TRUE;
        }
    }
   
    GetDlgItem (IDC_EMAIL_IN_SUB)->EnableWindow (bEnableEmailInSub);
    if ( !bEnableEmailInSub )
        SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_SETCHECK, BST_UNCHECKED);
}


BOOL CTemplateV2SubjectNamePropertyPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog ();

    // Initialize Combo Box
    CString text;

    VERIFY (text.LoadString (IDS_SUBJECT_NAME_NONE));
    int nIndex = m_nameCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_nameCombo.SetCurSel (nIndex); // set by default
        m_nameCombo.SetItemData (nIndex, (DWORD_PTR) NAME_TYPE_NONE);
    }

    VERIFY (text.LoadString (IDS_FULL_DN));
    nIndex = m_nameCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_nameCombo.SetItemData (nIndex, (DWORD_PTR) NAME_TYPE_FULL_DN);
        if ( m_rCertTemplate.SubjectNameMustBeFullDN () )
            m_nameCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_CN_ONLY));
    nIndex = m_nameCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_nameCombo.SetItemData (nIndex, (DWORD_PTR) NAME_TYPE_CN_ONLY);
        if ( m_rCertTemplate.SubjectNameMustBeCN () )
            m_nameCombo.SetCurSel (nIndex);
    }

    // Initialize Radio buttons
    if ( m_rCertTemplate.RequireSubjectInRequest () )
        SendDlgItemMessage (IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_SETCHECK, BST_CHECKED);

    // Initialize Check boxes
    if ( m_rCertTemplate.SubjectNameIncludesEMail () )
        SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesDNS () )
        SendDlgItemMessage (IDC_DNS_NAME, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesEMail () )
        SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesUPN () )
        SendDlgItemMessage (IDC_UPN, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesSPN () )
        SendDlgItemMessage (IDC_SPN, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    return TRUE;
}

void CTemplateV2SubjectNamePropertyPage::SetSettingsForNameTypeNone ()
{
    m_rCertTemplate.SubjectNameMustBeCN (false);
    m_rCertTemplate.SubjectNameMustBeFullDN (false);
    int nCntChecked = 0;

    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK) )
        nCntChecked++;
    if ( BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK) )
        nCntChecked++;
    if ( BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK) )
        nCntChecked++;
    if ( BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK) )
        nCntChecked++;

    if ( 0 == nCntChecked )
    {
        m_rCertTemplate.AltNameIncludesUPN (true);
        SendDlgItemMessage (IDC_UPN, BM_SETCHECK, BST_CHECKED);
    }

    // NTRAID# 313588 CertTMPL: If subject name format  = none, 
    // sub alt name should be marked as critical for D.C.A. cert 
    // template.
    m_rCertTemplate.ModifyCriticalExtensions (szOID_SUBJECT_ALT_NAME, true);
}

void CTemplateV2SubjectNamePropertyPage::OnSelchangeSubjectNameNameCombo() 
{
    SetModified ();
    m_rbIsDirty = true;

    int nSel = m_nameCombo.GetCurSel ();
    if ( nSel >= 0 )
    {
        switch (m_nameCombo.GetItemData (nSel) )
        {
        case NAME_TYPE_NONE:
            SetSettingsForNameTypeNone ();
            break;

        case NAME_TYPE_FULL_DN:
            m_rCertTemplate.SubjectNameMustBeCN (false);
            m_rCertTemplate.SubjectNameMustBeFullDN (true);
            // NTRAID# 313588 CertTMPL: If subject name format  = none, 
            // sub alt name should be marked as critical for D.C.A. cert 
            // template.
            m_rCertTemplate.ModifyCriticalExtensions (szOID_SUBJECT_ALT_NAME, 
                    false);
            break;

        case NAME_TYPE_CN_ONLY:
            m_rCertTemplate.SubjectNameMustBeCN (true);
            m_rCertTemplate.SubjectNameMustBeFullDN (false);
            // NTRAID# 313588 CertTMPL: If subject name format  = none, 
            // sub alt name should be marked as critical for D.C.A. cert 
            // template.
            m_rCertTemplate.ModifyCriticalExtensions (szOID_SUBJECT_ALT_NAME, 
                    false);
            break;

        default:
            ASSERT (0);
            break;
        }
    }

    EnableControls ();
}

void CTemplateV2SubjectNamePropertyPage::OnSubjectNameBuiltByCa() 
{
    SetModified ();
    SendDlgItemMessage (IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, BM_SETCHECK, BST_UNCHECKED);
    m_rbIsDirty = true;

    m_rCertTemplate.RequireSubjectInRequest (false);

	EnableControls ();
}

void CTemplateV2SubjectNamePropertyPage::OnSubjectNameSuppliedInRequest() 
{
    SetModified ();
    SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_SETCHECK, BST_UNCHECKED);
    m_rbIsDirty = true;
    m_rCertTemplate.RequireSubjectInRequest (true);

    // Clear all "built by CA" settings
    int nCnt = m_nameCombo.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        if ( NAME_TYPE_NONE == m_nameCombo.GetItemData (nIndex) )
        {
            m_nameCombo.SetCurSel (nIndex);
            break;
        }
    }
    SetSettingsForNameTypeNone ();

    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_GETCHECK) )
    {
        SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_SETCHECK, BST_UNCHECKED);
        m_rCertTemplate.SubjectNameIncludesEMail (false);
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK) &&
            CanUncheckLastSetting (IDC_EMAIL_IN_ALT) )
    {
        SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_SETCHECK, BST_UNCHECKED);
        m_rCertTemplate.AltNameIncludesEMail (false);
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK) &&
            CanUncheckLastSetting (IDC_DNS_NAME) )
    {
        m_rCertTemplate.AltNameIncludesDNS (false);
        SendDlgItemMessage (IDC_DNS_NAME, BM_SETCHECK, BST_UNCHECKED);
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK) && 
            CanUncheckLastSetting (IDC_UPN) )
    {
        m_rCertTemplate.AltNameIncludesUPN (false);
        SendDlgItemMessage (IDC_UPN, BM_SETCHECK, BST_UNCHECKED);  
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK) &&
            CanUncheckLastSetting (IDC_SPN) )
    {
        m_rCertTemplate.AltNameIncludesSPN (false);
        SendDlgItemMessage (IDC_SPN, BM_SETCHECK, BST_UNCHECKED);
    }

	EnableControls ();
}

void CTemplateV2SubjectNamePropertyPage::OnDnsName() 
{
    if ( CanUncheckLastSetting (IDC_DNS_NAME) )
    {
        m_rCertTemplate.AltNameIncludesDNS (
                BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK));
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnEmailInAlt() 
{
    if ( CanUncheckLastSetting (IDC_EMAIL_IN_ALT) )
    {
        m_rCertTemplate.AltNameIncludesEMail (
                BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK));
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnEmailInSub() 
{
    m_rCertTemplate.SubjectNameIncludesEMail (
            BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_GETCHECK));
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnSpn() 
{
    if ( CanUncheckLastSetting (IDC_SPN) )
    {
        m_rCertTemplate.AltNameIncludesSPN (
                BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK));
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnUpn() 
{
    if ( CanUncheckLastSetting (IDC_UPN) )
    {
        m_rCertTemplate.AltNameIncludesUPN (
                BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK));  
    }
    SetModified ();
    m_rbIsDirty = true;
}


bool CTemplateV2SubjectNamePropertyPage::CanUncheckLastSetting(int ctrlID)
{
    bool    bResult = true;

    // If request is to be built by CA and "none" is selected for subject name,
    // ensure that at least one of the alt-name options is checked
    // If the control in question is now unchecked, verify that at least
    // one other is checked
    if ( BST_UNCHECKED == SendDlgItemMessage (ctrlID, BM_GETCHECK) )
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_GETCHECK) )
        {
            int nSel = m_nameCombo.GetCurSel ();
            if ( nSel >= 0 )
            {
                if ( NAME_TYPE_NONE == m_nameCombo.GetItemData (nSel) )
                {
                    int nCntChecked = 0;

                    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK) )
                        nCntChecked++;
                    if ( BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK) )
                        nCntChecked++;
                    if ( BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK) )
                        nCntChecked++;
                    if ( BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK) )
                        nCntChecked++;

                    if ( 0 == nCntChecked )
                    {
                        CString text;
                        CString caption;
                        CThemeContextActivator activator;

                        VERIFY (caption.LoadString (IDS_CERTTMPL));
                        VERIFY (text.LoadString (IDS_AT_LEAST_1_NAME_OPTION_MUST_BE_CHECKED));

                        MessageBox (text, caption, MB_OK);

                        bResult = false;
                        SendDlgItemMessage (ctrlID, BM_SETCHECK, BST_CHECKED);
                    }
                }
            }
        }
    }

    return bResult;
}

void CTemplateV2SubjectNamePropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2SubjectNamePropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_SUBJECT_NAME) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2SubjectNamePropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\viewoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ViewOIDDlg.cpp
//
//  Contents:   Implementation of CViewOIDDlg
//
//----------------------------------------------------------------------------
// ViewOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "ViewOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern POLICY_OID_LIST	    g_policyOIDList;
extern PCWSTR               pcszNEWLINE;

/////////////////////////////////////////////////////////////////////////////
// CViewOIDDlg dialog


CViewOIDDlg::CViewOIDDlg(CWnd* pParent /*=NULL*/)
	: CHelpDialog(CViewOIDDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CViewOIDDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CViewOIDDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CViewOIDDlg)
	DDX_Control(pDX, IDC_OID_LIST, m_oidList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewOIDDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CViewOIDDlg)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_OID_LIST, OnItemchangedOidList)
	ON_BN_CLICKED(IDC_COPY_OID, OnCopyOid)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_OID_LIST, OnColumnclickOidList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewOIDDlg message handlers

BOOL CViewOIDDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	

    GetDlgItem (IDC_COPY_OID)->EnableWindow (FALSE);

    // Set up list control
	int	colWidths[NUM_COLS] = {200, 150, 100, 100};

    // Set to full-row select
    DWORD   dwExstyle = m_oidList.GetExtendedStyle ();
	m_oidList.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT);


	// Add "Policy Name" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_POLICY_NAME));
	VERIFY (m_oidList.InsertColumn (COL_POLICY_NAME, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_POLICY_NAME], COL_POLICY_NAME) != -1);

	VERIFY (szText.LoadString (IDS_OID));
	VERIFY (m_oidList.InsertColumn (COL_OID, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_OID], COL_OID) != -1);
	
	VERIFY (szText.LoadString (IDS_POLICY_TYPE));
	VERIFY (m_oidList.InsertColumn (COL_POLICY_TYPE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_POLICY_TYPE], COL_POLICY_TYPE) != -1);

	VERIFY (szText.LoadString (IDS_CPS_LOCATION));
	VERIFY (m_oidList.InsertColumn (COL_CPS_LOCATION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CPS_LOCATION], COL_CPS_LOCATION) != -1);
    m_oidList.SetColumnWidth (COL_CPS_LOCATION, LVSCW_AUTOSIZE_USEHEADER);

    // Fill list
    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            if ( FAILED (InsertItemInList (pPolicyOID)) )
                break;
        }
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CViewOIDDlg::InsertItemInList (CPolicyOID* pPolicyOID)
{
    ASSERT (pPolicyOID);
    if ( !pPolicyOID )
        return E_POINTER;

    if ( !pPolicyOID->IsApplicationOID () && !pPolicyOID->IsIssuanceOID () )
        return S_OK;  // not a failure, but don't add

    HRESULT hr = S_OK;
	LV_ITEM	lvItem;
	int		iItem = m_oidList.GetItemCount ();
	int iResult = 0;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_POLICY_NAME;
	lvItem.pszText = (PWSTR)(PCWSTR) pPolicyOID->GetDisplayName ();
    lvItem.lParam = (LPARAM) pPolicyOID;
	iItem = m_oidList.InsertItem (&lvItem);
	ASSERT (-1 != iItem);
	if ( -1 == iItem )
		hr = E_FAIL;

    if ( SUCCEEDED (hr) )
    {
	    ::ZeroMemory (&lvItem, sizeof (lvItem));
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = iItem;
        lvItem.iSubItem = COL_OID;
        lvItem.pszText = (PWSTR)(PCWSTR) pPolicyOID->GetOIDW ();
	    iResult = m_oidList.SetItem (&lvItem);
        ASSERT (-1 != iResult);
	    if ( -1 == iResult )
		    hr = E_FAIL;
    }

    if ( SUCCEEDED (hr) )
    {
        lvItem.iSubItem = COL_POLICY_TYPE;
        CString text;
        if ( pPolicyOID->IsApplicationOID () )
            VERIFY (text.LoadString (IDS_APPLICATION));
        else // Is issuance OID
            VERIFY (text.LoadString (IDS_ISSUANCE));
        lvItem.pszText = (PWSTR)(PCWSTR) text;
	    iResult = m_oidList.SetItem (&lvItem);
        ASSERT (-1 != iResult);
	    if ( -1 == iResult )
		    hr = E_FAIL;
    }


    if ( SUCCEEDED (hr) && pPolicyOID->IsIssuanceOID () )
    {
        lvItem.iSubItem = COL_CPS_LOCATION;
    
        PWSTR   pszCPS = 0;
        hr = CAOIDGetProperty(
                    pPolicyOID->GetOIDW (),
                    CERT_OID_PROPERTY_CPS,
                    &pszCPS);
        if ( SUCCEEDED (hr) )
        {
            lvItem.pszText = pszCPS;
	        iResult = m_oidList.SetItem (&lvItem);
            ASSERT (-1 != iResult);
	        if ( -1 == iResult )
		        hr = E_FAIL;

            CAOIDFreeProperty (pszCPS);
        }
        else if ( HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ||
                HRESULT_FROM_WIN32 (ERROR_DS_OBJ_NOT_FOUND) == hr )
        {
            hr = S_OK;
        }
        else
        {
            _TRACE (0, L"CAOIDGetProperty (%s, CERT_OID_PROPERTY_CPS) failed: 0x%x\n", 
                    (PCWSTR) pPolicyOID->GetOIDW (), hr);
            hr = S_OK;
        }
    }

    return hr;
}

void CViewOIDDlg::OnItemchangedOidList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
//	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    GetDlgItem (IDC_COPY_OID)->EnableWindow (m_oidList.GetSelectedCount () > 0);
	
	*pResult = 0;
}

void CViewOIDDlg::OnCopyOid() 
{
    CString szText;
    int nCnt = m_oidList.GetItemCount ();
    if ( nCnt > 0 && m_oidList.GetSelectedCount () > 0 )
    {
        for (int nItem = 0; nItem < nCnt; nItem++)
        {
            if ( LVIS_SELECTED == m_oidList.GetItemState (nItem, LVIS_SELECTED) )
            {
                if ( !szText.IsEmpty () )
                    szText += pcszNEWLINE;
                szText += m_oidList.GetItemText (nItem, COL_OID);
            }
        }
    }

    if ( !szText.IsEmpty () )
    {
        if ( OpenClipboard () ) 
        {
            if ( EmptyClipboard () )
            {
                size_t  nLen = wcslen (szText);
                HGLOBAL hglbCopy = GlobalAlloc (GMEM_MOVEABLE, 
                        (nLen + 1) * sizeof (WCHAR)); 
                if ( hglbCopy )
                {

                    PWSTR pszCopy = (PWSTR) GlobalLock (hglbCopy); 
                    if ( pszCopy )
                    {
                        wcscpy (pszCopy, szText); 
                        GlobalUnlock(hglbCopy); 
 
                        // Place the handle on the clipboard. 
 
                        if ( !SetClipboardData (CF_UNICODETEXT, hglbCopy) )
                        {
                            ASSERT (0);
                            _TRACE (0, L"SetClipboardData () failed: %d\n", GetLastError ());
                            GlobalFree (hglbCopy);
                        }
                    }
                    else
                        GlobalFree (hglbCopy);
                }

                if ( !CloseClipboard () ) 
                {
                    ASSERT (0);
                    _TRACE (0, L"CloseClipboard () failed: %d\n", GetLastError ());
                }
            }
            else
            {
                ASSERT (0);
                _TRACE (0, L"EmptyClipboard () failed: %d\n", GetLastError ());
            }
        }
        else
        {
            ASSERT (0);
            _TRACE (0, L"OpenClipboard () failed: %d\n", GetLastError ());
        }
    }
}

int CALLBACK CViewOIDDlg::fnCompareOIDItems (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int iVal = 0;

    if ( lParam1 && lParam2 )
    {
        CPolicyOID* pPolicyOID1 = (CPolicyOID*) lParam1;
        CPolicyOID* pPolicyOID2 = (CPolicyOID*) lParam2;
        switch (lParamSort)
        {
        case COL_POLICY_NAME:
            iVal = LocaleStrCmp (pPolicyOID1->GetDisplayName (), 
                    pPolicyOID2->GetDisplayName ());
            break;

        case COL_OID:
            iVal = LocaleStrCmp (pPolicyOID1->GetOIDW (), 
                    pPolicyOID2->GetOIDW ());
            break;

        case COL_POLICY_TYPE:
            {
                CString szApplication;
                CString szIssuance;

                VERIFY (szApplication.LoadString (IDS_APPLICATION));
                VERIFY (szIssuance.LoadString (IDS_ISSUANCE));
                iVal = LocaleStrCmp (pPolicyOID1->IsApplicationOID () ? szApplication : szIssuance, 
                        pPolicyOID2->IsApplicationOID () ? szApplication : szIssuance);
            }
            break;

        case COL_CPS_LOCATION:
            {
                CString strItem1;
                CString strItem2;

                if ( pPolicyOID1->IsIssuanceOID () )
                {
                    PWSTR   pszCPS = 0;
                    if ( SUCCEEDED (CAOIDGetProperty(
                                pPolicyOID1->GetOIDW (),
                                CERT_OID_PROPERTY_CPS,
                                &pszCPS)) )
                    {
                        strItem1 = pszCPS;
                    }
                }

                if ( pPolicyOID2->IsIssuanceOID () )
                {
                    PWSTR   pszCPS = 0;
                    if ( SUCCEEDED (CAOIDGetProperty(
                                pPolicyOID2->GetOIDW (),
                                CERT_OID_PROPERTY_CPS,
                                &pszCPS)) )
                    {
                        strItem2 = pszCPS;
                    }
                }

                iVal = LocaleStrCmp (strItem1, strItem2);
            }
            break;

        default:
            ASSERT (0);
            break;
        }
    }

    return iVal;
}


void CViewOIDDlg::OnColumnclickOidList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    if ( pNMListView )
    {
        m_oidList.SortItems ((PFNLVCOMPARE) fnCompareOIDItems, 
                (LPARAM) pNMListView->iSubItem);
        
    }
	
	*pResult = 0;
}

void CViewOIDDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CViewOIDDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_VIEW_OIDS) )
		{
			_TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CViewOIDDlg::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\about.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       About.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------\
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
//	HISTORY
//	01-Aug-97	t-danm		Creation.
//  11-Sep-97	bryanwal	Modify for certificate manager
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "about.h"

#include "stdabout.cpp" 

/////////////////////////////////////////////////////////////////////
CCertMgrAbout::CCertMgrAbout()
{
	m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
	m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CERTMGR;
	m_uIdBitmapSmallImage = IDB_CERTMGR_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTMGR_SMALL;
	m_uIdBitmapLargeImage = IDB_CERTMGR_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}


/////////////////////////////////////////////////////////////////////
CPublicKeyPoliciesAbout::CPublicKeyPoliciesAbout()
{
	m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
	m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINPKPABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CERTMGR;
	m_uIdBitmapSmallImage = IDB_CERTMGR_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTMGR_SMALL;
	m_uIdBitmapLargeImage = IDB_CERTMGR_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}

/////////////////////////////////////////////////////////////////////
CSaferWindowsAbout::CSaferWindowsAbout()
{
	m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
	m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINSAFERWINDOWSABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_SAFER_WINDOWS_SNAPIN;
	m_uIdBitmapSmallImage = IDB_CERTMGR_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTMGR_SMALL;
	m_uIdBitmapLargeImage = IDB_SAFERWINDOWS_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certentp\viewoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ViewOIDDlg.h
//
//  Contents:   Definition of CViewOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_VIEWOIDDLG_H__CACA6370_0DB7_423B_80AD_C8F0F30D75D9__INCLUDED_)
#define AFX_VIEWOIDDLG_H__CACA6370_0DB7_423B_80AD_C8F0F30D75D9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ViewOIDDlg.h : header file
//

#include "PolicyOID.h"

/////////////////////////////////////////////////////////////////////////////
// CViewOIDDlg dialog

class CViewOIDDlg : public CHelpDialog
{
// Construction
public:
	CViewOIDDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CViewOIDDlg)
	enum { IDD = IDD_VIEW_OIDS };
	CListCtrl	m_oidList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CViewOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
	enum {
		COL_POLICY_NAME = 0,
        COL_OID,
        COL_POLICY_TYPE,
        COL_CPS_LOCATION,
		NUM_COLS	// must be last
	};

protected:
    virtual void DoContextHelp (HWND hWndControl);
    static int CALLBACK fnCompareOIDItems (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    HRESULT InsertItemInList (CPolicyOID* pPolicyOID);

	// Generated message map functions
	//{{AFX_MSG(CViewOIDDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnItemchangedOidList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCopyOid();
	afx_msg void OnColumnclickOidList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIEWOIDDLG_H__CACA6370_0DB7_423B_80AD_C8F0F30D75D9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrslast.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSLast.cpp
//
//  Contents:   Implementation of Auto Cert Request Wizard Completion Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "ACRSLast.h"
#include "ACRSPSht.h"
#include "storegpe.h"


USE_HANDLE_MACROS("CERTMGR(ACRSLast.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Gross
#define MAX_GPE_NAME_SIZE  40


/////////////////////////////////////////////////////////////////////////////
// ACRSCompletionPage property page

IMPLEMENT_DYNCREATE (ACRSCompletionPage, CWizard97PropertyPage)

ACRSCompletionPage::ACRSCompletionPage () : CWizard97PropertyPage (ACRSCompletionPage::IDD)
{
	//{{AFX_DATA_INIT(ACRSCompletionPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

ACRSCompletionPage::~ACRSCompletionPage ()
{
}

void ACRSCompletionPage::DoDataExchange (CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange (pDX);
	//{{AFX_DATA_MAP(ACRSCompletionPage)
	DDX_Control (pDX, IDC_CHOICES_LIST, m_choicesList);
	DDX_Control (pDX, IDC_BOLD_STATIC, m_staticBold);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ACRSCompletionPage, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(ACRSCompletionPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ACRSCompletionPage message handlers

BOOL ACRSCompletionPage::OnInitDialog ()
{
	CWizard97PropertyPage::OnInitDialog ();
	
	m_staticBold.SetFont (&GetBigBoldFont ());

		// Set up columns in list view
	int	colWidths[NUM_COLS] = {150, 200};

	VERIFY (m_choicesList.InsertColumn (COL_OPTION, L"",
			LVCFMT_LEFT, colWidths[COL_OPTION], COL_OPTION) != -1);
	VERIFY (m_choicesList.InsertColumn (COL_VALUE, L"",
			LVCFMT_LEFT, colWidths[COL_VALUE], COL_VALUE) != -1);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL ACRSCompletionPage::OnSetActive ()
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive ();
	if ( bResult )
	{
		// Remove all items then repopulate.
		ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
		ASSERT (pSheet);
		if ( pSheet )
		{
			// If edit mode and nothing changed, show disabled finish
			if ( pSheet->GetACR () && !pSheet->m_bEditModeDirty )
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_DISABLEDFINISH | PSWIZB_BACK);
			else
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH | PSWIZB_BACK);

			if ( pSheet->IsDirty () )
				pSheet->MarkAsClean ();
			VERIFY (m_choicesList.DeleteAllItems ());
			CString	text;
			LV_ITEM	lvItem;
			int		iItem = 0;

			// Display cert type selection
			VERIFY (text.LoadString (IDS_CERTIFICATE_TYPE_COLUMN_NAME));

			::ZeroMemory (&lvItem, sizeof (lvItem));
			lvItem.mask = LVIF_TEXT;
			lvItem.iItem = iItem;
			lvItem.iSubItem = COL_OPTION;
			lvItem.pszText = (LPWSTR) (LPCWSTR) text;
			VERIFY (-1 != m_choicesList.InsertItem (&lvItem));

			WCHAR**		pawszPropertyValue = 0;
			HRESULT	hResult = ::CAGetCertTypeProperty (pSheet->m_selectedCertType,
					CERTTYPE_PROP_FRIENDLY_NAME,
					&pawszPropertyValue);
			ASSERT (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( pawszPropertyValue[0] )
				{
					VERIFY (m_choicesList.SetItemText (iItem, COL_VALUE,
							*pawszPropertyValue));
				}
				VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (
						pSheet->m_selectedCertType, pawszPropertyValue)));
			}
			iItem++;

			// Display CA selection
			VERIFY (text.LoadString (IDS_CERTIFICATE_AUTHORITIES));

			::ZeroMemory (&lvItem, sizeof (lvItem));
			lvItem.mask = LVIF_TEXT;
			lvItem.iSubItem = COL_OPTION;

			POSITION	pos = 0;
			HCAINFO		hCAInfo = 0;

			for (pos = pSheet->m_caInfoList.GetHeadPosition (); pos;)
			{
				lvItem.iItem = iItem;
				lvItem.pszText = (LPWSTR) (LPCWSTR) text;
				VERIFY (-1 != m_choicesList.InsertItem (&lvItem));

				hCAInfo = pSheet->m_caInfoList.GetNext (pos);
				ASSERT (hCAInfo);
				if ( hCAInfo )
				{
					hResult = ::CAGetCAProperty (hCAInfo, CA_PROP_DISPLAY_NAME,
							&pawszPropertyValue);
					ASSERT (SUCCEEDED (hResult));
					if ( SUCCEEDED (hResult) )
					{
						if ( pawszPropertyValue[0] )
						{
							VERIFY (m_choicesList.SetItemText (iItem, COL_VALUE,
									*pawszPropertyValue));
						}
						VERIFY (SUCCEEDED (::CAFreeCAProperty (hCAInfo, pawszPropertyValue)));
					}
				}
				text = L" ";	// only the first one has text in it
				iItem++;
			}
		}
	}

	return bResult;
}


BOOL ACRSCompletionPage::OnWizardFinish ()
{
    BOOL                        bResult = TRUE;
	HRESULT						hResult = S_OK;
	CWaitCursor					waitCursor;
	ACRSWizardPropertySheet*	pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		// If edit mode and nothing changed, just return
		if ( pSheet->GetACR () && !pSheet->m_bEditModeDirty )
		{
			ASSERT (0);
			return FALSE;
		}

				
		PCTL_ENTRY  pCTLEntry = NULL;
		DWORD       cCTLEntry = 0;

		hResult = GetCTLEntry (&cCTLEntry, &pCTLEntry);
		if ( SUCCEEDED (hResult) )
		{
			BYTE        *pbEncodedCTL = NULL;
			DWORD       cbEncodedCTL = 0;

			hResult = MakeCTL (cCTLEntry, pCTLEntry, &pbEncodedCTL, &cbEncodedCTL);
			if ( SUCCEEDED (hResult) )
			{
				bResult = pSheet->m_pCertStore->AddEncodedCTL (
						X509_ASN_ENCODING,
						pbEncodedCTL, cbEncodedCTL,
						CERT_STORE_ADD_REPLACE_EXISTING,
						NULL);
				if ( !bResult )
				{
					DWORD	dwErr = GetLastError ();
					hResult = HRESULT_FROM_WIN32 (dwErr);
					DisplaySystemError (m_hWnd, dwErr);
				}
			}

			if (pbEncodedCTL)
				::LocalFree (pbEncodedCTL);
		}

		if (pCTLEntry)
			::LocalFree (pCTLEntry);
	}
	
	if ( SUCCEEDED (hResult) )
		bResult = CWizard97PropertyPage::OnWizardFinish ();
	else
		bResult = FALSE;

    return bResult;
}




HRESULT ACRSCompletionPage::GetCTLEntry (OUT DWORD *pcCTLEntry, OUT PCTL_ENTRY *ppCTLEntry)
{
	HRESULT	hResult = S_OK;
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		const size_t	HASH_SIZE = 20;
		DWORD			cCA = (DWORD)pSheet->m_caInfoList.GetCount ();
		PCTL_ENTRY		pCTLEntry = (PCTL_ENTRY) ::LocalAlloc (LPTR,
										   (sizeof (CTL_ENTRY) + HASH_SIZE) *cCA);
		if ( pCTLEntry )
		{
			PBYTE			pbHash = (PBYTE) (pCTLEntry + cCA);
			HCAINFO			hCAInfo = NULL;
			PCCERT_CONTEXT  pCertContext = NULL;
			DWORD           cbHash = HASH_SIZE;
			DWORD           iCA = 0;

			for (POSITION pos = pSheet->m_caInfoList.GetHeadPosition (); pos;)
			{
				hCAInfo = pSheet->m_caInfoList.GetNext (pos);
				ASSERT (hCAInfo);
				if ( hCAInfo )
				{
					hResult = ::CAGetCACertificate (hCAInfo, &pCertContext);
					ASSERT (SUCCEEDED (hResult));
					if ( SUCCEEDED (hResult) )
					{
						cbHash = HASH_SIZE;
						if (::CertGetCertificateContextProperty (pCertContext,
														  CERT_SHA1_HASH_PROP_ID,
														  pbHash,
														  &cbHash))
						{
							pCTLEntry[iCA].SubjectIdentifier.cbData = cbHash;
							pCTLEntry[iCA].SubjectIdentifier.pbData = pbHash;
							pbHash += cbHash;
							::CertFreeCertificateContext (pCertContext);
							iCA++;
						}
						else
						{
							DWORD	dwErr = GetLastError ();
							hResult = HRESULT_FROM_WIN32 (dwErr);
							DisplaySystemError (m_hWnd, dwErr);
							break;
						}
					}
					else
						break;
				}
			}

			if ( SUCCEEDED (hResult) )
			{
				*pcCTLEntry = cCA;
				*ppCTLEntry = pCTLEntry;
			}
			else
			{
				if (pCTLEntry)
					::LocalFree (pCTLEntry);
			}
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}
	}

    return hResult;
}

HRESULT ACRSCompletionPage::MakeCTL (
             IN DWORD cCTLEntry,
             IN PCTL_ENTRY pCTLEntry,
             OUT BYTE **ppbEncodedCTL,
             OUT DWORD *pcbEncodedCTL)
{
	HRESULT					hResult = S_OK;
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		PCERT_EXTENSIONS        pCertExtensions = NULL;


		hResult = ::CAGetCertTypeExtensions (pSheet->m_selectedCertType, &pCertExtensions);
		ASSERT (SUCCEEDED (hResult));
		if ( SUCCEEDED (hResult) )
		{
			CMSG_SIGNED_ENCODE_INFO SignerInfo;
			memset (&SignerInfo, 0, sizeof (SignerInfo));
			CTL_INFO                CTLInfo;
			memset (&CTLInfo, 0, sizeof (CTLInfo));
			WCHAR**					pawszPropName = 0;


            ZeroMemory(&CTLInfo, sizeof(CTLInfo));
			// set up the CTL info
			CTLInfo.dwVersion = sizeof (CTLInfo);
			CTLInfo.SubjectUsage.cUsageIdentifier = 1;

			hResult = ::CAGetCertTypeProperty (pSheet->m_selectedCertType,
					CERTTYPE_PROP_DN,	&pawszPropName);
			ASSERT (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) && pawszPropName[0] )
			{
				LPSTR	psz = szOID_AUTO_ENROLL_CTL_USAGE;
                WCHAR   pwszGPEName[MAX_GPE_NAME_SIZE];

                IGPEInformation *pGPEInfo = pSheet->m_pCertStore->GetGPEInformation();

                ZeroMemory(pwszGPEName, MAX_GPE_NAME_SIZE*sizeof (WCHAR));

				CTLInfo.ListIdentifier.cbData = (DWORD) (sizeof (WCHAR) * (wcslen (pawszPropName[0]) + 1));

                if(pGPEInfo)
                {
                    pGPEInfo->GetName(pwszGPEName, sizeof(pwszGPEName)/sizeof(pwszGPEName[0]));
                    CTLInfo.ListIdentifier.cbData += (DWORD) (sizeof(WCHAR)*(wcslen(pwszGPEName)+1));
                }

				CTLInfo.ListIdentifier.pbData = (PBYTE)LocalAlloc(LPTR, CTLInfo.ListIdentifier.cbData);
                if(CTLInfo.ListIdentifier.pbData == NULL)
                {
                    hResult = E_OUTOFMEMORY;
                }

                if(pwszGPEName[0])
                {
                    wcscpy((LPWSTR)CTLInfo.ListIdentifier.pbData, pwszGPEName);
                    wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, L"|");
                }
                wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, pawszPropName[0]);


				CTLInfo.SubjectUsage.rgpszUsageIdentifier = &psz;
				::GetSystemTimeAsFileTime (&CTLInfo.ThisUpdate);
				CTLInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;
				CTLInfo.cCTLEntry = cCTLEntry;
				CTLInfo.rgCTLEntry = pCTLEntry;

				// UNDONE - add the cert type extension

				// add all the reg info as an extension
				CTLInfo.cExtension = pCertExtensions->cExtension;
				CTLInfo.rgExtension = pCertExtensions->rgExtension;

				// encode the CTL
				*pcbEncodedCTL = 0;
				SignerInfo.cbSize = sizeof (SignerInfo);
				if ( ::CryptMsgEncodeAndSignCTL (PKCS_7_ASN_ENCODING,
											  &CTLInfo, &SignerInfo, 0,
											  NULL, pcbEncodedCTL) )
				{
					*ppbEncodedCTL = (BYTE*) ::LocalAlloc (LPTR, *pcbEncodedCTL);
					if ( *ppbEncodedCTL )
					{
						if (!::CryptMsgEncodeAndSignCTL (PKCS_7_ASN_ENCODING,
													  &CTLInfo, &SignerInfo, 0,
													  *ppbEncodedCTL, pcbEncodedCTL))
						{
							DWORD	dwErr = GetLastError ();
							hResult = HRESULT_FROM_WIN32 (dwErr);
							DisplaySystemError (m_hWnd, dwErr);
						}
					}
					else
					{
						hResult = E_OUTOFMEMORY;
					}

				}
				else
				{
					DWORD	dwErr = GetLastError ();
					hResult = HRESULT_FROM_WIN32 (dwErr);
					DisplaySystemError (m_hWnd, dwErr);
				}

				VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (
						pSheet->m_selectedCertType, pawszPropName)));
			}
            if(CTLInfo.ListIdentifier.pbData)
            {
                ::LocalFree(CTLInfo.ListIdentifier.pbData);
            }

		}
		if (pCertExtensions)
			::LocalFree (pCertExtensions);
	}

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\about.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       about.h
//
//  Contents:
//
//----------------------------------------------------------------------------
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__


//	About for "Certificate Manager" snapin
class CCertMgrAbout :
	public CSnapinAbout,
	public CComCoClass<CCertMgrAbout, &CLSID_CertificateManagerAbout>

{
public:
DECLARE_REGISTRY(CCertMgrAbout, _T("CERTMGR.CertMgrAboutObject.1"), 
        _T("CERTMGR.CertMgrAboutObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	CCertMgrAbout();
};


//	About for "Public Key Policies" snapin
class CPublicKeyPoliciesAbout :
	public CSnapinAbout,
	public CComCoClass<CPublicKeyPoliciesAbout, &CLSID_PublicKeyPoliciesAbout>

{
public:
DECLARE_REGISTRY(CPublicKeyPoliciesAbout, _T("CERTMGR.PubKeyPolAboutObject.1"), 
        _T("CERTMGR.PubKeyPolAboutObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	CPublicKeyPoliciesAbout();
};

//	About for "Software Restriction Policies" snapin
class CSaferWindowsAbout :
	public CSnapinAbout,
	public CComCoClass<CSaferWindowsAbout, &CLSID_SaferWindowsAbout>

{
public:
DECLARE_REGISTRY(CSaferWindowsAbout, _T("CERTMGR.SaferWindowsAboutObject.1"), 
        _T("CERTMGR.SaferWindowsAboutObject.1"), IDS_CERTMGR_SAFER_WINDOWS_DESC, THREADFLAGS_BOTH)
	CSaferWindowsAbout();
};

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrslast.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSLast.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSLAST_H__1BCEA8C7_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
#define AFX_ACRSLAST_H__1BCEA8C7_756A_11D1_85D5_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSLast.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSCompletionPage dialog

class ACRSCompletionPage : public CWizard97PropertyPage
{
	DECLARE_DYNCREATE(ACRSCompletionPage)

// Construction
public:
	ACRSCompletionPage();
	virtual ~ACRSCompletionPage();

// Dialog Data
	//{{AFX_DATA(ACRSCompletionPage)
	enum { IDD = IDD_ACR_SETUP_FINAL };
	CListCtrl	m_choicesList;
	CStatic	m_staticBold;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ACRSCompletionPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HRESULT GetCTLEntry (OUT DWORD *pcCTLEntry, OUT PCTL_ENTRY *ppCTLEntry);
	HRESULT MakeCTL (IN DWORD cCTLEntry,
             IN PCTL_ENTRY pCTLEntry,
             OUT BYTE **ppbEncodedCTL,
             OUT DWORD *pcbEncodedCTL);

	// Generated message map functions
	//{{AFX_MSG(ACRSCompletionPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	enum {
		COL_OPTION = 0,
		COL_VALUE,
		NUM_COLS
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSLAST_H__1BCEA8C7_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrspsht.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSPSht.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "ACRSPSht.h"
#include "storegpe.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardPropertySheet

ACRSWizardPropertySheet::ACRSWizardPropertySheet(
		CCertStoreGPE* pCertStore, 
		CAutoCertRequest* pACR)
	:CWizard97PropertySheet (IDS_ACRS_WIZARD_SHEET_CAPTION, IDB_ACRS_WATERMARK, IDB_ACRS_BANNER), 
	m_bDirty (false),
	m_selectedCertType (0),
	m_pCertStore (pCertStore),
	m_pACR (pACR),
	m_bEditModeDirty (false)
{
	ASSERT (m_pCertStore);
	m_pCertStore->AddRef ();
	if ( m_pACR )
		m_pACR->AddRef ();
}

ACRSWizardPropertySheet::~ACRSWizardPropertySheet()
{
	m_pCertStore->Release ();
	if ( m_pACR )
		m_pACR->Release ();
}


bool ACRSWizardPropertySheet::IsDirty()
{
	return m_bDirty;
}

void ACRSWizardPropertySheet::MarkAsClean()
{
	m_bDirty = false;
}

void ACRSWizardPropertySheet::SetDirty()
{
	m_bDirty = true;
}

CAutoCertRequest* ACRSWizardPropertySheet::GetACR()
{
	return m_pACR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrgenpg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRGenPg.h
//
//  Contents:   Declaration of CACRGeneralPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRGENPG_H__B67821ED_7261_11D1_85D4_00C04FB94F17__INCLUDED_)
#define AFX_ACRGENPG_H__B67821ED_7261_11D1_85D4_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRGenPg.h : header file
//
#include "AutoCert.h"

/////////////////////////////////////////////////////////////////////////////
// CACRGeneralPage dialog

class CACRGeneralPage : public CHelpPropertyPage
{
// Construction
public:
	CACRGeneralPage(CAutoCertRequest& rACR);
	virtual ~CACRGeneralPage();

// Dialog Data
	//{{AFX_DATA(CACRGeneralPage)
	enum { IDD = IDD_AUTO_CERT_REQUEST_GENERAL };
	CEdit	m_certTypeEdit;
	CEdit	m_purposesEditControl;
	CListBox	m_caListbox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CACRGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    virtual void DoContextHelp (HWND hWndControl);

	// Generated message map functions
	//{{AFX_MSG(CACRGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CAutoCertRequest&   m_rACR;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRGENPG_H__B67821ED_7261_11D1_85D4_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrgenpg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRGenPg.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "ACRGenPg.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CACRGeneralPage property page

CACRGeneralPage::CACRGeneralPage(CAutoCertRequest& rACR) : 
	CHelpPropertyPage(CACRGeneralPage::IDD),
	m_rACR (rACR)
{
	m_rACR.AddRef ();
	//{{AFX_DATA_INIT(CACRGeneralPage)
	//}}AFX_DATA_INIT
}

CACRGeneralPage::~CACRGeneralPage()
{
	m_rACR.Release ();
}

void CACRGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CACRGeneralPage)
	DDX_Control(pDX, IDC_CERT_TYPE, m_certTypeEdit);
	DDX_Control(pDX, IDC_CERT_PURPOSES, m_purposesEditControl);
	DDX_Control(pDX, IDC_CA_LIST, m_caListbox);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CACRGeneralPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CACRGeneralPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CACRGeneralPage message handlers

BOOL CACRGeneralPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
	CString	purposes;
	HRESULT	hResult = m_rACR.GetUsages (purposes);
	if ( SUCCEEDED (hResult) )
	{
		if ( purposes.IsEmpty () )
			VERIFY (purposes.LoadString (IDS_ANY));
		m_purposesEditControl.SetWindowText (purposes);
	}
	else
	{
		CString	error;

		VERIFY (error.LoadString (IDS_ERROR_READING_ACR_PURPOSES));
		m_purposesEditControl.SetWindowText (error);
	}

	CString	certTypeName;
	hResult = m_rACR.GetCertTypeName (certTypeName);
	if ( !SUCCEEDED (hResult) )
	{
		VERIFY (certTypeName.LoadString (IDS_ERROR_READING_ACR_CERTTYPE));
	}
	m_certTypeEdit.SetWindowText (certTypeName);	


    // We want the display names

	CStringList&	CANameList = m_rACR.GetCANameList (TRUE);
	CString			CAName;
	POSITION		pos = CANameList.GetHeadPosition ();

	for (; pos; )
	{
		CAName = CANameList.GetNext (pos);
		m_caListbox.AddString (CAName);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CACRGeneralPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CACRGeneralPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_CERT_TYPE,      IDH_ACRPAGE_CERT_TYPE,
        IDC_CERT_PURPOSES,  IDH_ACRPAGE_CERT_PURPOSES,
        IDC_CA_LIST,        IDH_ACRPAGE_CA_LIST,
        0, 0
    };

    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    _TRACE (-1, L"Leaving CACRGeneralPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrspsht.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSPSht.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSPSHT_H__98CAC389_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
#define AFX_ACRSPSHT_H__98CAC389_7325_11D1_85D4_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSPSht.h : header file
//
#include "cookie.h"
#include "AutoCert.h"
#include "Wiz97Sht.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardPropertySheet
class CCertStoreGPE;	// forward definition

class ACRSWizardPropertySheet : public CWizard97PropertySheet
{
// Construction
public:
	ACRSWizardPropertySheet(CCertStoreGPE* pCertStore, CAutoCertRequest* pACR);

// Attributes
public:

// Operations
public:

// Implementation
public:
	bool m_bEditModeDirty;	// relevant only when editing, tells us if any changes were made.
							// If not, nothing happens when Finish is pressed.
	CAutoCertRequest* GetACR();
	CCertStoreGPE* m_pCertStore;
	HCERTTYPE m_selectedCertType;
	void SetDirty ();
	void MarkAsClean ();
	bool IsDirty ();
	virtual ~ACRSWizardPropertySheet();
	CTypedPtrList<CPtrList, HCAINFO>	m_caInfoList;

	// Generated message map functions
private:
	CAutoCertRequest* m_pACR;	// only set in 'edit' mode
	bool m_bDirty;				// used to know if it is necessary to re-enumerate the CAs
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSPSHT_H__98CAC389_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrswlcm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSWlcm.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "ACRSWLCM.H"
#include "ACRSPSht.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardWelcomePage property page

//IMPLEMENT_DYNCREATE(ACRSWizardWelcomePage, CWizard97PropertyPage)

ACRSWizardWelcomePage::ACRSWizardWelcomePage() : CWizard97PropertyPage(ACRSWizardWelcomePage::IDD)
{
	//{{AFX_DATA_INIT(ACRSWizardWelcomePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

ACRSWizardWelcomePage::~ACRSWizardWelcomePage()
{
}

void ACRSWizardWelcomePage::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ACRSWizardWelcomePage)
	DDX_Control(pDX, IDC_WIZARD_STATIC_BIG_BOLD1, m_staticBigBold);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ACRSWizardWelcomePage, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(ACRSWizardWelcomePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardWelcomePage message handlers

BOOL ACRSWizardWelcomePage::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

	m_staticBigBold.SetFont (&GetBigBoldFont ());

	CString	title;
	VERIFY (title.LoadString (IDS_ACRS_WIZARD_SHEET_CAPTION));
	CWnd* pParent = GetParent ();
    if ( pParent )
        pParent->SendMessage (PSM_SETTITLE, 0, (LPARAM) (LPCWSTR) title);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL ACRSWizardWelcomePage::OnSetActive() 
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       acrstype.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSTYPE_H__1BCEA8C5_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
#define AFX_ACRSTYPE_H__1BCEA8C5_756A_11D1_85D5_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSType.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardTypePage dialog

class ACRSWizardTypePage : public CWizard97PropertyPage
{
//	DECLARE_DYNCREATE(ACRSWizardTypePage)

// Construction
public:
	ACRSWizardTypePage();   // standard constructor
	virtual ~ACRSWizardTypePage();

// Dialog Data
	//{{AFX_DATA(ACRSWizardTypePage)
	enum { IDD = IDD_ACR_SETUP_TYPE };
	CListCtrl	m_certTypeList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ACRSWizardTypePage)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//	bool AlreadyInList (CStringList& typeList, CString propName);
	HRESULT GetPurposes (HCERTTYPE hCertType, int iItem);
	void EnumerateCertTypes ();

	// Generated message map functions
	//{{AFX_MSG(ACRSWizardTypePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnUseSmartcard();
	afx_msg void OnItemchangedCertTypes(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bInitDialogComplete;
	enum {
		COL_TYPE = 0,
		COL_PURPOSES,
		NUM_COLS
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSTYPE_H__1BCEA8C5_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrstype.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSType.cpp
//
//  Contents:   Implementation of Auto Cert Request Wizard Certificate Type Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "storegpe.h"
#include "ACRSType.h"
#include "ACRSPSht.h"


USE_HANDLE_MACROS("CERTMGR(ACRSType.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardTypePage property page

//IMPLEMENT_DYNCREATE(ACRSWizardTypePage, CWizard97PropertyPage)


ACRSWizardTypePage::ACRSWizardTypePage() 
	: CWizard97PropertyPage(ACRSWizardTypePage::IDD),
	m_bInitDialogComplete (false)
{
	//{{AFX_DATA_INIT(ACRSWizardTypePage)
	//}}AFX_DATA_INIT
	VERIFY (m_szHeaderTitle.LoadString (IDS_ACRS_TYPE_TITLE));
	VERIFY (m_szHeaderSubTitle.LoadString (IDS_ACRS_TYPE_SUBTITLE));
	InitWizard97 (FALSE);
}


ACRSWizardTypePage::~ACRSWizardTypePage ()
{
}


void ACRSWizardTypePage::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ACRSWizardTypePage)
	DDX_Control(pDX, IDC_CERT_TYPES, m_certTypeList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ACRSWizardTypePage, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(ACRSWizardTypePage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_USE_SMARTCARD, OnUseSmartcard)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_CERT_TYPES, OnItemchangedCertTypes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardTypePage message handlers

BOOL ACRSWizardTypePage::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

	// Set up columns in list view
	int	colWidths[NUM_COLS] = {200, 400};

	CString	columnLabel;
	VERIFY (columnLabel.LoadString (IDS_CERTIFICATE_TYPE_COLUMN_NAME));
	VERIFY (m_certTypeList.InsertColumn (COL_TYPE, (LPCWSTR) columnLabel, 
			LVCFMT_LEFT, colWidths[COL_TYPE], COL_TYPE) != -1);
	VERIFY (columnLabel.LoadString (IDS_PURPOSES_ALLOWED_COLUMN_NAME));
	VERIFY (m_certTypeList.InsertColumn (COL_PURPOSES, (LPCWSTR) columnLabel, 
			LVCFMT_LEFT, colWidths[COL_PURPOSES], COL_PURPOSES) != -1);


	EnumerateCertTypes ();  // Called here because only done once.

	m_bInitDialogComplete = true;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


///////////////////////////////////////////////////////////////////////////////
//
//	EnumerateCertTypes
//
//	Enumerate all known Certificate types
//
///////////////////////////////////////////////////////////////////////////////
void ACRSWizardTypePage::EnumerateCertTypes()
{
	CWaitCursor	waitCursor;

	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		CAutoCertRequest*	pACR = pSheet->GetACR ();
		HRESULT				hr = S_OK;
		WCHAR**				pawszPropertyValue = 0;
		HCERTTYPE			hCertType = 0;
		HCERTTYPE			hNextCertType = 0;
		int					iItem = 0;
		LV_ITEM				lvItem;
		HCERTTYPE			hACRCertType = 0;
		bool				bOneWasSelected = false;
		WCHAR**				pawszPropNameACR = 0;
		WCHAR**				pawszPropName = 0;
        bool                fMachine = FALSE;

		if ( pACR )		// an ACR was passed in - we're in 'edit' mode
		{

            hACRCertType = pACR->GetCertType ();
			hr = ::CAGetCertTypeProperty (hACRCertType,
					CERTTYPE_PROP_CN,
					&pawszPropNameACR);
			ASSERT (SUCCEEDED (hr));
		}

        fMachine = pSheet->m_pCertStore->IsMachineStore();
		m_certTypeList.DeleteAllItems ();
        hr = ::CAEnumCertTypes ((fMachine?CT_ENUM_MACHINE_TYPES:CT_ENUM_USER_TYPES), 
                                        &hCertType);
		ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) && !hCertType )
        {
			CString	caption;
			CString	text;
            CThemeContextActivator activator;

			VERIFY (caption.LoadString (IDS_CREATE_AUTO_CERT_REQUEST));
			VERIFY (text.LoadString (IDS_NO_CERT_TEMPLATES_INSTALLED));
			MessageBox (text, caption, MB_OK | MB_ICONWARNING);
        }

		while (SUCCEEDED (hr) && hCertType)
		{
            DWORD   dwFlags = 0;
            hr = ::CAGetCertTypeFlags (hCertType, &dwFlags);
            if ( SUCCEEDED (hr) )
            {
                DWORD   dwSchemaVersion = 0;

                // Only add version 1 cert templates (types)
                hr = CAGetCertTypePropertyEx (hCertType,
                        CERTTYPE_PROP_SCHEMA_VERSION,
                        &dwSchemaVersion);
                if ( SUCCEEDED (hr) )
                {
                    if ( 1 == dwSchemaVersion )
                    {
                        // Only add cert types appropriate for autoenrollment
                        if ( dwFlags & CT_FLAG_AUTO_ENROLLMENT )
                        {
			                hr = ::CAGetCertTypeProperty (hCertType,
					                CERTTYPE_PROP_FRIENDLY_NAME,
					                &pawszPropertyValue);
			                ASSERT (SUCCEEDED (hr));
			                if ( SUCCEEDED (hr) )
			                {
				                if ( pawszPropertyValue[0] )
				                {
					                hr = ::CAGetCertTypeProperty (hCertType,
							                CERTTYPE_PROP_CN,
							                &pawszPropName);
					                ASSERT (SUCCEEDED (hr));
					                if ( SUCCEEDED (hr) && pawszPropName[0] )
					                {
						                ::ZeroMemory (&lvItem, sizeof (lvItem));
						                UINT	selMask = 0;
						                if ( pawszPropNameACR && !bOneWasSelected )
						                {
							                // If an ACR was passed in, compare the
							                // names, if they are the same, mark
							                // it as selected.  Only one was selected
							                // so we needn't pass through here again if
							                // one is marked.
							                if ( !wcscmp (pawszPropNameACR[0], pawszPropName[0]) )
							                {
								                bOneWasSelected = true;
								                selMask = LVIF_STATE;
								                lvItem.state = LVIS_SELECTED;
							                }
						                }
						                iItem = m_certTypeList.GetItemCount ();

						                lvItem.mask = LVIF_TEXT | LVIF_PARAM | selMask;
						                lvItem.iItem = iItem;        
						                lvItem.iSubItem = COL_TYPE;      
						                lvItem.pszText = pawszPropertyValue[0]; 
						                lvItem.lParam = (LPARAM) hCertType;     
						                int iNewItem = m_certTypeList.InsertItem (&lvItem);
						                ASSERT (-1 != iNewItem);

						                hr = GetPurposes (hCertType, iNewItem);

						                VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hCertType,
								                pawszPropName)));
					                }
				                }
				                VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hCertType,
						                pawszPropertyValue)));
			                }
                        }
                    }
                }
                else if ( FAILED (hr) )
                {
                    _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
                }

			    // Find the Next Cert Type in an enumeration.
			    hr = ::CAEnumNextCertType (hCertType, &hNextCertType);
			    hCertType = hNextCertType;
            }
            else
            {
                _TRACE (0, L"CAGetCertTypeFlags () failed: 0x%x\n", hr);
            }
		}

		// If we are not in edit mode, select the first item in the list
		if ( !pACR && m_certTypeList.GetItemCount () > 0 )
		{
			VERIFY (m_certTypeList.SetItemState (0, LVIS_SELECTED, LVIS_SELECTED));
		}

		if ( hACRCertType && pawszPropNameACR )
		{
			VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hACRCertType,
				pawszPropNameACR)));
		}
	}
}


void ACRSWizardTypePage::OnDestroy() 
{
	CWizard97PropertyPage::OnDestroy();

	int			nItem = m_certTypeList.GetItemCount ();
	HCERTTYPE	hCertType = 0;
	HRESULT		hr = S_OK;

	for (int nIndex = 0; nIndex < nItem; nIndex++)
	{
		hCertType = (HCERTTYPE) m_certTypeList.GetItemData (nIndex);
		ASSERT (hCertType);
		if ( hCertType )
		{
			hr = ::CACloseCertType (hCertType);
			ASSERT (SUCCEEDED (hr));
		}
	}
}

HRESULT ACRSWizardTypePage::GetPurposes(HCERTTYPE hCertType, int iItem)
{
	CWaitCursor	waitCursor;
	PCERT_EXTENSIONS	pCertExtensions = 0;
	HRESULT				hr = ::CAGetCertTypeExtensions (
			hCertType, &pCertExtensions);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
		CString	purpose;
		CString purposes;

		for (DWORD dwIndex = 0; 
				dwIndex < pCertExtensions->cExtension; 
				dwIndex++)
		{
			if ( !_stricmp (pCertExtensions->rgExtension[dwIndex].pszObjId,
					szOID_ENHANCED_KEY_USAGE) )
			{
				DWORD	cbStructInfo = 0;
				BOOL bResult = ::CryptDecodeObject (  
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						szOID_ENHANCED_KEY_USAGE,
						pCertExtensions->rgExtension[dwIndex].Value.pbData,
						pCertExtensions->rgExtension[dwIndex].Value.cbData,
						0,
						NULL,
						&cbStructInfo);
				ASSERT (bResult);
				if ( bResult )
				{
					PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbStructInfo];
					if ( pUsage )
					{
						bResult = ::CryptDecodeObject (  
								X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
								szOID_ENHANCED_KEY_USAGE,
								pCertExtensions->rgExtension[dwIndex].Value.pbData,
								pCertExtensions->rgExtension[dwIndex].Value.cbData,
								0,
								pUsage,
								&cbStructInfo);
						ASSERT (bResult);
						if ( bResult )
						{
							for (DWORD dwUsageIDIndex = 0; 
                                    dwUsageIDIndex < pUsage->cUsageIdentifier; 
                                    dwUsageIDIndex++)
							{
								if ( MyGetOIDInfo (purpose, pUsage->rgpszUsageIdentifier[dwUsageIDIndex]) )
								{
									// add delimeter if not first iteration
									if ( dwUsageIDIndex )
										purposes += _T(", ");
									purposes += purpose;
								}
							}

						}
						delete [] pUsage;
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				break;
			}
		}
		::LocalFree ((HLOCAL) pCertExtensions);

		if ( purposes.IsEmpty () )
			VERIFY (purposes.LoadString (IDS_ANY));
		VERIFY (m_certTypeList.SetItemText (iItem, COL_PURPOSES, purposes));
	}

	return hr;
}

LRESULT ACRSWizardTypePage::OnWizardNext() 
{
	CWaitCursor	waitCursor;
	UINT	nSelCnt = m_certTypeList.GetSelectedCount ();
	LRESULT lResult = 0;

	if ( 1 == nSelCnt )
	{
		ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
		ASSERT (pSheet);
		if ( pSheet )
		{
			VERIFY (UpdateData (TRUE));
			pSheet->m_selectedCertType = 0;

			// Save type to property sheet
			UINT	flag = 0;
			int		nCnt = m_certTypeList.GetItemCount ();
			for (int nItem = 0; nItem < nCnt; nItem++)
			{
				flag = ListView_GetItemState (m_certTypeList.m_hWnd, nItem, LVIS_SELECTED);
				if ( flag & LVNI_SELECTED )
				{
					pSheet->m_selectedCertType = (HCERTTYPE) m_certTypeList.GetItemData (nItem);
					ASSERT (pSheet->m_selectedCertType);
					if ( !pSheet->m_selectedCertType )
					{
						CString	caption;
						CString	text;
                        CThemeContextActivator activator;

						VERIFY (caption.LoadString (IDS_CREATE_AUTO_CERT_REQUEST));
						VERIFY (text.LoadString (IDS_ERROR_RETRIEVING_SELECTED_CERT_TYPE));
						MessageBox (text, caption, MB_OK | MB_ICONWARNING);
						return -1;
					}
					break;	// since only 1 item can be selected
				}
			}
			ASSERT (pSheet->m_selectedCertType);	// we must have selected something by now
		}

		lResult = CWizard97PropertyPage::OnWizardNext();
	}
	else
	{
		CString	caption;
		CString	text;
        CThemeContextActivator activator;

		VERIFY (caption.LoadString (IDS_ACRS_WIZARD_SHEET_CAPTION));
		VERIFY (text.LoadString (IDS_MUST_SELECT_CERT_TYPE));
		MessageBox (text, caption, MB_OK);
		lResult = -1;
	}

    return lResult;
}

BOOL ACRSWizardTypePage::OnSetActive() 
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT | PSWIZB_BACK);

    int nCnt = m_certTypeList.GetItemCount ();
    if ( !nCnt )
        GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_DISABLEDFINISH);

	return bResult;
}

void ACRSWizardTypePage::OnUseSmartcard() 
{
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
		pSheet->SetDirty ();
}

void ACRSWizardTypePage::OnItemchangedCertTypes(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		pSheet->SetDirty ();
		if ( m_bInitDialogComplete )
			pSheet->m_bEditModeDirty = true;
	}
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\acrswlcm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       acrswlcm.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSWLCM_H__98CAC388_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
#define AFX_ACRSWLCM_H__98CAC388_7325_11D1_85D4_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSWLCM.H : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardWelcomePage dialog

class ACRSWizardWelcomePage : public CWizard97PropertyPage
{
//	DECLARE_DYNCREATE(ACRSWizardWelcomePage)

// Construction
public:
	ACRSWizardWelcomePage();
	virtual ~ACRSWizardWelcomePage();

// Dialog Data
	//{{AFX_DATA(ACRSWizardWelcomePage)
	enum { IDD = IDD_ACR_SETUP_WELCOME };
	CStatic	m_staticBigBold;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ACRSWizardWelcomePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(ACRSWizardWelcomePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSWLCM_H__98CAC388_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\addsheet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       AddSheet.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "AddSheet.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizSheet

CAddEFSWizSheet::CAddEFSWizSheet (UINT nIDCaption, CUsers& externalUsers, bool bMachineIsStandAlone)
	:CWizard97PropertySheet (nIDCaption, IDB_RECOVERY_WATERMARK, IDB_RECOVERY_BANNER),
	m_externalUsers (externalUsers),
    m_bMachineIsStandAlone (bMachineIsStandAlone)
{
    AddControlPages ();
    m_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat (CFSTR_DSOBJECTNAMES);
}


CAddEFSWizSheet::~CAddEFSWizSheet ()
{
}


//
// This routine adds the tab to the sheet
//

void CAddEFSWizSheet::AddControlPages ()
{
    AddPage (&m_WelcomePage);
	AddPage (&m_LocatePage);
    AddPage (&m_CompletePage);
}


CLIPFORMAT CAddEFSWizSheet::GetDataFormat ()
{
    return m_cfDsObjectNames;
}

DWORD CAddEFSWizSheet::Add (
        LPWSTR UserName,
        LPWSTR DnName, 
        PVOID UserCert, 
        PSID UserSid /*= NULL */, 
        DWORD Flag /*= USERINFILE*/,
        PCCERT_CONTEXT pCertContext /*= NULL*/
      )
{
    return m_Users.Add (
                    UserName,
                    DnName,
                    UserCert,
                    UserSid,
                    Flag,
                    pCertContext
                    );    
}

DWORD CAddEFSWizSheet::Remove (
    LPCWSTR UserName,
    LPCWSTR UserCertName
    )
{
    return m_Users.Remove (
                    UserName,
                    UserCertName
                    );
}

PUSERSONFILE CAddEFSWizSheet::StartEnum ()
{
    return m_Users.StartEnum ();
}

PUSERSONFILE CAddEFSWizSheet::GetNextUser (
    PUSERSONFILE Token, 
    CString &UserName,
    CString &CertName
    )
{
    return m_Users.GetNextUser (
                    Token,
                    UserName,
                    CertName
                    );
}

void CAddEFSWizSheet::ClearUserList (void)
{
   m_Users.Clear ();
}

DWORD CAddEFSWizSheet::AddNewUsers (void)
{
	m_externalUsers.Add (m_Users);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\addsheet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       addsheet.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ADDSHEET_H__AD17A140_5492_11D1_BB63_00A0C906345D__INCLUDED_)
#define AFX_ADDSHEET_H__AD17A140_5492_11D1_BB63_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddSheet.h : header file
//

#include "welcome.h"
#include "locate.h"
#include "complete.h"
#pragma warning(push, 3)
#include <dsclient.h>
#pragma warning(pop)
#include "Users.h"	// Added by ClassView

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizSheet

class CAddEFSWizSheet : public CWizard97PropertySheet
{
// Construction
public:
	CAddEFSWizSheet(UINT nIDCaption, CUsers& externalUsers, bool bMachineIsStandAlone);

    DWORD   Add(
                LPWSTR UserName,
                LPWSTR DnName, 
                PVOID UserCert, 
                PSID UserSid = NULL, 
                DWORD Flag = USERINFILE,
                PCCERT_CONTEXT pCertContext = NULL
              );

    DWORD   Remove(
                LPCWSTR UserName,
                LPCWSTR CertName
              );

    PUSERSONFILE    StartEnum(void);

    PUSERSONFILE GetNextUser(
                        PUSERSONFILE Token, 
                        CString &UserName,
                        CString &CertName
                        );

    void ClearUserList(void);

    DWORD AddNewUsers(void);

protected:
	void AddControlPages(void);

// Attributes
private:
    CUsers              m_Users;
    CUsers&             m_externalUsers;
    CAddEFSWizWelcome	m_WelcomePage;	// Welcome PropPage
    CAddEFSWizLocate    m_LocatePage;	// Locate User PropPage
    CAddEFSWizComplete  m_CompletePage; // Complete PropPage
    CString             m_SheetTitle;
    CLIPFORMAT          m_cfDsObjectNames; // ClipBoardFormat

// Attributes
public:
    const bool m_bMachineIsStandAlone;

// Operations
public:

// Implementation
public:
	CLIPFORMAT GetDataFormat(void);
	virtual ~CAddEFSWizSheet();
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDSHEET_H__AD17A140_5492_11D1_BB63_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\autocert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       AutoCert.cpp
//
//  Contents:   implementation of the CAutoCertRequest class.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "AutoCert.h"
#include "storegpe.h"


USE_HANDLE_MACROS("CERTMGR(AutoCert.cpp)")


////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAutoCertRequest::CAutoCertRequest (const PCCTL_CONTEXT pCTLContext, CCertStore& rCertStore) :
	CCTL (pCTLContext, rCertStore, CERTMGR_AUTO_CERT_REQUEST),
	m_pCertTypeExtension (0),
	m_pEnhKeyUsageExtension (0),
	m_bCANamesEnumerated (false),
	m_hCertType (0)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
}

CAutoCertRequest::~CAutoCertRequest()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( m_hCertType )
	{
		VERIFY (SUCCEEDED (::CACloseCertType (m_hCertType)));
	}
}



HRESULT CAutoCertRequest::GetCertTypeName(CString & certTypeName)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	HRESULT	hResult = S_OK;

    

	if ( CERTMGR_LOG_STORE_GPE != GetCertStore().m_objecttype && 
            CERTMGR_LOG_STORE_RSOP != GetCertStore().m_objecttype )
    {
        hResult = E_FAIL;
        return hResult;
    }

    CCertStore* pStore = reinterpret_cast <CCertStore*>(&GetCertStore());
    if(pStore == NULL)
    {
        hResult = E_FAIL;
        return hResult;
    }




	if ( m_szCertTypeName.IsEmpty () )
	{
		bool	bFound = false;


		hResult = E_FAIL;
		PCERT_EXTENSION	pCertTypeExtension = GetCertTypeExtension ();
		if ( pCertTypeExtension )
		{
			DWORD	cbValue = 0;

			if ( ::CryptDecodeObject(
					CRYPT_ASN_ENCODING,
					X509_UNICODE_ANY_STRING,
					pCertTypeExtension->Value.pbData,
					pCertTypeExtension->Value.cbData,
					0,
					0,
					&cbValue) )
			{
				CERT_NAME_VALUE* pCNValue = (CERT_NAME_VALUE*) 
					::LocalAlloc(LPTR, cbValue);
				if ( pCNValue )
				{
					if ( ::CryptDecodeObject(
							CRYPT_ASN_ENCODING,
							X509_UNICODE_ANY_STRING,
							pCertTypeExtension->Value.pbData,
							pCertTypeExtension->Value.cbData,
							0,
							pCNValue,
							&cbValue) )
					{
						LPWSTR			pszCertTypeName = (LPWSTR) pCNValue->Value.pbData;
						CString			CAName;
						HCERTTYPE		hCertType = 0;

						hResult = ::CAFindCertTypeByName ( pszCertTypeName,
                                                           NULL,
                                                            (pStore->IsMachineStore()?CT_ENUM_MACHINE_TYPES:CT_ENUM_USER_TYPES), 
                                                              &hCertType);
						if ( SUCCEEDED (hResult) )
						{
							WCHAR**		pawszPropertyValue = 0;

							hResult = ::CAGetCertTypeProperty (hCertType,
									CERTTYPE_PROP_FRIENDLY_NAME,
									&pawszPropertyValue);
							ASSERT (SUCCEEDED (hResult));
							if ( SUCCEEDED (hResult) )
							{
								if ( pawszPropertyValue[0] )
								{
									m_szCertTypeName = pawszPropertyValue[0];
									bFound = true;
									m_hCertType = hCertType;
								}
                                else
                                {
									VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hCertType,
										pawszPropertyValue)));
                                }
							}
							if ( !bFound )
							{
								hResult = ::CACloseCertType (hCertType);
								ASSERT (SUCCEEDED (hResult));
							}
						}

					}
					else
					{
						DWORD	dwErr = GetLastError ();
						DisplaySystemError (NULL, dwErr);
						hResult = HRESULT_FROM_WIN32 (dwErr);
					}
					::LocalFree (pCNValue);
				}
				else
				{
					hResult = E_OUTOFMEMORY;
				}
			}
			else
			{
				DWORD	dwErr = GetLastError ();
				DisplaySystemError (NULL, dwErr);
				hResult = HRESULT_FROM_WIN32 (dwErr);
			}
		}
		// If all calls succeded but it still wasn't found, then fail anyway.
		if ( SUCCEEDED (hResult) && !bFound )
			hResult = E_FAIL;
	}

	if ( SUCCEEDED (hResult) )
		certTypeName = m_szCertTypeName;

	return hResult;
}

PCERT_EXTENSION CAutoCertRequest::GetCertTypeExtension()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( !m_pCertTypeExtension )
	{
		m_pCertTypeExtension = ::CertFindExtension (
				szOID_ENROLL_CERTTYPE_EXTENSION, 
				GetCTLContext ()->pCtlInfo->cExtension,
				GetCTLContext ()->pCtlInfo->rgExtension);
		ASSERT (m_pCertTypeExtension);
		if ( !m_pCertTypeExtension )
		{
			DisplaySystemError (NULL, GetLastError ());
		}
	}

	return m_pCertTypeExtension;
}

PCERT_EXTENSION CAutoCertRequest::GetEnhancedKeyUsageExtension()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( !m_pEnhKeyUsageExtension )
	{
		m_pEnhKeyUsageExtension = ::CertFindExtension (
				szOID_ENHANCED_KEY_USAGE, 
				GetCTLContext ()->pCtlInfo->cExtension,
				GetCTLContext ()->pCtlInfo->rgExtension);
		ASSERT (m_pEnhKeyUsageExtension);
		if ( !m_pEnhKeyUsageExtension )
		{
			DWORD	dwErr = GetLastError ();
			if ( dwErr )
				DisplaySystemError (NULL, dwErr);
		}
	}

	return m_pEnhKeyUsageExtension;
}

HRESULT CAutoCertRequest::GetUsages(CString & usages)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	HRESULT	hResult = S_OK;

	if ( m_szUsages.IsEmpty () )
	{
		hResult = E_FAIL;
		PCERT_EXTENSION	pEnhKeyUsageExtension = GetEnhancedKeyUsageExtension ();
		ASSERT (pEnhKeyUsageExtension);
		if ( pEnhKeyUsageExtension )
		{
			DWORD	cbEnhKeyUsage = 0;


			if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
					szOID_ENHANCED_KEY_USAGE, 
					pEnhKeyUsageExtension->Value.pbData,
					pEnhKeyUsageExtension->Value.cbData,
					0, NULL, &cbEnhKeyUsage) )
			{
				PCERT_ENHKEY_USAGE	pEnhKeyUsage = (PCERT_ENHKEY_USAGE)
						::LocalAlloc (LPTR, cbEnhKeyUsage);
				if ( pEnhKeyUsage )
				{
					if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
							szOID_ENHANCED_KEY_USAGE, 
							pEnhKeyUsageExtension->Value.pbData,
							pEnhKeyUsageExtension->Value.cbData,
							0, pEnhKeyUsage, &cbEnhKeyUsage) )
					{
						CString	usageName;

						for (DWORD dwIndex = 0; 
								dwIndex < pEnhKeyUsage->cUsageIdentifier; 
								dwIndex++)
						{
							if ( MyGetOIDInfo (usageName, 
									pEnhKeyUsage->rgpszUsageIdentifier[dwIndex]) )
							{
								// add delimeter if not first iteration
								if ( dwIndex )
									m_szUsages += _T(", ");
								m_szUsages += usageName;
							}
						}
						hResult = S_OK;
					}
					else
						DisplaySystemError (NULL, GetLastError());
					::LocalFree (pEnhKeyUsage);
				}
				else
				{
					hResult = E_OUTOFMEMORY;
				}
			}
			else
				DisplaySystemError (NULL, GetLastError());
		}
	}

	if ( SUCCEEDED (hResult) )
		usages = m_szUsages;

	return hResult;
}


// To get CAs, enumerate CAs on DS, get certs, get hash, compare with stored hash
// in CTL, if match found, call GetCAInfoFromDS


HRESULT CAutoCertRequest::BuildCANameList()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	HRESULT	hResult = S_OK;

	if ( !m_bCANamesEnumerated )
	{
		m_bCANamesEnumerated = true;

		// To get CAs, enumerate CAs on DS, get certs, get hash, compare with stored hash
		// in CTL, if match found, call GetCAInfoFromDS
		CWaitCursor		waitCursor;
		HCAINFO			hCAInfo = 0;
		DWORD			dwCACnt = 0;
		HCAINFO*		pCAList = 0;
		UINT			nIndex = 0;
		PCCERT_CONTEXT* ppCertContext = NULL;
		DWORD           cbHash = 20;
		hResult = ::CAEnumFirstCA (NULL, 0, &hCAInfo);
		if ( SUCCEEDED (hResult) )
			dwCACnt = ::CACountCAs (hCAInfo);

		if ( dwCACnt > 0 )
		{
        
			pCAList = new HCAINFO[dwCACnt];
			ppCertContext = new PCCERT_CONTEXT[dwCACnt];
			if ( pCAList && ppCertContext )
			{
				nIndex = 0;
				while (SUCCEEDED (hResult) && hCAInfo && nIndex < dwCACnt)
				{
					pCAList[nIndex] = hCAInfo;
					hResult = ::CAGetCACertificate (hCAInfo, &ppCertContext[nIndex]);
					ASSERT (SUCCEEDED (hResult));
					nIndex++;
					hResult = ::CAEnumNextCA (hCAInfo, &hCAInfo);
				}
            
				PCCTL_CONTEXT	pCTLContext = GetCTLContext ();
				if ( pCTLContext )
				{
					PCTL_INFO		pCTLInfo = pCTLContext->pCtlInfo;
					DWORD			cCTLEntry = pCTLInfo->cCTLEntry;
					PCTL_ENTRY		rgCTLEntry = pCTLInfo->rgCTLEntry;
					const size_t	HASH_SIZE = 20;
					BYTE			pbHash[HASH_SIZE];
                
					for (UINT nCAHash = 0; nCAHash < cCTLEntry; nCAHash++)
					{
						for (UINT nCertContextIndex = 0; nCertContextIndex < dwCACnt; nCertContextIndex++)
						{
							cbHash = HASH_SIZE;
							if (::CertGetCertificateContextProperty (ppCertContext[nCertContextIndex],
															  CERT_SHA1_HASH_PROP_ID,
															  pbHash,
															  &cbHash) )
							{
                            
								// Compare pbHash with pCAHash;
								if ( !memcmp (pbHash, 
										rgCTLEntry[nCAHash].SubjectIdentifier.pbData, 
										rgCTLEntry[nCAHash].SubjectIdentifier.cbData) )
								{
                                    LPWSTR *awszCAName = NULL;
                                    LPWSTR *awszCADisplayName = NULL;
                                    //
                                    // Add this CA to the list of 
                                    // CA's.
                                    //
                                
	                                // get the name of the CA 
	                                hResult = ::CAGetCAProperty (pCAList[nCertContextIndex], 
                                                                 CA_PROP_NAME, 
                                                                 &awszCAName);


	                                if (SUCCEEDED (hResult) && awszCAName && awszCAName[0] )
	                                {
                                    
		                                // get the display name of the CA
		                                hResult = ::CAGetCAProperty (pCAList[nCertContextIndex], 
                                                                     CA_PROP_DISPLAY_NAME, 
                                                                     &awszCADisplayName);
                                    
		                                if ( SUCCEEDED(hResult) && awszCADisplayName && awszCADisplayName[0] )
                                        {
										    m_CANameList.AddHead (awszCAName[0]);

										    m_CADisplayNameList.AddHead (awszCADisplayName[0]);	
                                        }
                                    }

									if ( awszCAName )
                                    {
                                        CAFreeCAProperty(pCAList[nCertContextIndex], awszCAName);
                                    }
									if ( awszCADisplayName )
                                    {
                                        CAFreeCAProperty(pCAList[nCertContextIndex], awszCADisplayName);
                                    }
									break;

								}
							}
							else
							{
								DWORD	dwErr = GetLastError ();
								hResult = HRESULT_FROM_WIN32 (dwErr);
								DisplaySystemError (NULL, dwErr);
								break;
							}
						}
					}
				}

				for (UINT nCAListIndex = 0; nCAListIndex < dwCACnt; nCAListIndex++)
				{
					hResult = ::CACloseCA (pCAList[nCAListIndex]);
					ASSERT (SUCCEEDED (hResult));

					::CertFreeCertificateContext (ppCertContext[nCAListIndex]);
				}
			}
			else
			{
				hResult = E_OUTOFMEMORY;
			}
            if ( pCAList )
			    delete [] pCAList;
            if ( ppCertContext )
			    delete [] ppCertContext;
		}
	}

	return hResult;
}

CStringList& CAutoCertRequest::GetCANameList(bool fDisplayName)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	BuildCANameList ();
    return fDisplayName?m_CADisplayNameList:m_CANameList;
}

HCERTTYPE CAutoCertRequest::GetCertType()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( !m_hCertType )
	{
		CString	name;
		GetCertTypeName (name); // generates m_hCertType
	}
	return m_hCertType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\autocert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       AutoCert.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_AUTOCERT_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
#define AFX_AUTOCERT_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "ctl.h"
#pragma warning(push, 3)
#include <autoenr.h>
#pragma warning(pop)

class CAutoCertRequest : public CCTL  
{
public:
	HCERTTYPE GetCertType();
	CStringList& GetCANameList (bool fDisplayName);
	HRESULT GetUsages (CString& usages);
	HRESULT GetCertTypeName (CString& certTypeName);
	CAutoCertRequest (const PCCTL_CONTEXT pCTLContext, CCertStore& rCertStore);
	virtual ~CAutoCertRequest();

private:
	HCERTTYPE m_hCertType;
	bool m_bCANamesEnumerated;
	CString m_szUsages;
	PCERT_EXTENSION m_pEnhKeyUsageExtension;
	PCERT_EXTENSION m_pCertTypeExtension;
	CString m_szCertTypeName;
	CStringList m_CANameList;
	CStringList m_CADisplayNameList;
protected:

	HRESULT BuildCANameList ();
	PCERT_EXTENSION GetEnhancedKeyUsageExtension();
	PCERT_EXTENSION GetCertTypeExtension ();
};

#endif // !defined(AFX_AUTOCERT_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\autoenrollmentpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       AutoenrollmentPropertyPage.h
//
//  Contents:   Declaration of CAutoenrollmentPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_AUTOENROLLMENTPROPERTYPAGE_H__DA50335B_4919_4B92_BE66_73B07410EFBD__INCLUDED_)
#define AFX_AUTOENROLLMENTPROPERTYPAGE_H__DA50335B_4919_4B92_BE66_73B07410EFBD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AutoenrollmentPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAutoenrollmentPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CAutoenrollmentPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CAutoenrollmentPropertyPage(CCertMgrComponentData* pCompData,
            bool fIsComputerTYpe);
	~CAutoenrollmentPropertyPage();

// Dialog Data
	//{{AFX_DATA(CAutoenrollmentPropertyPage)
	enum { IDD = IDD_PROPPAGE_AUTOENROLL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAutoenrollmentPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void EnableControls ();
    virtual void OnOK();
    virtual void DoContextHelp (HWND hWndControl);
    void SetGPEFlags ();
	void GPEGetAutoenrollmentFlags ();
    void RSOPGetAutoenrollmentFlags (const CCertMgrComponentData* pCompData);

	void SaveCheck();
	// Generated message map functions
	//{{AFX_MSG(CAutoenrollmentPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnAutoenrollDisableAll();
	afx_msg void OnAutoenrollEnable();
	afx_msg void OnAutoenrollEnablePending();
	afx_msg void OnAutoenrollEnableTemplate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HKEY				    m_hAutoenrollmentFlagsKey;
	DWORD				    m_dwAutoenrollmentFlags;
	IGPEInformation*	    m_pGPEInformation;
	HKEY				    m_hGroupPolicyKey;
    bool                    m_fIsComputerType;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOENROLLMENTPROPERTYPAGE_H__DA50335B_4919_4B92_BE66_73B07410EFBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\autoenrollmentpropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       AutoenrollmentPropertyPage.cpp
//
//  Contents:   Implementation of CAutoenrollmentPropertyPage
//
//----------------------------------------------------------------------------
// AutoenrollmentPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "AutoenrollmentPropertyPage.h"
#include "compdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CAutoenrollmentPropertyPage property page

CAutoenrollmentPropertyPage::CAutoenrollmentPropertyPage(CCertMgrComponentData* pCompData,
        bool fIsComputerType) : 
    CHelpPropertyPage(CAutoenrollmentPropertyPage::IDD),
    m_dwAutoenrollmentFlags (0),
    m_hAutoenrollmentFlagsKey (0),
    m_hGroupPolicyKey (0),
    m_pGPEInformation (pCompData ? pCompData->GetGPEInformation () : 0),
    m_fIsComputerType (fIsComputerType)
{
    if ( m_pGPEInformation )
    {
        HRESULT hResult = m_pGPEInformation->GetRegistryKey (m_fIsComputerType ?
                GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
        if ( SUCCEEDED (hResult) )
		    GPEGetAutoenrollmentFlags ();
    } 
    else 
        RSOPGetAutoenrollmentFlags (pCompData);
}

CAutoenrollmentPropertyPage::~CAutoenrollmentPropertyPage()
{
    if ( m_hAutoenrollmentFlagsKey )
        ::RegCloseKey (m_hAutoenrollmentFlagsKey);
}

void CAutoenrollmentPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAutoenrollmentPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAutoenrollmentPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CAutoenrollmentPropertyPage)
	ON_BN_CLICKED(IDC_AUTOENROLL_DISABLE_ALL, OnAutoenrollDisableAll)
	ON_BN_CLICKED(IDC_AUTOENROLL_ENABLE, OnAutoenrollEnable)
	ON_BN_CLICKED(IDC_AUTOENROLL_ENABLE_PENDING, OnAutoenrollEnablePending)
	ON_BN_CLICKED(IDC_AUTOENROLL_ENABLE_TEMPLATE, OnAutoenrollEnableTemplate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAutoenrollmentPropertyPage message handlers

BOOL CAutoenrollmentPropertyPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog();

    // If this is the RSOP, make it read-only
    if ( !m_pGPEInformation )
    {
        // Make the page read-only
        GetDlgItem (IDC_AUTOENROLL_DISABLE_ALL)->EnableWindow (FALSE);
        GetDlgItem (IDC_AUTOENROLL_ENABLE)->EnableWindow (FALSE);
        GetDlgItem (IDC_AUTOENROLL_ENABLE_PENDING)->EnableWindow (FALSE);
        GetDlgItem (IDC_AUTOENROLL_ENABLE_TEMPLATE)->EnableWindow (FALSE);
    }

    if ( m_dwAutoenrollmentFlags & AUTO_ENROLLMENT_DISABLE_ALL )
        SendDlgItemMessage (IDC_AUTOENROLL_DISABLE_ALL, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE, BM_SETCHECK, BST_CHECKED);

    if ( m_dwAutoenrollmentFlags & (AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT | AUTO_ENROLLMENT_ENABLE_PENDING_FETCH) )
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_PENDING, BM_SETCHECK, BST_CHECKED);

    if ( m_dwAutoenrollmentFlags & AUTO_ENROLLMENT_ENABLE_TEMPLATE_CHECK )
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_TEMPLATE, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

	return TRUE;  // return TRUE unless you set the focus to a control
      // EXCEPTION: OCX Property Pages should return FALSE
}

void CAutoenrollmentPropertyPage::OnOK()
{
    if ( m_pGPEInformation )
    {
	    SaveCheck ();
	    CHelpPropertyPage::OnOK ();
    }
}

void CAutoenrollmentPropertyPage::SaveCheck()
{
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        m_dwAutoenrollmentFlags = 0;
        if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_DISABLE_ALL, BM_GETCHECK) )
            m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_DISABLE_ALL;
        else
        {
            if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_PENDING, BM_GETCHECK) )
                m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT | AUTO_ENROLLMENT_ENABLE_PENDING_FETCH;

            if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_TEMPLATE, BM_GETCHECK) )
                m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_ENABLE_TEMPLATE_CHECK;
        }

        SetGPEFlags (); // save flag to registry
    }
}


void CAutoenrollmentPropertyPage::SetGPEFlags ()
{
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        DWORD   cbData = sizeof (m_dwAutoenrollmentFlags);
        LONG    lResult = ::RegSetValueEx (m_hAutoenrollmentFlagsKey,
				    AUTO_ENROLLMENT_POLICY, // address of value to set
				    0,              // reserved
				    REG_DWORD,          // flag for value type
				    (CONST BYTE *) &m_dwAutoenrollmentFlags, // address of value data
				    cbData);        // size of value data);
        ASSERT (ERROR_SUCCESS == lResult);
        if ( ERROR_SUCCESS == lResult )
		{
			// TRUE means we're changing the machine policy only
            m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                    TRUE, &g_guidExtension, &g_guidSnapin);
            m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                    TRUE, &g_guidRegExt, &g_guidSnapin);
		}
		else
            DisplaySystemError (m_hWnd, lResult);
    }
}

void CAutoenrollmentPropertyPage::RSOPGetAutoenrollmentFlags(const CCertMgrComponentData* pCompData)
{
    if ( pCompData )
    {
        const CRSOPObjectArray* pObjectArray = 
                m_fIsComputerType ? pCompData->GetRSOPObjectArrayComputer () : 
                        pCompData->GetRSOPObjectArrayUser ();
        int     nIndex = 0;
        // NOTE: rsop object array is sorted first by registry key, then by precedence
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // Consider only entries from this store
                if ( !_wcsicmp (AUTO_ENROLLMENT_KEY, pObject->GetRegistryKey ()) &&
						!_wcsicmp (AUTO_ENROLLMENT_POLICY, pObject->GetValueName ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    m_dwAutoenrollmentFlags = pObject->GetDWORDValue ();
                    break;
                }
            }
            else
                break;

            nIndex++;
        }
    }
}

void CAutoenrollmentPropertyPage::GPEGetAutoenrollmentFlags()
{
    DWORD   dwDisposition = 0;

    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            AUTO_ENROLLMENT_KEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&m_hAutoenrollmentFlagsKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (lResult == ERROR_SUCCESS);
    if ( lResult == ERROR_SUCCESS )
    {
    // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        lResult =  ::RegQueryValueEx (m_hAutoenrollmentFlagsKey,       // handle of key to query
		        AUTO_ENROLLMENT_POLICY,  // address of name of value to query
			    0,              // reserved
	        &dwType,        // address of buffer for value type
		    (LPBYTE) &dwData,       // address of data buffer
			&cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            m_dwAutoenrollmentFlags = dwData;
		}
        else
            DisplaySystemError (NULL, lResult);
    }
    else
        DisplaySystemError (NULL, lResult);
}

void CAutoenrollmentPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CAutoenrollmentPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_AUTOENROLL_DISABLE_ALL,         IDH_AUTOENROLL_DISABLE_ALL,
        IDC_AUTOENROLL_ENABLE,              IDH_AUTOENROLL_ENABLE,
        IDC_AUTOENROLL_ENABLE_PENDING,      IDH_AUTOENROLL_ENABLE_PENDING,
        IDC_AUTOENROLL_ENABLE_TEMPLATE,     IDH_AUTOENROLL_ENABLE_TEMPLATE,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CAutoenrollmentPropertyPage::DoContextHelp\n");
}

void CAutoenrollmentPropertyPage::OnAutoenrollDisableAll() 
{
    SetModified (TRUE);
   	SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_PENDING, BM_SETCHECK, BST_UNCHECKED);
    SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_TEMPLATE, BM_SETCHECK, BST_UNCHECKED);
    EnableControls ();
}

void CAutoenrollmentPropertyPage::OnAutoenrollEnable() 
{
    SetModified (TRUE);
    EnableControls ();
}

void CAutoenrollmentPropertyPage::OnAutoenrollEnablePending() 
{
	SetModified (TRUE);
}

void CAutoenrollmentPropertyPage::OnAutoenrollEnableTemplate() 
{
    SetModified (TRUE);
    EnableControls ();
}

void CAutoenrollmentPropertyPage::EnableControls ()
{
    // Only change the enabling if this is not RSOP
    if ( m_pGPEInformation )
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_ENABLE, BM_GETCHECK) )
        {
            GetDlgItem (IDC_AUTOENROLL_ENABLE_PENDING)->EnableWindow (TRUE);
            GetDlgItem (IDC_AUTOENROLL_ENABLE_TEMPLATE)->EnableWindow (TRUE);
        }
        else
        {
            GetDlgItem (IDC_AUTOENROLL_ENABLE_PENDING)->EnableWindow (FALSE);
            GetDlgItem (IDC_AUTOENROLL_ENABLE_TEMPLATE)->EnableWindow (FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\cmponent.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:         cmponent.cpp
//
//  Contents:   Implementation of CCertMgrComponent
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <gpedit.h>
#include <wintrust.h>
#include <sceattch.h>
#include "compdata.h" // CCertMgrComponentData
#include "dataobj.h"
#include "cmponent.h" // CCertMgrComponent
#include "storegpe.h"
#include "users.h"
#include "addsheet.h"
#include "StoreRSOP.h"
#include "SaferEntry.h"


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS ("CERTMGR (cmponent.cpp)")
#include "stdcmpnt.cpp" // CComponent

extern bool g_bSchemaIsW2K;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

// CERTMGR_USAGE, CERTMGR_USAGE, CERTMGR_USAGE, CERTMGR_CERT_CONTAINER
UINT m_aColumns0[CERT_NUM_COLS+1] =
	{IDS_COLUMN_SUBJECT, IDS_COLUMN_ISSUER, IDS_COLUMN_EXPIRATION_DATE, 
        IDS_COLUMN_PURPOSE, IDS_COLUMN_FRIENDLY_NAME, IDS_COLUMN_STATUS, 
        IDS_COLUMN_TEMPLATE_NAME, 0};
// CERTMGR_SNAPIN
UINT m_aColumns1[2] =
	{IDS_COLUMN_LOG_CERTIFICATE_STORE,0};
// CERTMGR_CERTIFICATE, CERTMGR_CRL, CERTMGR_CTL
UINT m_aColumns2[2] =
	{0,0};
// CERTMGR_CRL_CONTAINER
UINT m_aColumns3[4] =
	{IDS_COLUMN_ISSUER, IDS_COLUMN_EFFECTIVE_DATE, IDS_COLUMN_NEXT_UPDATE, 0};
// CERTMGR_CTL_CONTAINER
UINT m_aColumns4[6] =
	{IDS_COLUMN_ISSUER, IDS_COLUMN_EFFECTIVE_DATE, IDS_COLUMN_PURPOSE, IDS_COLUMN_FRIENDLY_NAME, 0};

UINT m_aColumns5[2] =
	{IDS_COLUMN_OBJECT_TYPE, 0};

// CERTMGR_SAFER_USER_LEVELS, CERTMGR_SAFER_COMPUTER_LEVELS
UINT m_aColumns6[SAFER_LEVELS_NUM_COLS+1] =
    {IDS_COLUMN_NAME, IDS_COLUMN_DESCRIPTION, 0};

// CERTMGR_SAFER_USER_ENTRIES, CERTMGR_SAFER_COMPUTER_ENTRIES
UINT m_aColumns7[SAFER_ENTRIES_NUM_COLS+1] =
{IDS_COLUMN_NAME, IDS_COLUMN_TYPE, IDS_COLUMN_LEVEL, IDS_COLUMN_DESCRIPTION, IDS_COLUMN_LAST_MODIFIED_DATE, 0};

UINT* m_Columns[CERTMGR_NUMTYPES] =
	{	
		m_aColumns1, // CERTMGR_SNAPIN
		m_aColumns2, // CERTMGR_CERTIFICATE (result)
		m_aColumns5, // CERTMGR_LOG_STORE
		m_aColumns5, // CERTMGR_PHYS_STORE
		m_aColumns0, // CERTMGR_USAGE
		m_aColumns3, // CERTMGR_CRL_CONTAINER
		m_aColumns4, // CERTMGR_CTL_CONTAINER
		m_aColumns0, // CERTMGR_CERT_CONTAINER
		m_aColumns2, // CERTMGR_CRL (result)
		m_aColumns2, // CERTMGR_CTL (result)
		m_aColumns2, // CERTMGR_AUTO_CERT_REQUEST
		m_aColumns5, //	CERTMGR_CERT_POLICIES_USER,
		m_aColumns5, // CERTMGR_CERT_POLICIES_COMPUTER,
		m_aColumns5, // CERTMGR_LOG_STORE_GPE
		m_aColumns5, // CERTMGR_LOG_STORE_RSOP
        m_aColumns1, // CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS
        m_aColumns1, // CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS
        m_aColumns5, // CERTMGR_SAFER_COMPUTER_ROOT
        m_aColumns5, // CERTMGR_SAFER_USER_ROOT
        m_aColumns6, // CERTMGR_SAFER_COMPUTER_LEVELS
        m_aColumns6, // CERTMGR_SAFER_USER_LEVELS
        m_aColumns7, // CERTMGR_SAFER_COMPUTER_ENTRIES
        m_aColumns7, // CERTMGR_SAFER_USER_ENTRIES
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_LEVEL,
        m_aColumns2, // CERTMGR_SAFER_USER_LEVEL,
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_ENTRY,
        m_aColumns2, // CERTMGR_SAFER_USER_ENTRY,
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS
        m_aColumns2, // CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES
        m_aColumns2, // CERTMGR_SAFER_USER_DEFINED_FILE_TYPES
        m_aColumns2, // CERTMGR_SAFER_USER_ENFORCEMENT
        m_aColumns2  // CERTMGR_SAFER_COMPUTER_ENFORCEMENT
	};


UINT** g_aColumns = 0;	// for framework
int** g_aColumnWidths = 0;  // for framework
const int SINGLE_COL_WIDTH = 450;

CCertMgrComponent::CCertMgrComponent ()
:   m_pViewedCookie (NULL),
	m_bUsageStoresEnumerated (false),
	m_pPastedDO (NULL),
	m_bShowArchivedCertsStateWhenLogStoresEnumerated (false),
    m_nSelectedCertColumn (0),
    m_nSelectedCRLColumn (0),
    m_nSelectedCTLColumn (0),
    m_nSelectedSaferEntryColumn (0),
    m_pLastUsageCookie (0),
    m_pControlbar (0),
    m_pToolbar (0)
{
     AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
	_TRACE (1, L"Entering CCertMgrComponent::CCertMgrComponent\n");

	const int ISSUED_TO_BY_WIDTH = 200;
	const int FRIENDLY_NAME_WIDTH = 125;
	const int DATE_WIDTH = 100;
	const int PURPOSE_WIDTH = 125;
	const int STATUS_WIDTH = 50;
    const int TEMPLATE_WIDTH = 100;
    const int SAFER_LEVEL_NAME_WIDTH = 150;
    const int SAFER_LEVEL_DESCRIPTION_WIDTH = 400;
    const int SAFER_ENTRY_NAME_WIDTH = 250;
    const int SAFER_ENTRY_TYPE_WIDTH = 75;
    const int SAFER_ENTRY_LEVEL_WIDTH = 100;
    const int SAFER_ENTRY_DESCRIPTION_WIDTH = 200;
    const int SAFER_ENTRY_LAST_MODIFIED_DATE_WIDTH = 200;

    ::ZeroMemory (m_ColumnWidths, sizeof (UINT*) * CERTMGR_NUMTYPES);
	m_ColumnWidths[CERTMGR_SNAPIN] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SNAPIN] )
		m_ColumnWidths[CERTMGR_SNAPIN][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_USAGE] = new UINT[CERT_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_USAGE] )
	{
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_SUBJECT] = ISSUED_TO_BY_WIDTH;    // issued to
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_ISSUER] = ISSUED_TO_BY_WIDTH;		// issued by
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_EXPIRATION_DATE] = DATE_WIDTH;	// expiration date
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_PURPOSE] = PURPOSE_WIDTH;			// purpose
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_CERT_NAME] = FRIENDLY_NAME_WIDTH;	// friendly name
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_STATUS] = STATUS_WIDTH;			// status
		m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_TEMPLATE] = TEMPLATE_WIDTH;		// template
	}

	m_ColumnWidths[CERTMGR_PHYS_STORE] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_PHYS_STORE] )
		m_ColumnWidths[CERTMGR_PHYS_STORE][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_LOG_STORE] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_LOG_STORE] )
		m_ColumnWidths[CERTMGR_LOG_STORE][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_CERTIFICATE] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_CERTIFICATE] )
		m_ColumnWidths[CERTMGR_CERTIFICATE][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_CRL_CONTAINER] = new UINT[CRL_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_CRL_CONTAINER] )
	{
		m_ColumnWidths[CERTMGR_CRL_CONTAINER][0] = ISSUED_TO_BY_WIDTH; // issued by
		m_ColumnWidths[CERTMGR_CRL_CONTAINER][1] = DATE_WIDTH;	// effective date
		m_ColumnWidths[CERTMGR_CRL_CONTAINER][2] = DATE_WIDTH;	// next update
	}

	m_ColumnWidths[CERTMGR_CTL_CONTAINER] = new UINT[CTL_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_CTL_CONTAINER] )
	{
		m_ColumnWidths[CERTMGR_CTL_CONTAINER][0] = ISSUED_TO_BY_WIDTH;	// issued by
		m_ColumnWidths[CERTMGR_CTL_CONTAINER][1] = DATE_WIDTH;	// effective date
		m_ColumnWidths[CERTMGR_CTL_CONTAINER][2] = PURPOSE_WIDTH;	// purpose
		m_ColumnWidths[CERTMGR_CTL_CONTAINER][3] = FRIENDLY_NAME_WIDTH;	// friendly name
	}

	m_ColumnWidths[CERTMGR_CERT_CONTAINER] = new UINT[CERT_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_CERT_CONTAINER] )
	{
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_SUBJECT] = ISSUED_TO_BY_WIDTH;	// issued to
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_ISSUER] = ISSUED_TO_BY_WIDTH;	// issued by
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_EXPIRATION_DATE] = DATE_WIDTH;	// expiration date
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_PURPOSE] = PURPOSE_WIDTH;		// purpose
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_CERT_NAME] = FRIENDLY_NAME_WIDTH;// friendly name
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_STATUS] = STATUS_WIDTH;			// status
		m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_TEMPLATE] = TEMPLATE_WIDTH;		// template
	}

	m_ColumnWidths[CERTMGR_CRL] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_CRL] )
		m_ColumnWidths[CERTMGR_CRL][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_CTL] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_CTL] )
		m_ColumnWidths[CERTMGR_CTL][0] = SINGLE_COL_WIDTH;

     m_ColumnWidths[CERTMGR_LOG_STORE_GPE] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_LOG_STORE_GPE] )
		m_ColumnWidths[CERTMGR_LOG_STORE_GPE][0] = SINGLE_COL_WIDTH;

     m_ColumnWidths[CERTMGR_LOG_STORE_RSOP] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_LOG_STORE_RSOP] )
		m_ColumnWidths[CERTMGR_LOG_STORE_RSOP][0] = SINGLE_COL_WIDTH;

     m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST] )
		m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_CERT_POLICIES_USER] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_CERT_POLICIES_USER] )
		m_ColumnWidths[CERTMGR_CERT_POLICIES_USER][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_CERT_POLICIES_COMPUTER] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_CERT_POLICIES_COMPUTER] )
		m_ColumnWidths[CERTMGR_CERT_POLICIES_COMPUTER][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS] )
		m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS] )
		m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ROOT] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ROOT] )
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ROOT][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_USER_ROOT] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_ROOT] )
		m_ColumnWidths[CERTMGR_SAFER_USER_ROOT][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS] = new UINT[SAFER_LEVELS_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS] )
    {
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS][COLNUM_SAFER_LEVEL_NAME] = SAFER_LEVEL_NAME_WIDTH;
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS][COLNUM_SAFER_LEVEL_DESCRIPTION] = SAFER_LEVEL_DESCRIPTION_WIDTH;
    }

	m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS] = new UINT[SAFER_LEVELS_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS] )
    {
        m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS][COLNUM_SAFER_LEVEL_NAME] = SAFER_LEVEL_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS][COLNUM_SAFER_LEVEL_DESCRIPTION] = SAFER_LEVEL_DESCRIPTION_WIDTH;
    }

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES] = new UINT[SAFER_ENTRIES_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES] )
    {
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_NAME] = SAFER_ENTRY_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_TYPE] = SAFER_ENTRY_TYPE_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_LEVEL] = SAFER_ENTRY_LEVEL_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_DESCRIPTION] = SAFER_ENTRY_DESCRIPTION_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE] = SAFER_ENTRY_LAST_MODIFIED_DATE_WIDTH;
    }

	m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES] = new UINT[SAFER_ENTRIES_NUM_COLS];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES] )
    {
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_NAME] = SAFER_ENTRY_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_TYPE] = SAFER_ENTRY_TYPE_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_LEVEL] = SAFER_ENTRY_LEVEL_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_DESCRIPTION] = SAFER_ENTRY_DESCRIPTION_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE] = SAFER_ENTRY_LAST_MODIFIED_DATE_WIDTH;
    }

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVEL] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVEL] )
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVEL][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_USER_LEVEL] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_LEVEL] )
		m_ColumnWidths[CERTMGR_SAFER_USER_LEVEL][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRY] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRY] )
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRY][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_USER_ENTRY] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_ENTRY] )
		m_ColumnWidths[CERTMGR_SAFER_USER_ENTRY][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS] )
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS] )
		m_ColumnWidths[CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES] )
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_USER_DEFINED_FILE_TYPES] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_DEFINED_FILE_TYPES] )
		m_ColumnWidths[CERTMGR_SAFER_USER_DEFINED_FILE_TYPES][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_USER_ENFORCEMENT] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_USER_ENFORCEMENT] )
		m_ColumnWidths[CERTMGR_SAFER_USER_ENFORCEMENT][0] = SINGLE_COL_WIDTH;

	m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENFORCEMENT] = new UINT[1];
	if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENFORCEMENT] )
		m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENFORCEMENT][0] = SINGLE_COL_WIDTH;

	_TRACE (-1, L"Leaving CCertMgrComponent::CCertMgrComponent\n");
}

CCertMgrComponent::~CCertMgrComponent ()
{
	_TRACE (1, L"Entering CCertMgrComponent::~CCertMgrComponent\n");
	VERIFY ( SUCCEEDED (ReleaseAll ()) );

	CloseAndReleaseUsageStores ();

	for (int i = 0; i < CERTMGR_NUMTYPES; i++)
	{
        if ( m_ColumnWidths[i] )
		    delete [] m_ColumnWidths[i];
	}

    if ( m_pLastUsageCookie )
        m_pLastUsageCookie->Release ();

    if ( m_pToolbar )
        m_pToolbar->Release ();

    if ( m_pControlbar )
        m_pControlbar->Release ();

	_TRACE (-1, L"Leaving CCertMgrComponent::~CCertMgrComponent\n");
}

HRESULT CCertMgrComponent::ReleaseAll ()
{
	_TRACE (1, L"Entering CCertMgrComponent::ReleaseAll\n");

	HRESULT hr = CComponent::ReleaseAll ();
	_TRACE (-1, L"Leaving CCertMgrComponent::ReleaseAll: 0x%x\n", hr);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation

HRESULT CCertMgrComponent::LoadStrings ()
{
	_TRACE (1, L"Entering CCertMgrComponent::LoadStrings\n");
	_TRACE (-1, L"Leaving CCertMgrComponent::LoadStrings\n");
	return S_OK;
}

HRESULT CCertMgrComponent::LoadColumns ( CCertMgrCookie* pcookie )
{
	_TRACE (1, L"Entering CCertMgrComponent::LoadColumns\n");
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
     TEST_NONNULL_PTR_PARAM (pcookie);
	HRESULT	hr = S_OK;
	CString	str;


	switch ( pcookie->m_objecttype )
	{

	case CERTMGR_SNAPIN:
		if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
			VERIFY (str.LoadString (IDS_COLUMN_LOG_CERTIFICATE_STORE) );
		else
			VERIFY (str.LoadString (IDS_COLUMN_PURPOSE) );
		hr = m_pHeader->InsertColumn (0,
				const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT, m_ColumnWidths
				[CERTMGR_SNAPIN][0]);
		break;

	case CERTMGR_LOG_STORE:
		if ( QueryComponentDataRef ().m_bShowPhysicalStoresPersist )
			VERIFY (str.LoadString (IDS_COLUMN_PHYS_CERTIFICATE_STORE) );
		else
			VERIFY (str.LoadString (IDS_COLUMN_OBJECT_TYPE) );
		hr = m_pHeader->InsertColumn (0,
				const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
				m_ColumnWidths[CERTMGR_LOG_STORE][0]);
		break;

	case CERTMGR_LOG_STORE_GPE:
		{
			CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pcookie);
			if ( pStore )
			{
				switch (pStore->GetStoreType ())
				{
				case EFS_STORE:
					if ( pStore->IsNullEFSPolicy () )
					{
						VERIFY (str.LoadString (IDS_STATUS));
						hr = m_pHeader->InsertColumn (0,
								const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
								SINGLE_COL_WIDTH);
					}
					else
						hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
					break;

				case ROOT_STORE:
					hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
					break;

				case TRUST_STORE:
					hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CTL_CONTAINER));
					break;

				case ACRS_STORE:
					VERIFY (str.LoadString (IDS_COLUMN_AUTO_CERT_REQUEST));
					hr = m_pHeader->InsertColumn (0,
							const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
							m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST][0]);
					break;

				default:
					break;
				}
			}
			else
                {
                     _TRACE (0, L"Unexpected error: reinterpret_cast <CCertStoreGPE*> (pcookie) failed.\n");
                     hr = E_UNEXPECTED;
                }
		}
		break;

	case CERTMGR_LOG_STORE_RSOP:
		{
			CCertStoreRSOP* pStore = reinterpret_cast <CCertStoreRSOP*> (pcookie);
			if ( pStore )
			{
				switch (pStore->GetStoreType ())
				{
				case EFS_STORE:
					if ( pStore->IsNullEFSPolicy () )
					{
						VERIFY (str.LoadString (IDS_STATUS));
						hr = m_pHeader->InsertColumn (0,
								const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
								SINGLE_COL_WIDTH);
					}
					else
						hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
					break;

				case ROOT_STORE:
					hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
					break;

				case TRUST_STORE:
					hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CTL_CONTAINER));
					break;

				case ACRS_STORE:
					VERIFY (str.LoadString (IDS_COLUMN_AUTO_CERT_REQUEST));
					hr = m_pHeader->InsertColumn (0,
							const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
							m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST][0]);
					break;

				default:
					break;
				}
			}
			else
                {
                     _TRACE (0, L"Unexpected error: reinterpret_cast <CCertStoreGPE*> (pcookie) failed.\n");
                     hr = E_UNEXPECTED;
                }
		}
		break;

	default:
		hr = LoadColumnsFromArrays ( (INT) (pcookie->m_objecttype));
		break;
	}


	_TRACE (-1, L"Leaving CCertMgrComponent::LoadColumns: 0x%x\n", hr);
	return hr;
}


/* This is generated by UpdateAllViews () */
HRESULT CCertMgrComponent::OnViewChange (LPDATAOBJECT pDataObject, LPARAM /*data*/, LPARAM hint)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnViewChange\n");
     HRESULT hr = S_OK;
	if ( pDataObject )
    {
        if ( HINT_CERT_ENROLLED_USAGE_MODE & hint )
        {
            // Force reenumeration of usage stores
            m_bUsageStoresEnumerated = false;
        }

	    if ( (HINT_CHANGE_VIEW_TYPE & hint) ||
		    (HINT_CHANGE_STORE_TYPE & hint) ||
		    (HINT_SHOW_ARCHIVE_CERTS & hint) ||
            (HINT_CHANGE_COMPUTER & hint) ||
            (HINT_REFRESH_STORES & hint) )
        {
		    hr = QueryComponentDataRef ().RefreshScopePane (0);
	    }
	    else if ( HINT_EFS_ADD_DEL_POLICY & hint )
	    {
            // Delete existing columns and add new columns
            if ( m_pResultData )
            {
                m_pResultData->DeleteAllRsltItems ();
            }
            else
            {
                _TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
            }
            do {
                hr = m_pHeader->DeleteColumn (0);
            } while ( SUCCEEDED (hr) );

            CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
            if ( pCookie )
                hr = LoadColumns (pCookie);
            else
            {
                _TRACE (0, L"Unexpected error: ConvertCookie () returned NULL\n");
                hr = E_UNEXPECTED;
            }
        }
        else if ( (HINT_PASTE_COOKIE & hint) ||
                (HINT_IMPORT & hint) )
        {
            // Do nothing
        }
        else
        {
            hr = QueryComponentDataRef ().RefreshScopePane (pDataObject);
            if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist && 
                    m_pLastUsageCookie)
            {
                hr = DisplayCertificateCountByUsage (
                        m_pLastUsageCookie->GetObjectName (),
                        m_pLastUsageCookie->GetCertCount ());
            }
        }

        if ( SUCCEEDED (hr) )
        {
            hr = RefreshResultPane ();
        }

        CCertMgrComponentData&	compData = QueryComponentDataRef ();
        CCertMgrCookie* pCookie = compData.ConvertCookie (pDataObject);
        if ( pCookie )
        {
            switch (pCookie->m_objecttype)
            {
            case CERTMGR_CERTIFICATE:
                {
                    CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                    if ( pCert )
                    {
                        if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                        {
                            hr = DisplayCertificateCountByStore (m_pConsole, 
                                    pCert->GetCertStore ());
                        }
                        else
                        {
                            ASSERT (m_pLastUsageCookie);
                            if ( m_pLastUsageCookie )
                            {
                                 hr = DisplayCertificateCountByUsage (
                                        m_pLastUsageCookie->GetObjectName (),
                                        m_pLastUsageCookie->GetCertCount ());
                            }
                        }
                    }
                }
                break;

            case CERTMGR_LOG_STORE:
            case CERTMGR_PHYS_STORE:
            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE_RSOP:
                {
                    CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
                    if ( pStore )
                    {
                        pStore->GetStoreHandle (); // to initialize read-only flag
                        if ( pStore->IsReadOnly () )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                        hr = DisplayCertificateCountByStore (m_pConsole, pStore,
                                (CERTMGR_LOG_STORE_GPE == pCookie->m_objecttype || 
                                CERTMGR_LOG_STORE_RSOP == pCookie->m_objecttype));
                        pStore->Close ();
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;

            case CERTMGR_USAGE:
                {
                    CUsageCookie* pUsage = reinterpret_cast <CUsageCookie*> (pCookie);
                    if ( pUsage )
                    {
                        hr = DisplayCertificateCountByUsage (pCookie->GetObjectName (),
                        pUsage->GetCertCount ());
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                ASSERT (0);
                break;

            case CERTMGR_SNAPIN:
            case CERTMGR_CRL_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
            case CERTMGR_CERT_CONTAINER:
            case CERTMGR_CRL:
            case CERTMGR_CTL:
            case CERTMGR_AUTO_CERT_REQUEST:
            case CERTMGR_CERT_POLICIES_USER:
            case CERTMGR_CERT_POLICIES_COMPUTER:
            default:
                {
                    IConsole2*	pConsole2 = 0;
                    hr = m_pConsole->QueryInterface (
                            IID_PPV_ARG(IConsole2, &pConsole2));
                    if (SUCCEEDED (hr))
                    {
                        hr = pConsole2->SetStatusText (L"");
                        if ( !SUCCEEDED (hr) )
                        {
                            _TRACE (0, L"IConsole2::SetStatusText () failed: %x", hr);
                        }
                        pConsole2->Release ();
                    }
                }
                break;
            }
        }
    }
    else
    {
        hr = E_POINTER;
        _TRACE (0, L"Unexpected error: paramater pDataObject was NULL\n");
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::OnViewChange: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::Show ( CCookie* pcookie, LPARAM arg, HSCOPEITEM /*hScopeItem*/, LPDATAOBJECT /*pDataObject*/)
{
	_TRACE (1, L"Entering CCertMgrComponent::Show\n");
	HRESULT	hr = S_OK;
     TEST_NONNULL_PTR_PARAM (pcookie);

	if ( !arg )
	{
		if ( !m_pResultData )
		{
			_TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
			return E_UNEXPECTED;
		}

		m_pViewedCookie = reinterpret_cast <CCertMgrCookie*> (pcookie);
		if ( m_pViewedCookie )
			hr = SaveWidths (m_pViewedCookie);
		m_pViewedCookie = 0;
		return S_OK;
	}

    if ( m_pResultData )
    {
        m_pResultData->ModifyViewStyle (MMC_ENSUREFOCUSVISIBLE, 
                (MMC_RESULT_VIEW_STYLE) 0);
    }

	m_pViewedCookie = reinterpret_cast <CCertMgrCookie*> (pcookie);
     if ( m_pViewedCookie )
	{
		// Load default columns and widths
		LoadColumns (m_pViewedCookie);

		// Restore persisted column widths
		switch (m_pViewedCookie->m_objecttype)
		{
		case CERTMGR_SNAPIN:
		case CERTMGR_USAGE:
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_CERT_POLICIES_USER:
		case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            break;

        case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
		default:
			_TRACE (0, L"Invalid or unexpected m_objecttype in switch: 0x%x\n", m_pViewedCookie->m_objecttype);
			break;
		}

		hr = PopulateListbox (m_pViewedCookie);
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::Show: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::Show ( CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem)
{
	_TRACE (1, L"Entering CCertMgrComponent::Show\n");
	_TRACE (0, L"Unexpected: We should never enter this method.\n");
	_TRACE (-1, L"Leaving CCertMgrComponent::Show\n");
	return Show (pcookie, arg, hScopeItem, 0);
}


HRESULT CCertMgrComponent::OnNotifyAddImages (
        LPDATAOBJECT /*pDataObject*/,
        LPIMAGELIST lpImageList,
        HSCOPEITEM /*hSelectedItem*/)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyAddImages\n");
	long	lViewMode = 0;
     HRESULT hr = S_OK;

	if ( m_pResultData )
     {
	     QueryComponentDataRef ().SetResultData (m_pResultData);

	     hr = m_pResultData->GetViewMode (&lViewMode);	
	     if ( SUCCEEDED (hr) )
         {
	        BOOL	bLoadLargeIcons = (LVS_ICON == lViewMode);

	        hr = QueryComponentDataRef ().LoadIcons (lpImageList, bLoadLargeIcons);
         }
     }
     else
     {
          _TRACE (0, L"Unexpected error: m_pResultData is NULL\n");
          hr = E_UNEXPECTED;
     }
	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyAddImages: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::EnumCertificates (CCertStore& rCertStore)
{
	_TRACE (1, L"Entering CCertMgrComponent::EnumCertificates\n");

	CWaitCursor				cursor;
     PCCERT_CONTEXT			pCertContext = 0;
	HRESULT					hr = 0;
	CCertificate*			pCert = 0;
	RESULTDATAITEM			rdItem;
	CCookie&				rootCookie = QueryComponentDataRef ().QueryBaseRootCookie ();

	::ZeroMemory (&rdItem, sizeof (rdItem));
	rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	rdItem.nImage = iIconCertificate;
	rdItem.nCol = 0;
	rdItem.str = MMC_TEXTCALLBACK;


	//	Iterate through the list of certificates in the system store,
	//	allocate new certificates with the CERT_CONTEXT returned,
	//	and store them in the certificate list.
	while ( 1 )
	{
		pCertContext = rCertStore.EnumCertificates (pCertContext);
		if ( !pCertContext )
		{
			if ( EFS_STORE == rCertStore.GetStoreType () )
			{
				if ( rCertStore.IsNullEFSPolicy () )
				{
					CString	name;
					VERIFY (name.LoadString (IDS_NO_POLICY_DEFINED));
					CCertMgrCookie* pNewCookie = new CCertMgrCookie (
							CERTMGR_NULL_POLICY, 0, (LPCWSTR) name);
					if ( pNewCookie )
					{
						rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);
						::ZeroMemory (&rdItem, sizeof (rdItem));
						rdItem.mask = RDI_STR | RDI_PARAM;
                        rdItem.str = MMC_TEXTCALLBACK;
						rdItem.lParam = (LPARAM) pNewCookie;
						pNewCookie->m_resultDataID = m_pResultData;
						hr = m_pResultData->InsertItem (&rdItem);
					}
					else
					{
						hr = E_OUTOFMEMORY;
						break;
					}
				}
			}
			break;
		}
		pCert =
			new CCertificate (pCertContext, &rCertStore);
		if ( !pCert )
		{
			hr = E_OUTOFMEMORY;
			break;
		}

		rootCookie.m_listResultCookieBlocks.AddHead (pCert);
		rdItem.lParam = (LPARAM) pCert;
		pCert->m_resultDataID = m_pResultData;
		hr = m_pResultData->InsertItem (&rdItem);
          if ( FAILED (hr) )
          {
		     _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
          }
	}
	rCertStore.Close ();

	_TRACE (-1, L"Leaving CCertMgrComponent::EnumCertificates: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::PopulateListbox (CCertMgrCookie* pCookie)
{
	_TRACE (1, L"Entering CCertMgrComponent::PopulateListbox\n");
    if ( !pCookie )
        return E_POINTER;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = S_OK;
	CWaitCursor	cursor;
    CCertMgrComponentData& dataRef = QueryComponentDataRef ();

	switch ( pCookie->m_objecttype )
	{
	case CERTMGR_PHYS_STORE:
	case CERTMGR_LOG_STORE:
		break;

	case CERTMGR_LOG_STORE_GPE:
	case CERTMGR_LOG_STORE_RSOP:
		{
			CCertStore*	pStore = reinterpret_cast <CCertStore*> (pCookie);
			if ( pStore )
			{
				switch (pStore->GetStoreType () )
				{
				case EFS_STORE:
				case ROOT_STORE:
					hr = EnumCertificates (*pStore);
					if ( SUCCEEDED (hr) )
					{
						m_currResultNodeType = CERTMGR_CERTIFICATE;
						m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                                (long) m_currResultNodeType);
					}
					break;

				case ACRS_STORE:
					hr = EnumCTLs (*pStore);
					if ( SUCCEEDED (hr) )
					{
						m_currResultNodeType = CERTMGR_AUTO_CERT_REQUEST;
						m_pResultData->Sort (m_nSelectedCTLColumn, 0, 
                                (long) m_currResultNodeType);
					}
					break;

				case TRUST_STORE:
					hr = EnumCTLs (*pStore);
					if ( SUCCEEDED (hr) )
					{
						m_currResultNodeType = CERTMGR_CTL;
						m_pResultData->Sort (m_nSelectedCTLColumn, 0, 
                                (long) m_currResultNodeType);
					}
					break;


				default:
				     _TRACE (0, L"Error: Unexpected store type: 0x%x\n", pStore->GetStoreType ());
                          hr = E_UNEXPECTED;
					break;
				}

                if ( SUCCEEDED (hr) )
                    hr = DisplayCertificateCountByStore (m_pConsole, pStore, true);
			}
			else
				hr = E_POINTER;
		}
		break;

	case CERTMGR_CERT_CONTAINER:
		{
			CContainerCookie*	pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
			if ( pContainer )
			{
				hr = EnumCertificates (pContainer->GetCertStore ());
				if ( SUCCEEDED (hr) )
				{
					m_currResultNodeType = CERTMGR_CERTIFICATE;
					m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                            (long) m_currResultNodeType);
                    hr = DisplayCertificateCountByStore (m_pConsole, &pContainer->GetCertStore (), false);
				}
			}
		}
		break;

	case CERTMGR_USAGE:
		{
			CUsageCookie* pUsageCookie = reinterpret_cast <CUsageCookie*> (pCookie);
			if ( pUsageCookie )
			{
				hr = EnumCertsByUsage (pUsageCookie);
				if ( SUCCEEDED (hr) )
				{
					m_currResultNodeType = CERTMGR_CERTIFICATE;
					m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                            (long) m_currResultNodeType);
				}
			}
		}
		break;

	case CERTMGR_CRL_CONTAINER:
		{
			CContainerCookie*	pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
			if ( pContainer )
			{
				PCCRL_CONTEXT	pCRLContext = 0;
				CCRL*			pCRL = 0;
				RESULTDATAITEM	rdItem;
				CCookie&		rootCookie = dataRef.QueryBaseRootCookie ();


				::ZeroMemory (&rdItem, sizeof (rdItem));
				rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
				rdItem.nImage = iIconCRL;
				rdItem.nCol = 0;

				//	Iterate through the list of certificates in the system store,
				//	allocate new certificates with the CERT_CONTEXT returned,
				//	and store them in the certificate list.
				DWORD	dwFlags = 0;
				while ( 1 )
				{
					pCRLContext = pContainer->GetCertStore ().GetCRL (NULL,
							pCRLContext, &dwFlags);
					if ( !pCRLContext )
						break;
					pCRL =
						new CCRL (pCRLContext, pContainer->GetCertStore ());
					if ( !pCRL )
					{
						hr = E_OUTOFMEMORY;
						break;
					}

					rootCookie.m_listResultCookieBlocks.AddHead (pCRL);
					rdItem.str = MMC_TEXTCALLBACK;
					rdItem.lParam = (LPARAM) pCRL;
					pCRL->m_resultDataID = m_pResultData;
					hr = m_pResultData->InsertItem (&rdItem);
                          if ( FAILED (hr) )
                          {
		                     _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                          }
				}
				if ( SUCCEEDED (hr) )
				{
					m_currResultNodeType = CERTMGR_CRL;
					m_pResultData->Sort (m_nSelectedCRLColumn, 0, 
                            (long) m_currResultNodeType);
				}
			}
		}
		break;

	case CERTMGR_CTL_CONTAINER:
		{
			CContainerCookie*	pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
			if ( pContainer )
			{
				hr = EnumCTLs (pContainer->GetCertStore ());
				if ( SUCCEEDED (hr) )
				{
					m_currResultNodeType = CERTMGR_CTL;
					m_pResultData->Sort (m_nSelectedCTLColumn, 0, 
                            (long) m_currResultNodeType);
                    hr = DisplayCertificateCountByStore (m_pConsole, &pContainer->GetCertStore (), false);
				}
			}
		}
		break;


    case CERTMGR_CERT_POLICIES_USER:
    case CERTMGR_CERT_POLICIES_COMPUTER:
        // Only this node if machine is joined to a Whistler or later domain
        if ( !dataRef.m_bMachineIsStandAlone && !g_bSchemaIsW2K )
		{
			RESULTDATAITEM	rdItem;
			CCookie&		rootCookie = dataRef.QueryBaseRootCookie ();


			::ZeroMemory (&rdItem, sizeof (rdItem));
			rdItem.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
			rdItem.nImage = iIconAutoEnroll;
			rdItem.nCol = 0;

            CString objectName;
            VERIFY (objectName.LoadString (IDS_PKP_AUTOENROLLMENT_SETTINGS));
            CCertMgrCookie* pNewCookie = new CCertMgrCookie (
                    CERTMGR_CERT_POLICIES_COMPUTER == pCookie->m_objecttype ? 
                        CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS :
                        CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS,
                    pCookie->QueryNonNULLMachineName (),
                    objectName);
			if ( !pNewCookie )
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);
			rdItem.str = MMC_TEXTCALLBACK ;
			rdItem.lParam = (LPARAM) pNewCookie;
			pNewCookie->m_resultDataID = m_pResultData;
			hr = m_pResultData->InsertItem (&rdItem);
            if ( FAILED (hr) )
            {
                 _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
            }
		}
		break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        ASSERT (0);
        break;

    case CERTMGR_SAFER_COMPUTER_LEVELS:
        {
            CPolicyKey  policyKey (dataRef.m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, true);
            hr = AddSaferLevels (true, 
                    pCookie->QueryNonNULLMachineName (), policyKey.GetKey ());
        }
        break;

    case CERTMGR_SAFER_USER_LEVELS:
        {
            CPolicyKey  policyKey (dataRef.m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, false);
            hr = AddSaferLevels (false, 
                    pCookie->QueryNonNULLMachineName (), policyKey.GetKey ());
        }
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
        {
            CSaferEntries* pSaferEntries = dynamic_cast <CSaferEntries*> (pCookie);
            if ( pSaferEntries )
            {
                hr = SaferEnumerateEntries (
                        CERTMGR_SAFER_COMPUTER_ENTRIES == pCookie->m_objecttype,
                        pSaferEntries);
                if (SUCCEEDED (hr) )
                    m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                            (long) m_currResultNodeType);
            }
        }
        break;

    case CERTMGR_SAFER_COMPUTER_ROOT:
    case CERTMGR_SAFER_USER_ROOT:
        {
            CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
            if ( pSaferRootCookie )
            {
                if ( (pSaferRootCookie->m_bCreateSaferNodes && dataRef.m_bSaferSupported) 
                        || dataRef.m_bIsRSOP )
		        {
			        RESULTDATAITEM	rdItem;
			        CCookie&		rootCookie = dataRef.QueryBaseRootCookie ();


			        ::ZeroMemory (&rdItem, sizeof (rdItem));
			        rdItem.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
			        rdItem.nImage = iIconSettings;
			        rdItem.nCol = 0;

                    CString         objectName;
                    CCertMgrCookie* pNewCookie = 0;

                    if ( SUCCEEDED (hr) )
                    {
                        VERIFY (objectName.LoadString (IDS_SAFER_ENFORCEMENT));
                        pNewCookie = new CCertMgrCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype ? 
                                    CERTMGR_SAFER_COMPUTER_ENFORCEMENT :
                                    CERTMGR_SAFER_USER_ENFORCEMENT,
                                pCookie->QueryNonNULLMachineName (),
                                objectName);
			            if ( !pNewCookie )
			            {
				            hr = E_OUTOFMEMORY;
				            break;
			            }

			            rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);
			            rdItem.str = MMC_TEXTCALLBACK ;
			            rdItem.lParam = (LPARAM) pNewCookie;
			            pNewCookie->m_resultDataID = m_pResultData;
			            hr = m_pResultData->InsertItem (&rdItem);
                        if ( FAILED (hr) )
                        {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                        }
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        VERIFY (objectName.LoadString (IDS_SAFER_DEFINED_FILE_TYPES));
                        pNewCookie = new CCertMgrCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype ? 
                                    CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES :
                                    CERTMGR_SAFER_USER_DEFINED_FILE_TYPES,
                                pCookie->QueryNonNULLMachineName (),
                                objectName);
			            if ( !pNewCookie )
			            {
				            hr = E_OUTOFMEMORY;
				            break;
			            }

			            rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);

			            rdItem.str = MMC_TEXTCALLBACK ;
			            rdItem.lParam = (LPARAM) pNewCookie;
			            pNewCookie->m_resultDataID = m_pResultData;
			            hr = m_pResultData->InsertItem (&rdItem);
                        if ( FAILED (hr) )
                        {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                        }
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        VERIFY (objectName.LoadString (IDS_SAFER_TRUSTED_PUBLISHERS));
                        pNewCookie = new CCertMgrCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype ? 
                                    CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS :
                                    CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS,
                                pCookie->QueryNonNULLMachineName (),
                                objectName);
			            if ( !pNewCookie )
			            {
				            hr = E_OUTOFMEMORY;
				            break;
			            }

			            rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);

			            rdItem.str = MMC_TEXTCALLBACK ;
			            rdItem.lParam = (LPARAM) pNewCookie;
			            pNewCookie->m_resultDataID = m_pResultData;
			            hr = m_pResultData->InsertItem (&rdItem);
                        if ( FAILED (hr) )
                        {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                        }
                    }
		        }
                else
                {
                    CComPtr<IUnknown> spUnknown;
                    hr = m_pConsole->QueryResultView(&spUnknown);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IMessageView> spMessageView;
                        hr = spUnknown->QueryInterface (IID_PPV_ARG (IMessageView, &spMessageView));
                        if (SUCCEEDED(hr))
                        {
                            CString szTitle;
                            CString szMessage;

                            VERIFY (szTitle.LoadString (IDS_SAFER_NO_POLICY_TITLE));
                            VERIFY (szMessage.LoadString (IDS_SAFER_NO_POLICY_TEXT));

                            spMessageView->SetTitleText (szTitle);
                            spMessageView->SetBodyText (szMessage);
                            spMessageView->SetIcon (Icon_Warning);
                        }
                    }
                }
            }
        }
		break;

	default:
		break;
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::PopulateListbox: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::RefreshResultPane ()
{
	_TRACE (1, L"Entering CCertMgrComponent::RefreshResultPane\n");
	HRESULT hr = S_OK;

	if ( m_pResultData )
	{
		// Does this return E_UNEXPECTED when there are no items?
		HRESULT hr1 = m_pResultData->DeleteAllRsltItems ();
		if ( FAILED (hr1) )
		{
               _TRACE (0, L"IResultData::DeleteAllRsltItems () failed: 0x%x\n", hr1);
		}
	}
	else
     {
          _TRACE (0, L"Unexpected error: m_pResultData is NULL\n");
		hr = E_UNEXPECTED;
     }

	if ( m_pViewedCookie )
	{
		hr = PopulateListbox (m_pViewedCookie);
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::RefreshResultPane: 0x%x\n", hr);
	return hr;
}

STDMETHODIMP CCertMgrComponent::GetDisplayInfo (RESULTDATAITEM * pResult)
{	
//	_TRACE (1, L"Entering CCertMgrComponent::GetDisplayInfo\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT hr = S_OK;


	if ( pResult && !pResult->bScopeItem ) //&& (pResult->mask & RDI_PARAM) )
	{
		CCookie* pResultCookie = reinterpret_cast<CCookie*> (pResult->lParam);
		ASSERT (pResultCookie);
		if ( !pResultCookie || IsBadWritePtr ((LPVOID) pResultCookie, sizeof (CCookie)) )
			return E_UNEXPECTED;

		CCookie* pActiveCookie = ActiveBaseCookie (pResultCookie);
		ASSERT (pActiveCookie);
		if ( !pActiveCookie || IsBadWritePtr ((LPVOID) pActiveCookie, sizeof (CCookie)) )
			return E_UNEXPECTED;

		CCertMgrCookie* pCookie = reinterpret_cast <CCertMgrCookie*>(pActiveCookie);
		ASSERT (pCookie);
		switch (pCookie->m_objecttype)
		{
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_USER_ENTRIES:
            // iIconSaferHashEntry
            // iIconSaferURLEntry
            // iIconSaferNameEntry
            ASSERT (0);
            break;

        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
			if (pResult->mask & RDI_STR)
			{
				if ( COLNUM_SAFER_LEVEL_NAME == pResult->nCol )
				{
					m_szDisplayInfoResult = pCookie->GetObjectName ();
					pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
				}
                else if ( COLNUM_SAFER_LEVEL_DESCRIPTION == pResult->nCol )
                {
                    CSaferLevel* pLevel = dynamic_cast <CSaferLevel*> (pCookie);
                    if ( pLevel )
                    {
					    m_szDisplayInfoResult = pLevel->GetDescription ();
					    pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                }
			}
            if ( pResult->mask & RDI_IMAGE )
            {
                CSaferLevel* pLevel = dynamic_cast <CSaferLevel*> (pCookie);
                if ( pLevel && pLevel->IsDefault () )
                {
                    QueryComponentDataRef ().m_dwDefaultSaferLevel = 
                            pLevel->GetLevel ();
                    pResult->nImage = iIconDefaultSaferLevel;
                }
                else
                    pResult->nImage = iIconSaferLevel;
            }
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            if (pResult->mask & RDI_STR)
            {
                CSaferEntry* pSaferEntry = dynamic_cast <CSaferEntry*> (pCookie);
                if ( pSaferEntry )
                {
			        switch (pResult->nCol)
                    {
                    case COLNUM_SAFER_ENTRIES_NAME:
                        m_szDisplayInfoResult = pSaferEntry->GetDisplayName ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_TYPE:
                        m_szDisplayInfoResult = pSaferEntry->GetTypeString ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_LEVEL:
                        m_szDisplayInfoResult = pSaferEntry->GetLevelFriendlyName ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_DESCRIPTION:
                        m_szDisplayInfoResult = pSaferEntry->GetDescription ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE:
                        m_szDisplayInfoResult = pSaferEntry->GetShortLastModified ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
            }
            if ( pResult->mask & RDI_IMAGE )
            {
                CSaferEntry* pEntry = dynamic_cast <CSaferEntry*> (pCookie);
                if ( pEntry )
                {
                    switch (pEntry->GetType () )
                    {
                    case SAFER_ENTRY_TYPE_HASH:
                        pResult->nImage = iIconSaferHashEntry;
                        break;

                    case SAFER_ENTRY_TYPE_PATH:
                        pResult->nImage = iIconSaferNameEntry;
                        break;

                    case SAFER_ENTRY_TYPE_URLZONE:
                        pResult->nImage = iIconSaferURLEntry;
                        break;

                    case SAFER_ENTRY_TYPE_CERT:
                        pResult->nImage = iIconSaferCertEntry;
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
            }
			break;


        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
			if (pResult->mask & RDI_STR)
			{
				if ( 0 == pResult->nCol )
				{
					m_szDisplayInfoResult = pCookie->GetObjectName ();
					pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
				}
			}
			if (pResult->mask & RDI_IMAGE)
                pResult->nImage = iIconAutoEnroll;
			break;

        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
			if (pResult->mask & RDI_STR)
			{
				if ( 0 == pResult->nCol )
				{
					m_szDisplayInfoResult = pCookie->GetObjectName ();
					pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
				}
			}
			if (pResult->mask & RDI_IMAGE)
                pResult->nImage = iIconSettings;
			break;

		case CERTMGR_NULL_POLICY:
			if (pResult->mask & RDI_STR)
			{
				if ( 0 == pResult->nCol )
				{
					m_szDisplayInfoResult = pCookie->GetObjectName ();
					pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
				}
			}
			break;

		case CERTMGR_CERTIFICATE:
			{
				CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
				ASSERT (pCert);
				if ( pCert )
				{
					if (pResult->mask & RDI_STR)
					{
						// Note:  text is first stored in class variable so that the buffer is
						// somewhat persistent.  Copying the buffer pointer directly to the
						// pResult->str would result in the buffer being freed before the pointer
						// is used.
						switch (pResult->nCol)
						{
						case COLNUM_CERT_ISSUER:
							m_szDisplayInfoResult = pCert->GetIssuerName ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								m_szDisplayInfoResult = pCert->GetAlternateIssuerName ();
								if ( m_szDisplayInfoResult.IsEmpty () )
									SetTextNotAvailable ();
							}
							break;

						case COLNUM_CERT_SUBJECT:
							m_szDisplayInfoResult = pCert->GetSubjectName ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								m_szDisplayInfoResult = pCert->GetAlternateSubjectName ();
								if ( m_szDisplayInfoResult.IsEmpty () )
									SetTextNotAvailable ();
							}
							break;

						case COLNUM_CERT_EXPIRATION_DATE:
							m_szDisplayInfoResult = pCert->GetValidNotAfter ();
							break;

						case COLNUM_CERT_PURPOSE:
							m_szDisplayInfoResult = pCert->GetEnhancedKeyUsage ();
							break;

						case COLNUM_CERT_CERT_NAME:
							m_szDisplayInfoResult = pCert->GetFriendlyName ();
							break;

						case COLNUM_CERT_STATUS:
                            m_szDisplayInfoResult = pCert->FormatStatus ();
							break;

                        // NTRAID# 247237	Cert UI: Cert Snapin: Certificates snapin should show  template name
                        case COLNUM_CERT_TEMPLATE:
                            m_szDisplayInfoResult = pCert->GetTemplateName ();
							break;

						default:
							ASSERT (0);
							break;
						}

						pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
					}
					if (pResult->mask & RDI_IMAGE)
						pResult->nImage = iIconCertificate;
				}
			}
			break;

		case CERTMGR_CTL:
			{
				CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
				ASSERT (pCTL);
				if ( pCTL )
				{
					if (pResult->mask & RDI_STR)
					{
						// Note:  text is first stored in class variable so that the buffer is
						// somewhat persistent.  Copying the buffer pointer directly to the
						// pResult->str would result in the buffer being freed before the pointer
						// is used.
						switch (pResult->nCol)
						{
						case COLNUM_CTL_ISSUER:
							m_szDisplayInfoResult = pCTL->GetIssuerName ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;


						case COLNUM_CTL_EFFECTIVE_DATE:
							m_szDisplayInfoResult = pCTL->GetEffectiveDate ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;

						case COLNUM_CTL_PURPOSE:
							m_szDisplayInfoResult = pCTL->GetPurpose ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;

						case COLNUM_CTL_FRIENDLY_NAME:
							m_szDisplayInfoResult = pCTL->GetFriendlyName ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;

						default:
							ASSERT (0);
							break;
						}

						pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
					}
					if (pResult->mask & RDI_IMAGE)
						pResult->nImage = iIconCTL;
				}
			}
			break;

		case CERTMGR_CRL:
			{
				CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
				ASSERT (pCRL);
				if ( pCRL )
				{
					if (pResult->mask & RDI_STR)
					{
						// Note:  text is first stored in class variable so that the buffer is
						// somewhat persistent.  Copying the buffer pointer directly to the
						// pResult->str would result in the buffer being freed before the pointer
						// is used.
						switch (pResult->nCol)
						{
						case COLNUM_CRL_ISSUER:
							m_szDisplayInfoResult = pCRL->GetIssuerName ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;


						case COLNUM_CRL_EFFECTIVE_DATE:
							m_szDisplayInfoResult = pCRL->GetEffectiveDate ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;

						case COLNUM_CRL_NEXT_UPDATE:
							m_szDisplayInfoResult = pCRL->GetNextUpdate ();
							if ( m_szDisplayInfoResult.IsEmpty () )
							{
								SetTextNotAvailable ();
							}
							break;

						default:
							ASSERT (0);
							break;
						}

						pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
					}
					if (pResult->mask & RDI_IMAGE)
						pResult->nImage = iIconCRL;
				}
			}
			break;

		case CERTMGR_AUTO_CERT_REQUEST:
			{
				CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pCookie);
				ASSERT (pACR);
				if ( pACR )
				{
					if (pResult->mask & RDI_STR)
					{
						// Note:  text is first stored in class variable so that the buffer is
						// somewhat persistent.  Copying the buffer pointer directly to the
						// pResult->str would result in the buffer being freed before the pointer
						// is used.
						switch (pResult->nCol)
						{
						case 0:
							{
								CString	name;

								if ( SUCCEEDED (pACR->GetCertTypeName (name)) )
									m_szDisplayInfoResult = name;
								else
									SetTextNotAvailable ();
							}
							break;

						default:
							ASSERT (0);
							break;
						}

						pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
					}
					if (pResult->mask & RDI_IMAGE)
						pResult->nImage = iIconAutoCertRequest;
				}
			}
			break;
		}
     }
	else
		hr = CComponent::GetDisplayInfo (pResult);

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertMgrComponent::AddMenuItems (LPDATAOBJECT pDataObject,
                                                          LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                                          long *pInsertionAllowed)
{
	_TRACE (1, L"Entering CCertMgrComponent::AddMenuItems\n");
	HRESULT	hr = S_OK;
	hr = QueryComponentDataRef ().AddMenuItems (pDataObject,
			pContextMenuCallback, pInsertionAllowed);
	_TRACE (-1, L"Leaving CCertMgrComponent::AddMenuItems: 0x%x\n", hr);
	return hr;
}


STDMETHODIMP CCertMgrComponent::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::Command\n");
	HRESULT	hr = S_OK;

	switch (nCommandID)
	{
	case IDM_OPEN:
	case IDM_TASK_OPEN:
		hr = OnOpen (pDataObject);
		break;

	default:
		hr = QueryComponentDataRef ().Command (nCommandID, pDataObject);
		break;
	}
	_TRACE (-1, L"Leaving CCertMgrComponent::Command: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::OnNotifyDblClick (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyDblClick\n");
	HRESULT	hr = S_OK;
	ASSERT (pDataObject);

	CCertMgrCookie* pParentCookie =
			QueryComponentDataRef ().ConvertCookie (pDataObject);
	if ( pParentCookie )
	{
		switch ( pParentCookie->m_objecttype )
		{
			case CERTMGR_SNAPIN:
			case CERTMGR_USAGE:
			case CERTMGR_PHYS_STORE:
			case CERTMGR_LOG_STORE:
			case CERTMGR_LOG_STORE_GPE:
   			case CERTMGR_LOG_STORE_RSOP:
			case CERTMGR_CRL_CONTAINER:
			case CERTMGR_CTL_CONTAINER:
			case CERTMGR_CERT_CONTAINER:
			case CERTMGR_AUTO_CERT_REQUEST:
			case CERTMGR_CERT_POLICIES_USER:
			case CERTMGR_CERT_POLICIES_COMPUTER:
            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
            case CERTMGR_SAFER_COMPUTER_ENTRY:
            case CERTMGR_SAFER_USER_ENTRY:
            case CERTMGR_SAFER_USER_ROOT:
            case CERTMGR_SAFER_USER_ENTRIES:
            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_LEVELS:
            case CERTMGR_SAFER_COMPUTER_LEVELS:
            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
            case CERTMGR_SAFER_USER_ENFORCEMENT:
    			hr = S_FALSE;
				break;

			case CERTMGR_CERTIFICATE:
				{
					CCertificate*	pCert = reinterpret_cast <CCertificate*> (pParentCookie);
					ASSERT (pCert);
					if ( pCert )
						hr = LaunchCommonCertDialog (pCert);
					else
						hr = E_UNEXPECTED;
				}
				hr = S_OK;
				break;


			case CERTMGR_CTL:
				{
					CCTL*	pCTL = reinterpret_cast <CCTL*> (pParentCookie);
					ASSERT (pCTL);
					if ( pCTL )
						hr = LaunchCommonCTLDialog (pCTL);
					else
						hr = E_UNEXPECTED;
				}
				hr = S_OK;
				break;

			case CERTMGR_CRL:
				{
					CCRL*	pCRL = reinterpret_cast <CCRL*> (pParentCookie);
					ASSERT (pCRL);
					if ( pCRL )
						hr = LaunchCommonCRLDialog (pCRL);
					else
						hr = E_UNEXPECTED;
				}
				hr = S_OK;
				break;

			default:
				_TRACE (0, L"CCertMgrComponentData::EnumerateScopeChildren bad parent type\n");
				ASSERT (FALSE);
				hr = S_OK;
				break;
		}
	}
	else
		hr =  E_UNEXPECTED;


	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyDblClick: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::OnNotifySelect (LPDATAOBJECT pDataObject, BOOL fSelected)
{
	_TRACE (0, L"Entering CCertMgrComponent::OnNotifySelect - fSelected == %d.\n", fSelected);
     ASSERT (m_pConsoleVerb && 0xdddddddd != (UINT_PTR) m_pConsoleVerb);
	if ( !m_pConsoleVerb || 0xdddddddd == (UINT_PTR) m_pConsoleVerb )
		return E_FAIL;


	HRESULT	hr = S_OK;
	CCertMgrComponentData& compData = QueryComponentDataRef ();
	BOOL	bIsFileView = !(compData.m_szFileName.IsEmpty ());

	// Don't add menu items if this is a serialized file
    CertificateManagerObjectType objectType = compData.GetObjectType (pDataObject);
	switch (objectType)
	{
	case CERTMGR_SNAPIN:
		if ( fSelected )
		{
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		}
		m_currResultNodeType = CERTMGR_INVALID;
		break;

	case CERTMGR_USAGE:
		m_currResultNodeType = CERTMGR_CERTIFICATE;
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CUsageCookie* pUsage = reinterpret_cast <CUsageCookie*> (pCookie);
				ASSERT (pUsage);
				if ( pUsage )
				{
                    if ( m_pLastUsageCookie )
                        m_pLastUsageCookie->Release ();
                    m_pLastUsageCookie = pUsage;
                    m_pLastUsageCookie->AddRef ();
					hr = DisplayCertificateCountByUsage (pCookie->GetObjectName (),
							pUsage->GetCertCount ());
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		if ( fSelected )
		{
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		}
		break;

	case CERTMGR_PHYS_STORE:
	case CERTMGR_LOG_STORE:
		if ( fSelected )
        {
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        }
		else
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		if ( !bIsFileView )
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
				ASSERT (pStore);
				if ( pStore )
				{
					pStore->GetStoreHandle (); // to initialize read-only flag
					if ( pStore->IsReadOnly () ) //|| !fSelected)
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
					else
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                    if ( fSelected )
					    hr = DisplayCertificateCountByStore (m_pConsole, pStore);
					pStore->Close ();
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_INVALID;
		break;
	
	case CERTMGR_LOG_STORE_GPE:
	case CERTMGR_LOG_STORE_RSOP:
		if ( fSelected && CERTMGR_LOG_STORE_RSOP != QueryComponentDataRef ().GetObjectType (pDataObject) )
        {
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
            m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        }
		else
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		if ( !bIsFileView )
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
				ASSERT (pStore);
				if ( pStore )
				{
					hr = DisplayCertificateCountByStore (m_pConsole, pStore, true);

					switch (pStore->GetStoreType ())
					{
					case ROOT_STORE:
						if ( fSelected )
							m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
						else
							m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
						m_currResultNodeType = CERTMGR_CERTIFICATE;
						break;

					case EFS_STORE:
    				    if ( fSelected )
						    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
					    else
						    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
    					m_currResultNodeType = CERTMGR_CERTIFICATE;
						break;

					case TRUST_STORE:
                        if ( compData.m_bIsRSOP )
                        {
						    if ( fSelected )
							    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
						    else
							    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                        }
						m_currResultNodeType = CERTMGR_CTL;
						break;

					case ACRS_STORE:
                        if ( compData.m_bIsRSOP )
                        {
						    if ( fSelected )
							    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
						    else
							    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                        }
						m_currResultNodeType = CERTMGR_AUTO_CERT_REQUEST;
						break;

					default:
						ASSERT (0);
						m_currResultNodeType = CERTMGR_INVALID;
						break;
					}
					
					if ( pStore->IsReadOnly () ) //|| !fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
					else if ( ACRS_STORE != pStore->GetStoreType () )
					{
						// Do not allow cut and paste for ACRS store.
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
						if ( !fSelected &&
								CERTMGR_LOG_STORE_GPE != pStore->m_objecttype )
						{
							pStore->Commit ();
						}
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		break;
	
	case CERTMGR_CERTIFICATE:
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			ASSERT (pCookie);
			if ( pCookie )
			{
				CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
				ASSERT (pCert);
				if ( pCert )
				{
                    if ( fSelected )
                    {
					    if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
					    {
						    hr = DisplayCertificateCountByStore (
								    m_pConsole, pCert->GetCertStore ());
					    }
					    else
					    {
						    // Display by count in each purpose
                            ASSERT (m_pLastUsageCookie);
                            if ( m_pLastUsageCookie )
                            {
    					         hr = DisplayCertificateCountByUsage (
                                        m_pLastUsageCookie->GetObjectName (),
	    						        m_pLastUsageCookie->GetCertCount ());
                            }
					    }
                    }

					if ( fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
					else
						m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);
					if ( !bIsFileView )
					{
						if ( fSelected )
							m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
						else
							m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);

                        CCertStore* pCertStore = pCert->GetCertStore ();
                        if ( pCertStore )
                        {
						    if ( pCertStore->IsReadOnly () || !fSelected )
							    m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
						    else
						    {
							    if ( pCert->CanDelete () )
								    m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
							    else
								    m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);

							    if ( !fSelected &&
									    CERTMGR_LOG_STORE_GPE == pCertStore->m_objecttype )
							    {
								    pCertStore->Commit ();
							    }
						    }
                        }
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_CERTIFICATE;
		break;

	case CERTMGR_CRL_CONTAINER:
		if ( fSelected )
        {
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
            m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        }
		else
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		if ( !bIsFileView )
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CContainerCookie* pCont = reinterpret_cast <CContainerCookie*> (pCookie);
				ASSERT (pCont);
				if ( pCont )
				{
				    if ( pCont->GetCertStore ().IsReadOnly () ) //|| !fSelected )
					    m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
				    else
				    {
					    m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
					    if ( !fSelected )
						    pCont->GetCertStore ().Commit ();
                    }
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_CRL;
		break;

	case CERTMGR_CTL_CONTAINER:
		if ( fSelected )
        {
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
            m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        }
		else
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		if ( !bIsFileView )
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CContainerCookie* pCont = reinterpret_cast <CContainerCookie*> (pCookie);
				ASSERT (pCont);
				if ( pCont )
				{
					if ( pCont->GetCertStore ().IsReadOnly () ) //|| !fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
					else
					{
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
						if ( !fSelected )
							pCont->GetCertStore ().Commit ();
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_CTL;
		break;

	case CERTMGR_CERT_CONTAINER:
		if ( fSelected )
        {
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
            m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        }
		else
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		if ( !bIsFileView )
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CContainerCookie* pCont = reinterpret_cast <CContainerCookie*> (pCookie);
				ASSERT (pCont);
				if ( pCont )
				{
                    if ( fSelected )
					    hr = DisplayCertificateCountByStore (
						    	m_pConsole, &pCont->GetCertStore ());
					if ( pCont->GetCertStore ().IsReadOnly () ) //|| !fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
					else
					{
						m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
						if ( !fSelected )
							pCont->GetCertStore ().Commit ();
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_CERTIFICATE;
		break;

	case CERTMGR_CRL:
		if ( fSelected )
			m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
		else
			m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
				ASSERT (pCRL);
				if ( pCRL )
				{
					if ( pCRL->GetCertStore ().IsReadOnly () || !fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
					else
					{
						m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
						if ( !fSelected &&
								CERTMGR_LOG_STORE_GPE == pCRL->GetCertStore ().m_objecttype )
						{
							pCRL->GetCertStore ().Commit ();
						}
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_CRL;
		break;

	case CERTMGR_AUTO_CERT_REQUEST:
		if ( fSelected )
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
			m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
			m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
			m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);
		}

		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CAutoCertRequest* pAutoCert = reinterpret_cast <CAutoCertRequest*> (pCookie);
				ASSERT (pAutoCert);
				if ( pAutoCert )
				{
					if ( pAutoCert->GetCertStore ().IsReadOnly () || !fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
					else
					{
						m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
						if ( !fSelected &&
								CERTMGR_LOG_STORE_GPE == pAutoCert->GetCertStore ().m_objecttype )
						{
							pAutoCert->GetCertStore ().Commit ();
						}
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_AUTO_CERT_REQUEST;
		break;

	case CERTMGR_CTL:
		if ( !bIsFileView )
		{
			CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
				ASSERT (pCTL);
				if ( pCTL )
				{
					if ( pCTL->GetCertStore ().IsReadOnly () || !fSelected )
						m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
					else
					{
						m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
						if ( !fSelected &&
								CERTMGR_LOG_STORE_GPE == pCTL->GetCertStore ().m_objecttype )
						{
							pCTL->GetCertStore ().Commit ();
						}
					}

					// Don't allow auto cert requests to be copied. They can't be
					// pasted anywhere.
					if ( ACRS_STORE != pCTL->GetCertStore ().GetStoreType () )
						m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				hr = E_UNEXPECTED;
		}
		m_currResultNodeType = CERTMGR_CTL;
		break;

	case CERTMGR_CERT_POLICIES_COMPUTER:
	case CERTMGR_CERT_POLICIES_USER:
		m_currResultNodeType = CERTMGR_INVALID;
		if ( fSelected )
		{
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		}
		break;

	case CERTMGR_MULTISEL:
		{
			if ( fSelected )
				m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
			else
				m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);

			bool	bDeleteSet = false;


			CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pDataObject);
			ASSERT (pDO);
			if ( pDO )
			{
				// Is multiple select, get all selected items and delete - confirm
				// first deletion only.
				CCertMgrCookie*	pCookie = 0;
				pDO->Reset();
				while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
				{
					if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
					{
						CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
						ASSERT (pCert);
						if ( (pCert && !pCert->CanDelete ()) || !fSelected )
						{
							m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
							bDeleteSet = true;
							break;
						}
					}
					else
						break;
				}
			}

			if ( !bDeleteSet && fSelected )
				m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
		}
		m_currResultNodeType = CERTMGR_MULTISEL;
		break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
    case CERTMGR_SAFER_COMPUTER_LEVEL:
    case CERTMGR_SAFER_USER_LEVEL:
    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
    case CERTMGR_SAFER_USER_ENFORCEMENT:
		if ( fSelected )
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
			m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
		}
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRY:
    case CERTMGR_SAFER_USER_ENTRY:
		if ( fSelected )
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
			m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
		}
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
		if ( fSelected )
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
		}
		else
		{
			m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
		}
        break;

    case CERTMGR_SAFER_COMPUTER_LEVELS:
    case CERTMGR_SAFER_USER_LEVELS:
        if ( fSelected )
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
        break;

    case CERTMGR_SAFER_COMPUTER_ROOT:
    case CERTMGR_SAFER_USER_ROOT:
        if ( fSelected )
            m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
        {
            CString szStatusText;

            if ( !QueryComponentDataRef ().m_bSaferSupported )
		    {
                szStatusText.LoadString (IDS_SAFER_NOT_SUPPORTED);
            }
            IConsole2*	pConsole2 = 0;
            hr = m_pConsole->QueryInterface (
                    IID_PPV_ARG(IConsole2, &pConsole2));
            if (SUCCEEDED (hr))
            {
                hr = pConsole2->SetStatusText (const_cast <LPOLESTR>((PCWSTR) szStatusText));
                if ( !SUCCEEDED (hr) )
                {
                    _TRACE (0, L"IConsole::SetStatusText () failed: %x", hr);
                }
            pConsole2->Release ();
            }
        }
        break;

    default:
		m_currResultNodeType = CERTMGR_INVALID;
		hr = E_UNEXPECTED;
		break;
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifySelect: 0x%x\n", hr);
	return hr;
}

STDMETHODIMP CCertMgrComponent::CreatePropertyPages (
	LPPROPERTYSHEETCALLBACK pCallBack,
     LONG_PTR handle,		// This handle must be saved in the property page object to notify the parent when modified
	LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::CreatePropertyPages\n");
	HRESULT	hr = S_OK;

	hr = QueryComponentDataRef ().CreatePropertyPages (pCallBack, handle, pDataObject);
	_TRACE (-1, L"Leaving CCertMgrComponent::CreatePropertyPages: 0x%x\n", hr);
	return hr;
}

STDMETHODIMP CCertMgrComponent::QueryPagesFor (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::QueryPagesFor\n");
	HRESULT	hr = S_OK;
	hr = QueryComponentDataRef ().QueryPagesFor (pDataObject);
	_TRACE (-1, L"Leaving CCertMgrComponent::QueryPagesFor: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::OnNotifyRefresh (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyRefresh\n");
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT	hr = S_OK;

	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	if ( !pCookie )
		return E_UNEXPECTED;

	CCertMgrComponentData&	dataRef = QueryComponentDataRef ();
	
	switch (pCookie->m_objecttype)
	{
	case CERTMGR_CERT_POLICIES_USER:
	case CERTMGR_CERT_POLICIES_COMPUTER:
		if ( dataRef.m_bIsRSOP )
		{
			// Delete all the scope items and force a reexpansion
			
			hr = dataRef.DeleteScopeItems (pCookie->m_hScopeItem);

            hr = dataRef.BuildWMIList (0, 
                    CERTMGR_CERT_POLICIES_COMPUTER == pCookie->m_objecttype);
            if ( SUCCEEDED (hr) )
            {
    			GUID	guid;
	    		hr = dataRef.ExpandScopeNodes (
		    			pCookie, pCookie->m_hScopeItem,
			    		_T (""), 0, guid);
            }
		}
		break;

	case CERTMGR_SNAPIN:
		{
			// Close and release the usage stores if any.
			CloseAndReleaseUsageStores ();
			m_bUsageStoresEnumerated = false;

			// Delete all the scope items and force a reexpansion
			hr = dataRef.DeleteScopeItems ();

            if ( dataRef.m_bIsRSOP )
            {
                ASSERT (0);  // do we ever hit this?
                hr = dataRef.BuildWMIList (0, true);
            }

            if ( SUCCEEDED (hr) )
            {
    			GUID	guid;
	    		hr = dataRef.ExpandScopeNodes (
		    			dataRef.m_pRootCookie, dataRef.m_hRootScopeItem,
			    		_T (""), 0, guid);
            }
		}
		break;

	case CERTMGR_PHYS_STORE:
	case CERTMGR_LOG_STORE:
		{
			CCertStore*	pCertStore = reinterpret_cast <CCertStore*> (pCookie);
			ASSERT (pCertStore);
			if ( pCertStore )
				pCertStore->Resync ();

			HSCOPEITEM	hScopeItem = pCookie->m_hScopeItem;
			ASSERT (hScopeItem);
			if ( hScopeItem )
			{
				hr = dataRef.DeleteChildren (hScopeItem);
				GUID	guid;
				hr = dataRef.ExpandScopeNodes (
						pCookie, hScopeItem, _T (""), 0, guid);
				if ( SUCCEEDED (hr) )
				{
					hr = RefreshResultPane ();
					ASSERT (SUCCEEDED (hr));
				}
			}
		}
		break;

	case CERTMGR_CRL_CONTAINER:
	case CERTMGR_CTL_CONTAINER:
	case CERTMGR_CERT_CONTAINER:
		{
			CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
			ASSERT (pContainer);
			if ( pContainer )
			{
				pContainer->GetCertStore ().Resync ();
			}
		}
		hr = RefreshResultPane ();
		ASSERT (SUCCEEDED (hr));
		break;


	case CERTMGR_LOG_STORE_GPE:
		{
			CCertStore*	pCertStore = reinterpret_cast <CCertStore*> (pCookie);
			ASSERT (pCertStore);
			if ( pCertStore )
				pCertStore->Resync ();
		}
		hr = RefreshResultPane ();
		ASSERT (SUCCEEDED (hr));
		break;

	case CERTMGR_LOG_STORE_RSOP:
        // must be refreshed at root node
        ASSERT (0);
        break;

	case CERTMGR_USAGE:
		// Close all the stores.  This will force them to be
		// re-enumerated later.
		CloseAndReleaseUsageStores ();
		m_bUsageStoresEnumerated = false;
		hr = RefreshResultPane ();
		ASSERT (SUCCEEDED (hr));
		break;


	case CERTMGR_AUTO_CERT_REQUEST:
		hr = RefreshResultPane ();
		ASSERT (SUCCEEDED (hr));
		break;

	case CERTMGR_CERTIFICATE:
		{
			CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
			ASSERT (pCert);
			if ( pCert )
			{
                CCertStore* pStore = pCert->GetCertStore ();
                if ( pStore )
				    pStore->Resync ();
			}
		}
		hr = RefreshResultItem (pCookie);
		ASSERT (SUCCEEDED (hr));
		break;

	case CERTMGR_CTL:
		{
			CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
			ASSERT (pCTL);
			if ( pCTL )
			{
				pCTL->GetCertStore ().Resync ();
			}
		}
		hr = RefreshResultItem (pCookie);
		ASSERT (SUCCEEDED (hr));
		break;

	case CERTMGR_CRL:
		{
			CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
			ASSERT (pCRL);
			if ( pCRL )
			{
				pCRL->GetCertStore ().Resync ();
			}
		}
		hr = RefreshResultItem (pCookie);
		ASSERT (SUCCEEDED (hr));
		break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        ASSERT (0);
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
        {
            bool    bAllowRefresh = true;

            RESULTDATAITEM  rdItem;
            ::ZeroMemory (&rdItem, sizeof (RESULTDATAITEM));
            rdItem.nIndex = -1;
            rdItem.mask = RDI_STATE | RDI_PARAM | RDI_INDEX;
            do
            {
                hr = m_pResultData->GetNextItem (&rdItem);
                if ( SUCCEEDED (hr) )
                {
                    CCertMgrCookie* pCurrCookie = (CCertMgrCookie*) rdItem.lParam;
                    if ( pCurrCookie )
                    {
                        if ( pCurrCookie->HasOpenPropertyPages () )
                        {
		                    CString text;
		                    CString	caption;

		                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		                    VERIFY (text.LoadString (IDS_CANT_REFRESH_PAGES_OPEN));
		                    int		iRetVal = 0;
		                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
				                    MB_OK, &iRetVal)));
                            bAllowRefresh = false;
                            break;
                        }
                    }
                }
            } while ( SUCCEEDED (hr) && -1 != rdItem.nIndex );


            if ( !bAllowRefresh )
                break;
        }

		hr = RefreshResultPane ();
		ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRY:
    case CERTMGR_SAFER_USER_ENTRY:
		hr = RefreshResultPane ();
		ASSERT (SUCCEEDED (hr));
        break;

	default:
		ASSERT (0);
		hr = E_UNEXPECTED;
		break;
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyRefresh: 0x%x\n", hr);
	return hr;
}

void CCertMgrComponent::SetTextNotAvailable ()
{
	_TRACE (1, L"Entering CCertMgrComponent::SetTextNotAvailable\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	m_szDisplayInfoResult.LoadString (IDS_NOT_AVAILABLE);
	_TRACE (-1, L"Leaving CCertMgrComponent::SetTextNotAvailable\n");
}


HRESULT	CCertMgrComponent::DeleteCookie (
        CCertMgrCookie* pCookie, 
        LPDATAOBJECT pDataObject, 
        bool bRequestConfirmation, 
        bool bIsMultipleSelect, 
        bool bDoCommit)
{
	_TRACE (1, L"Entering CCertMgrComponent::DeleteCookie\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;
	CString	text;
	CString	caption;
	int		iRetVal = IDYES;

	switch (pCookie->m_objecttype)
	{
	case CERTMGR_CERTIFICATE:
		{
			CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
			ASSERT (pCert);
			if ( pCert )
			{
				if ( bRequestConfirmation )
				{
					switch ( pCert->GetStoreType () )
					{
					case ROOT_STORE:
						if ( bIsMultipleSelect )
						{
							if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
							else
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_ROOT_MULTI_CERT));
						}
						else
							VERIFY (text.LoadString (IDS_CONFIRM_DELETE_ROOT_CERT));
						break;

					case CA_STORE:
						if ( bIsMultipleSelect )
						{
							if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
							else
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CA_MULTI_CERT));
						}
						else
							VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CA_CERT));
						break;

					case MY_STORE:
						if ( bIsMultipleSelect )
						{
							if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
							else
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MY_MULTI_CERT));
						}
						else
							VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MY_CERT));
						break;

					default:
						if ( bIsMultipleSelect )
						{
							if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
							else
								VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULTI));
						}
						else
							VERIFY (text.LoadString (IDS_CONFIRM_DELETE));
						break;
					}
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
					ASSERT (SUCCEEDED (hr));
				}

				if ( IDYES == iRetVal )
				{
                    CWaitCursor waitCursor;
					pCert->GetCertStore (); // to initialize handle

					hr = DeleteCertFromResultPane (pCert, pDataObject, bDoCommit);
				}
				else
					hr = E_FAIL;
			}
		}
		break;

	case CERTMGR_CRL:
		{
			CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
			ASSERT (pCRL);
			if ( pCRL )
			{
				if ( m_pPastedDO != pDataObject )
				{
					VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CRL));
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
					ASSERT (SUCCEEDED (hr));
				}

				if ( IDYES == iRetVal )
				{
                          CWaitCursor waitCursor;
					hr = DeleteCRLFromResultPane (pCRL, pDataObject);
					if ( SUCCEEDED (hr) )
						pCRL->GetCertStore ().Commit ();
				}
				else
					hr = E_FAIL;
			}
		}
		break;

	case CERTMGR_CTL:
		{
			CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
			ASSERT (pCTL);
			if ( pCTL )
			{
				if ( bRequestConfirmation )
				{
					VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CTL));
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
					ASSERT (SUCCEEDED (hr));
				}

				if ( IDYES == iRetVal )
				{
                          CWaitCursor waitCursor;
					hr = QueryComponentDataRef ().DeleteCTLFromResultPane (pCTL,
							pDataObject);
					if ( SUCCEEDED (hr) )
					{
						pCTL->GetCertStore ().Commit ();
					}
				}
				else
					hr = E_FAIL;
			}
		}
		break;

	case CERTMGR_AUTO_CERT_REQUEST:
		{
			CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pCookie);
			ASSERT (pACR);
			if ( pACR )
			{
				if ( bRequestConfirmation )
				{
					VERIFY (text.LoadString (IDS_CONFIRM_DELETE_ACR));
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
					ASSERT (SUCCEEDED (hr));
				}

				if ( IDYES == iRetVal )
				{
					hr = QueryComponentDataRef ().DeleteCTLFromResultPane (pACR,
							pDataObject);
					if ( SUCCEEDED (hr) )
					{
						pACR->GetCertStore ().Commit ();
					}
				}
				else
					hr = E_FAIL;
			}
		}
		break;

    case CERTMGR_SAFER_COMPUTER_ENTRY:
    case CERTMGR_SAFER_USER_ENTRY:
		{
			CSaferEntry* pSaferEntry = reinterpret_cast <CSaferEntry*> (pCookie);
			ASSERT (pSaferEntry);
			if ( pSaferEntry )
			{
				if ( bRequestConfirmation )
				{
					if ( bIsMultipleSelect )
						VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULTI_SAFER_ENTRY));
					else
						VERIFY (text.LoadString (IDS_CONFIRM_DELETE_SAFER_ENTRY));

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
					hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
					ASSERT (SUCCEEDED (hr));
				}

				if ( IDYES == iRetVal )
				{
                    CWaitCursor waitCursor;

					hr = DeleteSaferEntryFromResultPane (pSaferEntry, pDataObject, bDoCommit);
				}
				else
					hr = E_FAIL;
			}
		}
        break;

	default:
		ASSERT (0);
		hr = E_UNEXPECTED;
		break;
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::DeleteCookie: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::OnNotifyDelete (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyDelete\n");
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	CCertMgrCookie* pCookie =
			QueryComponentDataRef ().ConvertCookie (pDataObject);
	if ( pCookie )
	{
        CWaitCursor waitCursor;
		if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
		{

			// Is multiple select, get all selected items and paste each one
			CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pDataObject);
			ASSERT (pDO);
			if ( pDO )
			{
				// Is multiple select, get all selected items and delete - confirm
				// first deletion only.  Don't commit until all are deleted.
				bool	    bRequestConfirmation = true;

                CCertStore* pCertStore = 0;
                // NTRAID# 129428	Cert UI: Cert snapin: Deleting large 
                // number of certificates from the stores takes over 3 minutes
                // Change this to false to do commit only at end.
                bool        bDoCommit = false;

				pDO->Reset();
				while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE &&
						SUCCEEDED (hr) )
				{
                    if ( pCookie->HasOpenPropertyPages () )
                    {
		                CString text;
		                CString	caption;

		                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		                text.FormatMessage (IDS_CANT_DELETE_OBJECT_PAGES_OPEN, 
				                pCookie->GetObjectName ()); 
		                int		iRetVal = 0;
		                VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
				                MB_OK, &iRetVal)));
                        hr = E_FAIL;
                        break;
                    }
                }

                if ( SUCCEEDED (hr) )
                {
                    // If this is the store view, don't commit with each delete but commit
                    // all at once at the end.
				    pDO->Reset();
				    while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE &&
						    SUCCEEDED (hr) )
				    {
                        if ( bRequestConfirmation ) // first time through
                        {
                            if ( CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ||
                                    CERTMGR_SAFER_USER_ENTRY == pCookie->m_objecttype )
                            {
                            }
                            // Get the affected store.  The store is the same for all the
                            // certs in the list if the view mode is by store
                            else if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                            {
                                bDoCommit = false;
                                switch (pCookie->m_objecttype)
                                {
                                case CERTMGR_CERTIFICATE:
                                    {
                                        CCertificate* pCert = dynamic_cast<CCertificate*> (pCookie);
                                        if ( pCert )
                                        {
                                            pCertStore = pCert->GetCertStore ();
                                        }
                                    }
                                    break;

                                case CERTMGR_CRL:
                                    {
                                        CCRL* pCRL = dynamic_cast<CCRL*> (pCookie);
                                        if ( pCRL )
                                            pCertStore = &(pCRL->GetCertStore ());
                                    }
                                    break;

                                case CERTMGR_CTL:
                                    {
                                        CCTL* pCTL = dynamic_cast<CCTL*> (pCookie);
                                        if ( pCTL )
                                            pCertStore = &(pCTL->GetCertStore ());
                                    }
                                    break;

                                case CERTMGR_AUTO_CERT_REQUEST:
                                    {
                                        CAutoCertRequest* pAutoCertReq = dynamic_cast <CAutoCertRequest*> (pCookie);
                                        if ( pAutoCertReq )
                                            pCertStore = &(pAutoCertReq->GetCertStore ());
                                    }
                                    break;

                                default:
                                    ASSERT (0);
                                    break;
                                }
                            }
                        }

    					hr = DeleteCookie (pCookie, pDataObject, bRequestConfirmation, true, bDoCommit);
	    				bRequestConfirmation = false;
				    }


                    if ( pCertStore )
                    {
    			        hr = pCertStore->Commit ();
    			        if ( SUCCEEDED (hr) )
    				        pCertStore->Resync ();
                    }
                    else if ( QueryComponentDataRef ().m_pGPEInformation && 
                        (CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ||
                        CERTMGR_SAFER_USER_ENTRY == pCookie->m_objecttype ) )
                    {
                        hr = QueryComponentDataRef ().m_pGPEInformation->PolicyChanged (
                                CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ? TRUE : FALSE,
                                FALSE, &g_guidExtension, &g_guidSnapin);
                        hr = QueryComponentDataRef ().m_pGPEInformation->PolicyChanged (
                                CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ? TRUE : FALSE,
                                FALSE, &g_guidRegExt, &g_guidSnapin);
                    }
                }
			}
		}
		else
		{
            if ( pCookie->HasOpenPropertyPages () )
            {
		        CString text;
		        CString	caption;

		        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		        text.FormatMessage (IDS_CANT_DELETE_OBJECT_PAGES_OPEN, 
				        pCookie->GetObjectName ()); 
		        int		iRetVal = 0;
		        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
				        MB_OK, &iRetVal)));
                hr = E_FAIL;
            }
            else
            {
			    // If m_pPastedDO == pDataObject then this delete is the
			    // result of a paste.
			    // In that event, we don't want a confirmation message.
			    hr = DeleteCookie (pCookie, pDataObject, m_pPastedDO != pDataObject, false, true);
            }
		}
	}

	if ( m_pPastedDO == pDataObject )
		m_pPastedDO = 0;

//    if ( SUCCEEDED (hr) )
//	    hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);

    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyDelete: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::DeleteCertFromResultPane (
        CCertificate * pCert, 
        LPDATAOBJECT pDataObject, 
        bool bDoCommit)
{
	_TRACE (1, L"Entering CCertMgrComponent::DeleteCertFromResultPane\n");
	HRESULT			hr = S_OK;
	if ( pCert->DeleteFromStore (bDoCommit) )
	{
        if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist && m_pLastUsageCookie )
        {
            m_pLastUsageCookie->SetCertCount (m_pLastUsageCookie->GetCertCount () - 1);
        }
		HRESULTITEM	itemID;
		hr = m_pResultData->FindItemByLParam ( (LPARAM) pCert, &itemID);
		if ( SUCCEEDED (hr) )
		{
			hr = m_pResultData->DeleteItem (itemID, 0);
		}

		// If we can't succeed in removing this one item, then update the whole panel.
		if ( !SUCCEEDED (hr) )
		{
			hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
		}
	}
	else
	{
		DWORD	dwErr = GetLastError ();
		CString text;
		CString	caption;
        CCertStore* pStore = pCert->GetCertStore ();

        if ( pStore )
        {
		    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		    text.FormatMessage (IDS_CANT_DELETE_CERT_FROM_SYSTEM_STORE, 
				    pStore->GetLocalizedName (), 
				    GetSystemMessage (dwErr));
		    int		iRetVal = 0;
		    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
				    MB_OK, &iRetVal)));
        }
		hr = HRESULT_FROM_WIN32 (dwErr);
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::DeleteCertFromResultPane: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::DeleteCRLFromResultPane (CCRL * pCRL, LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::DeleteCRLFromResultPane\n");
	HRESULT			hr = S_OK;
	if ( pCRL->DeleteFromStore () )
	{
		hr = pCRL->GetCertStore ().Commit ();
		ASSERT (SUCCEEDED (hr));
		if ( SUCCEEDED (hr) )
		{
			HRESULTITEM	itemID;
			hr = m_pResultData->FindItemByLParam ( (LPARAM) pCRL, &itemID);
			if ( SUCCEEDED (hr) )
			{
				hr = m_pResultData->DeleteItem (itemID, 0);
			}
            else
            {
                _TRACE (0, L"IResultData::FindItemByLParam () failed: 0x%x (%s)\n",
                        hr, (PCWSTR) GetSystemMessage (hr));
            }

			// If we can't succeed in removing this one item, then update the whole panel.
			if ( !SUCCEEDED (hr) )
			{
				hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
			}
		}
	}
	else
	{
		DisplayAccessDenied ();
	}
	_TRACE (-1, L"Leaving CCertMgrComponent::DeleteCRLFromResultPane: 0x%x\n", hr);
	return hr;
}

typedef struct _ENUM_ARG {
     DWORD					dwFlags;
	CCertMgrComponent*		m_pComp;
	LPCWSTR					m_pcszMachineName;
	LPCONSOLE				m_pConsole;
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumIComponentSysCallback (
     IN const void* pwszSystemStore,
     IN DWORD dwFlags,
     IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
     IN OPTIONAL void* /*pvReserved*/,
     IN OPTIONAL void* pvArg
     )
{
	_TRACE (1, L"Entering EnumIComponentSysCallback\n");
     PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;

	// Create new cookies
	SPECIAL_STORE_TYPE	storeType = GetSpecialStoreType ((LPWSTR) pwszSystemStore);

	if ( pEnumArg->m_pComp->QueryComponentDataRef ().ShowArchivedCerts () )
		dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;

	//
	// We will not expose the ACRS store for machines or users.  It is not
	// interesting or useful at this level.  All Auto Cert Requests should
	// be managed only at the policy level.
	//
	if ( ACRS_STORE != storeType )
	{
		CCertStore* pNewCookie = new CCertStore (
				CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				dwFlags,
				pEnumArg->m_pcszMachineName,
				(LPCWSTR) pwszSystemStore,
				(LPCWSTR) pwszSystemStore,
				_T (""),
				storeType,
				dwFlags,
				pEnumArg->m_pConsole);
		if ( pNewCookie )
			pEnumArg->m_pComp->m_usageStoreList.AddTail (pNewCookie);
	}

	_TRACE (-1, L"Leaving EnumIComponentSysCallback\n");
     return TRUE;
}



HRESULT CCertMgrComponent::EnumerateLogicalStores (CCertMgrCookie& parentCookie)
{
	_TRACE (1, L"Entering CCertMgrComponent::EnumerateLogicalStores\n");
	CWaitCursor				cursor;
	HRESULT					hr = S_OK;
     ENUM_ARG				enumArg;
	CCertMgrComponentData&	compData = QueryComponentDataRef ();
     DWORD					dwFlags = compData.GetLocation ();

      ::ZeroMemory (&enumArg, sizeof (enumArg));
     enumArg.dwFlags = dwFlags;
	enumArg.m_pComp = this;
	enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
	enumArg.m_pConsole = m_pConsole;
	CString	location;
	void*	pvPara = 0;

    // empty out the store list first
	CCertStore*	pCertStore = 0;
	while (!m_usageStoreList.IsEmpty () )
	{
		pCertStore = m_usageStoreList.RemoveHead ();
		ASSERT (pCertStore);
		if ( pCertStore )
        {
            pCertStore->SetDirty ();
            pCertStore->Commit ();
            pCertStore->Release ();
        }
	}

	if ( !compData.GetManagedService ().IsEmpty () )
	{
		if ( !compData.GetManagedComputer ().IsEmpty () )
		{
			location = compData.GetManagedComputer () + _T("\\") +
					compData.GetManagedComputer ();
			pvPara = (void *) (LPCWSTR) location;
		}
		else
			pvPara = (void *) (LPCWSTR) compData.GetManagedService ();
	}
	else if ( !compData.GetManagedComputer ().IsEmpty () )
	{
		pvPara = (void *) (LPCWSTR) compData.GetManagedComputer ();
	}

	CString	fileName = compData.GetCommandLineFileName ();
	if ( fileName.IsEmpty () )
	{
		// Ensure creation of MY store
		HCERTSTORE hTempStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
				dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
				MY_SYSTEM_STORE_NAME);
		if ( hTempStore )  // otherwise, store is read only
		{
			VERIFY (::CertCloseStore (hTempStore, CERT_CLOSE_STORE_CHECK_FLAG));
		}
		else
		{
			_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
					MY_SYSTEM_STORE_NAME, GetLastError ());		
		}

		if ( !::CertEnumSystemStore (dwFlags, pvPara, &enumArg,
				EnumIComponentSysCallback) )
		{
			DWORD	dwErr = GetLastError ();
			CString text;
			CString	caption;

			VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			if ( ERROR_ACCESS_DENIED == dwErr )
			{
				VERIFY (text.LoadString (IDS_NO_PERMISSION));

			}
			else
			{
				text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
			}
			int		iRetVal = 0;
			VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
					MB_OK, &iRetVal)));
			hr = HRESULT_FROM_WIN32 (dwErr);
		}
	}
	else
	{
		// Create new cookies

		CCertStore* pNewCookie = new CCertStore (
				CERTMGR_LOG_STORE,
				CERT_STORE_PROV_FILENAME_W,
				0, //dwFlags,
				parentCookie.QueryNonNULLMachineName (),
				fileName, fileName, _T (""), NO_SPECIAL_TYPE,
				QueryComponentDataRef ().GetLocation (),
				m_pConsole);
		if ( pNewCookie )
			m_usageStoreList.AddTail (pNewCookie);
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::EnumerateLogicalStores: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::EnumCertsByUsage (CUsageCookie * pUsageCookie)
{
	_TRACE (1, L"Entering CCertMgrComponent::EnumCertsByUsage\n");
	ASSERT (pUsageCookie);
	if ( !pUsageCookie )
		return E_POINTER;
	CCertMgrComponentData&	compData = QueryComponentDataRef ();

	HRESULT hr = m_pResultData->DeleteAllRsltItems ();
	if ( SUCCEEDED (hr) )
	{
		compData.RemoveResultCookies (m_pResultData);
	}

	if ( m_bShowArchivedCertsStateWhenLogStoresEnumerated !=
			compData.ShowArchivedCerts () )
	{
		m_bShowArchivedCertsStateWhenLogStoresEnumerated =
				compData.ShowArchivedCerts ();
		m_bUsageStoresEnumerated = false;
		CloseAndReleaseUsageStores ();
	}
	// Enumerate system stores, if not already done
	if ( !m_bUsageStoresEnumerated && pUsageCookie )
	{
		hr = EnumerateLogicalStores (*pUsageCookie);
		m_bUsageStoresEnumerated = true;
	}


	// Iterate through stores and find certs for given Oid.
	CCertStore*	pCertStore = 0;
	CCookie&	rootCookie = compData.QueryBaseRootCookie ();
	int			nCertCount = 0;

	for (POSITION pos = m_usageStoreList.GetHeadPosition (); pos; )
	{
		pCertStore = m_usageStoreList.GetNext (pos);
		ASSERT (pCertStore);
		if ( pCertStore )
		{
			int		nOIDCount = pUsageCookie->GetOIDCount ();
			ASSERT (nOIDCount > 0);
			if ( nOIDCount <= 0 )
				continue;

			CERT_ENHKEY_USAGE	enhKeyUsage;
			enhKeyUsage.cUsageIdentifier = nOIDCount;
			enhKeyUsage.rgpszUsageIdentifier = new LPSTR [nOIDCount];
			if ( enhKeyUsage.rgpszUsageIdentifier )
			{
				for (int nIndex = 0; nIndex < nOIDCount; nIndex++)
				{
					enhKeyUsage.rgpszUsageIdentifier[nIndex] =
							 (!nIndex) ?
							pUsageCookie->GetFirstOID () :
							pUsageCookie->GetNextOID ();
				}

				PCCERT_CONTEXT	pPrevCertContext = 0;
				PCCERT_CONTEXT	pCertContext = 0;
				CCertificate*	pCert = 0;
				DWORD			dwErr = 0;
				RESULTDATAITEM	rdItem;
				void*			pvPara = (void *) &enhKeyUsage;

				::ZeroMemory (&rdItem, sizeof (rdItem));
				rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
				rdItem.nImage = iIconCertificate;
				rdItem.nCol = 0;

				bool	bDone = false;
				while ( !bDone )
				{
					pCertContext = pCertStore->FindCertificate (
							CERT_FIND_VALID_ENHKEY_USAGE_FLAG |
								CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG, // | CERT_FIND_OR_ENHKEY_USAGE_FLAG ,
							CERT_FIND_ENHKEY_USAGE,
							pvPara,
 							pPrevCertContext);
					if ( !pCertContext )
					{
						dwErr = GetLastError ();
						switch (dwErr)
						{
						case CRYPT_E_NOT_FOUND:	// We're done.  No more certificates.
							break;

						case 0:		// no error to display
							break;

                        case E_INVALIDARG:
                            if ( !pCertStore->GetStoreHandle () )
                            {
					            CString	text;
					            CString caption;
					            int		iRetVal = IDNO;

					            text.FormatMessage 
                                        (IDS_CANNOT_OPEN_CERT_STORE_TO_FIND_CERT_BY_PURPOSE,
                                        pCertStore->GetLocalizedName ());
					            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					            hr = m_pConsole->MessageBox (text, caption,
							            MB_ICONWARNING | MB_OK, &iRetVal);
                                break;
                            }
                            // fall through

						default:
							compData.DisplaySystemError (dwErr);
							break;
						}
						bDone = true;
						continue;
					}
					pCert =
						new CCertificate (pCertContext, pCertStore);

					if ( !pCert )
					{
						// Do this twice.  Must reduce ref count by 2
						::CertFreeCertificateContext (pCertContext);
						::CertFreeCertificateContext (pCertContext);
						hr = E_OUTOFMEMORY;
						break;
					}
					nCertCount++;

					rootCookie.m_listResultCookieBlocks.AddHead (pCert);
					rdItem.str = MMC_CALLBACK;
					rdItem.lParam = (LPARAM) pCert;
					pCert->m_resultDataID = m_pResultData;
					hr = m_pResultData->InsertItem (&rdItem);
					ASSERT (SUCCEEDED (hr));


					pPrevCertContext = pCertContext;
				}
				pCertStore->Close ();
				delete [] enhKeyUsage.rgpszUsageIdentifier;
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}
	}

	pUsageCookie->SetCertCount (nCertCount);
    hr = DisplayCertificateCountByUsage (
            pUsageCookie->GetObjectName (),
            pUsageCookie->GetCertCount ());
	_TRACE (-1, L"Leaving CCertMgrComponent::EnumCertsByUsage: 0x%x\n", hr);
	return hr;
}


// This compare is used to sort the items in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort () was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//             -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing.

STDMETHODIMP CCertMgrComponent::Compare (
        LPARAM /*lUserParam*/, 
        MMC_COOKIE cookieA, 
        MMC_COOKIE cookieB, 
        int* pnResult)
{
	HRESULT					hr = S_OK;

    if ( pnResult && cookieA && cookieB )
	{
		int	     colNum = *pnResult;

        if ( CERTMGR_MULTISEL == m_currResultNodeType )
        {
			CCertMgrCookie*	pCookie = reinterpret_cast<CCertMgrCookie*> (cookieA);
            if ( pCookie )
            {
                switch (pCookie->m_objecttype)
                {
                case CERTMGR_CERTIFICATE:
                    m_currResultNodeType = CERTMGR_CERTIFICATE;
                    break;

                case CERTMGR_CTL:
                    m_currResultNodeType = CERTMGR_CTL;
                    break;

                case CERTMGR_CRL: 
                    m_currResultNodeType = CERTMGR_CRL;
                    break;

                default:
                    break;
                }
			}
        }

		CCertMgrCookie* pCookieA = reinterpret_cast <CCertificate*> (cookieA);
		CCertMgrCookie* pCookieB = reinterpret_cast <CCertificate*> (cookieB);

		switch (m_currResultNodeType)
		{
		case CERTMGR_CERTIFICATE:
			{
                ASSERT (CERTMGR_CERTIFICATE == pCookieA->m_objecttype &&
                    CERTMGR_CERTIFICATE == pCookieB->m_objecttype);
                if ( CERTMGR_CERTIFICATE == pCookieA->m_objecttype &&
                    CERTMGR_CERTIFICATE == pCookieB->m_objecttype )
                {
                    m_nSelectedCertColumn = colNum;
				    CCertificate* pCertA = reinterpret_cast <CCertificate*> (cookieA);
				    CCertificate* pCertB = reinterpret_cast <CCertificate*> (cookieB);
				    switch ( colNum )
				    {
				    case COLNUM_CERT_SUBJECT:
                        *pnResult = LocaleStrCmp (pCertA->GetSubjectName (),
                                pCertB->GetSubjectName ());
					    break;

				    case COLNUM_CERT_ISSUER:
					    *pnResult = LocaleStrCmp (pCertA->GetIssuerName (),
                                pCertB->GetIssuerName ());
					    break;

				    case COLNUM_CERT_EXPIRATION_DATE:
					    *pnResult = pCertA->CompareExpireDate (*pCertB);
					    break;

				    case COLNUM_CERT_PURPOSE:
					    *pnResult = LocaleStrCmp (pCertA->GetEnhancedKeyUsage (),
                                         pCertB->GetEnhancedKeyUsage ());
					    break;

				    case COLNUM_CERT_CERT_NAME:
					    *pnResult = LocaleStrCmp (pCertA->GetFriendlyName (),
                                         pCertB->GetFriendlyName ());
					    break;

                    case COLNUM_CERT_STATUS:
                        *pnResult = LocaleStrCmp (pCertA->FormatStatus (), 
                                pCertB->FormatStatus ());
                        break;

                    // NTRAID# 247237	Cert UI: Cert Snapin: Certificates snapin should show  template name
                    case COLNUM_CERT_TEMPLATE:
                        *pnResult = LocaleStrCmp (pCertA->GetTemplateName (), 
                                pCertB->GetTemplateName ());
                        break;

				    default:
					    ASSERT (0);
					    break;
				    }
                }
			}
			break;

		case CERTMGR_CRL:
			{
                ASSERT (CERTMGR_CRL == pCookieA->m_objecttype &&
                    CERTMGR_CRL == pCookieB->m_objecttype);
                if ( CERTMGR_CRL == pCookieA->m_objecttype &&
                    CERTMGR_CRL == pCookieB->m_objecttype )
                {
                    m_nSelectedCRLColumn = colNum;
				    CCRL* pCRLA = reinterpret_cast <CCRL*> (cookieA);
				    CCRL* pCRLB = reinterpret_cast <CCRL*> (cookieB);
				    switch ( colNum )
				    {
				    case COLNUM_CRL_EFFECTIVE_DATE:
					    *pnResult = pCRLA->CompareEffectiveDate (*pCRLB);
					    break;

				    case COLNUM_CRL_ISSUER:
					    *pnResult = LocaleStrCmp (pCRLA->GetIssuerName (),
                                         pCRLB->GetIssuerName ());
					    break;

				    case COLNUM_CRL_NEXT_UPDATE:
					    *pnResult = pCRLA->CompareNextUpdate (*pCRLB);
					    break;

				    default:
					    ASSERT (0);
					    break;
				    }
                }
			}
			break;

		case CERTMGR_CTL:
			{
                ASSERT (CERTMGR_CTL == pCookieA->m_objecttype &&
                    CERTMGR_CTL == pCookieB->m_objecttype);
                if ( CERTMGR_CTL == pCookieA->m_objecttype &&
                    CERTMGR_CTL == pCookieB->m_objecttype )
                {
                    m_nSelectedCTLColumn = colNum;
				    CCTL* pCTLA = reinterpret_cast <CCTL*> (cookieA);
				    CCTL* pCTLB = reinterpret_cast <CCTL*> (cookieB);
				    switch ( colNum )
				    {
				    case COLNUM_CTL_ISSUER:
					    *pnResult = LocaleStrCmp (pCTLA->GetIssuerName (),
                                         pCTLB->GetIssuerName ());
					    break;

				    case COLNUM_CTL_EFFECTIVE_DATE:
					    *pnResult = pCTLA->CompareEffectiveDate (*pCTLB);
					    break;

				    case COLNUM_CTL_PURPOSE:
					    *pnResult = LocaleStrCmp (pCTLA->GetPurpose (),
                                         pCTLB->GetPurpose ());
					    break;

				    case COLNUM_CTL_FRIENDLY_NAME:
				    default:
					    ASSERT (0);
					    break;
				    }
                }
			}
			break;

		case CERTMGR_AUTO_CERT_REQUEST:
			{
                ASSERT (CERTMGR_AUTO_CERT_REQUEST == pCookieA->m_objecttype &&
                    CERTMGR_AUTO_CERT_REQUEST == pCookieB->m_objecttype);
                if ( CERTMGR_AUTO_CERT_REQUEST == pCookieA->m_objecttype &&
                    CERTMGR_AUTO_CERT_REQUEST == pCookieB->m_objecttype )
                {
				    CAutoCertRequest* pAutoCertA = reinterpret_cast <CAutoCertRequest*> (cookieA);
				    CAutoCertRequest* pAutoCertB = reinterpret_cast <CAutoCertRequest*> (cookieB);
				    switch ( colNum )
				    {
				    case 0:
					    {
                            CString strA;
                            CString strB;

						    VERIFY (SUCCEEDED (pAutoCertA->GetCertTypeName (strA)));
						    VERIFY (SUCCEEDED (pAutoCertB->GetCertTypeName (strB)));
                                    *pnResult = LocaleStrCmp (strA, strB);
					    }
					    break;

				    default:
					    ASSERT (0);
					    break;
				    }
                }
			}

        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            {
                CSaferEntry* pSaferEntryA = reinterpret_cast <CSaferEntry*> (cookieA);
                CSaferEntry* pSaferEntryB = reinterpret_cast <CSaferEntry*> (cookieB);
                m_nSelectedSaferEntryColumn = colNum;
                switch (colNum)
                {
                case COLNUM_SAFER_ENTRIES_NAME:
                    *pnResult = LocaleStrCmp (pSaferEntryA->GetObjectName (),
                            pSaferEntryB->GetObjectName ());
                    break;

                case COLNUM_SAFER_ENTRIES_TYPE:
                    *pnResult = LocaleStrCmp (pSaferEntryA->GetTypeString (),
                            pSaferEntryB->GetTypeString ());
                    break;

                case COLNUM_SAFER_ENTRIES_LEVEL:
                    *pnResult = LocaleStrCmp (pSaferEntryA->GetLevelFriendlyName (),
                            pSaferEntryB->GetLevelFriendlyName ());
                    break;

                case COLNUM_SAFER_ENTRIES_DESCRIPTION:
                    *pnResult = LocaleStrCmp (pSaferEntryA->GetDescription (),
                            pSaferEntryB->GetDescription ());
                    break;

                case COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE:
                    *pnResult = pSaferEntryA->CompareLastModified (*pSaferEntryB);
                    break;
               }
            }
            break;

		default:
			break;
		}
	}
	
	return hr;
}


HRESULT CCertMgrComponent::EnumCTLs (CCertStore& rCertStore)
{
	_TRACE (1, L"Entering CCertMgrComponent::EnumCTLs\n");
	CCertMgrComponentData&	compdata = QueryComponentDataRef ();
	RESULTDATAITEM			rdItem;
	CWaitCursor				cursor;
     PCCTL_CONTEXT			pCTLContext = 0;
	HRESULT					hr = 0;
	CCTL*					pCTL = 0;
	CCookie&				rootCookie = compdata.QueryBaseRootCookie ();
	CTypedPtrList<CPtrList, CCertStore*> storeList;

	// Only enumerate the logical stores if this is not the GPE or RSOP.  If it is the
	// GPE, add the Trust and Root store.
	if ( !compdata.m_pGPEInformation && !compdata.m_bIsRSOP )
	{
		hr = compdata.EnumerateLogicalStores (&storeList);
		ASSERT (SUCCEEDED (hr));
	}
	else
	{
		if ( compdata.m_pGPERootStore )
		{
			compdata.m_pGPERootStore->AddRef ();
			storeList.AddTail (compdata.m_pGPERootStore);
		}
		if ( compdata.m_pGPETrustStore )
		{
			compdata.m_pGPETrustStore->AddRef ();
			storeList.AddTail (compdata.m_pGPETrustStore);
		}
	}
	if ( compdata.m_pFileBasedStore )
	{
		compdata.m_pFileBasedStore->AddRef ();
		storeList.AddTail (compdata.m_pFileBasedStore);
	}

	::ZeroMemory (&rdItem, sizeof (rdItem));
	rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	rdItem.nCol = 0;	// Must always be 0
	while ( 1 )
	{
		pCTLContext = rCertStore.EnumCTLs (pCTLContext);
		if ( !pCTLContext )
			break;
		if ( ACRS_STORE == rCertStore.GetStoreType () )
		{
			pCTL =
				new CAutoCertRequest (pCTLContext, rCertStore);
		}
		else
		{
			pCTL =
				new CCTL (pCTLContext, rCertStore, CERTMGR_CTL, &storeList);
		}
		if ( !pCTL )
		{
			hr = E_OUTOFMEMORY;
			break;
		}

		if ( ACRS_STORE != rCertStore.GetStoreType () )
			rdItem.nImage = iIconCTL;
		else
			rdItem.nImage = 0;

		rootCookie.m_listResultCookieBlocks.AddHead (pCTL);
		rdItem.str = MMC_TEXTCALLBACK;
		rdItem.lParam = (LPARAM) pCTL;
		pCTL->m_resultDataID = m_pResultData;
		hr = m_pResultData->InsertItem (&rdItem);
		ASSERT (SUCCEEDED (hr));
	}
	rCertStore.Close ();

	CCertStore* pStore = 0;

	// Clean up store list
	while (!storeList.IsEmpty () )
	{
		pStore = storeList.RemoveHead ();
		ASSERT (pStore);
		if ( pStore )
		{
			pStore->Close ();
			pStore->Release ();
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::EnumCTLs: 0x%x\n", hr);
	return hr;
}


STDMETHODIMP CCertMgrComponent::Notify (LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
     _TRACE (1, L"Entering CCertMgrComponent::Notify\n");
     HRESULT hr = S_OK;

     switch (event)
     {
		case MMCN_CUTORMOVE:
			hr = OnNotifyCutOrMove (arg);
			break;

		case MMCN_QUERY_PASTE:
			hr = OnNotifyQueryPaste (pDataObject, arg, param);
			break;

		case MMCN_PASTE:
			hr = OnNotifyPaste (pDataObject, arg, param);
			break;

	     case MMCN_SHOW:
			// CODEWORK this is hacked together quickly
			{
				CCookie* pCookie = NULL;
				hr = ExtractData (pDataObject,
								  CDataObject::m_CFRawCookie,
								  &pCookie,
								  sizeof(pCookie));
				if ( SUCCEEDED (hr) )
				{
					hr = Show (ActiveBaseCookie (pCookie), arg,
							(HSCOPEITEM) param, pDataObject);
				}
			}
			break;

        case MMCN_CANPASTE_OUTOFPROC:
            hr = OnNotifyCanPasteOutOfProc (reinterpret_cast<LPBOOL>(param));
            break;

		default:
			hr = CComponent::Notify (pDataObject, event, arg, param);
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::Notify: 0x%x\n", hr);
	return hr;
}


void CCertMgrComponent::DisplayAccessDenied ()
{
	_TRACE (1, L"Entering CCertMgrComponent::DisplayAccessDenied\n");
	DWORD	dwErr = GetLastError ();
	ASSERT (E_ACCESSDENIED == dwErr);
	if ( E_ACCESSDENIED == dwErr )
	{
		LPVOID lpMsgBuf;
			
		FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				NULL,
				GetLastError (),
				MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				 (LPWSTR) &lpMsgBuf,     0,     NULL );
			
		// Display the string.
		CString	caption;
		VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		int		iRetVal = 0;
		VERIFY (SUCCEEDED (m_pConsole->MessageBox ( (LPWSTR) lpMsgBuf, caption,
			MB_ICONWARNING | MB_OK, &iRetVal)));

		// Free the buffer.
		LocalFree (lpMsgBuf);
	}
	_TRACE (-1, L"Leaving CCertMgrComponent::DisplayAccessDenied\n");
}

HRESULT CCertMgrComponent::OnNotifyPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyPaste\n");
	ASSERT (pDataObject && arg);
	if ( !pDataObject || !arg )
		return E_POINTER;

	HRESULT					hr = S_OK;
	CCertMgrComponentData&	dataRef = QueryComponentDataRef ();
	HSCOPEITEM				hScopeItem = -1;
	bool					bContainsCerts = false;
	bool					bContainsCTLs = false;
	bool					bContainsCRLs = false;

	CCertMgrCookie* pTargetCookie = dataRef.ConvertCookie (pDataObject);
	ASSERT (pTargetCookie);
	if ( pTargetCookie )
	{
		CCertStore*			pCertStore = 0;
		SPECIAL_STORE_TYPE	storeType = NO_SPECIAL_TYPE;

		switch (pTargetCookie->m_objecttype)
		{
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
			{
				pCertStore = reinterpret_cast <CCertStore*>
						(pTargetCookie);
				ASSERT (pCertStore);
				if ( pCertStore )
				{
					storeType = pCertStore->GetStoreType ();
					hScopeItem = pCertStore->m_hScopeItem;
					bContainsCerts = pCertStore->ContainsCertificates ();
					bContainsCRLs = pCertStore->ContainsCRLs ();
					bContainsCTLs = pCertStore->ContainsCTLs ();
					ASSERT (-1 != hScopeItem);
				}
				else
					hr = E_POINTER;
			}
			break;

		case CERTMGR_CRL_CONTAINER:
			{
				bContainsCRLs = true;
				CContainerCookie* pCont = reinterpret_cast <CContainerCookie*>
						(pTargetCookie);
				ASSERT (pCont);
				if ( pCont )
				{
					pCertStore = &(pCont->GetCertStore ());
					storeType = pCont->GetStoreType ();
				}
				else
					hr = E_POINTER;
			}
			break;

		case CERTMGR_CTL_CONTAINER:
			{
				bContainsCTLs = true;
				CContainerCookie* pCont = reinterpret_cast <CContainerCookie*>
						(pTargetCookie);
				ASSERT (pCont);
				if ( pCont )
				{
					pCertStore = &(pCont->GetCertStore ());
					storeType = pCont->GetStoreType ();
				}
				else
					hr = E_POINTER;
			}
			break;

		case CERTMGR_CERT_CONTAINER:
			{
				bContainsCerts = true;
				CContainerCookie* pCont = reinterpret_cast <CContainerCookie*>
						(pTargetCookie);
				ASSERT (pCont);
				if ( pCont )
				{
					pCertStore = &(pCont->GetCertStore ());
					storeType = pCont->GetStoreType ();
				}
				else
					hr = E_POINTER;
			}
			break;

		case CERTMGR_CERTIFICATE:
			{
				CCertificate* pCert = reinterpret_cast <CCertificate*> (pTargetCookie);
				ASSERT (pCert);
				if ( pCert )
				{
					pCertStore = pCert->GetCertStore ();
					storeType = pCert->GetStoreType ();
				}
				else
					hr = E_POINTER;
			}
			break;

		case CERTMGR_CRL:
			{
				CCRL* pCRL = reinterpret_cast <CCRL*> (pTargetCookie);
				ASSERT (pCRL);
				if ( pCRL )
				{
					pCertStore = &(pCRL->GetCertStore ());
				}
				else
					hr = E_POINTER;
			}
			break;

		case CERTMGR_CTL:
			{
				CCTL* pCTL = reinterpret_cast <CCTL*> (pTargetCookie);
				ASSERT (pCTL);
				if ( pCTL )
				{
					pCertStore = &(pCTL->GetCertStore ());
				}
				else
					hr = E_POINTER;
			}
			break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            {
                param = 0; // do not allow cut/move of originating cert
                CSaferEntries* pSaferEntries = dynamic_cast <CSaferEntries*> (pTargetCookie);
                if ( pSaferEntries )
                {
                    CCertStore* pGPEStore = 0;
                    bool    bIsComputer = 
                        (CERTMGR_SAFER_COMPUTER_ENTRIES == pTargetCookie->m_objecttype);
                    DWORD dwDefaultLevelID = CSaferLevel::ReturnDefaultLevel (
                        dataRef.m_pGPEInformation, 
                        bIsComputer ? true : false, 
                        bIsComputer ? dataRef.m_rsopObjectArrayComputer : dataRef.m_rsopObjectArrayUser);

                    if ( SAFER_LEVELID_DISALLOWED== dwDefaultLevelID )
                        hr = pSaferEntries->GetTrustedPublishersStore (&pGPEStore);
                    else
                        hr = pSaferEntries->GetDisallowedStore (&pGPEStore);
                    if ( SUCCEEDED (hr) )
                    {
                        pCertStore = pGPEStore;
                    }
                }
            }
            break;

		default:
			hr = E_UNEXPECTED;
			break;
		}


		if ( !SUCCEEDED (hr) )
			return hr;

		CCertMgrCookie* pPastedCookie =
				dataRef.ConvertCookie ((LPDATAOBJECT) arg);
		if ( pPastedCookie && pCertStore )
		{
			if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pPastedCookie )
			{
				LPDATAOBJECT*	ppDO = reinterpret_cast<LPDATAOBJECT*>((LPDATAOBJECT) param);
			     CCookiePtrArray	rgCookiesCopied;

				// Is multiple select, get all selected items and paste each one
				LPDATAOBJECT	pMSDO = (LPDATAOBJECT) arg;
				if ( pMSDO )
				{
					CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
					ASSERT (pDO);
					if ( pDO )
					{
						bool			bRequestConfirmation = true;
						CCertMgrCookie*	pCookie = 0;
						pDO->Reset();
						while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
						{
							hr = PasteCookie (pCookie, pTargetCookie, *pCertStore,
									storeType, bContainsCerts, bContainsCRLs, bContainsCTLs,
									hScopeItem, bRequestConfirmation, true);
							if ( SUCCEEDED (hr) && ppDO && S_FALSE != hr )
								rgCookiesCopied.Add (pCookie);
                            else if ( FAILED (hr) )
                                break;
							bRequestConfirmation = false;
						}
					}
					else
						return E_UNEXPECTED;
				}
				else
					return E_UNEXPECTED;


				if ( pCertStore && SUCCEEDED (hr) )
				{
					pCertStore->Commit ();
				}
				else
					pCertStore->Resync ();

                if ( !bContainsCerts ) 
                {
                    // not necessary for certs - they're 
                    //added to the end
				    m_pConsole->UpdateAllViews (pDataObject, 0, HINT_PASTE_COOKIE);
                }

				if ( !ppDO )
					return S_OK;

				*ppDO = 0;



			     if ( rgCookiesCopied.GetSize () == 0 )
					return S_FALSE;

				CComObject<CCertMgrDataObject>* pObject = 0;
				hr = CComObject<CCertMgrDataObject>::CreateInstance(&pObject);
				ASSERT(SUCCEEDED(hr));
				if (FAILED(hr))
					return hr;

				ASSERT(pObject != NULL);
				if (pObject == NULL)
					return E_OUTOFMEMORY;

				hr = pObject->Initialize (
						pPastedCookie,
						CCT_UNINITIALIZED,
						FALSE,
						0,
						L"",
						L"",
						L"",
						dataRef);

				for (int i=0; i < rgCookiesCopied.GetSize(); ++i)
				{
					pObject->AddCookie(rgCookiesCopied[i]);
				}

				hr = pObject->QueryInterface(
						IID_PPV_ARG (IDataObject, ppDO));

				return hr;
			}
			else
			{
				hr = PasteCookie (pPastedCookie, pTargetCookie, *pCertStore,
						storeType, bContainsCerts, bContainsCRLs, bContainsCTLs,
						hScopeItem, true, false);
				if ( pCertStore && SUCCEEDED (hr) )
				{
					if ( param )   // a non-NULL value indicates that a cut/move is desired
					{
						LPDATAOBJECT	srcDO = (LPDATAOBJECT) arg;
						LPDATAOBJECT*	ppDO = reinterpret_cast<LPDATAOBJECT*>(param);
						hr = srcDO->QueryInterface(
								IID_PPV_ARG (IDataObject, ppDO));
					}
					m_pPastedDO = (LPDATAOBJECT) arg;
					pCertStore->Commit ();
				}
				else
					pCertStore->Resync ();
                if ( !bContainsCerts ) 
                {
                    // not necessary for certs - they're 
                    //added to the end
                    m_pConsole->UpdateAllViews (pDataObject, 0, HINT_PASTE_COOKIE);
                }
			}
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyPaste: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::PasteCookie (
		CCertMgrCookie* pPastedCookie,
		CCertMgrCookie* pTargetCookie,
		CCertStore& rCertStore,
		SPECIAL_STORE_TYPE storeType,
		bool bContainsCerts,
		bool bContainsCRLs,
		bool bContainsCTLs,
		HSCOPEITEM hScopeItem,
		bool bRequestConfirmation,
		bool bIsMultipleSelect)
{
	_TRACE (1, L"Entering CCertMgrComponent::PasteCookie\n");
	HRESULT	hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	switch (pPastedCookie->m_objecttype)
	{
	case CERTMGR_CERTIFICATE:
		{
			CCertificate* pCert = reinterpret_cast <CCertificate*>(pPastedCookie);
			ASSERT (pCert);
			if ( pCert )
			{
                DWORD   dwFlags = 0;
                CCertStore* pStore = pCert->GetCertStore ();
                if ( pStore )
                {
                    if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == QueryComponentDataRef ().m_dwLocationPersist )
                        dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
				    bool bDeletePrivateKey = DeletePrivateKey (rCertStore, *pStore);
				    if ( bRequestConfirmation &&
						    pCert->GetStoreType () == MY_STORE &&
                            bDeletePrivateKey &&
						    ::CryptFindCertificateKeyProvInfo (
							    pCert->GetCertContext (), dwFlags, 0) )
				    {
					    CString	text;
					    CString caption;
					    int		iRetVal = IDNO;

					    if ( bIsMultipleSelect )
						    VERIFY (text.LoadString (IDS_WARNING_MULTI_CERT_COPY_W_PRIVATE_KEY_MULTI));
					    else
						    VERIFY (text.LoadString (IDS_WARNING_CERT_COPY_W_PRIVATE_KEY));
					    VERIFY (caption.LoadString (IDS_CERTIFICATE_COPY));
					    hr = m_pConsole->MessageBox (text, caption,
							    MB_ICONWARNING | MB_YESNO, &iRetVal);
					    ASSERT (SUCCEEDED (hr));
					    if ( iRetVal == IDNO )
						    return E_FAIL;
				    }

				    hr = CopyPastedCert (pCert, rCertStore, storeType, bDeletePrivateKey, 
                            pTargetCookie);
				    if ( SUCCEEDED (hr) && S_FALSE != hr )
				    {
					    hr = pTargetCookie->Commit ();
					    if ( SUCCEEDED (hr) )
					    {
						    if ( !bContainsCerts )
							    hr = QueryComponentDataRef ().CreateContainers (
									    hScopeItem, rCertStore);
					    }
				    }
                }
			}
			else
				hr = E_POINTER;
		}
		break;

	case CERTMGR_CRL:
		{
			CCRL* pCRL = reinterpret_cast <CCRL*>(pPastedCookie);
			ASSERT (pCRL);
			if ( pCRL )
			{
				hr = CopyPastedCRL (pCRL, rCertStore);
				if ( SUCCEEDED (hr) )
				{
					pTargetCookie->Commit ();
					if ( !bContainsCRLs )
						hr = QueryComponentDataRef ().CreateContainers (hScopeItem,
								rCertStore);
				}
			}
			else
				hr = E_POINTER;
		}
		break;

	case CERTMGR_CTL:
		{
			CCTL* pCTL = reinterpret_cast <CCTL*>(pPastedCookie);
			ASSERT (pCTL);
			if ( pCTL )
			{
				hr = CopyPastedCTL (pCTL, rCertStore);
				if ( SUCCEEDED (hr) )
				{
					pTargetCookie->Commit ();
					if ( !bContainsCTLs )
						hr = QueryComponentDataRef ().CreateContainers (hScopeItem,
								rCertStore);
				}
			}
			else
				hr = E_POINTER;
		}
		break;

	case CERTMGR_AUTO_CERT_REQUEST:
		{
			CAutoCertRequest* pAutoCert = reinterpret_cast <CAutoCertRequest*>(pPastedCookie);
			ASSERT (pAutoCert);
			if ( pAutoCert )
			{
				hr = CopyPastedCTL (pAutoCert, rCertStore);
				if ( SUCCEEDED (hr) )
				{
					pTargetCookie->Commit ();
					if ( !bContainsCTLs )
						hr = QueryComponentDataRef ().CreateContainers (hScopeItem,
								rCertStore);
				}
			}
			else
				hr = E_POINTER;
		}
		break;

	default:
		break;
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::PasteCookie: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::OnNotifyQueryPaste(
        LPDATAOBJECT pDataObject, 
        LPARAM arg, 
        LPARAM /*param*/)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyQueryPaste\n");
	ASSERT (pDataObject && arg);
	if ( !pDataObject || !arg )
		return E_POINTER;

	HRESULT	hr = S_FALSE;
	CCertMgrComponentData& dataRef = QueryComponentDataRef ();

	CCertMgrCookie* pTargetCookie = dataRef.ConvertCookie (pDataObject);
	ASSERT (pTargetCookie);
	if ( pTargetCookie )
	{
		CCertMgrCookie* pPastedCookie =
				dataRef.ConvertCookie ((LPDATAOBJECT) arg);
		if ( pPastedCookie )
		{
			// If this is multi-selection, get the first selected object
			// and substitute it for the pasted cookie.
			if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pPastedCookie )
			{
				LPDATAOBJECT	pMSDO = (LPDATAOBJECT) arg;
				if ( pMSDO )
				{
					CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
					ASSERT (pDO);
					if ( pDO )
					{
						pDO->Reset();
						if (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pPastedCookie), NULL) == S_FALSE)
						{
							return E_UNEXPECTED;
						}
					}
					else
						return E_UNEXPECTED;
				}
				else
					return E_UNEXPECTED;

			}

			switch (pPastedCookie->m_objecttype)
			{
			case CERTMGR_CERTIFICATE:
				switch (pTargetCookie->m_objecttype)
				{
				case CERTMGR_PHYS_STORE:
				case CERTMGR_LOG_STORE:
                    {
                        CCertStore* pTargetStore = reinterpret_cast <CCertStore*> (pTargetCookie);
                        if ( pTargetStore )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pSourceStore )
                            {
                                if ( pTargetStore->IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

				case CERTMGR_CERT_CONTAINER:
                    {
                        CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pTargetCookie);
                        if ( pContainer )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pSourceStore )
                            {
                                if ( pContainer->GetCertStore ().IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == pContainer->GetCertStore () )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

				case CERTMGR_CERTIFICATE:
                    {
                        CCertificate* pCert = reinterpret_cast <CCertificate*> (pTargetCookie);
                        if ( pCert )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            CCertStore* pTargetStore = pCert->GetCertStore ();
                            
                            if ( pSourceStore && pTargetStore )
                            {
                                if ( pTargetStore->IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
					break;

				case CERTMGR_LOG_STORE_GPE:
					{
						CCertStoreGPE* pTargetStore =
								reinterpret_cast <CCertStoreGPE*> (pTargetCookie);
						ASSERT (pTargetStore);
						if ( pTargetStore )
						{
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            if ( pSourceStore )
                            {
                                if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
							    else if ( pTargetStore->CanContain (pPastedCookie->m_objecttype) &&
                                        !pTargetStore->IsReadOnly () )
								    hr = S_OK;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
						}
						else
							hr = E_UNEXPECTED;
					}
					break;

				case CERTMGR_LOG_STORE_RSOP:
					{
						CCertStoreRSOP* pTargetStore =
								reinterpret_cast <CCertStoreRSOP*> (pTargetCookie);
						ASSERT (pTargetStore);
						if ( pTargetStore )
						{
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            if ( pSourceStore )
                            {
                                if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
							    else if ( pTargetStore->CanContain (pPastedCookie->m_objecttype) &&
                                        !pTargetStore->IsReadOnly () )
								    hr = S_OK;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
						}
						else
							hr = E_UNEXPECTED;
					}
					break;

                case CERTMGR_SAFER_COMPUTER_ENTRIES:
                case CERTMGR_SAFER_USER_ENTRIES:
                    hr = S_OK;
                    break;

				default:
					break;
				}
				break;

			case CERTMGR_CRL:
				switch (pTargetCookie->m_objecttype)
				{
				case CERTMGR_PHYS_STORE:
				case CERTMGR_LOG_STORE:
                    {
                        CCertStore* pTargetStore = reinterpret_cast <CCertStore*> (pTargetCookie);
                        if ( pTargetStore )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCRL*> (pPastedCookie)->GetCertStore ();
                            if ( pTargetStore->IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == *pTargetStore )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

				case CERTMGR_CRL_CONTAINER:
                    {
                        CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pTargetCookie);
                        if ( pContainer )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCRL*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pContainer->GetCertStore ().IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == pContainer->GetCertStore () )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

				case CERTMGR_CRL:
                    {
                        CCRL* pCRL = reinterpret_cast <CCRL*> (pTargetCookie);
                        if ( pCRL )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            CCertStore& rTargetStore = pCRL->GetCertStore ();

                            if ( pSourceStore )
                            {
                                if ( rTargetStore.IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == rTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
					break;

				default:
					break;
				}
				break;

			case CERTMGR_CTL:
				switch (pTargetCookie->m_objecttype)
				{
				case CERTMGR_PHYS_STORE:
				case CERTMGR_LOG_STORE:
                    {
                        CCertStore* pTargetStore = reinterpret_cast <CCertStore*> (pTargetCookie);
                        if ( pTargetStore )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCTL*> (pPastedCookie)->GetCertStore ();
                            if ( pTargetStore->IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == *pTargetStore )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

				case CERTMGR_CTL_CONTAINER:
                    {
                        CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pTargetCookie);
                        if ( pContainer )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCTL*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pContainer->GetCertStore ().IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == pContainer->GetCertStore () )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

				case CERTMGR_CTL:
                    {
                        CCTL* pCTL = reinterpret_cast <CCTL*> (pTargetCookie);
                        if ( pCTL )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            CCertStore& rTargetStore = pCTL->GetCertStore ();
                            
                            if ( pSourceStore )
                            {
                                if ( rTargetStore.IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == rTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
					break;

				case CERTMGR_LOG_STORE_GPE:
				case CERTMGR_LOG_STORE_RSOP:
					{
						CCertStore* pTargetStore =
								reinterpret_cast <CCertStore*> (pTargetCookie);
						ASSERT (pTargetStore);
						if ( pTargetStore )
						{
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCTL*> (pPastedCookie)->GetCertStore ();
                            if ( rSourceStore == *pTargetStore )
                                hr = S_FALSE;
							else if ( pTargetStore->CanContain (pPastedCookie->m_objecttype) &&
                                    !pTargetStore->IsReadOnly () )
								hr = S_OK;
                            else
                                hr = S_OK;
						}
						else
							hr = E_UNEXPECTED;
					}
					break;

				default:
					break;
				}
				break;

			case CERTMGR_AUTO_CERT_REQUEST:
				switch (pTargetCookie->m_objecttype)
				{
				case CERTMGR_LOG_STORE_GPE:
				case CERTMGR_LOG_STORE_RSOP:
					{
						CCertStore* pTargetStore =
								reinterpret_cast <CCertStore*> (pTargetCookie);
						ASSERT (pTargetStore);
						if ( pTargetStore )
						{
							if ( ACRS_STORE == pTargetStore->GetStoreType ()  &&
                                    !pTargetStore->IsReadOnly ())
								hr = S_OK;
						}
						else
							hr = E_UNEXPECTED;
					}
					break;

				default:
					break;
				}
				break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                ASSERT (0);
                break;

			default:
				break;
			}
		}
	}


	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyQueryPaste: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::CopyPastedCert(
        CCertificate * pCert, 
        CCertStore& rCertStore, 
        const SPECIAL_STORE_TYPE /*storeType*/, 
        bool bDeletePrivateKey,
        CCertMgrCookie* pTargetCookie)
{
	_TRACE (1, L"Entering CCertMgrComponent::CopyPastedCert\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;

	ASSERT (pCert);
	if ( pCert )
	{
		PCCERT_CONTEXT	pCertContext = pCert->GetCertContext ();
		ASSERT (pCertContext);
		if ( pCertContext )
		{
			hr = rCertStore.AddCertificateContext (pCertContext,
					m_pConsole, bDeletePrivateKey);
            if ( FAILED (hr) && S_FALSE != hr )
            {
                if ( HRESULT_FROM_WIN32 (CRYPT_E_EXISTS) != hr )
                {
				    CString	text;
				    CString	caption;
				    int		iRetVal = 0;
                    if ( E_INVALIDARG == hr && !rCertStore.GetStoreHandle () )
                    {
                        text.FormatMessage (IDS_CERT_CANNOT_BE_PASTED_CANT_OPEN_STORE, 
                                rCertStore.GetLocalizedName ());
                    }
                    else
                    {
				        text.FormatMessage (IDS_CERT_CANNOT_BE_PASTED, 
                                rCertStore.GetLocalizedName (), 
                                GetSystemMessage (hr));
                    }
			        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			        m_pConsole->MessageBox (text, caption,
					        MB_OK, &iRetVal);
                }
            }
            else
            {
				if ( CERTMGR_CERT_CONTAINER == pTargetCookie->m_objecttype )
				{
                    CContainerCookie* pContainerCookie = dynamic_cast <CContainerCookie*> (pTargetCookie);
                    if ( pContainerCookie )
                    {
                        CCertStore* pOriginatingStore = pCert->GetCertStore ();
                        if ( pContainerCookie->GetCertStore ().GetStoreName () == 
                                pOriginatingStore->GetStoreName () )
                        {
                            // Add certificate to result pane
	                        RESULTDATAITEM			rdItem;
	                        CCookie&				rootCookie = 
                                    QueryComponentDataRef ().QueryBaseRootCookie ();

	                        ::ZeroMemory (&rdItem, sizeof (rdItem));
	                        rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
	                        rdItem.nImage = iIconCertificate;
	                        rdItem.nCol = 0;
                            rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
	                        rdItem.str = MMC_TEXTCALLBACK;

	                        CCertificate* pNewCert = new CCertificate (
                                    ::CertDuplicateCertificateContext (pCertContext),
                                    &rCertStore);
		                    if ( pNewCert )
                            {
		                        rootCookie.m_listResultCookieBlocks.AddHead (pNewCert);
		                        rdItem.lParam = (LPARAM) pNewCert;
		                        pCert->m_resultDataID = m_pResultData;
		                        hr = m_pResultData->InsertItem (&rdItem);
                                if ( FAILED (hr) )
                                {
                                     _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                }
                                else
                                {
                                     hr = DisplayCertificateCountByStore (m_pConsole, 
                                            &rCertStore, false);
                                }
                            }
                            else
			                    hr = E_OUTOFMEMORY;

					        ASSERT (SUCCEEDED (hr));
                        }
                    }
				}
            }
		}
		else
			hr = E_UNEXPECTED;
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponent::CopyPastedCert: 0x%x\n", hr);
	return hr;
}



HRESULT CCertMgrComponent::CopyPastedCTL(CCTL * pCTL, CCertStore& rCertStore)
{
	_TRACE (1, L"Entering CCertMgrComponent::CopyPastedCTL\n");
	HRESULT	hr = S_OK;

	ASSERT (pCTL);
	if ( pCTL )
	{
		PCCTL_CONTEXT	pCTLContext = pCTL->GetCTLContext ();
		ASSERT (pCTLContext);
		if ( pCTLContext )
		{
			bool	bResult = rCertStore.AddCTLContext (pCTLContext);
			if ( !bResult )
			{
				DWORD	dwErr = GetLastError ();
				if ( CRYPT_E_EXISTS == dwErr )
				{
					CString	text;
					CString	caption;
					int		iRetVal = 0;


					VERIFY (text.LoadString (IDS_DUPLICATE_CTL));
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					hr = m_pConsole->MessageBox (text, caption,
							MB_OK, &iRetVal);
					ASSERT (SUCCEEDED (hr));
					hr = E_FAIL;
				}
				else
				{
					ASSERT (0);
					hr = HRESULT_FROM_WIN32 (dwErr);
				}
			}
		}
		else
			hr = E_UNEXPECTED;
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponent::CopyPastedCTL: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::CopyPastedCRL(CCRL * pCRL, CCertStore& rCertStore)
{
	_TRACE (1, L"Entering CCertMgrComponent::CopyPastedCRL\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;

	ASSERT (pCRL);
	if ( pCRL )
	{
		PCCRL_CONTEXT	pCRLContext = pCRL->GetCRLContext ();
		ASSERT (pCRLContext);
		if ( pCRLContext )
		{
			bool	bResult = rCertStore.AddCRLContext (pCRLContext);
			if ( !bResult )
			{
				DWORD	dwErr = GetLastError ();
				if ( CRYPT_E_EXISTS == dwErr )
				{
					CString	text;
					CString	caption;
					int		iRetVal = 0;


					VERIFY (text.LoadString (IDS_DUPLICATE_CRL));
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					hr = m_pConsole->MessageBox (text, caption,
							MB_OK, &iRetVal);
					ASSERT (SUCCEEDED (hr));
					hr = E_FAIL;
				}
				else
				{
					ASSERT (0);
					hr = HRESULT_FROM_WIN32 (dwErr);
				}
			}
		}
		else
			hr = E_UNEXPECTED;
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponent::CopyPastedCRL: 0x%x\n", hr);
	return hr;
}


STDMETHODIMP CCertMgrComponent::GetResultViewType(MMC_COOKIE cookie,
		BSTR* ppViewType,
		long* pViewOptions) 
{
	_TRACE (1, L"Entering CCertMgrComponent::GetResultViewType\n");
    HRESULT         hr = S_FALSE;
	CCertMgrCookie* pScopeCookie = reinterpret_cast <CCertMgrCookie*> (cookie);
	if ( pScopeCookie )
	{
		switch (pScopeCookie->m_objecttype)
		{
		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_USAGE:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
			*pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
            *ppViewType = NULL;
			break;

        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
            {
                CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pScopeCookie);
                if ( pSaferRootCookie )
                {
                    if ( pSaferRootCookie->m_bCreateSaferNodes )
                    {
       			        *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
                        *ppViewType = NULL;
                    }
                    else
                    {
                        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

                        LPOLESTR psz = NULL;
                        StringFromCLSID(CLSID_MessageView, &psz);

                        USES_CONVERSION;

                        if (psz != NULL)
                        {
                            *ppViewType = psz;
                            hr = S_OK;
                        }
                    }
                }
            }
            break;

		default:
            *ppViewType = NULL;
			break;
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::GetResultViewType: 0x%x\n", hr);
     return hr;
}


STDMETHODIMP CCertMgrComponent::Initialize(LPCONSOLE lpConsole)
{
	_TRACE (1, L"Entering CCertMgrComponent::Initialize\n");
	HRESULT	 hr = CComponent::Initialize (lpConsole);
	if ( SUCCEEDED (hr) )
	{
		ASSERT (m_pHeader);
		QueryComponentDataRef ().m_pHeader = m_pHeader;

        if ( lpConsole )
        {
           if ( QueryComponentDataRef ().m_pComponentConsole )
                 SAFE_RELEASE (QueryComponentDataRef ().m_pComponentConsole);
           QueryComponentDataRef ().m_pComponentConsole = m_pConsole;
           QueryComponentDataRef ().m_pComponentConsole->AddRef ();
        }
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::Initialize: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::LoadColumnsFromArrays (INT objecttype )
{
	_TRACE (1, L"Entering CCertMgrComponent::LoadColumnsFromArrays\n");
     ASSERT (m_pHeader);

	CString str;
	for ( INT i = 0; 0 != m_Columns[objecttype][i]; i++)
	{
		VERIFY(str.LoadString (m_Columns[objecttype][i]));
		m_pHeader->InsertColumn(i, const_cast<LPWSTR>((LPCWSTR)str), LVCFMT_LEFT,
			m_ColumnWidths[objecttype][i]);
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::LoadColumnsFromArrays: S_OK\n");
	return S_OK;
}

HRESULT CCertMgrComponent::SaveWidths(CCertMgrCookie * pCookie)
{
	_TRACE (1, L"Entering CCertMgrComponent::SaveWidths\n");
	HRESULT	hr = S_OK;

	m_fDirty = TRUE;

	ASSERT (pCookie);
	if ( pCookie )
	{
		switch (m_pViewedCookie->m_objecttype)
		{
		case CERTMGR_SNAPIN:
		case CERTMGR_USAGE:
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_CERT_POLICIES_USER:
		case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
			{
				const UINT* pColumns = m_Columns[m_pViewedCookie->m_objecttype];
				ASSERT(pColumns);
				int    nWidth = 0;

				for (UINT iIndex = 0; iIndex < pColumns[iIndex]; iIndex++)
				{
					hr = m_pHeader->GetColumnWidth ((int) iIndex, &nWidth);
					if ( SUCCEEDED (hr) )
					{
						m_ColumnWidths[m_pViewedCookie->m_objecttype][iIndex] =
								(UINT) nWidth;
					}
					else
						break;
				}
			}
			break;

		case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
		default:
			ASSERT (0);
			break;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponent::SaveWidths: 0x%x\n", hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
#define _dwMagicword	10000  // Internal version number
STDMETHODIMP CCertMgrComponent::Load(IStream __RPC_FAR *pIStream)
{
	_TRACE (1, L"Entering CCertMgrComponent::Load\n");
	HRESULT hr = S_OK;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword = 0;
	hr = pIStream->Read (&dwMagicword, sizeof(dwMagicword), NULL);
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		_TRACE (0, L"INFO: CCertMgrComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	int	numCols = 0;

	for (int iIndex = 0; iIndex < CERTMGR_NUMTYPES && SUCCEEDED (hr); iIndex++)
	{
		switch (iIndex)
		{
		case CERTMGR_USAGE:
		case CERTMGR_CERT_CONTAINER:
			numCols = CERT_NUM_COLS;
			break;

		case CERTMGR_CRL_CONTAINER:
			numCols = CRL_NUM_COLS;
			break;

		case CERTMGR_CTL_CONTAINER:
			numCols = CTL_NUM_COLS;
			break;

		case CERTMGR_SNAPIN:
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
			numCols = 1;
			break;

        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
            numCols = SAFER_LEVELS_NUM_COLS;
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            numCols = SAFER_ENTRIES_NUM_COLS;
            break;

		case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
		case CERTMGR_CERT_POLICIES_USER:
		case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
			continue;

		default:
			ASSERT (0);
			break;
		}

		for (int colNum = 0; colNum < numCols; colNum++)
		{
			hr = pIStream->Read (&(m_ColumnWidths[iIndex][colNum]),
					sizeof (UINT), NULL);
			ASSERT (SUCCEEDED (hr));
			if ( FAILED(hr) )
			{
				ASSERT (FALSE);
				break;
			}
		}
	}
#endif
	_TRACE (-1, L"Leaving CCertMgrComponent::Load: 0x%x\n", hr);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCertMgrComponent::Save(
        IStream __RPC_FAR *pIStream, 
        BOOL /*fSameAsLoad*/)
{
	_TRACE (1, L"Entering CCertMgrComponent::Save\n");
	HRESULT hr = S_OK;


#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr (pIStream);

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write (&dwMagicword, sizeof(dwMagicword), NULL);
	ASSERT (SUCCEEDED (hr));
	if ( FAILED (hr) )
		return hr;


	int	numCols = 0;

	for (int iIndex = 0; iIndex < CERTMGR_NUMTYPES && SUCCEEDED (hr); iIndex++)
	{
		switch (iIndex)
		{
		case CERTMGR_USAGE:
		case CERTMGR_CERT_CONTAINER:
			numCols = CERT_NUM_COLS;
			break;

		case CERTMGR_CRL_CONTAINER:
			numCols = CRL_NUM_COLS;
			break;

		case CERTMGR_CTL_CONTAINER:
			numCols = CTL_NUM_COLS;
			break;

		case CERTMGR_SNAPIN:
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_CERT_POLICIES_USER:
		case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
			numCols = 1;
			break;

        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            numCols = SAFER_ENTRIES_NUM_COLS;
            break;

        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
            numCols = SAFER_LEVELS_NUM_COLS;
            break;

		case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
			continue;

		default:
			ASSERT (0);
			break;
		}

		for (int colNum = 0; colNum < numCols; colNum++)
		{
			hr = pIStream->Write (&(m_ColumnWidths[iIndex][colNum]),
					sizeof (UINT), NULL);
			ASSERT (SUCCEEDED (hr));
			if ( FAILED(hr) )
			{
				ASSERT (FALSE);
				break;
			}
		}
	}
#endif

	_TRACE (-1, L"Leaving CCertMgrComponent::Save: 0x%x\n", hr);
	return S_OK;
}

HRESULT CCertMgrComponent::OnNotifyCutOrMove(LPARAM arg)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnNotifyCutOrMove\n");
	if ( !arg )
		return E_POINTER;

	LPDATAOBJECT pDataObject = reinterpret_cast <IDataObject*> (arg);
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_UNEXPECTED;


	HRESULT			hr = S_OK;

	CCertMgrCookie* pCookie =
			QueryComponentDataRef ().ConvertCookie (pDataObject);
	if ( pCookie )
	{
		if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
		{
			CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pDataObject);
			ASSERT (pDO);
			if ( pDO )
			{
//                CCertStore& rCertStore = pCookie->GetCertStore ();
				pDO->Reset();
				while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
				{
					hr = DeleteCookie (pCookie, pDataObject, false, true, false);
				}

//                hr = rCertStore.Commit ();
//			    if ( SUCCEEDED (hr) )
//				    rCertStore.Resync ();
			}
			else
				hr = E_FAIL;
		}
		else
		{
			hr = DeleteCookie (pCookie, pDataObject, false, false, true);
		}
		if ( SUCCEEDED (hr) )
			RefreshResultPane ();
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyCutOrMove: 0x%x\n", hr);
	return hr;
}



CCertMgrCookie* CCertMgrComponent::ConvertCookie(LPDATAOBJECT pDataObject)
{
	CCertMgrCookie* pCookie = 0;

	pCookie = QueryComponentDataRef ().ConvertCookie (pDataObject);
	return pCookie;
}

HRESULT CCertMgrComponent::OnOpen (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnOpen\n");
	HRESULT	hr = S_OK;
	ASSERT (pDataObject);
	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie )
	{
		switch (pParentCookie->m_objecttype)
		{
		case CERTMGR_CERTIFICATE:
			{
				CCertificate*	pCert = reinterpret_cast <CCertificate*> (pParentCookie);
				ASSERT (pCert);
				if ( pCert )
				{
					hr = LaunchCommonCertDialog (pCert);
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

		case CERTMGR_CTL:
			{
				CCTL*	pCTL = reinterpret_cast <CCTL*> (pParentCookie);
				ASSERT (pCTL);
				if ( pCTL )
				{
					hr = LaunchCommonCTLDialog (pCTL);
					if ( SUCCEEDED (hr) )
						hr = RefreshResultItem (pParentCookie);
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

		case CERTMGR_CRL:
			{
				CCRL*	pCRL = reinterpret_cast <CCRL*> (pParentCookie);
				ASSERT (pCRL);
				if ( pCRL )
				{
					hr = LaunchCommonCRLDialog (pCRL);
					if ( SUCCEEDED (hr) )
						hr = RefreshResultItem (pParentCookie);
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

			break;

		default:
			ASSERT (0);
			break;
		}
	}
	else
		hr = E_UNEXPECTED;

	_TRACE (-1, L"Leaving CCertMgrComponent::OnOpen: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::LaunchCommonCertDialog (CCertificate* pCert)
{
	_TRACE (1, L"Entering CCertMgrComponent::LaunchCommonCertDialog\n");
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT (pCert);
	if ( !pCert )
		return E_POINTER;

     CWaitCursor                           waitCursor;
	HWND							hwndParent = 0;
	HRESULT							hr = m_pConsole->GetMainWindow (&hwndParent);
	ASSERT (SUCCEEDED (hr));
	CCertMgrComponentData&	dataRef = QueryComponentDataRef ();
	CTypedPtrList<CPtrList, CCertStore*>	storeList;

	//  Add the Root store first on a remote machine.
	if ( !IsLocalComputername (dataRef.GetManagedComputer ()) )
	{
		storeList.AddTail (new CCertStore (CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				(LPCWSTR) dataRef.GetManagedComputer (),
				ROOT_SYSTEM_STORE_NAME,
				ROOT_SYSTEM_STORE_NAME,
				_T (""), ROOT_STORE,
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				m_pConsole));
	}

	hr = dataRef.EnumerateLogicalStores (&storeList);
	if ( SUCCEEDED (hr) )
	{
          POSITION pos = 0;
          POSITION prevPos = 0;

          // Validate store handles
		for (pos = storeList.GetHeadPosition ();
				pos;)
		{
               prevPos = pos;
			CCertStore* pStore = storeList.GetNext (pos);
			ASSERT (pStore);
			if ( pStore )
			{
                // Do not open the userDS store
                if ( USERDS_STORE == pStore->GetStoreType () )
                {
                    storeList.RemoveAt (prevPos);
                    pStore->Release ();
                    pStore = 0;
                }
                else
                {
				    if ( !pStore->GetStoreHandle () )
                    {
                        int      iRetVal = 0;
                        CString	caption;
                        CString	text;

                        text.FormatMessage (IDS_CANT_OPEN_STORE_AND_FAIL, pStore->GetLocalizedName ());
                        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                        hr = E_FAIL;
                        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption, 
                              MB_ICONWARNING | MB_OK, &iRetVal)));
                        break;
                    }
                }
			}
		}

          // Proceed only if all handles are valid 
          if ( SUCCEEDED (hr) )
          {
		     CRYPTUI_VIEWCERTIFICATE_STRUCT	vcs;
		     ::ZeroMemory (&vcs, sizeof (vcs));
		     vcs.dwSize = sizeof (vcs);
		     vcs.hwndParent = hwndParent;

		     //  Set these flags only on a remote machine.
		     if ( !IsLocalComputername (dataRef.GetManagedComputer ()) )
			     vcs.dwFlags = CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
		     else
			     vcs.dwFlags = 0;

             // All dialogs should be read-only under RSOP
             if ( dataRef.m_bIsRSOP || pCert->IsReadOnly () )
                 vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

		     vcs.pCertContext = pCert->GetNewCertContext ();
		     vcs.cStores = (DWORD)storeList.GetCount ();
		     vcs.rghStores = new HCERTSTORE[vcs.cStores];
		     if ( vcs.rghStores )
		     {
			     CCertStore*		pStore = 0;
			     DWORD			index = 0;

			     for (pos = storeList.GetHeadPosition ();
					     pos && index < vcs.cStores;
					     index++)
			     {
				     pStore = storeList.GetNext (pos);
				     ASSERT (pStore);
				     if ( pStore )
				     {
					     vcs.rghStores[index] = pStore->GetStoreHandle ();
				     }
			     }

			     BOOL fPropertiesChanged = FALSE;
          	     _TRACE (0, L"Calling CryptUIDlgViewCertificate()\n");
                 CThemeContextActivator activator;
			     BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
			     if ( bResult )
			     {
				     if ( fPropertiesChanged )
				     {
                         pStore = pCert->GetCertStore ();
                         if ( pStore )
                         {
					         pStore->SetDirty ();
						     pStore->Commit ();
						     pStore->Close ();
					         if ( IDM_USAGE_VIEW == dataRef.m_activeViewPersist )
					         {
						         // In case purposes were changed and the cert needs to be removed
						         RefreshResultPane ();
					         }
					         else
						         RefreshResultItem (pCert);
                         }
				     }
			     }

			     delete vcs.rghStores;
		     }
		     else
			     hr = E_OUTOFMEMORY;
        }

		while (!storeList.IsEmpty () )
		{
			CCertStore* pStore = storeList.RemoveHead ();
			if ( pStore )
			{
				pStore->Close ();
				pStore->Release ();
			}
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::LaunchCommonCertDialog: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::RefreshResultItem (CCertMgrCookie* pCookie)
{
	_TRACE (1, L"Entering CCertMgrComponent::RefreshResultItem\n");
	HRESULT	hr = S_OK;
	if ( pCookie )
	{
		HRESULTITEM	itemID = 0;

		if ( m_pResultData )
		{
			pCookie->Refresh ();
			hr = m_pResultData->FindItemByLParam ( (LPARAM) pCookie, &itemID);
			if ( SUCCEEDED (hr) )
			{
				hr = m_pResultData->UpdateItem (itemID);
				if ( FAILED (hr) )
				{
					_TRACE (0, L"IResultData::UpdateItem () failed: 0x%x\n", hr);          
				}
			}
			else
			{
				_TRACE (0, L"IResultData::FindItemByLParam () failed: 0x%x\n", hr);          
			}
		}
		else
		{
			_TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
			hr = E_FAIL;
		}
	}
	else
	{
		_TRACE (0, L"Unexpected error: pCookie parameter was NULL\n");
		hr = E_POINTER;
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::RefreshResultItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::LaunchCommonCTLDialog (CCTL* pCTL)
{
	_TRACE (1, L"Entering CCertMgrComponent::LaunchCommonCTLDialog\n");
     HRESULT hr = S_OK;
	if ( pCTL )
     {
	     CRYPTUI_VIEWCTL_STRUCT	vcs;
	     HWND					hwndParent = 0;
	     
          hr = m_pConsole->GetMainWindow (&hwndParent);
	     if ( FAILED (hr) )
          {
               _TRACE (0, L"IConsole::GetMainWindow () failed: 0x%x\n", hr);
          }
	     ::ZeroMemory (&vcs, sizeof (vcs));
	     vcs.dwSize = sizeof (vcs);
	     vcs.hwndParent = hwndParent;
	     vcs.dwFlags = 0;

         // All dialogs should be read-only under RSOP
         if ( QueryComponentDataRef ().m_bIsRSOP )
             vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

	     vcs.pCTLContext = pCTL->GetCTLContext ();

         CThemeContextActivator activator;
	     VERIFY (::CryptUIDlgViewCTL (&vcs));
     }
     else
          hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponent::LaunchCommonCTLDialog: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::LaunchCommonCRLDialog (CCRL* pCRL)
{
    _TRACE (1, L"Entering CCertMgrComponent::LaunchCommonCRLDialog\n");
    ASSERT (pCRL);
    CRYPTUI_VIEWCRL_STRUCT	vcs;
    HWND					hwndParent;
    HRESULT					hr = m_pConsole->GetMainWindow (&hwndParent);
    ASSERT (SUCCEEDED (hr));

    ::ZeroMemory (&vcs, sizeof (vcs));
    vcs.dwSize = sizeof (vcs);
    vcs.hwndParent = hwndParent;
    vcs.dwFlags = 0;

    // All dialogs should be read-only under RSOP
    if ( QueryComponentDataRef ().m_bIsRSOP )
        vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

    vcs.pCRLContext = pCRL->GetCRLContext ();

    CThemeContextActivator activator;
    VERIFY (::CryptUIDlgViewCRL (&vcs));

    _TRACE (-1, L"Leaving CCertMgrComponent::LaunchCommonCRLDialog: 0x%x\n", hr);
    return hr;
}




void CCertMgrComponent::CloseAndReleaseUsageStores()
{
	_TRACE (1, L"Entering CCertMgrComponent::CloseAndReleaseUsageStores\n");
	CCertStore*	pCertStore = 0;
	while (!m_usageStoreList.IsEmpty () )
	{
		pCertStore = m_usageStoreList.RemoveHead ();
		ASSERT (pCertStore);
		if ( pCertStore )
			pCertStore->Release ();
	}
	_TRACE (-1, L"Leaving CCertMgrComponent::CloseAndReleaseUsageStores\n");
}

bool CCertMgrComponent::DeletePrivateKey(CCertStore& rCertStoreDest, CCertStore& rCertStoreSrc)
{
	_TRACE (1, L"Entering CCertMgrComponent::DeletePrivateKey\n");
	bool bDeletePrivateKey = false;


	// Do not copy the private key if the stores are on different machines or
	// if the destination store is in the GPO.
	if ( rCertStoreDest.m_strMachineName  != rCertStoreSrc.m_strMachineName )
		bDeletePrivateKey = true;
	else if ( !rCertStoreDest.GetLocation () ) // Store is GPO store
		bDeletePrivateKey = true;
	

	_TRACE (-1, L"Leaving CCertMgrComponent::DeletePrivateKey\n");
	return bDeletePrivateKey;
}


/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CCertMgrComponent::OnPropertyChange (LPARAM param)
{
	_TRACE (1, L"Entering CCertMgrComponent::OnPropertyChange\n");
	HRESULT	hr = S_OK;

	hr = QueryComponentDataRef ().OnPropertyChange (param);
	_TRACE (-1, L"Leaving CCertMgrComponent::OnPropertyChange: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::DisplayCertificateCountByUsage(const CString & usageName, int nCertCnt) const
{
	_TRACE (1, L"Entering CCertMgrComponent::DisplayCertificateCountByUsage\n");
     AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
	ASSERT (!usageName.IsEmpty ());
	ASSERT (nCertCnt >= 0);
     IConsole2*	pConsole2 = 0;
     HRESULT		hr = m_pConsole->QueryInterface (
			IID_PPV_ARG (IConsole2, &pConsole2));
     if (SUCCEEDED (hr))
     {
		CString	statusText;


          switch (nCertCnt)
          {
               case 0:
				statusText.FormatMessage (IDS_STATUS_NO_CERTS_USAGE, usageName);
                     break;

               case 1:
				statusText.FormatMessage (IDS_STATUS_ONE_CERT_USAGE, usageName);
                     break;

               default:
				WCHAR	wszCertCount[16];

				AfxFormatString2 (statusText, IDS_STATUS_X_CERTS_USAGE,
						_itow (nCertCnt, wszCertCount, 10), (LPCWSTR) usageName);
                     break;
          }

          hr = pConsole2->SetStatusText ((LPWSTR)(LPCWSTR) statusText);	

          pConsole2->Release ();
     }

	_TRACE (-1, L"Leaving CCertMgrComponent::DisplayCertificateCountByUsage: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::OnNotifySnapinHelp (LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    CComQIPtr<IDisplayHelp,&IID_IDisplayHelp>	spDisplayHelp = m_pConsole;
    if ( !!spDisplayHelp )
    {
        CString strHelpTopic;

        UINT nLen = ::GetSystemWindowsDirectory (strHelpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strHelpTopic.ReleaseBuffer();
        if ( nLen )
        {
            /*
            * Help on the stores / purposes should start HTML help with Certficate Manager / Concepts / Understanding Certificate 	Manager / Certificate stores.
            topic is CMconcepts.chm::/sag_CMunCertStor.htm
            * Help on the Certificates / CTL / CRL nodes on the scope pane should open Certificate Manager / Concepts / 	Understanding Certificate Manager.
            topic is CMconcepts.chm::/sag_CMunderstandWks.htm
            * Help on certificates / CTL / CRL objects on the result pane should open Certificate Manager / Concepts / Using Certificate 	Manager.
            topic is CMconcepts.chm::/sag_CMusingWks.htm
            * Help on the Certificate Manager node should launch help with Certificate Manager.
            topic is CMconcepts.chm::/sag_CMtopNode.htm
            */
            CString helpFile;
            CString helpTopic;
            CCertMgrComponentData&	compData = QueryComponentDataRef ();
            CCertMgrCookie* pCookie = compData.ConvertCookie (pDataObject);
            if ( pCookie )
            {
                switch (pCookie->m_objecttype)
                {
                    case CERTMGR_LOG_STORE_GPE:
                    case CERTMGR_LOG_STORE_RSOP:
                    case CERTMGR_CERT_POLICIES_USER:
                    case CERTMGR_CERT_POLICIES_COMPUTER:
                    case CERTMGR_AUTO_CERT_REQUEST:
                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        helpFile = PKP_LINKED_HELP_FILE;
                        helpTopic = PKP_HELP_TOPIC;
                        break;

                    case CERTMGR_LOG_STORE:
                    case CERTMGR_PHYS_STORE:
                    case CERTMGR_USAGE:
                        helpFile = CM_LINKED_HELP_FILE;
                        helpTopic = CM_HELP_TOPIC;
                        break;

                    case CERTMGR_CRL_CONTAINER:
                    case CERTMGR_CTL_CONTAINER:
                    case CERTMGR_CERT_CONTAINER:
                        helpFile = CM_LINKED_HELP_FILE;
                        helpTopic = CM_HELP_TOPIC;
                        break;

                    case CERTMGR_CERTIFICATE:
                    {
                        CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                        if ( pCert )
                        {
                            CCertStore* pStore = pCert->GetCertStore ();
                            if ( pStore )
                            {
                                if ( EFS_STORE == pStore->GetStoreType () )
                                {
                                    helpFile = PKP_LINKED_HELP_FILE;
                                    helpTopic = PKP_HELP_TOPIC;
                                }
                                else
                                {
                                    helpFile = CM_LINKED_HELP_FILE;
                                    helpTopic = CM_HELP_TOPIC;
                                }
                            }
                        }
                    }
                    break;

                    case CERTMGR_CRL:
                    {
                        CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
                        if ( pCRL )
                        {
                            if ( EFS_STORE == pCRL->GetCertStore ().GetStoreType () )
                            {
                                helpFile = PKP_LINKED_HELP_FILE;
                                helpTopic = PKP_HELP_TOPIC;
                            }
                            else
                            {
                                helpFile = CM_LINKED_HELP_FILE;
                                helpTopic = CM_HELP_TOPIC;
                            }
                        }
                    }
                    break;

                    case CERTMGR_CTL:
                    {
                        CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
                        if ( pCTL )
                        {
                            if ( EFS_STORE == pCTL->GetCertStore ().GetStoreType () )
                            {
                                helpFile = PKP_LINKED_HELP_FILE;
                                helpTopic = PKP_HELP_TOPIC;
                            }
                            else
                            {
                                helpFile = CM_LINKED_HELP_FILE;
                                helpTopic = CM_HELP_TOPIC;
                            }
                        }
                    }
                    break;

                    case CERTMGR_SAFER_COMPUTER_ROOT:
                    case CERTMGR_SAFER_USER_ROOT:
                    case CERTMGR_SAFER_COMPUTER_LEVELS:
                    case CERTMGR_SAFER_USER_LEVELS:
                    case CERTMGR_SAFER_COMPUTER_ENTRIES:
                    case CERTMGR_SAFER_USER_ENTRIES:
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                        helpFile = SAFER_WINDOWS_LINKED_HELP_FILE;
                        helpTopic = SAFER_HELP_TOPIC;
                        break;

                    case CERTMGR_SNAPIN:
                    default:
                        helpFile = CM_LINKED_HELP_FILE;
                        helpTopic = CM_HELP_TOPIC;
                        break;
                }
            }   


            strHelpTopic += L"\\help\\";
            strHelpTopic += helpFile;
            strHelpTopic += L"::/";
            strHelpTopic += helpTopic;


            hr = spDisplayHelp->ShowTopic ((LPWSTR)(LPCWSTR) strHelpTopic);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CCertMgrComponent::SetControlbar(
                    /* [in] */ LPCONTROLBAR /*pControlbar*/)
{
/*
    HRESULT hr = S_OK;

    // if we've got a cached toolbar, release it
    if (m_pToolbar) {
        m_pToolbar->Release();
        m_pToolbar = NULL;
    }

    // if we've got a cached control bar, release it
    if (m_pControlbar) {
        m_pControlbar->Release();
        m_pControlbar = NULL;
    }

    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) 
    {
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        CThemeContextActivator activator;
        hr = m_pControlbar->Create(TOOLBAR,  // type of control
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_pToolbar));

        _ASSERT(SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            m_pToolbar->AddRef();

            // add the bitmap to the toolbar
            HBITMAP hbmp = LoadBitmap (MAKEINTRESOURCE(IDR_TOOLBAR1));
            hr = m_pToolbar->AddBitmap (3, hbmp, 16, 16, 
                              RGB(0, 128, 128)); //NOTE, hardcoded value 3

            _ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            hr = m_pToolbar->AddButtons(ARRAYLEN(SnapinButtons1), 
                              SnapinButtons1);

            _ASSERT(SUCCEEDED(hr));
        }
    }

    return hr;
*/
    return E_NOTIMPL;
}

HRESULT CCertMgrComponent::ControlbarNotify(
            MMC_NOTIFY_TYPE /*event*/,  // user action
            LPARAM /*arg*/,               // depends on the event parameter
            LPARAM /*param*/)             // depends on the event parameter
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\certifct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Certifct.cpp
//
//  Contents:   Implementation of CCertmgrApp and DLL registration.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Certifct.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("CERTMGR(Certifct.cpp)")

/////////////////////////////////////////////////////////////////////////////
//
const int FIELD_ISSUER_ALT_NAME =	0x00000001;
const int FIELD_SUBJECT_ALT_NAME =	0x00000002;
const int FIELD_CAN_DELETE =		0x00000004;
const int FIELD_IS_ARCHIVED =		0x00000008;
const int FIELD_TEMPLATE_NAME =     0x00000010;

CCertificate::CCertificate(const PCCERT_CONTEXT pCertContext, CCertStore* pCertStore) 
: CCertMgrCookie (CERTMGR_CERTIFICATE),
m_pCertContext (::CertDuplicateCertificateContext (pCertContext)),
	m_pCertInfo (0),
	m_fieldChecked (0),
	m_pCertStore (pCertStore),
	m_bCanDelete (false),
	m_bIsArchived (false)
{
//	_TRACE (1, L"Entering CCertificate::CCertificate\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertStore);
    if ( m_pCertStore )
	    m_pCertStore->AddRef ();
	ASSERT (m_pCertContext);
	if ( m_pCertContext )
		m_pCertInfo = m_pCertContext->pCertInfo;
//	_TRACE (-1, L"Leaving CCertificate::CCertificate\n");
}



CCertificate::~CCertificate()
{
//	_TRACE (1, L"Entering CCertificate::~CCertificate\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	if ( m_pCertContext )
		::CertFreeCertificateContext (m_pCertContext);
    if ( m_pCertStore )
    	m_pCertStore->Release ();
//	_TRACE (-1, L"Leaving CCertificate::~CCertificate\n");
}


CString CCertificate::GetFriendlyName ()
{
//	_TRACE (1, L"Entering CCertificate::GetFriendlyName\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertContext);
	if ( m_pCertContext && m_szFriendlyName.IsEmpty () )
	{	
		AFX_MANAGE_STATE (AfxGetStaticModuleState ());
		DWORD	cbData = 0;
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_FRIENDLY_NAME_PROP_ID,
				NULL,
				&cbData);
		if ( bResult )
		{
			LPWSTR	pszName = new WCHAR[cbData];
			if ( pszName )
			{
				::ZeroMemory (pszName, cbData*sizeof (WCHAR));
				bResult = ::CertGetCertificateContextProperty (
						m_pCertContext,
						CERT_FRIENDLY_NAME_PROP_ID,
						pszName,
						&cbData);
				ASSERT (bResult);
				if ( bResult )
				{
					m_szFriendlyName = pszName;
				}
				else
				{
					VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
				}
				delete [] pszName;
			}
		}
		else
		{
			if ( GetLastError () == CRYPT_E_NOT_FOUND )
			{
				VERIFY (m_szFriendlyName.LoadString (IDS_NONE));
			}
			else
			{
				ASSERT (0);
				VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
			}
		}
    }
//	_TRACE (-1, L"Leaving CCertificate::GetFriendlyName\n");
	return m_szFriendlyName;
}


CString CCertificate::GetIssuerName ()
{
//	_TRACE (1, L"Entering CCertificate::GetIssuerName\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		// Decode issuer name if not already present
		if ( m_szIssuerName.IsEmpty () )
		{
			m_szIssuerName = ::GetNameString (m_pCertContext, CERT_NAME_ISSUER_FLAG);
		}
	}
	else
		return _T("");


//	_TRACE (-1, L"Leaving CCertificate::GetIssuerName\n");
	return m_szIssuerName;
}

///////////////////////////////////////////////////////////////////////////
//	GetSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetSubjectName()
{
//	_TRACE (1, L"Entering CCertificate::GetSubjectName\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		// Decode subject name if not already present
		if ( m_szSubjectName.IsEmpty () )
		{
			m_szSubjectName = ::GetNameString (m_pCertContext, 0);
		}
	}
	else
		return _T("");

//	_TRACE (-1, L"Leaving CCertificate::GetSubjectName\n");
	return m_szSubjectName;
}

///////////////////////////////////////////////////////////////////////////
//	GetValidNotBefore ()
//
//	pszDateTime (IN / OPTIONAL)	 - returns the formatted date and time.
//	cbDateTime	(IN / OUT)		 - If pszDateTime is NULL, then the required length
//								of pszDateTime is returned.  
//								Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetValidNotBefore()
{
//	_TRACE (1, L"Entering CCertificate::GetValidNotBefore\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		// Format date/time string if not already present
		if ( m_szValidNotBefore.IsEmpty () )
		{
			HRESULT	hResult = FormatDate (m_pCertInfo->NotBefore, m_szValidNotBefore);
			if ( !SUCCEEDED (hResult) )
				return _T("");
		}
	}
	else
		return _T("");

//	_TRACE (-1, L"Leaving CCertificate::GetValidNotBefore\n");
	return m_szValidNotBefore;
}

///////////////////////////////////////////////////////////////////////////
//	GetValidNotAfter ()
//
//	pszDateTime (IN / OPTIONAL)	 - returns the formatted date and time.
//	cbDateTime	(IN / OUT)		 - If pszDateTime is NULL, then the required length
//								of pszDateTime is returned.  
//								Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetValidNotAfter ()
{
//	_TRACE (1, L"Entering CCertificate::GetValidNotAfter\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		// Format date/time string if not already present
		if ( m_szValidNotAfter.IsEmpty () )
		{
			HRESULT	hResult = FormatDate (m_pCertInfo->NotAfter, m_szValidNotAfter);
			if ( !SUCCEEDED (hResult) )
				m_szValidNotAfter = _T("");
		}
	}
	else
		m_szValidNotAfter = _T("");

//	_TRACE (-1, L"Leaving CCertificate::GetValidNotAfter\n");
	return m_szValidNotAfter;
}


CString CCertificate::GetEnhancedKeyUsage ()
{
//	_TRACE (1, L"Entering CCertificate::GetEnhancedKeyUsage\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		// Format date/time string if not already present
		if ( m_szEnhancedKeyUsage.IsEmpty () )
		{
			FormatEnhancedKeyUsagePropertyString (
					m_szEnhancedKeyUsage);
		}
	}
	else
		m_szEnhancedKeyUsage = _T("");

//	_TRACE (-1, L"Leaving CCertificate::GetEnhancedKeyUsage\n");
	return m_szEnhancedKeyUsage;
}


bool CCertificate::FormatEnhancedKeyUsagePropertyString (CString& string)
{
//	_TRACE (1, L"Entering CCertificate::FormatEnhancedKeyUsagePropertyString\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	BOOL	bReturn = TRUE;
	DWORD	cbUsage = 0;


	bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
			NULL, &cbUsage);
	if ( bReturn )
	{
		CString	usageName;

		PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) ::LocalAlloc (LPTR, cbUsage);
		if ( pUsage )
		{
			bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
					pUsage, &cbUsage);
			if ( bReturn )
			{
				if ( !pUsage->cUsageIdentifier )
				{
					switch (GetLastError ())
					{
					case CRYPT_E_NOT_FOUND:
						VERIFY (string.LoadString (IDS_ANY));
						break;

					case 0:
						VERIFY (string.LoadString (IDS_NONE));
						break;

					default:
						break;
					}
				}
				else
				{
					for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
					{
						if ( MyGetOIDInfo (usageName, pUsage->rgpszUsageIdentifier[dwIndex]) )
						{
							// add delimeter if not first iteration
							if ( dwIndex )
								string += _T(", ");
							string += usageName;
						}
					}
				}
			}
			else
			{
				switch (GetLastError ())
				{
				case CRYPT_E_NOT_FOUND:
					VERIFY (string.LoadString (IDS_ANY));
					break;

				case 0:
					VERIFY (string.LoadString (IDS_NONE));
					break;

				default:
					break;
				}
			}

			::LocalFree (pUsage);
		}
		else
		{
			bReturn = FALSE;
		}
	}
	else
	{
		switch (GetLastError ())
		{
		case CRYPT_E_NOT_FOUND:
			VERIFY (string.LoadString (IDS_ANY));
			break;

		case 0:
			VERIFY (string.LoadString (IDS_NONE));
			break;

		default:
			break;
		}
	}

//	_TRACE (-1, L"Leaving CCertificate::FormatEnhancedKeyUsagePropertyString\n");
    return bReturn ? true : false;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateIssuerName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetAlternateIssuerName ()
{
//	_TRACE (1, L"Entering CCertificate::GetAlternateIssuerName\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		if ( !(m_fieldChecked & FIELD_ISSUER_ALT_NAME) )
		{
			HRESULT	hResult = ConvertAltNameToString (_T(szOID_ISSUER_ALT_NAME),
					CERT_ALT_NAME_URL, m_szAltIssuerName);
			ASSERT (SUCCEEDED (hResult));
			if ( !SUCCEEDED (hResult) )
				m_szAltIssuerName = _T("");
			m_fieldChecked |= FIELD_ISSUER_ALT_NAME;
		}
	}
	else
		m_szAltIssuerName = _T("");

//	_TRACE (-1, L"Leaving CCertificate::GetAlternateIssuerName\n");
	return m_szAltIssuerName;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetAlternateSubjectName ()
{
//	_TRACE (1, L"Entering CCertificate::GetAlternateSubjectName\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		if ( !(m_fieldChecked & FIELD_SUBJECT_ALT_NAME) )
		{
			HRESULT	hResult = ConvertAltNameToString (_T(szOID_SUBJECT_ALT_NAME),
					CERT_ALT_NAME_URL, m_szAltSubjectName);
			if ( !SUCCEEDED (hResult) )
				m_szAltSubjectName = _T("");
			m_fieldChecked |= FIELD_SUBJECT_ALT_NAME;
		}
	}
	else
		m_szAltSubjectName = _T("");

//	_TRACE (-1, L"Leaving CCertificate::GetAlternateSubjectName\n");
	return m_szAltSubjectName;
}

///////////////////////////////////////////////////////////////////////////
//	GetSerialNumber ()
//
//	pszSerNum (IN / OPTIONAL)	- returns the alternate issuer name.  An empty 
//									string is a valid return value
//	cbSerNum (IN / OUT)			- If pszSerNum is NULL, then the required length
//									of pszSerNum is returned.  
//									Otherwise, contains the length of pszSerNum.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetSerialNumber ()
{
//	_TRACE (1, L"Entering CCertificate::GetSerialNumber\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		// Decode issuer name if not already present
		if ( m_szSerNum.IsEmpty () )
		{
            LPWSTR pwszText = 0;

            if ( SUCCEEDED (FormatSerialNoString (&pwszText, & (m_pCertInfo->SerialNumber))) )
            {
                m_szSerNum = pwszText;
                CoTaskMemFree (pwszText);
            }
		}
	}
	else
		m_szSerNum = _T("");
	
//	_TRACE (-1, L"Leaving CCertificate::GetSerialNumber\n");
	return m_szSerNum;
}

//////////////////////////////////////////////////////////////////////////////
//	ConvertAltNameToString ()
//
//  szOID (IN)			- The OID of the alternate name to retrieve
//	dwNameChoice (IN)	- The type of alternate name to return
//	altName (OUT)		- The version of the desired alternate name indicated
//							by dwNameChoice
//////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::ConvertAltNameToString(LPCWSTR szOID, const DWORD dwNameChoice, CString & altName)
{
//	_TRACE (1, L"Entering CCertificate::ConvertAltNameToString\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	HRESULT	hResult = S_OK;


	// Iterate through the extensions until the one indicated by the
	// passed-in szOID is found.
	for (DWORD	index = 0; index < m_pCertInfo->cExtension; index++)
	{
		ASSERT (m_pCertInfo->rgExtension);
		size_t	len = strlen (m_pCertInfo->rgExtension[index].pszObjId);
		LPWSTR	wcsObjId = new WCHAR[len];
		if ( wcsObjId )
		{
			::ZeroMemory (wcsObjId, len * sizeof (WCHAR));
			mbstowcs (wcsObjId,  m_pCertInfo->rgExtension[index].pszObjId, len);

			if ( !wcscmp (wcsObjId, szOID) )
			{
				CERT_ALT_NAME_INFO	nameInfo;
				DWORD				cbNameInfo = sizeof (CERT_ALT_NAME_INFO);

				BOOL	bResult = CryptDecodeObject(
						MY_ENCODING_TYPE,
						X509_ALTERNATE_NAME,	// in
						m_pCertInfo->rgExtension[index].Value.pbData,	// in
						m_pCertInfo->rgExtension[index].Value.cbData,	// in
						0,	// in
						(void *) &nameInfo,	// out
						&cbNameInfo);	// in/out
				ASSERT (bResult);
				if ( bResult )
				{
					//  We've found the right extension, now iterate through
					//	the alternate names until we find the desired type.
					for (DWORD	dwAltEntryIndex = 0; dwAltEntryIndex < nameInfo.cAltEntry; dwAltEntryIndex++)
					{
						if ( nameInfo.rgAltEntry[dwAltEntryIndex].dwAltNameChoice ==
								dwNameChoice )
						{
							altName = nameInfo.rgAltEntry[dwAltEntryIndex].pwszURL;
							break;
						}
					}
				}
				else
					hResult = E_UNEXPECTED;
				break;
			}
			delete [] wcsObjId;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}
	}

//	_TRACE (-1, L"Leaving CCertificate::ConvertAltNameToString\n");
	return hResult;
}

VOID CCertificate::DataToHex(PBYTE pSrc, CString & dest, int cb, bool bIncludeSpaces)
{
//	_TRACE (1, L"Entering CCertificate::DataToHex\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	unsigned char ch = 0;
	TCHAR	szDest[3];
	UINT	uLen = 0;

	dest.Empty ();

	while (cb-- > 0) 
	{
#pragma warning (once: 4244)		
        ch = 0x00FF & (unsigned char) (*pSrc++);
		wsprintf(szDest, _T("%02X"), ch);
		dest += szDest;
		uLen++;
		if ( bIncludeSpaces && !(uLen % 2) && cb )
			dest += _T(" ");
	}
//	_TRACE (-1, L"Leaving CCertificate::DataToHex\n");
}


CCertStore* CCertificate::GetCertStore() const	
{
//	_TRACE (0, L"Entering and leaving CCertificate::GetCertStore\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	return m_pCertStore;
}

PCCERT_CONTEXT CCertificate::GetCertContext() const
{
//	_TRACE (0, L"Entering and leaving CCertificate::GetCertContext\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	return m_pCertContext;
}

bool CCertificate::IsValid()
{
//	_TRACE (1, L"Entering CCertificate::IsValid\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	bool		bIsValid = false;
 	ASSERT (m_pCertInfo);
	if ( m_pCertInfo )
	{
		FILETIME	systemTime;


		::GetSystemTimeAsFileTime (&systemTime);
		LONG	lBefore = ::CompareFileTime (&m_pCertInfo->NotBefore, &systemTime);
		LONG	lAfter = ::CompareFileTime (&systemTime, &m_pCertInfo->NotAfter);
		if ( lBefore < 1 && lAfter < 1 )
			bIsValid = true;
	}

//	_TRACE (-1, L"Leaving CCertificate::IsValid\n");
	return bIsValid;
}




const SPECIAL_STORE_TYPE CCertificate::GetStoreType () const
{
//	_TRACE (0, L"Entering and leaving CCertificate::GetStoreType\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    if ( m_pCertStore )
    	return m_pCertStore->GetStoreType ();
    else
        return NO_SPECIAL_TYPE;
}

void CCertificate::Refresh()
{
//	_TRACE (1, L"Entering CCertificate::Refresh\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	// Clearing all fields forces rereading of the data.
	m_szAltIssuerName = L"";
	m_szAltSubjectName = L"";
	m_szAuthorityKeyID = L"";
	m_szEnhancedKeyUsage = L"";
	m_szFriendlyName = L"";
	m_szIssuerName = L"";
	m_szMD5Hash = L"";
	m_szPolicyURL = L"";
	m_szSerNum = L"";
	m_szSHAHash = L"";
	m_szSubjectKeyID = L"";
	m_szSubjectName = L"";
	m_szValidNotAfter = L"";
	m_szValidNotBefore = L"";
	m_fieldChecked = 0;
//	_TRACE (-1, L"Leaving CCertificate::Refresh\n");
}

CString CCertificate::GetMD5Hash()
{
//	_TRACE (1, L"Entering CCertificate::GetMD5Hash\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
 	ASSERT (m_pCertContext);
	if ( m_pCertContext && m_szMD5Hash.IsEmpty ())
	{
		m_szMD5Hash = GetGenericHash (CERT_MD5_HASH_PROP_ID);
	}
//	_TRACE (-1, L"Leaving CCertificate::GetMD5Hash\n");
	return m_szMD5Hash;
}

CString CCertificate::GetSHAHash()
{
//	_TRACE (1, L"Entering CCertificate::GetSHAHash\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
 	ASSERT (m_pCertContext);
	if ( m_pCertContext && m_szSHAHash.IsEmpty ())
	{
		m_szSHAHash = GetGenericHash (CERT_SHA1_HASH_PROP_ID);
	}
//	_TRACE (-1, L"Leaving CCertificate::GetSHAHash\n");
	return m_szSHAHash;
}



CString CCertificate::GetGenericHash(DWORD dwPropId)
{
//	_TRACE (1, L"Entering CCertificate::GetGenericHash\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	CString	szHash;


	DWORD	cbData = 0;
	BOOL	bReturn = ::CertGetCertificateContextProperty (
			m_pCertContext,
			dwPropId,
			NULL,
			&cbData);
	if ( bReturn )
	{
		cbData += 2;  // for null terminator
		BYTE* pCertHash = new BYTE[cbData];
		if ( pCertHash )
		{
			::ZeroMemory (pCertHash, cbData);
			bReturn = CertGetCertificateContextProperty (
					m_pCertContext,
					dwPropId,
					pCertHash,
					&cbData);
			ASSERT (bReturn);
			if ( bReturn )
			{
				DataToHex (pCertHash, szHash, cbData, false);
			}
			delete [] pCertHash;
		}
	}
//	_TRACE (-1, L"Leaving CCertificate::GetGenericHash\n");
	return szHash;	
}


int CCertificate::CompareExpireDate(const CCertificate & cert) const
{
//	_TRACE (1, L"Entering CCertificate::CompareExpireDate\n");
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	int	compVal = 0;

	ASSERT (m_pCertInfo && cert.m_pCertInfo);
	if ( m_pCertInfo && cert.m_pCertInfo )
	{
		compVal = ::CompareFileTime (&m_pCertInfo->NotAfter, 
				&cert.m_pCertInfo->NotAfter);
	}

//	_TRACE (-1, L"Leaving CCertificate::CompareExpireDate\n");
	return compVal;
}

bool CCertificate::CanDelete()
{
//	_TRACE (1, L"Entering CCertificate::CanDelete\n");
	if ( m_pCertContext && !(m_fieldChecked & FIELD_CAN_DELETE) )
	{	
		DWORD	dwAccessFlags = 0;
		DWORD	cbData = sizeof (DWORD);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_ACCESS_STATE_PROP_ID,
				&dwAccessFlags,
				&cbData);
		if ( bResult )
		{
			if ( dwAccessFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG )
				m_bCanDelete = true;
		}
		m_fieldChecked |= FIELD_CAN_DELETE;
    }

//	_TRACE (-1, L"Leaving CCertificate::CanDelete\n");
	return m_bCanDelete;
}

bool CCertificate::IsReadOnly()
{
	bool	bResult = false;
	
    if ( m_pCertStore )
	    bResult = (m_pCertStore->IsReadOnly () || !CanDelete ());

	return bResult;
}

bool CCertificate::IsArchived()
{
//	_TRACE (1, L"Entering CCertificate::IsArchived\n");
	if ( m_pCertContext && !(m_fieldChecked & FIELD_IS_ARCHIVED) )
	{	
		DWORD	cbData = sizeof (DWORD);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_ARCHIVED_PROP_ID,
				NULL,
				&cbData);
		if ( bResult )
		{
			m_bIsArchived = true;
		}
		else
			m_bIsArchived = false;
		m_fieldChecked |= FIELD_IS_ARCHIVED;
    }

//	_TRACE (-1, L"Leaving CCertificate::IsArchived\n");
	return m_bIsArchived;
}

BOOL CCertificate::DeleteFromStore(bool bDoCommit)
{
	_TRACE (1, L"Entering CCertificate::DeleteFromStore\n");
	BOOL	bResult = FALSE;

    if ( m_pCertStore )
    {
	    PCCERT_CONTEXT pCertContext = GetNewCertContext ();
	    if ( pCertContext )
	    {
		    bResult = ::CertDeleteCertificateFromStore (pCertContext);
		    if ( bResult )
		    {
			    m_pCertStore->InvalidateCertCount ();
			    m_pCertStore->SetDirty ();

                if ( bDoCommit )
                {
			        HRESULT hr = m_pCertStore->Commit ();
			        if ( SUCCEEDED (hr) )
				        m_pCertStore->Resync ();
			        else
				        bResult = FALSE;
                }
                m_pCertStore->Release ();
                m_pCertStore = 0;
		    }
	    }
    }

	_TRACE (-1, L"Leaving CCertificate::DeleteFromStore\n");
	return bResult;
}

PCCERT_CONTEXT CCertificate::GetNewCertContext()
{
	PCCERT_CONTEXT	pCertContext = 0;

    if ( m_pCertStore )
    {
	    HCERTSTORE		hCertStore = m_pCertStore->GetStoreHandle ();
	    if ( hCertStore )
	    {
		    DWORD	cbData = 20;
		    BYTE	certHash[20];
		    BOOL bReturn = ::CertGetCertificateContextProperty (
				    m_pCertContext,
				    CERT_SHA1_HASH_PROP_ID,
				    &certHash,
				    &cbData);
		    ASSERT (bReturn);
		    if ( bReturn )
		    {
			    CRYPT_DATA_BLOB	blob = {sizeof (certHash), certHash};
			    pCertContext = CertFindCertificateInStore(
				    hCertStore,
				    0,
				    0,
				    CERT_FIND_SHA1_HASH,
				    &blob,
				    0);
			    if ( pCertContext )
			    {
				    ::CertFreeCertificateContext (m_pCertContext);
				    m_pCertContext = ::CertDuplicateCertificateContext (pCertContext);
			    }
		    }
	    }
    }

	return pCertContext;
}

CString CCertificate::FormatStatus()
{
    CString status;

	status.FormatMessage (L"%1  %2",
			(IsReadOnly () ? L"R" : L" "),
			(IsArchived () ? L"A" : L" "));

    return status;
}



//////////////////////////////////////////////////////////////////////////////////////
// Stolen from private\ispu\ui\cryptui\frmtutil.cpp
//////////////////////////////////////////////////////////////////////////////////////
const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

HRESULT CCertificate::FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob)
{
	if ( !ppString || !pblob )
		return E_POINTER;

    DWORD                 i = 0;
    LPBYTE                pb;
    DWORD                 numCharsInserted = 0;

    //
    // calculate size needed
    //
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb--;
            numCharsInserted += 2;
        }
    }

    if (NULL == (*ppString = (LPWSTR) CoTaskMemAlloc (i+sizeof(WCHAR))))
    {
        return E_OUTOFMEMORY;
    }

    // fill the buffer
    i=0;
    numCharsInserted = 0;
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        if (numCharsInserted == 4)
        {
            (*ppString)[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            (*ppString)[i++] = RgwchHex[*pb & 0x0f];
            pb--;
            numCharsInserted += 2;
        }
    }
    (*ppString)[i] = 0;

    return S_OK;
}


CString CCertificate::GetDescription()
{
	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	if ( m_pCertContext && m_szDescription.IsEmpty () )
	{	
		AFX_MANAGE_STATE (AfxGetStaticModuleState ());
		DWORD	cbData = 0;
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_DESCRIPTION_PROP_ID,
				NULL,
				&cbData);
		if ( bResult )
		{
			LPWSTR	pszName = new WCHAR[cbData];
			if ( pszName )
			{
				::ZeroMemory (pszName, cbData*sizeof (WCHAR));
				bResult = ::CertGetCertificateContextProperty (
						m_pCertContext,
						CERT_DESCRIPTION_PROP_ID,
						pszName,
						&cbData);
				ASSERT (bResult);
				if ( bResult )
				{
					m_szDescription = pszName;
				}
				delete [] pszName;
			}
		}
		else
		{
            DWORD   dwErr = GetLastError ();
			if ( CRYPT_E_NOT_FOUND == dwErr )
			{
				_TRACE (0, L"CertGetCertificateContextProperty (CERT_DESCRIPTION_PROP_ID) found no description.\n");
			}
			else
			{
				_TRACE (0, L"CertGetCertificateContextProperty (CERT_DESCRIPTION_PROP_ID) failed: 0x%x\n", dwErr);
			}
		}
    }
	return m_szDescription;
}

HRESULT CCertificate::SetDescription(const CString &szDescription)
{
    _TRACE (1, L"Entering CCertificate::SetDescription (%s)\n", 
            (PCWSTR) szDescription);
    HRESULT         hr = S_OK;
    CRYPT_DATA_BLOB cryptDataBlob;
    ::ZeroMemory (&cryptDataBlob, sizeof (CRYPT_DATA_BLOB));
    cryptDataBlob.pbData = (LPBYTE) (PCWSTR) szDescription;
    cryptDataBlob.cbData = (DWORD) (wcslen (szDescription) + 1) * sizeof (WCHAR);
 
    BOOL bResult = ::CertSetCertificateContextProperty (m_pCertContext,
            CERT_DESCRIPTION_PROP_ID, 0, &cryptDataBlob);
    ASSERT (bResult);
    if ( bResult )
    {
        m_szDescription = szDescription;
    }
    else
    {
        DWORD dwErr = GetLastError ();
        _TRACE (0, L"CertSetCertificateContextProperty (CERT_DESCRIPTION_PROP_ID, %s) failed: %d\n",
                (PCWSTR) szDescription, dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (1, L"Entering CCertificate::SetDescription (%s): 0x%x\n", 
            (PCWSTR) szDescription, hr);
    return hr;
}

HRESULT CCertificate::SetLastModified ()
{
    HRESULT hr = S_OK;

    if ( m_pCertContext )
    {
        SYSTEMTIME  st;
        FILETIME    ft;

        GetSystemTime (&st);

        VERIFY (SystemTimeToFileTime(&st, &ft));
        CRYPT_DATA_BLOB cryptDataBlob;
        ::ZeroMemory (&cryptDataBlob, sizeof (CRYPT_DATA_BLOB));
        cryptDataBlob.pbData = (LPBYTE) &ft;
        cryptDataBlob.cbData = sizeof (FILETIME);

        BOOL bResult = ::CertSetCertificateContextProperty (
                m_pCertContext,
                CERT_DATE_STAMP_PROP_ID, 0, &cryptDataBlob);
        ASSERT (bResult);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CertSetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) failed: %d\n",
                    dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }

    return hr;
}

CString CCertificate::GetShortLastModified ()
{
    return GetLastModified (DATE_SHORTDATE);
}

CString CCertificate::GetLongLastModified ()
{
    return GetLastModified (DATE_LONGDATE);
}

///////////////////////////////////////////////////////////////////////////////
//
// Method:  GetLastModified
// Purpose: Get the date stamp property of the cert and format for display
// Inputs:  dwDateFlags - as defined in SDK, specify DATE_SHORTDATE or 
//              DATE_LONGDATE
//          bRetryIfNotPresent - to prevent stack overflow. Used if the property
//              is not set, to set the property to the current time and
//              retrieve again.
//
// Output:  locale-formatted date and time string
//
///////////////////////////////////////////////////////////////////////////////
CString CCertificate::GetLastModified(DWORD dwDateFlags, bool bRetryIfNotPresent /* true */)
{
    CString szDate;

	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	if ( m_pCertContext )
	{	
		AFX_MANAGE_STATE (AfxGetStaticModuleState ());
        FILETIME    ft;
		DWORD	    cbData = sizeof (ft);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_DATE_STAMP_PROP_ID,
				&ft,
				&cbData);
		if ( bResult )
		{
            VERIFY (SUCCEEDED (FormatDate (ft, szDate, dwDateFlags, true)) );
		}
		else
		{
            if ( bRetryIfNotPresent )
            {
                if ( SUCCEEDED (SetLastModified ()) )  // not present - set the value
                {
                    szDate = GetLastModified (dwDateFlags, false);
                    CCertStore* pCertStore = GetCertStore ();
                    if ( pCertStore )
                        pCertStore->Commit ();
                }
            }

            DWORD   dwErr = GetLastError ();
			if ( CRYPT_E_NOT_FOUND == dwErr )
			{
				_TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) found no property.\n");
			}
			else
			{
				_TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) failed: 0x%x\n", dwErr);
			}
		}
    }

	return szDate;
}

HRESULT CCertificate::GetLastModifiedFileTime (FILETIME& ft)
{
    HRESULT hr = S_OK;

	ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
	ASSERT (m_pCertContext);
	if ( m_pCertContext )
	{	
		DWORD	    cbData = sizeof (ft);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_DATE_STAMP_PROP_ID,
				&ft,
				&cbData);
		if ( !bResult )
		{
            DWORD   dwErr = GetLastError ();
			if ( CRYPT_E_NOT_FOUND == dwErr )
			{
				_TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) found no property.\n");
			}
			else
			{
				_TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) failed: 0x%x\n", dwErr);
			}
            hr = HRESULT_FROM_WIN32 (dwErr);
		}
    }
    else
        hr = E_FAIL;

	return hr;
}

BOOL CCertificate::operator==(CCertificate& rCert)
{
    if ( GetMD5Hash () == rCert.GetMD5Hash () )
        return TRUE;
    else
        return FALSE;
}

// NTRAID# 247237	Cert UI: Cert Snapin: Certificates snapin should show  template name
CString CCertificate::GetTemplateName()
{
    if ( m_pCertInfo && !(m_fieldChecked & FIELD_TEMPLATE_NAME) )
    {
	    // Iterate through the extensions until szOID_CERTIFICATE_TEMPLATE is found.
	    for (DWORD	index = 0; index < m_pCertInfo->cExtension; index++)
	    {
		    ASSERT (m_pCertInfo->rgExtension);
		    if ( !strcmp (szOID_CERTIFICATE_TEMPLATE, m_pCertInfo->rgExtension[index].pszObjId) )
            {
                m_szTemplateName = DecodeV2TemplateName (&(m_pCertInfo->rgExtension[index]));
                break;
            } 
 		    else if ( !strcmp (szOID_ENROLL_CERTTYPE_EXTENSION, m_pCertInfo->rgExtension[index].pszObjId) )
            {
                m_szTemplateName = DecodeV1TemplateName (&(m_pCertInfo->rgExtension[index]));
                break;
            }
        }
        m_fieldChecked |= FIELD_TEMPLATE_NAME;
    }

    return m_szTemplateName;
}

// NTRAID# 247237	Cert UI: Cert Snapin: Certificates snapin should show  template name
CString CCertificate::DecodeV1TemplateName (PCERT_EXTENSION pCertExtension)
{
    CString szTemplateName;
    ASSERT (pCertExtension);
    if ( pCertExtension )
    {
        DWORD	cbValue = 0;

	    if ( ::CryptDecodeObject(
			    CRYPT_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pCertExtension->Value.pbData,
			    pCertExtension->Value.cbData,
			    0,
			    0,
			    &cbValue) )
	    {
		    CERT_NAME_VALUE* pCNValue = (CERT_NAME_VALUE*) 
			    ::LocalAlloc(LPTR, cbValue);
		    if ( pCNValue )
		    {
			    if ( ::CryptDecodeObject(
					    CRYPT_ASN_ENCODING,
					    X509_UNICODE_ANY_STRING,
					    pCertExtension->Value.pbData,
					    pCertExtension->Value.cbData,
					    0,
					    pCNValue,
					    &cbValue) )
			    {
				    szTemplateName = (LPWSTR) pCNValue->Value.pbData;

                    // NTRAID# 395173 Certificates Snapin:The column "
                    // Certificate Template" should contain value of "Template 
                    // Name" for V1 templates
                    HCERTTYPE   hCertType = 0;
                    HRESULT hr = CAFindCertTypeByName (szTemplateName,
                            NULL,
                            CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES,
                            &hCertType);
                    if ( SUCCEEDED (hr) )
                    {
                        PWSTR* rgwszProp = 0;

                        hr = CAGetCertTypePropertyEx (hCertType, 
                            CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
                        if ( SUCCEEDED (hr) && rgwszProp )
                        {
                            szTemplateName = *rgwszProp;
                            CAFreeCertTypeProperty (hCertType, rgwszProp);
                        }
                        else
                        {
                            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
                        }

                        CACloseCertType (hCertType);
                    }
			    }
	            else
	            {
                    _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                            GetLastError ());
	            }
			    ::LocalFree (pCNValue);
		    }
	    }
	    else
	    {
            _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                    GetLastError ());
	    }
    }

    return szTemplateName;
}

// NTRAID# 247237	Cert UI: Cert Snapin: Certificates snapin should show  template name
CString CCertificate::DecodeV2TemplateName (PCERT_EXTENSION pCertExtension)
{
    CString szTemplateName;
    ASSERT (pCertExtension);
    if ( pCertExtension )
    {
        DWORD   cbData = 0;
   
        if ( CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERTIFICATE_TEMPLATE,
                              pCertExtension->Value.pbData,
                              pCertExtension->Value.cbData,
                              0,
                              NULL,
                              &cbData) )
        {
            CERT_TEMPLATE_EXT* pbTemplate = (CERT_TEMPLATE_EXT*) LocalAlloc(LPTR, cbData);
            if ( pbTemplate )
            {
                if ( CryptDecodeObject(X509_ASN_ENCODING,
                                      szOID_CERTIFICATE_TEMPLATE,
                                      pCertExtension->Value.pbData,
                                      pCertExtension->Value.cbData,
                                      0,
                                      pbTemplate,
                                      &cbData) )
                {
                    CString text;
                    CString description;

                    //copy the extension oid
                    if ( pbTemplate->pszObjId )
                    {
                        MyGetOIDInfo (szTemplateName, pbTemplate->pszObjId);
                    }
                }
	            else
	            {
                    _TRACE (0, L"CryptDecodeObject (X509_ASN_ENCODING, szOID_CERTIFICATE_TEMPLATE, ...) failed: 0x%x\n",
                            GetLastError ());
	            }
                LocalFree (pbTemplate);
            }
        }
	    else
	    {
            _TRACE (0, L"CryptDecodeObject (X509_ASN_ENCODING, szOID_CERTIFICATE_TEMPLATE, ...) failed: 0x%x\n",
                    GetLastError ());
	    }
    }

    return szTemplateName;
}


void CCertificate::SetStore (CCertStore* pStore)
{
    if ( !m_pCertStore && !pStore )
        return;

    if ( m_pCertStore && pStore )
    {
        if ( *m_pCertStore == *pStore )
            return;  // don't change if the same
    }

    if ( m_pCertStore )
    {
        m_pCertStore->Release ();
        m_pCertStore = 0;
    }

    

    if ( pStore )
    {
        m_pCertStore = pStore;
        m_pCertStore->AddRef ();
    }

    if ( m_pCertContext )
    {
        PCCERT_CONTEXT pCertContext = GetNewCertContext ();
        ::CertFreeCertificateContext (m_pCertContext);
       	m_pCertInfo = 0;
	    m_pCertContext = 0;
        
        m_pCertContext = pCertContext;
        if ( m_pCertContext )
            m_pCertInfo = m_pCertContext->pCertInfo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\certmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       CertMgr.cpp
//
//  Contents:   Implementation of DLL Exports
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <initguid.h>
#include <gpedit.h>
#include "CertMgr_i.c"
#include "about.h"		// CCertMgrAbout
#include "compdata.h" // CCertMgrSnapin, CCertMgrExtension
#pragma warning(push, 3)
#include <compuuid.h> // UUIDs for Computer Management
#include "uuids.h"
#include <efsstruc.h>
#include <sceattch.h>	// For Security Configuratino Editor snapin
#include <ntverp.h>		// VER_PRODUCTVERSION_STR, VERS_COMPANYNAME_STR
#include <typeinfo.h>
#pragma warning(pop)

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


bool g_bSchemaIsW2K = false;

USE_HANDLE_MACROS ("CERTMGR (CertMgr.cpp)")                                        

LPCWSTR CM_HELP_TOPIC = L"sag_CMtopNode.htm";  
LPCWSTR CM_HELP_FILE = L"certmgr.chm"; 
LPCWSTR CM_LINKED_HELP_FILE = L"CMconcepts.chm";
LPCWSTR PKP_LINKED_HELP_FILE = L"SecSetConcepts.chm";
LPCWSTR PKP_HELP_FILE = L"secsettings.chm";
LPCWSTR PKP_HELP_TOPIC = L"sag_secsettopnode.htm";
LPCWSTR SAFER_WINDOWS_HELP_FILE = L"SAFER.chm";
LPCWSTR SAFER_WINDOWS_LINKED_HELP_FILE = L"SAFERconcepts.chm";
LPCWSTR SAFER_HELP_TOPIC = L"SAFER_topnode.htm";
LPCWSTR CM_CONTEXT_HELP = L"\\help\\certmgr.hlp";
LPCWSTR WINDOWS_HELP = L"windows.hlp";

//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[CERTMGR_NUMTYPES] =
{
	{ // CERTMGR_SNAPIN
		structuuidNodetypeSnapin,
		lstruuidNodetypeSnapin    },
	{  // CERTMGR_CERTIFICATE
		structuuidNodetypeCertificate,
		lstruuidNodetypeCertificate  },
	{  // CERTMGR_LOG_STORE
		structuuidNodetypeLogStore,
		lstruuidNodetypeLogStore  },
	{  // CERTMGR_PHYS_STORE
		structuuidNodetypePhysStore,
		lstruuidNodetypePhysStore  },
	{  // CERTMGR_USAGE
		structuuidNodetypeUsage,
		lstruuidNodetypeUsage  },
	{  // CERTMGR_CRL_CONTAINER
		structuuidNodetypeCRLContainer,
		lstruuidNodetypeCRLContainer  },
	{  // CERTMGR_CTL_CONTAINER
		structuuidNodetypeCTLContainer,
		lstruuidNodetypeCTLContainer  },
	{  // CERTMGR_CERT_CONTAINER
		structuuidNodetypeCertContainer,
		lstruuidNodetypeCertContainer  },
	{  // CERTMGR_CRL
		structuuidNodetypeCRL,
		lstruuidNodetypeCRL  },
	{  // CERTMGR_CTL
		structuuidNodetypeCTL,
		lstruuidNodetypeCTL  },
	{  // CERTMGR_AUTO_CERT_REQUEST
		structuuidNodetypeAutoCertRequest,
		lstruuidNodetypeAutoCertRequest  },
	{ // CERTMGR_CERT_POLICIES_USER,
		structuuidNodetypeCertPoliciesUser,
		lstruiidNodetypeCertPoliciesUser },
	{ // CERTMGR_CERT_POLICIES_COMPUTER,
		structuuidNodetypeCertPoliciesComputer,
		lstruiidNodetypeCertPoliciesComputer },
	{  // CERTMGR_LOG_STORE_GPE
		structuuidNodetypeLogStore,
		lstruuidNodetypeLogStore  },
	{  // CERTMGR_LOG_STORE_RSOP
		structuuidNodetypeLogStore,
		lstruuidNodetypeLogStore  },
    { // CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS
        structuuidNodetypePKPAutoenrollmentSettings,
            lstruiidNodetypePKPAutoenrollmentSettings },
    { // CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS
        0,
            0 },
    { // CERTMGR_SAFER_COMPUTER_ROOT
        structuuidNodetypeSaferComputerRoot,
            lstruiidNodetypeSaferComputerRoot },
    { // CERTMGR_SAFER_COMPUTER_LEVELS
        structuuidNodetypeSaferComputerLevels,
            lstruiidNodetypeSaferComputerLevels },
    { // CERTMGR_SAFER_COMPUTER_ENTRIES
        structuuidNodetypeSaferComputerEntries,
            lstruiidNodetypeSaferComputerEntries },
    { // CERTMGR_SAFER_USER_ROOT
        structuuidNodetypeSaferUserRoot,
            lstruiidNodetypeSaferUserRoot },
    { // CERTMGR_SAFER_USER_ENTRIES
        structuuidNodetypeSaferUserEntries,
            lstruiidNodetypeSaferUserEntries },
    { // CERTMGR_SAFER_USER_LEVELS
        structuuidNodetypeSaferUserLevels,
            lstruiidNodetypeSaferUserLevels },
    { // CERTMGR_SAFER_COMPUTER_LEVEL
        structuuidNodetypeSaferComputerLevel,
            lstruiidNodetypeSaferComputerLevel },
    { // CERTMGR_SAFER_USER_LEVEL
        structuuidNodetypeSaferUserLevel,
            lstruiidNodetypeSaferUserLevel },
    { // CERTMGR_SAFER_COMPUTER_ENTRY
        structuuidNodetypeSaferComputerEntry,
            lstruiidNodetypeSaferComputerEntry },
    { // CERTMGR_SAFER_USER_ENTRY
        structuuidNodetypeSaferUserEntry,
            lstruiidNodetypeSaferUserEntry },
    { // CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS
        structuuidNodetypeSaferTrustedPublishers,
            lstruiidNodetypeSaferTrustedPublisher },
    { // CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS
        0,
            0 },
    { // CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES
        structuuidNodetypeSaferDefinedFileTypes,
            lstruiidNodetypeSaferDefinedFileTypes },
    { // CERTMGR_SAFER_USER_DEFINED_FILE_TYPES
        0,
            0 },
    { // CERTMGR_SAFER_USER_ENFORCEMENT
        structuuidNodetypeSaferEnforcement,
            lstruiidNodetypeSaferEnforcement },
    { // CERTMGR_SAFER_COMPUTER_ENFORCEMENT
        0,
            0 }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = CERTMGR_NUMTYPES;


HINSTANCE	g_hInstance = 0;
CString		g_szFileName;
CComModule	_Module;

BEGIN_OBJECT_MAP (ObjectMap)
	OBJECT_ENTRY (CLSID_CertificateManager, CCertMgrSnapin)
	OBJECT_ENTRY (CLSID_CertificateManagerPKPOLExt, CCertMgrPKPolExtension)
	OBJECT_ENTRY (CLSID_CertificateManagerAbout, CCertMgrAbout)
	OBJECT_ENTRY (CLSID_PublicKeyPoliciesAbout, CPublicKeyPoliciesAbout)
    OBJECT_ENTRY (CLSID_SaferWindowsExtension, CSaferWindowsExtension)
    OBJECT_ENTRY (CLSID_SaferWindowsAbout, CSaferWindowsAbout)
END_OBJECT_MAP ()

class CCertMgrApp : public CWinApp
{
public:
	CCertMgrApp ();
	virtual BOOL InitInstance ();
	virtual int ExitInstance ();
private:
};

CCertMgrApp theApp;

CCertMgrApp::CCertMgrApp ()
{
	LPWSTR	pszCommandLine = _wcsupr (::GetCommandLine ());
	LPWSTR	pszParam = L"/CERTMGR:FILENAME=";
	size_t	len = wcslen (pszParam);

	LPWSTR	pszArg = wcsstr (pszCommandLine, pszParam);
	if ( !pszArg )
		pszParam = L"-CERTMGR:FILENAME=";
	if ( pszArg )
	{
		LPWSTR	pszDelimiters = 0;

		// jump past the name of the arg to get the value
		pszArg += len;
		//	Is the file name delimited by double quotes?  This could indicate 
		//	the presence of spaces in the name.  If so, skip the quote
		//	and look for the closing quote.  Otherwise, look for the next
		//	space, tab or NULL terminator.
		if (  L'\"' == pszArg[0] )
		{
			pszDelimiters = L"\"";
			pszArg++;
		}
		else
			pszDelimiters = L" \t\0";

		len = wcscspn (pszArg, pszDelimiters);
		* (pszArg + len) = 0;
		g_szFileName = pszArg;
	}
}


BOOL CCertMgrApp::InitInstance ()
{
#ifdef _MERGE_PROXYSTUB
	hProxyDll = m_hInstance;

#endif
	g_hInstance = m_hInstance;
	AfxSetResourceHandle (m_hInstance);
	_Module.Init (ObjectMap, m_hInstance);

#if DBG == 1
    CheckDebugOutputLevel ();
#endif 

    SHFusionInitializeFromModuleID (m_hInstance, 2);

	return CWinApp::InitInstance ();
}

int CCertMgrApp::ExitInstance ()
{
    SHFusionUninitialize();

    SetRegistryScope (0, false);
	_Module.Term ();

	return CWinApp::ExitInstance ();
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow (void)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	return (AfxDllCanUnloadNow ()==S_OK && _Module.GetLockCount ()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject (rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//const WCHAR g_szNameString[] = TEXT ("NameString");
//const WCHAR g_szNodeType[] = TEXT ("NodeType");


STDAPI DllRegisterServer (void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // NTRAID# 88502	intlext: mui: me common: crypto: certificate 's 
    // intended purpose string unlocalized
    // Unregister szOID_EFS_RECOVERY
    CRYPT_OID_INFO  oid;
    ::ZeroMemory (&oid, sizeof (CRYPT_OID_INFO));
    oid.cbSize = sizeof (CRYPT_OID_INFO);
    oid.pszOID = szOID_EFS_RECOVERY;
    oid.dwGroupId = CRYPT_ENHKEY_USAGE_OID_GROUP_ID;

    CryptUnregisterOIDInfo (&oid);

	// registers object, typelib and all interfaces in typelib
	HRESULT	hr = _Module.RegisterServer (TRUE);
	ASSERT (SUCCEEDED (hr));
	if ( E_ACCESSDENIED == hr )
	{
		CString	caption;
		CString text;
        CThemeContextActivator activator;

		VERIFY (caption.LoadString (IDS_REGISTER_CERTMGR));
		VERIFY (text.LoadString (IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTMGR));

		MessageBox (NULL, text, caption, MB_OK);
		return hr;
	}

    try 
    {
        CString			strGUID;
	    CString			snapinName;
	    CString			verProviderStr, verVersionStr;
	    AMC::CRegKey	rkSnapins;
	    BOOL			fFound = rkSnapins.OpenKeyEx (HKEY_LOCAL_MACHINE, SNAPINS_KEY);
	    ASSERT (fFound);
	    if ( fFound )
	    {
		    {
			    AMC::CRegKey	rkCertMgrSnapin;
			    hr = GuidToCString (&strGUID, CLSID_CertificateManager);
			    if ( FAILED (hr) )
			    {
				    ASSERT (FALSE);
				    return SELFREG_E_CLASS;
			    }
			    rkCertMgrSnapin.CreateKeyEx (rkSnapins, strGUID);
			    ASSERT (rkCertMgrSnapin.GetLastError () == ERROR_SUCCESS);
			    rkCertMgrSnapin.SetString (g_szNodeType, g_aNodetypeGuids[CERTMGR_SNAPIN].bstr);
			    VERIFY (snapinName.LoadString (IDS_CERTIFICATE_MANAGER_REGISTRY));
			    rkCertMgrSnapin.SetString (g_szNameString, (LPCWSTR) snapinName);
			    hr = GuidToCString (&strGUID, CLSID_CertificateManagerAbout);
			    if ( FAILED (hr) )
			    {
				    ASSERT (FALSE);
				    return SELFREG_E_CLASS;
			    }
			    rkCertMgrSnapin.SetString (L"About", strGUID);

			    size_t	len = strlen (VER_COMPANYNAME_STR);
			    len = mbstowcs (verProviderStr.GetBufferSetLength ((int) len),
							    VER_COMPANYNAME_STR, len);
			    rkCertMgrSnapin.SetString (L"Provider", verProviderStr);

			    len = strlen (VER_PRODUCTVERSION_STR);
			    len = mbstowcs (verVersionStr.GetBufferSetLength ((int)len),
							    VER_PRODUCTVERSION_STR, len);
			    rkCertMgrSnapin.SetString (L"Version", verVersionStr);

			    AMC::CRegKey rkCertMgrStandalone;
			    rkCertMgrStandalone.CreateKeyEx (rkCertMgrSnapin, g_szStandAlone);
			    ASSERT (rkCertMgrStandalone.GetLastError () == ERROR_SUCCESS);


			    AMC::CRegKey rkMyNodeTypes;
			    rkMyNodeTypes.CreateKeyEx (rkCertMgrSnapin, g_szNodeTypes);
			    ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
			    AMC::CRegKey rkMyNodeType;

			    for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
			    {
				    switch (i)
				    {
				    case CERTMGR_LOG_STORE_GPE:
				    case CERTMGR_LOG_STORE_RSOP:
				    case CERTMGR_AUTO_CERT_REQUEST:
				    case CERTMGR_CERT_POLICIES_USER:
				    case CERTMGR_CERT_POLICIES_COMPUTER:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS: // not necessary - just another kind of the same node
					    break;

                    // TODO: What to do with these?
                    case CERTMGR_SAFER_COMPUTER_ROOT:
                    case CERTMGR_SAFER_USER_ROOT:
                    case CERTMGR_SAFER_COMPUTER_LEVELS:
                    case CERTMGR_SAFER_USER_LEVELS:
                    case CERTMGR_SAFER_COMPUTER_ENTRIES:
                    case CERTMGR_SAFER_USER_ENTRIES:
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                        break;

                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
				    default:
                        if ( wcslen (g_aNodetypeGuids[i].bstr) )
                        {
    					    rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
	    				    ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
		    			    rkMyNodeType.CloseKey ();
                        }
					    break;
				    }
			    }

				//
				// BryanWal 5/18/00
				// 94793: MUI: MMC: Certificates snap-in stores its display 
				//				information in the registry
				//
				// MMC now supports NameStringIndirect
				//
				TCHAR achModuleFileName[MAX_PATH+20];
				if (0 < ::GetModuleFileName(
							 AfxGetInstanceHandle(),
							 achModuleFileName,
							 sizeof(achModuleFileName)/sizeof(TCHAR) ))
				{
					CString strNameIndirect;
					strNameIndirect.Format(L"@%s,-%d",
											achModuleFileName,
											IDS_CERTIFICATE_MANAGER_REGISTRY );
					rkCertMgrSnapin.SetString(L"NameStringIndirect",
											strNameIndirect );
				}

			    rkCertMgrSnapin.CloseKey ();
		    }

		    AMC::CRegKey rkNodeTypes;
		    fFound = rkNodeTypes.OpenKeyEx (HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
		    ASSERT (fFound);
		    if ( fFound )
		    {
			    AMC::CRegKey rkNodeType;

			    for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
			    {
				    switch (i)
				    {
				    // these types are not used in the primary snapin
				    case CERTMGR_LOG_STORE_GPE:
				    case CERTMGR_LOG_STORE_RSOP:
				    case CERTMGR_AUTO_CERT_REQUEST:
				    case CERTMGR_CERT_POLICIES_USER:
				    case CERTMGR_CERT_POLICIES_COMPUTER:
                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                    case CERTMGR_SAFER_COMPUTER_ROOT:
                    case CERTMGR_SAFER_USER_ROOT:
                    case CERTMGR_SAFER_COMPUTER_LEVELS:
                    case CERTMGR_SAFER_USER_LEVELS:
                    case CERTMGR_SAFER_COMPUTER_ENTRIES:
                    case CERTMGR_SAFER_USER_ENTRIES:
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
					    break;

				    default:
					    if ( wcslen (g_aNodetypeGuids[i].bstr) )
                        {
                            rkNodeType.CreateKeyEx (rkNodeTypes, g_aNodetypeGuids[i].bstr);
					        ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
					        rkNodeType.CloseKey ();
                        }
					    break;
				    }
			    }


			    if ( IsWindowsNT () )
			    {
                    {
				        // Public Key PoliciesSnap-in under Security Configuration Editor (SCE)
				        // Certificate Manager extends "Computer Settings" and 
				        // "User Settings" node
				        CString strCertMgrExtPKPolGUID;
				        hr = GuidToCString (&strCertMgrExtPKPolGUID, 
						        CLSID_CertificateManagerPKPOLExt);
				        if ( FAILED (hr) )
				        {
					        ASSERT (FALSE);
					        return SELFREG_E_CLASS;
				        }

				        VERIFY (snapinName.LoadString (IDS_CERT_MGR_SCE_EXTENSION_REGISTRY));
				        {
					        AMC::CRegKey rkCertMgrExtension;
					        rkCertMgrExtension.CreateKeyEx (rkSnapins, strCertMgrExtPKPolGUID);
					        ASSERT (rkCertMgrExtension.GetLastError () == ERROR_SUCCESS);
					        rkCertMgrExtension.SetString (g_szNameString, (LPCWSTR) snapinName);
					        hr = GuidToCString (&strGUID, CLSID_PublicKeyPoliciesAbout);
					        if ( FAILED (hr) )
					        {
						        ASSERT (FALSE);
						        return SELFREG_E_CLASS;
					        }
					        rkCertMgrExtension.SetString (L"About", strGUID);
					        rkCertMgrExtension.SetString (L"Provider", verProviderStr);
					        rkCertMgrExtension.SetString (L"Version", verVersionStr);


					        // Register the node types of the extension
					        AMC::CRegKey rkMyNodeTypes;
					        rkMyNodeTypes.CreateKeyEx (rkCertMgrExtension, g_szNodeTypes);
					        ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
					        AMC::CRegKey rkMyNodeType;
					        for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
					        {
						        switch (i)
						        {
						        // None of these are used in the Public Key Policy extension
 						        case CERTMGR_USAGE:
						        case CERTMGR_PHYS_STORE:
						        case CERTMGR_LOG_STORE:
						        case CERTMGR_CRL_CONTAINER:
						        case CERTMGR_CTL_CONTAINER:
						        case CERTMGR_CERT_CONTAINER:
						        case CERTMGR_CRL:
                                case CERTMGR_SAFER_COMPUTER_ROOT:
                                case CERTMGR_SAFER_USER_ROOT:
                                case CERTMGR_SAFER_COMPUTER_LEVELS:
                                case CERTMGR_SAFER_USER_LEVELS:
                                case CERTMGR_SAFER_COMPUTER_ENTRIES:
                                case CERTMGR_SAFER_USER_ENTRIES:
                                case CERTMGR_SAFER_COMPUTER_LEVEL:
                                case CERTMGR_SAFER_USER_LEVEL:
                                case CERTMGR_SAFER_COMPUTER_ENTRY:
                                case CERTMGR_SAFER_USER_ENTRY:
                                case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_ENFORCEMENT:
                                case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:

                                // not necessary - just another kind of the same node
                                case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
							        break;

						        default:
                                    if ( wcslen (g_aNodetypeGuids[i].bstr) )
                                    {
							            rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
							            ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
							            rkMyNodeType.CloseKey ();
                                    }
							        break;
						        }
					        }

						    //
						    // BryanWal 5/18/00
						    // 94793: MUI: MMC: Certificates snap-in stores its display 
						    //				information in the registry
						    //
						    // MMC now supports NameStringIndirect
						    //
						    TCHAR achModuleFileName[MAX_PATH+20];
						    if (0 < ::GetModuleFileName(
									     AfxGetInstanceHandle(),
									     achModuleFileName,
									     sizeof(achModuleFileName)/sizeof(TCHAR) ))
						    {
							    CString strNameIndirect;
							    strNameIndirect.Format(L"@%s,-%d",
													    achModuleFileName,
													    IDS_CERT_MGR_SCE_EXTENSION_REGISTRY );
							    rkCertMgrExtension.SetString( L"NameStringIndirect",
													    strNameIndirect );
						    }
					        rkCertMgrExtension.CloseKey ();
				        }

				        hr = GuidToCString (&strGUID, cNodetypeSceTemplate);
				        if ( FAILED (hr) )
				        {
					        ASSERT (FALSE);
					        return SELFREG_E_CLASS;
				        }
				        rkNodeType.CreateKeyEx (rkNodeTypes, strGUID); 
				        ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
				        if ( rkNodeType.GetLastError () == ERROR_SUCCESS )
				        {
					        AMC::CRegKey rkExtensions;
					        ASSERT (rkExtensions.GetLastError () == ERROR_SUCCESS);
					        rkExtensions.CreateKeyEx (rkNodeType, g_szExtensions);
					        AMC::CRegKey rkNameSpace;
					        rkNameSpace.CreateKeyEx (rkExtensions, g_szNameSpace);
					        ASSERT (rkNameSpace.GetLastError () == ERROR_SUCCESS);
					        rkNameSpace.SetString (strCertMgrExtPKPolGUID, (LPCWSTR) snapinName);
					        rkNodeType.CloseKey ();
				        }
				        else
					        return SELFREG_E_CLASS;
                    }


                    {
				        // SAFER Windows Snap-in under Security Configuration Editor (SCE)
				        // Certificate Manager extends "Computer Settings" and 
				        // "User Settings" node
				        CString strSaferWindowsExtensionGUID;
				        hr = GuidToCString (&strSaferWindowsExtensionGUID, 
						        CLSID_SaferWindowsExtension);
				        if ( FAILED (hr) )
				        {
					        ASSERT (FALSE);
					        return SELFREG_E_CLASS;
				        }

				        VERIFY (snapinName.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
				        {
					        AMC::CRegKey rkCertMgrExtension;
					        rkCertMgrExtension.CreateKeyEx (rkSnapins, strSaferWindowsExtensionGUID);
					        ASSERT (rkCertMgrExtension.GetLastError () == ERROR_SUCCESS);
					        rkCertMgrExtension.SetString (g_szNameString, (LPCWSTR) snapinName);
					        hr = GuidToCString (&strGUID, CLSID_SaferWindowsAbout);
					        if ( FAILED (hr) )
					        {
						        ASSERT (FALSE);
						        return SELFREG_E_CLASS;
					        }
					        rkCertMgrExtension.SetString (L"About", strGUID);
					        rkCertMgrExtension.SetString (L"Provider", verProviderStr);
					        rkCertMgrExtension.SetString (L"Version", verVersionStr);


					        // Register the node types of the extension
					        AMC::CRegKey rkMyNodeTypes;
					        rkMyNodeTypes.CreateKeyEx (rkCertMgrExtension, g_szNodeTypes);
					        ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
					        AMC::CRegKey rkMyNodeType;
					        for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
					        {
						        switch (i)
						        {
                                case CERTMGR_CERTIFICATE:
                                case CERTMGR_LOG_STORE:
                                case CERTMGR_PHYS_STORE:
                                case CERTMGR_USAGE:
                                case CERTMGR_CRL_CONTAINER:
                                case CERTMGR_CTL_CONTAINER:
                                case CERTMGR_CERT_CONTAINER:
                                case CERTMGR_CRL:
                                case CERTMGR_CTL:
                                case CERTMGR_AUTO_CERT_REQUEST:
                                case CERTMGR_CERT_POLICIES_USER:
                                case CERTMGR_CERT_POLICIES_COMPUTER:
                                case CERTMGR_LOG_STORE_GPE:
                                case CERTMGR_LOG_STORE_RSOP:
                                case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                                case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
							        // None of these are used in the Software Restriction Policies extension
							        break;

                                case CERTMGR_SAFER_COMPUTER_ROOT:
                                case CERTMGR_SAFER_USER_ROOT:
                                case CERTMGR_SAFER_COMPUTER_LEVELS:
                                case CERTMGR_SAFER_USER_LEVELS:
                                case CERTMGR_SAFER_COMPUTER_ENTRIES:
                                case CERTMGR_SAFER_USER_ENTRIES:
                                case CERTMGR_SAFER_COMPUTER_LEVEL:
                                case CERTMGR_SAFER_USER_LEVEL:
                                case CERTMGR_SAFER_COMPUTER_ENTRY:
                                case CERTMGR_SAFER_USER_ENTRY:						        
                                case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_ENFORCEMENT:
                                case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                                default:
                                    if ( g_aNodetypeGuids[i].bstr && wcslen (g_aNodetypeGuids[i].bstr) )
                                    {
							            rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
							            ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
							            rkMyNodeType.CloseKey ();
                                    }
							        break;
						        }
					        }

						    TCHAR achModuleFileName[MAX_PATH+20];
						    if (0 < ::GetModuleFileName(
									     AfxGetInstanceHandle(),
									     achModuleFileName,
									     sizeof(achModuleFileName)/sizeof(TCHAR) ))
						    {
							    CString strNameIndirect;
							    strNameIndirect.Format( L"@%s,-%d",
													    achModuleFileName,
													    IDS_SAFER_WINDOWS_EXTENSION_REGISTRY );
							    rkCertMgrExtension.SetString( L"NameStringIndirect",
													    strNameIndirect );
						    }
					        rkCertMgrExtension.CloseKey ();
				        }

				        hr = GuidToCString (&strGUID, cNodetypeSceTemplate);
				        if ( FAILED (hr) )
				        {
					        ASSERT (FALSE);
					        return SELFREG_E_CLASS;
				        }
				        rkNodeType.CreateKeyEx (rkNodeTypes, strGUID); 
				        ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
				        if ( rkNodeType.GetLastError () == ERROR_SUCCESS )
				        {
					        AMC::CRegKey rkExtensions;
					        ASSERT (rkExtensions.GetLastError () == ERROR_SUCCESS);
					        rkExtensions.CreateKeyEx (rkNodeType, g_szExtensions);
					        AMC::CRegKey rkNameSpace;
					        rkNameSpace.CreateKeyEx (rkExtensions, g_szNameSpace);
					        ASSERT (rkNameSpace.GetLastError () == ERROR_SUCCESS);
					        rkNameSpace.SetString (strSaferWindowsExtensionGUID, 
                                    (LPCWSTR) snapinName);
					        rkNodeType.CloseKey ();
				        }
				        else
					        return SELFREG_E_CLASS;
                    }

				    // Deregister as extension to My Computer System Tools node
				    // CODEWORK It would be good if we deregistered the server too
				    // JonN 12/14/98
				    try
                    {
			            fFound = rkNodeType.OpenKeyEx (rkNodeTypes, TEXT(struuidNodetypeSystemTools));
			            // if this fails just carry on
			            if ( fFound )
			            {
				            AMC::CRegKey rkExtensions;
				            ASSERT (rkExtensions.GetLastError () == ERROR_SUCCESS);
				            fFound = rkExtensions.OpenKeyEx (rkNodeType, g_szExtensions);
				            // if this fails just carry on
				            if ( fFound )
				            {
					            AMC::CRegKey rkNameSpace;
					            ASSERT (rkNameSpace.GetLastError () == ERROR_SUCCESS);
					            fFound = rkNameSpace.OpenKeyEx (rkExtensions, g_szNameSpace);
					            // if this fails just carry on
					            if ( fFound )
					            {
						            rkNameSpace.DeleteValue( L"{9C7910D2-4C01-11D1-856B-00C04FB94F17}" );
					            }
				            }
			            }
				    } catch (COleException* /*e*/)
				    {
					    // don't do anything
				    }

			    } // endif IsWindowsNT ()
			    rkNodeTypes.CloseKey ();
		    }
		    else
			    return SELFREG_E_CLASS;
	    }
	    else
		    return SELFREG_E_CLASS;
	}
	catch (COleException* e)
	{
		ASSERT (FALSE);
		e->Delete ();
		return SELFREG_E_CLASS;
	}

	ASSERT (SUCCEEDED (hr));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer (void)
{

	_Module.UnregisterServer ();
	return S_OK;
}


STDAPI DllInstall(BOOL /*bInstall*/, LPCWSTR pszCmdLine)
{
    LPCWSTR wszCurrentCmd = pszCmdLine;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    // parse the cmd line
    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
            case L'?':
                return S_OK;
        }
    }


    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
//	ConvertNameBlobToString ()
//
//	nameBlob (IN)		- Contains a CERT_NAME_BLOB to be decoded
//	pszName	 (OUT)		- The decoded contents of the name blob
//	 
///////////////////////////////////////////////////////////////////////////
HRESULT ConvertNameBlobToString (CERT_NAME_BLOB nameBlob, CString & pszName)
{
	HRESULT	hr = S_OK;
	DWORD	dwSize = 0;

	// Call CertNameToStr to get returned the string length.
    dwSize = CertNameToStr (
              MY_ENCODING_TYPE,     // Encoding type
              &nameBlob,            // CERT_NAME_BLOB
              CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG, // Type
              NULL,                 // Place to return string
              dwSize);              // Size of string (chars), 
                                    //   including zero terminator.

	ASSERT (dwSize > 1);
	if ( dwSize > 1 )	// This function always returns a null char 
						//   (0), so the minimum count returned will 
						//   be 1, even if nothing got converted.
    {
		// Call CertNameToStr to get the string.
		dwSize = CertNameToStr (
				   MY_ENCODING_TYPE,     // Encoding type
				   &nameBlob,            // CERT_NAME_BLOB
				   CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG, // Type
				   pszName.GetBufferSetLength (dwSize),	// Place to return string
				   dwSize);              // Size of string (chars)
		ASSERT (dwSize > 1);
		pszName.ReleaseBuffer ();
		if ( dwSize <= 1 )
		{
			hr = E_UNEXPECTED;
		}
    }

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//	FormatDate ()
//
//	utcDateTime (IN)	-	A FILETIME in UTC format.
//	pszDateTime (OUT)	-	A string containing the local date and time 
//							formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime, DWORD dwDateFlags, bool bGetTime)
{
	//	Time is returned as UTC, will be displayed as local.  
	//	Use FileTimeToLocalFileTime () to make it local, 
	//	then call FileTimeToSystemTime () to convert to system time, then 
	//	format with GetDateFormat () and GetTimeFormat () to display 
	//	according to user and locale preferences	
	HRESULT		hr = S_OK;
	FILETIME	localDateTime;

	BOOL bResult = FileTimeToLocalFileTime (&utcDateTime, // pointer to UTC file time to convert 
			&localDateTime); // pointer to converted file time 
	ASSERT (bResult);
	if ( bResult )
	{
		SYSTEMTIME	sysTime;

		bResult = FileTimeToSystemTime (
				&localDateTime, // pointer to file time to convert 
				&sysTime); // pointer to structure to receive system time 
		if ( bResult )
		{
			CString	date;
			CString	time;

			// Get date
			// Get length to allocate buffer of sufficient size
			int iLen = GetDateFormat (
					LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
					dwDateFlags, // flags specifying function options 
					&sysTime, // date to be formatted 
					0, // date format string 
					0, // buffer for storing formatted string 
					0); // size of buffer 
			ASSERT (iLen > 0);
			if ( iLen > 0 )
			{
				int iResult = GetDateFormat (
						LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
						dwDateFlags, // flags specifying function options 
						&sysTime, // date to be formatted 
						0, // date format string 
						date.GetBufferSetLength (iLen), // buffer for storing formatted string 
						iLen); // size of buffer 
				ASSERT (iResult);
				date.ReleaseBuffer ();
				if ( iResult )
					pszDateTime = date;
				else
					hr = HRESULT_FROM_WIN32 (GetLastError ());

				if ( iResult && bGetTime )
				{
					// Get time
					// Get length to allocate buffer of sufficient size
					iLen = GetTimeFormat (
							LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
							0, // flags specifying function options 
							&sysTime, // date to be formatted 
							0, // date format string 
							0, // buffer for storing formatted string 
							0); // size of buffer 
					ASSERT (iLen > 0);
					if ( iLen > 0 )
					{
						iResult = GetTimeFormat (
								LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
								0, // flags specifying function options 
								&sysTime, // date to be formatted 
								0, // date format string 
								time.GetBufferSetLength (iLen), // buffer for storing formatted string 
								iLen); // size of buffer 
						ASSERT (iResult);
						time.ReleaseBuffer ();
						if ( iResult )
						{
							pszDateTime = date + L"  " + time;
						}
						else
							hr = E_UNEXPECTED;
					}
					else
						hr = E_UNEXPECTED;
				}
			}
			else
			{
				hr = HRESULT_FROM_WIN32 (GetLastError ());
			}
		}
		else
		{
			hr = HRESULT_FROM_WIN32 (GetLastError ());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32 (GetLastError ());
	}

	return hr;
}


void DisplaySystemError (HWND hParent, DWORD dwErr)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	LPVOID	lpMsgBuf;
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			 (LPWSTR) &lpMsgBuf,    0,    NULL);
		
	// Display the string.
	CString	caption;
	VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
    CThemeContextActivator activator;
	::MessageBox (hParent, (LPWSTR) lpMsgBuf, (LPCWSTR) caption, MB_OK);
	// Free the buffer.
	LocalFree (lpMsgBuf);
}


CString GetSystemMessage (DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CString message;

	LPVOID lpMsgBuf;
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			 (LPWSTR) &lpMsgBuf,    0,    NULL );
	message = (LPWSTR) lpMsgBuf;

	// Free the buffer.
	LocalFree (lpMsgBuf);

    return message;
}


bool MyGetOIDInfo (CString & string, LPCSTR pszObjId)
{   
	ASSERT (pszObjId);
    PCCRYPT_OID_INFO	pOIDInfo;  // This points to a constant data structure and must not be freed.
	bool				bResult = true;
            
    pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

    if ( pOIDInfo )
    {
		string = pOIDInfo->pwszName;
    }
    else
    {
        int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
		ASSERT (nLen);
		if ( nLen )
		{
			nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
					string.GetBufferSetLength (nLen), nLen);
			ASSERT (nLen);
			string.ReleaseBuffer ();
		}
		bResult = (nLen > 0) ? true : false;
    }
    return bResult;
}


bool IsWindowsNT()
{
	OSVERSIONINFO	versionInfo;

	::ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
	versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    BOOL	bResult = ::GetVersionEx (&versionInfo);
	ASSERT (bResult);
	if ( bResult )
	{
		if ( VER_PLATFORM_WIN32_NT == versionInfo.dwPlatformId )
			bResult = TRUE;
	}
		
	return bResult ? true : false;
}

bool GetNameStringByType (
        PCCERT_CONTEXT pCertContext, 
        DWORD dwFlag, 
        DWORD dwType, 
        CString& szNameString)
{
    bool    bResult = false;
	DWORD	dwTypePara = CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG;
	DWORD	cchNameString = 0;
	DWORD	dwResult = ::CertGetNameString (pCertContext,
					dwType,
					dwFlag,
					&dwTypePara,
					NULL,
					cchNameString);
	if ( dwResult > 1 )
	{
		cchNameString = dwResult;
		LPWSTR	pszNameString = new WCHAR[cchNameString];
		if ( pszNameString )
		{
			::ZeroMemory (pszNameString, cchNameString*sizeof (WCHAR));
			dwResult = ::CertGetNameString (pCertContext,
							dwType,
							dwFlag,
							&dwTypePara,
							pszNameString,
							cchNameString);
				ASSERT (dwResult > 1);
			if ( dwResult > 1 )
            {
                szNameString = pszNameString;
                bResult = true;
            }
			delete [] pszNameString;
		}
	}

	return bResult;
}

CString GetNameString (PCCERT_CONTEXT pCertContext, DWORD dwFlag)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString	szNameString;
    DWORD   dwTypes[] = {CERT_NAME_SIMPLE_DISPLAY_TYPE,
                        CERT_NAME_EMAIL_TYPE,
                        CERT_NAME_UPN_TYPE,
                        CERT_NAME_DNS_TYPE,
                        CERT_NAME_URL_TYPE,
                        (DWORD) -1};
    int     nIndex = 0;
    while ( -1 != dwTypes[nIndex])
    {
        if ( GetNameStringByType (
                pCertContext, 
                dwFlag, 
                dwTypes[nIndex], 
                szNameString) )
        {
            break;
        }
        nIndex++;
    }

    if ( szNameString.IsEmpty () )
		szNameString.FormatMessage (IDS_NOT_AVAILABLE);

	return szNameString;
}


bool CertHasEFSKeyUsage(PCCERT_CONTEXT pCertContext)
{
	bool	bFound = false;
	BOOL	bResult = FALSE;
	DWORD	cbUsage = 0;
	


	bResult = ::CertGetEnhancedKeyUsage (pCertContext,  
			0,  // get extension and property
			NULL, &cbUsage);
	if ( bResult )
	{
		PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];
		if ( pUsage )
		{
			bResult = ::CertGetEnhancedKeyUsage (pCertContext,  
					0, // get extension and property
					pUsage, &cbUsage);
			if ( bResult )
			{
				for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
				{
					if ( !_stricmp (szOID_EFS_RECOVERY, 
							pUsage->rgpszUsageIdentifier[dwIndex]) )
					{
						bFound = true;
						break;
					}
				}
			}
			else
			{
				ASSERT (GetLastError () == CRYPT_E_NOT_FOUND);
			}

			delete [] pUsage;
		}
	}
	else
	{
		ASSERT (GetLastError () == CRYPT_E_NOT_FOUND);
	}
    return bFound;
}


////// This stuff was stolen from windows\gina\snapins\gpedit (eric flo's stuff) //////

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPWSTR CheckSlash (LPWSTR lpDir)
{
    LPWSTR	lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) 
	{
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//				5/13/98		BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnodeRecurse (HKEY hKeyRoot, LPWSTR lpSubKey)
{
    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    LONG	lResult = RegDeleteKey(hKeyRoot, lpSubKey);
    if (lResult == ERROR_SUCCESS) 
	{
        return lResult;
    }


	HKEY	hKey = 0;
    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);
    if (lResult != ERROR_SUCCESS) 
	{
        return lResult;
    }


    LPWSTR	lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    DWORD		dwSize = MAX_PATH;
    FILETIME	ftWrite;
    WCHAR		szName[MAX_PATH];
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);
    if (lResult == ERROR_SUCCESS) 
	{
        do {

            lstrcpy (lpEnd, szName);

            if ( ERROR_SUCCESS != RegDelnodeRecurse(hKeyRoot, lpSubKey) ) 
			{
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);
    if (lResult == ERROR_SUCCESS) 
	{
        return lResult;
    }

    return lResult;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//				5/13/98		BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnode (HKEY hKeyRoot, LPWSTR lpSubKey)
{
    const size_t    BUF_LEN = 2 * MAX_PATH;
    WCHAR szDelKey[BUF_LEN];

    ::ZeroMemory (szDelKey, BUF_LEN * sizeof (WCHAR));
    wcsncpy (szDelKey, lpSubKey, BUF_LEN - 1);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);
}


HRESULT DisplayCertificateCountByStore(LPCONSOLE pConsole, CCertStore* pCertStore, bool bIsGPE)
{
	if ( !pConsole || !pCertStore )
		return E_POINTER;

	_TRACE (1, L"Entering DisplayCertificateCountByStore- %s \n", 
			(LPCWSTR) pCertStore->GetStoreName ());
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    IConsole2*	pConsole2 = 0;
    HRESULT		hr = pConsole->QueryInterface (IID_PPV_ARG (IConsole2, &pConsole2));
    if (SUCCEEDED (hr))
    {
		CString	statusText;
        int     nCertCount = 0;

        switch (pCertStore->GetStoreType ())
        {
        case ACRS_STORE:
            nCertCount = pCertStore->GetCTLCount ();
            break;

        case TRUST_STORE:
            if ( bIsGPE ) 
            {
                nCertCount = pCertStore->GetCTLCount ();
            }
            else
                nCertCount = pCertStore->GetCertCount ();
            break;

        default:
            nCertCount = pCertStore->GetCertCount ();
            break;
        }


        switch (nCertCount)
        {
            case 0:
                {
                    UINT formatID = 0;
                    switch (pCertStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        formatID = IDS_STATUS_NO_AUTOENROLLMENT_OBJECTS;
                        break;

                    case TRUST_STORE:
			            if ( bIsGPE ) 
                        {
                            formatID = IDS_STATUS_NO_CTLS;
                        }
                        else
                            formatID = IDS_STATUS_NO_CERTS;
                        break;

                    default:
                        formatID = IDS_STATUS_NO_CERTS;
                        break;
                    }
				    statusText.FormatMessage (formatID, pCertStore->GetLocalizedName ());
                }
                break;

            case 1:
                {
                    UINT formatID = 0;
                    switch (pCertStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        formatID = IDS_STATUS_ONE_AUTOENROLLMENT_OBJECT;
                        break;

                    case TRUST_STORE:
			            if ( bIsGPE ) 
                        {
                            formatID = IDS_STATUS_ONE_CTL;
                        }
                        else
                            formatID = IDS_STATUS_ONE_CERT;
                        break;

                    default:
                        formatID = IDS_STATUS_ONE_CERT;
                        break;
                    }
	    			statusText.FormatMessage (formatID, pCertStore->GetLocalizedName ());
                }
                break;
        
            default:
                {
                    UINT formatID = 0;
                    switch (pCertStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        formatID = IDS_STATUS_X_AUTOENROLLMENT_OBJECTS;
                        break;

                    case TRUST_STORE:
			            if ( bIsGPE )
                        {
                            formatID = IDS_STATUS_X_CTLS;
                        }
                        else
                            formatID = IDS_STATUS_X_CERTS;
                        break;

                    default:
                        formatID = IDS_STATUS_X_CERTS;
                        break;
                    }

				    statusText.FormatMessage (formatID, 
						    (LPCWSTR) pCertStore->GetLocalizedName (), nCertCount); 
                }
                 break;
        }

        hr = pConsole2->SetStatusText ((LPWSTR)(LPCWSTR) statusText);

        pConsole2->Release ();
    }

	_TRACE (-1, L"Leaving DisplayCertificateCountByStore- %s \n", 
			(LPCWSTR) pCertStore->GetStoreName ());
	return hr;
}


CString GetF1HelpFilename()
{
   static CString helpFileName;

   if ( helpFileName.IsEmpty () )
   {
       UINT result = ::GetSystemWindowsDirectory (
            helpFileName.GetBufferSetLength (MAX_PATH+1), MAX_PATH);
       ASSERT(result != 0 && result <= MAX_PATH);
       helpFileName.ReleaseBuffer ();
       if ( result != 0 && result <= MAX_PATH )
           helpFileName += CM_CONTEXT_HELP;
   }

   return helpFileName;
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int LocaleStrCmp(LPCWSTR ptsz1, LPCWSTR ptsz2)
{
    int iRet = 0;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1

        if ( 0 == iRet )
        {
            UNICODE_STRING unistr1;
            unistr1.Length = (USHORT) (wcslen(ptsz1) * sizeof(WCHAR));
            unistr1.MaximumLength = unistr1.Length;
            unistr1.Buffer = (LPWSTR)ptsz1;
            UNICODE_STRING unistr2;
            unistr2.Length = (USHORT) (wcslen(ptsz2) * sizeof(WCHAR));
            unistr2.MaximumLength = unistr2.Length;
            unistr2.Buffer = (LPWSTR)ptsz2;
            iRet = ::RtlCompareUnicodeString(
                &unistr1,
                &unistr2,
                FALSE );
        }
    }
    else
    {
        _TRACE (0, L"CompareString (%s, %s) failed: 0x%x\n", ptsz1, ptsz2, GetLastError ());
    }
    return iRet;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <winldap.h>
#include <ntldap.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

//--------------------------------------------------------------------------
//
//       Defines
//
//--------------------------------------------------------------------------
#define DS_RETEST_SECONDS                   3
#define CVT_BASE	                        (1000 * 1000 * 10)
#define CVT_SECONDS	                        (1)
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define TEMPLATE_CONTAINER_NAME             L"CN=Certificate Templates,CN=Public Key Services,CN=Services,"
#define SCHEMA_CONTAINER_NAME               L"CN=Schema,"

HRESULT myHError(HRESULT hr)
{

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if ( SUCCEEDED (hr) )
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
    }
    return(hr);
}

HRESULT 
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    HRESULT hr = S_OK;

    size_t cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	    hr = E_OUTOFMEMORY;
	    goto error;
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}

DWORD
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CString* pszDomainDn,
    OUT CString* pszConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    pszDomainDn      : a pointer to a string to be allocated in this routine

    pszConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];

    WCHAR  *DefaultNamingContext       = L"defaultNamingContext";
    WCHAR  *ConfigNamingContext       = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectClass=*";

    //
    // These must be present
    //

    //
    // Set the out parameters to null
    //

    if ( pszDomainDn )
        *pszDomainDn = L"";
    if ( pszConfigDn )
        *pszConfigDn = L"";

    //
    // Query for the ldap server oerational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = DefaultNamingContext;
    AttrArray[1] = ConfigNamingContext;  // this is the sentinel
    AttrArray[2] = NULL;  // this is the sentinel

    __try
    {
	    LdapError = ldap_search_sW(LdapHandle,
				       NULL,
				       LDAP_SCOPE_BASE,
				       ObjectClassFilter,
				       AttrArray,
				       FALSE,
				       &SearchResult);

	    WinError = LdapMapErrorToWin32(LdapError);

	    if (ERROR_SUCCESS == WinError) {

            Entry = ldap_first_entry(LdapHandle, SearchResult);

            if (Entry)
            {

                Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

                while (Attr)
                {

                    if (!_wcsicmp(Attr, DefaultNamingContext))
                    {
                        if ( pszDomainDn )
                        {
	                        Values = ldap_get_values(LdapHandle, Entry, Attr);

	                        if (Values && Values[0])
                            {
                                *pszDomainDn = Values[0];
	                        }
	                        ldap_value_free(Values);
                        }

                    }
                    else if (!_wcsicmp(Attr, ConfigNamingContext))
                    {
                        if ( pszConfigDn )
                        {
	                        Values = ldap_get_values(LdapHandle, Entry, Attr);

	                        if (Values && Values[0])
                            {
                                *pszConfigDn = Values[0];
	                        }
	                        ldap_value_free(Values);
                        }
                    }

                    Attr = ldap_next_attribute(LdapHandle, Entry, BerElement);
                }
            }

            if ( pszDomainDn && pszDomainDn->IsEmpty () )
            {
	            //
	            // We could get the default domain - bail out
	            //
	            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }
            else if ( pszConfigDn && pszConfigDn->IsEmpty () )
            {
	            //
	            // We could get the default domain - bail out
	            //
	            WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }

	    }
    }
    __except(WinError = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // make sure we free this
    if (SearchResult)
        ldap_msgfree( SearchResult );

    return WinError;
}

HRESULT myDoesDSExist(IN BOOL fRetry)
{
    HRESULT hr = S_OK;

    static BOOL s_fKnowDSExists = FALSE;
    static HRESULT s_hrDSExists = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    static FILETIME s_ftNextTest = {0,0};
    
    if (s_fKnowDSExists && (s_hrDSExists != S_OK) && fRetry)
    //    s_fKnowDSExists = FALSE;	// force a retry
    {
        FILETIME ftCurrent;
        GetSystemTimeAsFileTime(&ftCurrent);

        // if Compare is < 0 (next < current), force retest
        if (0 > CompareFileTime(&s_ftNextTest, &ftCurrent))
            s_fKnowDSExists = FALSE;    
    }

    if (!s_fKnowDSExists)
    {
        GetSystemTimeAsFileTime(&s_ftNextTest);

	// set NEXT in 100ns increments

        ((LARGE_INTEGER *) &s_ftNextTest)->QuadPart +=
	    (__int64) (CVT_BASE * CVT_SECONDS * 60) * DS_RETEST_SECONDS;

        // NetApi32 is delay loaded, so wrap to catch problems when it's not available
        __try
        {
            DOMAIN_CONTROLLER_INFO *pDCI;
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRole;
        
            // ensure we're not standalone
            pDsRole = NULL;
            hr = DsRoleGetPrimaryDomainInformation(	// Delayload wrapped
				    NULL,
				    DsRolePrimaryDomainInfoBasic,
				    (BYTE **) &pDsRole);

            if (S_OK == hr &&
                (pDsRole->MachineRole == DsRole_RoleStandaloneServer ||
                 pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
            }

            if (NULL != pDsRole) 
	    {
                DsRoleFreeMemory(pDsRole);     // Delayload wrapped
	    }
            if (S_OK == hr)
            {
                // not standalone; return info on our DS

                pDCI = NULL;
                hr = DsGetDcName(    // Delayload wrapped
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    DS_DIRECTORY_SERVICE_PREFERRED,
			    &pDCI);
            
                if (S_OK == hr && 0 == (pDCI->Flags & DS_DS_FLAG))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
                }
                if (NULL != pDCI)
                {
                   NetApiBufferFree(pDCI);    // Delayload wrapped
                }
            }
            s_fKnowDSExists = TRUE;
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }

        // else just allow users without netapi flounder with timeouts
        // if ds not available...

        s_hrDSExists = myHError(hr);
    }
    return(s_hrDSExists);
}




HRESULT
myRobustLdapBindEx(
    OUT LDAP ** ppldap,
    OPTIONAL OUT LPWSTR* ppszForestDNSName,
    IN BOOL fGC)
{
    HRESULT hr = S_OK;
    BOOL fForceRediscovery = FALSE;
    DWORD dwGetDCFlags = DS_RETURN_DNS_NAME;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    LDAP *pld = NULL;
    WCHAR const *pwszDomainControllerName = NULL;
    ULONG ldaperr = 0;

    if (fGC)
    {
        dwGetDCFlags |= DS_GC_SERVER_REQUIRED;
    }

    do {
        if (fForceRediscovery)
        {
           dwGetDCFlags |= DS_FORCE_REDISCOVERY;
        }
	ldaperr = LDAP_SERVER_DOWN;

        // netapi32!DsGetDcName is delay loaded, so wrap

        __try
        {
            // Get the GC location
            hr = DsGetDcName(
			NULL,     // Delayload wrapped
			NULL, 
			NULL, 
			NULL,
			dwGetDCFlags,
			&pDomainInfo);
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        if (S_OK != hr)
        {
	    hr = HRESULT_FROM_WIN32(hr);
            if (fForceRediscovery)
            {
                goto error;
            }
	    fForceRediscovery = TRUE;
	    continue;
        }

        if (NULL == pDomainInfo ||
            (fGC && 0 == (DS_GC_FLAG & pDomainInfo->Flags)) ||
            0 == (DS_DNS_CONTROLLER_FLAG & pDomainInfo->Flags) ||
            NULL == pDomainInfo->DomainControllerName)
        {
            if (!fForceRediscovery)
            {
                fForceRediscovery = TRUE;
                continue;
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
            goto error;
        }

        pwszDomainControllerName = pDomainInfo->DomainControllerName;

        // skip past forward slashes (why are they there?)

        while (L'\\' == *pwszDomainControllerName)
        {
            pwszDomainControllerName++;
        }

        // bind to ds

        pld = ldap_init(
		    const_cast<WCHAR *>(pwszDomainControllerName),
		    fGC? LDAP_GC_PORT : LDAP_PORT);
        if (NULL == pld)
	    {
            ldaperr = LdapGetLastError();
	    }
        else
        {
            // do this because we're explicitly setting DC name

            ldaperr = ldap_set_option(pld, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

	    ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        }
        hr = myHError(LdapMapErrorToWin32(ldaperr));

        if (fForceRediscovery)
        {
            break;
        }
        fForceRediscovery = TRUE;

    } while (LDAP_SERVER_DOWN == ldaperr);

    // everything's cool, party down

    if (S_OK == hr)
    {
        if (NULL != ppszForestDNSName)
        {
             hr = myDupString(
			pDomainInfo->DomainControllerName,
			ppszForestDNSName);

             if(S_OK != hr)
                 goto error;
        }
        *ppldap = pld;
        pld = NULL;
    }

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

    // we know netapi32 was already loaded safely (that's where we got
    // pDomainInfo), so no need to wrap

    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);     // Delayload wrapped
    }
    return(hr);
}

HRESULT
myRobustLdapBind(
    OUT LDAP ** ppldap,
    IN BOOL fGC)
{
    return(myRobustLdapBindEx(ppldap, NULL, fGC));
}


void CheckDomainVersion ()
{
    _TRACE (1, L"Entering CheckDomainVersion()\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT             hr=S_OK;
    DWORD               dwErr=0;
    ULONG               ldaperr=0;
    struct l_timeval    timeout;
    LPWSTR              awszAttr[2];
       
    LDAP                *pld = NULL;
    CString             szConfig;
    CString             szDN;
    LDAPMessage         *SearchResult = NULL;


    //*************************************************************
    // 
    // check the schema version
    //
    _TRACE (0, L"Checking the schema version...\n");
    //retrieve the ldap handle and the config string
    if(S_OK != myDoesDSExist(TRUE))
    {
        _TRACE (0, L"No DS exists.\n");
        goto error;
    }

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
    {
        _TRACE (0, L"Error: Failed to bind to the DS.\n");
        goto error;
    }

	dwErr = CAGetAuthoritativeDomainDn(pld, NULL, &szConfig);
	if(ERROR_SUCCESS != dwErr)
    {
        _TRACE (0, L"Error: Failed to get the domain name.\n");
	    hr = HRESULT_FROM_WIN32(dwErr);
        goto error;
    }

    szDN = SCHEMA_CONTAINER_NAME;
    szDN += szConfig;

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

    awszAttr[0]=L"cn";
    awszAttr[1]=NULL;
    
 	ldaperr = ldap_search_stW(
              pld, 
		      const_cast <PWCHAR>((PCWSTR) szDN),
		      LDAP_SCOPE_ONELEVEL,
		      L"(cn=ms-PKI-Enrollment-Flag)",
		      awszAttr,
		      0,
              &timeout,
		      &SearchResult);

    if ( LDAP_SUCCESS != ldaperr )
    {
        _TRACE (0, L"We have W2K Schema.  Exit\n");
        g_bSchemaIsW2K = true;
        hr = S_OK;
        goto error;
    }


error:


    if(SearchResult)
        ldap_msgfree(SearchResult);

    if (pld)
        ldap_unbind(pld);
    _TRACE (1, L"Entering CheckDomainVersion ()\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\cmponent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cmponent.h
//
//  Contents:
//
//----------------------------------------------------------------------------
// cmponent.h : Declaration of CCertMgrComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include <cryptui.h>
#include <winsafer.h>
#include "cookie.h"  // CCertMgrCookie
#include "certifct.h"
#include "ctl.h"
#include "crl.h"
#include "SaferUtil.h"
#include "SaferEntry.h"

enum {
	IDM_USAGE_VIEW = 100,
	IDM_STORE_VIEW = 101,
	IDM_TASK_RENEW_NEW_KEY,
	IDM_TASK_RENEW_SAME_KEY,
	IDM_TASK_IMPORT,
	IDM_TASK_EXPORT,
	IDM_TASK_CTL_EXPORT,
	IDM_TASK_EXPORT_STORE,
	IDM_OPEN,
	IDM_TASK_OPEN,
	IDM_TASK_FIND,
	IDM_TOP_FIND,
	IDM_ENROLL_NEW_CERT,
    IDM_ENROLL_NEW_CERT_SAME_KEY,
	IDM_ENROLL_NEW_CERT_NEW_KEY,
	IDM_CTL_EDIT,
	IDM_NEW_CTL,
	IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT,
	IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1,
	IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT2,
	IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT,
	IDM_EDIT_ACRS,
	IDM_TASK_CRL_EXPORT,
	IDM_OPTIONS,
	IDM_INIT_POLICY,
	IDM_DEL_POLICY,
	IDM_DEL_POLICY1,
    IDM_TOP_CHANGE_COMPUTER,
    IDM_TASK_CHANGE_COMPUTER,
    IDM_NEW_ACRS,
    IDM_SAFER_LEVEL_SET_DEFAULT,
    IDM_SAFER_NEW_ENTRY_PATH,
    IDM_SAFER_NEW_ENTRY_HASH,
    IDM_SAFER_NEW_ENTRY_CERTIFICATE,
    IDM_SAFER_NEW_ENTRY_INTERNET_ZONE,
    IDM_TASK_PULSEAUTOENROLL,
    IDM_TOP_CREATE_NEW_SAFER_POLICY,
    IDM_TASK_CREATE_NEW_SAFER_POLICY
};

// forward declarations
class CCertMgrComponentData;

class CCertMgrComponent :
	public CComponent,
	public IExtendContextMenu,
	public ICertificateManager,
	public IExtendPropertySheet,
	public IResultDataCompare,
    public IExtendControlbar,
	public PersistStream
{
public:
	CCertMgrComponent();
	virtual ~CCertMgrComponent();
BEGIN_COM_MAP(CCertMgrComponent)
	COM_INTERFACE_ENTRY(ICertificateManager)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IResultDataCompare)
	COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1



// IExtendContextMenu
public:
  STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
  STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IComponent implemented in CComponent
	// support methods for IComponent
	virtual HRESULT ReleaseAll();
	virtual HRESULT OnPropertyChange( LPARAM param );
	virtual HRESULT OnViewChange (LPDATAOBJECT pDataObject, LPARAM data, LPARAM hint);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem, LPDATAOBJECT pDataObject);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT pDataObject,
	                                   LPIMAGELIST lpImageList,
	                                   HSCOPEITEM hSelectedItem );

	HRESULT PopulateListbox(CCertMgrCookie* pcookie);
	HRESULT RefreshResultPane();

	static HRESULT LoadStrings();
    HRESULT LoadColumns( CCertMgrCookie* pcookie );

	CCertMgrComponentData& QueryComponentDataRef()
	{
		return (CCertMgrComponentData&)QueryBaseComponentDataRef();
	}

public:
	STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
	CCertMgrCookie* m_pViewedCookie; // CODEWORK I hate to have to do this...
	static const GUID m_ObjectTypeGUIDs[CERTMGR_NUMTYPES];
	static const BSTR m_ObjectTypeStrings[CERTMGR_NUMTYPES];

	inline CCertMgrCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertMgrCookie*)ActiveBaseCookie( pBaseCookie );
	}

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

	CTypedPtrList<CPtrList, CCertStore*>	m_usageStoreList;

	// PersistStream
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

// IExtendControlbar
    HRESULT STDMETHODCALLTYPE SetControlbar (/* [in] */ LPCONTROLBAR pControlbar);
    HRESULT STDMETHODCALLTYPE ControlbarNotify(
                MMC_NOTIFY_TYPE event,  // user action
                LPARAM arg,               // depends on the event parameter
                LPARAM param);             // depends on the event parameter
 
private:
    HRESULT AddLevel (
                const CString& szLevel, 
                DWORD dwLevel, 
                bool fIsMachine, 
                PCWSTR pszServerName);
	HRESULT AddSaferLevels (
                bool bIsComputer, 
                PCWSTR pszServerName,
                HKEY hGroupPolicyKey);
	bool m_bShowArchivedCertsStateWhenLogStoresEnumerated;
	LPDATAOBJECT					m_pPastedDO;
	CertificateManagerObjectType	m_currResultNodeType;
	bool							m_bUsageStoresEnumerated;
	CString							m_szDisplayInfoResult;
	UINT*							m_ColumnWidths[CERTMGR_NUMTYPES];
    int                             m_nSelectedCertColumn;
    int                             m_nSelectedCRLColumn;
    int                             m_nSelectedCTLColumn;
    int                             m_nSelectedSaferEntryColumn;
    CUsageCookie*                   m_pLastUsageCookie;
    LPCONTROLBAR                    m_pControlbar;
    LPTOOLBAR                       m_pToolbar;

	void SetTextNotAvailable ();

protected:

    HRESULT SaferFinishEntryAndAdd (SAFER_ENTRY_TYPE previousType, 
                PSAFER_IDENTIFICATION_HEADER pCaiCommon, 
                bool bIsComputer, 
                long dwLevel,
                CSaferEntries* pSaferEntries, 
                const CString& szPreviousKey);
    HRESULT InsertNewSaferEntry (
                SAFER_ENTRY_TYPE type, 
                bool bIsMachine, 
                PCWSTR pwcszObjectName, 
                PSAFER_IDENTIFICATION_HEADER pCaiCommon,
                DWORD dwLevel,
                CSaferEntries* pSaferEntries,
                IGPEInformation* pGPEInformation,
                CCertificate* pCert,
                PCWSTR pszRSOPRegistryKey = 0);
    HRESULT EnumSaferCertificates (
                bool bIsMachine, 
                CCertStore& rCertStore, 
                CSaferEntries* pSaferEntries);
    HRESULT SaferEnumerateNonCertEntries (HKEY hGroupPolicyKey, bool bIsComputer);
    HRESULT SaferEnumerateRSOPNonCertEntries (
                bool bIsComputer,
                CSaferEntries* pSaferEntries);
    HRESULT SaferEnumerateCertEntries (
                bool bIsComputer,
                CSaferEntries* pSaferEntries);
	HRESULT SaferGetSingleEntry (
                bool bIsMachine, 
                SAFER_LEVEL_HANDLE hLevel, 
                GUID& rEntryGuid,
                DWORD dwLevelID);
	HRESULT SaferEnumerateEntriesAtLevel (bool bIsMachine, HKEY hGroupPolicyKey, DWORD dwLevel);
	HRESULT SaferEnumerateEntries (bool bIsComputer,
                CSaferEntries* pSaferEntries);
	HRESULT DisplayCertificateCountByUsage (const CString& usageName, int nCertCnt) const;
	bool DeletePrivateKey (CCertStore& rCertStoreDest, CCertStore& rCertStoreSrc);
	void CloseAndReleaseUsageStores ();
	HRESULT PasteCookie (
				CCertMgrCookie* pPastedCookie,
				CCertMgrCookie* pTargetCookie,
				CCertStore& rCertStore,
				SPECIAL_STORE_TYPE storeType,
				bool bContainsCerts,
				bool bContainsCRLs,
				bool bContainsCTLs,
				HSCOPEITEM hScopeItem,
				bool bRequestConfirmation,
				bool bIsMultipleSelect);
	HRESULT	DeleteCookie (
				CCertMgrCookie* pCookie,
				LPDATAOBJECT pDataObject,
				bool bRequestConfirmation,
				bool bIsMultipleSelect,
                bool bDoCommit);
	HRESULT RefreshResultItem (CCertMgrCookie* pCookie);
	HRESULT LaunchCommonCertDialog (CCertificate* pCert);
	HRESULT LaunchCommonCTLDialog (CCTL* pCTL);
	HRESULT LaunchCommonCRLDialog (CCRL* pCRL);
	virtual HRESULT OnOpen (LPDATAOBJECT pDataObject);
	CCertMgrCookie* ConvertCookie (LPDATAOBJECT pDataObject);
	HRESULT OnNotifyCutOrMove (LPARAM arg);
	HRESULT SaveWidths (CCertMgrCookie* pCookie);
	HRESULT LoadColumnsFromArrays (INT objecttype);
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, BSTR* ppViewType, long* pViewOptions);
	HRESULT CopyPastedCRL (CCRL* pCRL, CCertStore& rCertStore);
	HRESULT CopyPastedCTL (CCTL* pCTL, CCertStore& rCertStore);
	HRESULT CopyPastedCert (
				CCertificate* pCert,
				CCertStore& rCertStore,
				const SPECIAL_STORE_TYPE storeType,
				bool bDeletePrivateKey,
                CCertMgrCookie* pTargetCookie);
	HRESULT OnNotifyQueryPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	HRESULT OnNotifyPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	void DisplayAccessDenied();
    STDMETHOD(Notify)(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	HRESULT EnumCTLs (CCertStore& rCertStore);
	HRESULT EnumerateLogicalStores (CCertMgrCookie& parentCookie);
	HRESULT EnumCertsByUsage (CUsageCookie* pUsageCookie);
	HRESULT EnumCertificates (CCertStore& rCertStore);
	HRESULT DeleteCRLFromResultPane (CCRL * pCRL, LPDATAOBJECT pDataObject);
	HRESULT DeleteCertFromResultPane (
                CCertificate* pCert, 
                LPDATAOBJECT pDataObject, 
                bool bDoCommit);
	HRESULT DeleteSaferEntryFromResultPane (
                CSaferEntry * pSaferEntry, 
                LPDATAOBJECT pDataObject, 
                bool bDoCommit);
	virtual HRESULT OnNotifyDelete (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyRefresh (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifySelect( LPDATAOBJECT pDataObject, BOOL fSelected);
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyDblClick( LPDATAOBJECT pDataObject );
    virtual HRESULT OnNotifyCanPasteOutOfProc (LPBOOL pbCanHandle);
}; // class CCertMgrComponent


// Enumeration for the icons used
enum
	{
	iIconDefault = 0,
	iIconCertificate,
	iIconCTL,
	iIconCRL,
	iIconAutoCertRequest,
    iIconAutoEnroll,
    iIconSaferLevel,
    iIconDefaultSaferLevel,
    iIconSaferHashEntry,
    iIconSaferURLEntry,
    iIconSaferNameEntry,
    iIconSettings,
    iIconSaferCertEntry,
	iIconLast		// Must be last
	};

typedef enum _COLNUM_CERTIFICATE {
	COLNUM_CERT_SUBJECT = 0,
	COLNUM_CERT_ISSUER,
	COLNUM_CERT_EXPIRATION_DATE,
	COLNUM_CERT_PURPOSE,
	COLNUM_CERT_CERT_NAME,
	COLNUM_CERT_STATUS,
    COLNUM_CERT_TEMPLATE,
	CERT_NUM_COLS
} COLNUM_ROOT;

typedef enum _COLNUM_CRL {
	COLNUM_CRL_ISSUER = 0,
	COLNUM_CRL_EFFECTIVE_DATE,
	COLNUM_CRL_NEXT_UPDATE,
	CRL_NUM_COLS
} COLNUM_CRL;

typedef enum _COLNUM_CTL {
	COLNUM_CTL_ISSUER = 0,
	COLNUM_CTL_EFFECTIVE_DATE,
	COLNUM_CTL_PURPOSE,
	COLNUM_CTL_FRIENDLY_NAME,
	CTL_NUM_COLS
} COLNUM_CTL;

typedef enum _COLNUM_SAFER_LEVELS {
    COLNUM_SAFER_LEVEL_NAME = 0,
    COLNUM_SAFER_LEVEL_DESCRIPTION,
    SAFER_LEVELS_NUM_COLS
} COLNUM_SAFER_LEVELS;

typedef enum _COLNUM_SAFER_ENTRIES {
    COLNUM_SAFER_ENTRIES_NAME = 0,
    COLNUM_SAFER_ENTRIES_TYPE,
    COLNUM_SAFER_ENTRIES_LEVEL,
    COLNUM_SAFER_ENTRIES_DESCRIPTION,
    COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE,
    SAFER_ENTRIES_NUM_COLS
} COLNUM_SAFER_ENTRIES;


#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\certifct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       certifct.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_CERTIFCT_H__9D512D04_126D_11D1_B5D3_00C04FB94F17__INCLUDED_)
#define AFX_CERTIFCT_H__9D512D04_126D_11D1_B5D3_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cookie.h"
#include "nodetype.h"

#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

/////////////////////////////////////////////////////////////////////////////
// CCertificate

class CCertificate : public CCertMgrCookie
{
public:
	CCertificate(const PCCERT_CONTEXT pCertContext, CCertStore* pCertStore);
	virtual ~CCertificate();


public:
	CString GetTemplateName();
	bool CanDelete();
	int CompareExpireDate (const CCertificate& cert) const;
	BOOL DeleteFromStore (bool bDoCommit);
	CString FormatStatus();
	CString GetAlternateSubjectName ();
	CString GetAlternateIssuerName ();
	PCCERT_CONTEXT GetCertContext () const;
	CCertStore* GetCertStore () const;
	CString GetDescription ();
	CString GetEnhancedKeyUsage ();
	CString GetFriendlyName ();
	CString GetMD5Hash ();
	CString GetIssuerName ();
	CString GetShortLastModified ();
	CString GetLongLastModified ();
    HRESULT GetLastModifiedFileTime (FILETIME& ft);
	PCCERT_CONTEXT GetNewCertContext ();
	CString GetSerialNumber ();
	CString GetSHAHash ();
	const SPECIAL_STORE_TYPE GetStoreType () const;
	CString GetSubjectName ();
	CString GetValidNotAfter ();
	CString GetValidNotBefore ();
	bool IsArchived();
	bool IsReadOnly ();
	bool IsValid ();
	virtual void Refresh ();
	HRESULT SetDescription (const CString& szDescription);
    HRESULT SetLastModified ();
    BOOL operator==(CCertificate&);
    void SetStore (CCertStore* pStore);

private:
    CString DecodeV1TemplateName (PCERT_EXTENSION pCertExtension);
    CString DecodeV2TemplateName (PCERT_EXTENSION pCertExtension);
    HRESULT FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob);
	bool FormatEnhancedKeyUsagePropertyString (CString& string);
	VOID DataToHex (PBYTE pSrc, CString & dest, int cb, bool bIncludeSpaces = true);
	HRESULT ConvertAltNameToString (LPCWSTR szOID, const DWORD dwNameChoice, CString &altName);
    CString CCertificate::GetLastModified(DWORD dwDateFlags, bool bRetryIfNotPresent = true);

private:	// data
	bool                    m_bIsArchived;
	bool                    m_bCanDelete;
	CCertStore*             m_pCertStore;
	CString GetGenericHash (DWORD dwPropId);
	CString                 m_szSHAHash;
	CString                 m_szMD5Hash;
	CString                 m_szFriendlyName;
	CString					m_szEnhancedKeyUsage;
	CString					m_szPolicyURL;
	CString					m_szAuthorityKeyID;
	CString					m_szSubjectKeyID;
	CString					m_szSerNum;
	CString					m_szAltSubjectName;
	CString					m_szAltIssuerName;
	CString					m_szValidNotBefore;
	CString					m_szValidNotAfter;
	CString					m_szSubjectName;
	CString					m_szIssuerName;
	PCERT_INFO				m_pCertInfo;
	PCCERT_CONTEXT			m_pCertContext;
	DWORD					m_fieldChecked;
    CString                 m_szDescription;
    CString                 m_szTemplateName;
};

#endif // !defined(AFX_CERTIFCT_H__9D512D04_126D_11D1_B5D3_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\cmutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cmutils.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __CMUTILS_H
#define __CMUTILS_H
#include "cookie.h"

typedef CArray<CCertMgrCookie*, CCertMgrCookie*> CCookiePtrArray;

// Get subject or issuer name from a certificate context
CString GetNameString (PCCERT_CONTEXT pCertContext, DWORD dwFlag);

// Convert win32 error code to a text message and display
void DisplaySystemError (HWND hParent, DWORD dwErr);
CString GetSystemMessage (DWORD dwErr);

// Convert an OID to a displayable name
bool MyGetOIDInfo (CString & string, LPCSTR pszObjId);

// The certificate has File Encryption key usage
bool CertHasEFSKeyUsage (PCCERT_CONTEXT pCertContext);

HRESULT FormatDate (
        FILETIME utcDateTime, 
        CString & pszDateTime, 
        DWORD dwDateFlags = 0,
        bool bGetTime = false);
HRESULT ConvertNameBlobToString(CERT_NAME_BLOB nameBlob, CString & pszName);


bool IsWindowsNT ();

LRESULT RegDelnode (HKEY hKeyRoot, LPWSTR lpSubKey);

HRESULT DisplayCertificateCountByStore (LPCONSOLE pConsole, CCertStore* pCertStore, bool bIsGPE = false);

// Help File for F1 and ? help
CString GetF1HelpFilename();

#ifndef szOID_EFS_RECOVERY
#define szOID_EFS_RECOVERY      "1.3.6.1.4.1.311.10.3.4.1"
#endif

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))

extern LPCWSTR  CM_HELP_TOPIC;
extern LPCWSTR  CM_HELP_FILE;
extern LPCWSTR  CM_LINKED_HELP_FILE;
extern LPCWSTR  PKP_LINKED_HELP_FILE;
extern LPCWSTR  PKP_HELP_FILE;
extern LPCWSTR  PKP_HELP_TOPIC;
extern LPCWSTR  SAFER_WINDOWS_HELP_FILE;
extern LPCWSTR  SAFER_WINDOWS_LINKED_HELP_FILE;
extern LPCWSTR  SAFER_HELP_TOPIC;
extern LPCWSTR  CM_CONTEXT_HELP;
extern LPCWSTR  WINDOWS_HELP;

HRESULT RenewCertificate (
        CCertificate* pCert, 
        bool bNewKey, 
        const CString& machineName, 
        DWORD dwLocation,
        const CString& managedComputer, 
        const CString& managedService, 
        HWND hwndParent, 
        LPCONSOLE pConsole,
        LPDATAOBJECT pDataObject);

int LocaleStrCmp(PCWSTR ptsz1, PCWSTR ptsz2); // calls CompareString () API.

#define	STR_BLOBCOUNT           L"BlobCount"
#define	STR_BLOB                L"Blob"
#define	STR_BLOB0               L"Blob0"
#define	STR_BLOBLENGTH          L"BlobLength"
#define	STR_WQL                 L"WQL"
#define	STR_SELECT_STATEMENT    L"SELECT * FROM RSOP_RegistryPolicySetting"
#define	STR_PROP_VALUENAME      L"valueName"
#define	STR_PROP_REGISTRYKEY    L"registryKey"
#define	STR_PROP_VALUE          L"value"
#define STR_PROP_PRECEDENCE     L"precedence"
#define STR_PROP_GPOID          L"GPOID"
#define	STR_REGKEY_CERTIFICATES L"\\Certificates"
#define	STR_REGKEY_CTLS         L"\\CTLs"
#define	STR_REGKEY_CRLS         L"\\CRLs"

#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\CertMgr"
#define SAFER_CODEID_KEY \
            SAFER_HKLM_REGBASE L"\\" SAFER_CODEIDS_REGSUBKEY

// Registry path to the trusted publisher store
#define CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\TrustedPublisher"

// Registry path to the disallowed store
#define CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\Disallowed"

// Registry path to the EFS settings
#define EFS_SETTINGS_REGPATH    L"Software\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\EFS"

// Registry value for EFS settings
#define EFS_SETTINGS_REGVALUE   L"EfsConfiguration"

// Enabling themes
#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

void CheckDomainVersion ();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\compdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       compdata.h
//
//  Contents:
//
//----------------------------------------------------------------------------

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "cmponent.h" // LoadIconsIntoImageList
#include "certifct.h"
#include "CTL.h"
#include "CRL.h"
#include "AutoCert.h"
#include "certmgrd.h"
#include "options.h"
#include "cookie.h"	// Added by ClassView
#include "StoreRSOP.h"
#include "RSOPObject.h"
#include "SaferLevel.h"
#include "SaferEntryCertificatePropertyPage.h"
#include "SaferEntryPathPropertyPage.h"
#include "SaferEntryHashPropertyPage.h"
#include "SaferEntryInternetZonePropertyPage.h"

#define HINT_CHANGE_VIEW_TYPE	        0x00000001
#define HINT_CHANGE_STORE_TYPE	        0x00000002
#define HINT_SHOW_ARCHIVE_CERTS	        0x00000004
#define HINT_PASTE_COOKIE		        0x00000008
#define HINT_EFS_ADD_DEL_POLICY	        0x00000010
#define HINT_IMPORT				        0x00000020
#define HINT_CHANGE_COMPUTER            0x00000040
#define HINT_REFRESH_STORES             0x00000080
#define HINT_CERT_ENROLLED_USAGE_MODE   0x00000100


class CCertStoreGPE;	// forward declaration
class CFindDialog;		// forward declaration

class CCertMgrComponentData:
	public CComponentData,
	public IExtendContextMenu,
	public IExtendPropertySheet,
	public PersistStream,
	public CHasMachineName
{
friend CCertMgrComponent;
friend CViewOptionsDlg;
friend CFindDialog;
friend CSaferEntryCertificatePropertyPage;
friend CSaferEntryPathPropertyPage;
friend CSaferEntryHashPropertyPage;
friend CSaferEntryInternetZonePropertyPage;

public:
    IGPEInformation* GetGPEInformation ()
    {
        if ( m_pGPEInformation )
            m_pGPEInformation->AddRef ();

        return m_pGPEInformation;
    }

    IRSOPInformation* GetRSOPInformation (bool bIsComputer)
    {
        if ( bIsComputer )
        {
            if ( m_pRSOPInformationComputer )
                m_pRSOPInformationComputer->AddRef ();

            return m_pRSOPInformationComputer;
        }
        else
        {
            if ( m_pRSOPInformationUser )
                m_pRSOPInformationUser->AddRef ();

            return m_pRSOPInformationUser;
        }
    }

	CertificateManagerObjectType GetObjectType (LPDATAOBJECT pDataObject);

// Use DECLARE_NOT_AGGREGATABLE(CCertMgrComponentData)
// if you don't want your object to support aggregation
//DECLARE_AGGREGATABLE(CCertMgrComponentData)
//DECLARE_REGISTRY(CCertMgrComponentData, _T("CERTMGR.CertMgrObject.1"), _T("CERTMGR.CertMgrObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)

	CCertMgrComponentData();
	virtual ~CCertMgrComponentData();
BEGIN_COM_MAP(CCertMgrComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IExtendContextMenu
public:
    const CRSOPObjectArray* GetRSOPObjectArrayComputer () const
    {
        return &m_rsopObjectArrayComputer;
    }
    const CRSOPObjectArray* GetRSOPObjectArrayUser () const
    {
        return &m_rsopObjectArrayUser;
    }

    CCertMgrCookie* GetRootCookie ()
    {
        return 	m_pRootCookie;
    }

	void RemoveResultCookies (LPRESULTDATA pResultData);
	bool ShowArchivedCerts () const;
	HRESULT CreateContainers (
			HSCOPEITEM hScopeItem,
			CCertStore& rTargetStore);
	HRESULT EnumerateLogicalStores (CTypedPtrList<CPtrList, CCertStore*>*	pStoreList);
	CString GetThisComputer() const;
	void SetResultData (LPRESULTDATA pResultData);
	CUsageCookie* FindDuplicateUsage (HSCOPEITEM hParent, LPCWSTR pszName);
	LPCONSOLENAMESPACE GetConsoleNameSpace () const;
	DWORD GetLocation () const;
	CString GetManagedComputer () const;
	CString GetManagedService () const;
	CString GetCommandLineFileName () const;
	HRESULT RefreshScopePane (LPDATAOBJECT pDataObject);
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent);

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

	virtual CCookie& QueryBaseRootCookie();

	inline CCertMgrCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertMgrCookie*)ActiveBaseCookie( pBaseCookie );
	}

	inline CCertMgrCookie& QueryRootCookie()
	{
        ASSERT (m_pRootCookie);
	    return *m_pRootCookie;
	}

	virtual HRESULT OnNotifyRelease(LPDATAOBJECT pDataObject, HSCOPEITEM hItem);


	// CHasMachineName
	DECLARE_FORWARDS_MACHINE_NAME( (m_pRootCookie) )

    // ISnapinHelp2
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

    bool ComputerIsStandAlone () const
    {
        return m_bMachineIsStandAlone;
    }


protected:
    bool                m_bSaferSupported;
    DWORD*              m_pdwSaferLevels;
	DWORD               m_dwDefaultSaferLevel;
    CRSOPObjectArray    m_rsopObjectArrayComputer;
    CRSOPObjectArray    m_rsopObjectArrayUser;
	LPCONSOLE           m_pComponentConsole;
	IGPEInformation*	m_pGPEInformation;

    HRESULT             AddSaferCreateNewPolicyMenuItems (
                                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                LONG lInsertionPointID);
 	HRESULT				AddACRSNewMenuItem(
 								LPCONTEXTMENUCALLBACK pContextMenuCallback,
 								LONG				lInsertionPointID,
 								bool				bIsReadOnly);
	HRESULT				AddACRSCTLPropPages (
								CAutoCertRequest*	pACR,
								LPPROPERTYSHEETCALLBACK pCallBack);
	HRESULT				AddAutoenrollmentSettingsPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool fIsComputerType);
	HRESULT				AddAddDomainEncryptedRecoveryAgentMenuItem(
								LPCONTEXTMENUCALLBACK pContextMenuCallback,
								LONG				lInsertionPointID,
								bool				bIsReadOnly);
	HRESULT				AddCertChainToPolicy (
								PCCERT_CONTEXT		pCertContext);
	HRESULT				AddCertPropPages (
								CCertificate*		pCert,
								LPPROPERTYSHEETCALLBACK pCallBack,
								LPDATAOBJECT		pDataObject,
								LONG_PTR			lNotifyHandle);
	HRESULT				AddCreateDomainEncryptedRecoveryAgentMenuItem(
								LPCONTEXTMENUCALLBACK pContextMenuCallback,
								LONG				lInsertionPointID,
								bool				bIsReadOnly);
	HRESULT				AddCRLExportMenuItem(
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	HRESULT				AddCTLExportMenuItem(
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	HRESULT				AddCTLNewMenuItem (
								LPCONTEXTMENUCALLBACK pContextMenuCallback,
								LONG				lInsertionPointID,
								bool				bIsReadOnly);
	HRESULT				AddDeletePolicyMenuItem (
								LPCONTEXTMENUCALLBACK pContextMenuCallback,
								LONG				lInsertionPointID);
    HRESULT             AddEFSSettingsPropPages (
                                LPPROPERTYSHEETCALLBACK pCallback,
                                bool fIsComputerType);
    HRESULT				AddExportMenuItem(
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	HRESULT				AddExportStoreMenuItem(
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	HRESULT				AddGPEStorePropPages(
								LPPROPERTYSHEETCALLBACK pCallBack,
                                CCertStore* pStore);
	HRESULT				AddImportMenuItem(
								LPCONTEXTMENUCALLBACK   pContextMenuCallback,
								bool				    bIsReadOnly,
                                LONG                    lInsertionPointID);
	HRESULT				AddInitPolicyMenuItem (
								LPCONTEXTMENUCALLBACK pContextMenuCallback,
								LONG				lInsertionPointID);
	HRESULT				AddOptionsMenuItem (
								LPCONTEXTMENUCALLBACK pContextMenuCallBack);
    HRESULT             AddSaferEnforcementPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool bIsComputerType);
	HRESULT				AddSaferDefinedFileTypesPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool bIsComputerType);
    HRESULT             AddSaferEntryPropertyPage (
                                LPPROPERTYSHEETCALLBACK pCallback, 
                                CCertMgrCookie* pCookie,
                                LPDATAOBJECT pDataObject, 
                                LONG_PTR lNotifyHandle);
    HRESULT             AddSaferNewEntryMenuItems (
                                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                LONG lInsertionPointID);
	HRESULT				AddSaferTrustedPublisherPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool fIsMachineType);
	HRESULT				AddScopeNode (
								CCertMgrCookie*		pCookie,
								const CString&		strServerName,
								HSCOPEITEM			hParent);
	HRESULT				AddSeparator (
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	HRESULT				AddSnapMgrPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack);
    HRESULT             BuildWMIList (LPDATAOBJECT pDataObject, bool bIsComputer);
	HRESULT				ChangeRootNodeName (
								const CString&		newName);
	HRESULT				CompleteEFSRecoveryAgent (
								CCertStoreGPE*		pStore,
								PCCERT_CONTEXT		pCertContext);
	bool				ContainerExists (
								HSCOPEITEM			hParent,
								CertificateManagerObjectType objectType);
	CCertMgrCookie*		ConvertCookie (
								LPDATAOBJECT		pDataObject);
	HRESULT				DeleteChildren (
								HSCOPEITEM			hParent);
	HRESULT				DeleteCTLFromResultPane (
								CCTL*				pCTL,
								LPDATAOBJECT		pDataObject);
	HRESULT				DeleteKeyFromRSABASE (
								PCCERT_CONTEXT		pCertContext);
	HRESULT				DeleteScopeItems (HSCOPEITEM hScopeItem = 0);
	void				DisplayAccessDenied();
	void				DisplaySystemError (
								DWORD				dwErr);
	HRESULT				ExpandScopeNodes (
								CCertMgrCookie*		pParentCookie,
								HSCOPEITEM			hParent,
								const CString&		strServerName,
								DWORD				dwLocation,
								const GUID&			guidObjectType);
    virtual bool FoundInRSOPFilter (BSTR /*bstrKey*/) const
    {
        return false;
    }
	HRESULT				GetResultData (LPRESULTDATA* ppResultData);
	bool				IsSecurityConfigurationEditorNodetype (
								const GUID&			refguid) const;
	HRESULT				IsUserAdministrator (
								BOOL&				bIsAdministrator);
	HRESULT				OnACRSEdit (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnAddDomainEncryptedDataRecoveryAgent(
								LPDATAOBJECT		pDataObject);
	HRESULT				OnCTLEdit (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnDeleteEFSPolicy (
								LPDATAOBJECT		pDataObject,
								bool				bCommitChanges);
	HRESULT				OnEnroll (
								LPDATAOBJECT		pDataObject,
								bool				bNewKey);
	HRESULT				OnExport (
								LPDATAOBJECT		pDataObject);

        HRESULT                         OnPulseAutoEnroll();

	HRESULT				OnFind (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnChangeComputer (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnImport (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnInitEFSPolicy (
								LPDATAOBJECT		pDataObject);
 	HRESULT				OnNewACRS (
 								LPDATAOBJECT		pDataObject);
	HRESULT				OnNewCTL (
								LPDATAOBJECT		pDataObject);
    HRESULT             OnCreateNewSaferPolicy (
                                LPDATAOBJECT        pDataObject);
	HRESULT             OnNewSaferEntry (
                                long nCommandID, 
                                LPDATAOBJECT pDataObject);
	HRESULT				OnNotifyPreload(
								LPDATAOBJECT		pDataObject,
								HSCOPEITEM			hRootScopeItem);
	HRESULT				OnOptions (LPDATAOBJECT pDataObject);
	virtual HRESULT		OnPropertyChange (LPARAM param);
	HRESULT				OnRenew (
								LPDATAOBJECT		pDataObject,
								bool				bNewKey);
	HRESULT				OnSetAsRecoveryCert (
								LPDATAOBJECT		pDataObject);
	HRESULT				QueryMultiSelectDataObject(
								MMC_COOKIE			cookie,
								DATA_OBJECT_TYPES	type,
                                   LPDATAOBJECT*		ppDataObject);
	HRESULT				ReleaseResultCookie (
								CBaseCookieBlock *	pResultCookie,
								CCookie&			rootCookie,
								HCERTSTORE			hStoreHandle,
								POSITION			pos2);

	// The following members are used to support Command Line override.
	// This code was copied from ..\mmcfmgmt\compdata.h.

	enum	// Bit fields for m_dwFlagsPersist
	{
		mskfAllowOverrideMachineName = 0x0001
	};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	CString m_strMachineNamePersist;	// Machine name to persist into .msc file
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line
    CString m_strLinkedHelpFile;  // Return in GetLinkedTopic ()
	
	void SetPersistentFlags(DWORD dwFlags)
	{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = !!(m_dwFlagsPersist & mskfAllowOverrideMachineName);
	}

	DWORD GetPersistentFlags()
	{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
	}

	LPHEADERCTRL	m_pHeader;

private:
	DWORD           m_dwRSOPFlagsComputer;
	DWORD           m_dwRSOPFlagsUser;
	bool            m_bIsRSOP;
	bool            m_bMachineIsStandAlone;
	bool            m_fInvalidComputer;
	CCertStore*		m_pFileBasedStore;
	CCertStore*	    m_pGPERootStore;
	CCertStore*	    m_pGPETrustStore;
	CCertStore*	    m_pGPEACRSUserStore;
	CCertStore*	    m_pGPEACRSComputerStore;
	PCRYPTUI_MMCCALLBACK_STRUCT	m_pCryptUIMMCCallbackStruct;
	bool            m_bMultipleObjectsSelected;
	HRESULT AddOpenMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddCTLOpenMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddCRLOpenMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddFindMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddPulseAutoEnrollMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddChangeComputerMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddEnrollMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly);
	HRESULT AddCertificateTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback,
			const bool bIsMyStore, bool bIsReadOnly, CCertificate* pCert);
	HRESULT AddCTLTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly);
	HRESULT AddACRTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly);
	HRESULT AddContainersToScopePane (
                HSCOPEITEM hParent, 
                CCertMgrCookie& parentCookie, 
                bool bDeleteAndExpand);
	HRESULT AddPhysicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie, const SPECIAL_STORE_TYPE storeType);
	HRESULT AddLogicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie);
    HRESULT AddSaferLevelPropPage (
                LPPROPERTYSHEETCALLBACK pCallback, 
                CSaferLevel* pSaferLevel, 
                LONG_PTR lNotifyHandle,
                LPDATAOBJECT pDataObject);
    HRESULT AddSaferLevelSetAsDefaultMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID);
	HRESULT AddUsagesToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie);
    HRESULT GetValuesAndInsertInRSOPObjectList (
                IWbemClassObject* pObject, 
                CRSOPObjectArray& rRsopObjectArray,
                bool bIsComputer);
    HRESULT GetGPOFriendlyName (PWSTR lpGPOID, PWSTR *pGPOName, bool bIsComputer);
    HRESULT OnSetSaferLevelDefault (LPDATAOBJECT pDataObject);
    HRESULT SaferEnumerateLevels (bool bIsMachine);

	DWORD			m_dwSCEMode;
	CString			m_szManagedServiceDisplayName;
	BOOL			m_bIsUserAdministrator;
	CString			m_szManagedServicePersist;
	CString			m_szFileName;
	BOOL			m_bShowPhysicalStoresPersist;
	BOOL			m_bShowArchivedCertsPersist;
	CString			m_szManagedComputer;
	CString			m_szThisComputer;
	CString			m_szLoggedInUser;
	CString			m_szManagedUser;
	DWORD			m_dwLocationPersist;
	HSCOPEITEM		m_hRootScopeItem;
	CCertMgrCookie* m_pRootCookie;
	int				m_activeViewPersist;
	LPRESULTDATA    m_pResultData;
    IRSOPInformation*   m_pRSOPInformationComputer;
    IRSOPInformation*   m_pRSOPInformationUser;
    IWbemServices *     m_pIWbemServicesComputer;
    IWbemServices *     m_pIWbemServicesUser;
    BSTR            m_pbstrLanguage;
    BSTR            m_pbstrQuery;
    BSTR            m_pbstrValueName;
    BSTR            m_pbstrRegistryKey;
    BSTR            m_pbstrValue;
    BSTR            m_pbstrPrecedence;
    BSTR            m_pbstrGPOid;
}; // CCertMgrComponentData


/////////////////////////////////////////////////////////////////////
class CCertMgrSnapin: public CCertMgrComponentData,
	public CComCoClass<CCertMgrSnapin, &CLSID_CertificateManager>
{
public:
	CCertMgrSnapin() : CCertMgrComponentData () 
    {
	    SetHtmlHelpFileName (CM_HELP_FILE);
        m_strLinkedHelpFile = CM_LINKED_HELP_FILE;
    };
	virtual ~CCertMgrSnapin() {};

// Use DECLARE_NOT_AGGREGATABLE(CCertMgrSnapin) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CCertMgrSnapin)
DECLARE_REGISTRY(CCertMgrSnapin, _T("CERTMGR.CertMgrObject.1"), _T("CERTMGR.CertMgrObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_CertificateManager;
		return S_OK;
	}
};


class CCertMgrPKPolExtension: public CCertMgrComponentData,
	public CComCoClass<CCertMgrPKPolExtension, &CLSID_CertificateManagerPKPOLExt>
{
public:
	CCertMgrPKPolExtension() : CCertMgrComponentData () 
    {
        SetHtmlHelpFileName (PKP_HELP_FILE);
        m_strLinkedHelpFile = PKP_LINKED_HELP_FILE;
    };
	virtual ~CCertMgrPKPolExtension() {};

// Use DECLARE_NOT_AGGREGATABLE(CCertMgrPKPolExtension) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CCertMgrPKPolExtension)
DECLARE_REGISTRY(CCertMgrPKPolExtension, _T("CERTMGR.CertMgrPKPolExtObject.1"), _T("CERTMGR.CertMgrPKPolExtObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }
	virtual BOOL IsExtensionSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_CertificateManagerPKPOLExt;
		return S_OK;
	}

    virtual bool FoundInRSOPFilter (BSTR bstrKey) const;
};

class CSaferWindowsExtension: public CCertMgrComponentData,
	public CComCoClass<CSaferWindowsExtension, &CLSID_SaferWindowsExtension>
{
public:
	CSaferWindowsExtension();
	virtual ~CSaferWindowsExtension() {};

// Use DECLARE_NOT_AGGREGATABLE(CSaferWindowsExtension) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CSaferWindowsExtension)
DECLARE_REGISTRY(CSaferWindowsExtension, _T("CERTMGR.CertMgrSaferWindowsExtensionObject.1"), 
                 _T("CERTMGR.CertMgrSaferWindowsExtensionObject.1"), IDS_CERTMGR_SAFER_WINDOWS_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }
	virtual BOOL IsExtensionSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_SaferWindowsExtension;
		return S_OK;
	}

    virtual bool FoundInRSOPFilter (BSTR bstrKey) const;
};

#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\compdata.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       compdata.cpp
//
//  Contents:   Implementation of CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTMGR (compdata.cpp)")
#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "snapmgr.h"
#include "Certifct.h"
#include "dlgs.h"
#include "SelAcct.h"
#include "FindDlg.h"
#pragma warning(push, 3)
#include <wintrust.h>
#include <cryptui.h>
#include <sceattch.h>
#pragma warning(pop)
#include "selservc.h"
#include "acrgenpg.h"
#include "acrspsht.h"
#include "acrswlcm.h"
#include "acrstype.h"

#include "acrslast.h"
#include "addsheet.h"
#include "gpepage.h"
#include "password.h"
#include "storegpe.h"
#include "uuids.h"
#include "StoreRSOP.h"
#include "PolicyPrecedencePropertyPage.h"
#include "AutoenrollmentPropertyPage.h"
#include "SaferEntry.h"
#include "SaferUtil.h"
#include "SaferDefinedFileTypesPropertyPage.h"
#include "EFSGeneralPropertyPage.h"


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stdcdata.cpp" // CComponentData implementation

extern	HINSTANCE	g_hInstance;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

//
// CCertMgrComponentData
//

extern	CString	g_szFileName; // If not empty, was called from command-line.

CCertMgrComponentData::CCertMgrComponentData ()
	: m_pRootCookie (0),
	m_activeViewPersist (IDM_STORE_VIEW),
	m_hRootScopeItem (0),
	m_bShowPhysicalStoresPersist (0),
	m_bShowArchivedCertsPersist (0),
	m_fAllowOverrideMachineName (0),
	m_dwFlagsPersist (0),
	m_dwLocationPersist (0),
	m_pResultData (0),
	m_pGPEInformation (0),
    m_pRSOPInformationComputer (0),
    m_pRSOPInformationUser (0),
	m_bIsUserAdministrator (FALSE),
	m_dwSCEMode (SCE_MODE_UNKNOWN),
	m_pHeader (0),
	m_bMultipleObjectsSelected (false) ,
	m_pCryptUIMMCCallbackStruct (0),
    m_pGPERootStore (0),
	m_pGPETrustStore (0),
	m_pFileBasedStore (0),
	m_pGPEACRSUserStore (0),
	m_pGPEACRSComputerStore (0),
	m_fInvalidComputer (false),
    m_bMachineIsStandAlone (true),
    m_pComponentConsole (0),
    m_bIsRSOP (false),
    m_pIWbemServicesComputer (0),
    m_pIWbemServicesUser (0),
    m_pbstrLanguage (SysAllocString (STR_WQL)),
    m_pbstrQuery (SysAllocString (STR_SELECT_STATEMENT)),
    m_pbstrValueName (SysAllocString (STR_PROP_VALUENAME)),
    m_pbstrRegistryKey (SysAllocString (STR_PROP_REGISTRYKEY)),
    m_pbstrValue (SysAllocString (STR_PROP_VALUE)),
    m_pbstrPrecedence (SysAllocString (STR_PROP_PRECEDENCE)),
    m_pbstrGPOid (SysAllocString (STR_PROP_GPOID)),
    m_dwRSOPFlagsComputer (0),
    m_dwRSOPFlagsUser (0),
    m_dwDefaultSaferLevel (0),
    m_pdwSaferLevels (0),
    m_bSaferSupported (false)
{
	_TRACE (1, L"Entering CCertMgrComponentData::CCertMgrComponentData\n");
    m_pRootCookie = new CCertMgrCookie (CERTMGR_SNAPIN);

	// Get name of logged-in user
	DWORD	dwSize = 0;
	::GetUserName (0, &dwSize);
	BOOL bRet = ::GetUserName (m_szLoggedInUser.GetBufferSetLength (dwSize), &dwSize);
	ASSERT (bRet);
	m_szLoggedInUser.ReleaseBuffer ();

	// Get name of this computer
	dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
	bRet = ::GetComputerName (m_szThisComputer.GetBufferSetLength (MAX_COMPUTERNAME_LENGTH + 1 ), &dwSize);
	ASSERT (bRet);
	m_szThisComputer.ReleaseBuffer ();

	// Find out if logged-in users is an Administrator
	IsUserAdministrator (m_bIsUserAdministrator);

	if ( !g_szFileName.IsEmpty () )
	{
		m_szFileName = g_szFileName;
		g_szFileName = _T ("");
	}

    // Find out if we're joined to a domain.
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pInfo = 0;
    DWORD dwErr = ::DsRoleGetPrimaryDomainInformation (
            0,
            DsRolePrimaryDomainInfoBasic, 
            (PBYTE*) &pInfo);
    if ( ERROR_SUCCESS == dwErr )
    {
        switch (pInfo->MachineRole)
        {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            m_bMachineIsStandAlone = true;
            break;

        case DsRole_RoleMemberWorkstation:
        case DsRole_RoleMemberServer:
        case DsRole_RoleBackupDomainController:
        case DsRole_RolePrimaryDomainController:
            m_bMachineIsStandAlone = false;
            break;

        default:
            break;
        }
    }
    else
    {
        _TRACE (0, L"DsRoleGetPrimaryDomainInformation () failed: 0x%x\n", dwErr);
    }
    NetApiBufferFree (pInfo);

	_TRACE (-1, L"Leaving CCertMgrComponentData::CCertMgrComponentData\n");
}

CCertMgrComponentData::~CCertMgrComponentData ()
{
	_TRACE (1, L"Entering CCertMgrComponentData::~CCertMgrComponentData\n");
	if ( m_pCryptUIMMCCallbackStruct )
	{
		::MMCFreeNotifyHandle (m_pCryptUIMMCCallbackStruct->lNotifyHandle);
		((LPDATAOBJECT)(m_pCryptUIMMCCallbackStruct->param))->Release ();
		::GlobalFree (m_pCryptUIMMCCallbackStruct);
		m_pCryptUIMMCCallbackStruct = 0;
	}

    if ( m_pGPERootStore )
    {
        m_pGPERootStore->Release ();
        m_pGPERootStore = 0;
    }
    if ( m_pGPETrustStore )
    {
        m_pGPETrustStore->Release ();
        m_pGPETrustStore = 0;
    }
	if ( m_pFileBasedStore )
	{
		m_pFileBasedStore->Release ();
		m_pFileBasedStore = 0;
	}

	if ( m_pGPEACRSUserStore )
	{
		m_pGPEACRSUserStore->Release ();
		m_pGPEACRSUserStore = 0;
	}

	if ( m_pGPEACRSComputerStore )
	{
		m_pGPEACRSComputerStore->Release ();
		m_pGPEACRSComputerStore = 0;
	}

	CCookie& rootCookie = QueryBaseRootCookie ();
	while ( !rootCookie.m_listResultCookieBlocks.IsEmpty() )
	{
		(rootCookie.m_listResultCookieBlocks.RemoveHead())->Release();
	}
	if ( m_pGPEInformation )
	{
		m_pGPEInformation->Release ();
		m_pGPEInformation = 0;
	}

    if ( m_pRSOPInformationComputer )
    {
        m_pRSOPInformationComputer->Release ();
        m_pRSOPInformationComputer = 0;
    }
    if ( m_pRSOPInformationUser )
    {
        m_pRSOPInformationUser->Release ();
        m_pRSOPInformationUser = 0;
    }

    if ( m_pResultData )
    {
        m_pResultData->Release ();
        m_pResultData = 0;
    }

    if ( m_pComponentConsole )
    {
        SAFE_RELEASE (m_pComponentConsole);
        m_pComponentConsole = 0;
    }

    if (m_pbstrLanguage)
        SysFreeString (m_pbstrLanguage);

    if (m_pbstrQuery)
        SysFreeString (m_pbstrQuery);

    if (m_pbstrRegistryKey)
        SysFreeString (m_pbstrRegistryKey);

    if (m_pbstrValueName)
        SysFreeString (m_pbstrValueName);

    if (m_pbstrValue)
        SysFreeString (m_pbstrValue);

    if ( m_pbstrPrecedence )
        SysFreeString (m_pbstrPrecedence);

    if ( m_pbstrGPOid )
        SysFreeString (m_pbstrGPOid);

    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArrayComputer.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pCurrObject = m_rsopObjectArrayComputer.GetAt (nIndex);
        if ( pCurrObject )
        {
            delete pCurrObject;
        }
        nIndex++;
    }
    m_rsopObjectArrayComputer.RemoveAll ();


    nIndex = 0;
    nUpperBound = m_rsopObjectArrayUser.GetUpperBound ();
    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pCurrObject = m_rsopObjectArrayUser.GetAt (nIndex);
        if ( pCurrObject )
        {
            delete pCurrObject;
        }
        nIndex++;
    }
    m_rsopObjectArrayUser.RemoveAll ();

    if ( m_pIWbemServicesComputer )
        m_pIWbemServicesComputer->Release ();

    if ( m_pIWbemServicesUser )
        m_pIWbemServicesUser->Release ();

    if ( m_pRootCookie )
        m_pRootCookie->Release ();

    if ( m_pdwSaferLevels )
        delete m_pdwSaferLevels;

    _TRACE (-1, L"Leaving CCertMgrComponentData::~CCertMgrComponentData\n");
}

DEFINE_FORWARDS_MACHINE_NAME ( CCertMgrComponentData, (m_pRootCookie) )

CCookie& CCertMgrComponentData::QueryBaseRootCookie ()
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::QueryBaseRootCookie\n");
    ASSERT (m_pRootCookie);
	return (CCookie&) *m_pRootCookie;
}


STDMETHODIMP CCertMgrComponentData::CreateComponent (LPCOMPONENT* ppComponent)
{
	_TRACE (1, L"Entering CCertMgrComponentData::CreateComponent\n");

    ASSERT (ppComponent);

    CComObject<CCertMgrComponent>* pObject = 0;
    CComObject<CCertMgrComponent>::CreateInstance (&pObject);
    ASSERT (pObject);
	pObject->SetComponentDataPtr ( (CCertMgrComponentData*) this);

    HRESULT hr = pObject->QueryInterface (IID_PPV_ARG (IComponent, ppComponent));
	_TRACE (1, L"Entering CCertMgrComponentData::CreateComponent\n");
	return hr;
}

HRESULT CCertMgrComponentData::LoadIcons (LPIMAGELIST pImageList, BOOL /*fLoadLargeIcons*/)
{
	_TRACE (1, L"Entering CCertMgrComponentData::LoadIcons\n");
	// Structure to map a Resource ID to an index of icon
	struct RESID2IICON
	{
		UINT uIconId;	// Icon resource ID
		int iIcon;		// Index of the icon in the image list
	};
	const static RESID2IICON rgzLoadIconList[] =
	{
		// Misc icons
		{ IDI_CERTIFICATE, iIconCertificate },
		{ IDI_CTL, iIconCTL },
		{ IDI_CRL, iIconCRL },
		{ IDI_AUTO_CERT_REQUEST, iIconAutoCertRequest },
        { IDI_AUTOENROLL, iIconAutoEnroll },
        { IDI_SAFER_LEVEL, iIconSaferLevel },
        { IDI_DEFAULT_SAFER_LEVEL, iIconDefaultSaferLevel },
        { IDI_SAFER_HASH_ENTRY, iIconSaferHashEntry },
        { IDI_SAFER_URL_ENTRY, iIconSaferURLEntry },
        { IDI_SAFER_NAME_ENTRY, iIconSaferNameEntry },
        { IDI_SETTINGS, iIconSettings },
        { IDI_SAFER_CERT_ENTRY, iIconSaferCertEntry },
		{ 0, 0} // Must be last
	};


	for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
	{
		HICON hIcon = ::LoadIcon (AfxGetInstanceHandle (),
				MAKEINTRESOURCE (rgzLoadIconList[i].uIconId));
		ASSERT (hIcon && "Icon ID not found in resources");
		/*HRESULT hr =*/ pImageList->ImageListSetIcon ( (PLONG_PTR) hIcon,
				rgzLoadIconList[i].iIcon);
//		ASSERT (SUCCEEDED (hr) && "Unable to add icon to ImageList");
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::LoadIcons\n");
    return S_OK;
}


HRESULT CCertMgrComponentData::OnNotifyExpand (LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnNotifyExpand\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CWaitCursor	waitCursor;
	ASSERT (pDataObject && hParent && m_pConsoleNameSpace);
	if (!bExpanding)
		return S_OK;

    static bool bDomainVersionChecked = false;

    if ( !bDomainVersionChecked ) 
    {
        if ( !m_bMachineIsStandAlone )  // only check if joined to a domain
            CheckDomainVersion ();
        bDomainVersionChecked = true;
    }

	GUID guidObjectType;
	HRESULT hr = ExtractObjectTypeGUID (pDataObject, &guidObjectType);
	ASSERT (SUCCEEDED (hr));
	if ( IsSecurityConfigurationEditorNodetype (guidObjectType) )
	{
		hr = ExtractData (pDataObject, CCertMgrDataObject::m_CFSCEModeType,
				&m_dwSCEMode, sizeof (DWORD));
		ASSERT (SUCCEEDED (hr));
		if ( SUCCEEDED (hr) )
		{
			switch (m_dwSCEMode)
			{
			case SCE_MODE_DOMAIN_USER:	// User Settings
			case SCE_MODE_OU_USER:
            case SCE_MODE_LOCAL_USER:
			case SCE_MODE_DOMAIN_COMPUTER:	// Computer Settings
			case SCE_MODE_OU_COMPUTER:
			case SCE_MODE_LOCAL_COMPUTER:
                m_bIsRSOP = false;
				if ( !m_pGPEInformation )
				{
					IUnknown* pIUnknown = 0;

					hr = ExtractData (pDataObject,
						CCertMgrDataObject::m_CFSCE_GPTUnknown,
						&pIUnknown, sizeof (IUnknown*));
					ASSERT (SUCCEEDED (hr));
					if ( SUCCEEDED (hr) )
					{
						hr = pIUnknown->QueryInterface (
								IID_PPV_ARG (IGPEInformation, &m_pGPEInformation));
						ASSERT (SUCCEEDED (hr));
#if DBG
                        if ( SUCCEEDED (hr) )
                        {
                            const int cbLen = 512;
                            WCHAR   szName[cbLen];
                            hr = m_pGPEInformation->GetName (szName, cbLen);
                            if ( SUCCEEDED (hr) )
                            {
                                _TRACE (0, L"IGPEInformation::GetName () returned: %s",
                                        szName);
                            }
                            else
                            {
                                _TRACE (0, L"IGPEInformation::GetName () failed: 0x%x\n", hr);
                            }
                        }
#endif
                        pIUnknown->Release ();
					}
				}

                if ( SUCCEEDED (hr) )
				{
					switch (m_dwSCEMode)
					{
					case SCE_MODE_DOMAIN_USER:
					case SCE_MODE_OU_USER:
                    case SCE_MODE_LOCAL_USER:
						hr = ExpandScopeNodes (NULL, hParent, _T (""),
							CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, NODEID_User);
						break;

					case SCE_MODE_DOMAIN_COMPUTER:
					case SCE_MODE_OU_COMPUTER:
					case SCE_MODE_LOCAL_COMPUTER:
						hr = ExpandScopeNodes (NULL, hParent, _T (""),
							CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, NODEID_Machine);
						break;

					default:
						ASSERT (0);
						hr = E_FAIL;
						break;
					}
				}
                break;

            case SCE_MODE_RSOP_USER:
            case SCE_MODE_RSOP_COMPUTER:
                m_bIsRSOP = true;
                hr = BuildWMIList (pDataObject, SCE_MODE_RSOP_COMPUTER == m_dwSCEMode);
                if ( SUCCEEDED (hr) )
				{
					switch (m_dwSCEMode)
					{
                    case SCE_MODE_RSOP_USER:
						hr = ExpandScopeNodes (NULL, hParent, _T (""),
							CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, 
                            NODEID_User);
						break;

					case SCE_MODE_RSOP_COMPUTER:
						hr = ExpandScopeNodes (NULL, hParent, _T (""),
							CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, 
                            NODEID_Machine);
						break;

					default:
						ASSERT (0);
						hr = E_FAIL;
						break;
					}
				}
				break;

			default:
				// we are not extending other nodes
				break;
			}
		}

		return hr;
	}

	// Beyond this point we are not dealing with extension node types.
	{
		CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
		if ( pParentCookie )
		{
			hr = ExpandScopeNodes (pParentCookie, hParent, _T (""), 0, guidObjectType);
		}
		else
			hr = E_UNEXPECTED;
	}


	_TRACE (-1, L"Leaving CCertMgrComponentData::OnNotifyExpand: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::OnNotifyRelease (LPDATAOBJECT /*pDataObject*/, HSCOPEITEM hItem)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnNotifyRelease\n");

	HRESULT	hr = DeleteChildren (hItem);

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnNotifyRelease: 0x%x\n", hr);
	return hr;
}


BSTR CCertMgrComponentData::QueryResultColumnText (CCookie& basecookie, int nCol)
{
//	_TRACE (1, L"Entering CCertMgrComponentData::QueryResultColumnText\n");
	CCertMgrCookie& cookie = (CCertMgrCookie&) basecookie;
	BSTR	strResult = L"";

#ifndef UNICODE
#error not ANSI-enabled
#endif
	switch ( cookie.m_objecttype )
	{
		case CERTMGR_SNAPIN:
		case CERTMGR_USAGE:
		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_CERT_POLICIES_USER:
		case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
			if ( 0 == nCol )
				strResult = const_cast<BSTR> (cookie.GetObjectName ());
			break;

        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
			if ( 0 == nCol )
				strResult = const_cast<BSTR> (cookie.GetObjectName ());
			break;

        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            ASSERT (0);
            break;

        case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
			if (COLNUM_CERT_SUBJECT == nCol)
			{
				CCertStore* pStore = reinterpret_cast <CCertStore*> (&cookie);
				ASSERT (pStore);
				if ( pStore )
					strResult = const_cast<BSTR> (pStore->GetLocalizedName ());
			}
			break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

		case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
		case CERTMGR_NULL_POLICY:
			_TRACE (0, L"CCertMgrComponentData::QueryResultColumnText bad parent type\n");
			ASSERT (0);
			break;

		default:
            ASSERT (0);
			break;
	}

//	_TRACE (-1, L"Leaving CCertMgrComponentData::QueryResultColumnText\n");
	return strResult;
}

int CCertMgrComponentData::QueryImage (CCookie& basecookie, BOOL /*fOpenImage*/)
{
//	_TRACE (1, L"Entering CCertMgrComponentData::QueryImage\n");
	int				nIcon = 0;

	CCertMgrCookie& cookie = (CCertMgrCookie&)basecookie;
	switch ( cookie.m_objecttype )
	{
		case CERTMGR_SNAPIN:
			nIcon = iIconCertificate;
			break;

		case CERTMGR_USAGE:
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_CERT_POLICIES_USER:
		case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
			break;

		case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
			ASSERT (0);	// not expected in scope pane
			break;

		default:
			_TRACE (0, L"CCertMgrComponentData::QueryImage bad parent type\n");
			ASSERT (0);
			break;
	}
//	_TRACE (-1, L"Leaving CCertMgrComponentData::QueryImage\n");
	return nIcon;
}


///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CCertMgrComponentData::QueryPagesFor (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::QueryPagesFor\n");
	HRESULT	hr = S_OK;
	ASSERT (pDataObject);

	if ( pDataObject )
	{
		DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
		hr = ExtractData (pDataObject,
				CCertMgrDataObject::m_CFDataObjectType,
				 &dataobjecttype, sizeof (dataobjecttype));
		if ( SUCCEEDED (hr) )
		{
			switch (dataobjecttype)
			{
			case CCT_SNAPIN_MANAGER:
				if ( !m_bIsUserAdministrator )
				{
					// Non-admins may manage only their own certs
					m_dwLocationPersist = CERT_SYSTEM_STORE_CURRENT_USER;
					hr = S_FALSE;
				}	
				break;

			case CCT_RESULT:
				{
					hr = S_FALSE;
					CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
					if ( pParentCookie )
					{
						switch (pParentCookie->m_objecttype)
						{
						case CERTMGR_CERTIFICATE:
						case CERTMGR_AUTO_CERT_REQUEST:
                        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        case CERTMGR_SAFER_COMPUTER_LEVEL:
                        case CERTMGR_SAFER_USER_LEVEL:
                        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                        case CERTMGR_SAFER_COMPUTER_ENTRY:
                        case CERTMGR_SAFER_USER_ENTRY:
                        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                        case CERTMGR_SAFER_USER_ENFORCEMENT:
							hr = S_OK;
							break;

						default:
							break;
						}
					}
				}
				break;

			case CCT_SCOPE:
				{
					CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
					if ( pParentCookie )
					{
						switch ( pParentCookie->m_objecttype )
						{
						case CERTMGR_LOG_STORE_GPE:
						case CERTMGR_LOG_STORE_RSOP:
							{
								CCertStore* pStore = reinterpret_cast <CCertStore*> (pParentCookie);
								ASSERT (pStore);
								if ( pStore )
                                {
                                    switch (pStore->GetStoreType ())
                                    {
                                    case ROOT_STORE:
                                    case EFS_STORE:
                                        hr = S_OK;
                                        break;

                                    default:
                                        break;
                                    }
								}
								else
									hr = S_FALSE;
							}
							break;

						default:
							hr = S_FALSE;
							break;
						}
					}
					else
					{
						hr = S_FALSE;
					}
				}
				break;

			default:
				hr = S_FALSE;
				break;
			}
		}
	}
	else
		hr = E_POINTER;
	

	_TRACE (-1, L"Leaving CCertMgrComponentData::QueryPagesFor: 0x%x\n", hr);
	return hr;
}

STDMETHODIMP CCertMgrComponentData::CreatePropertyPages (
	LPPROPERTYSHEETCALLBACK pCallback,
    LONG_PTR handle,		// This handle must be saved in the property page object to notify the parent when modified
	LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::CreatePropertyPages\n");
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = S_OK;


	ASSERT (pCallback && pDataObject);
	if ( pCallback && pDataObject )
	{
		DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
		hr = ExtractData (pDataObject,
				CCertMgrDataObject::m_CFDataObjectType,
				 &dataobjecttype, sizeof (dataobjecttype));
		switch (dataobjecttype)
		{
		case CCT_SNAPIN_MANAGER:
			hr = AddSnapMgrPropPages (pCallback);
			break;

		case CCT_RESULT:
			{
				CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
				if ( pParentCookie )
				{
                    switch (pParentCookie->m_objecttype)
                    {
                    case CERTMGR_CERTIFICATE:
                        {
						    CCertificate* pCert = reinterpret_cast <CCertificate*> (pParentCookie);
						    ASSERT (pCert);
						    if ( pCert )
						    {
							    // Anything, except ACRS
							    hr = AddCertPropPages (pCert, pCallback, pDataObject, handle);
						    }
						    else
							    hr = E_FAIL;
                        }
                        break;

                    case CERTMGR_AUTO_CERT_REQUEST:
					    {
						    CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pParentCookie);
						    ASSERT (pACR);
						    if ( pACR )
						    {
							    hr = AddACRSCTLPropPages (pACR, pCallback);
						    }
						    else
							    hr = E_FAIL;
					    }
                        break;

                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        hr = AddAutoenrollmentSettingsPropPages (pCallback,        
                                CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS == 
                                        pParentCookie->m_objecttype);
                        break;
                    
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                        hr = AddSaferLevelPropPage (pCallback,
                                dynamic_cast <CSaferLevel*>(pParentCookie),
                                handle,
                                pDataObject);
                        break;

                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                        hr = AddSaferTrustedPublisherPropPages (pCallback,        
                                CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS == 
                                    pParentCookie->m_objecttype);
                        break;

                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                        hr = AddSaferDefinedFileTypesPropPages (pCallback,        
                                CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES == 
                                    pParentCookie->m_objecttype);
                        break;

                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                        hr = AddSaferEnforcementPropPages (pCallback,        
                                CERTMGR_SAFER_COMPUTER_ENFORCEMENT == 
                                    pParentCookie->m_objecttype);
                        break;

                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                        hr = AddSaferEntryPropertyPage (pCallback, 
                                pParentCookie, pDataObject, handle);
                        break;

                    default:
                        break;
                    }
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

		case CCT_SCOPE:
			{
				CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
				if ( pParentCookie )
				{
					switch ( pParentCookie->m_objecttype )
					{
					case CERTMGR_LOG_STORE_GPE:
					case CERTMGR_LOG_STORE_RSOP:
						{
							CCertStore* pStore = reinterpret_cast <CCertStore*> (pParentCookie);
							ASSERT (pStore);
							if ( pStore )
							{
								if ( ROOT_STORE == pStore->GetStoreType () )
								{
									hr = AddGPEStorePropPages (pCallback, pStore);
								}
                                else if ( EFS_STORE == pStore->GetStoreType () )
                                {
                                    hr = AddEFSSettingsPropPages (pCallback,        
                                            pStore->IsMachineStore ());
                                }
							}
							else
								hr = E_FAIL;
						}
						break;
                    
                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        ASSERT (0);
                        break;

					default:
						break;
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			break;


		default:
			break;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::CreatePropertyPages: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddSnapMgrPropPages (LPPROPERTYSHEETCALLBACK pCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSnapMgrPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		//
		// Note that once we have established that this is a CCT_SNAPIN_MANAGER cookie,
		// we don't care about its other properties.  A CCT_SNAPIN_MANAGER cookie is
		// equivalent to a BOOL flag asking for the Node Properties page instead of a
		// managed object property page.  JonN 10/9/96
		//
		if ( m_bIsUserAdministrator )
		{
			CSelectAccountPropPage * pSelAcctPage =
					new CSelectAccountPropPage (IsWindowsNT ());
			if ( pSelAcctPage )
			{
				pSelAcctPage->AssignLocationPtr (&m_dwLocationPersist);
				HPROPSHEETPAGE hSelAcctPage = MyCreatePropertySheetPage (&pSelAcctPage->m_psp);
                if ( hSelAcctPage )
                {
				    hr = pCallback->AddPage (hSelAcctPage);
				    ASSERT (SUCCEEDED (hr));
                    if ( FAILED (hr) )
                        VERIFY (::DestroyPropertySheetPage (hSelAcctPage));
                }
                else
                    delete pSelAcctPage;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}

			// In Windows 95 or Windows 98,users will only be able to manage the
			// local machine.
			if ( IsWindowsNT () )
			{
				CCertMgrChooseMachinePropPage * pChooseMachinePage = new CCertMgrChooseMachinePropPage ();
				if ( pChooseMachinePage )
				{
					pChooseMachinePage->AssignLocationPtr (&m_dwLocationPersist);

					// Initialize state of object
                    ASSERT (m_pRootCookie);
                    if ( m_pRootCookie )
                    {
					    pChooseMachinePage->InitMachineName (m_pRootCookie->QueryTargetServer ());
					    pChooseMachinePage->SetOutputBuffers (
						    OUT &m_strMachineNamePersist,
						    OUT &m_fAllowOverrideMachineName,
						    OUT &m_pRootCookie->m_strMachineName);	// Effective machine name

					    HPROPSHEETPAGE hChooseMachinePage = MyCreatePropertySheetPage (&pChooseMachinePage->m_psp);
                        if ( hChooseMachinePage )
                        {
					        hr = pCallback->AddPage (hChooseMachinePage);
					        ASSERT (SUCCEEDED (hr));
                            if ( FAILED (hr) )
                                VERIFY (::DestroyPropertySheetPage (hChooseMachinePage));
                        }
                        else
                            delete pChooseMachinePage;
                    }
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}

				CSelectServiceAccountPropPage* pServicePage = new
						CSelectServiceAccountPropPage (&m_szManagedServicePersist,
							&m_szManagedServiceDisplayName,
							m_strMachineNamePersist);
				if ( pServicePage )
				{
//					pServicePage->SetCaption (IDS_MS_CERT_MGR); // access violation when called

					HPROPSHEETPAGE hServicePage = MyCreatePropertySheetPage (&pServicePage->m_psp);
                    if ( hServicePage )
                    {
					    hr = pCallback->AddPage (hServicePage);
					    ASSERT (SUCCEEDED (hr));
                        if ( FAILED (hr) )
                            VERIFY (::DestroyPropertySheetPage (hServicePage));

                    }
                    else
                        delete pServicePage;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
		else
		{
			// Non-administrators may view their own certs only.
			m_dwLocationPersist = CERT_SYSTEM_STORE_CURRENT_USER;
		}


	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSnapMgrPropPages: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddACRSCTLPropPages (CAutoCertRequest* pACR, LPPROPERTYSHEETCALLBACK pCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddACRSCTLPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pACR && pCallback);
	if ( pACR && pCallback )
	{
		CACRGeneralPage * pACRPage = new CACRGeneralPage (*pACR);
		if ( pACRPage )
		{
			HPROPSHEETPAGE hACRPage = MyCreatePropertySheetPage (&pACRPage->m_psp);
            if ( hACRPage )
            {
			    hr = pCallback->AddPage (hACRPage);
			    ASSERT (SUCCEEDED (hr));
                if ( FAILED (hr) )
                    VERIFY (::DestroyPropertySheetPage (hACRPage));
            }
            else
                delete pACRPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddACRSCTLPropPages: 0x%x\n", hr);
	return hr;
}

 
HRESULT CCertMgrComponentData::AddEFSSettingsPropPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    bool fIsComputerType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddEFSSettingsPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CEFSGeneralPropertyPage * pEFSPage = new CEFSGeneralPropertyPage (
                this, fIsComputerType);
		if ( pEFSPage )
		{
			HPROPSHEETPAGE hEFSPage = MyCreatePropertySheetPage (&pEFSPage->m_psp);
            if ( hEFSPage )
            {
			    hr = pCallback->AddPage (hEFSPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
	                    CString storePath = EFS_SETTINGS_REGPATH;
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, storePath,
                                        EFS_SETTINGS_REGVALUE,
                                        fIsComputerType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                    VERIFY (::DestroyPropertySheetPage (hEFSPage));
            }
            else
                delete pEFSPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddEFSSettingsPropPages: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddAutoenrollmentSettingsPropPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    bool fIsComputerType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddAutoenrollmentSettingsPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CAutoenrollmentPropertyPage * pAutoEnrollmentPage = new CAutoenrollmentPropertyPage (
                this, fIsComputerType);
		if ( pAutoEnrollmentPage )
		{
			HPROPSHEETPAGE hAutoEnrollmentPage = MyCreatePropertySheetPage (&pAutoEnrollmentPage->m_psp);
            if ( hAutoEnrollmentPage )
            {
			    hr = pCallback->AddPage (hAutoEnrollmentPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
	                    CString storePath = AUTO_ENROLLMENT_KEY;
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, storePath,
                                        AUTO_ENROLLMENT_POLICY,
                                        fIsComputerType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                    VERIFY (::DestroyPropertySheetPage (hAutoEnrollmentPage));
            }
            else
                delete pAutoEnrollmentPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddAutoenrollmentSettingsPropPages: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddGPEStorePropPages (
        LPPROPERTYSHEETCALLBACK pCallback, 
        CCertStore* pStore)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddGPEStorePropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback && pStore);
	if ( !pCallback || !pStore)
		return E_POINTER;
	ASSERT (m_pGPEInformation || m_pRSOPInformationComputer || m_pRSOPInformationUser );
	if ( !m_pGPEInformation && !m_pRSOPInformationComputer && !m_pRSOPInformationUser )
		return E_UNEXPECTED;

    bool bIsComputerType = pStore->IsMachineStore ();

	CGPERootGeneralPage * pGPERootPage = new CGPERootGeneralPage (this, bIsComputerType);
	if ( pGPERootPage )
	{
		HPROPSHEETPAGE hGPERootPage = MyCreatePropertySheetPage (&pGPERootPage->m_psp);
        if ( hGPERootPage )
        {
		    hr = pCallback->AddPage (hGPERootPage);
		    ASSERT (SUCCEEDED (hr));
            if ( FAILED (hr) )
                VERIFY (::DestroyPropertySheetPage (hGPERootPage));
        }
        else
            delete pGPERootPage;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

    if ( SUCCEEDED (hr) )
    {
        if ( m_bIsRSOP )
        {
	        CString storePath = CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH;
            storePath += L"\\";
            storePath += pStore->GetStoreName ();

            CPolicyPrecedencePropertyPage * pPrecedencePage = 
                    new CPolicyPrecedencePropertyPage (this, storePath, STR_BLOB, bIsComputerType);
	        if ( pPrecedencePage )
	        {
		        HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                if ( hPrecedencePage )
                {
		            hr = pCallback->AddPage (hPrecedencePage);
		            ASSERT (SUCCEEDED (hr));
                    if ( FAILED (hr) )
                        VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                }
                else
                    delete pPrecedencePage;
	        }
	        else
	        {
		        hr = E_OUTOFMEMORY;
            }
        }
    }

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddGPEStorePropPages: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCertPropPages (CCertificate * pCert, LPPROPERTYSHEETCALLBACK pCallback, LPDATAOBJECT pDataObject, LONG_PTR lNotifyHandle)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCertPropPages\n");
	HRESULT			hr = S_OK;
    CWaitCursor     waitCursor;
	ASSERT (pCert);
	ASSERT (pCallback);
	if ( pCert && pCallback )
	{
		PROPSHEETPAGEW*								ppsp = 0;
		DWORD										dwPageCnt = 0;
		CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT	sps;
		HCERTSTORE*									pPropPageStores = new HCERTSTORE[1];

        if ( pPropPageStores )
        {
		    m_pCryptUIMMCCallbackStruct = (PCRYPTUI_MMCCALLBACK_STRUCT)
				    ::GlobalAlloc (GMEM_FIXED, sizeof (CRYPTUI_MMCCALLBACK_STRUCT));
		    if ( m_pCryptUIMMCCallbackStruct )
		    {
			    m_pCryptUIMMCCallbackStruct->pfnCallback = &MMCPropertyChangeNotify;
			    m_pCryptUIMMCCallbackStruct->lNotifyHandle = lNotifyHandle;
			    pDataObject->AddRef ();
			    m_pCryptUIMMCCallbackStruct->param = (LPARAM) pDataObject;

                CCertStore* pStore = pCert->GetCertStore ();
                if ( pStore )
                {
			        pPropPageStores[0] = pStore->GetStoreHandle ();
			        ::ZeroMemory (&sps, sizeof (sps));
			        sps.dwSize = sizeof (sps);
			        sps.pMMCCallback = m_pCryptUIMMCCallbackStruct;
			        sps.pCertContext = pCert->GetNewCertContext ();
			        sps.cStores = 1;
			        sps.rghStores = pPropPageStores;

                    // All dialogs should be read-only under RSOP
                    if ( m_bIsRSOP || pCert->IsReadOnly () )
                        sps.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;
            
        	        _TRACE (0, L"Calling CryptUIGetCertificatePropertiesPages()\n");
			        BOOL bReturn = ::CryptUIGetCertificatePropertiesPages (
				        &sps,
				        NULL,
				        &ppsp,
				        &dwPageCnt);
			        ASSERT (bReturn);
			        if ( bReturn )
			        {
				        HPROPSHEETPAGE	hPage = 0;
				        for (DWORD dwIndex = 0; dwIndex < dwPageCnt; dwIndex++)
				        {
        	                _TRACE (0, L"Calling CreatePropertySheetPage()\n");
                            // Not necessary to call MyCreatePropertySheetPage here
                            // as these are not MFC-based property pages
                            hPage = ::CreatePropertySheetPage (&ppsp[dwIndex]);
					        if ( hPage )
					        {
						        hr = pCallback->AddPage (hPage);
						        ASSERT (SUCCEEDED (hr));
						        if ( FAILED (hr) )
						        {
							        VERIFY (::DestroyPropertySheetPage (hPage));
							        break;
						        }
					        }
					        else
					        {
						        hr = HRESULT_FROM_WIN32 (GetLastError ());
						        break;
					        }
				        }
			        }
			        else
                    {
                        hr = E_UNEXPECTED;
                        GlobalFree (m_pCryptUIMMCCallbackStruct);
                        ::CertFreeCertificateContext (sps.pCertContext);
                    }
                }
		    }
		    else
		    {
			    hr = E_OUTOFMEMORY;
		    }

            if ( E_OUTOFMEMORY == hr && ppsp )
                free (ppsp);    // source uses malloc

	        delete [] pPropPageStores;
        }
        else
            hr = E_OUTOFMEMORY;
	}
	else
		hr = E_POINTER;


	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCertPropPages: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddContainersToScopePane (
		HSCOPEITEM hParent,
		CCertMgrCookie& parentCookie,
        bool bDeleteAndExpand)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddContainersToScopePane\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    LPCONSOLENAMESPACE2 pConsoleNameSpace2 = 0;
    HRESULT hr = m_pConsoleNameSpace->QueryInterface (
		    IID_PPV_ARG (IConsoleNameSpace2, &pConsoleNameSpace2));
    if ( SUCCEEDED (hr) && pConsoleNameSpace2 )
    {
        hr = pConsoleNameSpace2->Expand (hParent);
        ASSERT (SUCCEEDED (hr));
        pConsoleNameSpace2->Release ();
        pConsoleNameSpace2 = 0;
    }

	if ( CERTMGR_PHYS_STORE == parentCookie.m_objecttype ||
			(CERTMGR_LOG_STORE == parentCookie.m_objecttype && !m_bShowPhysicalStoresPersist) )
	{
		CCertStore*	pStore =
				reinterpret_cast <CCertStore*> (&parentCookie);
		ASSERT (pStore);
		if ( pStore )
		{
			CString	objectName;
			if ( pStore->ContainsCRLs () &&
					!ContainerExists (hParent, CERTMGR_CRL_CONTAINER) )
			{
				VERIFY (objectName.LoadString (IDS_CERTIFICATE_REVOCATION_LIST));
				hr = AddScopeNode (new CContainerCookie (
						*pStore,
						CERTMGR_CRL_CONTAINER,
						pStore->QueryNonNULLMachineName (),
						objectName), L"", hParent);
			}

			if ( SUCCEEDED (hr) && pStore->ContainsCTLs () &&
					!ContainerExists (hParent, CERTMGR_CTL_CONTAINER) )
			{
				VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LIST));
				hr = AddScopeNode (new CContainerCookie (
						*pStore,
						CERTMGR_CTL_CONTAINER,
						pStore->QueryNonNULLMachineName (),
						objectName), L"", hParent);
			}
			
			if ( SUCCEEDED (hr) && pStore->ContainsCertificates () &&
					!ContainerExists (hParent, CERTMGR_CERT_CONTAINER) )
			{
				VERIFY (objectName.LoadString (IDS_CERTIFICATES));
				hr = AddScopeNode (new CContainerCookie (
						*pStore,
						CERTMGR_CERT_CONTAINER,
						pStore->QueryNonNULLMachineName (),
						objectName), L"", hParent);
			}
		}
		else
			hr = E_UNEXPECTED;
	}
    else if ( CERTMGR_LOG_STORE == parentCookie.m_objecttype && m_bShowPhysicalStoresPersist )
    {
        if ( bDeleteAndExpand )
        {
            hr = DeleteChildren (hParent);
            if ( SUCCEEDED (hr) )
            {
                GUID	guid;
                hr = ExpandScopeNodes (&parentCookie, hParent, _T (""), 0, guid);
            }
        }
    }

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddContainersToScopePane: 0x%x\n", hr);
	return hr;
}

typedef struct _ENUM_ARG {
    DWORD					m_dwFlags;
	LPCONSOLENAMESPACE		m_pConsoleNameSpace;
	HSCOPEITEM				m_hParent;
	CCertMgrComponentData*	m_pCompData;
	PCWSTR					m_pcszMachineName;
	CCertMgrCookie*			m_pParentCookie;
	SPECIAL_STORE_TYPE		m_storeType;
	LPCONSOLE				m_pConsole;
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumPhyCallback (
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
	_TRACE (1, L"Entering EnumPhyCallback\n");

	if ( ! (pStoreInfo->dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG) )
	{
		PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
		SCOPEDATAITEM tSDItem;

		::ZeroMemory (&tSDItem,sizeof (tSDItem));
		tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
		tSDItem.displayname = MMC_CALLBACK;
		tSDItem.relativeID = pEnumArg->m_hParent;
		tSDItem.nState = 0;

		if ( pEnumArg->m_pCompData->ShowArchivedCerts () )
			dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;

		// Create new cookies
		CCertStore* pNewCookie = new CCertStore (
				CERTMGR_PHYS_STORE,
				CERT_STORE_PROV_PHYSICAL,
				dwFlags,
				pEnumArg->m_pcszMachineName,
				pwszStoreName, (PCWSTR) pvSystemStore, pwszStoreName,
				pEnumArg->m_storeType,
				dwFlags,
				pEnumArg->m_pConsole);
		if ( pNewCookie )
		{
	//		pEnumArg->m_pParentCookie->m_listScopeCookieBlocks.AddHead (
	//				 (CBaseCookieBlock*) pNewCookie);
			// WARNING cookie cast
			tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
			tSDItem.nImage = pEnumArg->m_pCompData->QueryImage (*pNewCookie, FALSE);
			HRESULT	hr = pEnumArg->m_pConsoleNameSpace->InsertItem (&tSDItem);
			ASSERT (SUCCEEDED (hr));
			if ( SUCCEEDED (hr) )
				pNewCookie->m_hScopeItem = tSDItem.ID;
		}
	}

	_TRACE (-1, L"Leaving EnumPhyCallback\n");
    return TRUE;
}

HRESULT CCertMgrComponentData::AddPhysicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie, const SPECIAL_STORE_TYPE storeType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddPhysicalStoresToScopePane\n");
	CWaitCursor	cursor;
	HRESULT		hr = S_OK;
	DWORD		dwFlags = 0;
    ENUM_ARG	enumArg;


    dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
    dwFlags |= CERT_STORE_READONLY_FLAG | m_dwLocationPersist;

    ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = dwFlags;
	enumArg.m_pConsoleNameSpace = m_pConsoleNameSpace;
	enumArg.m_hParent = hParent;
	enumArg.m_pCompData = this;
	enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
	enumArg.m_pParentCookie = &parentCookie;
	enumArg.m_storeType = storeType;
	enumArg.m_pConsole = m_pConsole;

    if (!::CertEnumPhysicalStore (
                (PWSTR) (PCWSTR) parentCookie.GetObjectName (),
                dwFlags,
                &enumArg,
                EnumPhyCallback))
	{
		DWORD	dwErr = GetLastError ();
		DisplaySystemError (dwErr);
		hr = HRESULT_FROM_WIN32 (dwErr);
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddPhysicalStoresToScopePane: 0x%x\n", hr);
	return hr;
}

static BOOL WINAPI EnumIComponentDataSysCallback (
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
	_TRACE (1, L"Entering EnumIComponentDataSysCallback\n");
    PENUM_ARG       pEnumArg = (PENUM_ARG) pvArg;
    SCOPEDATAITEM   tSDItem;
    ::ZeroMemory (&tSDItem,sizeof (tSDItem));
    tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
	tSDItem.displayname = MMC_CALLBACK;
    tSDItem.relativeID = pEnumArg->m_hParent;
    tSDItem.nState = 0;


	// Create new cookies
	SPECIAL_STORE_TYPE	storeType = GetSpecialStoreType ((PWSTR) pwszSystemStore);

	//
	// We will not expose the ACRS store for machines or users.  It is not
	// interesting or useful at this level.  All Auto Cert Requests should
	// be managed only at the policy level.
	//
	if ( ACRS_STORE != storeType )
	{
		if ( pEnumArg->m_pCompData->ShowArchivedCerts () )
			dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
		CCertStore* pNewCookie = new CCertStore (
				CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				dwFlags,
				pEnumArg->m_pcszMachineName,
				 (PCWSTR) pwszSystemStore,
				 (PCWSTR) pwszSystemStore,
				_T (""),
				storeType,
				pEnumArg->m_dwFlags,
				pEnumArg->m_pConsole);
		if ( pNewCookie )
		{
			pEnumArg->m_pParentCookie->m_listScopeCookieBlocks.AddHead (
					(CBaseCookieBlock*) pNewCookie);
			// WARNING cookie cast
			tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
			tSDItem.nImage = pEnumArg->m_pCompData->QueryImage (*pNewCookie, FALSE);
			HRESULT	hr = pEnumArg->m_pConsoleNameSpace->InsertItem (&tSDItem);
			ASSERT (SUCCEEDED (hr));
			if ( SUCCEEDED (hr) )
				pNewCookie->m_hScopeItem = tSDItem.ID;
		}
	}

	_TRACE (-1, L"Leaving EnumIComponentDataSysCallback\n");
    return TRUE;
}



HRESULT CCertMgrComponentData::AddLogicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddLogicalStoresToScopePane\n");
	CWaitCursor	cursor;
	HRESULT		hr = S_OK;

    // If m_dwLocationPersist is 0 but the file name is empty, this means the
    // user launched certmgr.msc without providing a target file.  Launch
    // certificates snapin as the current user instead.
    if ( !m_dwLocationPersist && m_szFileName.IsEmpty () )
    {
        m_dwLocationPersist = CERT_SYSTEM_STORE_CURRENT_USER;
        ChangeRootNodeName (L"");
    }
    DWORD		dwFlags = m_dwLocationPersist;
    ENUM_ARG	enumArg;

     ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = dwFlags;
	enumArg.m_pConsoleNameSpace = m_pConsoleNameSpace;
	enumArg.m_hParent = hParent;
	enumArg.m_pCompData = this;
	enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
	enumArg.m_pParentCookie = &parentCookie;
	enumArg.m_pConsole = m_pConsole;
	CString	location;
	void*	pvPara = 0;
	
	switch (m_dwLocationPersist)
	{
	case CERT_SYSTEM_STORE_CURRENT_USER:
	case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        if ( !m_szManagedServicePersist.IsEmpty () )
            m_szManagedServicePersist.Empty ();
		break;

	case CERT_SYSTEM_STORE_CURRENT_SERVICE:
	case CERT_SYSTEM_STORE_SERVICES:
		break;

	default:
		ASSERT (0);
		break;
	}

	if ( !m_szManagedServicePersist.IsEmpty () )
	{
		if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )    //!=
		{
			location = m_szManagedComputer + _T ("\\") +
					m_szManagedServicePersist;
			pvPara = (void *) (PCWSTR) location;
		}
		else
			pvPara = (void *) (PCWSTR) m_szManagedServicePersist;
	}
	else if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )   //!=
	{
		pvPara = (void *) (PCWSTR) m_szManagedComputer;
	}


	if ( m_szFileName.IsEmpty () )
	{
		// Ensure creation of MY store
		HCERTSTORE hTempStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				NULL,
				dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
				MY_SYSTEM_STORE_NAME);
		if ( hTempStore )  // otherwise, store is read only
		{
			VERIFY (::CertCloseStore (hTempStore, CERT_CLOSE_STORE_CHECK_FLAG));
		}
		else
		{
			_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
					MY_SYSTEM_STORE_NAME, GetLastError ());		
		}

		if ( !::CertEnumSystemStore (dwFlags, pvPara, &enumArg,
				EnumIComponentDataSysCallback) )
		{
			DWORD	dwErr = GetLastError ();
			CString text;
			CString	caption;

			VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			if ( ERROR_ACCESS_DENIED == dwErr )
			{
				VERIFY (text.LoadString (IDS_NO_PERMISSION));

			}
			else
			{
				text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
			}
			int		iRetVal = 0;
			VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
					MB_OK, &iRetVal)));
			hr = HRESULT_FROM_WIN32 (dwErr);

			if ( ERROR_BAD_NETPATH == dwErr )
			{
				m_fInvalidComputer = true;
			}
		}
	}
	else
	{
		//	CertOpenStore with provider type of:
		//	CERT_STORE_PROV_FILE or CERT_STORE_PROV_FILENAME_A
		//	or CERT_STORE_PROV_FILENAME_W.
		//	See online documentation or wincrypt.h for more info.
		// Create new cookies
		dwFlags = 0;
		if ( ShowArchivedCerts () )
			dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
		
		ASSERT (!m_pFileBasedStore);
		m_pFileBasedStore = new CCertStore (
					CERTMGR_LOG_STORE,
					CERT_STORE_PROV_FILENAME_W,
					dwFlags,
					parentCookie.QueryNonNULLMachineName (),
					m_szFileName, m_szFileName, L"", NO_SPECIAL_TYPE,
					m_dwLocationPersist,
					m_pConsole);
		if ( m_pFileBasedStore )
		{
			m_pFileBasedStore->AddRef ();
			hr = AddScopeNode (m_pFileBasedStore,
					L"", hParent);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddLogicalStoresToScopePane: 0x%x\n", hr);
	return hr;
}


	// If the callback returns FALSE, stops the enumeration.
BOOL EnumOIDInfo (PCCRYPT_OID_INFO pInfo, void *pvArg)
{
	_TRACE (1, L"Entering EnumOIDInfo\n");
	ENUM_ARG*		pEnumArg = (ENUM_ARG*) pvArg;
    SCOPEDATAITEM	tSDItem;
    ::ZeroMemory (&tSDItem,sizeof (tSDItem));
    tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
	tSDItem.displayname = MMC_CALLBACK;
    tSDItem.relativeID = pEnumArg->m_hParent;
    tSDItem.nState = 0;

	// See if this usage is already listed by name.  If so, just add the
	// additional OID, otherwise, create a new cookie.
	CUsageCookie* pUsageCookie =
			pEnumArg->m_pCompData->FindDuplicateUsage (pEnumArg->m_hParent,
			pInfo->pwszName);
	if ( !pUsageCookie )
	{
		pUsageCookie= new CUsageCookie (CERTMGR_USAGE,
			pEnumArg->m_pcszMachineName,
			pInfo->pwszName);
		if ( pUsageCookie )
		{
            pEnumArg->m_pCompData->GetRootCookie ()->m_listScopeCookieBlocks.AddHead ( (CBaseCookieBlock*) pUsageCookie);

			// WARNING cookie cast
	        tSDItem.mask |= SDI_CHILDREN;
		    tSDItem.cChildren = 0;
			tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pUsageCookie);
			tSDItem.nImage = pEnumArg->m_pCompData->QueryImage (*pUsageCookie, FALSE);
			HRESULT	hr = pEnumArg->m_pConsoleNameSpace->InsertItem (&tSDItem);
			ASSERT (SUCCEEDED (hr));
		}
	}
	pUsageCookie->AddOID (pInfo->pszOID);


	_TRACE (-1, L"Leaving EnumOIDInfo\n");
	return TRUE;
}


HRESULT CCertMgrComponentData::AddUsagesToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddUsagesToScopePane\n");
	HRESULT		hr = S_OK;
	ENUM_ARG	enumArg;

	::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = 0;
	enumArg.m_pConsoleNameSpace = m_pConsoleNameSpace;
	enumArg.m_hParent = hParent;
	enumArg.m_pCompData = this;
	enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
	enumArg.m_pParentCookie = &parentCookie;
	enumArg.m_pConsole = m_pConsole;
	BOOL bResult = ::CryptEnumOIDInfo (CRYPT_ENHKEY_USAGE_OID_GROUP_ID, 0,
			&enumArg, EnumOIDInfo);
	ASSERT (bResult);


	_TRACE (-1, L"Leaving CCertMgrComponentData::AddUsagesToScopePane: 0x%x\n", hr);
	return hr;
}


BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
	_TRACE (1, L"Entering IsMMCMultiSelectDataObject\n");
    if (pDataObject == NULL)
        return FALSE;

    CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    FORMATETC fmt = {s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    BOOL bResult = ((pDataObject->QueryGetData(&fmt) == S_OK));
	_TRACE (-1, L"Leaving IsMMCMultiSelectDataObject - return %d\n", bResult);
	return bResult;
}



STDMETHODIMP CCertMgrComponentData::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::Command\n");
	HRESULT hr = S_OK;

	switch (nCommandID)
	{
	case IDM_TASK_RENEW_SAME_KEY:
		hr = OnRenew (pDataObject, false);
		break;

	case IDM_TASK_RENEW_NEW_KEY:
		hr = OnRenew (pDataObject, true);
		break;

	case IDM_TASK_IMPORT:
		hr = OnImport (pDataObject);
		break;

	case IDM_TASK_EXPORT:
		hr = OnExport (pDataObject);
		break;

	case IDM_CTL_EDIT:
		hr = OnCTLEdit (pDataObject);
		break;

	case IDM_EDIT_ACRS:
		hr = OnACRSEdit (pDataObject);
		break;

	case IDM_NEW_CTL:
		hr = OnNewCTL (pDataObject);
		break;

	case IDM_TASK_CTL_EXPORT:
	case IDM_TASK_CRL_EXPORT:
		hr = OnExport (pDataObject);
		break;

	case IDM_TASK_EXPORT_STORE:
		hr = OnExport (pDataObject);
		break;

	case IDM_TOP_FIND:
	case IDM_TASK_FIND:
		hr = OnFind (pDataObject);
		break;

    case IDM_TASK_PULSEAUTOENROLL:
        hr = OnPulseAutoEnroll();
        break;

    case IDM_TOP_CHANGE_COMPUTER:
    case IDM_TASK_CHANGE_COMPUTER:
        hr = OnChangeComputer (pDataObject);
        break;

	case IDM_ENROLL_NEW_CERT:
		hr = OnEnroll (pDataObject, true);
		break;

    case IDM_ENROLL_NEW_CERT_SAME_KEY:
        hr = OnEnroll (pDataObject, false);
        break;

	case IDM_ENROLL_NEW_CERT_NEW_KEY:
		hr = OnEnroll (pDataObject, true);
		break;

	case IDM_OPTIONS:
		hr = OnOptions (pDataObject);
		break;

	case IDM_INIT_POLICY:
		hr = OnInitEFSPolicy (pDataObject);
		break;

	case IDM_DEL_POLICY:
	case IDM_DEL_POLICY1:
		{
			AFX_MANAGE_STATE (AfxGetStaticModuleState ());
			CString	text;
			CString	caption;
			int		iRetVal = 0;


			VERIFY (text.LoadString (IDS_CONFIRM_DELETE_EFS_POLICY));
			VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			hr = m_pConsole->MessageBox (text, caption,
					MB_YESNO, &iRetVal);
			ASSERT (SUCCEEDED (hr));	
			if ( SUCCEEDED (hr) && IDYES == iRetVal )
				hr = OnDeleteEFSPolicy (pDataObject, true);
		}
		break;

	case IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT:
	case IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1:
	case IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT2:
		hr = OnAddDomainEncryptedDataRecoveryAgent (pDataObject);
		break;

	case IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT:
		hr = OnEnroll (pDataObject, true);
		break;

 	case IDM_NEW_ACRS:
 		hr = OnNewACRS (pDataObject);
 		break;

    case IDM_SAFER_LEVEL_SET_DEFAULT:
        hr = OnSetSaferLevelDefault (pDataObject);
        break;

    case IDM_SAFER_NEW_ENTRY_PATH:
    case IDM_SAFER_NEW_ENTRY_HASH:
    case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
    case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
        hr = OnNewSaferEntry (nCommandID, pDataObject);
        break;

    case IDM_TOP_CREATE_NEW_SAFER_POLICY:
    case IDM_TASK_CREATE_NEW_SAFER_POLICY:
        hr = OnCreateNewSaferPolicy (pDataObject);
        break;

	case -1:	// Received on forward/back buttons from toolbar
		break;

	default:
		ASSERT (0);
		break;
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::Command: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnNewACRS (LPDATAOBJECT pDataObject)
{
 	_TRACE (1, L"Entering CCertMgrComponentData::OnNewACRS\n");
 	ASSERT (pDataObject);
 	if ( !pDataObject )
 		return E_POINTER;
 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
 	HRESULT			hr = S_OK;
 	CCertMgrCookie*	pCookie = ConvertCookie (pDataObject);
 	ASSERT (pCookie);
 	if ( pCookie )
 	{
 		if ( CERTMGR_LOG_STORE_GPE == pCookie->m_objecttype )
 		{
 			CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
 			ASSERT (pStore);
 			if ( pStore )
 			{
 				HWND	hwndConsole = 0;
 				hr = m_pConsole->GetMainWindow (&hwndConsole);
 				ASSERT (SUCCEEDED (hr));
 				if ( SUCCEEDED (hr) )
 				{
 					ACRSWizardPropertySheet	sheet (pStore, NULL);

    				ACRSWizardWelcomePage	welcomePage;
 					ACRSWizardTypePage		typePage;
 					ACRSCompletionPage		completionPage;
 
 					sheet.AddPage (&welcomePage);
 					sheet.AddPage (&typePage);
 					sheet.AddPage (&completionPage);
 
 					if ( sheet.DoWizard (hwndConsole) )
 					{
 						pStore->SetDirty ();
 						hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
 						ASSERT (SUCCEEDED (hr));
 					}
 				}
 			}
 			else
 				hr = E_UNEXPECTED;
 		}
 		else
 			hr = E_UNEXPECTED;
 
 	}
 	else
 		hr = E_UNEXPECTED;
 
 	_TRACE (-1, L"Leaving CCertMgrComponentData::OnNewACRS: 0x%x\n", hr);
 	return hr;
}


HRESULT CCertMgrComponentData::RefreshScopePane (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::RefreshScopePane\n");
	HRESULT	hr = S_OK;
	CCertMgrCookie* pCookie = 0;
	
	if ( pDataObject )
		pCookie = ConvertCookie (pDataObject);
	if ( !pDataObject || ( pCookie && ((CCertMgrCookie*) CERTMGR_NULL_POLICY) != pCookie) )
	{
		// If m_hRootScopeItem is NULL, then this is an extension and we don't want to go in here.
		if ( !pDataObject || (m_hRootScopeItem && pCookie->m_hScopeItem == m_hRootScopeItem) )
		{
			hr = DeleteScopeItems ();
			ASSERT (SUCCEEDED (hr));
			if ( 1 ) //SUCCEEDED (hr) )
			{
				GUID	guid;
				hr = ExpandScopeNodes (m_pRootCookie, m_hRootScopeItem, 
                        _T (""), 0, guid);
			}
			else if ( E_UNEXPECTED == hr )
			{
				ASSERT (0);
			}
			else if ( E_INVALIDARG == hr )
			{
				ASSERT (0);
			}

		}
		else
		{
			switch (pCookie->m_objecttype)
			{
			case CERTMGR_LOG_STORE_GPE:
			case CERTMGR_LOG_STORE_RSOP:
			case CERTMGR_USAGE:
			case CERTMGR_LOG_STORE:
			case CERTMGR_PHYS_STORE:
			case CERTMGR_CRL_CONTAINER:
			case CERTMGR_CTL_CONTAINER:
			case CERTMGR_CERT_CONTAINER:
				hr = DeleteChildren (pCookie->m_hScopeItem);
				break;

			default:
				break;
			}
		}
	}
	_TRACE (-1, L"Leaving CCertMgrComponentData::RefreshScopePane: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::ExpandScopeNodes (
		CCertMgrCookie* pParentCookie,
		HSCOPEITEM		hParent,
		const CString&	strServerName,
		DWORD			dwLocation,
		const GUID&		guidObjectType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::ExpandScopeNodes\n");
	ASSERT (hParent);
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CWaitCursor	waitCursor;
	HRESULT		hr = S_OK;

	if ( pParentCookie )
	{
		CString		objectName;

		switch ( pParentCookie->m_objecttype )
		{
			// These node types have no children yet
			case CERTMGR_SNAPIN:
				// We don't expect the handle of the root scope item to change, ever!
				ASSERT ( m_hRootScopeItem ? (m_hRootScopeItem == hParent) : 1);
				if ( !m_hRootScopeItem )
					m_hRootScopeItem = hParent;

				switch (m_activeViewPersist)
				{
				case IDM_USAGE_VIEW:
					hr = AddUsagesToScopePane (hParent, *pParentCookie);
					break;

				case IDM_STORE_VIEW:
					hr = AddLogicalStoresToScopePane (hParent, *pParentCookie);
					break;

				default:
					ASSERT (0);
					hr = E_UNEXPECTED;
					break;
				}
				break;

			// This node type has no children
			case CERTMGR_USAGE:
			case CERTMGR_CRL_CONTAINER:
			case CERTMGR_CTL_CONTAINER:
			case CERTMGR_CERT_CONTAINER:
				break;

			case CERTMGR_PHYS_STORE:
				// Create one each of a CRL_CONTAINER node, CTL_CONTAINER 
                // node and CERT container node.
				hr = AddContainersToScopePane (hParent, *pParentCookie, 
                        false);
				break;

			case CERTMGR_LOG_STORE_RSOP:
			case CERTMGR_LOG_STORE_GPE:
				// This is the Group Policy Editor extension
				// This node type has no children
				break;

			case CERTMGR_LOG_STORE:
				if ( m_bShowPhysicalStoresPersist )
				{	
					SPECIAL_STORE_TYPE	storeType = NO_SPECIAL_TYPE;
					CCertStore* pCertStoreCookie =
							reinterpret_cast <CCertStore*> (pParentCookie);
					ASSERT (pCertStoreCookie);
					if ( pCertStoreCookie )
						storeType = pCertStoreCookie->GetStoreType ();
					hr = AddPhysicalStoresToScopePane (hParent, *pParentCookie,
							storeType);
				}
				else
				{
					// Create one each of a CRL_CONTAINER node, CTL_CONTAINER 
                    // node and CERT container node.
					hr = AddContainersToScopePane (hParent, *pParentCookie, 
                            false);
				}
				break;

			case CERTMGR_CERT_POLICIES_USER:
				// Don't add these nodes for local machine policy
				if ( SCE_MODE_LOCAL_COMPUTER != m_dwSCEMode )
				{
					// Add "Trusted Certificate Authorities"
					VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LISTS));

					if ( SUCCEEDED (hr) )
					{
                        if ( m_pGPEInformation )
                        {
						    hr = AddScopeNode (new CCertStoreGPE (
								    CERT_SYSTEM_STORE_RELOCATE_FLAG,
								    _T (""),
								     (PCWSTR) objectName,
								    TRUST_SYSTEM_STORE_NAME,
								    _T (""),
								    m_pGPEInformation,
								    NODEID_User,
								    m_pConsole),
								    strServerName,
								    hParent);
                        }
                        else if ( m_pRSOPInformationUser )
                        {
						    hr = AddScopeNode (new CCertStoreRSOP (
								    CERT_SYSTEM_STORE_RELOCATE_FLAG,
								    _T (""),
								     (PCWSTR) objectName,
								    TRUST_SYSTEM_STORE_NAME,
								    _T (""),
								    m_rsopObjectArrayUser,
								    NODEID_User,
								    m_pConsole),
								    strServerName,
								    hParent);
                        }
					}
				}
				break;

			case CERTMGR_CERT_POLICIES_COMPUTER:
				// Add only this node for local machine policy
				// Add "Encrypting File System"
                
                VERIFY (objectName.LoadString (IDS_ENCRYPTING_FILE_SYSTEM_NODE_NAME));

                if ( m_pGPEInformation )
                {
				    hr = AddScopeNode (new CCertStoreGPE (
						    CERT_SYSTEM_STORE_RELOCATE_FLAG,
						    _T (""),
						     (PCWSTR) objectName,
						    EFS_SYSTEM_STORE_NAME,
						    _T (""),
						    m_pGPEInformation,
						    NODEID_Machine,
						    m_pConsole),
						    strServerName,
						    hParent);
                }
                else if ( m_pRSOPInformationComputer )
                {
					hr = AddScopeNode (new CCertStoreRSOP (
							CERT_SYSTEM_STORE_RELOCATE_FLAG,
							_T (""),
							 (PCWSTR) objectName,
							EFS_SYSTEM_STORE_NAME,
							_T (""),
							m_rsopObjectArrayComputer,
							NODEID_Machine,
							m_pConsole),
							strServerName,
							hParent);
                }

				if ( SCE_MODE_LOCAL_COMPUTER != m_dwSCEMode )
				{
					// Add these policies if this is the domain policy
					if ( SUCCEEDED (hr) )
					{
                        // Add "Automatic Certificate Request Settings"
                        VERIFY (objectName.LoadString (IDS_AUTOMATIC_CERT_REQUEST_SETTINGS_NODE_NAME));
                        if ( m_pGPEInformation )
                        {
					        m_pGPEACRSComputerStore = new CCertStoreGPE (
		                                CERT_SYSTEM_STORE_RELOCATE_FLAG,
		                                _T (""),
		                                 (PCWSTR) objectName,
		                                ACRS_SYSTEM_STORE_NAME,
		                                _T (""),
		                                m_pGPEInformation,
		                                NODEID_Machine,
								        m_pConsole);
                        }
                        else if ( m_pRSOPInformationComputer )
                        {
                            m_pGPEACRSComputerStore = new CCertStoreRSOP (
							        CERT_SYSTEM_STORE_RELOCATE_FLAG,
							        _T (""),
							         (PCWSTR) objectName,
							        ACRS_SYSTEM_STORE_NAME,
							        _T (""),
							        m_rsopObjectArrayComputer,
							        NODEID_Machine,
							        m_pConsole);
                        }
						if ( m_pGPEACRSComputerStore )
						{
							m_pGPEACRSComputerStore->AddRef ();
							hr = AddScopeNode (m_pGPEACRSComputerStore,
									strServerName, hParent);
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}


					if ( SUCCEEDED (hr) )
					{
						// Add "Domain Root Certificate Authorities"
						VERIFY (objectName.LoadString (IDS_DOMAIN_ROOT_CERT_AUTHS_NODE_NAME));

						ASSERT (!m_pGPERootStore);
                        if ( m_pGPEInformation )
                        {
						    m_pGPERootStore = new CCertStoreGPE (
								    CERT_SYSTEM_STORE_RELOCATE_FLAG,
								    _T (""),
								     (PCWSTR) objectName,
								    ROOT_SYSTEM_STORE_NAME,
								    _T (""),
								    m_pGPEInformation,
								    NODEID_Machine,
								    m_pConsole);
                        }
                        else if ( m_pRSOPInformationComputer )
                        {
						    m_pGPERootStore = new CCertStoreRSOP (
								    CERT_SYSTEM_STORE_RELOCATE_FLAG,
								    _T (""),
								     (PCWSTR) objectName,
								    ROOT_SYSTEM_STORE_NAME,
								    _T (""),
								    m_rsopObjectArrayComputer,
								    NODEID_Machine,
								    m_pConsole);
                        }

						if ( m_pGPERootStore )
						{
							m_pGPERootStore->AddRef ();
							hr = AddScopeNode (m_pGPERootStore,
									strServerName, hParent);
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}

					if ( SUCCEEDED (hr) )
					{
						// Add "Trusted Certificate Authorities"
						VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LISTS));

						ASSERT (!m_pGPETrustStore);
                        if ( m_pGPEInformation )
                        {
						    m_pGPETrustStore = new CCertStoreGPE (
								    CERT_SYSTEM_STORE_RELOCATE_FLAG,
								    _T (""),
								     (PCWSTR) objectName,
								    TRUST_SYSTEM_STORE_NAME,
								    _T (""),
								    m_pGPEInformation,
								    NODEID_Machine,
								    m_pConsole);
                        }
                        else if ( m_pRSOPInformationComputer )
                        {
						    m_pGPETrustStore = new CCertStoreRSOP (
								    CERT_SYSTEM_STORE_RELOCATE_FLAG,
								    _T (""),
								     (PCWSTR) objectName,
								    TRUST_SYSTEM_STORE_NAME,
								    _T (""),
								    m_rsopObjectArrayComputer,
								    NODEID_Machine,
								    m_pConsole);
                        }
						if ( m_pGPETrustStore )
						{
							m_pGPETrustStore->AddRef ();
							hr = AddScopeNode (m_pGPETrustStore,
									strServerName, hParent);
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}
				}
				break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                {
                    CSaferRootCookie* pSaferRootCookie = 
                            dynamic_cast <CSaferRootCookie*> (pParentCookie);
                    if ( pSaferRootCookie )
                    {
                        bool bIsComputer = 
                                (CERTMGR_SAFER_COMPUTER_ROOT == pParentCookie->m_objecttype);
                        if ( !m_bIsRSOP )
                        {
                            // Find out if Safer is supported by the OS
                            m_bSaferSupported = false;
                            SAFER_LEVEL_HANDLE hLevel = 0;
                            CPolicyKey policyKey (m_pGPEInformation, 
                                    SAFER_HKLM_REGBASE, 
                                    CERTMGR_SAFER_COMPUTER_ROOT == pParentCookie->m_objecttype);
                            SetRegistryScope (policyKey.GetKey (), 
                                    CERTMGR_SAFER_COMPUTER_ROOT == pParentCookie->m_objecttype);

                            BOOL  bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
                                    SAFER_LEVELID_FULLYTRUSTED,
                                    SAFER_LEVEL_OPEN,
                                    &hLevel,
                                    policyKey.GetKey ());
                            if ( bRVal )
                            {
                                m_bSaferSupported = true;
                                VERIFY (SaferCloseLevel (hLevel));
                            }
                            else
                            {
                                DWORD dwErr = GetLastError ();
                                _TRACE (0, L"SaferCreateLevel () failed: 0x%x\n", dwErr);
                            }

                            // Install default file types
                            if ( m_bSaferSupported && m_pGPEInformation )
                            {
                                HKEY    hGroupPolicyKey = 0;
                                hr = m_pGPEInformation->GetRegistryKey (
                                        bIsComputer ? 
                                        GPO_SECTION_MACHINE : GPO_SECTION_USER,
		                                &hGroupPolicyKey);
                                if ( SUCCEEDED (hr) )
                                {
                                    // Check to see if safer defaults have already 
                                    // been defined.  If not, prompt the user
                                    // for confirmation.  If the response is "no"
                                    // then do not create the nodes
                                    PCWSTR pszKeyName = bIsComputer ? 
                                            SAFER_COMPUTER_CODEIDS_REGKEY :
                                            SAFER_USER_CODEIDS_REGKEY;

                                    HKEY hCodeIDsKey = 0;
                                    LONG lResult = RegOpenKeyEx (hGroupPolicyKey,
                                            pszKeyName, 0, KEY_READ, &hCodeIDsKey);
                                    if ( ERROR_FILE_NOT_FOUND == lResult )
                                    {
                                        pSaferRootCookie->m_bCreateSaferNodes = false;
                                        break;
                                    }
                                    else if ( hCodeIDsKey )
                                    {
                                        ::RegCloseKey (hCodeIDsKey);
                                        hCodeIDsKey = 0;
                                    }
                                    ::RegCloseKey (hGroupPolicyKey);
                                }
                            }
                        }

                        if ( m_bSaferSupported || m_bIsRSOP )
                        {
                            // Add "Levels" node
   				            VERIFY (objectName.LoadString (IDS_SAFER_LEVELS_NODE_NAME));
				            hr = AddScopeNode (new CCertMgrCookie (
						            bIsComputer ?
                                        CERTMGR_SAFER_COMPUTER_LEVELS : CERTMGR_SAFER_USER_LEVELS,
						            0,
						            (PCWSTR) objectName), strServerName, hParent);

                            // Add "Entries" node
                            if ( SUCCEEDED (hr) )
                            {
   				                VERIFY (objectName.LoadString (IDS_SAFER_ENTRIES_NODE_NAME));
				                hr = AddScopeNode (new CSaferEntries (
						                bIsComputer,
						                strServerName, 
                                        objectName, 
                                        m_pGPEInformation, 
                                        bIsComputer ? m_pRSOPInformationComputer : m_pRSOPInformationUser, 
                                        bIsComputer ? m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                                        m_pConsole), 
                                        strServerName, hParent);

                                if ( SUCCEEDED (hr) )
                                {
                                    hr = SaferEnumerateLevels (bIsComputer);
                                }
                            }
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_LEVELS:
                break;

            case CERTMGR_SAFER_USER_LEVELS:
                // TODO: Enumerate user levels
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
                // TODO: Enumerate computer entries
                break;

            case CERTMGR_SAFER_USER_ENTRIES:
                // TODO: Enumerate user entries
                break;

			case CERTMGR_CERTIFICATE:  // not expected in scope pane
			case CERTMGR_CRL:
			case CERTMGR_CTL:
			case CERTMGR_AUTO_CERT_REQUEST:
            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
				ASSERT (0);
				hr = E_UNEXPECTED;
				break;

			default:
				_TRACE (0, L"CCertMgrComponentData::EnumerateScopeChildren bad parent type\n");
				ASSERT (0);
				hr = S_OK;
				break;
		}
	}
	else
	{
		// If parentCookie not passed in, then this is an extension snap-in
		m_dwLocationPersist = dwLocation;


		if ( m_pGPEInformation || m_pRSOPInformationComputer || m_pRSOPInformationUser )
		{
			CString	objectName;


			if ( ::IsEqualGUID (guidObjectType, NODEID_Machine) )
			{
				if ( SUCCEEDED (hr) )
				{
                    CLSID classID;  
                    GetClassID (&classID);
                    
                    if ( ::IsEqualGUID (classID, CLSID_CertificateManagerPKPOLExt) )
                    {
						// Add "Public Key Policies" node
						VERIFY (objectName.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));
						hr = AddScopeNode (new CCertMgrCookie (
								CERTMGR_CERT_POLICIES_COMPUTER,
								0,
								(PCWSTR) objectName), 
                                strServerName, hParent);
                    }
                    else if ( ::IsEqualGUID (classID, CLSID_SaferWindowsExtension) )
                    {
						// Add "Software Restriction Policies" node
						VERIFY (objectName.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
						hr = AddScopeNode (new CSaferRootCookie (
							    CERTMGR_SAFER_COMPUTER_ROOT,
								0,
								(PCWSTR) objectName), 
                                strServerName, hParent);
                    }
				}

			}
            else if ( ::IsEqualGUID (guidObjectType, NODEID_User) )
            {
                if ( SUCCEEDED (hr) )
                {
                    CLSID classID;  
                    GetClassID (&classID);
                    
                    if ( ::IsEqualGUID (classID, CLSID_CertificateManagerPKPOLExt) )
                    {
                        // Add "Public Key Policies" node
                        VERIFY (objectName.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));
                        hr = AddScopeNode (new CCertMgrCookie (
                                CERTMGR_CERT_POLICIES_USER,
                                0,
                                (PCWSTR) objectName), strServerName, hParent);
                    }
                    else if ( ::IsEqualGUID (classID, CLSID_SaferWindowsExtension) )
                    {
                        if ( SCE_MODE_LOCAL_USER != m_dwSCEMode )
                        {
                            // Add "Software Restriction Policies" node
                            VERIFY (objectName.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                            hr = AddScopeNode (new CSaferRootCookie (
                                    CERTMGR_SAFER_USER_ROOT,
                                    0,
                                    (PCWSTR) objectName), strServerName, hParent);
                        }
                    }
                }
            }
        }
   }

	_TRACE (-1, L"Leaving CCertMgrComponentData::ExpandScopeNodes: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::DeleteScopeItems (HSCOPEITEM hScopeItem /* = 0 */)
{
	_TRACE (1, L"Entering CCertMgrComponentData::DeleteScopeItems\n");
	HRESULT	hr = S_OK;

    if ( m_pGPERootStore )
    {
        m_pGPERootStore->Release ();
        m_pGPERootStore = 0;
    }

    if ( m_pGPETrustStore )
    {
        m_pGPETrustStore->Release ();
        m_pGPETrustStore = 0;
    }

	if ( m_pGPEACRSComputerStore )
	{
		m_pGPEACRSComputerStore->Release ();
		m_pGPEACRSComputerStore = 0;
	}

	if ( m_pGPEACRSUserStore )
	{
		m_pGPEACRSUserStore->Release ();
		m_pGPEACRSUserStore = 0;
	}

	if ( m_pFileBasedStore )
	{
		m_pFileBasedStore->Release ();
		m_pFileBasedStore = 0;
	}

    hr = DeleteChildren (hScopeItem ? hScopeItem : m_hRootScopeItem);

	_TRACE (-1, L"Leaving CCertMgrComponentData::DeleteScopeItems: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::DeleteChildren (HSCOPEITEM hParent)
{
	_TRACE (1, L"Entering CCertMgrComponentData::DeleteChildren\n");
	if ( !hParent )
		return S_OK;

	HSCOPEITEM		hChild = 0;
	HSCOPEITEM		hNextChild = 0;
	MMC_COOKIE		lCookie = 0;
	CCertMgrCookie*	pCookie = 0;
	HRESULT			hr = S_OK;
	CCookie&		rootCookie = QueryBaseRootCookie ();

	// Optimization:  If we're deleting everything below the root, free all
	// the result items here so we don't have to go looking for them later by
	// store
	if ( hParent == m_hRootScopeItem )
	{
        LPRESULTDATA    pResultData = 0;
		hr = GetResultData (&pResultData);
        if ( SUCCEEDED (hr) )
        {
            hr = pResultData->DeleteAllRsltItems ();
            if ( SUCCEEDED (hr) || E_UNEXPECTED == hr ) // returns E_UNEXPECTED if console shutting down
            {
                RemoveResultCookies (pResultData);
            }
            else
            {
                _TRACE (0, L"IResultData::DeleteAllRsltItems () failed: 0x%x\n", hr);        
            }
			pResultData->Release ();
        }
	}


	hr = m_pConsoleNameSpace->GetChildItem (hParent, &hChild, &lCookie);
	ASSERT (SUCCEEDED (hr) || E_FAIL == hr);	// appears to return E_FAIL when there are no children
	while ( SUCCEEDED (hr) && hChild )
	{
		pCookie = reinterpret_cast <CCertMgrCookie*> (lCookie);

		hr = DeleteChildren (hChild);
		if ( !SUCCEEDED (hr) )
			break;

		hNextChild = 0;
		hr = m_pConsoleNameSpace->GetNextItem (hChild, &hNextChild, &lCookie);
		ASSERT (SUCCEEDED (hr));

		hr = m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
		ASSERT (SUCCEEDED (hr));

		switch (pCookie->m_objecttype)
		{
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_PHYS_STORE:
			{
				// If this is a store, delete all the result nodes that belong to this
				// store.  We can tell if objects were enumerated from this store simply
				// by comparing the store handles.
				CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
				ASSERT (pStore);
				if ( pStore )
				{
					// If the store is not 'open' (it's HCERTSTORE handle is still '0')
					// then we can skip checking this list.  We haven't enumerated anything
					// in this store.
					if ( pStore->IsOpen () )
					{
						POSITION			pos1 = 0;
						POSITION			pos2 = 0;
						CBaseCookieBlock*	pResultCookie = 0;
						HCERTSTORE			hStoreHandle = pStore->GetStoreHandle ();

						// As an optimization, if DeleteChildren was originally called with
						// the root scope item, all the result cookies have already been
						// deleted since we're going to delete them all anyway.
						for (pos1 = rootCookie.m_listResultCookieBlocks.GetHeadPosition();
							(pos2 = pos1) != NULL; )
						{
							pResultCookie = rootCookie.m_listResultCookieBlocks.GetNext (pos1);
							ASSERT (pResultCookie);
							if ( pResultCookie )
							{
								hr = ReleaseResultCookie (pResultCookie,
										rootCookie, hStoreHandle, pos2);
							}
						}						
						pStore->Close ();
					}
				}
			}
			// fall through

		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_USAGE:
			{
				POSITION			pos1 = 0;
				POSITION			pos2 = 0;
				CBaseCookieBlock*	pResultCookie = 0;

				// Find and remove this cookie from the scope cookie list
				for (pos1 = rootCookie.m_listScopeCookieBlocks.GetHeadPosition();
					pos1 != NULL; )
				{
					pos2 = pos1;
					pResultCookie = rootCookie.m_listResultCookieBlocks.GetNext (pos1);
					ASSERT (pResultCookie);
					if ( pResultCookie )
					{
						if ( pResultCookie->QueryBaseCookie (0) == pCookie )
						{
							rootCookie.m_listScopeCookieBlocks.RemoveAt (pos2);
							pResultCookie->Release ();
							break;
						}
					}
				}						
			}
			break;

		default:
			break;
		}

		hChild = hNextChild;
	}


	_TRACE (-1, L"Leaving CCertMgrComponentData::DeleteChildren: 0x%x\n", hr);
	return hr;
}


CertificateManagerObjectType CCertMgrComponentData::GetObjectType (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::GetObjectType\n");
	CertificateManagerObjectType	objType = CERTMGR_INVALID;

	ASSERT (pDataObject);
	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
		objType = CERTMGR_MULTISEL;
	else if ( pCookie )
		objType = pCookie->m_objecttype;

	_TRACE (-1, L"Leaving CCertMgrComponentData::GetObjectType\n");
	return objType;
}



HRESULT CCertMgrComponentData::OnPulseAutoEnroll()
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnPulseAutoEnroll\n");
	HRESULT	hr = S_OK;
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());

        HANDLE hEvent = NULL;
        LPWSTR wszEventName;

        
        // pulse autoenroll event here, choose between machine or user
        
        // user or machine pulse?
        wszEventName = L"Global\\" MACHINE_AUTOENROLLMENT_TRIGGER_EVENT;
        if (CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist)
            wszEventName = USER_AUTOENROLLMENT_TRIGGER_EVENT;
        
        hEvent=OpenEvent(EVENT_MODIFY_STATE, false, wszEventName);
        if (NULL==hEvent) 
        {
            DWORD dwErr = GetLastError();

            CString text;
            CString	caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_CANT_OPEN_AUTOENROLL_EVENT, GetSystemMessage (dwErr));

            int		iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption, MB_OK, &iRetVal)));

            hr=HRESULT_FROM_WIN32(dwErr);
            _TRACE (0, L"OpenEvent(%s) failed with 0x%08X.\n", wszEventName, hr);
            goto error;
        }
        
        if (!SetEvent(hEvent)) 
        {
            DWORD dwErr = GetLastError();
            DisplaySystemError (dwErr);
            hr=HRESULT_FROM_WIN32(dwErr);
            _TRACE (0, L"SetEvent failed with 0x%08X.\n", hr);
            goto error;
        }


error:
      if (NULL!=hEvent) 
         CloseHandle(hEvent);

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnPulseAutoEnroll: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnFind (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnFind\n");
	HRESULT	hr = S_OK;
	ASSERT (pDataObject);
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HWND		hParent = 0;


	ASSERT (pDataObject);
	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie )
	{
		switch (pParentCookie->m_objecttype)
		{
		case CERTMGR_SNAPIN:
		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
		case CERTMGR_LOG_STORE_GPE:
		case CERTMGR_LOG_STORE_RSOP:
		case CERTMGR_USAGE:
			{
				// Get parent window handle and attach to a CWnd object
				hr = m_pConsole->GetMainWindow (&hParent);
				ASSERT (SUCCEEDED (hr));
				if ( SUCCEEDED (hr) )
				{
					CWnd	parentWnd;
					VERIFY (parentWnd.Attach (hParent));
					CFindDialog	findDlg (&parentWnd,
							pParentCookie->QueryNonNULLMachineName (),
							m_szFileName,
							this);
					CThemeContextActivator activator;
                    INT_PTR	iReturn = findDlg.DoModal ();
					ASSERT (-1 != iReturn && IDABORT != iReturn);
					if ( -1 == iReturn || IDABORT == iReturn )
						hr = E_UNEXPECTED;
                    else
                    {
                        if ( findDlg.ConsoleRefreshRequired () )
                        {
                            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 
                                    HINT_REFRESH_STORES);
                        }
                    }

					parentWnd.Detach ();

                    
				}
			}
			break;

		case CERTMGR_CERTIFICATE:
		case CERTMGR_CRL:
		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
			ASSERT (0);
			hr = E_UNEXPECTED;
			break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

		case CERTMGR_CRL_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
		case CERTMGR_CERT_CONTAINER:
			break;

		default:
			ASSERT (0);
			hr = E_UNEXPECTED;
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnFind: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnChangeComputer (LPDATAOBJECT pDataObject)
{
    if ( !pDataObject )
        return E_POINTER;

	_TRACE (1, L"Entering CCertMgrComponentData::OnChangeComputer\n");
	HRESULT	hr = S_OK;
	ASSERT (pDataObject);
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());


	ASSERT (pDataObject);
	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie && CERTMGR_SNAPIN == pParentCookie->m_objecttype )
    {
	    HWND    hWndParent = NULL;
	    hr = m_pConsole->GetMainWindow (&hWndParent);
	    CString	machineName;
	    hr = ComputerNameFromObjectPicker (hWndParent, machineName);
	    if ( S_OK == hr )  // S_FALSE means user pressed "Cancel"
	    {
		    machineName.MakeUpper ();

		    // added IsLocalComputername 1/27/99 JonN
		    // If the user chooses the local computer, treat that as if they had chosen
		    // "Local Computer" in Snapin Manager.  This means that there is no way to
		    // reset the snapin to target explicitly at this computer without either
		    // reloading the snapin from Snapin Manager, or going to a different computer.
		    // When the Choose Target Computer UI is revised, we can make this more
		    // consistent with Snapin Manager.
		    if ( IsLocalComputername( machineName ) )
			    machineName = L"";

		    QueryRootCookie().SetMachineName (machineName);

		    // Set the persistent name.  If we are managing the local computer
		    // this name should be empty.
		    m_strMachineNamePersist = machineName;

		    hr = ChangeRootNodeName (machineName);
		    if ( SUCCEEDED(hr) )
		    {
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_CHANGE_COMPUTER);
		    }
	    }
    }
    else
		hr = E_UNEXPECTED;


	_TRACE (-1, L"Leaving CCertMgrComponentData::OnChangeComputer: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::IsUserAdministrator (BOOL & bIsAdministrator)
{
	_TRACE (1, L"Entering CCertMgrComponentData::IsUserAdministrator\n");
	HRESULT	hr = S_OK;
	DWORD	dwErr = 0;

	bIsAdministrator = FALSE;
	if ( IsWindowsNT () )
	{
		PSID						psidAdministrators;
		SID_IDENTIFIER_AUTHORITY	siaNtAuthority = SECURITY_NT_AUTHORITY;

		BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
				0, 0, 0, 0, 0, 0, &psidAdministrators);
		if ( bResult )
		{
			bResult = CheckTokenMembership (0, psidAdministrators,
					&bIsAdministrator);
			ASSERT (bResult);
			if ( !bResult )
			{
				dwErr = GetLastError ();
				DisplaySystemError (dwErr);
				hr = HRESULT_FROM_WIN32 (dwErr);
			}
			FreeSid (psidAdministrators);
		}
		else
		{
			dwErr = GetLastError ();
			DisplaySystemError (dwErr);
			hr = HRESULT_FROM_WIN32 (dwErr);
		}
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::IsUserAdministrator: 0x%x\n", hr);
	return hr;
}


void CCertMgrComponentData::DisplaySystemError (DWORD dwErr)
{
	_TRACE (1, L"Entering CCertMgrComponentData::DisplaySystemError\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	LPVOID lpMsgBuf;
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			 (PWSTR) &lpMsgBuf,    0,    NULL );
		
	// Display the string.
	CString	caption;
	VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
	int		iRetVal = 0;
	if ( m_pConsole )
	{
		HRESULT	hr = m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
			MB_ICONWARNING | MB_OK, &iRetVal);
		ASSERT (SUCCEEDED (hr));
	}
	else
	{
        CThemeContextActivator activator;
		::MessageBox (NULL, (PWSTR) lpMsgBuf, caption, MB_ICONWARNING | MB_OK);
	}
	// Free the buffer.
	LocalFree (lpMsgBuf);
	_TRACE (-1, L"Leaving CCertMgrComponentData::DisplaySystemError\n");
}

CString CCertMgrComponentData::GetCommandLineFileName () const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::GetCommandLineFileName\n");
	return m_szFileName;
}

//
// GetManagedComputer ()
//
// Returns the name of the managed computer.  If we are managing the local machine
// returns an empty string. (As required by a number of Crypt32 APIs
//
CString CCertMgrComponentData::GetManagedComputer () const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::GetManagedComputer\n");
	if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )  // !=
	{
		return m_szManagedComputer;
	}
	else
		return _T ("");
}

CString CCertMgrComponentData::GetManagedService () const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::GetManagedService\n");
	return m_szManagedServicePersist;
}

DWORD CCertMgrComponentData::GetLocation () const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::GetLocation\n");
	return m_dwLocationPersist;
}

LPCONSOLENAMESPACE CCertMgrComponentData::GetConsoleNameSpace () const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::GetConsoleNameSpace\n");
	return m_pConsoleNameSpace;
}


CUsageCookie* CCertMgrComponentData::FindDuplicateUsage (HSCOPEITEM hParent, PCWSTR pszName)
{
	_TRACE (1, L"Entering CCertMgrComponentData::FindDuplicateUsage\n");
	CUsageCookie*	pUsageCookie = 0;

	MMC_COOKIE		lCookie = 0;
	HSCOPEITEM		hChildItem = 0;
	bool			bFound = false;

	HRESULT	hr = m_pConsoleNameSpace->GetChildItem (hParent, &hChildItem, &lCookie);
	ASSERT (SUCCEEDED (hr));
	while ( hChildItem && SUCCEEDED (hr) )
	{
		pUsageCookie = reinterpret_cast <CUsageCookie*> (lCookie);
		if ( !wcscoll (pszName, pUsageCookie->GetObjectName ()) )
		{
			bFound = true;
			break;
		}

		hr = m_pConsoleNameSpace->GetNextItem (hChildItem, &hChildItem, &lCookie);
		ASSERT (SUCCEEDED (hr));
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::FindDuplicateUsage\n");
	if ( bFound )
		return pUsageCookie;
	else
		return NULL;
}


bool CCertMgrComponentData::IsSecurityConfigurationEditorNodetype (const GUID& refguid) const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::IsSecurityConfigurationEditorNodetype\n");
	return ::IsEqualGUID (refguid, cNodetypeSceTemplate) ? true : false;
}


HRESULT CCertMgrComponentData::OnEnroll (LPDATAOBJECT pDataObject, bool bNewKey)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnEnroll\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie )
	{
		CCertStore*		pStore = 0;
		CCertificate*	pCert = 0;
		CCertStoreGPE*	pGPEStore = 0;
		bool			bParentIsStoreOrContainer = false;
		HSCOPEITEM		hScopeItem = 0;
		bool			bEFSPolicyTurnedOn = false;

		switch (pParentCookie->m_objecttype)
		{
		case CERTMGR_CERTIFICATE:
			pCert = reinterpret_cast <CCertificate*> (pParentCookie);
			ASSERT (pCert);
			break;

		case CERTMGR_PHYS_STORE:
		case CERTMGR_LOG_STORE:
			if ( !m_pGPEInformation )  // If we are not extending the GPE/SCE
			{
				hScopeItem = pParentCookie->m_hScopeItem; // = 0;
				pStore = reinterpret_cast <CCertStore*> (pParentCookie);
				ASSERT (pStore);
			}
			bParentIsStoreOrContainer = true;
			break;

		case CERTMGR_CERT_CONTAINER:
			if ( !m_pGPEInformation )  // If we are not extending the GPE/SCE
			{
				CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pParentCookie);
				ASSERT (pContainer);
				if ( pContainer )
				{
					MMC_COOKIE lCookie = 0;
					hr = m_pConsoleNameSpace->GetParentItem (
							pContainer->m_hScopeItem, &hScopeItem, &lCookie);
					ASSERT (SUCCEEDED (hr));
					pStore = &pContainer->GetCertStore ();
				}
			}
			bParentIsStoreOrContainer = true;
			break;

		case CERTMGR_USAGE:
			break;

		case CERTMGR_LOG_STORE_RSOP:
            ASSERT (0);
            return E_FAIL;
            break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

		case CERTMGR_LOG_STORE_GPE:
			pGPEStore = reinterpret_cast <CCertStoreGPE*> (pParentCookie);
			ASSERT (pGPEStore);
			if ( pGPEStore )
			{
				if ( pGPEStore->IsNullEFSPolicy () )
				{
					pGPEStore->AllowEmptyEFSPolicy ();
					bEFSPolicyTurnedOn = true;
				}
			}
			else
				return E_FAIL;
			break;

		default:
			ASSERT (0);
			return E_UNEXPECTED;
		}
		HWND			hwndParent = 0;
		hr = m_pConsole->GetMainWindow (&hwndParent);
		ASSERT (SUCCEEDED (hr));
		CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT	pvkCert;
		CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW	pvkNew;
		CRYPTUI_WIZ_CERT_REQUEST_INFO		certRequestInfo;
		CRYPT_KEY_PROV_INFO					provInfo;

		// For EFS Recovery Agent
		CRYPTUI_WIZ_CERT_TYPE				certType;
		PWSTR								rgwszCertType = wszCERTTYPE_EFS_RECOVERY;
		
		::ZeroMemory (&certRequestInfo, sizeof (certRequestInfo));
		certRequestInfo.dwSize = sizeof (certRequestInfo);
		certRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

		// User wants to manage user account
		//	pass in NULL to machine name and to account name
		// User wants to manage local machine account
		//  pass in NULL for account name and result of ::GetComputerName ()
		//	to machine name
		// User want to manage remote machine
		//  pass in NULL for account name and machine name for machineName
		// User wants to manage remote account on remote machine
		//  pass in account name for accountName and machine name for machineName
		switch (m_dwLocationPersist)
		{
		case CERT_SYSTEM_STORE_CURRENT_SERVICE:
		case CERT_SYSTEM_STORE_SERVICES:
			certRequestInfo.pwszMachineName = (PCWSTR) m_szManagedComputer;
			certRequestInfo.pwszAccountName = (PCWSTR) m_szManagedServicePersist;
			break;

		case CERT_SYSTEM_STORE_CURRENT_USER:
			certRequestInfo.pwszMachineName = NULL;
			certRequestInfo.pwszAccountName = NULL;
			break;

		case CERT_SYSTEM_STORE_LOCAL_MACHINE:
			certRequestInfo.pwszMachineName = (PCWSTR) m_szManagedComputer;
			certRequestInfo.pwszAccountName = NULL;
			break;

		case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
		case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
			certRequestInfo.pwszMachineName = NULL;
			certRequestInfo.pwszAccountName = NULL;
			certRequestInfo.pwszDesStore = 0;
			certRequestInfo.dwCertOpenStoreFlag = 0;
			break;

		default:
			ASSERT (0);
			return E_UNEXPECTED;
			break;
		}


		if ( !pCert || bNewKey )
		{
			// Request a certificate with a new key
			certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
			::ZeroMemory (&pvkNew, sizeof (pvkNew));
			pvkNew.dwSize = sizeof (pvkNew);
			certRequestInfo.pPvkNew = &pvkNew;
			if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist )
			{
				::ZeroMemory (&provInfo, sizeof (provInfo));

				provInfo.dwFlags = CRYPT_MACHINE_KEYSET;
				pvkNew.pKeyProvInfo = &provInfo;
			}

			if ( pGPEStore && EFS_STORE == pGPEStore->GetStoreType () )
			{
				// This creates an Encryption Recovery Agent.
				::ZeroMemory (&certType, sizeof (CRYPTUI_WIZ_CERT_TYPE));
				certType.dwSize = sizeof (CRYPTUI_WIZ_CERT_TYPE);
				certType.cCertType = 1;
				certType.rgwszCertType = &rgwszCertType;
				
				
				certRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
				certRequestInfo.pCertType = &certType;
				::ZeroMemory (&provInfo, sizeof (provInfo));
				provInfo.pwszProvName = MS_DEF_PROV_W;
				provInfo.dwProvType = PROV_RSA_FULL;

				pvkNew.pKeyProvInfo = &provInfo;
				pvkNew.dwGenKeyFlags = CRYPT_EXPORTABLE;
			}
		}
		else
		{
			// Request a certificate with the same key as an existing certificate
            if ( IsLocalComputername (m_szManagedComputer) )
            {
                // Find out if the cert has a private key before continuing.
                DWORD   dwFlags = 0;

                if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist )
                    dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
			    if ( !::CryptFindCertificateKeyProvInfo (
					    pCert->GetCertContext (), dwFlags, 0) )
			    {
				    CString	text;
				    CString caption;
                    CThemeContextActivator activator;

				    VERIFY (text.LoadString (IDS_NO_PRIVATE_KEY));
				    VERIFY (caption.LoadString (IDS_REQUEST_CERT_SAME_KEY));
				    ::MessageBox (hwndParent, text, caption, MB_OK);
				    return hr;
			    }
            }
			certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT;
			::ZeroMemory (&pvkCert, sizeof (pvkCert));
			pvkCert.dwSize = sizeof (pvkCert);
			pvkCert.pCertContext = pCert->GetCertContext ();
			certRequestInfo.pPvkCert = &pvkCert;
		}

		certRequestInfo.pwszCertDNName = NULL;

		// Now that all the preliminaries are out of they way and the data is
		// all set up, call the enrollment wizard.
		DWORD			status = 0;
		PCCERT_CONTEXT	pNewCertContext = 0;
		BOOL			bResult = FALSE;
        CThemeContextActivator activator;        

        while (1)
        {
            bResult = ::CryptUIWizCertRequest (
                bNewKey ? CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY : 0,
				    hwndParent, NULL,
				    &certRequestInfo, &pNewCertContext, &status);
            DWORD   dwErr = GetLastError ();
            if ( !bResult && HRESULT_FROM_WIN32 (NTE_TOKEN_KEYSET_STORAGE_FULL) == dwErr )
            {
                // NTRAID# 299089 Enrollment Wizard: Should return some 
                // meaningful message when users fail to enroll/renew on a 
                // smart card
                if ( !bNewKey )
                    break;

                CString text;
                CString caption;
			    int		iRetVal = 0;

                VERIFY (text.LoadString (IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY));
			    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			    hr = m_pConsole->MessageBox (text, caption,
					    MB_YESNO, &iRetVal);
			    ASSERT (SUCCEEDED (hr));
                if ( IDYES == iRetVal )
                {
                    bNewKey = false;
                }
                else
                    break;
            }
            else
                break;
        }

		if ( bResult && (CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == status) && pNewCertContext )
		{
			if ( bEFSPolicyTurnedOn )
				hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);

            ASSERT (!(pStore && pGPEStore)); // these can't both be true
			if ( pStore )
			{
				pStore->IncrementCertCount ();
				pStore->SetDirty ();
				pStore->Resync ();
				
			}
			else if ( pGPEStore )
			{
				pGPEStore->InvalidateCertCount ();
				pGPEStore->SetDirty ();
				pGPEStore->Resync ();


			    if ( EFS_STORE == pGPEStore->GetStoreType () )
			    {
				    hr = CompleteEFSRecoveryAgent (pGPEStore, pNewCertContext);
			    }
			}
            else if ( pCert && pCert->GetCertStore ())
            {
                pCert->GetCertStore ()->Resync ();
            }

			if ( !m_pGPEInformation )  // If we are not extending the GPE/SCE
			{
                if ( bParentIsStoreOrContainer )
                {
				    ASSERT (hScopeItem);
				    ASSERT (pStore);
				    hr = CreateContainers (hScopeItem, *pStore);
				    if ( CERTMGR_CERT_CONTAINER == pParentCookie->m_objecttype )
				    {
                        // Add certificate to result pane
	                    RESULTDATAITEM			rdItem;
	                    CCookie&				rootCookie = QueryBaseRootCookie ();

	                    ::ZeroMemory (&rdItem, sizeof (rdItem));
	                    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
	                    rdItem.nImage = iIconCertificate;
	                    rdItem.nCol = 0;
                        rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
	                    rdItem.str = MMC_TEXTCALLBACK;

                        PCCERT_CONTEXT pFoundCertContext = 
                                pStore->FindCertificate (0, CERT_FIND_EXISTING,
                                (void*) pNewCertContext, NULL);
                        if ( pFoundCertContext )
                        {
	                        pCert = new CCertificate (pFoundCertContext, pStore);
		                    if ( pCert )
                            {
		                        rootCookie.m_listResultCookieBlocks.AddHead (pCert);
		                        rdItem.lParam = (LPARAM) pCert;
		                        pCert->m_resultDataID = m_pResultData;
		                        hr = m_pResultData->InsertItem (&rdItem);
                                if ( FAILED (hr) )
                                {
                                     _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                }
                                else
                                {
                                    hr = DisplayCertificateCountByStore (
                                            m_pComponentConsole, pStore, false);
                                }
                            }
                            else
			                    hr = E_OUTOFMEMORY;

                            ::CertFreeCertificateContext (pFoundCertContext);
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32 (GetLastError ());
                        }

					    ASSERT (SUCCEEDED (hr));
				    }
                    hr = DisplayCertificateCountByStore (m_pComponentConsole, pStore);
                }
                else
                {
				    hr = m_pConsole->UpdateAllViews (pDataObject, 0, 
                            HINT_CERT_ENROLLED_USAGE_MODE);
				    ASSERT (SUCCEEDED (hr));
                }
			}
			else
			{
				hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
				ASSERT (SUCCEEDED (hr));
				hr = DisplayCertificateCountByStore (m_pComponentConsole, pGPEStore, true);
			}
			::CertFreeCertificateContext (pNewCertContext);
		}
		else if ( bEFSPolicyTurnedOn )
		{
			// If we allowed policy creation just for this enrollment, but
			// nothing was enrolled, go ahead and delete the policy.
			hr = OnDeleteEFSPolicy (pDataObject, false);
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnEnroll: 0x%x\n", hr);
	return hr;
}


HRESULT RenewCertificate (
        CCertificate* pCert, 
        bool bNewKey, 
        const CString& machineName, 
        DWORD dwLocation,
        const CString& managedComputer, 
        const CString& managedService, 
        HWND hwndParent, 
        LPCONSOLE pConsole,
        LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    if ( pCert )
    {
		CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT	pvkCert;
		CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW	pvkNew;
		CRYPTUI_WIZ_CERT_REQUEST_INFO		certRequestInfo;
		CRYPT_KEY_PROV_INFO					provInfo;


		::ZeroMemory (&certRequestInfo, sizeof (certRequestInfo));
		certRequestInfo.dwSize = sizeof (certRequestInfo);
		certRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
		// User wants to manage user account
		//	pass in NULL to machine name and to account name
		// User wants to manage local machine account
		//  pass in NULL for account name and result of ::GetComputerName ()
		//	to machine name
		// User want to manage remote machine
		//  pass in NULL for account name and machine name for machineName
		// User wants to manage remote account on remote machine
		//  pass in account name for accountName and machine name for machineName
		// TODO: Ensure that this is NULL if the local machine
		BOOL	bIsLocalMachine = IsLocalComputername (machineName);
		switch (dwLocation)
		{
		case CERT_SYSTEM_STORE_CURRENT_SERVICE:
		case CERT_SYSTEM_STORE_SERVICES:
			certRequestInfo.pwszMachineName = (PCWSTR) managedComputer;
			certRequestInfo.pwszAccountName = (PCWSTR) managedService;
			break;

		case CERT_SYSTEM_STORE_CURRENT_USER:
			certRequestInfo.pwszMachineName = NULL;
			certRequestInfo.pwszAccountName = NULL;
			break;

		case CERT_SYSTEM_STORE_LOCAL_MACHINE:
			certRequestInfo.pwszMachineName = (PCWSTR) managedComputer;
			certRequestInfo.pwszAccountName = NULL;
			break;

		default:
			ASSERT (0);
			return E_UNEXPECTED;
			break;
		}
		certRequestInfo.pRenewCertContext = pCert->GetCertContext ();
		if ( bNewKey )
		{
			certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
			::ZeroMemory (&pvkNew, sizeof (pvkNew));
			pvkNew.dwSize = sizeof (pvkNew);
			if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == dwLocation )
			{
				::ZeroMemory (&provInfo, sizeof (provInfo));
				provInfo.dwFlags = CRYPT_MACHINE_KEYSET;
				pvkNew.pKeyProvInfo = &provInfo;
			}
			certRequestInfo.pPvkNew = &pvkNew;
		}
		else
		{
            if ( bIsLocalMachine )
            {
                DWORD   dwFlags = 0;

                if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == dwLocation )
                    dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
			    if ( !::CryptFindCertificateKeyProvInfo (
					    pCert->GetCertContext (), dwFlags, 0) )
			    {
				    CString	text;
				    CString caption;
                    CThemeContextActivator activator;

				    VERIFY (text.LoadString (IDS_NO_PRIVATE_KEY));
				    VERIFY (caption.LoadString (IDS_RENEW_CERT_SAME_KEY));
				    ::MessageBox (hwndParent, text, caption, MB_OK);
				    return hr;
			    }
            }

			certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT;
			::ZeroMemory (&pvkCert, sizeof (pvkCert));
			pvkCert.dwSize = sizeof (pvkCert);
			pvkCert.pCertContext = pCert->GetCertContext ();
			certRequestInfo.pPvkCert = &pvkCert;
		}
			

		DWORD			status = 0;
		PCCERT_CONTEXT	pNewCertContext = 0;
		BOOL			bResult = FALSE;
        CThemeContextActivator activator;           

        while (1)
        {
            bResult = ::CryptUIWizCertRequest (
                bNewKey ? CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY : 0,
				    hwndParent, NULL,
				    &certRequestInfo, &pNewCertContext, &status);
            if ( !bResult && HRESULT_FROM_WIN32 (NTE_TOKEN_KEYSET_STORAGE_FULL) == GetLastError () )
            {
                // NTRAID# 299089 Enrollment Wizard: Should return some 
                // meaningful message when users fail to enroll/renew on a 
                // smart card
                if ( !bNewKey )
                    break;

                CString text;
                CString caption;
			    int		iRetVal = 0;

                VERIFY (text.LoadString (IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY));
			    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                if ( pConsole )
                {
    			    hr = pConsole->MessageBox (text, caption, MB_YESNO, &iRetVal);
		    	    ASSERT (SUCCEEDED (hr));
                }
                else
                {
                    CThemeContextActivator activator;
                    iRetVal = ::MessageBox (hwndParent, text, caption, MB_OK);
                }
                if ( IDYES == iRetVal )
                {
                    bNewKey = false;
                }
                else
                    break;
            }
            else
                break;
        }

		if ( bResult && (CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == status) && pNewCertContext )
		{
            CCertStore* pStore = pCert->GetCertStore ();
            if ( pStore )
            {
                pStore->SetDirty ();
                pStore->Resync ();
                if ( pConsole )
			        hr = pConsole->UpdateAllViews (pDataObject, 0, 0);
            }

            CertFreeCertificateContext (pNewCertContext);
			ASSERT (SUCCEEDED (hr));
		}
    }
    else
        hr = E_POINTER;

    return hr;
}

HRESULT CCertMgrComponentData::OnRenew (LPDATAOBJECT pDataObject, bool bNewKey)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnRenew\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	        hr = S_OK;
	HWND	        hwndParent = 0;
	VERIFY (SUCCEEDED (m_pConsole->GetMainWindow (&hwndParent)));
	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie && CERTMGR_CERTIFICATE == pParentCookie->m_objecttype )
	{
		CCertificate* pCert = reinterpret_cast <CCertificate*> (pParentCookie);
		ASSERT (pCert);
		if ( pCert )
		{
            hr = RenewCertificate (pCert, bNewKey, m_strMachineNamePersist, 
                    m_dwLocationPersist, m_szManagedComputer, 
                    m_szManagedServicePersist, hwndParent, m_pConsole, pDataObject);
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnRenew: 0x%x\n", hr);
	return hr;
}


CCertMgrCookie* CCertMgrComponentData::ConvertCookie (LPDATAOBJECT pDataObject)
{
	CCertMgrCookie*	pParentCookie = 0;
	CCookie*		pBaseParentCookie = 0;
	HRESULT			hr = ExtractData (pDataObject,
			CCertMgrDataObject::m_CFRawCookie,
			 &pBaseParentCookie,
			 sizeof (pBaseParentCookie) );
	if ( SUCCEEDED (hr) )
	{
		pParentCookie = ActiveCookie (pBaseParentCookie);
		ASSERT (pParentCookie);
	}
	return pParentCookie;
}


HRESULT CCertMgrComponentData::OnImport (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnImport\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;
	ASSERT (m_szFileName.IsEmpty ());
	if ( !m_szFileName.IsEmpty () )
		return E_UNEXPECTED;
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;
	

	DWORD			dwFlags = 0;
    
    if ( CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist )
    {
        // We're managing the user's certificate store
        dwFlags |= CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER;
    }
    else 
    {
        // We're managing certificates on a machine
        dwFlags |= CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE;

        if ( !IsLocalComputername (m_szManagedComputer) )
        {
            // We're managing certificates on a remote machine
            dwFlags |= CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE;
        }
    }

	HCERTSTORE		hDestStore = 0;
	CCertStore*		pDestStore = 0;
	HSCOPEITEM		hScopeItem = 0;
	int				nOriginalCertCount = 0;

	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie )
	{
		hScopeItem = pParentCookie->m_hScopeItem;
		switch (pParentCookie->m_objecttype)
		{
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

		case CERTMGR_LOG_STORE_RSOP:
            ASSERT (0);
            return E_FAIL;
            break;

		case CERTMGR_LOG_STORE_GPE:
			{
                dwFlags |= CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE;
				pDestStore = reinterpret_cast <CCertStore*> (pParentCookie);
				ASSERT (pDestStore);
				if ( pDestStore )
				{
					nOriginalCertCount = pDestStore->GetCertCount ();
					hDestStore = pDestStore->GetStoreHandle ();

					switch (pDestStore->GetStoreType ())
					{
					case ACRS_STORE:
						break;
							
					case TRUST_STORE:
						dwFlags |= CRYPTUI_WIZ_IMPORT_ALLOW_CTL;
						break;

					case ROOT_STORE:
						dwFlags |= CRYPTUI_WIZ_IMPORT_ALLOW_CERT;
						break;

					case EFS_STORE:
						break;

					default:
						ASSERT (0);
						break;
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

		case CERTMGR_LOG_STORE:
		case CERTMGR_PHYS_STORE:
			{
				pDestStore = reinterpret_cast <CCertStore*> (pParentCookie);
				ASSERT (pDestStore);
				if ( pDestStore )
				{
					nOriginalCertCount = pDestStore->GetCertCount ();
					hDestStore = pDestStore->GetStoreHandle ();
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

		case CERTMGR_CERT_CONTAINER:
		case CERTMGR_CTL_CONTAINER:
			{
				CContainerCookie*	pContainer = reinterpret_cast <CContainerCookie*> (pParentCookie);
				ASSERT (pContainer);
				if ( pContainer )
				{
					MMC_COOKIE lCookie = 0;
					hr = m_pConsoleNameSpace->GetParentItem (
							pContainer->m_hScopeItem, &hScopeItem, &lCookie);
					ASSERT (SUCCEEDED (hr));
					pDestStore = &pContainer->GetCertStore ();
					nOriginalCertCount = pDestStore->GetCertCount ();
					hDestStore = pDestStore->GetStoreHandle ();
				}
				else
					hr = E_UNEXPECTED;
			}
			break;

        case CERTMGR_USAGE:
            pDestStore = 0;
            hDestStore = 0;
            break;

		default:
			ASSERT (0);
			hr = E_UNEXPECTED;
		}
	}
    else
        hr = E_UNEXPECTED;


	if ( SUCCEEDED (hr) )
	{
		HWND				hwndParent = 0;
		hr = m_pConsole->GetMainWindow (&hwndParent);
		ASSERT (SUCCEEDED (hr));

		// Now that all the data is set up and everything is in readiness,
		// call the Import Wizard
        CThemeContextActivator activator;
		BOOL bResult = ::CryptUIWizImport (dwFlags, hwndParent, 0, NULL, hDestStore);
		if ( bResult )
		{
			bool		bWizardCancelled = false;
			CCertStore*	pStore = 0;

			switch (pParentCookie->m_objecttype)
			{
            case CERTMGR_LOG_STORE_RSOP:
                ASSERT (0);
                return E_FAIL;
                break;

			case CERTMGR_LOG_STORE_GPE:
			case CERTMGR_LOG_STORE:
			case CERTMGR_PHYS_STORE:
				{
					pStore = reinterpret_cast <CCertStore*> (pParentCookie);
					ASSERT (pStore);
					if ( pStore )
					{
						pStore->InvalidateCertCount ();
						if ( pStore->GetCertCount () != nOriginalCertCount )
						{
							pStore->SetDirty ();
							hr = pStore->Commit ();
						}
						else
							bWizardCancelled = true;
					}
					else
						hr = E_UNEXPECTED;
				}
				break;

			case CERTMGR_CERT_CONTAINER:
			case CERTMGR_CTL_CONTAINER:
				{
					CContainerCookie*	pContainer = reinterpret_cast <CContainerCookie*> (pParentCookie);
					ASSERT (pContainer);
					if ( pContainer )
					{
						pStore = &pContainer->GetCertStore ();
						
						pStore->InvalidateCertCount ();
						if ( pStore->GetCertCount () != nOriginalCertCount )
						{
							pStore->SetDirty ();
							hr = pStore->Commit ();
						}
						else
							bWizardCancelled = true;
					}
					else
						hr = E_UNEXPECTED;
				}
				break;

            case CERTMGR_USAGE:
                break;

			default:
				ASSERT (0);
				hr = E_UNEXPECTED;
			}

			if ( !bWizardCancelled )
			{
				if ( pStore )
				{
					if ( SUCCEEDED (hr) )
						pStore->Resync ();
				}
				
				if ( CERTMGR_LOG_STORE == pParentCookie->m_objecttype ||
						(CERTMGR_LOG_STORE == pParentCookie->m_objecttype && !m_bShowPhysicalStoresPersist) )
				{
                    if ( pStore )
					    hr = CreateContainers (hScopeItem, *pStore);
				}

				hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_IMPORT);
				ASSERT (SUCCEEDED (hr));
			}
		}
		if ( pDestStore )
			pDestStore->Close ();
	}
	_TRACE (-1, L"Leaving CCertMgrComponentData::OnImport: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnExport (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnExport\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;

	LPDATAOBJECT	pMSDO = ExtractMultiSelect (pDataObject);
	m_bMultipleObjectsSelected = false;

	if ( pMSDO )
	{
		// Iterate through list of selected objects -
		// Add them to a memory store
		// Export to PFX file through wizard with new
		// "export from store - certs only" flag
		m_bMultipleObjectsSelected = true;
		HCERTSTORE	hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
				0, NULL, 0, NULL);
		ASSERT (hCertStore);
		if ( hCertStore )
		{
			CCertMgrCookie*		pCookie = 0;
			CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
			ASSERT (pDO);
			if ( pDO )
			{
				BOOL	bResult = FALSE;
				pDO->Reset();
				while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
				{
					ASSERT (CERTMGR_CERTIFICATE == pCookie->m_objecttype);
					if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
					{
						CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
						ASSERT (pCert);
						if ( pCert )
						{
							bResult = ::CertAddCertificateContextToStore (
									hCertStore,
									::CertDuplicateCertificateContext (pCert->GetCertContext ()),
									CERT_STORE_ADD_NEW, 0);
							ASSERT (bResult);
							if ( !bResult )
								break;
						}
					}
				}

				// Call Export Wizard
				CRYPTUI_WIZ_EXPORT_INFO	cwi;
				::ZeroMemory (&cwi, sizeof (cwi));
				cwi.dwSize = sizeof (cwi);
				cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY;
				cwi.hCertStore = hCertStore;

				HWND	hwndParent = 0;
				hr = m_pConsole->GetMainWindow (&hwndParent);
				ASSERT (SUCCEEDED (hr));
                CThemeContextActivator activator;
				bResult = ::CryptUIWizExport (
						0,
						hwndParent,
						0,
						&cwi,
						NULL);

				VERIFY (::CertCloseStore (hCertStore, CERT_CLOSE_STORE_CHECK_FLAG));
			}
			else
				hr = E_FAIL;

			return hr;
		}
		else
		{
			
			_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
					CERT_STORE_PROV_MEMORY, GetLastError ());		
		}
	}


	CRYPTUI_WIZ_EXPORT_INFO	cwi;
	CCertificate*			pCert = 0;
	CCRL*					pCRL = 0;
	CCTL*					pCTL = 0;
	CCertStore*				pCertStore = 0;
	CCertMgrCookie*			pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( !pCookie )
		return E_UNEXPECTED;

	::ZeroMemory (&cwi, sizeof (cwi));
	cwi.dwSize = sizeof (cwi);
	switch (pCookie->m_objecttype)
	{
	case CERTMGR_CERTIFICATE:
		cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
		pCert = reinterpret_cast <CCertificate*> (pCookie);
		ASSERT (pCert);
		if ( pCert )
			cwi.pCertContext = pCert->GetCertContext ();
		else
			return E_UNEXPECTED;
		break;

	case CERTMGR_CRL:
		cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CRL_CONTEXT;
		pCRL = reinterpret_cast <CCRL*> (pCookie);
		ASSERT (pCRL);
		if ( pCRL )
			cwi.pCRLContext = pCRL->GetCRLContext ();
		else
			return E_UNEXPECTED;
		break;

	case CERTMGR_CTL:
		cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CTL_CONTEXT;
		pCTL = reinterpret_cast <CCTL*> (pCookie);
		ASSERT (pCTL);
		if ( pCTL )
			cwi.pCTLContext = pCTL->GetCTLContext ();
		else
			return E_UNEXPECTED;
		break;

	case CERTMGR_LOG_STORE:
	case CERTMGR_PHYS_STORE:
		cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_STORE;
		pCertStore = reinterpret_cast <CCertStore*> (pCookie);
		ASSERT (pCertStore);
		if ( pCertStore )
			cwi.hCertStore = pCertStore->GetStoreHandle ();
		else
			return E_UNEXPECTED;
		break;

	default:
		ASSERT (0);
		return E_UNEXPECTED;
	}

	HWND	hwndParent = 0;
	hr = m_pConsole->GetMainWindow (&hwndParent);
	ASSERT (SUCCEEDED (hr));
    CThemeContextActivator activator;
	::CryptUIWizExport (
			0,
			hwndParent,
			0,
			&cwi,
			NULL);

	if ( pCertStore )
		pCertStore->Close ();
	_TRACE (-1, L"Leaving CCertMgrComponentData::OnExport: 0x%x\n", hr);
	return hr;
}

					
HRESULT CCertMgrComponentData::OnNewCTL (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnNewCTL\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;
	HRESULT				hr = S_OK;
	CCertMgrCookie*		pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( !pCookie )
		return E_UNEXPECTED;

	CCertStore*	pStore = 0;
	CContainerCookie* pCont = 0;

	switch ( pCookie->m_objecttype )
	{
	case CERTMGR_CTL_CONTAINER:
		{
			pCont = reinterpret_cast <CContainerCookie*> (pCookie);
			ASSERT (pCont);
			if ( pCont )
			{
				pStore = &(pCont->GetCertStore ());
			}
			else
				return E_UNEXPECTED;
		}
		break;

	case CERTMGR_LOG_STORE_RSOP:
        ASSERT (0);
        return E_UNEXPECTED;
        break;

	case CERTMGR_LOG_STORE:
	case CERTMGR_LOG_STORE_GPE:
	case CERTMGR_PHYS_STORE:
		{
			pStore = reinterpret_cast <CCertStore*> (pCookie);
			ASSERT (pStore);
			if ( !pStore )
				return E_UNEXPECTED;
		}
		break;

	default:
		ASSERT (0);
		return E_UNEXPECTED;
	}

	ASSERT (pStore);
	if ( !pStore )
		return E_UNEXPECTED;

    pStore->Lock ();

	CRYPTUI_WIZ_BUILDCTL_DEST_INFO	destInfo;

	::ZeroMemory (&destInfo, sizeof (destInfo));
	destInfo.dwSize = sizeof (destInfo);
	destInfo.dwDestinationChoice = CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE;
	destInfo.hCertStore = pStore->GetStoreHandle ();
	ASSERT (destInfo.hCertStore);
	if ( !destInfo.hCertStore )
		return E_UNEXPECTED;

	HWND	hwndParent = 0;
	hr = m_pConsole->GetMainWindow (&hwndParent);
	ASSERT (SUCCEEDED (hr));
	PCCTL_CONTEXT	pCTLContext = 0;
    CThemeContextActivator activator;
	BOOL	bResult = ::CryptUIWizBuildCTL (
			CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
			hwndParent,
			0,
			NULL,
			&destInfo,
			&pCTLContext);
	if ( bResult )
	{
		// If pCTLContext, then the wizard completed
		if ( pCTLContext )
		{
			pStore->SetDirty ();
			pStore->Commit ();
			hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
			ASSERT (SUCCEEDED (hr));
			::CertFreeCTLContext (pCTLContext);
		}
	}

    pStore->Unlock ();
	pStore->Close ();
	_TRACE (-1, L"Leaving CCertMgrComponentData::OnNewCTL: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnACRSEdit (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnACRSEdit\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT				hr = S_OK;
	CCertMgrCookie*		pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( !pCookie )
		return E_UNEXPECTED;

	switch ( pCookie->m_objecttype )
	{
	case CERTMGR_AUTO_CERT_REQUEST:
		{
			CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pCookie);
			ASSERT (pACR);
			if ( pACR )
			{
				CCertStore& rStore = pACR->GetCertStore ();
				CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (&rStore);
				ASSERT (pStore);
				if ( pStore )
				{
					HWND		hwndConsole = 0;
					hr = m_pConsole->GetMainWindow (&hwndConsole);
					ASSERT (SUCCEEDED (hr));
					if ( SUCCEEDED (hr) )
					{
						ACRSWizardPropertySheet	sheet (pStore, pACR);

						ACRSWizardWelcomePage	welcomePage;
						ACRSWizardTypePage		typePage;
						ACRSCompletionPage		completionPage;

						sheet.AddPage (&welcomePage);
						sheet.AddPage (&typePage);
						sheet.AddPage (&completionPage);

						if ( sheet.DoWizard (hwndConsole) )
						{
							pStore->SetDirty ();
							hr = DeleteCTLFromResultPane (pACR, pDataObject);
							hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
							ASSERT (SUCCEEDED (hr));
						}
					}
				}
				else
					hr = E_UNEXPECTED;
			}
			else
				return E_UNEXPECTED;
		}
		break;

	default:
		ASSERT (0);
		return E_UNEXPECTED;
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnACRSEdit: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnCTLEdit (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnCTLEdit\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;
	HRESULT				hr = S_OK;
	CCertMgrCookie*		pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( !pCookie )
		return E_UNEXPECTED;

	switch ( pCookie->m_objecttype )
	{
	case CERTMGR_CTL:
		{
			CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
			ASSERT (pCTL);
			if ( pCTL )
			{
				CCertStore& rStore = pCTL->GetCertStore ();
				CRYPTUI_WIZ_BUILDCTL_SRC_INFO	srcInfo;

				::ZeroMemory (&srcInfo, sizeof (srcInfo));
			   	srcInfo.dwSize = sizeof (srcInfo);
				srcInfo.pCTLContext = pCTL->GetCTLContext ();
				srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL;

				HWND	hwndParent = 0;
				hr = m_pConsole->GetMainWindow (&hwndParent);
				ASSERT (SUCCEEDED (hr));
				PCCTL_CONTEXT	pNewCTLContext = 0;
                CThemeContextActivator activator;
				BOOL	bResult = ::CryptUIWizBuildCTL (
						CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
						hwndParent,
						0,
						&srcInfo,
						NULL,
						&pNewCTLContext);
				ASSERT (bResult);
				if ( bResult && pNewCTLContext )
				{
					rStore.SetDirty ();
					// Delete old CTL and add the new one.
					if ( pCTL->DeleteFromStore () )
					{
						if ( !rStore.AddCTLContext (pNewCTLContext) )
						{
							DWORD	dwErr = GetLastError ();
							if ( CRYPT_E_EXISTS == dwErr )
							{
								CString	text;
								CString	caption;
								int		iRetVal = 0;


								VERIFY (text.LoadString (IDS_DUPLICATE_CTL));
								VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
								hr = m_pConsole->MessageBox (text, caption,
										MB_OK, &iRetVal);
								ASSERT (SUCCEEDED (hr));
								hr = E_FAIL;
							}
							else
							{
								DisplaySystemError (dwErr);
								hr = HRESULT_FROM_WIN32 (dwErr);
							}
						}
						rStore.Commit ();
						hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
						ASSERT (SUCCEEDED (hr));
					}
					else
					{
						DWORD	dwErr = GetLastError ();
						DisplaySystemError (dwErr);
						hr = HRESULT_FROM_WIN32 (dwErr);
					}
				}
			}
			else
				return E_UNEXPECTED;
		}
		break;

	default:
		ASSERT (0);
		return E_UNEXPECTED;
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::OnCTLEdit: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::OnAddDomainEncryptedDataRecoveryAgent (LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnAddDomainEncryptedDataRecoveryAgent\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
	{
		CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
		ASSERT (pStore && EFS_STORE == pStore->GetStoreType ());
		if ( pStore && EFS_STORE == pStore->GetStoreType () )
		{
			HWND	hwndConsole = 0;
			hr = m_pConsole->GetMainWindow (&hwndConsole);
			ASSERT (SUCCEEDED (hr));
			if ( SUCCEEDED (hr) )
			{
				CUsers			EFSUsers;
				CAddEFSWizSheet efsAddSheet (IDS_ADDTITLE, EFSUsers, m_bMachineIsStandAlone);

				if ( efsAddSheet.DoWizard (hwndConsole) )
				{
					pStore->SetDirty ();

					CString			szUserName;
					CString			szCertName;
					PUSERSONFILE	pUser = EFSUsers.StartEnum ();

					if ( pStore->IsNullEFSPolicy () )
					{
						pStore->AllowEmptyEFSPolicy ();						
						hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
						ASSERT (SUCCEEDED (hr));
					}

					// If the store is an empty store, we need to delete it before adding
					// the first cert.  Otherwise CertAddCertificateContextToStore () fails
					// with E_ACCESS_DENIED
					if ( 0 == pStore->GetCertCount () )
						pStore->DeleteEFSPolicy (false);

					while ( pUser )
					{
						hr = pStore->AddCertificateContext (
								pUser->m_pCertContext, m_pConsole, false);
						if ( SUCCEEDED (hr) )
						{
    						pStore->AddCertToList (pUser->m_pCertContext, pUser->m_UserSid);

                            hr = AddCertChainToPolicy (pUser->m_pCertContext);
							hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
							ASSERT (SUCCEEDED (hr));
						}
						else
							break;
						pUser = EFSUsers.GetNextUser (pUser, szUserName, szCertName);
					}
					pStore->Commit ();
					hr = DisplayCertificateCountByStore (m_pComponentConsole, pStore, true);
				}
			}
		}
		else
			hr = E_UNEXPECTED;
	}
	_TRACE (-1, L"Leaving CCertMgrComponentData::OnAddDomainEncryptedDataRecoveryAgent: 0x%x\n", hr);
	return hr;
}


// This code from Robert Reichel
/*++

Routine Description:

    This routine returns the TOKEN_USER structure for the
    current user, and optionally, the AuthenticationId from his
    token.

Arguments:

    AuthenticationId - Supplies an optional pointer to return the
        AuthenticationId.

Return Value:

    On success, returns a pointer to a TOKEN_USER structure.

    On failure, returns NULL.  Call GetLastError() for more
    detailed error information.

--*/

PTOKEN_USER EfspGetTokenUser ()
{
	_TRACE (1, L"Entering EfspGetTokenUser\n");
    HANDLE				hToken = 0;
    DWORD				dwReturnLength = 0;
    PTOKEN_USER			pTokenUser = NULL;

	BOOL	bResult = ::OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &hToken);
	if ( bResult )
	{
        bResult  = ::GetTokenInformation (
                     hToken,
                     TokenUser,
                     NULL,
                     0,
                     &dwReturnLength
                     );

        if ( !bResult && dwReturnLength > 0 )
		{
            pTokenUser = (PTOKEN_USER) malloc (dwReturnLength);

            if (pTokenUser)
			{
                bResult = GetTokenInformation (
                             hToken,
                             TokenUser,
                             pTokenUser,
                             dwReturnLength,
                             &dwReturnLength
                             );

                if ( !bResult)
				{
                    DWORD dwErr = GetLastError ();
					DisplaySystemError (NULL, dwErr);
                    free (pTokenUser);
                    pTokenUser = NULL;
                }
            }
        }
		else
		{
            DWORD dwErr = GetLastError ();
			DisplaySystemError (NULL, dwErr);
        }

        ::CloseHandle (hToken);
    }
	else
	{
		DWORD	dwErr = GetLastError ();
		DisplaySystemError (NULL, dwErr);
    }

	_TRACE (-1, L"Leaving EfspGetTokenUser\n");
    return pTokenUser;
}


HRESULT CCertMgrComponentData::CompleteEFSRecoveryAgent(CCertStoreGPE* pStore, PCCERT_CONTEXT pCertContext)
{
	_TRACE (1, L"Entering CCertMgrComponentData::CompleteEFSRecoveryAgent\n");
	HRESULT	hr = S_OK;
	ASSERT (pCertContext);
	if ( !pCertContext || !pStore )
		return E_POINTER;

	// This is using to Enroll to create a new EFS Recovery Agent.
	// Get PSID of logged-in user and save to store


	// If the store is an empty store, we need to delete it before adding
	// the first cert.  Otherwise CertAddCertificateContextToStore () fails
	// with E_ACCESS_DENIED
	if ( 0 == pStore->GetCertCount () )
		pStore->DeleteEFSPolicy (false);
	hr = pStore->AddCertificateContext (pCertContext, m_pConsole, false);
	if ( SUCCEEDED (hr) )
	{
		pStore->Commit ();

		PTOKEN_USER	pTokenUser = ::EfspGetTokenUser ();
		if ( pTokenUser )
		{
			pStore->AddCertToList (pCertContext, pTokenUser->User.Sid);
			free (pTokenUser);
		}

		if ( SUCCEEDED (hr) )
		{
			hr = AddCertChainToPolicy (pCertContext);
		}
	}
	else
	{
		int		iRetVal = 0;
		CString	text;
		CString	caption;

		text.FormatMessage (IDS_CANT_ADD_CERT, pStore->GetLocalizedName (), 
				GetSystemMessage (hr));
		VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));

		m_pConsole->MessageBox (text, caption,
			MB_OK | MB_ICONWARNING, &iRetVal);
	}


// Exportable keys are not currently supported. We can uncomment this code if this
// feature becomes available again in the future.
/*
	int		iRetVal = 0;
	CString	text;
	CString	caption;

	VERIFY (text.LoadString (IDS_EXPORT_AND_DELETE_EFS_KEY));
	VERIFY (caption.LoadString (IDS_CREATE_AUTO_CERT_REQUEST));

	hr = m_pConsole->MessageBox (text, caption,
		MB_YESNO | MB_ICONQUESTION, &iRetVal);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) && IDYES == iRetVal )
	{
		// Remove the private key from the cert.
		hr = CertSetCertificateContextProperty (pCertContext,
				CERT_KEY_PROV_INFO_PROP_ID, 0, 0);
		ASSERT (SUCCEEDED (hr));

 		// Bring up the common file open dialog to get a filename
		// and the standard password dialog to get a password so
		// that I can write out the PFX file.
		HWND	hwndConsole = 0;
		hr = m_pConsole->GetMainWindow (&hwndConsole);
		ASSERT (SUCCEEDED (hr));
		if ( SUCCEEDED (hr) )
		{
			CString	szFilter;
			VERIFY (szFilter.LoadString (IDS_SAVE_PFX_FILTER));

			CWnd	mainWindow;
			if ( mainWindow.Attach (hwndConsole) )
			{
				CFileDialog*	pFileDlg = new CFileDialog (FALSE,	// use as File Save As
						L"pfx",			// default extension
						NULL,				// preferred file name
						OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_CREATEPROMPT | OFN_NOREADONLYRETURN,
						(PCWSTR) szFilter,	
						&mainWindow);
				if ( pFileDlg )
				{
                    CThemeContextActivator activator;
					if ( IDOK == pFileDlg->DoModal () )
					{
						CString								pathName = pFileDlg->GetPathName ();
						CRYPTUI_WIZ_EXPORT_INFO				cwi;
						CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO	cci;

						::ZeroMemory (&cwi, sizeof (cwi));
						cwi.dwSize = sizeof (cwi);
						cwi.pwszExportFileName = (PCWSTR) pathName;
						cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
						cwi.pCertContext = pCertContext;

						::ZeroMemory (&cci, sizeof (cci));
						cci.dwSize = sizeof (cci);
						cci.dwExportFormat = CRYPTUI_WIZ_EXPORT_FORMAT_PFX;
						cci.fExportChain = TRUE;
						cci.fExportPrivateKeys = TRUE;

						CPassword	passwordDlg;


						// Launch password dialog
                        CThemeContextActivator activator;
						if ( IDOK == passwordDlg.DoModal () )
						{
							if ( !wcslen (passwordDlg.GetPassword ()) )
							{
								// If password string is empty, pass NULL.
								cci.pwszPassword = 0;
							}
							else
								cci.pwszPassword = passwordDlg.GetPassword ();

                            CThemeContextActivator activator;
							BOOL  bResult = ::CryptUIWizExport (
									CRYPTUI_WIZ_NO_UI,
									0,		// hwndParent ignored
									0,		// pwszWizardTitle ignored
									&cwi,
									(void*) &cci);
							if ( bResult )
							{
								hr = DeleteKeyFromRSABASE (pCertContext);
							}
							else
							{
								DWORD	dwErr = GetLastError ();
								DisplaySystemError (dwErr);
							}
						}
					}

					delete pFileDlg;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}

			}
			else
				ASSERT (0);
			VERIFY (mainWindow.Detach () == hwndConsole);
		}
	}
*/

	_TRACE (-1, L"Leaving CCertMgrComponentData::CompleteEFSRecoveryAgent: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddScopeNode(CCertMgrCookie * pNewCookie, const CString & strServerName, HSCOPEITEM hParent)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddScopeNode\n");
	ASSERT (pNewCookie);
	if ( !pNewCookie )
		return E_POINTER;

	HRESULT	hr = S_OK;


	SCOPEDATAITEM tSDItem;

	::ZeroMemory (&tSDItem,sizeof (tSDItem));
	tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
	tSDItem.displayname = MMC_CALLBACK;
	tSDItem.relativeID = hParent;
	tSDItem.nState = 0;

    switch (pNewCookie->m_objecttype)
    {
    case CERTMGR_USAGE:
    case CERTMGR_CRL_CONTAINER:
    case CERTMGR_CTL_CONTAINER:
    case CERTMGR_CERT_CONTAINER:
    case CERTMGR_LOG_STORE_GPE:
    case CERTMGR_LOG_STORE_RSOP:
    case CERTMGR_SAFER_COMPUTER_LEVELS:
    case CERTMGR_SAFER_USER_LEVELS:
    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
        tSDItem.mask |= SDI_CHILDREN;
        tSDItem.cChildren = 0;
        break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        ASSERT (0);
        break;

    default:
        break;
    }
	if ( pNewCookie != m_pRootCookie && m_pRootCookie )
		m_pRootCookie->m_listScopeCookieBlocks.AddHead ( (CBaseCookieBlock*) pNewCookie);
	if ( !strServerName.IsEmpty () )
		pNewCookie->m_strMachineName = strServerName;
	tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
	tSDItem.nImage = QueryImage (*pNewCookie, FALSE);
	hr = m_pConsoleNameSpace->InsertItem (&tSDItem);
	if ( SUCCEEDED (hr) )
		pNewCookie->m_hScopeItem = tSDItem.ID;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddScopeNode: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::DeleteKeyFromRSABASE(PCCERT_CONTEXT pCertContext)
{
	_TRACE (1, L"Entering CCertMgrComponentData::DeleteKeyFromRSABASE\n");
	ASSERT (pCertContext);
	if ( !pCertContext )
		return E_POINTER;
	HRESULT	hr = S_OK;
	DWORD	cbData = 0;

	BOOL bResult = ::CertGetCertificateContextProperty (pCertContext,
			CERT_KEY_PROV_INFO_PROP_ID,	0, &cbData);
	ASSERT (bResult);
	if ( bResult )
	{
		PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::LocalAlloc (LPTR, cbData);
		if ( pKeyProvInfo )
		{
			bResult = ::CertGetCertificateContextProperty (pCertContext,
					CERT_KEY_PROV_INFO_PROP_ID,	pKeyProvInfo, &cbData);
			ASSERT (bResult);
			if ( bResult )
			{
				HCRYPTPROV	hProv = 0;
				bResult = ::CryptAcquireContext (&hProv,
						pKeyProvInfo->pwszContainerName,
						pKeyProvInfo->pwszProvName,
						pKeyProvInfo->dwProvType,
						CRYPT_DELETEKEYSET);
				ASSERT (bResult);
				if ( !bResult )
				{
					DWORD	dwErr = GetLastError ();
					hr = HRESULT_FROM_WIN32 (dwErr);
					DisplaySystemError (dwErr);
				}
			}
			else
			{
				DWORD	dwErr = GetLastError ();
				hr = HRESULT_FROM_WIN32 (dwErr);
				DisplaySystemError (dwErr);
			}

			::LocalFree (pKeyProvInfo);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		DWORD	dwErr = GetLastError ();
		hr = HRESULT_FROM_WIN32 (dwErr);
		DisplaySystemError (dwErr);
	}


	_TRACE (-1, L"Leaving CCertMgrComponentData::DeleteKeyFromRSABASE: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::ReleaseResultCookie (
		CBaseCookieBlock *	pResultCookie,
		CCookie&			rootCookie,
		HCERTSTORE			hStoreHandle,
		POSITION			pos2)
{
//	_TRACE (1, L"Entering CCertMgrComponentData::ReleaseResultCookie\n");
	CCertMgrCookie* pCookie = reinterpret_cast <CCertMgrCookie*> (pResultCookie);
	ASSERT (pCookie);
	if ( pCookie )
	{
		switch (pCookie->m_objecttype)
		{
		case CERTMGR_CERTIFICATE:
			{
				CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
				ASSERT (pCert);
				if ( pCert && pCert->GetCertStore () )
				{
					if ( pCert->GetCertStore ()->GetStoreHandle () == hStoreHandle )
					{
						// pCookie and pCert point to the same object
						pResultCookie = rootCookie.m_listResultCookieBlocks.GetAt (pos2);
						ASSERT (pResultCookie);
						rootCookie.m_listResultCookieBlocks.RemoveAt (pos2);
						if ( pResultCookie )
						{
							pResultCookie->Release ();
						}
					}
					pCert->GetCertStore ()->Close ();
				}
			}
			break;

		case CERTMGR_CTL:
		case CERTMGR_AUTO_CERT_REQUEST:
			{
				CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
				ASSERT (pCTL);
				if ( pCTL )
				{
					if ( pCTL->GetCertStore ().GetStoreHandle () == hStoreHandle )
					{
						// pCookie and pCert point to the same object
						pResultCookie = rootCookie.m_listResultCookieBlocks.GetAt (pos2);
						ASSERT (pResultCookie);
						rootCookie.m_listResultCookieBlocks.RemoveAt (pos2);
						if ( pResultCookie )
						{
							pResultCookie->Release ();
						}
					}
					pCTL->GetCertStore ().Close ();
				}
			}
			break;

		case CERTMGR_CRL:
			{
				CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
				ASSERT (pCRL);
				if ( pCRL )
				{
					if ( pCRL->GetCertStore ().GetStoreHandle () == hStoreHandle )
					{
						// pCookie and pCert point to the same object
						pResultCookie = rootCookie.m_listResultCookieBlocks.GetAt (pos2);
						ASSERT (pResultCookie);
						rootCookie.m_listResultCookieBlocks.RemoveAt (pos2);
						if ( pResultCookie )
						{
							pResultCookie->Release ();
						}
					}
					pCRL->GetCertStore ().Close ();
				}
			}
			break;

		default:
//			_TRACE (0, L"CCertMgrComponentData::ReleaseResultCookie () - bad cookie type: 0x%x\n", 
//                    pCookie->m_objecttype); 
			break;
		}
	}

//	_TRACE (-1, L"Leaving CCertMgrComponentData::ReleaseResultCookie: S_OK\n");
	return S_OK;
}

void CCertMgrComponentData::SetResultData(LPRESULTDATA pResultData)
{
	_TRACE (1, L"Entering CCertMgrComponentData::SetResultData\n");
	ASSERT (pResultData);
	if ( pResultData && !m_pResultData )
	{
		m_pResultData = pResultData;
		m_pResultData->AddRef ();
	}
	_TRACE (-1, L"Leaving CCertMgrComponentData::SetResultData\n");
}

HRESULT CCertMgrComponentData::GetResultData(LPRESULTDATA* ppResultData)
{
	HRESULT	hr = S_OK;

	if ( !ppResultData )
		hr = E_POINTER;
	else if ( !m_pResultData )
    {
        if ( m_pConsole )
        {
            hr = m_pConsole->QueryInterface(IID_PPV_ARG (IResultData, &m_pResultData));
            _ASSERT (SUCCEEDED (hr));
        }
        else
            hr = E_FAIL;
    }
	
    if ( SUCCEEDED (hr) && m_pResultData )
	{
		*ppResultData = m_pResultData;
		m_pResultData->AddRef ();
	}

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
// Check to see if a child scope pane object exists of the desired type
// immediately below hParent
//
///////////////////////////////////////////////////////////////////////////////
bool CCertMgrComponentData::ContainerExists(HSCOPEITEM hParent, CertificateManagerObjectType objectType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::ContainerExists\n");
	bool			bExists = false;
	CCertMgrCookie*	pCookie = 0;
	HSCOPEITEM		hChild = 0;
	MMC_COOKIE		lCookie = 0;
	HRESULT			hr = m_pConsoleNameSpace->GetChildItem (hParent,
			&hChild, &lCookie);
	ASSERT (SUCCEEDED (hr));
	while ( SUCCEEDED (hr) && hChild )
	{
		pCookie = reinterpret_cast <CCertMgrCookie*> (lCookie);
		ASSERT (pCookie);
		if ( pCookie )
		{
			if ( pCookie->m_objecttype == objectType )
			{
				bExists = true;
				break;
			}
		}
		hr = m_pConsoleNameSpace->GetNextItem (hChild, &hChild, &lCookie);
		ASSERT (SUCCEEDED (hr));
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::ContainerExists\n");
	return bExists;
}


void CCertMgrComponentData::DisplayAccessDenied ()
{
	_TRACE (1, L"Entering CCertMgrComponentData::DisplayAccessDenied\n");
	DWORD	dwErr = GetLastError ();
	ASSERT (E_ACCESSDENIED == dwErr);
	if ( E_ACCESSDENIED == dwErr )
	{
		LPVOID lpMsgBuf;
			
		FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				NULL,
				GetLastError (),
				MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				 (PWSTR) &lpMsgBuf,    0,    NULL );
			
		// Display the string.
		CString	caption;
		VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		int		iRetVal = 0;
		VERIFY (SUCCEEDED (m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
			MB_ICONWARNING | MB_OK, &iRetVal)));

		// Free the buffer.
		LocalFree (lpMsgBuf);
	}
	_TRACE (-1, L"Leaving CCertMgrComponentData::DisplayAccessDenied\n");
}


HRESULT CCertMgrComponentData::DeleteCTLFromResultPane (CCTL * pCTL, LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::DeleteCTLFromResultPane\n");
	ASSERT (pCTL);
	ASSERT (pDataObject);
	if ( !pCTL || !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	if ( pCTL->DeleteFromStore () )
	{
		hr = pCTL->GetCertStore ().Commit ();
		ASSERT (SUCCEEDED (hr));
		if ( SUCCEEDED (hr) )
		{
			HRESULTITEM	itemID  = 0;
			hr = m_pResultData->FindItemByLParam ( (LPARAM) pCTL, &itemID);
			if ( SUCCEEDED (hr) )
			{
				hr = m_pResultData->DeleteItem (itemID, 0);
				ASSERT (SUCCEEDED (hr));
			}
		
			// If we can't succeed in removing this one item, then update the whole panel.
			if ( !SUCCEEDED (hr) )
			{
				hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
			}
		}
	}
	else
	{
		DisplayAccessDenied ();
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::DeleteCTLFromResultPane: 0x%x\n", hr);
	return hr;
}


/*
HRESULT CCertMgrComponentData::OnSetAsRecoveryCert(LPDATAOBJECT pDataObject)
{
	HRESULT	hr = S_OK;

	CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
	if ( pParentCookie && CERTMGR_CERTIFICATE == pParentCookie->m_objecttype )
	{
		CCertificate* pCert = reinterpret_cast <CCertificate*> (pParentCookie);
		ASSERT (pCert);
		if ( pCert )
		{
			PTOKEN_USER	pTokenUser = ::EfspGetTokenUser ();
			if ( pTokenUser )
			{
				ASSERT (::CertHasEFSKeyUsage (pCert->GetCertContext ()));
				PCCERT_CONTEXT			pCertContext = pCert->GetCertContext ();

				EFS_CERTIFICATE_BLOB	efsCertBlob;
				::ZeroMemory (&efsCertBlob, sizeof (efsCertBlob));
				efsCertBlob.dwCertEncodingType = pCertContext->dwCertEncodingType;
				efsCertBlob.cbData = pCertContext->cbCertEncoded;
				efsCertBlob.pbData = pCertContext->pbCertEncoded;

				ENCRYPTION_CERTIFICATE encryptionCert;
				::ZeroMemory (&encryptionCert, sizeof (encryptionCert));
				encryptionCert.cbTotalLength = sizeof (encryptionCert);
				encryptionCert.pUserSid = (SID*) pTokenUser->User.Sid;
				encryptionCert.pCertBlob = &efsCertBlob;


				DWORD	dwResult = ::SetUserFileEncryptionKey (&encryptionCert);
				if ( dwResult )
				{
					// The most likely error here is that the user doesn't have the
					// private key of this certificate.  In that case, put up a special
					// message box to that effect.
					// TODO: Get the return code from RobertRe for this case.  As of
					// 3/4/98 he doesn't yet know what it is.
					DisplaySystemError (dwResult);
				}
			}
			else
				hr = E_FAIL;
		}
		else
			hr = E_UNEXPECTED;
	}
	else
		hr = E_UNEXPECTED;

	return hr;
}
*/

CString CCertMgrComponentData::GetThisComputer() const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::GetThisComputer\n");
	return m_szThisComputer;
}

typedef struct _ENUM_LOG_ARG {
    DWORD							m_dwFlags;
	CTypedPtrList<CPtrList, CCertStore*>* m_pStoreList;
	PCWSTR							m_pcszMachineName;
	CCertMgrComponentData*			m_pCompData;
	LPCONSOLE						m_pConsole;
} ENUM_LOG_ARG, *PENUM_LOG_ARG;



static BOOL WINAPI EnumLogCallback (
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
	_TRACE (1, L"Entering EnumLogCallback\n");
	BOOL			bResult = TRUE;
    PENUM_LOG_ARG	pEnumArg = (PENUM_LOG_ARG) pvArg;

	// Create new cookies
	SPECIAL_STORE_TYPE	storeType = GetSpecialStoreType ((PWSTR) pwszSystemStore);

	//
	// We will not expose the ACRS store for machines or users.  It is not
	// interesting or useful at this level.  All Auto Cert Requests should
	// be managed only at the policy level.
	//
	if ( ACRS_STORE != storeType )
	{
		if ( pEnumArg->m_pCompData->ShowArchivedCerts () )
			dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
		CCertStore* pStore = new CCertStore (
				CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				dwFlags,
				pEnumArg->m_pcszMachineName,
				(PCWSTR) pwszSystemStore,
				(PCWSTR) pwszSystemStore,
				_T (""), storeType,
				pEnumArg->m_dwFlags,
				pEnumArg->m_pConsole);
		if ( pStore )
		{
			pEnumArg->m_pStoreList->AddTail (pStore);
		}
	}

	_TRACE (-1, L"Leaving EnumLogCallback\n");
    return bResult;
}


HRESULT CCertMgrComponentData::EnumerateLogicalStores (CTypedPtrList<CPtrList, CCertStore*>*	pStoreList)
{
	_TRACE (1, L"Entering CCertMgrComponentData::EnumerateLogicalStores\n");
	CWaitCursor				cursor;
	HRESULT					hr = S_OK;
    ENUM_LOG_ARG			enumArg;
    DWORD					dwFlags = GetLocation ();

     ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = dwFlags;
	enumArg.m_pStoreList = pStoreList;
	enumArg.m_pcszMachineName =
			QueryRootCookie ().QueryNonNULLMachineName ();
	enumArg.m_pCompData = this;
	enumArg.m_pConsole = m_pConsole;
	CString	location;
	void*	pvPara = 0;

	

	if ( !GetManagedService ().IsEmpty () )
	{
		if ( !GetManagedComputer ().IsEmpty () )
		{
			location = GetManagedComputer () + _T("\\") +
					GetManagedComputer ();
			pvPara = (void *) (PCWSTR) location;
		}
		else
			pvPara = (void *) (PCWSTR) GetManagedService ();
	}
	else if ( !GetManagedComputer ().IsEmpty () )
	{
		pvPara = (void *) (PCWSTR) GetManagedComputer ();
	}

	CString	fileName = GetCommandLineFileName ();
	if ( fileName.IsEmpty () )
	{
		// Ensure creation of MY store
		HCERTSTORE hTempStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				NULL,
				dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
				MY_SYSTEM_STORE_NAME);
		if ( hTempStore )  // otherwise, store is read only
		{
			VERIFY (::CertCloseStore (hTempStore, CERT_CLOSE_STORE_CHECK_FLAG));
		}
		else
		{
			_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
						MY_SYSTEM_STORE_NAME, GetLastError ());		
		}

		if ( !::CertEnumSystemStore (dwFlags, pvPara, &enumArg, EnumLogCallback) )
		{
			DWORD	dwErr = GetLastError ();
			CString text;
			CString	caption;

			VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			if ( ERROR_ACCESS_DENIED == dwErr )
			{
				VERIFY (text.LoadString (IDS_NO_PERMISSION));

			}
			else
			{
				text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
			}
			int		iRetVal = 0;
			VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
					MB_OK, &iRetVal)));
			hr = HRESULT_FROM_WIN32 (dwErr);
			hr = HRESULT_FROM_WIN32 (dwErr);
		}
	}
	else
	{
		// Create new cookies
		dwFlags = 0;

		// If there is a class file-based store, use that, otherwise allocate
		// a new one.
		CCertStore* pStore = m_pFileBasedStore;
		if ( !pStore )
			pStore = new CCertStore (
				CERTMGR_LOG_STORE,
				CERT_STORE_PROV_FILENAME_W,
				dwFlags,
				QueryRootCookie ().QueryNonNULLMachineName (),
				fileName, fileName, _T (""), NO_SPECIAL_TYPE,
				m_dwLocationPersist,
				m_pConsole);
		else
			pStore->AddRef ();
		if ( pStore )
		{
			pStoreList->AddTail (pStore);
		}
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::EnumerateLogicalStores: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnNotifyPreload(
        LPDATAOBJECT /*lpDataObject*/, 
        HSCOPEITEM hRootScopeItem)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnNotifyPreload\n");
	ASSERT (m_fAllowOverrideMachineName);
	HRESULT	hr = S_OK;

    QueryBaseRootCookie ().m_hScopeItem = hRootScopeItem;

	// The machine name will be changed only if the stores are machine-based
	// stores.
	if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist )
	{
		
		CString		machineName = QueryRootCookie ().QueryNonNULLMachineName();

		hr = ChangeRootNodeName (machineName);
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnNotifyPreload: 0x%x\n", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//	ChangeRootNodeName ()
//
//  Purpose:	Change the text of the root node
//
//	Input:		newName - the new machine name that the snapin manages
//  Output:		Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertMgrComponentData::ChangeRootNodeName(const CString & newName)
{
	_TRACE (1, L"Entering CCertMgrComponentData::ChangeRootNodeName\n");

    if ( !QueryBaseRootCookie ().m_hScopeItem )
    {
        if ( m_hRootScopeItem )
            QueryBaseRootCookie ().m_hScopeItem = m_hRootScopeItem;
        else
		    return E_UNEXPECTED;
    }

	CString		formattedName;

    switch (m_dwLocationPersist)
	{
    case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        {
       	    CString		machineName (newName);

	        // If machineName is empty, then this manages the local machine.  Get
	        // the local machine name.  Then format the computer name with the snapin
	        // name
	        if ( IsLocalComputername (machineName) )
	        {
		        formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_LOCAL_MACHINE);
                m_szManagedComputer = L"";
	        }
	        else
	        {
		        machineName.MakeUpper ();
		        formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_MACHINE, machineName);
                m_szManagedComputer = machineName;
	        }
        }
        break;

	case CERT_SYSTEM_STORE_CURRENT_SERVICE:
	case CERT_SYSTEM_STORE_SERVICES:
        {
       	    CString		machineName (newName);

	        // If machineName is empty, then this manages the local machine.  Get
	        // the local machine name.  Then format the computer name with the snapin
	        // name
	        if ( IsLocalComputername (machineName) )
		    {
			    // Get this machine name and add it to the string.
			    formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE_LOCAL_MACHINE,
					    m_szManagedServiceDisplayName);
                m_szManagedComputer = L"";
		    }
		    else
		    {
			    formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE,
					    m_szManagedServiceDisplayName, machineName);
                m_szManagedComputer = machineName;
		    }
        }
		break;

    case CERT_SYSTEM_STORE_CURRENT_USER:
        VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_USER));
        break;

    default:
        return S_OK;
    }


	SCOPEDATAITEM	item;
	::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
	item.mask = SDI_STR;
	item.displayname = (PWSTR) (PCWSTR) formattedName;
	item.ID = QueryBaseRootCookie ().m_hScopeItem;

	HRESULT	hr = m_pConsoleNameSpace->SetItem (&item);
    if ( FAILED (hr) )
    {
        _TRACE (0, L"IConsoleNameSpace2::SetItem () failed: 0x%x\n", hr);        
    }
	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::ChangeRootNodeName: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::CreateContainers(
            HSCOPEITEM hScopeItem, 
            CCertStore& rTargetStore)
{
	_TRACE (1, L"Entering CCertMgrComponentData::CreateContainers\n");
	HRESULT	hr = S_OK;

	// If the container was a cert store and it does not
	// already have Certs/CRLs/CTLs, instantiate a new CRL container
	// in the scope pane.
	if ( -1 != hScopeItem )
	{
		SCOPEDATAITEM item;

		::ZeroMemory (&item, sizeof (item));
		item.mask = SDI_STATE;
		item.nState = 0;
		item.ID = hScopeItem;

		hr = m_pConsoleNameSpace->SetItem (&item);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"IConsoleNameSpace2::SetItem () failed: 0x%x\n", hr);        
        }
		if ( CERTMGR_LOG_STORE_GPE != rTargetStore.m_objecttype && 
                CERTMGR_LOG_STORE_RSOP != rTargetStore.m_objecttype)
		{
			AddContainersToScopePane (hScopeItem,
					rTargetStore, true);
		}
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::CreateContainers: 0x%x\n", hr);
	return hr;
}



HRESULT CCertMgrComponentData::OnOptions(LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnOptions\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HWND		hParent = 0;


	// Get parent window handle and attach to a CWnd object
	HRESULT	hr = m_pConsole->GetMainWindow (&hParent);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
		int				activeView = m_activeViewPersist;
		BOOL			bShowPhysicalStores = m_bShowPhysicalStoresPersist;
		BOOL			bShowArchivedCerts = m_bShowArchivedCertsPersist;
		CWnd			parentWnd;
		VERIFY (parentWnd.Attach (hParent));
		CViewOptionsDlg	optionsDlg (&parentWnd,
				this);

        CThemeContextActivator activator;
		INT_PTR	iReturn = optionsDlg.DoModal ();
		ASSERT (-1 != iReturn);
		if ( -1 == iReturn )
			hr = (HRESULT)iReturn;

		if ( IDOK == iReturn )
		{
			long	hint = 0;

			if ( activeView != m_activeViewPersist )
			{
				hint |= HINT_CHANGE_VIEW_TYPE;
				if ( IDM_USAGE_VIEW == m_activeViewPersist )
				{
					// view by usage
					ASSERT (m_pHeader);
					if ( m_pHeader && GetObjectType (pDataObject) == CERTMGR_SNAPIN )
					{
						CString	str;
						VERIFY (str.LoadString (IDS_COLUMN_PURPOSE) );
						hr = m_pHeader->SetColumnText (0,
								const_cast<PWSTR> ( (PCWSTR) str));
					}
				}
				else
				{
					// View by stores
					ASSERT (m_pHeader);
					if ( m_pHeader && GetObjectType (pDataObject) == CERTMGR_SNAPIN )
					{
						CString	str;
						VERIFY (str.LoadString (IDS_COLUMN_LOG_CERTIFICATE_STORE));
						hr = m_pHeader->SetColumnText (0,
								const_cast<PWSTR> ( (PCWSTR) str));
					}
				}
			}

			if ( bShowPhysicalStores != m_bShowPhysicalStoresPersist )
				hint |= HINT_CHANGE_STORE_TYPE;
			
			if ( bShowArchivedCerts != m_bShowArchivedCertsPersist )
				hint |= HINT_SHOW_ARCHIVE_CERTS;

			if ( hint )
			{
				hr = m_pConsole->UpdateAllViews (pDataObject, 0, hint);
				ASSERT (SUCCEEDED (hr));
				m_fDirty = TRUE;
			}
		}
		parentWnd.Detach ();
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnOptions: 0x%x\n", hr);
	return hr;
}

bool CCertMgrComponentData::ShowArchivedCerts() const
{
	_TRACE (0, L"Entering and leaving CCertMgrComponentData::ShowArchivedCerts\n");
	if ( m_bShowArchivedCertsPersist )
		return true;
	else
		return false;
}


HRESULT CCertMgrComponentData::OnPropertyChange (LPARAM param)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnPropertyChange\n");
	ASSERT (param);
	if ( !param )
		return E_FAIL;
		
	HRESULT			hr = S_OK;
	LPDATAOBJECT	pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
    bool            bHandled = false;

    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            {
		        HRESULTITEM	itemID = 0;

		        if ( m_pResultData )
		        {
			        pCookie->Refresh ();
			        hr = m_pResultData->FindItemByLParam ( (LPARAM) pCookie, &itemID);
			        if ( SUCCEEDED (hr) )
			        {
				        hr = m_pResultData->UpdateItem (itemID);
				        if ( FAILED (hr) )
				        {
					        _TRACE (0, L"IResultData::UpdateItem () failed: 0x%x\n", hr);          
				        }
			        }
			        else
			        {
				        _TRACE (0, L"IResultData::FindItemByLParam () failed: 0x%x\n", hr);          
			        }
		        }
		        else
		        {
			        _TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
			        hr = E_FAIL;
		        }
                bHandled = true;
            }
            break;

        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
            if ( m_pConsole )
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
            break;

        default:
            break;
        }
    }

	if ( !bHandled && m_pCryptUIMMCCallbackStruct )
	{

		if ( pDataObject == reinterpret_cast<LPDATAOBJECT>(m_pCryptUIMMCCallbackStruct->param) )
		{
			::MMCFreeNotifyHandle (m_pCryptUIMMCCallbackStruct->lNotifyHandle);
			pCookie = ConvertCookie (pDataObject);
			if ( pCookie )
			{
				ASSERT (CERTMGR_CERTIFICATE == pCookie->m_objecttype);
				if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
				{
					CCertificate* pCert = reinterpret_cast<CCertificate*>(pCookie);
					ASSERT (pCert);
					if ( pCert && pCert->GetCertStore () )
					{
						pCert->GetCertStore ()->SetDirty ();
						pCert->GetCertStore ()->Commit ();
						pCert->GetCertStore ()->Close ();
					}
				}
			}
			
			pDataObject->Release ();
			::GlobalFree (m_pCryptUIMMCCallbackStruct);
			m_pCryptUIMMCCallbackStruct = 0;
			m_pConsole->UpdateAllViews (pDataObject, 0, 0);
		}
	}
	

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnPropertyChange: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnDeleteEFSPolicy(LPDATAOBJECT pDataObject, bool bCommitChanges)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnDeleteEFSPolicy\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
	{
		CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
		ASSERT (pStore && EFS_STORE == pStore->GetStoreType () && !pStore->IsNullEFSPolicy () );
		if ( pStore && EFS_STORE == pStore->GetStoreType () && !pStore->IsNullEFSPolicy ()  )
		{
			pStore->DeleteEFSPolicy (bCommitChanges);
			hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
		}
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnDeleteEFSPolicy: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::OnInitEFSPolicy(LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::OnInitEFSPolicy\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pDataObject);
	if ( !pDataObject )
		return E_POINTER;

	HRESULT			hr = S_OK;
	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
	{
		CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
		ASSERT (pStore && EFS_STORE == pStore->GetStoreType () && pStore->IsNullEFSPolicy () );
		if ( pStore && EFS_STORE == pStore->GetStoreType () && pStore->IsNullEFSPolicy () )
		{
			pStore->SetDirty ();
			pStore->AllowEmptyEFSPolicy ();
			pStore->PolicyChanged ();
            pStore->Commit ();
			hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
		}
	}

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnInitEFSPolicy: 0x%x\n", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CCertMgrComponentData::RemoveResultCookies
//
// Remove and delete all the result cookies corresponding to the LPRESULTDATA
// object passed in.  Thus all cookies added to pResultData are released and
// removed from the master list.
//
///////////////////////////////////////////////////////////////////////////////
void CCertMgrComponentData::RemoveResultCookies(LPRESULTDATA pResultData)
{
	_TRACE (1, L"Entering CCertMgrComponentData::RemoveResultCookies\n");
	CCertMgrCookie*	pCookie = 0;

	CCookie& rootCookie = QueryBaseRootCookie ();

	POSITION		curPos = 0;

	for (POSITION nextPos = rootCookie.m_listResultCookieBlocks.GetHeadPosition (); nextPos; )
	{
		curPos = nextPos;
		pCookie = reinterpret_cast <CCertMgrCookie*> (rootCookie.m_listResultCookieBlocks.GetNext (nextPos));
		ASSERT (pCookie);
		if ( pCookie )
		{
			if ( pCookie->m_resultDataID == pResultData )
			{
				pCookie->Release ();
				rootCookie.m_listResultCookieBlocks.RemoveAt (curPos);
			}
		}
	}
	_TRACE (-1, L"Leaving CCertMgrComponentData::RemoveResultCookies\n");
}


HRESULT CCertMgrComponentData::AddCertChainToPolicy(PCCERT_CONTEXT pCertContext)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCertChainToPolicy\n");
    HRESULT hr = S_OK;
    ASSERT (pCertContext);
    if ( !pCertContext )
        return E_POINTER;

    CERT_CHAIN_PARA         certChainPara;
    ::ZeroMemory (&certChainPara, sizeof (CERT_CHAIN_PARA));
    certChainPara.cbSize = sizeof (CERT_CHAIN_PARA);
	certChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
	certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = new LPSTR[1];
	if ( !certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier )
		return E_OUTOFMEMORY;
	certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;

    PCCERT_CHAIN_CONTEXT    pChainContext = 0;
    BOOL	bValidated = ::CertGetCertificateChain (
            HCCE_LOCAL_MACHINE,             // HCERTCHAINENGINE hChainEngine,
            pCertContext,
            0,                              // LPFILETIME pTime,
            0,                              // HCERTSTORE hAdditionalStore,
            &certChainPara,
            0,                              // dwFlags,
            0,                              // pvReserved,
            &pChainContext);
    if ( bValidated )
    {
        // NTRAID# 310388	CRYPTUI: Chain validation failing for self-signed certificates
	    // Check to see if cert is self-signed
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[pChainContext->cChain - 1];
        if ( pChain )
        {
            PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[pChain->cElement - 1];
            if ( pElement )
            {
                BOOL bSelfSigned = pElement->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED;

                DWORD dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;

                bValidated = ((0 == dwErrorStatus) || 
                    (dwErrorStatus == CERT_TRUST_IS_UNTRUSTED_ROOT) && bSelfSigned);
                if ( bValidated )
                {
// NTRAID# 301213 EFS Recovery Agent Import: 
// Should not import the whole chain by default
/*

                    CString         objectName;
                    CCertStoreGPE   CAStore (
							            CERT_SYSTEM_STORE_RELOCATE_FLAG,
							            _T (""),
							            _T (""),
							            CA_SYSTEM_STORE_NAME,
							            _T (""),
							            m_pGPEInformation,
							            NODEID_Machine,
							            m_pConsole);
                    CCertStoreGPE*	pRootStore = dynamic_cast <CCertStoreGPE*> (m_pGPERootStore);
                    if ( !pRootStore )
                    {
	                    VERIFY (objectName.LoadString (IDS_DOMAIN_ROOT_CERT_AUTHS_NODE_NAME));
                        pRootStore = new CCertStoreGPE (CERT_SYSTEM_STORE_RELOCATE_FLAG,
		                        _T (""),
					             (PCWSTR) objectName,
					            ROOT_SYSTEM_STORE_NAME,
					            _T (""),
					            m_pGPEInformation,
					            NODEID_Machine,
					            m_pConsole);
                        if ( !pRootStore )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    CCertStoreGPE*	pTrustStore = dynamic_cast<CCertStoreGPE*> (m_pGPETrustStore);
                    if ( !pTrustStore )
                    {
	                    VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LISTS));
                        pTrustStore = new CCertStoreGPE (CERT_SYSTEM_STORE_RELOCATE_FLAG,
		                        _T (""),
					             (PCWSTR) objectName,
					            TRUST_SYSTEM_STORE_NAME,
					            _T (""),
					            m_pGPEInformation,
					            NODEID_Machine,
					            m_pConsole);
                        if ( !pTrustStore )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

	                //
	                // Copy all certs from all simple chains to the CA store, except the
		            // last cert on the last chain: copy that to the root store.
		            // If any CTLs are found, copy those to the trust store.
	                //
                    for (DWORD dwIndex = 0; dwIndex < pChainContext->cChain; dwIndex++)
	                {
		                DWORD i = 0;
			            if ( pChainContext->rgpChain[dwIndex]->pTrustListInfo )
			            {
				            // Add to Trust Store
				            if ( pChainContext->rgpChain[dwIndex]->pTrustListInfo->pCtlContext )
				            {
                                pTrustStore->AddCTLContext(
					                    pChainContext->rgpChain[dwIndex]->pTrustListInfo->pCtlContext);
				            }
			            }
		                while (i < pChainContext->rgpChain[dwIndex]->cElement)
		                {
			                //
			                // If we are on the root cert, then add to the root store,
                            // otherwise, add to the CA store
			                //
				            // The last element is the self-signed cert if
				            // CERT_TRUST_NO_ERROR was returned
			                if ( (dwIndex == pChainContext->cChain - 1) &&
						            (i == pChainContext->rgpChain[dwIndex]->cElement - 1) )
			                {
                                pRootStore->AddCertificateContext(
					                    pChainContext->rgpChain[dwIndex]->rgpElement[i]->pCertContext,
					                    0, false);
			                }
                            else
                            {
                                CAStore.AddCertificateContext(
					                    pChainContext->rgpChain[dwIndex]->rgpElement[i]->pCertContext,
					                    0, false);
                            }

			                i++;
		                }
	                }

		            pRootStore->Commit ();
		            pTrustStore->Commit ();
		            CAStore.Commit ();

		pRootStore->Commit ();
		pTrustStore->Commit ();
		CAStore.Commit ();
        ::CertFreeCertificateChain(pCertChainContext);
        pCertChainContext = 0;

                    if ( pRootStore && !m_pGPERootStore )
                        pRootStore->Release ();
                    if ( pTrustStore && !m_pGPETrustStore )
                        pTrustStore->Release ();
*/
                    ::CertFreeCertificateChain(pChainContext);
                    pChainContext = 0;
                }
            }
            else
                bValidated = FALSE;
        }
        else
            bValidated = FALSE;
    }
	else
		bValidated = FALSE;

	if ( pChainContext )
       ::CertFreeCertificateChain(pChainContext);

    if ( !bValidated )
    {
	    int		iRetVal = 0;
	    CString	text;
	    CString	caption;

	    VERIFY (text.LoadString (IDS_CERT_COULD_NOT_BE_VALIDATED));
	    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));

	    hr = m_pConsole->MessageBox (text, caption,
		    MB_OK, &iRetVal);
    }

	delete [] certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier;

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::AddCertChainToPolicy: 0x%x\n", hr);
    return hr;
}


STDMETHODIMP CCertMgrComponentData::GetLinkedTopics(LPOLESTR* lpCompiledHelpFiles)
{
    HRESULT hr = S_OK;


    if ( lpCompiledHelpFiles )
    {
        CString strLinkedTopic;

        UINT nLen = ::GetSystemWindowsDirectory (strLinkedTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strLinkedTopic.ReleaseBuffer();
        if ( nLen )
        {
            strLinkedTopic += L"\\help\\";
            strLinkedTopic += m_strLinkedHelpFile;

            *lpCompiledHelpFiles = reinterpret_cast<LPOLESTR>
                    (CoTaskMemAlloc((strLinkedTopic.GetLength() + 1)* sizeof(wchar_t)));

            if ( *lpCompiledHelpFiles )
            {
                wcscpy(*lpCompiledHelpFiles, (PWSTR)(PCWSTR)strLinkedTopic);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }
    else
        return E_POINTER;


    return hr;
}

STDMETHODIMP CCertMgrComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
    return CComponentData::GetHelpTopic (lpCompiledHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\componentdatamenus.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ComponentDataMenus.cpp
//
//  Contents:   Implementation of menu stuff CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTMGR (compdata.cpp)")
#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "Certifct.h"


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertMgrComponentData::AddMenuItems (LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
	HRESULT	hr = S_OK;

	// Don't add any menu items if the computer is known not to be valid.
	if ( !m_fInvalidComputer )
	{
		_TRACE (1, L"Entering CCertMgrComponentData::AddMenuItems\n");
		BOOL							bIsFileView = !m_szFileName.IsEmpty ();
		CCertMgrCookie*					pCookie = 0;

		LPDATAOBJECT	pMSDO = ExtractMultiSelect (pDataObject);
		m_bMultipleObjectsSelected = false;

		if ( pMSDO )
		{
			m_bMultipleObjectsSelected = true;

			CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
			ASSERT (pDO);
			if ( pDO )
			{
				// Get first cookie - all items should be the same?
				// Is this a valid assumption?
				// TODO: Verify
				pDO->Reset();
				if ( pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) == S_FALSE )
					return S_FALSE;
			}
			else
				return E_UNEXPECTED;

		}
		else
			pCookie = ConvertCookie (pDataObject);
		ASSERT (pCookie);
		if ( !pCookie )
			return E_UNEXPECTED;

		CertificateManagerObjectType	objType = pCookie->m_objecttype;

		//  Don't add menu items if this is a serialized file
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
  		{
			switch (objType)
			{
			case CERTMGR_CERTIFICATE:
				if ( !m_bMultipleObjectsSelected )
				{
					CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
					ASSERT (pCert);
					if ( pCert )
					{
						hr = AddOpenMenuItem (pContextMenuCallback,
								CCM_INSERTIONPOINTID_PRIMARY_TOP);
					}
					else
						hr = E_FAIL;
				}
				break;
			
			case CERTMGR_CRL:
				if ( !m_bMultipleObjectsSelected )
					hr = AddCRLOpenMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP);
				break;

			case CERTMGR_CTL:
				if ( !m_bMultipleObjectsSelected )
					hr = AddCTLOpenMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP);
				break;

			case CERTMGR_SNAPIN:
                if ( CERT_SYSTEM_STORE_CURRENT_USER != m_dwLocationPersist )
                {
                    hr = AddChangeComputerMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP);
                }
                // fall through

			case CERTMGR_PHYS_STORE:
			case CERTMGR_USAGE:
			case CERTMGR_LOG_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
				hr = AddFindMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TOP);
				break;

            case CERTMGR_LOG_STORE_RSOP:
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                break;

			case CERTMGR_LOG_STORE_GPE:
				ASSERT (!m_bMultipleObjectsSelected);
				{
					CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*>
							 (pCookie);
					ASSERT (pStore);
					if ( pStore )
					{
						switch (pStore->GetStoreType ())
						{
						case TRUST_STORE:
						case ROOT_STORE:
							if ( pStore->GetStoreHandle () )
							{
								hr = AddImportMenuItem (pContextMenuCallback,
										pStore->IsReadOnly (),
                                        CCM_INSERTIONPOINTID_PRIMARY_TOP);
								pStore->Close ();
							}
							break;

						case EFS_STORE:
						    if ( pStore->GetStoreHandle () )
						    {
							    hr = AddAddDomainEncryptedRecoveryAgentMenuItem (
									    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TOP,
									    pStore->IsReadOnly () );
                                if ( !m_bMachineIsStandAlone )
                                {
								    hr = AddCreateDomainEncryptedRecoveryAgentMenuItem (
										    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TOP,
										    pStore->IsReadOnly () );
                                }

							    pStore->Close ();
						    }
						    else if ( pStore->IsNullEFSPolicy () )
						    {
							    hr = AddAddDomainEncryptedRecoveryAgentMenuItem (
									    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TOP,
									    pStore->IsReadOnly () );
                                if ( !m_bMachineIsStandAlone )
                                {
    							    hr = AddCreateDomainEncryptedRecoveryAgentMenuItem (
	    								    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TOP,
		    							    pStore->IsReadOnly () );
                                }

							    pStore->Close ();
						    }
                            break;

                        default:
                            break;
                        }
					}
				}
				break;

			case CERTMGR_CRL_CONTAINER:
			case CERTMGR_CTL_CONTAINER:
			case CERTMGR_CERT_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
                break;

            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
                if ( m_pGPEInformation )
                {
					CSaferLevel* pLevel = reinterpret_cast <CSaferLevel*>
							 (pCookie);
					ASSERT (pLevel);
					if ( pLevel )
					{
                        // RAID#265590	Safer Windows:  "Set as default" menu 
                        // item is enabled in the context menu of a security 
                        // level when the security level is already the default.
                        if ( ( SAFER_LEVELID_DISALLOWED == pLevel->GetLevel () ||
                                SAFER_LEVELID_FULLYTRUSTED == pLevel->GetLevel () )
                                && !pLevel->IsDefault () )
                        {
                            hr = AddSaferLevelSetAsDefaultMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TOP);
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_ENTRIES:
                if ( m_pGPEInformation )
                    hr = AddSaferNewEntryMenuItems (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP);
                break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                {
                    CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
                    if ( pSaferRootCookie )
                    {
                        if ( !pSaferRootCookie->m_bCreateSaferNodes && !m_bIsRSOP)
                            hr = AddSaferCreateNewPolicyMenuItems (pContextMenuCallback,
                                    CCM_INSERTIONPOINTID_PRIMARY_TOP);
                    }
                }
                break;

			default:
				break;
			}
  		}
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_NEW	)
  		{
			if ( CERTMGR_LOG_STORE_GPE == objType )
			{
				ASSERT (!m_bMultipleObjectsSelected);
				CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*>
						 (pCookie);
				ASSERT (pStore);
				if ( pStore && pStore->GetStoreHandle () )
				{
					switch (pStore->GetStoreType ())
					{
					case TRUST_STORE:
						hr = AddCTLNewMenuItem (pContextMenuCallback,
								CCM_INSERTIONPOINTID_PRIMARY_NEW, pStore->IsReadOnly ());
						break;

					case ACRS_STORE:
						hr = AddACRSNewMenuItem (pContextMenuCallback,
 								CCM_INSERTIONPOINTID_PRIMARY_NEW, pStore->IsReadOnly ());
    					break;

					case EFS_STORE:
						hr = AddAddDomainEncryptedRecoveryAgentMenuItem (
								pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_NEW,
								pStore->IsReadOnly ());
						break;

					default:
						break;
					}
					pStore->Close ();
				}
			}
  		}
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
  		{
			switch (objType)
			{
			case CERTMGR_CERTIFICATE:
                if ( !m_bIsRSOP )
				{
					CCertificate* pCert =
							reinterpret_cast <CCertificate*> (pCookie);
					ASSERT (pCert);
					if ( pCert && pCert->GetCertStore () )
					{
						hr = AddCertificateTaskMenuItems (
								pContextMenuCallback,
								 (pCert->GetStoreType () == MY_STORE),
								 pCert->GetCertStore ()->IsReadOnly (),
								 pCert);
					}
				}
				break;

			case CERTMGR_CRL:
				if ( !m_bMultipleObjectsSelected )
				{
					AddCRLOpenMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);
                    if ( !m_bIsRSOP )
	    				AddCRLExportMenuItem (pContextMenuCallback);
				}
				break;

			case CERTMGR_AUTO_CERT_REQUEST:
				if ( !m_bMultipleObjectsSelected && !m_bIsRSOP )
				{
					CAutoCertRequest* pAutoCert =
							reinterpret_cast <CAutoCertRequest*> (pCookie);
					ASSERT (pAutoCert);
					if ( pAutoCert )
					{
						hr = AddACRTaskMenuItems (pContextMenuCallback,
								pAutoCert->GetCertStore ().IsReadOnly ());
					}
				}
				break;

			case CERTMGR_CTL:
                if ( !m_bIsRSOP )
    			{
					CCTL* pCTL =
							reinterpret_cast <CCTL*> (pCookie);
					ASSERT (pCTL);
					if ( pCTL )
					{
						hr = AddCTLTaskMenuItems (pContextMenuCallback,
								pCTL->GetCertStore ().IsReadOnly ());
					}
				}
				break;

			case CERTMGR_SNAPIN:
				ASSERT (!m_bMultipleObjectsSelected);
				hr = AddFindMenuItem (pContextMenuCallback, 
                                                   CCM_INSERTIONPOINTID_PRIMARY_TASK);
                if ( SUCCEEDED (hr) && 
                        CERT_SYSTEM_STORE_CURRENT_USER != m_dwLocationPersist )
                {
                    hr = AddChangeComputerMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK);
                }
               
                // must be targetting current user OR LOCAL machine, must be joined to domain
                if( SUCCEEDED (hr) && 
                        !m_bMachineIsStandAlone &&
                        ((CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist) || (CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist)) &&
                        IsLocalComputername (m_strMachineNamePersist))
                {
                     hr = AddPulseAutoEnrollMenuItem(pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);
                }


				break;

			case CERTMGR_USAGE:
				ASSERT (!m_bMultipleObjectsSelected);
				hr = AddFindMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);
				if ( !bIsFileView )
				{
                    // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
                    if ( IsLocalComputername (m_strMachineNamePersist) && !m_bIsRSOP )
                    {
                        hr = AddSeparator (pContextMenuCallback);
					    // NOTE: New certs will be added only to MY store.
					    hr = AddEnrollMenuItem (pContextMenuCallback, FALSE);
                        if ( SUCCEEDED (hr) )
                        {
					        hr = AddImportMenuItem (pContextMenuCallback, false,
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK);
                        }
                    }
				}
				break;

			case CERTMGR_PHYS_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
				hr = AddFindMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);
				if ( !bIsFileView && !m_bIsRSOP)
				{
					hr = AddSeparator (pContextMenuCallback);
					{
						CCertStore* pStore =
								reinterpret_cast <CCertStore*> (pCookie);
						ASSERT (pStore);
						if ( pStore && pStore->GetStoreHandle () )
						{
                            // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
							if ( pStore->GetStoreType () == MY_STORE &&
                                    IsLocalComputername (m_szManagedComputer) )
                            {
								hr = AddEnrollMenuItem (pContextMenuCallback,
										pStore->IsReadOnly ());
                            }
                            if ( SUCCEEDED (hr) )
							    hr = AddImportMenuItem (pContextMenuCallback,
								    	pStore->IsReadOnly (),
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK);
							pStore->Close ();
						}
					}
					hr = AddExportStoreMenuItem (pContextMenuCallback);
				}
				break;

			case CERTMGR_LOG_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
				hr = AddFindMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);
				if ( !bIsFileView && !m_bIsRSOP )
				{
					hr = AddSeparator (pContextMenuCallback);
					{
						CCertStore* pStore =
								reinterpret_cast <CCertStore*> (pCookie);
						ASSERT (pStore);
						if ( pStore && pStore->GetStoreHandle () )
						{
                            // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
							if ( pStore->GetStoreType () == MY_STORE  && 
                                    IsLocalComputername (m_szManagedComputer) )
							{
								hr = AddEnrollMenuItem (pContextMenuCallback,
										pStore->IsReadOnly ());
							}
							hr = AddImportMenuItem (pContextMenuCallback,
									pStore->IsReadOnly (),
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK);
							pStore->Close ();
						}
					}
				}
				break;

			case CERTMGR_LOG_STORE_RSOP:
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                break;

			case CERTMGR_LOG_STORE_GPE:
				ASSERT (!m_bMultipleObjectsSelected);
				{
					CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*>
							 (pCookie);
					ASSERT (pStore);
					if ( pStore )
					{
						switch (pStore->GetStoreType ())
						{
						case TRUST_STORE:
						case ROOT_STORE:
							if ( pStore->GetStoreHandle () && !m_bIsRSOP )
							{
								hr = AddImportMenuItem (pContextMenuCallback,
										pStore->IsReadOnly (),
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK);
								pStore->Close ();
							}
							break;

						case EFS_STORE:
						    if ( pStore->GetStoreHandle () )
						    {
							    hr = AddAddDomainEncryptedRecoveryAgentMenuItem (
									    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK,
									    pStore->IsReadOnly () );
                                if ( !m_bMachineIsStandAlone )
                                {
								    hr = AddCreateDomainEncryptedRecoveryAgentMenuItem (
										    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK,
										    pStore->IsReadOnly () );
                                }
							    hr = AddDeletePolicyMenuItem (pContextMenuCallback,
									    CCM_INSERTIONPOINTID_PRIMARY_TASK);
							    pStore->Close ();
						    }
						    else if ( pStore->IsNullEFSPolicy () )
						    {
							    hr = AddAddDomainEncryptedRecoveryAgentMenuItem (
									    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK,
									    pStore->IsReadOnly () );
                                if ( !m_bMachineIsStandAlone )
                                {
    							    hr = AddCreateDomainEncryptedRecoveryAgentMenuItem (
	    								    pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK,
		    							    pStore->IsReadOnly () );
                                }

								hr = AddInitPolicyMenuItem (pContextMenuCallback,
										CCM_INSERTIONPOINTID_PRIMARY_TASK);

							    pStore->Close ();
						    }
                            break;

                        default:
                            break;
                        }
					}
				}
				break;

			case CERTMGR_CRL_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
				break;

			case CERTMGR_CTL_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
				if ( !bIsFileView && !m_bIsRSOP )
				{
					CContainerCookie* pCont =
							reinterpret_cast <CContainerCookie*> (pCookie);
					ASSERT (pCont);
					if ( pCont )
					{
						hr = AddImportMenuItem (pContextMenuCallback,
								pCont->GetCertStore ().IsReadOnly (),
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
					}
				}
				break;

			case CERTMGR_CERT_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
				if ( !bIsFileView && !m_bIsRSOP )
				{
					CContainerCookie* pContainer =
							reinterpret_cast <CContainerCookie*> (pCookie);
					ASSERT (pContainer);
					if ( pContainer )
					{
                        // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
						if ( pContainer->GetStoreType () == MY_STORE &&
                                IsLocalComputername (m_szManagedComputer) )
						{
							hr = AddEnrollMenuItem (pContextMenuCallback,
									pContainer->GetCertStore ().IsReadOnly ());
						}
						hr = AddImportMenuItem (pContextMenuCallback,
								pContainer->GetCertStore ().IsReadOnly (),
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
					}
				}
				break;

            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
                if ( m_pGPEInformation )
                {
					CSaferLevel* pLevel = reinterpret_cast <CSaferLevel*>
							 (pCookie);
					ASSERT (pLevel);
					if ( pLevel )
					{
                        // RAID#265590	Safer Windows:  "Set as default" menu 
                        // item is enabled in the context menu of a security 
                        // level when the security level is already the default.
                        if ( (SAFER_LEVELID_DISALLOWED == pLevel->GetLevel () ||
                                SAFER_LEVELID_FULLYTRUSTED == pLevel->GetLevel ()) 
                                && !pLevel->IsDefault () )
                        {
                            hr = AddSaferLevelSetAsDefaultMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK);
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_ENTRIES:
                if ( m_pGPEInformation )
                    hr = AddSaferNewEntryMenuItems (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK);
                break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                {
                    CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
                    if ( pSaferRootCookie )
                    {
                        if ( !pSaferRootCookie->m_bCreateSaferNodes && !m_bIsRSOP)
                            hr = AddSaferCreateNewPolicyMenuItems (pContextMenuCallback,
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK);
                    }
                }
                break;

            default:
                break;
			}
  		}
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW )
  		{
			switch (objType)
			{	
			case CERTMGR_CERTIFICATE:
			case CERTMGR_CRL:
			case CERTMGR_CTL:
			case CERTMGR_AUTO_CERT_REQUEST:
				break;

			case CERTMGR_SNAPIN:
			case CERTMGR_PHYS_STORE:
			case CERTMGR_USAGE:
			case CERTMGR_LOG_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
				hr = AddOptionsMenuItem (pContextMenuCallback);
				break;

			default:
				break;
			}
   		}
		
		_TRACE (-1, L"Leaving CCertMgrComponentData::AddMenuItems: 0x%x\n", hr);
	}

	return hr;
}


HRESULT CCertMgrComponentData::AddACRSNewMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddACRSNewMenuItem\n");
 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
 	ASSERT (pContextMenuCallback);
 	HRESULT			hr = S_OK;
 	CONTEXTMENUITEM	menuItem;
 	CString			szMenu;
 	CString			szHint;
 

 	// unchanging settings
 	::ZeroMemory (&menuItem, sizeof (menuItem));
 	menuItem.lInsertionPointID = lInsertionPointID;
 	menuItem.fFlags = 0;
 
 	VERIFY (szMenu.LoadString (IDS_NEW_AUTO_CERT_REQUEST));
 	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
 	VERIFY (szHint.LoadString (IDS_NEW_AUTO_CERT_REQUEST_HINT));
 	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
 	menuItem.lCommandID = IDM_NEW_ACRS;
 	if ( bIsReadOnly )
 		menuItem.fFlags = MF_GRAYED;
 
 	hr = pContextMenuCallback->AddItem (&menuItem);
 	ASSERT (SUCCEEDED (hr));

 	_TRACE (-1, L"Leaving CCertMgrComponentData::AddACRSNewMenuItem: 0x%x\n", hr);
 	return hr;
}


HRESULT CCertMgrComponentData::AddCertificateTaskMenuItems (
		LPCONTEXTMENUCALLBACK pContextMenuCallback, 
        const bool bIsMyStore, 
        bool bIsReadOnly,
		CCertificate* /*pCert*/)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCertificateTaskMenuItems\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;

	if ( !m_bMultipleObjectsSelected )
	{
		AddOpenMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);
		AddSeparator (pContextMenuCallback);

		if ( m_szFileName.IsEmpty () )
		{
            // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
			if ( bIsMyStore && 
                    CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist &&
                    IsLocalComputername (m_szManagedComputer) )
			{
				VERIFY (szMenu.LoadString (IDS_ENROLL_CERT_WITH_NEW_KEY));
				menuItem.strName = (PWSTR) (PCWSTR) szMenu;
				VERIFY (szHint.LoadString (IDS_ENROLL_CERT_WITH_NEW_KEY_HINT));
				menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
				menuItem.lCommandID = IDM_ENROLL_NEW_CERT_NEW_KEY;
				if ( bIsReadOnly )
					menuItem.fFlags = MF_GRAYED;
				hr = pContextMenuCallback->AddItem (&menuItem);
				ASSERT (SUCCEEDED (hr));

				VERIFY (szMenu.LoadString (IDS_ENROLL_CERT_WITH_SAME_KEY));
				menuItem.strName = (PWSTR) (PCWSTR) szMenu;
				VERIFY (szHint.LoadString (IDS_ENROLL_CERT_WITH_SAME_KEY_HINT));
				menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
				menuItem.lCommandID = IDM_ENROLL_NEW_CERT_SAME_KEY;
				if ( bIsReadOnly )
					menuItem.fFlags = MF_GRAYED;
				hr = pContextMenuCallback->AddItem (&menuItem);
				ASSERT (SUCCEEDED (hr));

				VERIFY (szMenu.LoadString (IDS_RENEW_NEW_KEY));
				menuItem.strName = (PWSTR) (PCWSTR) szMenu;
				VERIFY (szHint.LoadString (IDS_RENEW_NEW_KEY_HINT));
				menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
				menuItem.lCommandID = IDM_TASK_RENEW_NEW_KEY;
				if ( bIsReadOnly )
					menuItem.fFlags = MF_GRAYED;
				hr = pContextMenuCallback->AddItem (&menuItem);
				ASSERT (SUCCEEDED (hr));

				VERIFY (szMenu.LoadString (IDS_RENEW_SAME_KEY));
				menuItem.strName = (PWSTR) (PCWSTR) szMenu;
				VERIFY (szHint.LoadString (IDS_RENEW_SAME_KEY_HINT));
				menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
				menuItem.lCommandID = IDM_TASK_RENEW_SAME_KEY;
				if ( bIsReadOnly )
					menuItem.fFlags = MF_GRAYED;
				hr = pContextMenuCallback->AddItem (&menuItem);
				ASSERT (SUCCEEDED (hr));
			}
		}
	}
	hr = AddExportMenuItem (pContextMenuCallback);

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCertificateTaskMenuItems: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddCTLTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCTLTaskMenuItems\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;

	if ( !m_bMultipleObjectsSelected )
		AddCTLOpenMenuItem (pContextMenuCallback, CCM_INSERTIONPOINTID_PRIMARY_TASK);

	hr = AddCTLExportMenuItem (pContextMenuCallback);
	
	if ( !m_bMultipleObjectsSelected )
	{
		VERIFY (szMenu.LoadString (IDS_EDIT));
		menuItem.strName = (PWSTR) (PCWSTR) szMenu;
		VERIFY (szHint.LoadString (IDS_CTL_EDIT_HINT));
		menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
		menuItem.lCommandID = IDM_CTL_EDIT;
		if ( bIsReadOnly )
			menuItem.fFlags = MF_GRAYED;
		hr = pContextMenuCallback->AddItem (&menuItem);
		ASSERT (SUCCEEDED (hr));
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCTLTaskMenuItems: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddACRTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddACRTaskMenuItems\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	
	VERIFY (szMenu.LoadString (IDS_EDIT));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_ACR_EDIT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_EDIT_ACRS;
	if ( bIsReadOnly )
		menuItem.fFlags = MF_GRAYED;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddACRTaskMenuItems: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddEnrollMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddEnrollMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;

	if ( CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist )
	{
		CONTEXTMENUITEM	menuItem;
		CString			szMenu;
		CString			szHint;

		::ZeroMemory (&menuItem, sizeof (menuItem));
		menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
		menuItem.fFlags = 0;
		menuItem.fSpecialFlags = 0;
		VERIFY (szMenu.LoadString (IDS_ENROLL_NEW_CERT));
		menuItem.strName = (PWSTR) (PCWSTR) szMenu;
		VERIFY (szHint.LoadString (IDS_ENROLL_NEW_CERT_HINT));
		menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
		menuItem.lCommandID = IDM_ENROLL_NEW_CERT;
		if ( bIsReadOnly )
			menuItem.fFlags = MF_GRAYED;

		hr = pContextMenuCallback->AddItem (&menuItem);
		ASSERT (SUCCEEDED (hr));
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddEnrollMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddFindMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddFindMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;

	VERIFY (szMenu.LoadString (IDS_FIND));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_FIND_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	if ( CCM_INSERTIONPOINTID_PRIMARY_TOP == lInsertionPointID )
		menuItem.lCommandID = IDM_TOP_FIND;
	else
		menuItem.lCommandID = IDM_TASK_FIND;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddFindMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT  CCertMgrComponentData::AddPulseAutoEnrollMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddPulseAutoEnrollMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;

	VERIFY (szMenu.LoadString (IDS_PULSEAUTOENROLL));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_PULSEAUTOENROLL_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_TASK_PULSEAUTOENROLL;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddPulseAutoEnrollMenuItem: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddChangeComputerMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddChangeComputerMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;

	VERIFY (szMenu.LoadString (IDS_CHANGE_COMPUTER));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_CHANGE_COMPUTER_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	if ( CCM_INSERTIONPOINTID_PRIMARY_TOP == lInsertionPointID )
		menuItem.lCommandID = IDM_TOP_CHANGE_COMPUTER;
	else
		menuItem.lCommandID = IDM_TASK_CHANGE_COMPUTER;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddChangeComputerMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddSeparator (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSeparator\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	CONTEXTMENUITEM	menuItem;

	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fSpecialFlags = 0;
	menuItem.strName = _T ("Separator");			// Dummy name
	menuItem.strStatusBarText = _T ("Separator");// Dummy status text
	menuItem.lCommandID = ID_SEPARATOR;			// Command ID
	menuItem.fFlags = MF_SEPARATOR;				// most important the flag
	HRESULT	hr = pContextMenuCallback->AddItem (&menuItem);

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSeparator: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddImportMenuItem (
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            bool bIsReadOnly,
            LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddImportMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	VERIFY (szMenu.LoadString (IDS_IMPORT));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_IMPORT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_TASK_IMPORT;
	if ( bIsReadOnly )
		menuItem.fFlags = MF_GRAYED;

	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddImportMenuItem: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddExportStoreMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddExportStoreMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	VERIFY (szMenu.LoadString (IDS_EXPORT_STORE));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_EXPORT_STORE_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_TASK_EXPORT_STORE;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddExportStoreMenuItem: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddExportMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddExportMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	VERIFY (szMenu.LoadString (IDS_EXPORT));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_EXPORT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_TASK_EXPORT;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddExportMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCTLExportMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCTLExportMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	VERIFY (szMenu.LoadString (IDS_EXPORT));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_CTL_EXPORT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_TASK_CTL_EXPORT;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCTLExportMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCRLExportMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCRLExportMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	VERIFY (szMenu.LoadString (IDS_EXPORT));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_CRL_EXPORT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_TASK_CRL_EXPORT;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCRLExportMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddOpenMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddOpenMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (IDS_VIEW));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_VIEW_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = (CCM_INSERTIONPOINTID_PRIMARY_TOP == lInsertionPointID)
			? IDM_OPEN : IDM_TASK_OPEN;
	menuItem.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddOpenMenuItem: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddCTLOpenMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCTLOpenMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (IDS_VIEW));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_CTL_VIEW_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = (CCM_INSERTIONPOINTID_PRIMARY_TOP == lInsertionPointID)
			? IDM_OPEN : IDM_TASK_OPEN;
	menuItem.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCTLOpenMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCRLOpenMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCRLOpenMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (IDS_VIEW));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_CRL_VIEW_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = (CCM_INSERTIONPOINTID_PRIMARY_TOP == lInsertionPointID)
			? IDM_OPEN : IDM_TASK_OPEN;
	menuItem.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCRLOpenMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddAddDomainEncryptedRecoveryAgentMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddAddDomainEncryptedRecoveryAgentMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	if ( lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TOP )
	{
		VERIFY (szMenu.LoadString (IDS_ADD_DATA_RECOVERY_AGENT));
		menuItem.lCommandID = IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT;
	}
	else if ( lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TASK )
	{
		VERIFY (szMenu.LoadString (IDS_ADD_DATA_RECOVERY_AGENT));
		menuItem.lCommandID = IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1;
	}
	else if ( lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_NEW )
	{
		VERIFY (szMenu.LoadString (IDS_ENCRYPTED_RECOVERY_AGENT));
		menuItem.lCommandID = IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT2;
	}
	else
	{
		ASSERT (0);
		return E_UNEXPECTED;
	}
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	if ( bIsReadOnly )
		menuItem.fFlags = MF_GRAYED;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddAddDomainEncryptedRecoveryAgentMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCreateDomainEncryptedRecoveryAgentMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCreateDomainEncryptedRecoveryAgentMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (IDS_CREATE));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT;
	if ( bIsReadOnly )
		menuItem.fFlags = MF_GRAYED;

	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCreateDomainEncryptedRecoveryAgentMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddInitPolicyMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddInitPolicyMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (IDS_INIT_POLICY));
	menuItem.lCommandID = IDM_INIT_POLICY;

    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_INIT_POLICY_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddInitPolicyMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddDeletePolicyMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddDeletePolicyMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	if ( lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TOP )
	{
		VERIFY (szMenu.LoadString (IDS_DEL_POLICY));
		menuItem.lCommandID = IDM_DEL_POLICY;
	}
	else if ( lInsertionPointID == CCM_INSERTIONPOINTID_PRIMARY_TASK )
	{
		VERIFY (szMenu.LoadString (IDS_DEL_POLICY));
		menuItem.lCommandID = IDM_DEL_POLICY1;
	}
	else
	{
		ASSERT (0);
		return E_UNEXPECTED;
	}
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_DEL_POLICY_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddDeletePolicyMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCTLNewMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            LONG lInsertionPointID, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCTLNewMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (IDS_NEW_CTL));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_NEW_CTL_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_NEW_CTL;
	if ( bIsReadOnly )
		menuItem.fFlags = MF_GRAYED;

	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCTLNewMenuItem: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddSaferCreateNewPolicyMenuItems (
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferCreateNewPolicyMenuItems\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

