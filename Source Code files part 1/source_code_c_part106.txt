yExpires =
                    network->MulticastKeyExpires;



                //
                // Set EncryptedMulticastKey
                //
                status = NmpUnprotectData(network->EncryptedMulticastKey,
                                          network->EncryptedMulticastKeyLength,
                                          &MulticastKey,
                                          &MulticastKeyLength
                                          );
                if (status != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to decrypt multicast key  "
                        "for network %1!ws!, status %2!u!.\n",
                        networkId,
                        status
                        );
                    goto error_exit;
                }

               status = NmpDeriveClusterKey(
                                     networkId,
                                     NM_WCSLEN(networkId),
                                     &EncryptionKey,
                                     &EncryptionKeyLength
                                     );
               if (status != ERROR_SUCCESS)
               {
                   ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Failed to derive cluster key for "
                       "network %1!ws!, status %2!u!.\n",
                       networkId, status
                       );
                   goto error_exit;
               }

               MACLength = NMP_MAC_DATA_LENGTH_EXPECTED;

               status = NmpEncryptDataAndCreateMAC(
                               NmCryptServiceProvider,
                               NMP_ENCRYPT_ALGORITHM,
                               NMP_KEY_LENGTH,
                               MulticastKey, // Data
                               MulticastKeyLength, // Data length
                               EncryptionKey,
                               EncryptionKeyLength,
                               TRUE, // Create salt
                               &Salt,
                               NMP_SALT_BUFFER_LEN,
                               &EncryptedMulticastKey,
                               &EncryptedMulticastKeyLength,
                               &MAC,
                               &MACLength
                               );
               if (status != ERROR_SUCCESS)
               {
                   ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Failed to "
                       "encrypt data or generate MAC for "
                       "network %1!ws!, status %2!u!.\n",
                       networkId,
                       status
                       );
                   goto error_exit;
               }

               networkMulticastKey->EncryptedMulticastKey =
                   MIDL_user_allocate(EncryptedMulticastKeyLength);

               if (networkMulticastKey->EncryptedMulticastKey == NULL) {
                   ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Failed to allocate %1!u! bytes "
                       "for encrypted multicast key.\n",
                       EncryptedMulticastKeyLength
                       );
                   status = ERROR_NOT_ENOUGH_MEMORY;
                   goto error_exit;
               }

               CopyMemory(networkMulticastKey->EncryptedMulticastKey,
                          EncryptedMulticastKey,
                          EncryptedMulticastKeyLength
                          );

               networkMulticastKey->EncryptedMulticastKeyLength =
                    EncryptedMulticastKeyLength;



               //
               // Set Salt
               //
               networkMulticastKey->Salt =
                   MIDL_user_allocate(NMP_SALT_BUFFER_LEN);

               if (networkMulticastKey->Salt == NULL) {
                   ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Failed to allocate %1!u! bytes "
                       "for encrypted multicast key salt.\n",
                       NMP_SALT_BUFFER_LEN
                       );
                   status = ERROR_NOT_ENOUGH_MEMORY;
                   goto error_exit;
               }

               CopyMemory(networkMulticastKey->Salt,
                          Salt,
                          NMP_SALT_BUFFER_LEN
                          );

               networkMulticastKey->SaltLength =
                    NMP_SALT_BUFFER_LEN;



               //
               // Set MAC
               //
               networkMulticastKey->MAC =
                   MIDL_user_allocate(MACLength);

               if (networkMulticastKey->MAC == NULL) {
                   ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Failed to allocate %1!u! bytes "
                       "for encrypted multicast key MAC.\n",
                       MACLength
                       );
                   status = ERROR_NOT_ENOUGH_MEMORY;
                   goto error_exit;
               }

               CopyMemory(networkMulticastKey->MAC,
                          MAC,
                          MACLength
                          );

               networkMulticastKey->MACLength =
                    MACLength;



               //
               // release MulticastKey
               //
               if (MulticastKey != NULL)
               {
                   RtlSecureZeroMemory(MulticastKey, MulticastKeyLength);
                   LocalFree(MulticastKey);
                   MulticastKey = NULL;
               }


               //
               // release EncryptionKey
               //
               if (EncryptionKey != NULL)
               {
                   RtlSecureZeroMemory(EncryptionKey, EncryptionKeyLength);
                   LocalFree(EncryptionKey);
                   EncryptionKey = NULL;
               }

            } // if (network->EncryptedMulticastKey != NULL)
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Network %1!ws! has no multicast key.\n",
                    networkId
                    );
            }

            break;

        } // if (wcscmp(NetworkId, networkId) == 0)

    }  // for

    if (found == FALSE)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Unable to find network %1!ws!.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;

    }

    *NetworkMulticastKey = networkMulticastKey;

error_exit:

    if (MulticastKey != NULL)
    {
        RtlSecureZeroMemory(MulticastKey, MulticastKeyLength);
        LocalFree(MulticastKey);
        MulticastKey = NULL;
    }

    if (EncryptionKey != NULL)
    {
        RtlSecureZeroMemory(EncryptionKey, EncryptionKeyLength);
        LocalFree(EncryptionKey);
        EncryptionKey = NULL;
    }

    if (EncryptedMulticastKey != NULL)
    {
        HeapFree(GetProcessHeap(), 0, EncryptedMulticastKey);
    }

    if (Salt != NULL)
    {
        HeapFree(GetProcessHeap(), 0, Salt);
    }

    if (MAC != NULL)
    {
        HeapFree(GetProcessHeap(), 0, MAC);
    }

    if (status != ERROR_SUCCESS)
    {
        NmpFreeNetworkMulticastKey(networkMulticastKey
                                   );
    }

    return (status);

} //  NmpGetNetworkMulticastKey

/////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpRegisterNetwork(
    IN PNM_NETWORK   Network,
    IN BOOLEAN       RetryOnFailure
    )
/*++

Routine Description:

    Registers a network and the associated interfaces with the
    cluster transport and brings the network online.

Arguments:

    Network - A pointer to the network to register.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/
{
    PLIST_ENTRY     entry;
    PNM_INTERFACE   netInterface;
    DWORD           status = ERROR_SUCCESS;
    DWORD           tempStatus;
    PVOID           tdiAddress = NULL;
    ULONG           tdiAddressLength = 0;
    LPWSTR          networkId = (LPWSTR) OmObjectId(Network);
    PVOID           tdiAddressInfo = NULL;
    ULONG           tdiAddressInfoLength = 0;
    DWORD           responseLength;
    PNM_INTERFACE   localInterface = Network->LocalInterface;
    BOOLEAN         restricted = FALSE;
    BOOLEAN         registered = FALSE;


    if (Network->LocalInterface != NULL) {
        if (!NmpIsNetworkRegistered(Network)) {
            //
            // Register the network
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Registering network %1!ws! (%2!ws!) with cluster "
                "transport.\n",
                networkId,
                OmObjectName(Network)
                );

            if (!NmpIsNetworkForInternalUse(Network)) {
                restricted = TRUE;
            }

            status = ClusnetRegisterNetwork(
                         NmClusnetHandle,
                         Network->ShortId,
                         Network->Priority,
                         restricted
                         );

            if (status == ERROR_SUCCESS) {
                registered = TRUE;

                //
                // Bring the network online.
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Bringing network %1!ws! online.\n",
                    networkId
                    );

                status = ClRtlBuildTcpipTdiAddress(
                             localInterface->Address,
                             localInterface->ClusnetEndpoint,
                             &tdiAddress,
                             &tdiAddressLength
                             );

                if (status == ERROR_SUCCESS) {
                    ClRtlQueryTcpipInformation(
                        NULL,
                        NULL,
                        &tdiAddressInfoLength
                        );

                    tdiAddressInfo = LocalAlloc(
                                         LMEM_FIXED,
                                         tdiAddressInfoLength
                                         );

                    if (tdiAddressInfo != NULL) {
                        responseLength = tdiAddressInfoLength;

                        status = ClusnetOnlineNetwork(
                                     NmClusnetHandle,
                                     Network->ShortId,
                                     L"\\Device\\Udp",
                                     tdiAddress,
                                     tdiAddressLength,
                                     localInterface->AdapterId,
                                     tdiAddressInfo,
                                     &responseLength
                                     );

                        if (status != ERROR_SUCCESS) {
                            ClRtlLogPrint(LOG_CRITICAL,
                                "[NM] Cluster transport failed to bring "
                                "network %1!ws! online, status %2!u!.\n",
                                networkId,
                                status
                                );
                        }
                        else {
                            CL_ASSERT(responseLength == tdiAddressInfoLength);
                        }

                        LocalFree(tdiAddressInfo);
                    }
                    else {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NM] Failed to allocate memory to register "
                            "network %1!ws! with cluster transport.\n",
                            networkId
                            );
                    }

                    LocalFree(tdiAddress);
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NM] Failed to build address to register "
                        "network %1!ws! withh cluster transport, "
                        "status %2!u!.\n",
                        networkId,
                        status
                        );
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to register network %1!ws! with cluster "
                    "transport, status %2!u!.\n",
                    networkId,
                    status
                    );
            }

            if (status == ERROR_SUCCESS) {
                Network->Flags |= NM_FLAG_NET_REGISTERED;
                Network->RegistrationRetryTimeout = 0;

                //
                // Start multicast.
                //
                NmpStartMulticast(Network, NmStartMulticastDynamic);
            }
            else {
                WCHAR  string[16];

                wsprintfW(&(string[0]), L"%u", status);

                CsLogEvent2(
                    LOG_UNUSUAL,
                    NM_EVENT_REGISTER_NETWORK_FAILED,
                    OmObjectName(Network),
                    string
                    );

                if (registered) {
                    NmpDeregisterNetwork(Network);
                }

                //
                // Retry if the error is transient.
                //
                if ( RetryOnFailure &&
                     ( (status == ERROR_INVALID_NETNAME) ||
                       (status == ERROR_NOT_ENOUGH_MEMORY) ||
                       (status == ERROR_NO_SYSTEM_RESOURCES)
                     )
                   )
                {
                    NmpStartNetworkRegistrationRetryTimer(Network);

                    status = ERROR_SUCCESS;
                }

                return(status);
            }
        }

        //
        // Register the network's interfaces.
        //
        for (entry = Network->InterfaceList.Flink;
             entry != &(Network->InterfaceList);
             entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NetworkLinkage
                               );

            if (!NmpIsInterfaceRegistered(netInterface)) {
                tempStatus = NmpRegisterInterface(
                                 netInterface,
                                 RetryOnFailure
                                 );

                if (tempStatus != ERROR_SUCCESS) {
                    status = tempStatus;
                }
            }
        }
    }


    return(status);

}  // NmpRegisterNetwork


VOID
NmpDeregisterNetwork(
    IN  PNM_NETWORK   Network
    )
/*++

Routine Description:

    Deregisters a network and the associated interfaces from the
    cluster transport.

Arguments:

    Network - A pointer to the network to deregister.

Return Value:

    None.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD           status;
    PNM_INTERFACE   netInterface;
    PLIST_ENTRY     entry;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Deregistering network %1!ws! (%2!ws!) from cluster transport.\n",
        OmObjectId(Network),
        OmObjectName(Network)
        );

    status = ClusnetDeregisterNetwork(
                 NmClusnetHandle,
                 Network->ShortId
                 );

    CL_ASSERT(
        (status == ERROR_SUCCESS) ||
        (status == ERROR_CLUSTER_NETWORK_NOT_FOUND)
        );

    //
    // Mark all of the network's interfaces as deregistered.
    //
    for (entry = Network->InterfaceList.Flink;
         entry != &(Network->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);

        netInterface->Flags &= ~NM_FLAG_IF_REGISTERED;
    }

    //
    // Mark the network as deregistered
    //
    Network->Flags &= ~NM_FLAG_NET_REGISTERED;

    return;

} // NmpDeregisterNetwork


VOID
NmpInsertInternalNetwork(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Inserts a network into internal networks list based on its priority.

Arguments:

    Network - A pointer to the network object to be inserted.

Return Value:

    None.

Notes:

    Called with the NmpLock held.

--*/
{
    PLIST_ENTRY    entry;
    PNM_NETWORK    network;


    //
    // Maintain internal networks in highest to lowest
    // (numerically lowest to highest) priority order.
    //
    for (entry = NmpInternalNetworkList.Flink;
         entry != &NmpInternalNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, InternalLinkage);

        if (Network->Priority < network->Priority) {
            break;
        }
    }

    //
    // Insert the network in front of this entry.
    //
    InsertTailList(entry, &(Network->InternalLinkage));

    return;

}  // NmpInsertNetwork


DWORD
NmpValidateNetworkRoleChange(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole
    )
{
    if ( !(NewRole & ClusterNetworkRoleInternalUse) &&
         NmpIsNetworkForInternalUse(Network)
       )
    {
        //
        // This change eliminates an internal network. This is only
        // legal if we would still have at least one internal network
        // between all active nodes.
        //
        if ((NmpInternalNetworkCount < 2) || !NmpVerifyConnectivity(Network)) {
            return(ERROR_CLUSTER_LAST_INTERNAL_NETWORK);
        }
    }

    if ( ( !(NewRole & ClusterNetworkRoleClientAccess) )
         &&
         NmpIsNetworkForClientAccess(Network)
       )
    {
        BOOL  hasDependents;

        //
        // This change eliminates a public network. This is only
        // legal if there are no dependencies (IP address resources) on
        // the network.
        //
        NmpReleaseLock();

        hasDependents = FmCheckNetworkDependency(OmObjectId(Network));

        NmpAcquireLock();

        if (hasDependents) {
            return(ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS);
        }
    }

    return(ERROR_SUCCESS);

}  // NmpValidateNetworkRoleChange


BOOLEAN
NmpVerifyNodeConnectivity(
    PNM_NODE      Node1,
    PNM_NODE      Node2,
    PNM_NETWORK   ExcludedNetwork
    )
{
    PLIST_ENTRY      ifEntry1, ifEntry2;
    PNM_NETWORK      network;
    PNM_INTERFACE    interface1, interface2;


    for (ifEntry1 = Node1->InterfaceList.Flink;
         ifEntry1 != &(Node1->InterfaceList);
         ifEntry1 = ifEntry1->Flink
        )
    {
        interface1 = CONTAINING_RECORD(
                         ifEntry1,
                         NM_INTERFACE,
                         NodeLinkage
                         );

        network = interface1->Network;

        if ( (network != ExcludedNetwork) &&
             NmpIsNetworkForInternalUse(network)
           )
        {
            for (ifEntry2 = Node2->InterfaceList.Flink;
                 ifEntry2 != &(Node2->InterfaceList);
                 ifEntry2 = ifEntry2->Flink
                )
            {
                interface2 = CONTAINING_RECORD(
                                 ifEntry2,
                                 NM_INTERFACE,
                                 NodeLinkage
                                 );

                if (interface2->Network == interface1->Network) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] nodes %1!u! & %2!u! are connected over "
                        "network %3!ws!\n",
                        Node1->NodeId,
                        Node2->NodeId,
                        OmObjectId(interface1->Network)
                        );
                    return(TRUE);
                }
            }
        }
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Nodes %1!u! & %2!u! are not connected over any internal "
        "networks\n",
        Node1->NodeId,
        Node2->NodeId
        );

    return(FALSE);

}  // NmpVerifyNodeConnectivity


BOOLEAN
NmpVerifyConnectivity(
    PNM_NETWORK   ExcludedNetwork
    )
{
    PLIST_ENTRY    node1Entry, node2Entry;
    PNM_NODE       node1, node2;


    ClRtlLogPrint(LOG_NOISE, "[NM] Verifying connectivity\n");

    for (node1Entry = NmpNodeList.Flink;
         node1Entry != &NmpNodeList;
         node1Entry = node1Entry->Flink
        )
    {
        node1 = CONTAINING_RECORD(
                         node1Entry,
                         NM_NODE,
                         Linkage
                         );

        if (NM_NODE_UP(node1)) {
            for (node2Entry = node1->Linkage.Flink;
                 node2Entry != &NmpNodeList;
                 node2Entry = node2Entry->Flink
                )
            {
                node2 = CONTAINING_RECORD(
                                 node2Entry,
                                 NM_NODE,
                                 Linkage
                                 );

                if (NM_NODE_UP(node2)) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Verifying nodes %1!u! & %2!u! are connected\n",
                        node1->NodeId,
                        node2->NodeId
                        );

                    if (!NmpVerifyNodeConnectivity(
                            node1,
                            node2,
                            ExcludedNetwork
                            )
                        )
                    {
                        return(FALSE);
                    }
                }
            }
        }
    }

    return(TRUE);

}  // NmpVerifyConnectivity


VOID
NmpIssueClusterPropertyChangeEvent(
    VOID
    )
{
    DWORD      status;
    DWORD      valueLength = 0;
    DWORD      valueSize = 0;
    PWCHAR     clusterName = NULL;


    //
    // The notification API expects a
    // cluster name to be associated with this event.
    //
    status = NmpQueryString(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_NAME,
                 REG_SZ,
                 &clusterName,
                 &valueLength,
                 &valueSize
                 );

    if (status == ERROR_SUCCESS) {
        ClusterEventEx(
            CLUSTER_EVENT_PROPERTY_CHANGE,
            EP_CONTEXT_VALID | EP_FREE_CONTEXT,
            clusterName
            );

        //
        // clusterName will be freed by the event processing code.
        //
    }
    else {
        ClRtlLogPrint(LOG_WARNING,
            "[NM] Failed to issue cluster property change event, "
            "status %1!u!.\n",
            status
            );
    }

    return;

}  // NmpIssueClusterPropertyChangeEvent


DWORD
NmpMarshallObjectInfo(
    IN  const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN  PVOID                        ObjectInfo,
    OUT PVOID *                      PropertyList,
    OUT LPDWORD                      PropertyListSize
    )
{
    DWORD   status;
    PVOID   propertyList = NULL;
    DWORD   propertyListSize = 0;
    DWORD   bytesReturned = 0;
    DWORD   bytesRequired = 0;


    status = ClRtlPropertyListFromParameterBlock(
                 PropertyTable,
                 NULL,
                 &propertyListSize,
                 (LPBYTE) ObjectInfo,
                 &bytesReturned,
                 &bytesRequired
                 );

    if (status != ERROR_MORE_DATA) {
        CL_ASSERT(status != ERROR_SUCCESS);
        return(status);
    }

    CL_ASSERT(bytesRequired > 0);

    propertyList = MIDL_user_allocate(bytesRequired);

    if (propertyList == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    propertyListSize = bytesRequired;

    status = ClRtlPropertyListFromParameterBlock(
                 PropertyTable,
                 propertyList,
                 &propertyListSize,
                 (LPBYTE) ObjectInfo,
                 &bytesReturned,
                 &bytesRequired
                 );

    if (status != ERROR_SUCCESS) {
        CL_ASSERT(status != ERROR_MORE_DATA);
        MIDL_user_free(propertyList);
    }
    else {
        CL_ASSERT(bytesReturned == propertyListSize);
        *PropertyList = propertyList;
        *PropertyListSize = bytesReturned;
    }

    return(status);

}  // NmpMarshallObjectInfo


VOID
NmpReferenceNetwork(
    PNM_NETWORK  Network
    )
{
    OmReferenceObject(Network);

    return;
}

VOID
NmpDereferenceNetwork(
    PNM_NETWORK  Network
    )
{
    OmDereferenceObject(Network);

    return;
}


PNM_NETWORK
NmpReferenceNetworkByAddress(
    LPWSTR  NetworkAddress,
    LPWSTR  NetworkMask
    )
/*++

Notes:

    Called with NM lock held.

--*/
{
    PNM_NETWORK   network;
    PLIST_ENTRY   entry;


    for ( entry = NmpNetworkList.Flink;
          entry != &NmpNetworkList;
          entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        if ((lstrcmpW(network->Address, NetworkAddress) == 0) &&
            (lstrcmpW(network->AddressMask, NetworkMask) == 0)) {
            NmpReferenceNetwork(network);

            return(network);
        }
    }

    return(NULL);

} // NmpReferenceNetworkByAddress


PNM_NETWORK
NmpReferenceNetworkByRemoteAddress(
    LPWSTR  RemoteAddress
    )
/*++

Routine Description:

    Search for the network object whose address and subnet mask
    match RemoteAddress. Reference and return that network object.

Arguments:

    RemoteAddress - remote network address

Return value:

    Reference network object, or NULL if no match found

Notes:

    Called with NM lock held.

--*/
{
    ULONG         remoteAddress;
    PNM_NETWORK   network;
    PLIST_ENTRY   entry;
    DWORD         error;

    error = ClRtlTcpipStringToAddress(RemoteAddress, &remoteAddress);
    if (error != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to parse remote address %1!ws!, error %2!u!.\n",
            RemoteAddress, error
            );
        return(NULL);
    }

    for ( entry = NmpNetworkList.Flink;
          entry != &NmpNetworkList;
          entry = entry->Flink
        )
    {
        ULONG     networkAddress;
        ULONG     networkMask;

        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        if (network->Address == NULL || network->AddressMask == NULL) {
            continue;
        }

        error = ClRtlTcpipStringToAddress(network->Address, &networkAddress);
        if (error != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to parse network address %1!ws!, error %2!u!.\n",
                network->Address, error
                );
            continue;
        }

        error = ClRtlTcpipStringToAddress(network->AddressMask, &networkMask);
        if (error != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to parse network address mask %1!ws!, error %2!u!.\n",
                network->AddressMask, error
                );
            continue;
        }

        if (ClRtlAreTcpipAddressesOnSameSubnet(
                remoteAddress,
                networkAddress,
                networkMask
                )) {
            NmpReferenceNetwork(network);
            return(network);
        }
    }

    return(NULL);

} // NmpReferenceNetworkByRemoteAddress


BOOLEAN
NmpCheckForNetwork(
    VOID
    )
/*++

Routine Description:

    Checks whether at least one network on this node configured for MSCS
    has media sense.

Arguments:

    None.

Return Value:

    TRUE if a viable network is found. FALSE otherwise.

Notes:

    Called with and returns with no locks held.

--*/
{
    PLIST_ENTRY      entry;
    PNM_NETWORK      network;
    BOOLEAN          haveNetwork = FALSE;
    DWORD            lockRetries = 3;
    BOOL             lockAcquired = FALSE;
    
    //
    // In order to examine our network interfaces, we need to 
    // acquire the NM lock, but if the NM lock is tied up for
    // a long time (e.g. a local transaction with a lost MNS
    // share), then we don't want to block arbitration forever.
    // Try to obtain the lock four times, sleeping 150 msecs before
    // retries, for a total of approximately one half second.
    // 
    lockAcquired = TryEnterCriticalSection(&NmpLock);
    while (!lockAcquired && lockRetries-- > 0) {
        Sleep(150);
        lockAcquired = TryEnterCriticalSection(&NmpLock);
    }
    
    if (!lockAcquired) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to acquire NM lock while checking "
            "networks prior to arbitration. Assuming we have "
            "network connectivity to avoid further arbitration "
            "delay.\n"
            );    
        return(TRUE);
    }

    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK,
                      Linkage
                      );

        // if a network's local interface is disabled, it is not
        // considered a viable network. in this case the
        // LocalInterface field is NULL.
        if (network->LocalInterface != NULL) {
            if (NmpVerifyLocalInterfaceConnected(network->LocalInterface)) {

                haveNetwork = TRUE;
                break;

            } else {

                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Network adapter %1!ws! with address %2!ws! "
                    "reported not connected.\n",
                    network->LocalInterface->AdapterId,
                    network->LocalInterface->Address
                    );
            }
        }
    }

    NmpReleaseLock();

    if (!haveNetwork) {
        SetLastError(ERROR_NETWORK_NOT_AVAILABLE);
    }

    return(haveNetwork);

} // NmpCheckForNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\member.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    member.c

Abstract:

    Cluster membership management routines for the Node Manager.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/


#include "nmp.h"
#include <clusrtl.h>


//
// Data
//
BOOLEAN     NmpMembershipCleanupOk = FALSE;
BITSET      NmpUpNodeSet = 0;
LIST_ENTRY  NmpLeaderChangeWaitList = {NULL, NULL};


//
// Routines
//
VOID
NmpMarkNodeUp(
    CL_NODE_ID  NodeId
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    BitsetAdd(NmpUpNodeSet, NodeId);

    return;
}


VOID
NmpNodeUpEventHandler(
    IN PNM_NODE   Node
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    NmpMarkNodeUp(Node->NodeId);

    // MM has Declared the node to be up. Reset The node down event.
    if (!ResetEvent(Node->MmNodeStateDownEvent)) {
        DWORD status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Failed to reset node down event for Node= %1!u! status= %2!u!.\n",
            Node->NodeId,
            status
            );
        CsInconsistencyHalt(status);
    }

    //
    // Don't declare the local node to be up. The join code will
    // take care of this.
    //
    if ((Node != NmLocalNode) && (Node->State == ClusterNodeJoining)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Joining node %1!u! is now participating in the cluster membership.\n",
            Node->NodeId
            );

        CL_ASSERT(NmpJoinerNodeId == Node->NodeId);
        CL_ASSERT(Node->State == ClusterNodeJoining);
        CL_ASSERT(NmpJoinTimer == 0);
        CL_ASSERT(NmpJoinAbortPending == FALSE);
        CL_ASSERT(NmpJoinerUp == FALSE);

        NmpJoinerUp = TRUE;
    }

    return;

}  // NmpNodeUpEventHandler


VOID
NmpNodeDownEventHandler(
    IN PNM_NODE   Node
    )
{
   NmpMultiNodeDownEventHandler( BitsetFromUnit(Node->NodeId) );
}


DWORD
NmpMultiNodeDownEventHandler(
    IN BITSET DownedNodeSet
    )
{
    CL_NODE_ID                    i;
    PNM_NODE                      node;
    DWORD                         status;
    BOOLEAN                       iAmNewLeader = FALSE;
    PNM_LEADER_CHANGE_WAIT_ENTRY  waitEntry;
    PLIST_ENTRY                   listEntry;


    ClRtlLogPrint(LOG_NOISE, "[NM] Down node set: %1!04X!.\n", DownedNodeSet);

    NmpAcquireLock();

    //
    // Compute the new up node set
    //
    BitsetSubtract(NmpUpNodeSet, DownedNodeSet);

    ClRtlLogPrint(LOG_NOISE, "[NM] New up node set: %1!04X!.\n", NmpUpNodeSet);

    //
    // Check for failure of a joining node.
    //
    if (NmpJoinerNodeId != ClusterInvalidNodeId) {

        if (NmpJoinerNodeId == NmLocalNodeId) {
            //
            // The joining node is the local node. Halt.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Aborting join because of change in membership.\n"
                );
            CsInconsistencyHalt(ERROR_CLUSTER_JOIN_ABORTED);
        }
        else if ( (BitsetIsMember(NmpJoinerNodeId, DownedNodeSet))
                  ||
                  ( (BitsetIsMember(NmpSponsorNodeId, DownedNodeSet)) &&
                    (!BitsetIsMember(NmpJoinerNodeId, DownedNodeSet))
                  )
                )
        {
            //
            // The joining node is down or the sponsor is down and the joiner
            // is not yet an active member. Cleanup the join state. If the
            // sponsor is down and the joiner is an active member, we will
            // clean up when we detect that the joiner has perished.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Aborting join of node %1!u! sponsored by node %2!u!\n",
                NmpJoinerNodeId,
                NmpSponsorNodeId
                );

	        //
	        // Reset joiner state if sponsor died
	        //
            if (BitsetIsMember(NmpSponsorNodeId, DownedNodeSet)) {
                node = NmpIdArray[NmpJoinerNodeId];
                node->State = ClusterNodeDown;
                // [GorN 4/3/2000] 
                // Without a node down, cluadmin won't refresh the state.
                // If this code is to be changed to emit CLUSTER_NODE_CHANGE_EVENT or
                // some other event, NmpUpdateJoinAbort has to be changed as well,
                // so that we will have the same join cleanup behavior 
                BitsetAdd(DownedNodeSet, NmpJoinerNodeId);
            }

            NmpJoinerNodeId = ClusterInvalidNodeId;
            NmpSponsorNodeId = ClusterInvalidNodeId;
            NmpJoinTimer = 0;
            NmpJoinAbortPending = FALSE;
            NmpJoinSequence = 0;
            NmpJoinerUp = FALSE;
            NmpJoinerOutOfSynch = FALSE;
        }
        else {
            //
            // Mark that the joiner is out of synch with the cluster
            // state. The sponsor will eventually abort the join.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Joiner node %1!u! is now out of synch with the cluster state.\n",
                NmpJoinerNodeId
                );
            NmpJoinerOutOfSynch = TRUE;
        }
    }

    //
    // Check if the leader node went down
    //
    if (BitsetIsMember(NmpLeaderNodeId, DownedNodeSet)) {
        BOOL  isEventSet;

        //
        // Elect a new leader - active node with the smallest ID.
        //
        for (i = ClusterMinNodeId; i <= NmMaxNodeId; i++) {
            if (BitsetIsMember(i, NmpUpNodeSet)) {
                NmpLeaderNodeId = i;
                break;
            }
        }

        CL_ASSERT(i <= NmMaxNodeId);

        if (NmpLeaderNodeId == NmLocalNodeId) {
            //
            // The local node is the new leader.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] This node is the new leader.\n"
                );

            iAmNewLeader = TRUE;
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Node %1!u! is the new leader.\n",
                NmpLeaderNodeId
                );
        }

        //
        // Wake up any threads waiting for an RPC call to the leader to
        // complete.
        //
        while (!IsListEmpty(&NmpLeaderChangeWaitList)) {
            listEntry = RemoveHeadList(&NmpLeaderChangeWaitList);

            //
            // NULL out the entry's links to indicate that it has been
            // dequeued. The users of the notification feature depend
            // on this action.
            //
            listEntry->Flink = NULL; listEntry->Blink = NULL;

            //
            // Wake up the waiting thread.
            //
            waitEntry = (PNM_LEADER_CHANGE_WAIT_ENTRY) listEntry;
            isEventSet = SetEvent(waitEntry->LeaderChangeEvent);
            CL_ASSERT(isEventSet != 0);
        }
    }

    //
    // First recovery pass - clean up node states and disable communication
    //
    for (i = ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        node = NmpIdArray[i];

        if ( (node != NULL) && (BitsetIsMember(i, DownedNodeSet)) ) {
            node->State = ClusterNodeDown;

            //MM has declared the node to be down. Set the node down event.
            if (!SetEvent(node->MmNodeStateDownEvent)) {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NMJOIN] Failed to set node down event for Node= %1!u! status= %2!u!.\n",
                    node->NodeId,
                    status
                    );
                CsInconsistencyHalt(status);
            }
            
            status = ClusnetOfflineNodeComm(
                         NmClusnetHandle,
                         node->NodeId
                         );

            CL_ASSERT(
                (status == ERROR_SUCCESS) ||
                (status == ERROR_CLUSTER_NODE_ALREADY_DOWN)
                );
        }
    }

    //
    // Inform the rest of the service that these nodes are gone
    //
    ClusterEventEx(
        CLUSTER_EVENT_NODE_DOWN_EX,
        EP_CONTEXT_VALID,
        ULongToPtr(DownedNodeSet)
        );

    //
    // Second recovery pass - clean up network states and issue old-style
    // node down events
    //
    for (i = ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        node = NmpIdArray[i];

        if ( (node != NULL) && (BitsetIsMember(i, DownedNodeSet)) ) {
            //
            // Issue an individual node down event.
            //
            ClusterEvent(CLUSTER_EVENT_NODE_DOWN, node);

            //
            // Now do Intracluster RPC cleanup...
            //
            NmpTerminateRpcsToNode(node->NodeId);

            //
            // Update the network and interface information.
            //
            NmpUpdateNetworkConnectivityForDownNode(node);

            //
            // Log an event
            //
            if (NmpLeaderNodeId == NmLocalNodeId) {
                LPCWSTR nodeName = OmObjectName(node);

                CsLogEvent1(
                    LOG_UNUSUAL,
                    NM_EVENT_NODE_DOWN,
                    nodeName
                    );
            }
        }
    }

    //
    // If this node is the new leader, schedule a state computation for all
    // networks. State reports may have been received before this node
    // assumed leadership duties.
    //
    if (iAmNewLeader) {
        NmpRecomputeNT5NetworkAndInterfaceStates();
    }

    NmpReleaseLock();

    return(ERROR_SUCCESS);

}  // NmpNodesDownEventHandler //



DWORD
NmpNodeChange(
    IN DWORD NodeId,
    IN NODESTATUS NewStatus
    )
{
    PNM_NODE  node;


    CL_ASSERT(
        (NodeId >= ClusterMinNodeId) &&
        (NodeId <= NmMaxNodeId)
        );

    NmpAcquireLock();

    node = NmpIdArray[NodeId];

    CL_ASSERT(node != NULL);

    if (node != NULL) {
        if (NewStatus == NODE_DOWN) {
           NmpNodeDownEventHandler(node);
        }
        else {
            CL_ASSERT(NewStatus == NODE_UP);
            NmpNodeUpEventHandler(node);
        }
    }

    NmpReleaseLock();

    return(ERROR_SUCCESS);

}  // NmpNodeChange


VOID
NmpHoldIoEventHandler(
    VOID
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Holding I/O.\n"
        );
#if defined(HOLD_IO_IS_SAFE_NOW)
    FmHoldIO();
#endif

    return;
}


VOID
NmpResumeIoEventHandler(
    VOID
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Resuming I/O.\n"
        );
#if defined(HOLD_IO_IS_SAFE_NOW)
    FmResumeIO();
#endif

    return;
}


BOOL
NmpCheckQuorumEventHandler(
    VOID
    )
{
    BOOL                       haveQuorum;

    //
    // daviddio 06/19/2000
    // 
    // Before asking FM to arbitrate, determine if we have any
    // viable network interfaces. If not, return failure to MM
    // and allow other cluster nodes to arbitrate. The SCM
    // will restart the cluster service, so that if no nodes
    // successfully arbitrate, we will get another shot.
    //
    if (NmpCheckForNetwork()) {

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Checking if we own the quorum resource.\n"
            );

        haveQuorum = FmArbitrateQuorumResource();

        if (haveQuorum) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] We own the quorum resource.\n"
                );
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] We do not own the quorum resource, status %1!u!.\n",
                GetLastError()
                );

            //[GN] ClusnetHalt( NmClusnetHandle ); => NmpHaltEventHandler
            //
        }
    
    } else {

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Abdicating quorum because no valid network "
            "interfaces were detected.\n"
            );
        haveQuorum = FALSE;
    }


    return(haveQuorum);

}  // NmpCheckQuorumEventHandler


void
NmpMsgCleanup1(
    IN DWORD DeadNodeId
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Phase 1 message cleanup - node %1!u!.\n",
        DeadNodeId
        );

    return;
}


void
NmpMsgCleanup2(
    IN BITSET DownedNodeSet
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Phase 2 message cleanup - node %1!04X!.\n",
        DownedNodeSet
        );

    NmpAcquireLock();
    if ( NmpCleanupIfJoinAborted &&
         (NmpJoinerNodeId != ClusterInvalidNodeId) &&
         BitsetIsMember(NmpJoinerNodeId, DownedNodeSet) )
    {
        //
        // Since the joiner is in the DownedNodeSet mask
        // the node down will be delivered on this node by a regroup engine.
        // No need for NmpUpdateAbortJoin to issue a node down.
        //
        NmpCleanupIfJoinAborted = FALSE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] NmpCleanupIfJoinAborted is set to false. Joiner - %1!u!.\n",
            NmpJoinerNodeId
            );
    }
    NmpReleaseLock();

    //
    // Inform the rest of the service that these nodes are gone
    //
    ClusterSyncEventEx(
        CLUSTER_EVENT_NODE_DOWN_EX,
        EP_CONTEXT_VALID,
        ULongToPtr(DownedNodeSet)
        );

    return;
}


VOID
NmpHaltEventHandler(
    IN DWORD HaltCode
    )
{
    WCHAR  string[16];

    // Do a graceful stop if we are shutting down //

    if (HaltCode == MM_STOP_REQUESTED) {
        DWORD Status = ERROR_SUCCESS;
    
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Prompt shutdown is requested by a membership engine\n"
            );
        ClusnetHalt( NmClusnetHandle );

        CsLogEvent(LOG_NOISE, SERVICE_SUCCESSFUL_TERMINATION);

        CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CsServiceStatus.dwControlsAccepted = 0;
        CsServiceStatus.dwCheckPoint = 0;
        CsServiceStatus.dwWaitHint = 0;
        CsServiceStatus.dwWin32ExitCode = Status;
        CsServiceStatus.dwServiceSpecificExitCode = Status;

        CsAnnounceServiceStatus();

        ExitProcess(Status);

    } else {

        wsprintfW(&(string[0]), L"%u", HaltCode);

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Halting this node due to membership or communications error. Halt code = %1!u!\n",
            HaltCode
            );

        ClusnetHalt( NmClusnetHandle );

        //
        // Adjust membership code to win32 error code. (If mapping exits)
        //

        HaltCode = MMMapHaltCodeToDosError( HaltCode );

        CsInconsistencyHalt(HaltCode);
    }        
}


void
NmpJoinFailed(
    void
    )
{
    return;
}



DWORD
NmpGumUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )
/*++

Routine Description:

    Handles GUM updates for membership events.

Arguments:

    Context - Supplies the update context. This is the message type

    SourceNode - Supplies whether or not the update originated on this node.

    BufferLength - Supplies the length of the update.

    Buffer - Supplies a pointer to the buffer.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD status;


    if (Context == NmUpdateJoinComplete) {
        status = NmpUpdateJoinComplete(Buffer);
    }
    else {
        status = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Discarding unknown gum request %1!u!\n",
            Context
            );
    }

    return(status);

}  // NmpUpdateGumHandler


DWORD
NmpMembershipInit(
    VOID
    )
{
    DWORD           status;


    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing membership...\n");

    InitializeListHead(&NmpLeaderChangeWaitList);

    //
    // Initialize membership engine.
    //
    status = MMInit(
                 NmLocalNodeId,
                 NmMaxNodes,
                 NmpNodeChange,
                 NmpCheckQuorumEventHandler,
                 NmpHoldIoEventHandler,
                 NmpResumeIoEventHandler,
                 NmpMsgCleanup1,
                 NmpMsgCleanup2,
                 NmpHaltEventHandler,
                 NmpJoinFailed,
                 NmpMultiNodeDownEventHandler
                 );

    if (status != MM_OK) {
        status = MMMapStatusToDosError(status);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Membership initialization failed, status %1!u!.\n",
            status
            );
        return(status);
    }

    NmpMembershipCleanupOk = TRUE;

    ClRtlLogPrint(LOG_NOISE,"[NM] Membership initialization complete.\n");

    return(ERROR_SUCCESS);

}  // NmpMembershipInit


VOID
NmpMembershipShutdown(
    VOID
    )
{
    if (NmpMembershipCleanupOk) {
        ClRtlLogPrint(LOG_NOISE,"[NM] Shutting down membership...\n");

        MMShutdown();

        NmpMembershipCleanupOk = FALSE;

        ClRtlLogPrint(LOG_NOISE,"[NM] Membership shutdown complete.\n");
    }

    return;

}  // NmpMembershipShutdown
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\netioctl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netioctl.c

Abstract:

    Network control functions.

Author:

    John Vert (jvert) 2-Mar-1997

Revision History:

--*/

#include "nmp.h"

//
// Network Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNetworkCommonProperties[] =
    {
        {
            CLUSREG_NAME_NET_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Description)
        },
        {
            CLUSREG_NAME_NET_ROLE, NULL, CLUSPROP_FORMAT_DWORD,
            ClusterNetworkRoleClientAccess,
            ClusterNetworkRoleNone,
            ClusterNetworkRoleInternalAndClient,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Role)
        },
        {
            0
        }
    };

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNetworkROCommonProperties[] =
    {
        {
            CLUSREG_NAME_NET_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_INFO, Name)
        },
        {
            CLUSREG_NAME_NET_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_INFO, Address)
            },
        {
            CLUSREG_NAME_NET_ADDRESS_MASK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_INFO, AddressMask)
        },
        {
            0
        }
    };

//
// Cluster registry API function pointers.
// defined in ioctl.c
//
extern CLUSTER_REG_APIS NmpClusterRegApis;


//
// Local Functions
//

DWORD
NmpNetworkControl(
    IN PNM_NETWORK Network,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkGetCommonProperties(
    IN PNM_NETWORK Network,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkValidateCommonProperties(
    IN  PNM_NETWORK               Network,
    IN  PVOID                     InBuffer,
    IN  DWORD                     InBufferSize,
    OUT PNM_NETWORK_INFO          NetworkInfo  OPTIONAL
    );

DWORD
NmpNetworkSetCommonProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNetworkEnumPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkGetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkValidatePrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNetworkSetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNetworkGetFlags(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD
WINAPI
NmNetworkControl(
    IN PNM_NETWORK Network,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    Network - Supplies the network to be controlled.

    HostNode - Supplies the host node on which the resource control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // Cluster service ioctls were designed to have access modes, e.g.
    // read-only, read-write, etc. These access modes are not implemented.
    // If eventually they are implemented, an access mode check should be
    // placed here.
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_NETWORK ) {
        return(ERROR_INVALID_FUNCTION);
    }

    if (NmpEnterApi(NmStateOnline)) {
        status = NmpNetworkControl(
                     Network,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process NetworkControl request.\n"
            );
    }

    return(status);

} // NmNetworkControl



DWORD
NmpNetworkControl(
    IN PNM_NETWORK Network,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    Network - Supplies the network to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    HDMKEY  networkKey;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    networkKey = DmOpenKey( DmNetworksKey,
                            OmObjectId( Network ),
                            MAXIMUM_ALLOWED
                        );
    if ( networkKey == NULL ) {
        return(GetLastError());
    }

    switch ( ControlCode ) {

    case CLUSCTL_NETWORK_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_NETWORK_GET_NAME:
        if ( OmObjectName( Network ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectName( Network ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectName( Network ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_GET_ID:
        if ( OmObjectId( Network ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectId( Network ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectId( Network ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_ENUM_COMMON_PROPERTIES:
        status = NmpNetworkEnumCommonProperties(
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES:
        status = NmpNetworkGetCommonProperties(
                     Network,
                     TRUE, // ReadOnly
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_GET_COMMON_PROPERTIES:
        status = NmpNetworkGetCommonProperties(
                     Network,
                     FALSE, // ReadOnly
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES:
        NmpAcquireLock();

        status = NmpNetworkValidateCommonProperties(
                     Network,
                     InBuffer,
                     InBufferSize,
                     NULL
                     );

        NmpReleaseLock();

        break;

    case CLUSCTL_NETWORK_SET_COMMON_PROPERTIES:
        status = NmpNetworkSetCommonProperties(
                     Network,
                     networkKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES:
        status = NmpNetworkGetPrivateProperties(
                     Network,
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES:
        status = NmpNetworkValidatePrivateProperties(
                     Network,
                     networkKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES:
        status = NmpNetworkSetPrivateProperties(
                     Network,
                     networkKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETWORK_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_GET_FLAGS:
        status = NmpNetworkGetFlags(
                     Network,
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_ENUM_PRIVATE_PROPERTIES:
        status = NmpNetworkEnumPrivateProperties(
                     Network,
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    DmCloseKey( networkKey );

    return(status);

} // NmpNetworkControl



DWORD
NmpNetworkEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given network.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties( NmpNetworkCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // NmpNetworkEnumCommonProperties



DWORD
NmpNetworkGetCommonProperties(
    IN PNM_NETWORK Network,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given network.

Arguments:

    Network - Supplies the network.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    RegistryKey - Supplies the registry key for this network.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    NM_NETWORK_INFO         networkInfo;
    PRESUTIL_PROPERTY_ITEM  propertyTable;
    DWORD                   outBufferSize = OutBufferSize;


    //
    // Fetch the properties from the object
    //
    ZeroMemory(&networkInfo, sizeof(networkInfo));

    NmpAcquireLock();

    status = NmpGetNetworkObjectInfo(Network, &networkInfo);

    NmpReleaseLock();

    if (status == ERROR_SUCCESS) {

        if ( ReadOnly ) {
            propertyTable = NmpNetworkROCommonProperties;
        }
        else {
            propertyTable = NmpNetworkCommonProperties;
        }

        status = ClRtlPropertyListFromParameterBlock(
                     propertyTable,
                     OutBuffer,
                     &outBufferSize,
                     (LPBYTE) &networkInfo,
                     BytesReturned,
                     Required
                     );

        ClNetFreeNetworkInfo(&networkInfo);
    }

    return(status);

} // NmpNetworkGetCommonProperties



DWORD
NmpNetworkValidateCommonProperties(
    IN  PNM_NETWORK               Network,
    IN  PVOID                     InBuffer,
    IN  DWORD                     InBufferSize,
    OUT PNM_NETWORK_INFO          NetworkInfo  OPTIONAL
    )

/*++

Routine Description:

    Validates the common properties for a given network.

Arguments:

    Network - Supplies the network object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

    NetworkInfo - On output, contains a pointer to a network 
                  information structure with the updates applied.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                    status;
    NM_NETWORK_INFO          infoBuffer;
    PNM_NETWORK_INFO         networkInfo;
    LPCWSTR                  networkId = OmObjectId(Network);


    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    if (NetworkInfo != NULL) {
        networkInfo = NetworkInfo;
    }
    else {
        networkInfo = &infoBuffer;
    }

    ZeroMemory(networkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Get a copy of the current network parameters.
    //
    status = NmpGetNetworkObjectInfo(Network, networkInfo);

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Validate the property list and update the parameter block.
    //
    status = ClRtlVerifyPropertyTable(
                 NmpNetworkCommonProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) networkInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] ValidateCommonProperties, error in verify routine.\n"
            );
        goto error_exit;
    }

    CL_ASSERT(networkInfo->Role <= ClusterNetworkRoleInternalAndClient);

    //
    // If the role changed, ensure that the change is legal for this cluster.
    //
    if (Network->Role != ((CLUSTER_NETWORK_ROLE) networkInfo->Role)) {
        status = NmpValidateNetworkRoleChange(
                     Network,
                     networkInfo->Role
                     );

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    //
    // The change is valid.
    //

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if ((status != ERROR_SUCCESS) || (networkInfo == &infoBuffer)) {
        ClNetFreeNetworkInfo(networkInfo);
    }

    return(status);

} // NmpNetworkValidateCommonProperties



DWORD
NmpNetworkSetCommonProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given network.

Arguments:

    Network - Supplies the network object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Setting common properties for network %1!ws!.\n",
        networkId
        );

    //
    // Issue a global update
    //
    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateSetNetworkCommonProperties,
                 3,
                 NM_WCSLEN(networkId),
                 networkId,
                 InBufferSize,
                 InBuffer,
                 sizeof(InBufferSize),
                 &InBufferSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Global update to set common properties for network %1!ws! failed, status %2!u!.\n",
            networkId,
            status
            );
    }


    return(status);

} // NmpNetworkSetCommonProperties



DWORD
NmpNetworkEnumPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given network.

Arguments:

    Network - Supplies the network object.

    RegistryKey - Registry key for the network.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster network parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enum private properties for the network.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &NmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNetworkEnumPrivateProperties



DWORD
NmpNetworkGetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given network.

Arguments:

    Network - Supplies the network object.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster network parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the network.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &NmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNetworkGetPrivateProperties



DWORD
NmpNetworkValidatePrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given network.

Arguments:

    Network - Supplies the network object.

    RegistryKey - Registry key for the network.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // NmpNetworkValidatePrivateProperties



DWORD
NmpNetworkSetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given network.

Arguments:

    Network - Supplies the network object.

    RegistryKey - Registry key for the network.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;
    BOOLEAN     setProperties = TRUE;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Validate any multicast parameters being set.
        //
        status = NmpMulticastValidatePrivateProperties(
                     Network,
                     RegistryKey,
                     InBuffer,
                     InBufferSize
                     );
        if (status == ERROR_SUCCESS) {

            //
            // Open the cluster network\xx\parameters key
            //
            parametersKey = DmOpenKey( RegistryKey,
                                       CLUSREG_KEYNAME_PARAMETERS,
                                       MAXIMUM_ALLOWED );
            if ( parametersKey == NULL ) {
                status = GetLastError();
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    //
                    // Try to create the parameters key.
                    //
                    parametersKey = DmCreateKey( RegistryKey,
                                                 CLUSREG_KEYNAME_PARAMETERS,
                                                 0,
                                                 KEY_READ | KEY_WRITE,
                                                 NULL,
                                                 &disposition );
                    if ( parametersKey == NULL ) {
                        status = GetLastError();
                        return(status);
                    }
                }
            }

            NmpMulticastManualConfigChange(
                Network,
                RegistryKey,
                parametersKey,
                InBuffer,
                InBufferSize,
                &setProperties
                );
            
            if (setProperties) {
                status = ClRtlSetPrivatePropertyList( 
                             NULL, // IN HANDLE hXsaction
                             parametersKey,
                             &NmpClusterRegApis,
                             InBuffer,
                             InBufferSize
                             );
            }

            DmCloseKey( parametersKey );
        }
    }

    return(status);

} // NmpNetworkSetPrivateProperties



DWORD
NmpNetworkGetFlags(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given network.

Arguments:

    Network - Supplies the network.

    RegistryKey - Registry key for the network.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the network.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // NmpNetworkGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\mcast.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    mcast.c

Abstract:

    Implements the Node Manager's network multicast management routines.

    The multicast configuration is stored separately for each network in
    three different places:

    1. Cluster database:

        The cluster database is the persistent configuration. It does
        not include the key, which is secret, short-lived, and never
        written to stable storage. The cluster database is updated on
        each GUM update with the new state.

    2. Network data structure:

        The network data structure contains what amounts to a cache of
        the cluster database. So, for instance, the address in the
        network data structure should match the address in the database
        (provided there has been at least one multicast config/refresh
        so that the cache is "primed"). The network also contains non-
        persistent data, such as the current key and timers. For
        example, both the database and network store the lease
        expiration time, but only the network contains the timer that
        ticks down.

    3. ClusNet:

        ClusNet stores in kernel nonpaged pool only the most basic
        configuration for each network needed to send and receive
        multicast traffic. This includes the address and the key (and
        the brand). Actually, in order to accomodate transitions,
        ClusNet also stores the previous <address, key, brand>. The
        address stored by ClusNet may differ from that in the network
        data structure and the cluster database. The reason is that
        ClusNet has no notion of, for instance, disabling multicast.
        The service implements disabling by sending a 0.0.0.0
        multicast address to ClusNet.

    The cluster database is only modified in the multicast config
    GUM update (except for private property changes from down-level
    nodes, but that is an edge case).

    The network data structure and ClusNet can be modified either in
    the GUM update or in a refresh. Refresh happens during join or by
    non-leaders when a network suddenly becomes multicast-ready (e.g.
    new network created, number of nodes increases to three, etc.).
    Refresh only reads the config from the database. It does not seek
    leases, etc., unless it becomes NM leader during refresh and must
    generate a new multicast key.

Author:

    David Dion (daviddio) 15-Mar-2001


Revision History:

--*/


#include "nmp.h"
#include <align.h>


/////////////////////////////////////////////////////////////////////////////
//
// Constants
//
/////////////////////////////////////////////////////////////////////////////


//
// Lease status.
//
typedef enum {
    NmMcastLeaseValid = 0,
    NmMcastLeaseNeedsRenewal,
    NmMcastLeaseExpired
} NM_MCAST_LEASE_STATUS, *PNM_MCAST_LEASE_STATUS;

#define CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST L"MulticastClusterDisabled"

#define CLUSREG_NAME_NET_MULTICAST_ADDRESS     L"MulticastAddress"
#define CLUSREG_NAME_NET_DISABLE_MULTICAST     L"MulticastDisabled"
#define CLUSREG_NAME_NET_MULTICAST_KEY_SALT    L"MulticastSalt"
#define CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED  L"MulticastLeaseObtained"
#define CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES   L"MulticastLeaseExpires"
#define CLUSREG_NAME_NET_MCAST_REQUEST_ID      L"MulticastRequestId"
#define CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS  L"MulticastLeaseServer"
#define CLUSREG_NAME_NET_MCAST_CONFIG_TYPE     L"MulticastConfigType"
#define CLUSREG_NAME_NET_MCAST_RANGE_LOWER     L"MulticastAddressRangeLower"
#define CLUSREG_NAME_NET_MCAST_RANGE_UPPER     L"MulticastAddressRangeUpper"

#define NMP_MCAST_DISABLED_DEFAULT          0           // NOT disabled

#define NMP_SINGLE_SOURCE_SCOPE_ADDRESS     0x000000E8  // (232.*.*.*)
#define NMP_SINGLE_SOURCE_SCOPE_MASK        0x000000FF  // (255.0.0.0)

#define NMP_LOCAL_SCOPE_ADDRESS             0x0000FFEF  // (239.255.*.*)
#define NMP_LOCAL_SCOPE_MASK                0x0000FFFF  // (255.255.*.*)

#define NMP_ORG_SCOPE_ADDRESS               0x0000C0EF  // (239.192.*.*)
#define NMP_ORG_SCOPE_MASK                  0x0000FCFF  // (255.63.*.*)

#define NMP_MCAST_DEFAULT_RANGE_LOWER       0x0000FFEF  // (239.255.0.0)
#define NMP_MCAST_DEFAULT_RANGE_UPPER       0xFFFEFFEF  // (239.255.254.255)

#define NMP_MCAST_LEASE_RENEWAL_THRESHOLD   300         // 5 minutes
#define NMP_MCAST_LEASE_RENEWAL_WINDOW      1800        // 30 minutes
#define NMP_MADCAP_REQUERY_PERDIOD          3600 * 24   // 1 day

#define NMP_MCAST_CONFIG_STABILITY_DELAY    5 * 1000    // 5 seconds

#define NMP_MCAST_REFRESH_RENEW_DELAY       5 * 60 * 1000  // 5 minutes

//
// Minimum cluster node count in which to run multicast
//
#define NMP_MCAST_MIN_CLUSTER_NODE_COUNT    3

//
// MADCAP lease request/response buffer sizes. These sizes are based on
// IPv4 addresses.
//
#define NMP_MADCAP_REQUEST_BUFFER_SIZE \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_REQUEST),TYPE_ALIGNMENT(DWORD)) + \
         sizeof(DWORD))

#define NMP_MADCAP_REQUEST_ADDR_OFFSET \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_REQUEST),TYPE_ALIGNMENT(DWORD)))

#define NMP_MADCAP_RESPONSE_BUFFER_SIZE \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_RESPONSE),TYPE_ALIGNMENT(DWORD)) + \
         sizeof(DWORD))

#define NMP_MADCAP_RESPONSE_ADDR_OFFSET \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_RESPONSE),TYPE_ALIGNMENT(DWORD)))

//
// Avoid trying to free a global NM string.
//
#define NMP_GLOBAL_STRING(_string)               \
    (((_string) == NmpNullMulticastAddress) ||   \
     ((_string) == NmpNullString))

//
// Conditions in which we release an address.
//
#define NmpNeedRelease(_Address, _Server, _RequestId, _Expires)    \
    (((_Address) != NULL) &&                                       \
     (NmpMulticastValidateAddress(_Address)) &&                    \
     ((_Server) != NULL) &&                                        \
     ((_RequestId)->ClientUID != NULL) &&                          \
     ((_RequestId)->ClientUIDLength != 0) &&                       \
     ((_Expires) != 0))

//
// Convert IPv4 addr DWORD into four arguments for a printf/log routine.
//
#define NmpIpAddrPrintArgs(_ip) \
    ((_ip >> 0 ) & 0xff),       \
    ((_ip >> 8 ) & 0xff),       \
    ((_ip >> 16) & 0xff),       \
    ((_ip >> 24) & 0xff)


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////

LPWSTR                 NmpNullMulticastAddress = L"0.0.0.0";
BOOLEAN                NmpMadcapClientInitialized = FALSE;
BOOLEAN                NmpIsNT5NodeInCluster = FALSE;
BOOLEAN                NmpMulticastIsNotEnoughNodes = FALSE;
BOOLEAN                NmpMulticastRunInitialConfig = FALSE;

// MADCAP lease release node.
typedef struct _NM_NETWORK_MADCAP_ADDRESS_RELEASE {
    LIST_ENTRY             Linkage;
    LPWSTR                 McastAddress;
    LPWSTR                 ServerAddress;
    MCAST_CLIENT_UID       RequestId;
} NM_NETWORK_MADCAP_ADDRESS_RELEASE, *PNM_NETWORK_MADCAP_ADDRESS_RELEASE;

// Data structure for GUM update
typedef struct _NM_NETWORK_MULTICAST_UPDATE {
    DWORD                  Disabled;
    DWORD                  AddressOffset;
    DWORD                  EncryptedMulticastKeyOffset;
    DWORD                  EncryptedMulticastKeyLength;
    DWORD                  SaltOffset;
    DWORD                  SaltLength;
    DWORD                  MACOffset;
    DWORD                  MACLength;
    time_t                 LeaseObtained;
    time_t                 LeaseExpires;
    DWORD                  LeaseRequestIdOffset;
    DWORD                  LeaseRequestIdLength;
    DWORD                  LeaseServerOffset;
    NM_MCAST_CONFIG        ConfigType;
} NM_NETWORK_MULTICAST_UPDATE, *PNM_NETWORK_MULTICAST_UPDATE;

// Data structure for multicast parameters, converted to and from the
// GUM update data structure
typedef struct _NM_NETWORK_MULTICAST_PARAMETERS {
    DWORD                  Disabled;
    LPWSTR                 Address;
    PVOID                  Key;
    DWORD                  KeyLength;
    DWORD                  MulticastKeyExpires;
    time_t                 LeaseObtained;
    time_t                 LeaseExpires;
    MCAST_CLIENT_UID       LeaseRequestId;
    LPWSTR                 LeaseServer;
    NM_MCAST_CONFIG        ConfigType;
} NM_NETWORK_MULTICAST_PARAMETERS, *PNM_NETWORK_MULTICAST_PARAMETERS;

// Data structure for multicast property validation
typedef struct _NM_NETWORK_MULTICAST_INFO {
    LPWSTR                  MulticastAddress;
    DWORD                   MulticastDisable;
    PVOID                   MulticastSalt;
    DWORD                   MulticastLeaseObtained;
    DWORD                   MulticastLeaseExpires;
    PVOID                   MulticastLeaseRequestId;
    LPWSTR                  MulticastLeaseServer;
    DWORD                   MulticastConfigType;
    LPWSTR                  MulticastAddressRangeLower;
    LPWSTR                  MulticastAddressRangeUpper;
} NM_NETWORK_MULTICAST_INFO, *PNM_NETWORK_MULTICAST_INFO;

RESUTIL_PROPERTY_ITEM
NmpNetworkMulticastProperties[] =
    {
        {
            CLUSREG_NAME_NET_MULTICAST_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0, // no flags - multicast address is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastAddress)
        },
        {
            CLUSREG_NAME_NET_DISABLE_MULTICAST, NULL, CLUSPROP_FORMAT_DWORD,
            NMP_MCAST_DISABLED_DEFAULT, 0, 0xFFFFFFFF,
            0, // no flags - disable is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastDisable)
        },
        {
            CLUSREG_NAME_NET_MULTICAST_KEY_SALT, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastSalt)
        },
        {
            CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, MAXLONG,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseObtained)
        },
        {
            CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, MAXLONG,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseExpires)
        },
        {
            CLUSREG_NAME_NET_MCAST_REQUEST_ID, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseRequestId)
        },
        {
            CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseServer)
        },
        {
            CLUSREG_NAME_NET_MCAST_CONFIG_TYPE, NULL, CLUSPROP_FORMAT_DWORD,
            NmMcastConfigManual, NmMcastConfigManual, NmMcastConfigAuto,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastConfigType)
        },
        {
            CLUSREG_NAME_NET_MCAST_RANGE_LOWER, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0, // no flags - multicast address range is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastAddressRangeLower)
        },
        {
            CLUSREG_NAME_NET_MCAST_RANGE_UPPER, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0, // no flags - multicast address range is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastAddressRangeUpper)
        },
        {
            0
        }
    };

//
// Cluster registry API function pointers. Need a separate collection
// of function pointers for multicast because nobody else (e.g. FM, NM)
// fills in DmLocalXXX.
//
CLUSTER_REG_APIS
NmpMcastClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    (PFNCLRTLLOCALCREATEKEY) DmLocalCreateKey,
    (PFNCLRTLLOCALSETVALUE) DmLocalSetValue,
    (PFNCLRTLLOCALDELETEVALUE) DmLocalDeleteValue
};

//
// Restricted ranges: we cannot choose a multicast address out of these
// ranges, even if an administrator defines a selection range that
// overlaps with a restricted range.
//
// Note, however, that if an administrator manually configures an
// address, we accept it without question.
//
struct _NM_MCAST_RESTRICTED_RANGE {
    DWORD   Lower;
    DWORD   Upper;
    LPWSTR  Description;
} NmpMulticastRestrictedRange[] =
    {
        // single-source scope
        { NMP_SINGLE_SOURCE_SCOPE_ADDRESS,
            NMP_SINGLE_SOURCE_SCOPE_ADDRESS | ~NMP_SINGLE_SOURCE_SCOPE_MASK,
            L"Single-Source IP Multicast Address Range" },

        // upper /24 of admin local scope
        { (NMP_LOCAL_SCOPE_ADDRESS | ~NMP_LOCAL_SCOPE_MASK) & 0x00FFFFFF,
            NMP_LOCAL_SCOPE_ADDRESS | ~NMP_LOCAL_SCOPE_MASK,
            L"Administrative Local Scope Relative Assignment Range" },

        // upper /24 of admin organizational scope
        { (NMP_ORG_SCOPE_ADDRESS | ~NMP_ORG_SCOPE_MASK) & 0x00FFFFFF,
            NMP_ORG_SCOPE_ADDRESS | ~NMP_ORG_SCOPE_MASK,
            L"Administrative Organizational Scope Relative Assignment Range" }
    };

DWORD NmpMulticastRestrictedRangeCount =
          sizeof(NmpMulticastRestrictedRange) /
          sizeof(struct _NM_MCAST_RESTRICTED_RANGE);

//
// Range intervals: intervals in the IPv4 class D address space
// from which we can choose an address.
//
typedef struct _NM_MCAST_RANGE_INTERVAL {
    LIST_ENTRY Linkage;
    DWORD      hlLower;
    DWORD      hlUpper;
} NM_MCAST_RANGE_INTERVAL, *PNM_MCAST_RANGE_INTERVAL;

#define NmpMulticastRangeIntervalSize(_interval) \
    ((_interval)->hlUpper - (_interval)->hlLower + 1)


/////////////////////////////////////////////////////////////////////////////
//
// Internal prototypes
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpScheduleNetworkMadcapWorker(
    PNM_NETWORK   Network
    );

DWORD
NmpReconfigureMulticast(
    IN PNM_NETWORK        Network
    );

DWORD
NmpRegenerateMulticastKey(
    IN OUT PNM_NETWORK        Network
    );

/////////////////////////////////////////////////////////////////////////////
//
// Initialization & cleanup routines
//
/////////////////////////////////////////////////////////////////////////////

VOID
NmpMulticastInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize multicast readiness variables.

--*/
{
    //
    // Figure out if this is a mixed NT5/NT5.1 cluster.
    //
    if (CLUSTER_GET_MAJOR_VERSION(CsClusterHighestVersion) == 3) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Enabling mixed NT5/NT5.1 operation.\n"
            );
        NmpIsNT5NodeInCluster = TRUE;
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Disabling mixed NT5/NT5.1 operation.\n"
            );
        NmpIsNT5NodeInCluster = FALSE;
    }

    //
    // Figure out if there are enough nodes in this cluster
    // to run multicast.
    //
    if (NmpNodeCount < NMP_MCAST_MIN_CLUSTER_NODE_COUNT) {
        NmpMulticastIsNotEnoughNodes = TRUE;
    } else {
        NmpMulticastIsNotEnoughNodes = FALSE;
    }

    return;

} // NmpMulticastInitialize


DWORD
NmpMulticastCleanup(
    VOID
    )
/*++

Notes:

    Called with NM lock held.

--*/
{
    //
    // Cleanup the MADCAP client.
    //
    if (NmpMadcapClientInitialized) {
        McastApiCleanup();
        NmpMadcapClientInitialized = FALSE;
    }

    return(ERROR_SUCCESS);

} // NmpMulticastCleanup

/////////////////////////////////////////////////////////////////////////////
//
// Internal routines.
//
/////////////////////////////////////////////////////////////////////////////

#if CLUSTER_BETA
LPWSTR
NmpCreateLogString(
    IN   PVOID  Source,
    IN   DWORD  SourceLength
    )
{
    PWCHAR displayBuf, bufp;
    PCHAR  chp;
    DWORD  x, i;

    displayBuf = LocalAlloc(
                     LMEM_FIXED | LMEM_ZEROINIT,
                     SourceLength * ( 7 * sizeof(WCHAR) )
                     );
    if (displayBuf == NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to allocate display buffer of size %1!u!.\n",
            SourceLength * sizeof(WCHAR)
            );
        goto error_exit;
    }

    bufp = displayBuf;
    chp = (PCHAR) Source;
    for (i = 0; i < SourceLength; i++) {
        x = (DWORD) (*chp);
        x &= 0xff;
        wsprintf(bufp, L"%02x ", x);
        chp++;
        bufp = &displayBuf[wcslen(displayBuf)];
    }

error_exit:

    return(displayBuf);

} // NmpCreateLogString
#endif // CLUSTER_BETA


BOOLEAN
NmpIsClusterMulticastReady(
    IN BOOLEAN       CheckNodeCount,
    IN BOOLEAN       Verbose
    )
/*++

Routine Description:

    Determines from the cluster version and the NM up node
    set whether multicast should be run in this cluster.

    Criteria: no nodes with version below Whistler
              at least three nodes configured (at this point,
                  we're not worried about how many nodes are
                  actually running)

Arguments:

    CheckNodeCount - indicates whether number of nodes
                     configured in cluster should be
                     considered

    Verbose - indicates whether to write results to the
              cluster log

Return value:

    TRUE if multicast should be run.

Notes:

    Called and returns with NM lock held.

--*/
{
    LPWSTR    reason = NULL;

    //
    // First check for the lowest version.
    //
    if (NmpIsNT5NodeInCluster) {
        reason = L"there is at least one NT5 node configured "
                 L"in the cluster membership";
    }

    //
    // Count the nodes.
    //
    else if (CheckNodeCount && NmpMulticastIsNotEnoughNodes) {
        reason = L"there are not enough nodes configured "
                 L"in the cluster membership";
    }

    if (Verbose && reason != NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast is not justified for this "
            "cluster because %1!ws!.\n",
            reason
            );
    }

    return((BOOLEAN)(reason == NULL));

} // NmpIsClusterMulticastReady


BOOLEAN
NmpMulticastValidateAddress(
    IN   LPWSTR            McastAddress
    )
/*++

Routine Description:

    Determines whether McastAddress is a valid
    multicast address.

Notes:

    IPv4 specific.

--*/
{
    DWORD        status;
    DWORD        address;

    status = ClRtlTcpipStringToAddress(McastAddress, &address);
    if (status == ERROR_SUCCESS) {

        address = ntohl(address);

        if (IN_CLASSD(address)) {
            return(TRUE);
        }
    }

    return(FALSE);

} // NmpMulticastValidateAddress


VOID
NmpFreeNetworkMulticastInfo(
    IN     PNM_NETWORK_MULTICAST_INFO McastInfo
    )
{
    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastAddress);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastSalt);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastLeaseRequestId);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastLeaseServer);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastAddressRangeLower);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastAddressRangeUpper);

    return;

} // NmpFreeNetworkMulticastInfo


DWORD
NmpStoreString(
    IN              LPWSTR    Source,
    IN OUT          LPWSTR  * Dest,
    IN OUT OPTIONAL DWORD   * DestLength
    )
{
    DWORD    sourceSize;
    DWORD    destLength;

    if (Source != NULL) {
        sourceSize = NM_WCSLEN(Source);
    } else {
        sourceSize = 0;
    }

    if (DestLength == NULL) {
        destLength = 0;
    } else {
        destLength = *DestLength;
    }

    if (*Dest != NULL && ((destLength < sourceSize) || (Source == NULL))) {

        MIDL_user_free(*Dest);
        *Dest = NULL;
    }

    if (*Dest == NULL) {

        if (sourceSize > 0) {
            *Dest = MIDL_user_allocate(sourceSize);
            if (*Dest == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to allocate buffer of size %1!u! "
                    "for source string %2!ws!.\n",
                    sourceSize, Source
                    );
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (DestLength != NULL) {
            *DestLength = sourceSize;
        }
    }

    if (sourceSize > 0) {
        RtlCopyMemory(*Dest, Source, sourceSize);
    }

    return(ERROR_SUCCESS);

} // NmpStoreString


DWORD
NmpStoreRequestId(
    IN     LPMCAST_CLIENT_UID   Source,
    IN OUT LPMCAST_CLIENT_UID   Dest
    )
{
    DWORD status;
    DWORD len;

    len = Source->ClientUIDLength;
    if (Source->ClientUID == NULL) {
        len = 0;
    }

    if (Dest->ClientUID != NULL &&
        (Dest->ClientUIDLength < Source->ClientUIDLength || len == 0)) {

        MIDL_user_free(Dest->ClientUID);
        Dest->ClientUID = NULL;
        Dest->ClientUIDLength = 0;
    }

    if (Dest->ClientUID == NULL && len > 0) {

        Dest->ClientUID = MIDL_user_allocate(len);
        if (Dest->ClientUID == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
    }

    if (len > 0) {
        RtlCopyMemory(
            Dest->ClientUID,
            Source->ClientUID,
            len
            );
    }

    Dest->ClientUIDLength = len;

    status = ERROR_SUCCESS;

error_exit:

    return(status);

} // NmpStoreRequestId


VOID
NmpStartNetworkMulticastAddressRenewTimer(
    PNM_NETWORK   Network,
    DWORD         Timeout
    )
/*++

Notes:

    Must be called with NM lock held.

--*/
{
    LPCWSTR   networkId = OmObjectId(Network);
    LPCWSTR   networkName = OmObjectName(Network);

    if (Network->McastAddressRenewTimer != Timeout) {

        Network->McastAddressRenewTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] %1!ws! multicast address lease renew "
            "timer (%2!u!ms) for network %3!ws! (%4!ws!)\n",
            ((Timeout == 0) ? L"Cleared" : L"Started"),
            Network->McastAddressRenewTimer,
            networkId,
            networkName
            );
    }

    return;

} // NmpStartNetworkMulticastAddressRenewTimer



VOID
NmpStartNetworkMulticastAddressReconfigureTimer(
    PNM_NETWORK  Network,
    DWORD        Timeout
    )
/*++

Notes:

    Must be called with NM lock held.

--*/
{
    LPCWSTR   networkId = OmObjectId(Network);
    LPCWSTR   networkName = OmObjectName(Network);

    if (Network->McastAddressReconfigureRetryTimer != Timeout) {

        Network->McastAddressReconfigureRetryTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] %1!ws! multicast address reconfigure "
            "timer (%2!u!ms) for network %3!ws! (%4!ws!)\n",
            ((Timeout == 0) ? L"Cleared" : L"Started"),
            Network->McastAddressReconfigureRetryTimer,
            networkId,
            networkName
            );
    }

    return;

} // NmpStartNetworkMulticastAddressReconfigureTimer




VOID
NmpStartNetworkMulticastKeyRegenerateTimer(
    PNM_NETWORK   Network,
    DWORD         Timeout
    )
/*++

Notes:

    Must be called with NM lock held.

--*/
{
    LPCWSTR   networkId = OmObjectId(Network);
    LPCWSTR   networkName = OmObjectName(Network);

    if (Network->McastKeyRegenerateTimer != Timeout) {

        Network->McastKeyRegenerateTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] %1!ws! multicast key regenerate "
            "timer (%2!u!ms) for network %3!ws! (%4!ws!)\n",
            ((Timeout == 0) ? L"Cleared" : L"Started"),
            Network->McastKeyRegenerateTimer,
            networkId,
            networkName
            );
    }

    return;

} // NmpStartNetworkMulticastKeyRegenerateTimer



VOID
NmpMulticastFreeParameters(
    IN  PNM_NETWORK_MULTICAST_PARAMETERS Parameters
    )
{
    if (Parameters == NULL) {
        return;
    }
    
    if (Parameters->Address != NULL) {
        if (!NMP_GLOBAL_STRING(Parameters->Address)) {
            MIDL_user_free(Parameters->Address);
        }
        Parameters->Address = NULL;
    }


    if (Parameters->Key != NULL) {
        RtlSecureZeroMemory(Parameters->Key, Parameters->KeyLength);
    }
    NM_MIDL_FREE_OBJECT_FIELD(Parameters, Key);
    Parameters->KeyLength = 0;

    NM_MIDL_FREE_OBJECT_FIELD(Parameters, LeaseRequestId.ClientUID);
    Parameters->LeaseRequestId.ClientUIDLength = 0;

    if (Parameters->LeaseServer != NULL) {
        if (!NMP_GLOBAL_STRING(Parameters->LeaseServer)) {
            MIDL_user_free(Parameters->LeaseServer);
        }
        Parameters->LeaseServer = NULL;
    }

    return;

} // NmpMulticastFreeParameters


DWORD
NmpMulticastCreateParameters(
    IN  DWORD                            Disabled,
    IN  LPWSTR                           Address,
    IN  PVOID                            Key,
    IN  DWORD                            KeyLength,
    IN  time_t                           LeaseObtained,
    IN  time_t                           LeaseExpires,
    IN  LPMCAST_CLIENT_UID               LeaseRequestId,
    IN  LPWSTR                           LeaseServer,
    IN  NM_MCAST_CONFIG                  ConfigType,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS Parameters
    )
{
    DWORD status;

    RtlZeroMemory(Parameters, sizeof(*Parameters));

    // disabled
    Parameters->Disabled = Disabled;

    // address
    if (Address != NULL) {
        status = NmpStoreString(Address, &(Parameters->Address), NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    // key
    if (Key != NULL) {
        Parameters->Key = MIDL_user_allocate(KeyLength);
        if (Parameters->Key == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
        RtlCopyMemory(Parameters->Key, Key, KeyLength);
        Parameters->KeyLength = KeyLength;
    }

    Parameters->LeaseObtained = LeaseObtained;
    Parameters->LeaseExpires = LeaseExpires;

    // lease request id
    if (LeaseRequestId != NULL && LeaseRequestId->ClientUID != NULL) {
        status = NmpStoreRequestId(LeaseRequestId, &Parameters->LeaseRequestId);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    // lease server address
    if (LeaseServer != NULL) {
        status = NmpStoreString(LeaseServer, &(Parameters->LeaseServer), NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    // config type
    Parameters->ConfigType = ConfigType;

    // multicast key expiration
    Parameters->MulticastKeyExpires = 0;

    return(ERROR_SUCCESS);

error_exit:

    NmpMulticastFreeParameters(Parameters);

    return(status);

} // NmpMulticastCreateParameters


DWORD
NmpMulticastCreateParametersFromUpdate(
    IN     PNM_NETWORK                        Network,
    IN     PNM_NETWORK_MULTICAST_UPDATE       Update,
    IN     BOOLEAN                            GenerateKey,
    OUT    PNM_NETWORK_MULTICAST_PARAMETERS   Parameters
    )
/*++

Routine Description:

    Converts a data structure received in a GUM update
    into a locally allocated parameters data structure.
    The base Parameters data structure must be allocated
    by the caller, though the fields are allocated in
    this routine.

--*/
{
    DWORD            status;
    MCAST_CLIENT_UID requestId;
    LPWSTR NetworkId;
    PVOID EncryptionKey = NULL;
    DWORD EncryptionKeyLength;
    PBYTE MulticastKey = NULL;
    DWORD MulticastKeyLength;


    requestId.ClientUID =
        ((Update->LeaseRequestIdOffset == 0) ? NULL :
         (LPBYTE)((PUCHAR)Update + Update->LeaseRequestIdOffset));
    requestId.ClientUIDLength = Update->LeaseRequestIdLength;


    if (Update->EncryptedMulticastKeyOffset != 0)
    {
        //
        // Decrypted multicast key
        //
        NetworkId = (LPWSTR) OmObjectId(Network);

        status = NmpDeriveClusterKey(NetworkId,
                                     NM_WCSLEN(NetworkId),
                                     &EncryptionKey,
                                     &EncryptionKeyLength
                                     );

        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] NmpMulticastCreateParametersFromUpdate: Failed to "
                "derive cluster key for "
                "network %1!ws!, status %2!u!.\n",
                NetworkId,
                status
                );

            // Non-fatal error. Proceed with NULL key. This node
            // will not be able to send or receive multicast on
            // this network.
            MulticastKey = NULL;
            MulticastKeyLength = 0;
            status = ERROR_SUCCESS;

        } else {
            status = NmpVerifyMACAndDecryptData(
                            NmCryptServiceProvider,
                            NMP_ENCRYPT_ALGORITHM,
                            NMP_KEY_LENGTH,
                            (PBYTE) ((PUCHAR)Update + Update->MACOffset),
                            Update->MACLength,
                            NMP_MAC_DATA_LENGTH_EXPECTED,
                            (PBYTE) ((PUCHAR)Update +
                                     Update->EncryptedMulticastKeyOffset),
                            Update->EncryptedMulticastKeyLength,
                            EncryptionKey,
                            EncryptionKeyLength,
                            (PBYTE) ((PUCHAR)Update + Update->SaltOffset),
                            Update->SaltLength,
                            &MulticastKey,
                            &MulticastKeyLength
                            );

            if (status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] NmpMulticastCreateParametersFromUpdate: "
                    "Failed to verify MAC or decrypt data for "
                    "network %1!ws!, status %2!u!.\n",
                    NetworkId,
                    status
                    );

                // Non-fatal error. Proceed with NULL key. This node
                // will not be able to send or receive multicast on
                // this network.
                MulticastKey = NULL;
                MulticastKeyLength = 0;
                status = ERROR_SUCCESS;
            }
        }

        //
        // A new key is always generated before a multicast config
        // GUM update (unless multicast is disabled, in which case
        // the EncryptedMulticastKey will be NULL). Set the key
        // expiration to the default.
        //
        Parameters->MulticastKeyExpires = NM_NET_MULTICAST_KEY_REGEN_TIMEOUT;
    }

    status = NmpMulticastCreateParameters(
                 Update->Disabled,
                 ((Update->AddressOffset == 0) ? NULL :
                  (LPWSTR)((PUCHAR)Update + Update->AddressOffset)),
                 MulticastKey,
                 MulticastKeyLength,
                 Update->LeaseObtained,
                 Update->LeaseExpires,
                 &requestId,
                 ((Update->LeaseServerOffset == 0) ? NULL :
                  (LPWSTR)((PUCHAR)Update + Update->LeaseServerOffset)),
                 Update->ConfigType,
                 Parameters
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] NmpMulticastCreateParametersFromUpdate: "
            "Failed to create parameters for "
            "network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
    }

    if (EncryptionKey != NULL)
    {
        RtlSecureZeroMemory(EncryptionKey, EncryptionKeyLength);
        LocalFree(EncryptionKey);
    }

    if (MulticastKey != NULL)
    {
        RtlSecureZeroMemory(MulticastKey, MulticastKeyLength);
        LocalFree(MulticastKey);
    }

    if (status != ERROR_SUCCESS) {
        NmpMulticastFreeParameters(Parameters);
    }

    return(status);

} // NmpMulticastCreateParametersFromUpdate



DWORD
NmpMulticastCreateUpdateFromParameters(
    IN  PNM_NETWORK                       Network,
    IN  PNM_NETWORK_MULTICAST_PARAMETERS  Parameters,
    OUT PNM_NETWORK_MULTICAST_UPDATE    * Update,
    OUT DWORD                           * UpdateSize
    )
{
    DWORD                            updateSize;
    PNM_NETWORK_MULTICAST_UPDATE     update;
    DWORD                            address = 0;
    DWORD                            encryptedMulticastKey = 0;
    DWORD                            salt = 0;
    DWORD                            mac = 0;
    LPWSTR                           NetworkId;
    PVOID                            EncryptionKey = NULL;
    DWORD                            EncryptionKeyLength;
    PBYTE                            Salt = NULL;
    PBYTE                            EncryptedMulticastKey = NULL;
    DWORD                            EncryptedMulticastKeyLength = 0;
    PBYTE                            MAC = NULL;
    DWORD                            MACLength;
    DWORD                            status = ERROR_SUCCESS;
    DWORD                            requestId = 0;
    DWORD                            leaseServer = 0;



    //
    // Calculate the size of the update data buffer.
    //
    updateSize = sizeof(*update);

    // address
    if (Parameters->Address != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(LPWSTR));
        address = updateSize;
        updateSize += NM_WCSLEN(Parameters->Address);
    }


    if (Parameters->Key != NULL)
    {

        NetworkId = (LPWSTR) OmObjectId(Network);

        status = NmpDeriveClusterKey(
                              NetworkId,
                              NM_WCSLEN(NetworkId),
                              &EncryptionKey,
                              &EncryptionKeyLength
                              );
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] NmpMulticastCreateUpdateFromParameters: Failed to "
                "derive cluster key for "
                "network %1!ws!, status %2!u!.\n",
                NetworkId,
                status
                );
            goto error_exit;
        }

        MACLength = NMP_MAC_DATA_LENGTH_EXPECTED;

        status = NmpEncryptDataAndCreateMAC(
                        NmCryptServiceProvider,
                        NMP_ENCRYPT_ALGORITHM,
                        NMP_KEY_LENGTH,
                        Parameters->Key, // Data
                        Parameters->KeyLength, // Data length
                        EncryptionKey,
                        EncryptionKeyLength,
                        TRUE, // Create salt
                        &Salt,
                        NMP_SALT_BUFFER_LEN,
                        &EncryptedMulticastKey,
                        &EncryptedMulticastKeyLength,
                        &MAC,
                        &MACLength
                        );
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] NmpMulticastCreateUpdateFromParameters: Failed to "
                "encrypt data or generate MAC for "
                "network %1!ws!, status %2!u!.\n",
                NetworkId,
                status
                );
            goto error_exit;
        }

        // encrypted multicast key
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(PVOID));
        encryptedMulticastKey = updateSize;
        updateSize += EncryptedMulticastKeyLength;

        // salt
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(PVOID));
        salt = updateSize;
        updateSize += NMP_SALT_BUFFER_LEN;

        // mac
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(PVOID));
        mac = updateSize;
        updateSize += MACLength;
    }

    // request id
    if (Parameters->LeaseRequestId.ClientUID != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(LPBYTE));
        requestId = updateSize;
        updateSize += Parameters->LeaseRequestId.ClientUIDLength;
    }

    // lease server
    if (Parameters->LeaseServer != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(LPWSTR));
        leaseServer = updateSize;
        updateSize += NM_WCSLEN(Parameters->LeaseServer);
    }

    //
    // Allocate the update buffer.
    //
    update = MIDL_user_allocate(updateSize);
    if (update == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] NmpMulticastCreateUpdateFromParameters: Failed to "
            "allocate %1!u! bytes.\n",
            updateSize
            );
        goto error_exit;
    }

    //
    // Fill in the update buffer.
    //
    update->Disabled = Parameters->Disabled;

    update->AddressOffset = address;
    if (address != 0) {
        RtlCopyMemory(
            (PUCHAR)update + address,
            Parameters->Address,
            NM_WCSLEN(Parameters->Address)
            );
    }


    // encrypted multicast key
    update->EncryptedMulticastKeyOffset = encryptedMulticastKey;
    update->EncryptedMulticastKeyLength = EncryptedMulticastKeyLength;
    if (encryptedMulticastKey != 0)
    {
        RtlCopyMemory(
            (PUCHAR)update + encryptedMulticastKey,
            EncryptedMulticastKey,
            EncryptedMulticastKeyLength
            );
    }

    // salt
    update->SaltOffset = salt;
    update->SaltLength = NMP_SALT_BUFFER_LEN;
    if (salt != 0)
    {
        RtlCopyMemory(
            (PUCHAR)update + salt,
            Salt,
            NMP_SALT_BUFFER_LEN
            );
    }

    // mac
    update->MACOffset = mac;
    update->MACLength = MACLength;
    if (mac != 0)
    {
        RtlCopyMemory(
            (PUCHAR)update + mac,
            MAC,
            MACLength
            );
    }



    update->LeaseObtained = Parameters->LeaseObtained;
    update->LeaseExpires = Parameters->LeaseExpires;

    update->LeaseRequestIdOffset = requestId;
    update->LeaseRequestIdLength = Parameters->LeaseRequestId.ClientUIDLength;
    if (requestId != 0) {
        RtlCopyMemory(
            (PUCHAR)update + requestId,
            Parameters->LeaseRequestId.ClientUID,
            Parameters->LeaseRequestId.ClientUIDLength
            );
    }

    update->LeaseServerOffset = leaseServer;
    if (leaseServer != 0) {
        RtlCopyMemory(
            (PUCHAR)update + leaseServer,
            Parameters->LeaseServer,
            NM_WCSLEN(Parameters->LeaseServer)
            );
    }

    update->ConfigType = Parameters->ConfigType;

    *Update = update;
    *UpdateSize = updateSize;

error_exit:

    if (EncryptionKey != NULL)
    {
        RtlSecureZeroMemory(EncryptionKey, EncryptionKeyLength);
        LocalFree(EncryptionKey);
    }

    if (EncryptedMulticastKey != NULL)
    {
        LocalFree(EncryptedMulticastKey);
    }

    if (Salt != NULL)
    {
        LocalFree(Salt);
    }

    if (MAC != NULL)
    {
        LocalFree(MAC);
    }

    return(status);

} // NmpMulticastCreateUpdateFromParameters



VOID
NmpFreeMulticastAddressRelease(
    IN     PNM_NETWORK_MADCAP_ADDRESS_RELEASE Release
    )
{
    if (Release == NULL) {
        return;
    }

    if (Release->McastAddress != NULL &&
        !NMP_GLOBAL_STRING(Release->McastAddress)) {
        MIDL_user_free(Release->McastAddress);
        Release->McastAddress = NULL;
    }

    if (Release->ServerAddress != NULL &&
        !NMP_GLOBAL_STRING(Release->ServerAddress)) {
        MIDL_user_free(Release->ServerAddress);
        Release->ServerAddress = NULL;
    }

    if (Release->RequestId.ClientUID != NULL) {
        MIDL_user_free(Release->RequestId.ClientUID);
        Release->RequestId.ClientUID = NULL;
        Release->RequestId.ClientUIDLength = 0;
    }

    LocalFree(Release);

    return;

} // NmpFreeMulticastAddressRelease

DWORD
NmpCreateMulticastAddressRelease(
    IN  LPWSTR                               McastAddress,
    IN  LPWSTR                               ServerAddress,
    IN  LPMCAST_CLIENT_UID                   RequestId,
    OUT PNM_NETWORK_MADCAP_ADDRESS_RELEASE * Release
    )
/*++

Routine Description:

    Allocate and initialize an entry for an address
    release list.

--*/
{
    DWORD                              status;
    PNM_NETWORK_MADCAP_ADDRESS_RELEASE release = NULL;

    release = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(*release));
    if (release == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = NmpStoreString(McastAddress, &(release->McastAddress), NULL);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpStoreString(ServerAddress, &(release->ServerAddress), NULL);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpStoreRequestId(RequestId, &(release->RequestId));
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    *Release = release;

    return(ERROR_SUCCESS);

error_exit:

    NmpFreeMulticastAddressRelease(release);

    return(status);

} // NmpCreateMulticastAddressRelease


VOID
NmpInitiateMulticastAddressRelease(
    IN PNM_NETWORK                         Network,
    IN PNM_NETWORK_MADCAP_ADDRESS_RELEASE  Release
    )
/*++

Routine Description:

    Stores an entry for the network multicast
    address release list on the list and schedules
    the release.

Notes:

    Called and returns with NM lock held.

--*/
{
    InsertTailList(&(Network->McastAddressReleaseList), &(Release->Linkage));

    NmpScheduleMulticastAddressRelease(Network);

    return;

} // NmpInitiateMulticastAddressRelease


DWORD
NmpQueryMulticastAddress(
    IN     PNM_NETWORK   Network,
    IN     HDMKEY        NetworkKey,
    IN OUT HDMKEY      * NetworkParametersKey,
    IN OUT LPWSTR      * McastAddr,
    IN OUT ULONG       * McastAddrLength
    )
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    DWORD         size = 0;

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address for "
        "network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA
    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Query for the multicast address.
    //
    status = NmpQueryString(
                 netParamKey,
                 CLUSREG_NAME_NET_MULTICAST_ADDRESS,
                 REG_SZ,
                 McastAddr,
                 McastAddrLength,
                 &size
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast address for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Found multicast address %1!ws! for "
        "network %2!ws! in cluster database.\n",
        *McastAddr, networkId
        );
#endif // CLUSTER_BETA

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpQueryMulticastAddress


DWORD
NmpQueryMulticastDisabled(
    IN     PNM_NETWORK   Network,
    IN OUT HDMKEY      * ClusterParametersKey,
    IN OUT HDMKEY      * NetworkKey,
    IN OUT HDMKEY      * NetworkParametersKey,
       OUT DWORD       * Disabled
    )
/*++

Routine Description:

    Checks whether multicast has been disabled for this
    network in the cluster database. Both the network
    paramters key and the cluster parameters key are
    checked. The order of precedence is as follows:

    - a value in the network parameters key has top
      precedence

    - if no value is found in the network parameters
      key, a value is checked in the cluster parameters
      key.

    - if no value is found in the cluster parameters
      key, return NMP_MCAST_DISABLED_DEFAULT.

    If an error is returned, the return value of
    Disabled is undefined.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    DWORD         type;
    DWORD         disabled;
    DWORD         len = sizeof(disabled);
    BOOLEAN       found = FALSE;

    HDMKEY        clusParamKey = NULL;
    BOOLEAN       openedClusParamKey = FALSE;
    HDMKEY        networkKey = NULL;
    BOOLEAN       openedNetworkKey = FALSE;
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;


    //
    // Open the network key, if necessary.
    //
    networkKey = *NetworkKey;

    if (networkKey == NULL) {

        networkKey = DmOpenKey(
                         DmNetworksKey,
                         networkId,
                         MAXIMUM_ALLOWED
                         );
        if (networkKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for network %1!ws!, "
                "status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetworkKey = TRUE;
        }
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          networkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
#endif // CLUSTER_BETA
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // If we found a network parameters key, check for the
    // disabled value.
    //
    if (netParamKey != NULL) {

        status = DmQueryValue(
                     netParamKey,
                     CLUSREG_NAME_NET_DISABLE_MULTICAST,
                     &type,
                     (LPBYTE) &disabled,
                     &len
                     );
        if (status == ERROR_SUCCESS) {
            if (type != REG_DWORD) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Unexpected type (%1!u!) for network "
                    "%2!ws! %3!ws!, status %4!u!. Checking "
                    "cluster parameters ...\n",
                    type, networkId,
                    CLUSREG_NAME_NET_DISABLE_MULTICAST, status
                    );
            } else {
                found = TRUE;
            }
        }
    }

    //
    // If we were unsuccessful at finding a value in the
    // network parameters key, try under the cluster
    // parameters key.
    //
    if (!found) {

        //
        // Open the cluster parameters key, if necessary.
        //
        clusParamKey = *NetworkParametersKey;

        if (clusParamKey == NULL) {

            clusParamKey = DmOpenKey(
                               DmClusterParametersKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               KEY_READ
                               );
            if (clusParamKey == NULL) {
                status = GetLastError();
#if CLUSTER_BETA
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Failed to find cluster Parameters "
                    "key, status %1!u!.\n",
                    status
                    );
#endif // CLUSTER_BETA
            } else {
                openedClusParamKey = TRUE;

                //
                // Query the disabled value under the cluster parameters
                // key.
                //
                status = DmQueryValue(
                             clusParamKey,
                             CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST,
                             &type,
                             (LPBYTE) &disabled,
                             &len
                             );
                if (status != ERROR_SUCCESS) {
#if CLUSTER_BETA
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Failed to read cluster "
                        "%1!ws! value, status %2!u!. "
                        "Using default value ...\n",
                        CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST, status
                        );
#endif // CLUSTER_BETA
                }
                else if (type != REG_DWORD) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Unexpected type (%1!u!) for cluster "
                        "%2!ws!, status %3!u!. "
                        "Using default value ...\n",
                        type, CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST, status
                        );
                } else {
                    found = TRUE;
                }
            }
        }
    }

    //
    // Return what we found. If we didn't find anything,
    // return the default.
    //
    if (found) {
        *Disabled = disabled;
    } else {
        *Disabled = NMP_MCAST_DISABLED_DEFAULT;
    }

    *NetworkKey = networkKey;
    networkKey = NULL;
    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;
    *ClusterParametersKey = clusParamKey;
    clusParamKey = NULL;

    //
    // Even if we didn't find anything, we return success
    // because we have a default. Note that we return error
    // if a fundamental operation (such as locating the
    // network key) failed.
    //
    status = ERROR_SUCCESS;

error_exit:

    if (openedClusParamKey && clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (openedNetworkKey && networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    return(status);

} // NmpQueryMulticastDisabled


DWORD
NmpQueryMulticastConfigType(
    IN     PNM_NETWORK        Network,
    IN     HDMKEY             NetworkKey,
    IN OUT HDMKEY           * NetworkParametersKey,
       OUT NM_MCAST_CONFIG  * ConfigType
    )
/*++

Routine Description:

    Reads the multicast config type from the cluster
    database.

--*/
{
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    DWORD         type;
    DWORD         len = sizeof(*ConfigType);
    DWORD         status;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address config type for "
        "network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Read the config type.
    //
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_CONFIG_TYPE,
                 &type,
                 (LPBYTE) ConfigType,
                 &len
                 );
    if (status == ERROR_SUCCESS) {
        if (type != REG_DWORD) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Unexpected type (%1!u!) for network "
                "%2!ws! %3!ws!, status %4!u!. Checking "
                "cluster parameters ...\n",
                type, networkId,
                CLUSREG_NAME_NET_MCAST_CONFIG_TYPE, status
                );
            status = ERROR_DATATYPE_MISMATCH;
            goto error_exit;
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to query network %1!ws! %2!ws! "
            "from cluster database, status %3!u!.\n",
            networkId, CLUSREG_NAME_NET_MCAST_CONFIG_TYPE, status
            );
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Found multicast address config type %1!u! "
        "for network %2!ws! in cluster database.\n",
        *ConfigType, networkId
        );
#endif // CLUSTER_BETA

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpQueryMulticastConfigType


DWORD
NmpMulticastNotifyConfigChange(
    IN     PNM_NETWORK                        Network,
    IN     HDMKEY                             NetworkKey,
    IN OUT HDMKEY                           * NetworkParametersKey,
    IN     PNM_NETWORK_MULTICAST_PARAMETERS   Parameters,
    IN     PVOID                              PropBuffer,
    IN     DWORD                              PropBufferSize
    )
/*++

Routine Description:

    Notify other cluster nodes of the new multicast
    configuration parameters by initiating a GUM
    update.

    If this is a manual update, there may be other
    properties to distribute in the GUM update.

Notes:

    Cannot be called with NM lock held.

--*/
{
    DWORD                        status = ERROR_SUCCESS;
    LPCWSTR                      networkId = OmObjectId(Network);
    PNM_NETWORK_MULTICAST_UPDATE update = NULL;
    DWORD                        updateSize = 0;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Notifying other nodes of type %1!u! multicast "
        "reconfiguration for network %2!ws!.\n",
        Parameters->ConfigType, networkId
        );

    status = NmpMulticastCreateUpdateFromParameters(
                 Network,
                 Parameters,
                 &update,
                 &updateSize
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to build GUM update for "
            "multicast configuration of network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // BUGBUG: Disseminate database updates to downlevel
    //         nodes!
    //

    //
    // Send junk if the prop buffer is empty.
    //
    if (PropBuffer == NULL || PropBufferSize == 0) {
        PropBuffer = &updateSize;
        PropBufferSize = sizeof(updateSize);
    }

    //
    // Send the update.
    //
    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateSetNetworkMulticastConfiguration,
                 4,
                 NM_WCSLEN(networkId),
                 networkId,
                 updateSize,
                 update,
                 PropBufferSize,
                 PropBuffer,
                 sizeof(PropBufferSize),
                 &PropBufferSize
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to send GUM update for "
            "multicast configuration of network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

error_exit:

    if (update != NULL) {
        MIDL_user_free(update);
        update = NULL;
    }

    return(status);

} // NmpMulticastNotifyConfigChange



DWORD
NmpWriteMulticastParameters(
    IN  PNM_NETWORK                      Network,
    IN  HDMKEY                           NetworkKey,
    IN  HDMKEY                           NetworkParametersKey,
    IN  HLOCALXSACTION                   Xaction,
    IN  PNM_NETWORK_MULTICAST_PARAMETERS Parameters
    )
{
    DWORD                       status = ERROR_SUCCESS;
    LPCWSTR                     networkId = OmObjectId(Network);
    LPWSTR                      failValueName = NULL;

    CL_ASSERT(NetworkKey != NULL);
    CL_ASSERT(NetworkParametersKey != NULL);
    CL_ASSERT(Xaction != NULL);

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Writing multicast parameters for "
        "network %1!ws! to cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA

    //
    // Address.
    //
    if (Parameters->Address != NULL) {
        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MULTICAST_ADDRESS,
                     REG_SZ,
                     (BYTE *) Parameters->Address,
                     NM_WCSLEN(Parameters->Address)
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MULTICAST_ADDRESS;
            goto error_exit;
        }
    }

    //
    // Lease server address.
    //
    if (Parameters->LeaseServer != NULL) {

        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS,
                     REG_SZ,
                     (BYTE *) Parameters->LeaseServer,
                     NM_WCSLEN(Parameters->LeaseServer)
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS;
            goto error_exit;
        }
    }

    //
    // Client request id.
    //
    if (Parameters->LeaseRequestId.ClientUID != NULL &&
        Parameters->LeaseRequestId.ClientUIDLength > 0) {

        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MCAST_REQUEST_ID,
                     REG_BINARY,
                     (BYTE *) Parameters->LeaseRequestId.ClientUID,
                     Parameters->LeaseRequestId.ClientUIDLength
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MCAST_REQUEST_ID;
            goto error_exit;
        }
    }

    //
    // Lease obtained.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkParametersKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED,
                 REG_DWORD,
                 (BYTE *) &(Parameters->LeaseObtained),
                 sizeof(Parameters->LeaseObtained)
                 );
    if (status != ERROR_SUCCESS) {
        failValueName = CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED;
        goto error_exit;
    }

    //
    // Lease expires.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkParametersKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES,
                 REG_DWORD,
                 (BYTE *) &(Parameters->LeaseExpires),
                 sizeof(Parameters->LeaseExpires)
                 );
    if (status != ERROR_SUCCESS) {
        failValueName = CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES;
        goto error_exit;
    }

    //
    // Config type.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkParametersKey,
                 CLUSREG_NAME_NET_MCAST_CONFIG_TYPE,
                 REG_DWORD,
                 (BYTE *) &(Parameters->ConfigType),
                 sizeof(Parameters->ConfigType)
                 );
    if (status != ERROR_SUCCESS) {
        failValueName = CLUSREG_NAME_NET_MCAST_CONFIG_TYPE;
        goto error_exit;
    }

error_exit:

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to write %1!ws! value "
            "for network %2!ws!, status %3!u!.\n",
            failValueName, networkId, status
            );
    }

    return(status);

} // NmpWriteMulticastParameters


DWORD
NmpMulticastEnumerateScopes(
    IN  BOOLEAN              Requery,
    OUT PMCAST_SCOPE_ENTRY * ScopeList,
    OUT DWORD              * ScopeCount
    )
/*++

Routine Description:

    Call MADCAP API to enumerate multicast scopes.

--*/
{
    DWORD                    status;
    PMCAST_SCOPE_ENTRY       scopeList = NULL;
    DWORD                    scopeListLength;
    DWORD                    scopeCount = 0;

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            return(status);
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Enumerate the multicast scopes.
    //
    scopeList = NULL;
    scopeListLength = 0;

    do {

        PVOID   watchdogHandle;

        //
        // Set watchdog timer to try to catch bug 400242. Specify
        // timeout of 5 minutes (in milliseconds).
        //
        watchdogHandle = ClRtlSetWatchdogTimer(
                             5 * 60 * 1000,
                             L"McastEnumerateScopes (Bug 400242)"
                             );
        if (watchdogHandle == NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to set %1!u!ms watchdog timer for "
                "McastEnumerateScopes.\n",
                5 * 60 * 1000
                );
        }

        status = McastEnumerateScopes(
                     AF_INET,
                     Requery,
                     scopeList,
                     &scopeListLength,
                     &scopeCount
                     );

        //
        // Cancel watchdog timer.
        //
        if (watchdogHandle != NULL) {
            ClRtlCancelWatchdogTimer(watchdogHandle);
        }

        if ( (scopeList == NULL && status == ERROR_SUCCESS) ||
             (status == ERROR_MORE_DATA)
           ) {
            if (scopeList != NULL) {
                LocalFree(scopeList);
            }
            scopeList = LocalAlloc(LMEM_FIXED, scopeListLength);
            if (scopeList == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to allocate multicast scope list "
                    "of length %1!u!.\n",
                    scopeListLength
                    );
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } else {
                //
                // Call McastEnumerateScopes again with proper
                // size scopeList buffer.
                //
                Requery = FALSE;
                continue;
            }
        } else {
            //
            // McastEnumerateScopes failed with an unexpected
            // error. Bail out.
            //
            break;
        }

    } while (TRUE);

    if (status != ERROR_SUCCESS) {
        if (scopeList != NULL) {
            LocalFree(scopeList);
            scopeList = NULL;
            scopeCount = 0;
        }
    }

    *ScopeList = scopeList;
    *ScopeCount = scopeCount;

    return(status);

} // NmpMulticastEnumerateScopes


_inline
DWORD
NmpMadcapTimeToNmTime(
    IN     time_t             MadcapTime
    )
/*++

Routine Description:

    Convert MADCAP (DHCP) time into NM time. MADCAP time
    is a time_t and in seconds. NM time is a DWORD in
    milliseconds.

Arguments:

    MadcapTime - MADCAP time

Return value:

    Converted NM time, or MAXULONG if converted NM time
    would overflow.

--*/
{
    LARGE_INTEGER    product, limit;

    product.QuadPart = (ULONG) MadcapTime;
    product = RtlExtendedIntegerMultiply(product, 1000);

    limit.QuadPart = MAXULONG;

    if (product.QuadPart > limit.QuadPart) {
        return(MAXULONG);
    } else {
        return(product.LowPart);
    }

} // NmpMadcapTimeToNmTime

DWORD
NmpRandomizeTimeout(
    IN     PNM_NETWORK        Network,
    IN     DWORD              BaseTimeout,
    IN     DWORD              Window,
    IN     DWORD              MinTimeout,
    IN     DWORD              MaxTimeout,
    IN     BOOLEAN            FavorNmLeader
    )
/*++

Routine Description:

    General-purpose routine to randomize a timeout value
    so that timers (probably) do not expire at the same
    time on multiple nodes.

    The randomized timeout will fall within Window
    on either side of BaseTimeout. If possible, Window
    is extended only above BaseTimeout, but it will be
    extended below if BaseTimeout + Window > MaxTimeout.

    If FavorNmLeader is TRUE, the NM leader is assigned
    the earliest timeout (within Window).

Arguments:

    Network - network

    BaseTimeout - time when lease should be renewed

    Window - period after (or before) BaseTimeout
             during which timeout can be set

    MaxTimeout - maximum allowable timeout

    MinTimeout - minimum allowable timeout

    FavorNmLeader - if TRUE, NM leader is assigned
                    the earliest timeout

Return value:

    Randomized timeout.

--*/
{
    DWORD            status;
    DWORD            result = 0;
    DWORD          * pOffset = NULL;
    DWORD            topWindow, bottomWindow, adjustedWindow;
    DWORD            adjustedBase;
    DWORD            offset, interval;

    if (MinTimeout > MaxTimeout) {
        result = BaseTimeout;
        goto error_exit;
    }

    if (MaxTimeout == 0) {
        result = 0;
        goto error_exit;
    }

    // Adjust the base so that it is between the min and max.
    adjustedBase = BaseTimeout;
    if (MaxTimeout < BaseTimeout) {
        adjustedBase = MaxTimeout;
    } else if (MinTimeout > adjustedBase) {
        adjustedBase = MinTimeout;
    }

    // If the Window is zero, we're done.
    if (Window == 0) {
        result = adjustedBase;
        goto error_exit;
    }

    //
    // Position the window. If necessary, we will extend
    // below and/or above the adjusted base.
    // - topWindow: amount window extends above adjusted base
    // - bottomWindow: amount window extends below adjusted base
    //

    if (Window < MaxTimeout - adjustedBase) {
        // There is enough room above the adjusted base
        // for the window.
        topWindow = Window;
        bottomWindow = 0;
        adjustedWindow = Window;
    } else {
        // Because of the max, the window pushes below
        // the adjusted base.
        topWindow = MaxTimeout - adjustedBase;
        bottomWindow = Window - topWindow;

        // Make sure the window doesn't extend below
        // the min.
        if (bottomWindow > adjustedBase ||
            adjustedBase - bottomWindow < MinTimeout) {

            // The window extends below the min. Set
            // the bottom of the window to be the min.
            bottomWindow = adjustedBase - MinTimeout;
        }

        // Adjusted window.
        adjustedWindow = topWindow - bottomWindow;

        // Adjust the base to the bottom of the window (and
        // recall that bottomWindow is an offset relative
        // to the current adjusted base).
        adjustedBase -= bottomWindow;
    }

    //
    // Check if the NM leader gets first dibs.
    //
    if (FavorNmLeader && NmpLeaderNodeId == NmLocalNodeId) {
        result = adjustedBase;
        goto error_exit;
    }

    //
    // Use a random number to choose an offset into the window.
    //
    status = NmpCreateRandomNumber(&pOffset, sizeof(*pOffset));
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to create random offset while "
            "randomizing timeout for network %1!ws!, "
            "status %2!u!.\n",
            OmObjectId(Network),
            status
            );
        //
        // Default to intervals based on node id
        //
        interval = (adjustedWindow > ClusterDefaultMaxNodes) ?
                   (adjustedWindow / ClusterDefaultMaxNodes) : 1;
        offset = (NmLocalNodeId * interval) % adjustedWindow;
    } else {
        offset = (*pOffset) % adjustedWindow;
    }

    result = adjustedBase + offset;

error_exit:

    if (pOffset != NULL) {
        LocalFree(pOffset);
        pOffset = NULL;
    }

    return(result);

} // NmpRandomizeTimeout


DWORD
NmpCalculateLeaseRenewTime(
    IN     PNM_NETWORK        Network,
    IN     NM_MCAST_CONFIG    ConfigType,
    IN OUT time_t           * LeaseObtained,
    IN OUT time_t           * LeaseExpires
    )
/*++

Routine Description:

    Determines when to schedule a lease renewal, based
    on the lease obtained and expires times and whether
    the current lease was obtained from a MADCAP server.

    If the lease was obtained from a MADCAP server, the
    policy mimics DHCP client renewal behavior. A
    renewal is scheduled for half the time until the
    lease expires. However, if the lease half-life is
    less than the renewal threshold, renew at the lease
    expiration time.

    If the address was selected after a MADCAP timeout,
    we still periodically query to make sure a MADCAP
    server doesn't suddenly appear on the network. In
    this case, LeaseExpires and LeaseObtained will be
    garbage, and we need to fill them in.

    If the address was configured by an administrator,
    return 0, indicating that the timer should not be set.

Return value:

    Relative NM ticks from current time that lease
    renewal should be scheduled.

--*/
{
    time_t           currentTime;
    time_t           leaseExpires;
    time_t           leaseObtained;
    time_t           result = 0;
    time_t           window = 0;
    time_t           leaseHalfLife = 0;
    DWORD            dwResult = 0;
    DWORD            dwWindow = 0;

    currentTime = time(NULL);
    leaseExpires = *LeaseExpires;
    leaseObtained = *LeaseObtained;

    switch (ConfigType) {

    case NmMcastConfigManual:
        dwResult = 0;
        *LeaseObtained = 0;
        *LeaseExpires = 0;
        break;

    case NmMcastConfigMadcap:
        if (leaseExpires < currentTime) {
            result = 1;
        } else if (leaseExpires <= leaseObtained) {
            result = 1;
        } else {
            leaseHalfLife = (leaseExpires - leaseObtained) / 2;
            if (leaseHalfLife < NMP_MCAST_LEASE_RENEWAL_THRESHOLD) {

                // The half life is too small.
                result = leaseExpires - currentTime;
                if (result == 0) {
                    result = 1;
                }
                window = result / 2;
            } else {

                // The half life is acceptable.
                result = leaseHalfLife;
                window = NMP_MCAST_LEASE_RENEWAL_WINDOW;
                if (result + window > leaseExpires) {
                    window = leaseExpires - result;
                }
            }
        }
        break;

    case NmMcastConfigAuto:
        result = NMP_MADCAP_REQUERY_PERDIOD;
        window = NMP_MCAST_LEASE_RENEWAL_WINDOW;

        //
        // Return the lease expiration time to be
        // written into the cluster database.
        //
        *LeaseObtained = currentTime;
        *LeaseExpires = currentTime + NMP_MADCAP_REQUERY_PERDIOD;
        break;

    default:
        CL_ASSERT(FALSE);
        result = 0;
        break;
    }

    //
    // Randomize the timeout so that all nodes don't
    // try to renew at the same time. If the config
    // type was manual, do not randomize -- leave the
    // timeout at zero so that it is cleared.
    //
    if (ConfigType != NmMcastConfigManual) {
        dwResult = NmpRandomizeTimeout(
                      Network,
                      NmpMadcapTimeToNmTime(result),
                      NmpMadcapTimeToNmTime(window),
                      1000,    // one second
                      MAXULONG,
                      TRUE
                      );
    }

    return(dwResult);

} // NmpCalculateLeaseRenewTime


VOID
NmpReportMulticastAddressLease(
    IN  PNM_NETWORK                      Network,
    IN  PNM_NETWORK_MULTICAST_PARAMETERS Parameters,
    IN  LPWSTR                           OldAddress
    )
/*++

Routine Description:

    Write an event log entry, if not repetitive,
    reporting that a multicast address lease was
    obtained.

    The repetitive criteria is that the address
    changed.

--*/
{
    BOOLEAN               writeLogEntry = FALSE;
    LPCWSTR               nodeName;
    LPCWSTR               networkName;

    if (Parameters->Address == NULL ||
        Parameters->LeaseServer == NULL ||
        Network == NULL ||
        Network->LocalInterface == NULL) {
        return;
    }

    if (OldAddress == NULL || wcscmp(Parameters->Address, OldAddress) != 0) {

        networkName = OmObjectName(Network);
        nodeName  = OmObjectName(Network->LocalInterface->Node);

        ClusterLogEvent4(
            LOG_NOISE,
            LOG_CURRENT_MODULE,
            __FILE__,
            __LINE__,
            NM_EVENT_OBTAINED_MULTICAST_LEASE,
            0,
            NULL,
            nodeName,
            Parameters->Address,
            networkName,
            Parameters->LeaseServer
            );
    }

    return;

} // NmpReportMulticastAddressLease


VOID
NmpReportMulticastAddressChoice(
    IN  PNM_NETWORK        Network,
    IN  LPWSTR             Address,
    IN  LPWSTR             OldAddress
    )
/*++

Routine Description:

    Write an event log entry, if not repetitive,
    reporting that a multicast address was
    automatically selected for this network.

    The repetitive criteria is that our previous
    config type was anything other than automatic
    selection or the chosen address is different.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    HDMKEY                networkKey = NULL;
    HDMKEY                netParamKey = NULL;

    NM_MCAST_CONFIG       configType;
    BOOLEAN               writeLogEntry = FALSE;
    LPCWSTR               nodeName;
    LPCWSTR               networkName;


    if (Address == NULL ||
        Network == NULL ||
        Network->LocalInterface == NULL
        ) {
        writeLogEntry = FALSE;
        goto error_exit;
    }

    if (OldAddress == NULL || wcscmp(Address, OldAddress) != 0) {
        writeLogEntry = TRUE;
    }

    if (!writeLogEntry) {

        //
        // Open the network key.
        //
        networkKey = DmOpenKey(
                         DmNetworksKey,
                         networkId,
                         MAXIMUM_ALLOWED
                         );
        if (networkKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for network %1!ws!, "
                "status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }

        status = NmpQueryMulticastConfigType(
                     Network,
                     networkKey,
                     &netParamKey,
                     &configType
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to query multicast config type "
                "for network %1!ws!, status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }

        if (configType != NmMcastConfigAuto) {
            writeLogEntry = TRUE;
        }
    }

    if (writeLogEntry) {

        networkName = OmObjectName(Network);
        nodeName  = OmObjectName(Network->LocalInterface->Node);

        CsLogEvent3(
            LOG_NOISE,
            NM_EVENT_MULTICAST_ADDRESS_CHOICE,
            nodeName,
            Address,
            networkName
            );
    }

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return;

} // NmpReportMulticastAddressChoice


VOID
NmpReportMulticastAddressFailure(
    IN  PNM_NETWORK               Network,
    IN  DWORD                     Error
    )
/*++

Routine Description:

    Write an event log entry reporting failure
    to obtain a multicast address for specified
    network with specified error.

--*/
{
    LPCWSTR      nodeName;
    LPCWSTR      networkName;
    WCHAR        errorString[12];

    if (Network == NULL || Network->LocalInterface == NULL) {
        return;
    }

    nodeName = OmObjectName(Network->LocalInterface->Node);
    networkName = OmObjectName(Network);

    wsprintfW(&(errorString[0]), L"%u", Error);

    CsLogEvent3(
        LOG_UNUSUAL,
        NM_EVENT_MULTICAST_ADDRESS_FAILURE,
        nodeName,
        networkName,
        errorString
        );

    return;

} // NmpReportMulticastAddressFailure


DWORD
NmpGetMulticastAddressSelectionRange(
    IN     PNM_NETWORK            Network,
    IN     HDMKEY                 NetworkKey,
    IN OUT HDMKEY               * NetworkParametersKey,
    OUT    ULONG                * RangeLower,
    OUT    ULONG                * RangeUpper
    )
/*++

Routine Description:

    Queries the cluster database to determine if a selection
    range has been configured. If both lower and upper bounds
    of range are valid, returns that range. Otherwise, returns
    default range.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    LPWSTR        addr = NULL;
    DWORD         addrLen;
    DWORD         size;
    DWORD         hllower, hlupper;

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address selection range "
        "for network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA
    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. "
                "Using default multicast address range.\n",
                networkId, status
                );
#endif // CLUSTER_BETA
            goto usedefault;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Query for the lower bound of the range.
    //
    addr = NULL;
    addrLen = 0;
    size = 0;
    status = NmpQueryString(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_RANGE_LOWER,
                 REG_SZ,
                 &addr,
                 &addrLen,
                 &size
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to read lower bound of "
            "multicast address selection range for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto usedefault;
    }

    status = ClRtlTcpipStringToAddress(addr, RangeLower);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to convert lower bound of "
            "multicast address selection range %1!ws! for "
            "network %2!ws! into TCP/IP address, "
            "status %3!u!. Using default.\n",
            addr, networkId, status
            );
        goto usedefault;
    }

    hllower = ntohl(*RangeLower);
    if (!IN_CLASSD(hllower)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Lower bound of multicast address "
            "selection range %1!ws! for network %2!ws! "
            "is not a class D IPv4 address. "
            "Using default.\n",
            addr, networkId
            );
        goto usedefault;
    }

    //
    // Query for the upper bound of the range.
    //
    size = 0;
    status = NmpQueryString(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_RANGE_UPPER,
                 REG_SZ,
                 &addr,
                 &addrLen,
                 &size
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to read upper bound of "
            "multicast address selection range for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto usedefault;
    }

    status = ClRtlTcpipStringToAddress(addr, RangeUpper);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to convert upper bound of "
            "multicast address selection range %1!ws! for "
            "network %2!ws! into TCP/IP address, "
            "status %3!u!. Using default.\n",
            addr, networkId, status
            );
        goto usedefault;
    }

    hlupper = ntohl(*RangeUpper);
    if (!IN_CLASSD(hlupper)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Upper bound of multicast address "
            "selection range %1!ws! for network %2!ws! "
            "is not a class D IPv4 address. "
            "Using default.\n",
            addr, networkId
            );
        goto usedefault;
    }

    //
    // Make sure it's a legitimate range.
    //
    if (hllower >= hlupper) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast address selection range "
            "[%1!u!.%2!u!.%3!u!.%4!u!, %5!u!.%6!u!.%7!u!.%8!u!] "
            "for network %2!ws! is not valid. "
            "Using default.\n",
            NmpIpAddrPrintArgs(*RangeLower),
            NmpIpAddrPrintArgs(*RangeUpper), networkId
            );
        goto usedefault;
    }

    status = ERROR_SUCCESS;

    goto error_exit;

usedefault:

    *RangeLower = NMP_MCAST_DEFAULT_RANGE_LOWER;
    *RangeUpper = NMP_MCAST_DEFAULT_RANGE_UPPER;

    status = ERROR_SUCCESS;

error_exit:

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Using multicast address selection range "
            "[%1!u!.%2!u!.%3!u!.%4!u!, %5!u!.%6!u!.%7!u!.%8!u!] "
            "for network %9!ws! in cluster database.\n",
            NmpIpAddrPrintArgs(*RangeLower),
            NmpIpAddrPrintArgs(*RangeUpper), networkId
            );

        *NetworkParametersKey = netParamKey;
        netParamKey = NULL;
    }

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (addr != NULL) {
        MIDL_user_free(addr);
        addr = NULL;
    }

    return(status);

} // NmpGetMulticastAddressSelectionRange


DWORD
NmpMulticastExcludeRange(
    IN OUT PLIST_ENTRY         SelectionRange,
    IN     DWORD               HlLower,
    IN     DWORD               HlUpper
    )
/*++

Routine Description:

    Exclude range defined by (HlLower, HlUpper) from
    list of selection intervals in SelectionRange.

Arguments:

    SelectionRange - sorted list of non-overlapping
                     selection intervals

    HlLower - lower bound of exclusion in host format

    HlUpper - upper bound of exclusion in host format

--*/
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PNM_MCAST_RANGE_INTERVAL newInterval;
    PLIST_ENTRY              entry;

    // Determine if the exclusion overlaps with any interval.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        if (HlLower < interval->hlLower &&
            HlUpper < interval->hlUpper) {

            // Exclusion completely misses below interval.
            // Since list is sorted, there is no possibility
            // of a matching interval farther down list.
            break;
        }

        else if (HlLower > interval->hlUpper) {

            // Exclusion completely misses above interval.
            // There might be matching intervals later
            // in sorted list.
        }

        else if (HlLower <= interval->hlLower &&
                 HlUpper >= interval->hlUpper) {

            // Exclusion completely covers interval.
            // Remove interval.
            RemoveEntryList(entry);
        }

        else if (HlLower > interval->hlLower &&
                 HlUpper < interval->hlUpper) {

            // Exclusion splits interval.
            newInterval = LocalAlloc(LMEM_FIXED, sizeof(*newInterval));
            if (newInterval == NULL) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            newInterval->hlLower = HlUpper+1;
            newInterval->hlUpper = interval->hlUpper;

            interval->hlUpper = HlLower-1;

            // Insert the new interval after the current interval
            InsertHeadList(entry, &newInterval->Linkage);

            // We can skip the new interval because we already
            // know how it compares to the exclusion.
            entry = &newInterval->Linkage;
            continue;
        }

        else if (HlLower <= interval->hlLower) {

            // Exclusion overlaps lower part of interval. Shrink
            // interval from below.
            interval->hlLower = HlUpper + 1;
        }

        else {

            // Exclusion overlaps upper part of interval. Shrink
            // interval from above.
            interval->hlUpper = HlLower - 1;
        }
    }

    return(ERROR_SUCCESS);

} // NmpMulticastExcludeRange


BOOLEAN
NmpMulticastAddressInRange(
    IN  PLIST_ENTRY    SelectionRange,
    IN  LPWSTR         McastAddress
    )
/*++

Routine Description:

    Determines if McastAddress is in one of range intervals.

--*/
{
    DWORD                    mcastAddress;
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;

    // Convert the address from a string into an address.
    if (ClRtlTcpipStringToAddress(
            McastAddress,
            &mcastAddress
            ) != ERROR_SUCCESS) {
        return(FALSE);
    }

    mcastAddress = ntohl(mcastAddress);

    // Walk the list of intervals.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        if (mcastAddress >= interval->hlLower &&
            mcastAddress <= interval->hlUpper) {
            return(TRUE);
        }

        else if (mcastAddress < interval->hlLower) {

            // Address is below current interval.
            // Since interval list is sorted in
            // increasing order, there is no chance
            // of a match later in list.
            break;
        }
    }

    return(FALSE);

} // NmpMulticastAddressInRange


DWORD
NmpMulticastAddressRangeSize(
    IN  PLIST_ENTRY  SelectionRange
    )
/*++

Routine Description:

    Returns size of selection range.

--*/
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;
    DWORD                    size = 0;

    // Walk the list of intervals.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        size += NmpMulticastRangeIntervalSize(interval);
    }

    return(size);

} // NmpMulticastAddressRangeSize


DWORD
NmpMulticastRangeOffsetToAddress(
    IN  PLIST_ENTRY          SelectionRange,
    IN  DWORD                Offset
    )
/*++

Routine Description:

    Returns the address that is Offset into the
    SelectionRange. The address is returned in
    host format.

    If SelectionRange is empty, returns 0.
    If Offset falls outside of non-empty range,
    returns upper or lower boundary of selection
    range.

--*/
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;
    DWORD                    address = 0;

    // Walk the list of intervals.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        address = interval->hlLower;

        if (address + Offset <= interval->hlUpper) {
            address = address + Offset;
            break;
        } else {
            address = interval->hlUpper;
            Offset -= NmpMulticastRangeIntervalSize(interval);
        }
    }

    return(address);

} // NmpMulticastRangeOffsetToAddress


VOID
NmpMulticastFreeSelectionRange(
    IN  PLIST_ENTRY   SelectionRange
    )
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;

    while (!IsListEmpty(SelectionRange)) {

        entry = RemoveHeadList(SelectionRange);

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        LocalFree(interval);
    }

    return;

} // NmpMulticastFreeSelectionRange


DWORD
NmpChooseMulticastAddress(
    IN  PNM_NETWORK                       Network,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Choose a default multicast address and fill in
    Parameters appropriately.

    If there is already a valid multicast address in
    the selection range stored in the cluster database,
    continue to use it.

    If there is not already a valid multicast address,
    choose an address within the multicast address range
    by hashing on the last few bytes of the network id
    GUID.

Arguments:

    Network - network address is being chosen for

    Parameters - configuration parameters with new address

--*/
{
    LPCWSTR                  networkId = OmObjectId(Network);
    DWORD                    status = ERROR_SUCCESS;
    HDMKEY                   networkKey = NULL;
    HDMKEY                   netParamKey = NULL;

    PMCAST_SCOPE_ENTRY       scopeList = NULL;
    DWORD                    scopeCount;

    LIST_ENTRY               selectionRange;
    PNM_MCAST_RANGE_INTERVAL interval;
    DWORD                    index;
    DWORD                    hlLower;
    DWORD                    hlUpper;
    DWORD                    networkAddress;
    DWORD                    networkSubnet;

    UUID                     networkIdGuid;
    DWORD                    rangeSize;
    DWORD                    offset;
    DWORD                    address;
    LPWSTR                   mcastAddress = NULL;
    DWORD                    mcastAddressLength = 0;

    InitializeListHead(&selectionRange);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Choosing multicast address for "
        "network %1!ws!.\n",
        networkId
        );

    networkKey = DmOpenKey(
                     DmNetworksKey,
                     networkId,
                     MAXIMUM_ALLOWED
                     );
    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to open key for network %1!ws!, "
            "status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Build an array of selection intervals. These are intervals
    // in the IPv4 class D address space from which an address
    // can be selected.
    //

    // Start with the entire range.
    interval = LocalAlloc(LMEM_FIXED, sizeof(*interval));
    if (interval == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    InsertHeadList(&selectionRange, &interval->Linkage);

    //
    // Get the selection range.
    //
    status = NmpGetMulticastAddressSelectionRange(
                 Network,
                 networkKey,
                 &netParamKey,
                 &interval->hlLower,
                 &interval->hlUpper
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine multicast "
            "address selection range for network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    interval->hlLower = ntohl(interval->hlLower);
    interval->hlUpper = ntohl(interval->hlUpper);

    //
    // Process exclusions from the multicast address
    // selection range, starting with well-known exclusions.
    //
    for (index = 0; index < NmpMulticastRestrictedRangeCount; index++) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Excluding %1!ws! "
            "[%2!u!.%3!u!.%4!u!.%5!u!, %6!u!.%7!u!.%8!u!.%9!u!] "
            "from multicast address range for network %10!ws!.\n",
            NmpMulticastRestrictedRange[index].Description,
            NmpIpAddrPrintArgs(NmpMulticastRestrictedRange[index].Lower),
            NmpIpAddrPrintArgs(NmpMulticastRestrictedRange[index].Upper),
            networkId
            );

        // Convert the exclusion to host format.
        hlLower = ntohl(NmpMulticastRestrictedRange[index].Lower);
        hlUpper = ntohl(NmpMulticastRestrictedRange[index].Upper);

        NmpMulticastExcludeRange(&selectionRange, hlLower, hlUpper);

        // If the selection range is now empty, there is no point
        // in examining other exclusions.
        if (IsListEmpty(&selectionRange)) {
            status = ERROR_INCORRECT_ADDRESS;
            goto error_exit;
        }
    }

    //
    // Process multicast scopes as exclusions. Specifically, any
    // scope whose interface matches this network is excluded
    // because it is conceivable that machines on the network are
    // already using addresses in these scopes.
    //
    status = ClRtlTcpipStringToAddress(
                 Network->Address,
                 &networkAddress
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            Network->Address, status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 Network->AddressMask,
                 &networkSubnet
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address mask string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            Network->AddressMask, status
            );
        goto error_exit;
    }

    //
    // Query multicast scopes to determine if we should
    // exclude any addresses from the selection range.
    //
    status = NmpMulticastEnumerateScopes(
                 FALSE,                 // do not force requery
                 &scopeList,
                 &scopeCount
                 );
    if (status != ERROR_SUCCESS) {
        scopeCount = 0;
    }

    for (index = 0; index < scopeCount; index++) {

        if (ClRtlAreTcpipAddressesOnSameSubnet(
                networkAddress,
                scopeList[index].ScopeCtx.Interface.IpAddrV4,
                networkSubnet
                )) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Excluding MADCAP scope "
                "[%1!u!.%2!u!.%3!u!.%4!u!, %5!u!.%6!u!.%7!u!.%8!u!] "
                "from multicast address selection range for "
                "network %9!ws!.\n",
                NmpIpAddrPrintArgs(scopeList[index].ScopeCtx.ScopeID.IpAddrV4),
                NmpIpAddrPrintArgs(scopeList[index].LastAddr.IpAddrV4),
                networkId
                );

            hlLower = ntohl(scopeList[index].ScopeCtx.ScopeID.IpAddrV4);
            hlUpper = ntohl(scopeList[index].LastAddr.IpAddrV4);

            NmpMulticastExcludeRange(&selectionRange, hlLower, hlUpper);

            // If the selection range is empty, there is no point
            // in examining other exclusions.
            if (IsListEmpty(&selectionRange)) {
                status = ERROR_INCORRECT_ADDRESS;
                goto error_exit;
            }

        }
    }

    //
    // The range of intervals from which we can select an
    // address is now constructed.
    //
    // Before choosing an address, see if there is already an
    // old one in the database that matches the selection range.
    //
    status = NmpQueryMulticastAddress(
                 Network,
                 networkKey,
                 &netParamKey,
                 &mcastAddress,
                 &mcastAddressLength
                 );
    if (status == ERROR_SUCCESS) {

        //
        // We found an address. See if it falls in the range.
        //
        if (!NmpMulticastAddressInRange(&selectionRange, mcastAddress)) {

            //
            // We can't use this address. Free the string.
            //
            MIDL_user_free(mcastAddress);
            mcastAddress = NULL;
        }
    } else {
        mcastAddress = NULL;
    }

    if (mcastAddress == NULL) {

        //
        // Calculate the size of the selection range.
        //
        rangeSize = NmpMulticastAddressRangeSize(&selectionRange);

        //
        // Calculate the range offset using the last DWORD of
        // the network id GUID.
        //
        status = UuidFromString((LPWSTR)networkId, &networkIdGuid);
        if (status == RPC_S_OK) {
            offset = (*((PDWORD)&(networkIdGuid.Data4[4]))) % rangeSize;
        } else {
            offset = 0;
        }

        //
        // Choose an address within the specified range.
        //
        address = NmpMulticastRangeOffsetToAddress(&selectionRange, offset);
        CL_ASSERT(address != 0);
        CL_ASSERT(IN_CLASSD(address));
        address = htonl(address);

        //
        // Convert the address to a string.
        //
        status = ClRtlTcpipAddressToString(address, &mcastAddress);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert selected multicast "
                "address %1!u!.%2!u!.%3!u!.%4!u! for "
                "network %5!ws! to a TCP/IP "
                "address string, status %6!u!.\n",
                NmpIpAddrPrintArgs(address), networkId, status
                );
            goto error_exit;
        }
    }

    //
    // Build a parameters data structure for this address.
    //
    status = NmpMulticastCreateParameters(
                 0,                       // disabled
                 mcastAddress,
                 NULL,                    // key
                 0,                       // key length
                 0,                       // lease obtained
                 0,                       // lease expires (filled in below)
                 NULL,                    // request id
                 NmpNullMulticastAddress, // lease server
                 NmMcastConfigAuto,
                 Parameters
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to build multicast parameters "
            "for network %1!ws! after choosing address, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Calculate the lease renew time. We don't need
    // the lease renew time right now, but a side
    // effect of this routine is to ensure that the
    // lease end time is set correctly (e.g. for
    // manual or auto config).
    //
    NmpCalculateLeaseRenewTime(
        Network,
        NmMcastConfigAuto,
        &Parameters->LeaseObtained,
        &Parameters->LeaseExpires
        );

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Chose multicast address %1!ws! for "
        "network %2!ws!.\n",
        Parameters->Address, networkId
        );

error_exit:

    //
    // If the list is empty, then the selection range
    // is empty, and we could not choose an address.
    //
    if (IsListEmpty(&selectionRange)) {
        CL_ASSERT(status != ERROR_SUCCESS);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Multicast address selection range for "
            "network %1!ws! is empty. Unable to select "
            "a multicast address.\n",
            networkId
            );
    } else {
        NmpMulticastFreeSelectionRange(&selectionRange);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (scopeList != NULL) {
        LocalFree(scopeList);
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    return(status);

} // NmpChooseMulticastAddress


#define NmpMulticastIsScopeMarked(_scope)           \
    ((_scope)->ScopeCtx.Interface.IpAddrV4 == 0 &&  \
     (_scope)->ScopeCtx.ScopeID.IpAddrV4 == 0 &&    \
     (_scope)->ScopeCtx.ServerID.IpAddrV4 == 0)

#define NmpMulticastMarkScope(_scope)               \
    RtlZeroMemory(&((_scope)->ScopeCtx), sizeof((_scope)->ScopeCtx))


BOOLEAN
NmpIsMulticastScopeNetworkValid(
    IN                PIPNG_ADDRESS          LocalAddress,
    IN                PIPNG_ADDRESS          LocalMask,
    IN OUT            PMCAST_SCOPE_ENTRY     Scope,
    OUT    OPTIONAL   BOOLEAN              * InterfaceMatch
    )
/*++

Routine Description:

    Determine if the scope is valid for the network with
    specified local address and mask. The valid criteria are
    - the interface must match (same subnet) the network address.
    - the scope must not be single-source (232.*.*.*), as defined
      by the IANA

    If the scope is not valid, mark it so that future
    consideration is fast. Mark it by zeroing the scope context
    interface field.

Arguments:

    LocalAddress - local address for network

    LocalMask - subnet mask for network

    CurrentScope - scope under consideration

    InterfaceMatch - indicates whether the scope matched the
                     local network interface

Return value:

    TRUE if the scope matches the network.
    FALSE otherwise, and the scope is marked if not already.

--*/
{
    if (InterfaceMatch != NULL) {
        *InterfaceMatch = FALSE;
    }

    //
    // First check if the scope has been marked.
    //
    if (NmpMulticastIsScopeMarked(Scope)) {
        return(FALSE);
    }

    //
    // This scope is not a candidate if it is not on
    // the correct interface.
    //
    if (!ClRtlAreTcpipAddressesOnSameSubnet(
             Scope->ScopeCtx.Interface.IpAddrV4,
             LocalAddress->IpAddrV4,
             LocalMask->IpAddrV4
             )) {

        //
        // Mark this scope to avoid trying it again.
        //
        NmpMulticastMarkScope(Scope);

        return(FALSE);
    }

    //
    // The local interface matches this scope.
    //
    if (InterfaceMatch != NULL) {
        *InterfaceMatch = TRUE;
    }

    //
    // This scope is not a candidate if it is single-source.
    //
    if (ClRtlAreTcpipAddressesOnSameSubnet(
            Scope->ScopeCtx.Interface.IpAddrV4,
            NMP_SINGLE_SOURCE_SCOPE_ADDRESS,
            NMP_SINGLE_SOURCE_SCOPE_MASK
            )) {

        //
        // Mark this scope to avoid trying it again.
        //
        NmpMulticastMarkScope(Scope);

        return(FALSE);
    }

    return(TRUE);

} // NmpIsMulticastScopeNetworkValid


DWORD
NmpNetworkAddressOctetMatchCount(
    IN     ULONG          LocalAddress,
    IN     ULONG          LocalMask,
    IN     ULONG          TargetAddress
    )
/*++

Routine Description:

    Counts the octets matched in the target address
    to the local network number.

    Note: this routine assumes contiguous subnet masks!

Arguments:

    LocalAddress - local IPv4 address

    LocalMask - local IPv4 subnet mask

    TargetAddress - target IPv4 address

Return value:

    Count of octets matched.

--*/
{
    ULONG networkNumber;
    struct in_addr *inNetwork, *inTarget;

    networkNumber = LocalAddress & LocalMask;

    inNetwork = (struct in_addr *) &networkNumber;
    inTarget = (struct in_addr *) &TargetAddress;

    if (inNetwork->S_un.S_un_b.s_b1 != inTarget->S_un.S_un_b.s_b1) {
        return(0);
    }

    if (inNetwork->S_un.S_un_b.s_b2 != inTarget->S_un.S_un_b.s_b2) {
        return(1);
    }

    if (inNetwork->S_un.S_un_b.s_b3 != inTarget->S_un.S_un_b.s_b3) {
        return(2);
    }

    if (inNetwork->S_un.S_un_b.s_b4 != inTarget->S_un.S_un_b.s_b4) {
        return(3);
    }

    return(4);

} // NmpNetworkAddressOctetMatchCount

BOOLEAN
NmpIsMulticastScopeBetter(
    IN     PIPNG_ADDRESS          LocalAddress,
    IN     PIPNG_ADDRESS          LocalMask,
    IN     PMCAST_SCOPE_ENTRY     CurrentScope,
    IN     PMCAST_SCOPE_ENTRY     NewScope
    )
/*++

Routine Description:

    Compares the current scope to the new scope according
    to the scope evaluation criteria. Assumes both scopes
    match the current network.

Arguments:

    LocalAddress - local address for network

    LocalMask - subnet mask for network

    CurrentScope - currently placed scope

    NewScope - possible better scope

Return value:

    TRUE if NewScope is better than CurrentScope

--*/
{
    BOOL    currentLocal, newLocal;
    DWORD   currentCount, newCount;

    //
    // If the new scope is an administrative
    // link-local and the current best is not,
    // then the new scope wins.
    //
    currentLocal = ClRtlAreTcpipAddressesOnSameSubnet(
                       CurrentScope->ScopeCtx.Interface.IpAddrV4,
                       NMP_LOCAL_SCOPE_ADDRESS,
                       NMP_LOCAL_SCOPE_MASK
                       );
    newLocal = ClRtlAreTcpipAddressesOnSameSubnet(
                   NewScope->ScopeCtx.Interface.IpAddrV4,
                   NMP_LOCAL_SCOPE_ADDRESS,
                   NMP_LOCAL_SCOPE_MASK
                   );
    if (newLocal && !currentLocal) {
        return(TRUE);
    } else if (currentLocal && !newLocal) {
        return(FALSE);
    }

    //
    // If the two scopes come from different servers, we
    // rank them according to how close we think the server
    // is.
    //
    if (CurrentScope->ScopeCtx.ServerID.IpAddrV4 !=
        NewScope->ScopeCtx.ServerID.IpAddrV4) {

        //
        // If the new scope's server is on the same subnet as
        // the local address and the current scope's server is
        // not, then the new scope wins.
        //
        currentLocal = ClRtlAreTcpipAddressesOnSameSubnet(
                           CurrentScope->ScopeCtx.ServerID.IpAddrV4,
                           LocalAddress->IpAddrV4,
                           LocalMask->IpAddrV4
                           );
        newLocal = ClRtlAreTcpipAddressesOnSameSubnet(
                       NewScope->ScopeCtx.ServerID.IpAddrV4,
                       LocalAddress->IpAddrV4,
                       LocalMask->IpAddrV4
                       );
        if (newLocal && !currentLocal) {
            return(TRUE);
        } else if (currentLocal && !newLocal) {
            return(FALSE);
        }

        //
        // If neither server is on the same subnet and the new scope's
        // server seems closer than the current scope's server, then
        // the new scope wins. Note that this is only a heuristic.
        //
        if (!newLocal && !currentLocal) {
            currentCount = NmpNetworkAddressOctetMatchCount(
                               LocalAddress->IpAddrV4,
                               LocalMask->IpAddrV4,
                               CurrentScope->ScopeCtx.ServerID.IpAddrV4
                               );
            newCount = NmpNetworkAddressOctetMatchCount(
                           LocalAddress->IpAddrV4,
                           LocalMask->IpAddrV4,
                           NewScope->ScopeCtx.ServerID.IpAddrV4
                           );
            if (newCount > currentCount) {
                return(TRUE);
            } else if (currentCount > newCount) {
                return(FALSE);
            }
        }
    }

    //
    // If the new scope has a larger range than
    // the current best, the new scope wins. The scope
    // range is the last address minus the scope ID.
    // We do not consider exclusions.
    //
    currentCount = CurrentScope->LastAddr.IpAddrV4 -
                   CurrentScope->ScopeCtx.ScopeID.IpAddrV4;
    newCount = NewScope->LastAddr.IpAddrV4 -
               NewScope->ScopeCtx.ScopeID.IpAddrV4;
    if (newCount > currentCount) {
        return(TRUE);
    } else if (currentCount > newCount) {
        return(FALSE);
    }

    //
    // If the new scope has a smaller TTL than
    // the current best, the new scope wins.
    //
    if (NewScope->TTL < CurrentScope->TTL) {
        return(TRUE);
    } else if (CurrentScope->TTL < NewScope->TTL) {
        return(FALSE);
    }

    //
    // No condition was found to indicate that the new scope
    // is better.
    //
    return(FALSE);

} // NmpIsMulticastScopeBetter


DWORD
NmpFindMulticastScopes(
    IN           PNM_NETWORK          Network,
    OUT          PMCAST_SCOPE_CTX   * ScopeCtxList,
    OUT          DWORD              * ScopeCtxCount,
    OUT OPTIONAL BOOLEAN            * FoundInterfaceMatch
    )
/*++

Routine Description:

    Gets an enumeration of multicast scopes from a MADCAP server
    and sorts the scopes according to the multicast scope criteria.
    Allocates and returns an array of scopes that must be freed
    by the caller.

Arguments:

    Network - network for which scope is sought

    ScopeList - returned scope list, must be freed by caller.

    ScopeCount - returned count of scopes in list

    FoundInterfaceMatch - TRUE if at least one scope in the scope
                          list matches this network's interface

Return value:

    Status of enumeration or allocations.

--*/
{
    LPCWSTR            networkId = OmObjectId(Network);
    DWORD              status;

    PMCAST_SCOPE_ENTRY scopeList = NULL;
    DWORD              scopeCount;
    DWORD              scope;
    PMCAST_SCOPE_CTX   sortedCtxList = NULL;
    DWORD              sortedCount = 0;
    DWORD              sortedScopeCtx;
    PMCAST_SCOPE_ENTRY nextScope;
    BOOLEAN            currentCorrectInterface = FALSE;
    BOOLEAN            foundInterfaceMatch = FALSE;

    IPNG_ADDRESS       networkAddress;
    IPNG_ADDRESS       networkSubnet;


    CL_ASSERT(ScopeCtxList != NULL);
    CL_ASSERT(ScopeCtxCount != NULL);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Finding multicast scopes for "
        "network %1!ws!.\n",
        networkId
        );

    status = NmpMulticastEnumerateScopes(
                 TRUE,        // force requery
                 &scopeList,
                 &scopeCount
                 );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_TIMEOUT || status == ERROR_NO_DATA) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Request to MADCAP server failed while "
                "enumerating scopes for network %1!ws! "
                "(status %2!u!). Assuming there are currently "
                "no MADCAP servers on the network.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to enumerate multicast scopes for "
                "network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

    if (scopeCount == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Zero multicast scopes located in enumeration "
            "on network %1!ws!.\n",
            networkId
            );
        goto error_exit;
    }

    //
    // Get the network's address and mask, used to evaluate
    // scopes.
    //
    // Note: this code is IPv4 specific in that it relies on the
    //       IP address fitting into a ULONG. It uses the
    //       IPNG_ADDRESS data structure only to work with the
    //       MADCAP API.
    //
    status = ClRtlTcpipStringToAddress(
                 Network->Address,
                 &(networkAddress.IpAddrV4)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            Network->Address, status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 Network->AddressMask,
                 &(networkSubnet.IpAddrV4)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address mask string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            Network->AddressMask, status
            );
        goto error_exit;
    }

    ClRtlLogPrint(
        LOG_NOISE,
        "[NM] Ranking multicast scopes for network "
        "%1!ws! with address %2!ws! and mask %3!ws!.\n",
        networkId, Network->Address, Network->AddressMask
        );

    //
    // Iterate through the scope list to count the valid scopes
    // for this network. Also remember whether any scope matches
    // the local network interface.
    // Note that this test munges the scope entries.
    //
    for (scope = 0, sortedCount = 0; scope < scopeCount; scope++) {

        if (NmpIsMulticastScopeNetworkValid(
                &networkAddress,
                &networkSubnet,
                &(scopeList[scope]),
                &currentCorrectInterface
                )) {
            sortedCount++;
        }

        foundInterfaceMatch =
            (BOOLEAN)(foundInterfaceMatch || currentCorrectInterface);
    }

    //
    // Exit if no valid scopes were found.
    //
    if (sortedCount == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to locate a valid multicast scope "
            "for network %1!ws!.\n",
            networkId
            );
        goto error_exit;
    }

    //
    // Allocate a new scope list for the sorted scope contexts. The
    // scope context is all that is needed for an address lease
    // request.
    //
    sortedCtxList = MIDL_user_allocate(sortedCount * sizeof(MCAST_SCOPE_CTX));
    if (sortedCtxList == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate multicast scope context "
            "list for %1!u! scopes.\n",
            sortedCount
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Rank the enumerated scopes using a variation of
    // insertion sort.
    // Note that the scope list returned by the enumeration is munged.
    //
    for (sortedScopeCtx = 0; sortedScopeCtx < sortedCount; sortedScopeCtx++) {

        //
        // Find the next valid scope in the list returned from
        // the enumeration.
        //
        nextScope = NULL;

        for (scope = 0; scope < scopeCount; scope++) {

            if (!NmpMulticastIsScopeMarked(&scopeList[scope])) {
                nextScope = &scopeList[scope];
                break;
            }
        }

        if (nextScope == NULL) {
            //
            // There are no more valid scopes for this network.
            //
            break;
        }

        //
        // We know that there is at least one valid scope, but we
        // want the best of the unranked scopes. Compare the scope
        // we picked from the list to all those remaining.
        //
        for (scope++; scope < scopeCount; scope++) {

            if (!NmpMulticastIsScopeMarked(&scopeList[scope]) &&
                NmpIsMulticastScopeBetter(
                    &networkAddress,
                    &networkSubnet,
                    nextScope,
                    &scopeList[scope]
                    )) {

                nextScope = &scopeList[scope];
            }
        }

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Ranking scope on "
            "interface %1!u!.%2!u!.%3!u!.%4!u!, "
            "id %5!u!.%6!u!.%7!u!.%8!u!, "
            "last address %9!u!.%10!u!.%11!u!.%12!u!, "
            "from server %13!u!.%14!u!.%15!u!.%16!u!, with "
            "description %17!ws!, "
            "in list position %18!u!.\n",
            NmpIpAddrPrintArgs(nextScope->ScopeCtx.Interface.IpAddrV4),
            NmpIpAddrPrintArgs(nextScope->ScopeCtx.ScopeID.IpAddrV4),
            NmpIpAddrPrintArgs(nextScope->LastAddr.IpAddrV4),
            NmpIpAddrPrintArgs(nextScope->ScopeCtx.ServerID.IpAddrV4),
            nextScope->ScopeDesc.Buffer,
            sortedScopeCtx
            );

        //
        // Copy the scope context into the sorted scope context
        // list.
        //
        sortedCtxList[sortedScopeCtx] = nextScope->ScopeCtx;

        //
        // Mark the scope so that it is not used again.
        //
        NmpMulticastMarkScope(nextScope);
    }

error_exit:

    *ScopeCtxList = sortedCtxList;
    *ScopeCtxCount = sortedCount;

    if (FoundInterfaceMatch != NULL) {
        *FoundInterfaceMatch = foundInterfaceMatch;
    }

    if (scopeList != NULL) {
        LocalFree(scopeList);
    }

    return(status);

} // NmpFindMulticastScopes


DWORD
NmpGenerateMulticastRequestId(
    IN OUT LPMCAST_CLIENT_UID   RequestId
    )
/*++

Routine Description:

    Allocate, if necessary, and generate a client request id
    data structure. If the buffer described by the input
    MCAST_CLIENT_UID data structure is too small, it is
    deallocated.

Arguments:

    RequestId - IN: pointer to MCAST_CLIENT_UID data structure.
                    if ClientUID field is non-NULL, it points
                        to a buffer for the generated ID and
                        ClientUIDLength is the length of that
                        buffer.
                OUT: filled in MCAST_CLIENT_UID data structure.

--*/
{
    DWORD               status;
    LPBYTE              clientUid = NULL;
    MCAST_CLIENT_UID    requestId;
    DWORD               clientUidLength;

    CL_ASSERT(RequestId != NULL);

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Generating MADCAP client request id.\n"
        );
#endif // CLUSTER_BETA

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Allocate a buffer for the client uid, if necessary.
    //
    clientUid = RequestId->ClientUID;
    clientUidLength = RequestId->ClientUIDLength;

    if (clientUid != NULL && clientUidLength < MCAST_CLIENT_ID_LEN) {
        MIDL_user_free(clientUid);
        clientUid = NULL;
        clientUidLength = 0;
        RequestId->ClientUID = NULL;
    }

    if (clientUid == NULL) {
        clientUidLength = MCAST_CLIENT_ID_LEN;
        clientUid = MIDL_user_allocate(clientUidLength);
        if (clientUid == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer for multicast "
                "clientUid.\n"
                );
            goto error_exit;
        }
    }

    //
    // Obtain a new ID.
    //
    requestId.ClientUID = clientUid;
    requestId.ClientUIDLength = clientUidLength;
    status = McastGenUID(&requestId);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to obtain multicast address "
            "request client id, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    *RequestId = requestId;
    clientUid = NULL;

error_exit:

    if (clientUid != NULL) {
        MIDL_user_free(clientUid);
        clientUid = NULL;
    }

    return(status);

} // NmpGenerateMulticastRequestId


DWORD
NmpRequestMulticastAddress(
    IN     PNM_NETWORK                Network,
    IN     BOOLEAN                    Renew,
    IN     PMCAST_SCOPE_CTX           ScopeCtx,
    IN     LPMCAST_CLIENT_UID         RequestId,
    IN OUT LPWSTR                   * McastAddress,
    IN OUT DWORD                    * McastAddressLength,
    IN OUT LPWSTR                   * ServerAddress,
    IN OUT DWORD                    * ServerAddressLength,
       OUT time_t                   * LeaseStartTime,
       OUT time_t                   * LeaseEndTime,
       OUT BOOLEAN                  * NewMcastAddress
    )
/*++

Routine Description:

    Renew lease on multicast group address using MADCAP
    client API.

Arguments:

    Network - network on which address is used

    ScopeCtx - multicast scope (ignored if Renew)

    RequestId - client request id

    McastAddress - IN: address to renew (ignored if !Renew)
                   OUT: resulting address

    McastAddressLength - length of McastAddress buffer

    ServerAddress - IN: address of server on which to renew
                        (ignored if !Renew)
                    OUT: address of address where renew occurred

    ServerAddressLength - length of ServerAddress buffer

    LeaseStartTime - UTC lease start time in seconds (buffer
                     allocated by caller)

    LeaseEndTime - UTC lease stop time in seconds (buffer
                   allocated by caller)

    NewMcastAddress - whether resulting mcast address is
                      new (different than request on renewal
                      and always true on successful request)

--*/
{
    DWORD                     status;
    LPCWSTR                   networkId = OmObjectId(Network);
    UCHAR                     requestBuffer[NMP_MADCAP_REQUEST_BUFFER_SIZE];
    PMCAST_LEASE_REQUEST      request;
    UCHAR                     responseBuffer[NMP_MADCAP_RESPONSE_BUFFER_SIZE];
    PMCAST_LEASE_RESPONSE     response;
    LPWSTR                    address = NULL;
    DWORD                     addressSize;
    DWORD                     requestAddress = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Preparing to send multicast address %1!ws! "
        "for network %2!ws! to MADCAP server.\n",
        ((Renew) ? L"renewal" : L"request"),
        OmObjectId(Network)
        );

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Fill in the request. All fields are zero except those
    // set below.
    //
    request = (PMCAST_LEASE_REQUEST) &requestBuffer[0];
    RtlZeroMemory(request, sizeof(requestBuffer));
    request->MinLeaseDuration = 0;       // currently ignored
    request->MinAddrCount = 1;           // currently ignored
    request->MaxLeaseStartTime = (LONG) time(NULL); // currently ignored
    request->AddrCount = 1;

    //
    // Set the renew parameters.
    //
    if (Renew) {

        request->pAddrBuf = (PBYTE)request + NMP_MADCAP_REQUEST_ADDR_OFFSET;

        status = ClRtlTcpipStringToAddress(
                     *McastAddress,
                     &requestAddress
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert requested address %1!ws! "
                "into a TCP/IP address, status %2!u!.\n",
                *McastAddress, status
                );
            goto error_exit;
        }
        *((PULONG) request->pAddrBuf) = requestAddress;

        status = ClRtlTcpipStringToAddress(
                     *ServerAddress,
                     (PULONG) &(request->ServerAddress.IpAddrV4)
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert server address %1!ws! "
                "into a TCP/IP address, status %2!u!.\n",
                *ServerAddress, status
                );
            goto error_exit;
        }
    }

    //
    // Set the address count and buffer fields in the response.
    //
    response = (PMCAST_LEASE_RESPONSE) &responseBuffer[0];
    RtlZeroMemory(response, sizeof(responseBuffer));
    response->AddrCount = 1;
    response->pAddrBuf = (PBYTE)(response) + NMP_MADCAP_RESPONSE_ADDR_OFFSET;

    //
    // Renew or request, as indicated.
    //
    if (Renew) {

        status = McastRenewAddress(
                     AF_INET,
                     RequestId,
                     request,
                     response
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to renew multicast address %1!ws! "
                "with server %2!ws!, status %3!u!.\n",
                *McastAddress, *ServerAddress, status
                );
            goto error_exit;
        }

    } else {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Requesting multicast address on "
            "Scope ID %1!u!.%2!u!.%3!u!.%4!u!, "
            "Server ID %5!u!.%6!u!.%7!u!.%8!u!, "
            "Interface %9!u!.%10!u!.%11!u!.%12!u!, "
            "for network %13!ws!.\n",
            NmpIpAddrPrintArgs(ScopeCtx->ScopeID.IpAddrV4),
            NmpIpAddrPrintArgs(ScopeCtx->ServerID.IpAddrV4),
            NmpIpAddrPrintArgs(ScopeCtx->Interface.IpAddrV4),
            networkId
            );

        status = McastRequestAddress(
                     AF_INET,
                     RequestId,
                     ScopeCtx,
                     request,
                     response
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to obtain multicast address on "
                "Scope ID %1!u!.%2!u!.%3!u!.%4!u!, "
                "Server ID %5!u!.%6!u!.%7!u!.%8!u!, "
                "Interface %9!u!.%10!u!.%11!u!.%12!u!, "
                "for network %13!ws!, status %14!u!.\n",
                NmpIpAddrPrintArgs(ScopeCtx->ScopeID.IpAddrV4),
                NmpIpAddrPrintArgs(ScopeCtx->ServerID.IpAddrV4),
                NmpIpAddrPrintArgs(ScopeCtx->Interface.IpAddrV4),
                networkId, status
                );
            goto error_exit;
        }
    }

    //
    // Return results through out parameters.
    //
    address = NULL;
    status = ClRtlTcpipAddressToString(
                 response->ServerAddress.IpAddrV4,
                 &address
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert server address %1!x! "
            "into a TCP/IP address string, status %2!u!.\n",
            response->ServerAddress.IpAddrV4, status
            );
        goto error_exit;
    }

    status = NmpStoreString(address, ServerAddress, ServerAddressLength);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to store server address %1!ws! "
            "in return buffer, status %2!u!.\n",
            address, status
            );
        goto error_exit;
    }

    LocalFree(address);
    address = NULL;

    status = ClRtlTcpipAddressToString(
                 *((PULONG) response->pAddrBuf),
                 &address
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert leased address %1!x! "
            "into a TCP/IP address string, status %2!u!.\n",
            *((PULONG) response->pAddrBuf), status
            );
        goto error_exit;
    }

    status = NmpStoreString(address, McastAddress, McastAddressLength);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to store leased address %1!ws! "
            "in return buffer, status %2!u!.\n",
            address, status
            );
        goto error_exit;
    }

    if (Renew) {
        if (*((PULONG) response->pAddrBuf) != requestAddress) {
            *NewMcastAddress = TRUE;
        } else {
            *NewMcastAddress = FALSE;
        }
    } else {
        *NewMcastAddress = TRUE;
    }

    *LeaseStartTime = response->LeaseStartTime;
    *LeaseEndTime = response->LeaseEndTime;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Obtained lease on multicast address %1!ws! "
        "(%2!ws!) from MADCAP server %3!ws! for network %4!ws!.\n",
        *McastAddress,
        ((*NewMcastAddress) ? L"new" : L"same"),
        *ServerAddress, networkId
        );

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Lease starts at %1!u!, ends at %2!u!, "
        "duration %3!u!.\n",
        *LeaseStartTime, *LeaseEndTime, *LeaseEndTime - *LeaseStartTime
        );
#endif // CLUSTER_BETA

error_exit:

    if (address != NULL) {
        LocalFree(address);
        address = NULL;
    }

    return(status);

} // NmpRequestMulticastAddress


NM_MCAST_LEASE_STATUS
NmpCalculateLeaseStatus(
    IN     PNM_NETWORK   Network,
    IN     time_t        LeaseObtained,
    IN     time_t        LeaseExpires
    )
/*++

Routine Description:

    Calculate lease status based on current time,
    lease end time, and config type. If config type
    is auto, we do not use a half-life for the lease.

    Rely on the compiler's correct code generation for
    time_t math!

Return value:

    Lease status

--*/
{
    LPCWSTR                  networkId = OmObjectId(Network);
    time_t                   currentTime;
    time_t                   renewThreshold;
    NM_MCAST_LEASE_STATUS    status;

    if (Network->ConfigType == NmMcastConfigManual ||
        LeaseExpires == 0 ||
        LeaseExpires <= LeaseObtained) {

        //
        // A lease expiration of 0 means we hold the lease
        // forever. Most likely, an administrator statically
        // configured the network with this address.
        //
        status = NmMcastLeaseValid;

    } else {

        time(&currentTime);

        if (currentTime > LeaseExpires) {
            status = NmMcastLeaseExpired;
        } else {

            if (Network->ConfigType == NmMcastConfigAuto) {
                // We chose this address. There is no server
                // expiring it. Use the chosen expiration time
                // rather than the half-life.
                renewThreshold = LeaseExpires;
            } else {
                // We got this address from a MADCAP server.
                // Renew at half-life.
                renewThreshold = LeaseObtained +
                                 ((LeaseExpires - LeaseObtained) / 2);
            }

            if (currentTime >= renewThreshold) {
                status = NmMcastLeaseNeedsRenewal;
            } else {
                status = NmMcastLeaseValid;
            }
        }
    }

#if CLUSTER_BETA
    if (Network->ConfigType == NmMcastConfigManual ||
        LeaseExpires == 0 ||
        LeaseExpires <= LeaseObtained) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Found that multicast address lease for "
            "network %1!ws! does not expire.\n",
            networkId
            );
    } else if (status == NmMcastLeaseExpired) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Found that multicast address lease for "
            "network %1!ws! expired %2!u! seconds ago.\n",
            networkId, currentTime - LeaseExpires
            );
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Found that multicast address lease for "
            "network %1!ws! expires in %2!u! seconds. With "
            "lease obtained %3!u! seconds ago, renewal is "
            "%4!ws!needed.\n",
            networkId, LeaseExpires - currentTime,
            currentTime - LeaseObtained,
            ((status > NmMcastLeaseValid) ? L"" : L"not ")
            );
    }
#endif // CLUSTER_BETA

    return(status);

} // NmpCalculateLeaseStatus

DWORD
NmpQueryMulticastAddressLease(
    IN     PNM_NETWORK             Network,
    IN     HDMKEY                  NetworkKey,
    IN OUT HDMKEY                * NetworkParametersKey,
       OUT NM_MCAST_LEASE_STATUS * LeaseStatus,
       OUT time_t                * LeaseObtained,
       OUT time_t                * LeaseExpires
    )
/*++

Routine Description:

    Query the lease obtained and expires times stored in the
    cluster database.

Return value:

    Error if lease times not found.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;

    DWORD         type;
    DWORD         len;
    time_t        leaseExpires;
    time_t        leaseObtained;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address lease for "
        "network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Query the lease obtained and expires value from the
    // cluster database.
    //
    len = sizeof(leaseObtained);
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED,
                 &type,
                 (LPBYTE) &leaseObtained,
                 &len
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast lease obtained "
            " time for network %1!ws! from cluster database, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    } else if (type != REG_DWORD) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Unexpected type (%1!u!) for network "
            "%2!ws! %3!ws!.\n",
            type, networkId, CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED
            );
        status = ERROR_DATATYPE_MISMATCH;
        goto error_exit;
    }

    len = sizeof(leaseExpires);
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES,
                 &type,
                 (LPBYTE) &leaseExpires,
                 &len
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast lease expiration "
            " time for network %1!ws! from cluster database, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    } else if (type != REG_DWORD) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Unexpected type (%1!u!) for network "
            "%2!ws! %3!ws!.\n",
            type, networkId, CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES
            );
        status = ERROR_DATATYPE_MISMATCH;
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;

    *LeaseStatus = NmpCalculateLeaseStatus(
                       Network,
                       leaseObtained,
                       leaseExpires
                       );

    *LeaseObtained = leaseObtained;
    *LeaseExpires = leaseExpires;

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpQueryMulticastAddressLease


VOID
NmpCheckMulticastAddressLease(
    IN     PNM_NETWORK             Network,
       OUT NM_MCAST_LEASE_STATUS * LeaseStatus,
       OUT time_t                * LeaseObtained,
       OUT time_t                * LeaseExpires
    )
/*++

Routine Description:

    Check the lease parameters stored in the network
    object. Determine if a lease renew is required.

Notes:

    Called and returns with NM lock held.

--*/
{
#if CLUSTER_BETA
    LPCWSTR               networkId = OmObjectId(Network);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Checking multicast address lease for "
        "network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    //
    // Determine if we need to renew.
    //
    *LeaseStatus = NmpCalculateLeaseStatus(
                       Network,
                       Network->MulticastLeaseObtained,
                       Network->MulticastLeaseExpires
                       );

    *LeaseObtained = Network->MulticastLeaseObtained;
    *LeaseExpires = Network->MulticastLeaseExpires;

    return;

} // NmpCheckMulticastAddressLease


DWORD
NmpMulticastGetDatabaseLeaseParameters(
    IN              PNM_NETWORK          Network,
    IN OUT          HDMKEY             * NetworkKey,
    IN OUT          HDMKEY             * NetworkParametersKey,
       OUT OPTIONAL LPMCAST_CLIENT_UID   RequestId,
       OUT OPTIONAL LPWSTR             * ServerAddress,
       OUT OPTIONAL LPWSTR             * McastAddress
    )
/*++

Routine Description:

    Read parameters needed to renew a lease from the
    cluster database.

Return value:

    SUCCESS if all parameters were successfully read.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    HDMKEY                networkKey = NULL;
    BOOLEAN               openedNetworkKey = FALSE;
    HDMKEY                netParamKey = NULL;
    BOOLEAN               openedNetParamKey = FALSE;

    DWORD                 type;
    DWORD                 len;

    MCAST_CLIENT_UID      requestId = { NULL, 0 };
    LPWSTR                serverAddress = NULL;
    DWORD                 serverAddressLength = 0;
    LPWSTR                mcastAddress = NULL;
    DWORD                 mcastAddressLength = 0;

    //
    // Open the network key, if necessary.
    //
    networkKey = *NetworkKey;

    if (networkKey == NULL) {

        networkKey = DmOpenKey(
                         DmNetworksKey,
                         networkId,
                         MAXIMUM_ALLOWED
                         );
        if (networkKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for network %1!ws!, "
                "status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }
        openedNetworkKey = TRUE;
    }

    //
    // Open the network parameters key if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          networkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open Parameters key for "
                "network %1!ws!, status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }
        openedNetParamKey = TRUE;
    }

    //
    // Read the client request id.
    //
    if (RequestId != NULL) {
        requestId.ClientUIDLength = MCAST_CLIENT_ID_LEN;
        requestId.ClientUID = MIDL_user_allocate(requestId.ClientUIDLength);
        if (requestId.ClientUID == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer to read "
                "request id from Parameters database "
                "key for network %1!ws!.\n",
                networkId
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        len = requestId.ClientUIDLength;
        status = DmQueryValue(
                     netParamKey,
                     CLUSREG_NAME_NET_MCAST_REQUEST_ID,
                     &type,
                     (LPBYTE) requestId.ClientUID,
                     &len
                     );
        if (status == ERROR_SUCCESS) {
            if (type != REG_BINARY) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Unexpected type (%1!u!) for network "
                    "%2!ws! %3!ws!, status %4!u!.\n",
                    type, networkId,
                    CLUSREG_NAME_NET_MCAST_REQUEST_ID, status
                    );
                goto error_exit;
            }
            requestId.ClientUIDLength = len;
        } else {
            goto error_exit;
        }
    }

    //
    // Read the address of the server that granted the
    // current lease.
    //
    if (ServerAddress != NULL) {
        serverAddress = NULL;
        serverAddressLength = 0;
        status = NmpQueryString(
                     netParamKey,
                     CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS,
                     REG_SZ,
                     &serverAddress,
                     &serverAddressLength,
                     &len
                     );
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    //
    // Read the last known multicast address.
    //
    if (McastAddress != NULL) {
        status = NmpQueryMulticastAddress(
                     Network,
                     networkKey,
                     &netParamKey,
                     &mcastAddress,
                     &mcastAddressLength
                     );
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
        if (!NmpMulticastValidateAddress(mcastAddress)) {
            MIDL_user_free(mcastAddress);
            mcastAddress = NULL;
            mcastAddressLength = 0;
            goto error_exit;
        }
    }

    //
    // We found all the parameters.
    //
    *NetworkKey = networkKey;
    networkKey = NULL;
    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;
    if (RequestId != NULL) {
        *RequestId = requestId;
        requestId.ClientUID = NULL;
        requestId.ClientUIDLength = 0;
    }
    if (ServerAddress != NULL) {
        *ServerAddress = serverAddress;
        serverAddress = NULL;
    }
    if (McastAddress != NULL) {
        *McastAddress = mcastAddress;
        mcastAddress = NULL;
    }

    status = ERROR_SUCCESS;

error_exit:

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        requestId.ClientUID = NULL;
        requestId.ClientUIDLength = 0;
    }

    if (serverAddress != NULL) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (openedNetworkKey && networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpMulticastGetDatabaseLeaseParameters


DWORD
NmpMulticastGetNetworkLeaseParameters(
    IN     PNM_NETWORK          Network,
       OUT LPMCAST_CLIENT_UID   RequestId,
       OUT LPWSTR             * ServerAddress,
       OUT LPWSTR             * McastAddress
    )
/*++

Routine Description:

    Read parameters needed to renew a lease from the
    network object data structure.

Return value:

    SUCCESS if all parameters were successfully read.

Notes:

    Must be called with NM lock held.

--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);

    MCAST_CLIENT_UID      requestId = { NULL, 0 };
    LPWSTR                serverAddress = NULL;
    DWORD                 serverAddressLength = 0;
    LPWSTR                mcastAddress = NULL;
    DWORD                 mcastAddressLength = 0;


    if (Network->MulticastAddress == NULL ||
        Network->MulticastLeaseServer == NULL ||
        Network->MulticastLeaseRequestId.ClientUID == NULL) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to locate multicast lease "
            "parameter in network object %1!ws!.\n",
            networkId
            );
        status = ERROR_NOT_FOUND;
        goto error_exit;
    }

    status = NmpStoreString(
                 Network->MulticastAddress,
                 &mcastAddress,
                 NULL
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to copy multicast address %1!ws! "
            "from network object %2!ws!, status %3!u!.\n",
            Network->MulticastAddress,
            networkId, status
            );
        goto error_exit;
    }

    status = NmpStoreString(
                 Network->MulticastLeaseServer,
                 &serverAddress,
                 NULL
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to copy lease server address %1!ws! "
            "from network object %2!ws!, status %3!u!.\n",
            Network->MulticastLeaseServer,
            networkId, status
            );
        goto error_exit;
    }

    status = NmpStoreRequestId(
                 &(Network->MulticastLeaseRequestId),
                 &requestId
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to copy lease request id "
            "from network object %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    *RequestId = requestId;
    requestId.ClientUID = NULL;
    requestId.ClientUIDLength = 0;
    *ServerAddress = serverAddress;
    serverAddress = NULL;
    *McastAddress = mcastAddress;
    mcastAddress = NULL;

    status = ERROR_SUCCESS;

error_exit:

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        RtlZeroMemory(&requestId, sizeof(requestId));
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (serverAddress != NULL) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    return(status);

} // NmpMulticastGetNetworkLeaseParameters


DWORD
NmpMulticastNeedRetryRenew(
    IN     PNM_NETWORK                       Network,
    OUT    time_t                          * DeferRetry
    )
/*++

Routine Description:

    Called after a MADCAP timeout, determines whether
    a new MADCAP request should be sent after a delay.
    Specifically, a retry after delay is in order when
    the current address was obtained from a MADCAP
    server that might simply be temporarily unresponsive.

    The default is to not retry.

Arguments:

    Network - network

    DeferRetry - OUT: seconds to defer until retrying
                      MADCAP query, or zero if should
                      not retry

--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    HDMKEY                networkKey = NULL;
    HDMKEY                netParamKey = NULL;

    NM_MCAST_CONFIG       configType;
    NM_MCAST_LEASE_STATUS leaseStatus;
    time_t                leaseObtained;
    time_t                leaseExpires;
    time_t                currentTime;
    time_t                halfhalfLife;

    *DeferRetry = 0;

    //
    // Open the network key.
    //
    networkKey = DmOpenKey(
                     DmNetworksKey,
                     networkId,
                     MAXIMUM_ALLOWED
                     );
    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to open key for network %1!ws!, "
            "status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    status = NmpQueryMulticastConfigType(
                 Network,
                 networkKey,
                 &netParamKey,
                 &configType
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to query multicast config type "
            "for network %1!ws!, status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    if (configType != NmMcastConfigMadcap) {
        goto error_exit;
    }

    status = NmpQueryMulticastAddressLease(
                 Network,
                 networkKey,
                 &netParamKey,
                 &leaseStatus,
                 &leaseObtained,
                 &leaseExpires
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to query multicast lease expiration "
            "time for network %1!ws!, status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Check if the lease has expired.
    //
    if (leaseStatus == NmMcastLeaseExpired) {
        goto error_exit;
    }

    //
    // Check if we are within the threshold of expiration.
    //
    currentTime = time(NULL);
    if (leaseExpires <= currentTime ||
        leaseExpires - currentTime < NMP_MCAST_LEASE_RENEWAL_THRESHOLD) {
        goto error_exit;
    }

    //
    // Calculate half the time until expiration.
    //
    halfhalfLife = currentTime + ((leaseExpires - currentTime) / 2);

    if (leaseExpires - halfhalfLife < NMP_MCAST_LEASE_RENEWAL_THRESHOLD) {
        *DeferRetry = NMP_MCAST_LEASE_RENEWAL_THRESHOLD;
    } else {
        *DeferRetry = halfhalfLife - currentTime;
    }

    status = ERROR_SUCCESS;

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpMulticastNeedRetryRenew


DWORD
NmpGetMulticastAddress(
    IN     PNM_NETWORK                       Network,
    IN OUT LPWSTR                          * McastAddress,
    IN OUT LPWSTR                          * ServerAddress,
    IN OUT LPMCAST_CLIENT_UID                RequestId,
       OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Try to obtain a multicast address lease. If the
    address, server, and request id are non-NULL, first
    try to renew. If unsuccessful in renewing, try a
    new lease.

    Return lease parameters through Parameters.

    Free McastAddress, ServerAddress, and RequestId
    if new values are returned through Parameters.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD                 status = ERROR_SUCCESS;
    LPCWSTR               networkId = OmObjectId(Network);
    BOOLEAN               renew = FALSE;
    BOOLEAN               madcapTimeout = FALSE;
    BOOLEAN               newMcastAddress = FALSE;
    NM_MCAST_CONFIG       configType = NmMcastConfigAuto;

    PMCAST_SCOPE_CTX      scopeCtxList = NULL;
    DWORD                 scopeCtxCount;
    DWORD                 scopeCtx;
    BOOLEAN               interfaceMatch = FALSE;
    DWORD                 mcastAddressLength = 0;
    LPWSTR                serverAddress = NULL;
    DWORD                 serverAddressLength = 0;
    MCAST_CLIENT_UID      requestId = {NULL, 0};
    time_t                leaseStartTime;
    time_t                leaseEndTime;
    DWORD                 len;

    //
    // First try to renew, but only if the proper parameters are
    // supplied.
    //
    renew = (BOOLEAN)(*McastAddress != NULL &&
                      *ServerAddress != NULL &&
                      RequestId->ClientUID != NULL &&
                      NmpMulticastValidateAddress(*McastAddress) &&
                      lstrcmpW(*ServerAddress, NmpNullMulticastAddress) != 0
                      );

    if (renew) {

        mcastAddressLength = NM_WCSLEN(*McastAddress);
        serverAddressLength = NM_WCSLEN(*ServerAddress);

        status = NmpRequestMulticastAddress(
                     Network,
                     TRUE,
                     NULL,
                     RequestId,
                     McastAddress,
                     &mcastAddressLength,
                     ServerAddress,
                     &serverAddressLength,
                     &leaseStartTime,
                     &leaseEndTime,
                     &newMcastAddress
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to renew multicast address "
                "for network %1!ws!, status %2!u!. Attempting "
                "a fresh request ...\n",
                networkId, status
                );
        }
    }

    //
    // Try a fresh request if we had no lease to renew or the
    // renewal failed.
    //
    if (!renew || status != ERROR_SUCCESS) {

        //
        // Get the multicast scopes that match this network.
        //
        status = NmpFindMulticastScopes(
                     Network,
                     &scopeCtxList,
                     &scopeCtxCount,
                     &interfaceMatch
                     );
        if (status != ERROR_SUCCESS || scopeCtxCount == 0) {
            if (status == ERROR_TIMEOUT) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Attempt to contact MADCAP server timed "
                    "out while enumerating multicast scopes "
                    "(status %1!u!). Selecting default multicast "
                    "address for network %2!ws! ...\n",
                    status, networkId
                    );
                //
                // Set the MADCAP timeout flag to TRUE, even
                // if we already contacted a MADCAP server for
                // renewal (but was denied). The theory is that
                // that MADCAP server is no longer serving this
                // network if it failed to respond to an enumerate
                // scopes request.
                //
                madcapTimeout = TRUE;
                goto error_exit;
            } else if (interfaceMatch) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to find viable multicast scope "
                    "for network %1!ws! (status %2!u!), but cannot "
                    "choose a default address since a MADCAP server "
                    "was detected on this network.\n",
                    networkId, status
                    );
                madcapTimeout = FALSE;
                goto error_exit;
            } else {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] MADCAP server reported no viable multicast "
                    "scopes on interface for network %1!ws!. "
                    "Selecting default multicast address ... \n",
                    networkId
                    );
                //
                // Treat this situation as a MADCAP timeout,
                // because there are likely no MADCAP servers
                // for this network.
                //
                madcapTimeout = TRUE;
                goto error_exit;
            }
        }

        CL_ASSERT(scopeCtxList != NULL && scopeCtxCount > 0);

        //
        // The scope context list is sorted by preference. Start
        // at the beginning of the list and request an address
        // lease in each scope until one is granted. Generate a
        // new request id for each request.
        //
        for (scopeCtx = 0; scopeCtx < scopeCtxCount; scopeCtx++) {

            //
            // Generate a client request id.
            //
            status = NmpGenerateMulticastRequestId(RequestId);
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to generate multicast client "
                    "request ID for network %1!ws!, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }

            //
            // Request a lease.
            //
            mcastAddressLength =
                (*McastAddress == NULL) ? 0 : NM_WCSLEN(*McastAddress);
            serverAddressLength =
                (*ServerAddress == NULL) ? 0 : NM_WCSLEN(*ServerAddress);
            status = NmpRequestMulticastAddress(
                         Network,
                         FALSE,
                         &scopeCtxList[scopeCtx],
                         RequestId,
                         McastAddress,
                         &mcastAddressLength,
                         ServerAddress,
                         &serverAddressLength,
                         &leaseStartTime,
                         &leaseEndTime,
                         &newMcastAddress
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] MADCAP server %1!u!.%2!u!.%3!u!.%4!u! "
                    "was unable to provide a multicast address "
                    "in Scope ID %5!u!.%6!u!.%7!u!.%8!u! "
                    "for network %9!ws!, status %10!u!.\n",
                    NmpIpAddrPrintArgs(scopeCtxList[scopeCtx].ServerID.IpAddrV4),
                    NmpIpAddrPrintArgs(scopeCtxList[scopeCtx].ScopeID.IpAddrV4),
                    networkId, status
                    );
            } else {
                //
                // No need to try additional scopes.
                //
                break;
            }
        }
    }

    if (status == ERROR_SUCCESS) {

        //
        // Madcap config succeeded.
        //
        configType = NmMcastConfigMadcap;
        madcapTimeout = FALSE;

        //
        // Save lease renewal parameters.
        //
        requestId = *RequestId;
        serverAddress = *ServerAddress;

        //
        // Fill in the parameters data structure.
        //
        status = NmpMulticastCreateParameters(
                     0,      // disabled
                     *McastAddress,
                     NULL,   // key
                     0,      // key length
                     leaseStartTime,
                     leaseEndTime,
                     &requestId,
                     serverAddress,
                     configType,
                     Parameters
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create multicast parameters "
                "data structure for network %1!ws!, "
                "status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

error_exit:

    if (scopeCtxList != NULL) {
        MIDL_user_free(scopeCtxList);
        scopeCtxList = NULL;
    }

    if (madcapTimeout) {
        status = ERROR_TIMEOUT;
    }

    return(status);

} // NmpGetMulticastAddress


DWORD
NmpMulticastSetNullAddressParameters(
    IN  PNM_NETWORK                       Network,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Called after failure to process multicast parameters.
    Changes only address field in parameters to turn
    off multicast in clusnet.

--*/
{
    LPCWSTR          networkId = OmObjectId(Network);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Setting NULL multicast address (%1!ws!) "
        "for network %2!ws!.\n",
        NmpNullMulticastAddress, networkId
        );

    if (Parameters->Address != NULL) {
        MIDL_user_free(Parameters->Address);
    }

    Parameters->Address = NmpNullMulticastAddress;

    return(ERROR_SUCCESS);

} // NmpMulticastSetNullAddressParameters


DWORD
NmpMulticastSetNoAddressParameters(
    IN  PNM_NETWORK                       Network,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Called after failure to obtain a multicast address.
    Fills in parameters data structure to reflect
    failure and to establish retry.

--*/
{
    NmpMulticastSetNullAddressParameters(Network, Parameters);

    Parameters->ConfigType = NmMcastConfigAuto;
    NmpCalculateLeaseRenewTime(
        Network,
        Parameters->ConfigType,
        &Parameters->LeaseObtained,
        &Parameters->LeaseExpires
        );

    return(ERROR_SUCCESS);

} // NmpMulticastSetNoAddressParameters


DWORD
NmpRenewMulticastAddressLease(
    IN  PNM_NETWORK   Network
    )
/*++

Routine Description:

    Renew a multicast address lease, as determined by lease
    parameters stored in the cluster database.

Notes:

    Called with NM lock held and must return with NM lock held.

--*/
{
    DWORD                           status;
    LPCWSTR                         networkId = OmObjectId(Network);
    HDMKEY                          networkKey = NULL;
    HDMKEY                          netParamKey = NULL;
    BOOLEAN                         lockAcquired = TRUE;

    MCAST_CLIENT_UID                requestId = { NULL, 0 };
    LPWSTR                          serverAddress = NULL;
    DWORD                           serverAddressLength = 0;
    LPWSTR                          mcastAddress = NULL;
    DWORD                           mcastAddressLength = 0;
    LPWSTR                          oldMcastAddress = NULL;

    NM_NETWORK_MULTICAST_PARAMETERS parameters;
    time_t                          deferRetry = 0;
    BOOLEAN                         localInterface = FALSE;


    RtlZeroMemory(&parameters, sizeof(parameters));

    localInterface = (BOOLEAN)(Network->LocalInterface != NULL);

    if (localInterface) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Renewing multicast address lease for "
            "network %1!ws!.\n",
            networkId
            );
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Attempting to renew multicast address "
            "lease for network %1!ws! despite the lack of "
            "a local interface.\n",
            networkId
            );
    }

    //
    // Get the lease parameters from the network object.
    //
    status = NmpMulticastGetNetworkLeaseParameters(
                 Network,
                 &requestId,
                 &serverAddress,
                 &mcastAddress
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to find multicast lease "
            "parameters in network object %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
    }

    //
    // Release the NM lock.
    //
    NmpReleaseLock();
    lockAcquired = FALSE;

    //
    // Check if we found the parameters we need. If not,
    // try the cluster database.
    //
    if (status != ERROR_SUCCESS) {

        status = NmpMulticastGetDatabaseLeaseParameters(
                     Network,
                     &networkKey,
                     &netParamKey,
                     &requestId,
                     &serverAddress,
                     &mcastAddress
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to find multicast lease "
                "parameters for network %1!ws! in "
                "cluster database, status %2!u!.\n",
                networkId, status
                );
        }
    }

    //
    // Remember the old multicast address.
    //
    if (mcastAddress != NULL) {
        status = NmpStoreString(mcastAddress, &oldMcastAddress, NULL);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to copy current multicast "
                "address (%1!ws!) for network %2!ws! "
                "during lease renewal, status %3!u!.\n",
                mcastAddress, networkId, status
                );
            //
            // Not a fatal error. Only affects event-log
            // decision.
            //
            oldMcastAddress = NULL;
        }
    }

    //
    // Get an address either by renewing a current
    // lease or obtaining a new lease.
    //
    status = NmpGetMulticastAddress(
                 Network,
                 &mcastAddress,
                 &serverAddress,
                 &requestId,
                 &parameters
                 );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_TIMEOUT) {
            //
            // The MADCAP server, if it exists, is currently not
            // responding.
            //
            status = NmpMulticastNeedRetryRenew(
                         Network,
                         &deferRetry
                         );
            if (status != ERROR_SUCCESS || deferRetry == 0) {

                //
                // Choose an address, but only if there is a
                // local interface on this network. Otherwise,
                // we cannot assume that the MADCAP server is
                // unresponsive because we may have no way to
                // contact it.
                //
                if (!localInterface) {
                    status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Cannot choose a multicast address "
                        "for network %1!ws! because this node "
                        "has no local interface.\n",
                        networkId
                        );
                    goto error_exit;
                }

                status = NmpChooseMulticastAddress(
                             Network,
                             &parameters
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to choose a default multicast "
                        "address for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                    goto error_exit;
                } else {
                    NmpReportMulticastAddressChoice(
                        Network,
                        parameters.Address,
                        oldMcastAddress
                        );
                }
            } else {

                //
                // Set the renew timer once we reacquire the
                // network lock.
                //
            }
        }
    } else {
        NmpReportMulticastAddressLease(
            Network,
            &parameters,
            oldMcastAddress
            );
    }

    if (deferRetry == 0) {

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to obtain a multicast "
                "address for network %1!ws! during "
                "lease renewal, status %2!u!.\n",
                networkId, status
                );
            NmpReportMulticastAddressFailure(Network, status);
            NmpMulticastSetNoAddressParameters(Network, &parameters);
        }

        //
        // Create new multicast key.
        //
        status = NmpCreateRandomNumber(&(parameters.Key),
                                       MulticastKeyLen
                                       );
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create random number "
                "for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
        parameters.KeyLength = MulticastKeyLen;

        //
        // Disseminate the new multicast parameters.
        //
        status = NmpMulticastNotifyConfigChange(
                     Network,
                     networkKey,
                     &netParamKey,
                     &parameters,
                     NULL,
                     0
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to disseminate multicast "
                "configuration for network %1!ws! during "
                "lease renewal, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

error_exit:

    if (lockAcquired && (networkKey != NULL || netParamKey != NULL)) {
        NmpReleaseLock();
        lockAcquired = FALSE;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        RtlZeroMemory(&requestId, sizeof(requestId));
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (serverAddress != NULL) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    if (oldMcastAddress != NULL) {
        MIDL_user_free(oldMcastAddress);
        oldMcastAddress = NULL;
    }

    NmpMulticastFreeParameters(&parameters);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    if (deferRetry != 0) {

        //
        // Now that the lock is held, start the timer to
        // renew again.
        //
        NmpStartNetworkMulticastAddressRenewTimer(
            Network,
            NmpMadcapTimeToNmTime(deferRetry)
            );

        status = ERROR_SUCCESS;
    }

    return(status);

} // NmpRenewMulticastAddressLease


DWORD
NmpReleaseMulticastAddress(
    IN     PNM_NETWORK       Network
    )
/*++

Routine Description:

    Contacts MADCAP server to release a multicast address
    that was previously obtained in a lease.

    If multiple addresses need to be released, reschedules
    MADCAP worker thread.

Notes:

    Called and must return with NM lock held.

--*/
{
    DWORD                              status;
    LPCWSTR                            networkId = OmObjectId(Network);
    BOOLEAN                            lockAcquired = TRUE;
    PNM_NETWORK_MADCAP_ADDRESS_RELEASE releaseInfo = NULL;
    PLIST_ENTRY                        entry;

    UCHAR                     requestBuffer[NMP_MADCAP_REQUEST_BUFFER_SIZE];
    PMCAST_LEASE_REQUEST      request;

    //
    // Pop a lease data structure off the release list.
    //
    if (IsListEmpty(&(Network->McastAddressReleaseList))) {
        return(ERROR_SUCCESS);
    }

    entry = RemoveHeadList(&(Network->McastAddressReleaseList));
    releaseInfo = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK_MADCAP_ADDRESS_RELEASE,
                      Linkage
                      );

    //
    // Release the network lock.
    //
    NmpReleaseLock();
    lockAcquired = FALSE;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Releasing multicast address %1!ws! for "
        "network %2!ws!.\n",
        releaseInfo->McastAddress, networkId
        );

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Build the MADCAP request structure.
    //
    request = (PMCAST_LEASE_REQUEST) &requestBuffer[0];
    RtlZeroMemory(request, sizeof(requestBuffer));
    request->MinLeaseDuration = 0;       // currently ignored
    request->MinAddrCount = 1;           // currently ignored
    request->MaxLeaseStartTime = (LONG) time(NULL); // currently ignored
    request->AddrCount = 1;

    request->pAddrBuf = (PBYTE)request + NMP_MADCAP_REQUEST_ADDR_OFFSET;

    status = ClRtlTcpipStringToAddress(
                 releaseInfo->McastAddress,
                 ((PULONG) request->pAddrBuf)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert requested address %1!ws! "
            "into a TCP/IP address, status %2!u!.\n",
            releaseInfo->McastAddress, status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 releaseInfo->ServerAddress,
                 (PULONG) &(request->ServerAddress.IpAddrV4)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert server address %1!ws! "
            "into a TCP/IP address, status %2!u!.\n",
            releaseInfo->ServerAddress, status
            );
        goto error_exit;
    }

    //
    // Call MADCAP to release the address.
    //
    status = McastReleaseAddress(
                 AF_INET,
                 &releaseInfo->RequestId,
                 request
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to release multicast address %1!ws! "
            "through MADCAP server %2!ws!, status %3!u!.\n",
            releaseInfo->McastAddress,
            releaseInfo->ServerAddress,
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Successfully released multicast address "
        "%1!ws! for network %2!ws!.\n",
        releaseInfo->McastAddress, networkId
        );

error_exit:

    NmpFreeMulticastAddressRelease(releaseInfo);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    if (!IsListEmpty(&(Network->McastAddressReleaseList))) {
        NmpScheduleMulticastAddressRelease(Network);
    }

    return(status);

} // NmpReleaseMulticastAddress


DWORD
NmpProcessMulticastConfiguration(
    IN     PNM_NETWORK                      Network,
    IN     PNM_NETWORK_MULTICAST_PARAMETERS Parameters,
    OUT    PNM_NETWORK_MULTICAST_PARAMETERS UndoParameters
    )
/*++

Routine Description:

    Processes configuration changes and calls clusnet if
    appropriate.

    If multicast is disabled, the address and key
    may be NULL. In this case, choose defaults
    to send to clusnet, but do not commit the changes
    in the local network object.

Arguments:

    Network - network to process

    Parameters - parameters with which to configure Network.
                 If successful, Parameters data structure
                 is cleared.

    UndoParameters - If successful, former multicast
                 parameters of Network. Must be freed
                 by caller.

Notes:

    Called and returns with NM lock held.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    LPWSTR  networkId = (LPWSTR) OmObjectId(Network);
    BOOLEAN callClusnet = FALSE;
    LPWSTR  mcastAddress = NULL;
    DWORD   brand;
    PVOID   tdiMcastAddress = NULL;
    DWORD   tdiMcastAddressLength = 0;
    UUID    networkIdGuid;
    BOOLEAN mcastAddrChange = FALSE;
    BOOLEAN mcastKeyChange = FALSE;
    PVOID EncryptedMulticastKey = NULL;
    DWORD EncryptedMulticastKeyLength = 0;
    PVOID CurrentMulticastKey = NULL;
    DWORD CurrentMulticastKeyLength = 0;


#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Processing multicast configuration parameters "
        "for network %1!ws!.\n",
        networkId
        /* ,
        ((Parameters->Address != NULL) ? Parameters->Address : L"<NULL>") */
        );
#endif // CLUSTER_BETA

    //
    // Zero the undo parameters so that freeing them is not
    // destructive.
    //
    RtlZeroMemory(UndoParameters, sizeof(*UndoParameters));

    //
    // First determine if we need to reconfigure clusnet.
    //
    if (Parameters->Address != NULL) {
        if (Network->MulticastAddress == NULL ||
            wcscmp(Network->MulticastAddress, Parameters->Address) != 0) {

            // The multicast address in the config parameters is
            // different from the one in memory.
            mcastAddrChange = TRUE;
        }
        mcastAddress = Parameters->Address;
    } else {
        mcastAddress = NmpNullMulticastAddress;
    }

    if (Parameters->Key != NULL)
    {
        //
        // Unprotect the current key to see if it has changed.
        //
        if (Network->EncryptedMulticastKey != NULL)
        {
            status = NmpUnprotectData(
                         Network->EncryptedMulticastKey,
                         Network->EncryptedMulticastKeyLength,
                         &CurrentMulticastKey,
                         &CurrentMulticastKeyLength
                         );

            if (status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to decrypt multicast key  "
                    "for network %1!ws! while processing new "
                    "parameters, status %2!u!. "
                    "Assuming key has changed.\n",
                    networkId,
                    status
                    );
                // Non-fatal error. Assume the key has changed.
                // The check below will find CurrentMulticastKey
                // still NULL, and mcastKeyChange will be set true.
            }
        }

        if (CurrentMulticastKey == NULL ||
            (CurrentMulticastKeyLength != Parameters->KeyLength ||
             RtlCompareMemory(
                 CurrentMulticastKey,
                 Parameters->Key,
                 Parameters->KeyLength
                 ) != Parameters->KeyLength
             ))
        {
            //
            // The key in the config parameters is different
            // from the key in memory.
            //
            mcastKeyChange = TRUE;
        }
    }

    if (!Parameters->Disabled &&
        (!NmpIsNetworkMulticastEnabled(Network))) {

        // Multicast is now enabled. Call clusnet with the new address.
        callClusnet = TRUE;
    }

    if (Parameters->Disabled &&
        (NmpIsNetworkMulticastEnabled(Network))) {

        // Multicast is now disabled. Call clusnet with NULL address
        // regardless of which address was specified in the
        // parameters.
        mcastAddress = NmpNullMulticastAddress;
        callClusnet = TRUE;
    }

    if (!Parameters->Disabled &&
        (mcastAddrChange || mcastKeyChange )) {

        // The multicast address, and/or key changed and
        // multicast is enabled.
        callClusnet = TRUE;
    }

    if (callClusnet) {

        //
        // If this network does not have a local interface, do not
        // plumb the configuration into clusnet or commit changes.
        // However, the error status must be success so that we
        // don't fail a GUM update.
        //
        if (Network->LocalInterface == NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Not configuring cluster network driver with "
                "multicast parameters because network %1!ws! "
                "has no local interface.\n",
                networkId
                );
            status = ERROR_SUCCESS;
            callClusnet = FALSE;
        }
    }

    if (callClusnet) {

        //
        // If this network is not yet registered, do not plumb
        // the configuration into clusnet or commit changes.
        // However, the error status must be success so that we
        // don't fail a GUM update.
        //
        if (!NmpIsNetworkRegistered(Network)) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Not configuring cluster network driver with "
                "multicast parameters because network %1!ws! "
                "is not registered.\n",
                networkId
                );
            status = ERROR_SUCCESS;
            callClusnet = FALSE;
        }
    }

    //
    // Finalize the address and brand parameters for
    // clusnet. The new configuration will reflect the current
    // parameters block except for the address, which is stored
    // in temporary mcastAddress variable. mcastAddress points
    // either to the address in the parameters block or
    // the NULL multicast address if we are disabling.
    //
    if (callClusnet) {

        //
        // We cannot hand a NULL key to clusnet with a
        // valid address. It is okay to store the new address,
        // but make sure we do not try to send with no key
        // (allowing sending with no key could open a security
        // vulnerability).
        //
        if (mcastAddress != NmpNullMulticastAddress &&
            Parameters->Key == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Configuring valid multicast address "
                "with invalid key is not allowed. Zeroing "
                "multicast address for clusnet configuration "
                "of network %1!ws!.\n",
                networkId
                );
            mcastAddress = NmpNullMulticastAddress;
        }

        //
        // Build a TDI address from the address string.
        //
        status = ClRtlBuildTcpipTdiAddress(
                     mcastAddress,
                     Network->LocalInterface->ClusnetEndpoint,
                     &tdiMcastAddress,
                     &tdiMcastAddressLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to build TCP/IP TDI multicast address "
                "%1!ws! port %2!ws! for network %3!ws!, "
                "status %4!u!.\n",
                mcastAddress,
                Network->LocalInterface->ClusnetEndpoint,
                networkId, status
                );
            //
            // Non-fatal error. A node should not get banished
            // from the cluster for this. Skip the call to
            // clusnet.
            //
            callClusnet = FALSE;
            status = ERROR_SUCCESS;
        }

        //
        // Use the lower bytes of the network GUID for the
        // brand.
        //
        status = UuidFromString(networkId, &networkIdGuid);
        if (status == RPC_S_OK) {
            brand = *((PDWORD)&(networkIdGuid.Data4[4]));
        } else {
            brand = 0;
        }
    }

    //
    // Plumb the new configuration into clusnet.
    //
    if (callClusnet) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Configuring cluster network driver with "
            "multicast parameters for network %1!ws!.\n",
            networkId
            );

#ifdef MULTICAST_DEBUG
        NmpDbgPrintData(L"NmpProcessMulticastConfiguration(): before ClusnetConfigureMulticast()",
                     Parameters->Key,
                     Parameters->KeyLength
                     );
#endif


        status = ClusnetConfigureMulticast(
                     NmClusnetHandle,
                     Network->ShortId,
                     brand,
                     tdiMcastAddress,
                     tdiMcastAddressLength,
                     Parameters->Key,
                     Parameters->KeyLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to configure multicast parameters "
                "for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            if (!Parameters->Disabled) {
                Network->Flags |= NM_FLAG_NET_MULTICAST_ENABLED;
            } else {
                Network->Flags &= ~NM_FLAG_NET_MULTICAST_ENABLED;
            }
        }
    }

    //
    // Commit the changes to the network object.
    // The old state of the network object will be stored in
    // the undo parameters, in case we need to undo this change.
    // The new state of the network object will reflect the
    // paramters block, including the address (even if we
    // disabled).
    //
    UndoParameters->Address = Network->MulticastAddress;
    Network->MulticastAddress = Parameters->Address;

    UndoParameters->ConfigType = Network->ConfigType;
    Network->ConfigType = Parameters->ConfigType;

    UndoParameters->LeaseObtained = Network->MulticastLeaseObtained;
    Network->MulticastLeaseObtained = Parameters->LeaseObtained;
    UndoParameters->LeaseExpires = Network->MulticastLeaseExpires;
    Network->MulticastLeaseExpires = Parameters->LeaseExpires;

    UndoParameters->LeaseRequestId = Network->MulticastLeaseRequestId;
    Network->MulticastLeaseRequestId = Parameters->LeaseRequestId;

    UndoParameters->LeaseServer = Network->MulticastLeaseServer;
    Network->MulticastLeaseServer = Parameters->LeaseServer;

    if (Parameters->Key != NULL && Parameters->KeyLength != 0)
    {
        status = NmpProtectData(Parameters->Key,
                                Parameters->KeyLength,
                                &EncryptedMulticastKey,
                                &EncryptedMulticastKeyLength
                                );

        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to encrypt multicast key  "
                "for network %1!ws! while processing new "
                "parameters, status %2!u!.\n",
                networkId,
                status
                );
                // Non-fatal error. Next update we will assume
                // the key has changed. In the meantime, if
                // somebody asks us for the key, we will return
                // NULL.
        }
    }

    UndoParameters->Key = Network->EncryptedMulticastKey;
    Network->EncryptedMulticastKey = EncryptedMulticastKey;
    UndoParameters->KeyLength = Network->EncryptedMulticastKeyLength;
    Network->EncryptedMulticastKeyLength = EncryptedMulticastKeyLength;

    UndoParameters->MulticastKeyExpires = Network->MulticastKeyExpires;
    Network->MulticastKeyExpires = Parameters->MulticastKeyExpires;

    //
    // Zero the parameters structure so that the memory now
    // pointed to by the network object is not freed.
    //
    RtlZeroMemory(Parameters, sizeof(*Parameters));

error_exit:

    if (CurrentMulticastKey != NULL)
    {
        RtlSecureZeroMemory(CurrentMulticastKey, CurrentMulticastKeyLength);
        LocalFree(CurrentMulticastKey);
    }

    if (tdiMcastAddress != NULL) {
        LocalFree(tdiMcastAddress);
        tdiMcastAddress = NULL;
    }

    return(status);

} // NmpProcessMulticastConfiguration


VOID
NmpNetworkMadcapWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker routine for deferred operations on network objects.
    Invoked to process items placed in the cluster delayed work queue.

Arguments:

    WorkItem - A pointer to a work item structure that identifies the
               network for which to perform work.

    Status - Ignored.

    BytesTransferred - Ignored.

    IoContext - Ignored.

Return Value:

    None.

Notes:

    This routine is run in an asynchronous worker thread.
    The NmpActiveThreadCount was incremented when the thread was
    scheduled. The network object was also referenced.

--*/
{
    DWORD         status;
    PNM_NETWORK   network = (PNM_NETWORK) WorkItem->Context;
    LPCWSTR       networkId = OmObjectId(network);
    BOOLEAN       rescheduled = FALSE;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Worker thread processing MADCAP client requests "
        "for network %1!ws!.\n",
        networkId
        );

    if ((NmpState >= NmStateOnlinePending) && !NM_DELETE_PENDING(network)) {

        while (TRUE) {

            if (!(network->Flags & NM_NET_MADCAP_WORK_FLAGS)) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // Reconfigure multicast if needed.
            //
            if (network->Flags & NM_FLAG_NET_RECONFIGURE_MCAST) {
                network->Flags &= ~NM_FLAG_NET_RECONFIGURE_MCAST;

                status = NmpReconfigureMulticast(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to reconfigure multicast "
                        "for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                }
            }

            //
            // Renew an address lease if needed.
            //
            if (network->Flags & NM_FLAG_NET_RENEW_MCAST_ADDRESS) {
                network->Flags &= ~NM_FLAG_NET_RENEW_MCAST_ADDRESS;

                status = NmpRenewMulticastAddressLease(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to renew multicast address "
                        "lease for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                }
            }

            //
            // Release an address lease if needed.
            //
            if (network->Flags & NM_FLAG_NET_RELEASE_MCAST_ADDRESS) {
                network->Flags &= ~NM_FLAG_NET_RELEASE_MCAST_ADDRESS;

                status = NmpReleaseMulticastAddress(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to release multicast address "
                        "lease for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                }
            }


            //
            // Regenerate multicast key if needed.
            //
            if (network->Flags & NM_FLAG_NET_REGENERATE_MCAST_KEY) {
                network->Flags &= ~NM_FLAG_NET_REGENERATE_MCAST_KEY;

                status = NmpRegenerateMulticastKey(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to regenerate multicast key"
                        "for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                }
            }


            if (!(network->Flags & NM_NET_MADCAP_WORK_FLAGS)) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // More work to do. Resubmit the work item. We do this instead
            // of looping so we don't hog the worker thread. If
            // rescheduling fails, we will loop again in this thread.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] More MADCAP work to do for network %1!ws!. "
                "Rescheduling worker thread.\n",
                networkId
                );

            status = NmpScheduleNetworkMadcapWorker(network);

            if (status == ERROR_SUCCESS) {
                rescheduled = TRUE;
                break;
            }

        }

    } else {
        network->Flags &= ~NM_NET_MADCAP_WORK_FLAGS;
    }

    if (!rescheduled) {
        network->Flags &= ~NM_FLAG_NET_MADCAP_WORKER_RUNNING;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Worker thread finished processing MADCAP client "
        "requests for network %1!ws!.\n",
        networkId
        );

    NmpLockedLeaveApi();

    NmpReleaseLock();

    OmDereferenceObject(network);

    return;

} // NmpNetworkMadcapWorker

DWORD
NmpScheduleNetworkMadcapWorker(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedule a worker thread to execute madcap client
    requests for this network

Arguments:

    Network - Pointer to the network for which to schedule a worker thread.

Return Value:

    A Win32 status code.

Notes:

    Called with the NM global lock held.

--*/
{
    DWORD     status;
    LPCWSTR   networkId = OmObjectId(Network);


    ClRtlInitializeWorkItem(
        &(Network->MadcapWorkItem),
        NmpNetworkMadcapWorker,
        (PVOID) Network
        );

    status = ClRtlPostItemWorkQueue(
                 CsDelayedWorkQueue,
                 &(Network->MadcapWorkItem),
                 0,
                 0
                 );

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Scheduled worker thread to execute MADCAP "
            "client requests for network %1!ws!.\n",
            networkId
            );

        NmpActiveThreadCount++;
        Network->Flags |= NM_FLAG_NET_MADCAP_WORKER_RUNNING;
        OmReferenceObject(Network);
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to schedule worker thread to execute "
            "MADCAP client requests for network "
            "%1!ws!, status %2!u!\n",
            networkId,
            status
            );
    }

    return(status);

} // NmpScheduleNetworkMadcapWorker


VOID
NmpShareMulticastAddressLease(
    IN     PNM_NETWORK                        Network,
    IN     BOOLEAN                            Refresh
    )
/*++

Routine description:

    Called after a multicast configuration change,
    sets a timer to renew the multicast address lease
    for this network, if one exists.

    If this call is made from a refresh, it is not the
    result of a global update and it may be out of sync
    with other nodes. For instance, if this network
    was just enabled for cluster use, the NM leader node
    may be trying to obtain the multicast configuration
    at the same time this node is refreshing it.
    Consequently, delay a minimum amount of time before
    renewing a multicast address if this is a refresh.

Arguments:

    Network - multicast network

    Refresh - TRUE if this call is made during a refresh

Notes:

    Called and returns with NM lock held.

--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    DWORD                 disabled;
    BOOLEAN               delay = TRUE;

    time_t                leaseObtained;
    time_t                leaseExpires;
    DWORD                 leaseTimer = 0;
    NM_MCAST_LEASE_STATUS leaseStatus = NmMcastLeaseValid;

    if (NmpIsNetworkMulticastEnabled(Network)) {

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Sharing ownership of multicast lease "
            "for network %1!ws!.\n",
            networkId
            );
#endif // CLUSTER_BETA

        NmpCheckMulticastAddressLease(
            Network,
            &leaseStatus,
            &leaseObtained,
            &leaseExpires
            );

        if (leaseStatus != NmMcastLeaseValid) {

            if (Refresh) {
                leaseTimer = NMP_MCAST_REFRESH_RENEW_DELAY;
            } else {
                delay = FALSE;
            }

        } else {
            leaseTimer = NmpCalculateLeaseRenewTime(
                             Network,
                             Network->ConfigType,
                             &leaseObtained,
                             &leaseExpires
                             );
            if (Refresh && (leaseTimer < NMP_MCAST_REFRESH_RENEW_DELAY)) {
                leaseTimer = NMP_MCAST_REFRESH_RENEW_DELAY;
            }
        }
    } else {

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] No need to share multicast lease renewal "
            "responsibility for network %1!ws! because "
            "multicast has been disabled.\n",
            networkId
            );
#endif // CLUSTER_BETA

        //
        // Clear the timer, if it is set.
        //
        leaseTimer = 0;
    }

    if (delay) {
        NmpStartNetworkMulticastAddressRenewTimer(Network, leaseTimer);
    } else {
        NmpScheduleMulticastAddressRenewal(Network);
    }

    return;

} // NmpShareMulticastAddressLease


VOID
NmpShareMulticastKeyRegeneration(
    IN     PNM_NETWORK                        Network,
    IN     BOOLEAN                            Refresh
    )
/*++

Routine description:

    Called after a multicast configuration change,
    sets a timer to regenerate the multicast key
    for this network, if one exists.

    If this call is made from a refresh, it is not the
    result of a global update and it may be out of sync
    with other nodes. For instance, if this network
    was just enabled for cluster use, the NM leader node
    may be trying to obtain the multicast configuration
    at the same time this node is refreshing it.
    Consequently, delay a minimum amount of time before
    regenerating a new key if this is a refresh.

Arguments:

    Network - multicast network

    Refresh - TRUE if this call is made during a refresh

Notes:

    Called and returns with NM lock held.

--*/
{
    DWORD                 regenTimeout;
    DWORD                 baseTimeout, minTimeout;

    if (NmpIsNetworkMulticastEnabled(Network)) {

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Sharing ownership of multicast key "
            "regeneration for network %1!ws!.\n",
            networkId
            );
#endif // CLUSTER_BETA

        if (Network->EncryptedMulticastKey != NULL) {

            // Set the key regeneration timer according to the
            // parameters or the default.
            baseTimeout = (Network->MulticastKeyExpires != 0) ?
                          Network->MulticastKeyExpires :
                          NM_NET_MULTICAST_KEY_REGEN_TIMEOUT;
            minTimeout = (Refresh) ? NMP_MCAST_REFRESH_RENEW_DELAY : 1000;

            regenTimeout = NmpRandomizeTimeout(
                               Network,
                               baseTimeout,
                               NM_NET_MULTICAST_KEY_REGEN_TIMEOUT_WINDOW,
                               minTimeout,
                               MAXULONG,
                               TRUE
                               );
        } else {

            // Clear the key regeneration timer because there is
            // no key.
            regenTimeout = 0;
        }
    } else {

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] No need to share multicast key regeneration "
            "responsibility for network %1!ws! because "
            "multicast has been disabled.\n",
            networkId
            );
#endif // CLUSTER_BETA

        //
        // Clear the timer, if it is set.
        //
        regenTimeout = 0;
    }

    NmpStartNetworkMulticastKeyRegenerateTimer(Network, regenTimeout);

    return;

}


DWORD
NmpMulticastFormManualConfigParameters(
    IN  PNM_NETWORK                        Network,
    IN  HDMKEY                             NetworkKey,
    IN  HDMKEY                             NetworkParametersKey,
    IN  BOOLEAN                            DisableConfig,
    IN  DWORD                              Disabled,
    IN  BOOLEAN                            McastAddressConfig,
    IN  LPWSTR                             McastAddress,
    OUT BOOLEAN                          * NeedUpdate,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS   Parameters
    )
/*++

Routine Description:

    Using parameters provided and those already configured,
    form a parameters structure to reflect a manual
    configuration.

Arguments:

    Network - network being configured

    NetworkKey - network key in cluster database

    NetworkParametersKey - network parameters key in cluster database

    DisableConfig - whether the disabled value was set

    Disabled - if DisableConfig, the value that was set

    McastAddressConfig - whether the multicast address value was set

    McastAddress - if McastAddressConfig, the value that was set

    NeedUpdate - indicates whether an update is needed, i.e. whether
                 anything changed

    Parameters - parameter structure, allocated by caller, to fill in

--*/
{
    DWORD                              status;
    LPCWSTR                            networkId = OmObjectId(Network);
    HDMKEY                             networkKey = NULL;
    HDMKEY                             netParamKey = NULL;
    HDMKEY                             clusParamKey = NULL;
    BOOLEAN                            lockAcquired = FALSE;
    DWORD                              regDisabled;
    BOOLEAN                            disabledChange = FALSE;
    BOOLEAN                            mcastAddressDefault = FALSE;
    BOOLEAN                            mcastAddressChange = FALSE;
    BOOLEAN                            getAddress = FALSE;
    DWORD                              len;
    BOOLEAN                            localInterface = FALSE;

    LPWSTR                             mcastAddress = NULL;
    LPWSTR                             serverAddress = NULL;
    MCAST_CLIENT_UID                   requestId = {NULL, 0};

    PNM_NETWORK_MADCAP_ADDRESS_RELEASE release = NULL;

    //
    // Validate incoming parameters.
    //
    // Any nonzero disabled value is set to 1 for simplification.
    //
    if (DisableConfig) {
        if (Disabled != 0) {
            Disabled = 1;
        }
    }

    //
    // Non-valid and NULL multicast addresses signify
    // revert-to-default.
    //
    if (McastAddressConfig &&
        (McastAddress == NULL || !NmpMulticastValidateAddress(McastAddress))) {

        mcastAddressDefault = TRUE;
        McastAddress = NULL;
    }

    //
    // Base decisions on the current status of the network
    // object and cluster database. Before acquiring the NM lock,
    // determine whether we are currently disabled by querying the
    // cluster database.
    //
    status = NmpQueryMulticastDisabled(
                 Network,
                 &clusParamKey,
                 &networkKey,
                 &netParamKey,
                 &regDisabled
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine whether multicast "
            "is disabled for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;

    } else {
        //
        // Registry keys are no longer needed.
        //
        if (clusParamKey != NULL) {
            DmCloseKey(clusParamKey);
            clusParamKey = NULL;
        }

        if (netParamKey != NULL) {
            DmCloseKey(netParamKey);
            netParamKey = NULL;
        }

        if (networkKey != NULL) {
            DmCloseKey(networkKey);
            networkKey = NULL;
        }
    }

    NmpAcquireLock();
    lockAcquired = TRUE;

    //
    // See if anything changed.
    //
    if (DisableConfig) {
        if (Disabled != regDisabled) {
            disabledChange = TRUE;
        }
    }

    if (McastAddressConfig) {
        if (mcastAddressDefault) {
            mcastAddressChange = TRUE;
        } else {
            if (Network->MulticastAddress != NULL) {
                if (lstrcmpW(Network->MulticastAddress, McastAddress) != 0) {
                    mcastAddressChange = TRUE;
                }
            } else {
                mcastAddressChange = TRUE;
            }
        }
    }

    if (!disabledChange && !mcastAddressChange) {
        *NeedUpdate = FALSE;
        status = ERROR_SUCCESS;
#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Private property update to network %1!ws! "
            "contains no multicast changes.\n",
            networkId
            );
#endif // CLUSTER_BETA
        goto error_exit;
    }

    //
    // Initialize the parameters from the network object.
    //
    status = NmpMulticastCreateParameters(
                 regDisabled,
                 Network->MulticastAddress,
                 NULL,  // key
                 0,     // key length
                 Network->MulticastLeaseObtained,
                 Network->MulticastLeaseExpires,
                 &Network->MulticastLeaseRequestId,
                 Network->MulticastLeaseServer,
                 NmMcastConfigManual,
                 Parameters
                 );
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    localInterface = (BOOLEAN)(Network->LocalInterface != NULL);

    NmpReleaseLock();
    lockAcquired = FALSE;

    if (mcastAddressChange) {

        //
        // Figure out what address to use.
        //
        if (!mcastAddressDefault) {

            //
            // An address was dictated.
            //
            // If we currently have a leased address, release it.
            //
            if (NmpNeedRelease(
                    Parameters->Address,
                    Parameters->LeaseServer,
                    &(Parameters->LeaseRequestId),
                    Parameters->LeaseExpires
                    )) {

                status = NmpCreateMulticastAddressRelease(
                             Parameters->Address,
                             Parameters->LeaseServer,
                             &(Parameters->LeaseRequestId),
                             &release
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to create multicast address "
                        "release for address %1!ws! on network %2!ws! "
                        "during manual configuration, status %3!u!.\n",
                        ((Parameters->Address != NULL) ?
                         Parameters->Address : L"<NULL>"),
                        networkId, status
                        );
                    goto error_exit;
                }
            }

            //
            // Store the new address in the parameters data structure.
            //
            status = NmpStoreString(
                         McastAddress,
                         &Parameters->Address,
                         NULL
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            Parameters->ConfigType = NmMcastConfigManual;
            Parameters->LeaseObtained = 0;
            Parameters->LeaseExpires = 0;

            //
            // Clear out the lease server.
            //
            len = (Parameters->LeaseServer != NULL) ?
                NM_WCSLEN(Parameters->LeaseServer) : 0;
            status = NmpStoreString(
                         NmpNullMulticastAddress,
                         &Parameters->LeaseServer,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

        } else {

            //
            // Need to find an address elsewhere.
            //
            getAddress = TRUE;
        }
    }

    //
    // We also may need to renew the lease if we are moving from
    // disabled to enabled and an address was not specified, but
    // only if we don't already have a lease that doesn't expire.
    //
    if (disabledChange && !Disabled) {

        Parameters->Disabled = 0;

        if (!mcastAddressChange) {

            //
            // An address was not set. All we currently have is
            // what's in the network object (and copied to the
            // parameters block).
            //
            if (Parameters->Address != NULL &&
                NmpMulticastValidateAddress(Parameters->Address)) {

                //
                // We already have a valid multicast address, but
                // the lease may need to be renewed.
                //
                if (Parameters->LeaseExpires != 0) {
                    getAddress = TRUE;
                } else {
                    Parameters->ConfigType = NmMcastConfigManual;
                }

            } else {

                //
                // We have no valid multicast address. Get one.
                //
                getAddress = TRUE;
            }
        }
    }

    //
    // We don't bother renewing the lease if we are disabling.
    //
    if (Disabled) {
        getAddress = FALSE;
        Parameters->Disabled = Disabled;

        //
        // If we currently have a leased address that we haven't
        // already decided to release, release it.
        //
        if (release == NULL && NmpNeedRelease(
                                   Parameters->Address,
                                   Parameters->LeaseServer,
                                   &(Parameters->LeaseRequestId),
                                   Parameters->LeaseExpires
                                   )) {

            status = NmpCreateMulticastAddressRelease(
                         Parameters->Address,
                         Parameters->LeaseServer,
                         &(Parameters->LeaseRequestId),
                         &release
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to create multicast address "
                    "release for address %1!ws! on network %2!ws! "
                    "during manual configuration, status %3!u!.\n",
                    ((Parameters->Address != NULL) ?
                     Parameters->Address : L"<NULL>"),
                    networkId, status
                    );
                goto error_exit;
            }

            //
            // Since we are releasing the address, there is not
            // much point in saving it. If we re-enable multicast
            // in the future, we will request a fresh lease.
            //
            len = (Parameters->LeaseServer != NULL) ?
                NM_WCSLEN(Parameters->LeaseServer) : 0;
            status = NmpStoreString(
                         NmpNullMulticastAddress,
                         &Parameters->LeaseServer,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            len = (Parameters->Address != NULL) ?
                NM_WCSLEN(Parameters->Address) : 0;
            status = NmpStoreString(
                         NmpNullMulticastAddress,
                         &Parameters->Address,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            // requestId is initialized to be blank
            status = NmpStoreRequestId(
                         &requestId,
                         &Parameters->LeaseRequestId
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            //
            // Remember that this had been a MADCAP address.
            //
            Parameters->ConfigType = NmMcastConfigMadcap;

        } else if (!(mcastAddressChange && !mcastAddressDefault)) {

            //
            // If no address is being set, we may keep the former
            // address in the database even though it is not being
            // used. We also need to remember the way we got that
            // address in case it is ever used again. If we fail
            // to determine the previous configuration, we need
            // to set it to manual so that we don't lose a manual
            // configuration.
            //
            status = NmpQueryMulticastConfigType(
                         Network,
                         NetworkKey,
                         &NetworkParametersKey,
                         &Parameters->ConfigType
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to query multicast address "
                    "config type for network %1!ws! during "
                    "manual configuration, status %2!u!.\n",
                    networkId, status
                    );
                Parameters->ConfigType = NmMcastConfigManual;
            }
        }
    }

    //
    // Synchronously get a new address.
    //
    if (getAddress) {

        //
        // Create temporary strings for proposed address, lease
        // server, and request id.
        //
        status = NmpStoreString(Parameters->Address, &mcastAddress, NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        status = NmpStoreString(Parameters->LeaseServer, &serverAddress, NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        status = NmpStoreRequestId(&Parameters->LeaseRequestId, &requestId);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Get the address.
        //
        status = NmpGetMulticastAddress(
                     Network,
                     &mcastAddress,
                     &serverAddress,
                     &requestId,
                     Parameters
                     );
        if (status != ERROR_SUCCESS) {
            if (status == ERROR_TIMEOUT) {
                //
                // MADCAP server is not responding. Choose an
                // address, but only if there is a local
                // interface on this network. Otherwise, we
                // cannot assume that the MADCAP server is
                // unresponsive because we may have no way to
                // contact it.
                //
                if (!localInterface) {
                    status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Cannot choose a multicast address "
                        "for network %1!ws! because this node "
                        "has no local interface.\n",
                        networkId
                        );
                } else {

                    status = NmpChooseMulticastAddress(
                                 Network,
                                 Parameters
                                 );
                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NM] Failed to choose a default multicast "
                            "address for network %1!ws!, status %2!u!.\n",
                            networkId, status
                            );
                    } else {
                        NmpReportMulticastAddressChoice(
                            Network,
                            Parameters->Address,
                            NULL
                            );
                    }
                }
            }
        } else {
            NmpReportMulticastAddressLease(
                Network,
                Parameters,
                NULL
                );
        }

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to get multicast address for "
                "network %1!ws! during manual configuration, "
                "status %2!u!.\n",
                networkId, status
                );
            NmpReportMulticastAddressFailure(Network, status);
            NmpMulticastSetNoAddressParameters(Network, Parameters);
        }
    }


    if (((DisableConfig && !Disabled) ||
         (!DisableConfig && !regDisabled)) &&
        (status == ERROR_SUCCESS))
    {
        //
        // Create new multicast key.
        //
        status = NmpCreateRandomNumber(&(Parameters->Key),
                                       MulticastKeyLen
                                       );
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create random number "
                "for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
        Parameters->KeyLength = MulticastKeyLen;

    }


    *NeedUpdate = TRUE;

    //
    // Check if we have an address to release.
    //
    if (release != NULL) {
        NmpAcquireLock();
        NmpInitiateMulticastAddressRelease(Network, release);
        release = NULL;
        NmpReleaseLock();
    }

error_exit:

    if (lockAcquired) {
        NmpReleaseLock();
        lockAcquired = FALSE;
    }

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        RtlZeroMemory(&requestId, sizeof(requestId));
    }

    if (mcastAddress != NULL && !NMP_GLOBAL_STRING(mcastAddress)) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (serverAddress != NULL && !NMP_GLOBAL_STRING(serverAddress)) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    if (release != NULL) {
        NmpFreeMulticastAddressRelease(release);
    }

    if (clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    return(status);

} // NmpMulticastFormManualConfigParameters


DWORD
NmpReconfigureMulticast(
    IN PNM_NETWORK        Network
    )
/*++

Routine Description:

    Create the multicast configuration for this network
    for the cluster. This includes the following:

    - Check the address lease and renew if necessary.
    - Generate a new multicast key.

    The address lease is checked first. If the lease
    needs to be renewed, schedule a worker thread to
    do it asynchronously.

Notes:

    Called and returns with NM lock held.

--*/
{
    DWORD                           status;
    LPWSTR                          networkId = (LPWSTR) OmObjectId(Network);
    HDMKEY                          networkKey = NULL;
    HDMKEY                          netParamKey = NULL;
    HDMKEY                          clusParamKey = NULL;
    BOOLEAN                         lockAcquired = TRUE;

    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_MCAST_LEASE_STATUS           leaseStatus = NmMcastLeaseValid;
    DWORD                           mcastAddressLength = 0;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Reconfiguring multicast for network %1!ws!.\n",
        networkId
        );

    //
    // Clear reconfiguration timer and work flag.
    // This timer is set in NmpMulticastCheckReconfigure. It is not
    // necessary to call NmpReconfigureMulticast() twice.
    //
    Network->Flags &= ~NM_FLAG_NET_RECONFIGURE_MCAST;
    Network->McastAddressReconfigureRetryTimer = 0;

    NmpReleaseLock();
    lockAcquired = FALSE;

    //
    // Check if multicast is disabled. This has the side-effect,
    // on success, of opening at least the network key, and
    // possibly the network parameters key (if it exists) and
    // the cluster parameters key.
    //
    status = NmpQueryMulticastDisabled(
                 Network,
                 &clusParamKey,
                 &networkKey,
                 &netParamKey,
                 &params.Disabled
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine whether multicast "
            "is disabled for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Read the address from the database. It may have
    // been configured manually, and we do not want to
    // lose it.
    //
    status = NmpQueryMulticastAddress(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.Address,
                 &mcastAddressLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast address "
            "for network %1!ws! from cluster "
            "database, status %2!u!.\n",
            networkId, status
            );
    }

    //
    // Only proceed with lease renewal if multicast is
    // not disabled.
    //
    if (!params.Disabled) {

        //
        // Check the address lease.
        //
        status = NmpQueryMulticastAddressLease(
                     Network,
                     networkKey,
                     &netParamKey,
                     &leaseStatus,
                     &params.LeaseObtained,
                     &params.LeaseExpires
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to determine multicast address "
                "lease status for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            if (params.Address == NULL) {

                // We did not find an address. Assume we
                // should obtain an address automatically.
                params.LeaseObtained = time(NULL);
                params.LeaseExpires = time(NULL);
                leaseStatus = NmMcastLeaseExpired;
            } else {

                // We found an address but not any lease
                // parameters. Assume that the address
                // was manually configured.
                params.ConfigType = NmMcastConfigManual;
                params.LeaseObtained = 0;
                params.LeaseExpires = 0;
                leaseStatus = NmMcastLeaseValid;
            }
        }

        //
        // If we think we have a valid lease, check first
        // how we got it. If the address was selected
        // rather than obtained via MADCAP, go through
        // the MADCAP query process again.
        //
        if (leaseStatus == NmMcastLeaseValid) {
            status = NmpQueryMulticastConfigType(
                         Network,
                         networkKey,
                         &netParamKey,
                         &params.ConfigType
                         );
            if (status != ERROR_SUCCESS) {
                //
                // Since we already have an address, stick
                // with whatever information we deduced
                // from the lease expiration.
                //
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to determine the type of the "
                    "multicast address for network %1!ws!, "
                    "status %2!u!. Assuming manual configuration.\n",
                    networkId, status
                    );
            } else if (params.ConfigType == NmMcastConfigAuto) {
                leaseStatus = NmMcastLeaseNeedsRenewal;
            }
        }

        //
        // If we need to renew the lease, we may block
        // indefinitely due to the madcap API. Schedule
        // the renewal and defer configuration to when
        // it completes.
        //
        if (leaseStatus != NmMcastLeaseValid) {

            NmpAcquireLock();

            NmpScheduleMulticastAddressRenewal(Network);

            NmpReleaseLock();

            status = ERROR_IO_PENDING;

            goto error_exit;

        } else {

            //
            // Ensure that the lease expiration is set correctly
            // (a side effect of calculating the lease renew time).
            // We don't actually set the lease renew timer
            // here. Instead, we wait for the notification
            // that the new parameters have been disseminated
            // to all cluster nodes.
            //
            NmpCalculateLeaseRenewTime(
                Network,
                params.ConfigType,
                &params.LeaseObtained,
                &params.LeaseExpires
                );
        }

        //
        // Create new multicast key
        //

        status = NmpCreateRandomNumber(&(params.Key),
                                       MulticastKeyLen
                                       );
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create random number "
                "for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Successfully created multicast key "
            "for network %1!ws!.\n",
            networkId
            );

        params.KeyLength = MulticastKeyLen;


    }


    //
    // Registry keys are no longer needed.
    //
    if (clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    //
    // Disseminate the configuration.
    //
    status = NmpMulticastNotifyConfigChange(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params,
                 NULL,
                 0
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to disseminate multicast "
            "configuration for network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

error_exit:


    if (clusParamKey != NULL || netParamKey != NULL || networkKey != NULL) {
        if (lockAcquired) {
            NmpReleaseLock();
            lockAcquired = FALSE;
        }

        if (clusParamKey != NULL) {
            DmCloseKey(clusParamKey);
            clusParamKey = NULL;
        }

        if (netParamKey != NULL) {
            DmCloseKey(netParamKey);
            netParamKey = NULL;
        }

        if (networkKey != NULL) {
            DmCloseKey(networkKey);
            networkKey = NULL;
        }
    }

    NmpMulticastFreeParameters(&params);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    return(status);

} // NmpReconfigureMulticast




VOID
NmpScheduleMulticastReconfiguration(
    IN PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to reconfigure multicast
    for a network.

    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network to renew.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressReconfigureRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_RECONFIGURE_MCAST;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressReconfigureRetryTimer = 1;
    }

    return;

} // NmpScheduleMulticastReconfiguration


VOID
NmpMulticastCheckReconfigure(
    IN  PNM_NETWORK Network
    )
/*++

Routine Description:

    Checks whether the NM leader has a local interface on this
    network. If not, sets the reconfigure timer such that other
    nodes will have a chance to reconfigure multicast for this
    network, but if several minutes pass and it doesn't happen,
    this node can do it.

    This timer is cleared in NmpUpdateSetNetworkMulticastConfiguration
    and NmpReconfigureMulticast.

Arguments:

    Network - network to be reconfigured

Return value:

    None

Notes:

    Called and returns with NM lock held.

--*/
{
    DWORD timeout;

    if (Network->LocalInterface == NULL) {
        // This node has no local interface. It should
        // not bother trying to reconfigure multicast.
        return;
    }

    if (NmpLeaderNodeId != NmLocalNodeId &&
        (NmpGetInterfaceForNodeAndNetworkById(
             NmpLeaderNodeId,
             Network->ShortId
             ) != NULL)
        ) {
        // We are not the leader, and the leader node has an
        // interface on this network. It is responsibile for
        // reconfiguring multicast. If it fails, there must
        // be a good reason.
        //
        // If we are the leader, we should not be in this
        // routine at all, but we will retry the reconfigure
        // nonetheless.
        return;
    }

    // We will set a timer. Randomize the timeout.
    timeout = NmpRandomizeTimeout(
                  Network,
                  NM_NET_MULTICAST_RECONFIGURE_TIMEOUT,  // Base
                  NM_NET_MULTICAST_RECONFIGURE_TIMEOUT,  // Window
                  NM_NET_MULTICAST_RECONFIGURE_TIMEOUT,  // Minimum
                  MAXULONG,                              // Maximum
                  TRUE
                  );

    NmpStartNetworkMulticastAddressReconfigureTimer(
        Network,
        timeout
        );

    return;

} // NmpMulticastCheckReconfigure


DWORD
NmpStartMulticastInternal(
    IN PNM_NETWORK              Network,
    IN NM_START_MULTICAST_MODE  Mode
    )
/*++

Routine Description:

    Start multicast on the specified network after
    performing network-specific checks (currently
    only that the network is enabled for cluster use).

    Reconfigure multicast if the caller is forming the
    cluster or the NM leader.

    Refresh the multicast configuration from the cluster
    database otherwise.

Arguments:

    Network - network on which to start multicast.

    Mode - indicates caller mode

Notes:

    Must be called with NM lock held.

--*/
{
    //
    // Do not run multicast config on this network if it
    // is restricted from cluster use.
    //
    if (Network->Role != ClusterNetworkRoleNone) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Starting multicast for cluster network %1!ws!.\n",
            OmObjectId(Network)
            );

        if (Mode == NmStartMulticastForm || NmpLeaderNodeId == NmLocalNodeId) {

            NmpScheduleMulticastReconfiguration(Network);

        } else {
            if (Mode != NmStartMulticastDynamic) {
                NmpScheduleMulticastRefresh(Network);
            }
            else
            {
                //
                // Non NM leader node and Mode is NmStartMulticastDynamic:
                // Set timer to reconfigure multicast for the network,
                // in case NM leader goes down before issuing
                // GUM update NmpUpdateSetNetworkMulticastConfiguration.
                // This timer is cleared in
                // NmpUpdateSetNetworkMulticastConfiguration.
                //
                NmpMulticastCheckReconfigure(Network);
            }
        }
    }

    return(ERROR_SUCCESS);

} // NmpStartMulticastInternal


/////////////////////////////////////////////////////////////////////////////
//
// Routines exported within NM.
//
/////////////////////////////////////////////////////////////////////////////

VOID
NmpMulticastProcessClusterVersionChange(
    VOID
    )
/*++

Routine Description:

    Called when the cluster version changes. Updates
    global variables to track whether this is a mixed-mode
    cluster, and starts or stops multicast if necessary.

Notes:

    Called and returns with NM lock held.

--*/
{
    BOOLEAN startMcast = FALSE;
    BOOLEAN stop = FALSE;

    //
    // Figure out if there is a node in this cluster whose
    // version reveals that it doesn't speak multicast.
    //
    if (CLUSTER_GET_MAJOR_VERSION(CsClusterHighestVersion) < 4) {
        if (NmpIsNT5NodeInCluster == FALSE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Disabling multicast in mixed-mode cluster.\n"
                );
            NmpIsNT5NodeInCluster = TRUE;
            stop = TRUE;
        }
    }
    else {
        if (NmpIsNT5NodeInCluster == TRUE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Enabling multicast after upgrade from "
                "mixed-mode cluster.\n"
                );
            NmpIsNT5NodeInCluster = FALSE;
            startMcast = TRUE;
        }
    }

    if (NmpNodeCount < NMP_MCAST_MIN_CLUSTER_NODE_COUNT) {
        if (NmpMulticastIsNotEnoughNodes == FALSE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] There are no longer the minimum number of "
                "nodes configured in the cluster membership to "
                "justify multicast.\n"
                );
            NmpMulticastIsNotEnoughNodes = TRUE;
            stop = TRUE;
        }
    } else {
        if (NmpMulticastIsNotEnoughNodes == TRUE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] The cluster is configured with enough "
                "nodes to justify multicast.\n"
                );
            NmpMulticastIsNotEnoughNodes = FALSE;
            startMcast = TRUE;
        }
    }

    if (stop) {

        //
        // Stop multicast, since we are no longer
        // multicast-ready.
        //
        NmpStopMulticast(NULL);

        //
        // Don't bother checking whether we are now
        // multicast-ready.
        //
        startMcast = FALSE;
    }

    //
    // Start multicast if this is the NM leader node
    // and one of the multicast conditions changed.
    //
    if ((startMcast) &&
        (NmpLeaderNodeId == NmLocalNodeId) &&
        (!NmpMulticastIsNotEnoughNodes) &&
        (!NmpIsNT5NodeInCluster)) {

        NmpStartMulticast(NULL, NmStartMulticastDynamic);
    }

    return;

} // NmpMulticastProcessClusterVersionChange


VOID
NmpScheduleMulticastAddressRenewal(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to renew the multicast
    address lease for a network.

    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network to renew.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressRenewTimer = 0;
        Network->Flags |= NM_FLAG_NET_RENEW_MCAST_ADDRESS;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressRenewTimer = 1;
    }

    return;

} // NmpScheduleMulticastAddressRenewal


VOID
NmpScheduleMulticastKeyRegeneration(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to regenerate the multicast
    key for a network.

    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastKeyRegenerateTimer = 0;
        Network->Flags |= NM_FLAG_NET_REGENERATE_MCAST_KEY;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastKeyRegenerateTimer = 1;
    }

    return;

} // NmpScheduleMulticastKeyRegeneration

VOID
NmpScheduleMulticastAddressRelease(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to renew the multicast
    address lease for a network.

    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network to renew.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressReleaseRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_RELEASE_MCAST_ADDRESS;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressReleaseRetryTimer = 1;
    }

    return;

} // NmpScheduleMulticastAddressRelease


VOID
NmpScheduleMulticastRefresh(
    IN PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to refresh the multicast
    configuration for a network from the cluster database.

    The regular network worker thread (as opposed to the
    MADCAP worker thread) is used because refreshing does
    not call out of the cluster with the MADCAP API.

Arguments:

    A pointer to the network to refresh.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkWorkerRunning(Network)) {
        status = NmpScheduleNetworkWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressRefreshRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_REFRESH_MCAST;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressRefreshRetryTimer = 1;
    }

    return;

} // NmpScheduleMulticastRefresh


VOID
NmpFreeMulticastAddressReleaseList(
    IN     PNM_NETWORK       Network
    )
/*++

Routine Description:

    Free all release data structures on network list.

Notes:

    Assume that the Network object will not be accessed
    by any other threads during this call.

--*/
{
    PNM_NETWORK_MADCAP_ADDRESS_RELEASE releaseInfo = NULL;
    PLIST_ENTRY                        entry;

    while (!IsListEmpty(&(Network->McastAddressReleaseList))) {

        //
        // Simply free the memory -- don't try to release the
        // leases.
        //
        entry = RemoveHeadList(&(Network->McastAddressReleaseList));
        releaseInfo = CONTAINING_RECORD(
                          entry,
                          NM_NETWORK_MADCAP_ADDRESS_RELEASE,
                          Linkage
                          );
        NmpFreeMulticastAddressRelease(releaseInfo);
    }

    return;

} // NmpFreeMulticastAddressReleaseList


DWORD
NmpMulticastManualConfigChange(
    IN     PNM_NETWORK          Network,
    IN     HDMKEY               NetworkKey,
    IN     HDMKEY               NetworkParametersKey,
    IN     PVOID                InBuffer,
    IN     DWORD                InBufferSize,
       OUT BOOLEAN            * SetProperties
    )
/*++

Routine Description:

    Called by node that receives a clusapi request to set
    multicast parameters for a network.

    This routine is a no-op in mixed-mode clusters.

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD                            status;
    LPCWSTR                          networkId = OmObjectId(Network);
    BOOLEAN                          disableConfig = FALSE;
    BOOLEAN                          addrConfig = FALSE;
    DWORD                            disabled;
    NM_NETWORK_MULTICAST_PARAMETERS  params;
    LPWSTR                           mcastAddress = NULL;
    BOOLEAN                          needUpdate = FALSE;


    if (!NmpIsClusterMulticastReady(TRUE, TRUE)) {
        *SetProperties = TRUE;
        return(ERROR_SUCCESS);
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Examining update to private properties "
        "for network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    RtlZeroMemory(&params, sizeof(params));

    //
    // Cannot proceed if either registry key is NULL.
    //
    if (NetworkKey == NULL || NetworkParametersKey == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Ignoring possible multicast changes in "
            "private properties update to network %1!ws! "
            "because registry keys are missing.\n",
            networkId
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // If a writeable multicast parameter is among those properties
    // being set, we may need to take action before the update is
    // disseminated.
    //
    // Check whether multicast is being disabled for this network.
    //
    status = ClRtlFindDwordProperty(
                 InBuffer,
                 InBufferSize,
                 CLUSREG_NAME_NET_DISABLE_MULTICAST,
                 &disabled
                 );
    if (status == ERROR_SUCCESS) {
        disableConfig = TRUE;
    } else {
        disabled = NMP_MCAST_DISABLED_DEFAULT;
    }

    //
    // Check whether a multicast address is being set for this
    // network.
    //
    status = ClRtlFindSzProperty(
                 InBuffer,
                 InBufferSize,
                 CLUSREG_NAME_NET_MULTICAST_ADDRESS,
                 &mcastAddress
                 );
    if (status == ERROR_SUCCESS) {
        addrConfig = TRUE;
    }

    if (disableConfig || addrConfig) {

        //
        // Multicast parameters are being written.
        //

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Processing manual update to multicast "
            "configuration for network %1!ws!.\n",
            networkId
            );

        status = NmpMulticastFormManualConfigParameters(
                     Network,
                     NetworkKey,
                     NetworkParametersKey,
                     disableConfig,
                     disabled,
                     addrConfig,
                     mcastAddress,
                     &needUpdate,
                     &params
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to determine multicast "
                "configuration parameters for network "
                "%1!ws! during manual configuration, "
                "status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }


        //
        // Notify other nodes of the config change.
        //
        if (needUpdate) {
            status = NmpMulticastNotifyConfigChange(
                         Network,
                         NetworkKey,
                         &NetworkParametersKey,
                         &params,
                         InBuffer,
                         InBufferSize
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to disseminate multicast "
                    "configuration for network %1!ws! during "
                    "manual configuration, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }

            //
            // The properties have been disseminated. There is
            // no need to set them again (in fact, if we changed
            // one of the multicast properties, it could be
            // overwritten).
            //
            *SetProperties = FALSE;
        }
    }

    if (!needUpdate) {

        //
        // No multicast properties are affected. Set them
        // in the cluster database normally.
        //
        *SetProperties = TRUE;
        status = ERROR_SUCCESS;
    }

error_exit:

    if (mcastAddress != NULL) {
        LocalFree(mcastAddress);
        mcastAddress = NULL;
    }

    NmpMulticastFreeParameters(&params);

    //
    // If multicast config failed, default to setting properties.
    //
    if (status != ERROR_SUCCESS) {
        *SetProperties = TRUE;
    }

    return(status);

} // NmpMulticastManualConfigChange


DWORD
NmpUpdateSetNetworkMulticastConfiguration(
    IN    BOOL                          SourceNode,
    IN    LPWSTR                        NetworkId,
    IN    PVOID                         UpdateBuffer,
    IN    PVOID                         PropBuffer,
    IN    LPDWORD                       PropBufferSize
    )
/*++

Routine Description:

    Global update routine for multicast configuration.

    Starts a local transaction.
    Commits property buffer to local database.
    Commits multicast configuration to local database,
        possibly overwriting properties from buffer.
    Configures multicast parameters.
    Commits transaction.
    Backs out multicast configuration changes if needed.
    Starts lease renew timer if needed.

Arguments:

    SourceNode - whether this node is source of update.

    NetworkId - affected network

    Update - new multicast configuration

    PropBuffer - other properties to set in local
                 transaction. may be absent.

    PropBufferSize - size of property buffer.

Return value:

    SUCCESS if properties or configuration could not be
    committed. Error not necessarily returned if
    multicast config failed.

--*/
{
    DWORD                            status;
    PNM_NETWORK                      network = NULL;
    PNM_NETWORK_MULTICAST_UPDATE     update = UpdateBuffer;
    NM_NETWORK_MULTICAST_PARAMETERS  params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS  undoParams = { 0 };
    HLOCALXSACTION                   xaction = NULL;
    HDMKEY                           networkKey = NULL;
    HDMKEY                           netParamKey = NULL;
    DWORD                            createDisposition;
    BOOLEAN                          lockAcquired = FALSE;
    DWORD                            leaseRenewTime;

    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetNetworkCommonProperties "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to multicast configuration "
        "for network %1!ws!.\n",
        NetworkId
        );

    //
    // Find the network's object
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

    if (network == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to find network %1!ws!.\n",
            NetworkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;
    }

    //
    // Convert the update into a parameters data structure.
    //
    status = NmpMulticastCreateParametersFromUpdate(
                 network,
                 update,
                 (BOOLEAN)(update->Disabled == 0),
                 &params
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to convert update parameters to "
            "multicast parameters for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId, status
            );
        goto error_exit;
    }

    //
    // Open the network's database key
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open database key for network %1!ws!, "
            "status %2!u!\n",
            NetworkId, status
            );
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Open or create the network's parameters key.
    //
    netParamKey = DmLocalCreateKey(
                      xaction,
                      networkKey,
                      CLUSREG_KEYNAME_PARAMETERS,
                      0,   // registry options
                      MAXIMUM_ALLOWED,
                      NULL,
                      &createDisposition
                      );
    if (netParamKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open/create Parameters database "
            "key for network %1!ws!, status %2!u!.\n",
            NetworkId, status
            );
        goto error_exit;
    }

    NmpAcquireLock();
    lockAcquired = TRUE;

    //
    // If the multicast configuration for this network is
    // currently being refreshed (occurs outside of a GUM
    // update), then the properties we are about to write
    // to the database might make that refresh obsolete or
    // even inconsistent. Abort it now.
    //
    if (network->Flags & NM_FLAG_NET_REFRESH_MCAST_RUNNING) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Aborting multicast configuration refresh "
            "in progress on network %1!ws! with GUM update.\n",
            NetworkId
            );
        network->Flags |= NM_FLAG_NET_REFRESH_MCAST_ABORTING;
    }

    //
    // Cancel any pending multicast configuration refreshes.
    // They would be redundant after this GUM update.
    //
    network->Flags &= ~NM_FLAG_NET_REFRESH_MCAST;
    network->McastAddressRefreshRetryTimer = 0;


    //
    // Clear reconfiguration timer and work flag.
    // This timer is set in NmpMulticastCheckReconfigure.
    // It is not necessary to call NmpReconfigureMulticast() once
    // this GUM update is executed.
    //
    network->Flags &= ~NM_FLAG_NET_RECONFIGURE_MCAST;
    network->McastAddressReconfigureRetryTimer = 0;

    //
    // Cancel pending multicast key regeneration, if scheduled.
    // It would be redundant after this update.
    //
    network->Flags &= ~NM_FLAG_NET_REGENERATE_MCAST_KEY;

    //
    // If we were given a property buffer, then this update was
    // caused by a manual configuration (setting of private
    // properties). Write those properties first, knowing that
    // they may get overwritten later when we write multicast
    // parameters.
    //
    if (*PropBufferSize > sizeof(DWORD)) {
        status = ClRtlSetPrivatePropertyList(
                     xaction,
                     netParamKey,
                     &NmpMcastClusterRegApis,
                     PropBuffer,
                     *PropBufferSize
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to set private properties for "
                "network %1!ws! during a multicast configuration "
                "update, status %2!u!.\n",
                NetworkId, status
                );
            goto error_exit;
        }
    }

    //
    // Write the multicast configuration.
    //
    status = NmpWriteMulticastParameters(
                 network,
                 networkKey,
                 netParamKey,
                 xaction,
                 &params
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to write multicast configuration for "
            "network %1!ws!, status %2!u!.\n",
            NetworkId, status
            );
        goto error_exit;
    }

    //
    // Process the multicast configuration, including storing new
    // parameters in the network object and plumbing them into
    // clusnet.
    //
    status = NmpProcessMulticastConfiguration(network, &params, &undoParams);
    if (status == ERROR_SUCCESS) {

        //
        // Share responsibility for lease renewal and key
        // regeneration.
        //
        NmpShareMulticastAddressLease(network, FALSE);

        NmpShareMulticastKeyRegeneration(network, FALSE);

    } else {

        //
        // We should not be sharing the responsibility for renewing
        // this lease or regenerating the key, especially since the
        // data in the network object may no longer be accurate.
        // Clear the timers, if they are set, as well as any work flags.
        //
        NmpStartNetworkMulticastAddressRenewTimer(network, 0);
        network->Flags &= ~NM_FLAG_NET_RENEW_MCAST_ADDRESS;

        NmpStartNetworkMulticastKeyRegenerateTimer(network, 0);
        network->Flags &= ~NM_FLAG_NET_REGENERATE_MCAST_KEY;

        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to process multicast configuration for "
            "network %1!ws!, status %2!u!. Attempting null "
            "multicast configuration.\n",
            NetworkId, status
            );

        NmpMulticastSetNullAddressParameters(network, &params);

        status = NmpProcessMulticastConfiguration(
                     network,
                     &params,
                     &undoParams
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to process multicast configuration for "
                "network %1!ws!, status %2!u!.\n",
                NetworkId, status
                );
            goto error_exit;
        }
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    //
    // Close the network parameters key, which was obtained with
    // DmLocalCreateKey, before committing/aborting the transaction.
    //
    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (xaction != NULL) {

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    NmpMulticastFreeParameters(&params);
    if (undoParams.Key != NULL)
    {
        //
        // undoParams.Key is set to Network->EncryptedMulticastKey in
        // NmpProcessMulticastConfiguration, which should be freed by
        // LocalFree(), as it was allocated by NmpProtectData().
        // While NmpMulticastFreeParameters() frees undoParams.Key by
        // MIDL_user_free().
        //
        LocalFree(undoParams.Key);
        undoParams.Key = NULL;
    }
    NmpMulticastFreeParameters(&undoParams);

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (network != NULL) {
        OmDereferenceObject(network);
    }

    return(status);

} // NmpUpdateSetNetworkMulticastConfiguration


DWORD
NmpRegenerateMulticastKey(
    IN OUT PNM_NETWORK        Network
    )
/*++

Routine Description:

    Regenerate multicast key for Network, and issue GUM update
    to propagate this new multicast key to all cluster nodes.

Parameters:

    Network - [OUT] A pointer to network object.
                    New multicast key and key length are stored in
                    Network->EncryptedMulticastKey and
                    Network->EncryptedMulticastKeyLength.

Notes:

    Called and returned with NM lock held.
    Lock is released during execution.

--*/
{
    DWORD                             status = ERROR_SUCCESS;
    LPWSTR                            networkId = (LPWSTR) OmObjectId(Network);
    HDMKEY                            networkKey = NULL;
    HDMKEY                            netParamKey = NULL;
    BOOL                              LockAcquired = TRUE;
    PNM_NETWORK_MULTICAST_PARAMETERS  params = NULL;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Regenerating multicast key for network %1!ws!.\n",
        networkId
        );

    params = MIDL_user_allocate(sizeof(NM_NETWORK_MULTICAST_PARAMETERS));
    if (params == NULL)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate %1!u! bytes.\n",
            sizeof(NM_NETWORK_MULTICAST_PARAMETERS)
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    ZeroMemory(params, sizeof(NM_NETWORK_MULTICAST_PARAMETERS));


    params->Disabled = (NmpIsNetworkMulticastEnabled(Network) ? 0 : 1);
    if (!(params->Disabled))
    {


        status = NmpMulticastCreateParameters(
                     params->Disabled,
                     Network->MulticastAddress,
                     NULL,   // key
                     0,      // keylength
                     Network->MulticastLeaseObtained,
                     Network->MulticastLeaseExpires,
                     &Network->MulticastLeaseRequestId,
                     Network->MulticastLeaseServer,
                     Network->ConfigType,
                     params
                     );

        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create multicast parameters "
                "data structure for network %1!ws!, "
                "status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }


        //
        // Create new multicast key
        //
        status = NmpCreateRandomNumber(&(params->Key),
                                       MulticastKeyLen
                                       );
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create random number "
                "for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
        params->KeyLength = MulticastKeyLen;


        NmpReleaseLock();
        LockAcquired = FALSE;


        //
        // Disseminate the configuration.
        //
        status = NmpMulticastNotifyConfigChange(
                     Network,
                     networkKey,
                     &netParamKey,
                     params,
                     NULL,
                     0
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to disseminate multicast "
                "configuration for network %1!ws!, "
                "status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }


    } // if (!params.Disabled)

    status = ERROR_SUCCESS;


error_exit:

    if (netParamKey != NULL || networkKey != NULL)
    {

        if (netParamKey != NULL) {
            DmCloseKey(netParamKey);
            netParamKey = NULL;
        }

        if (networkKey != NULL) {
            DmCloseKey(networkKey);
            networkKey = NULL;
        }
    }

    if (LockAcquired == FALSE)
    {
        NmpAcquireLock();
        LockAcquired = TRUE;
    }

    NmpMulticastFreeParameters(params);

    if (params != NULL) {
        MIDL_user_free(params);
    }


    return(status);

} // NmpRegenerateMulticastKey


DWORD
NmpGetMulticastKey(
    IN OUT PNM_NETWORK_MULTICAST_PARAMETERS Params,
    IN PNM_NETWORK                          Network
    )
/*++

Routine Description:

   Get multicast key for Network from NM leader.

Parameters:

   Params - [IN OUT] If this node successfully gets multicast key from
                     NM leader, it stores multicast key and key length in
                     Params->Key and Params->KeyLength. It does not store
                     multicast key in Network->EncryptedMulticastKey.

  Network - [IN] A pointer to the network object.


Return value:

   ERROR_SUCCESS: Successfully gets encrypted multicast key from NM leader,
                  verifies MAC, and decrypts multicast key.

                  Or NM_FLAG_NET_REFRESH_MCAST_ABORTING is set.

   ERROR_CLUSTER_INVALID_NODE: This node becomes NM leader.

   Win32 error code: otherwise.

Notes:

   Called and returned with the NM lock held. Lock
   released and reacquired during execution.

--*/
{
    LPWSTR                          NetworkId = (LPWSTR) OmObjectId(Network);
    DWORD                           status = ERROR_SUCCESS;
    PNM_NETWORK_MULTICASTKEY        networkMulticastKey = NULL;
    PVOID                           EncryptionKey = NULL;
    DWORD                           EncryptionKeyLength;
    PVOID                           MulticastKey = NULL;
    DWORD                           MulticastKeyLength;
    CL_NODE_ID                      NmpLeaderNodeIdSaved;
    BOOL                            Continue = TRUE;


    while (Continue)
    {

        Continue = FALSE;

        if (NmpLeaderNodeId == NmLocalNodeId)
        {
            //
            // This node becomes NM leader.
            //
            status = ERROR_CLUSTER_INVALID_NODE;
            goto error_exit;
        }
        NmpLeaderNodeIdSaved = NmpLeaderNodeId;

        if (Network->Flags & NM_FLAG_NET_REFRESH_MCAST_ABORTING)
        {
            status = ERROR_SUCCESS;
            goto error_exit;
        }

        //
        // Get multicast key from NM leader
        //
         NmpReleaseLock();

         ClRtlLogPrint(LOG_NOISE,
             "[NM] Getting multicast key for "
             "network %1!ws! from NM leader (node %2!u!).\n",
             NetworkId, NmpLeaderNodeId
             );

         status = NmpGetMulticastKeyFromNMLeader(NmpLeaderNodeId,
                                                 NmLocalNodeIdString,
                                                 NetworkId,
                                                 &networkMulticastKey
                                                 );
         NmpAcquireLock();

         if (Network->Flags & NM_FLAG_NET_REFRESH_MCAST_ABORTING)
         {
             status = ERROR_SUCCESS;
             goto error_exit;
         }

         if (status == ERROR_SUCCESS)
         {
             if (networkMulticastKey->EncryptedMulticastKey != NULL)
             {

                 //
                 // set Params->Key, Params->KeyLength, and
                 //     Params->MulticastKeyExpires.
                 //
                 status = NmpDeriveClusterKey(NetworkId,
                                              NM_WCSLEN(NetworkId),
                                              &EncryptionKey,
                                              &EncryptionKeyLength
                                              );

                 if (status != ERROR_SUCCESS)
                 {
                     ClRtlLogPrint(LOG_UNUSUAL,
                         "[NM] Failed to derive cluster key for "
                         "network %1!ws!, status %2!u!.\n",
                         NetworkId, status
                         );
                     goto error_exit;
                 }

                 status = NmpVerifyMACAndDecryptData(
                                 NmCryptServiceProvider,
                                 NMP_ENCRYPT_ALGORITHM,
                                 NMP_KEY_LENGTH,
                                 networkMulticastKey->MAC,
                                 networkMulticastKey->MACLength,
                                 NMP_MAC_DATA_LENGTH_EXPECTED,
                                 networkMulticastKey->EncryptedMulticastKey,
                                 networkMulticastKey->EncryptedMulticastKeyLength,
                                 EncryptionKey,
                                 EncryptionKeyLength,
                                 networkMulticastKey->Salt,
                                 networkMulticastKey->SaltLength,
                                 (PBYTE *) &MulticastKey,
                                 &MulticastKeyLength
                                 );

                 if (status != ERROR_SUCCESS)
                 {
                     ClRtlLogPrint(LOG_UNUSUAL,
                         "[NM] Failed to verify MAC or decrypt multicast key for "
                         "network %1!ws!, status %2!u!.\n",
                         NetworkId, status
                         );
                     goto error_exit;
                 }

                 if (EncryptionKey != NULL)
                 {
                     RtlSecureZeroMemory(EncryptionKey, EncryptionKeyLength);
                     LocalFree(EncryptionKey);
                     EncryptionKey = NULL;
                 }

                 if (Params->Key != NULL)
                 {
                     RtlSecureZeroMemory(Params->Key, Params->KeyLength);
                     LocalFree(Params->Key);
                 }

                 Params->Key = LocalAlloc(0, MulticastKeyLength);
                 if (Params->Key == NULL)
                 {
                     status = ERROR_NOT_ENOUGH_MEMORY;
                     ClRtlLogPrint(LOG_UNUSUAL,
                         "[NM] Failed to allocate %1!u! bytes.\n",
                         MulticastKeyLength
                         );
                     goto error_exit;
                 }

                 CopyMemory(Params->Key, MulticastKey, MulticastKeyLength);

                 Params->KeyLength = MulticastKeyLength;

                 Params->MulticastKeyExpires = networkMulticastKey->MulticastKeyExpires;

             } // if (networkMulticastKey->EncryptedMulticastKey != NULL)
             else
             {
                 ClRtlLogPrint(LOG_UNUSUAL,
                                 "[NM] NM leader (node %1!u!) returned a NULL multicast key "
                                 "for network %2!ws!.\n",
                                 NmpLeaderNodeId, NetworkId
                                 );
             }
         } // if (status == ERROR_SUCCESS)
         else
         {
             //
             // Failed to get multicast key from NM leader.
             //
             ClRtlLogPrint(LOG_UNUSUAL,
                             "[NM] Failed to get multicast key for "
                             "network %1!ws! from "
                             "NM leader (node %2!u!), status %3!u!.\n",
                             NetworkId,
                             NmpLeaderNodeId,
                             status
                             );

             if (NmpLeaderNodeIdSaved != NmpLeaderNodeId)
             {
                 //
                 // Leader node changed.
                 //

                 ClRtlLogPrint(LOG_NOISE,
                     "[NM] NM leader node has changed. "
                     "Getting multicast key for "
                     " network %1!ws! from new NM leader (node %2!u!).\n",
                     NetworkId, NmpLeaderNodeId
                     );

                 Continue = TRUE;
             }
         }
    }  // while

error_exit:

    if (EncryptionKey != NULL)
    {
        RtlSecureZeroMemory(EncryptionKey, EncryptionKeyLength);
        LocalFree(EncryptionKey);
    }

    if (MulticastKey != NULL)
    {
        //
        // MulticastKey is allocated using HeapAlloc() in NmpVerifyMACAndDecryptData().
        //
        RtlSecureZeroMemory(MulticastKey, MulticastKeyLength);
        HeapFree(GetProcessHeap(), 0, MulticastKey);
    }

    NmpFreeNetworkMulticastKey(networkMulticastKey);


    return (status);
} // NmpGetMulticastKey()

DWORD
NmpRefreshMulticastConfiguration(
    IN PNM_NETWORK  Network
    )
/*++

Routine Description:

    NmpRefreshMulticastConfiguration enables multicast on
    the specified Network according to parameters in the
    cluster database.

    This routine processes the multicast configuration from
    the database, but it does not run in a GUM update.
    If a GUM update occurs during this routine, a flag is
    set indicating that the routine should be aborted.

    If this routine fails in a way that indicates that the
    network multicast needs to be reconfigured, then a timer
    is set (to allow the leader to reconfigure first).

Notes:

    Called and returns with the NM lock held, but releases
    during execution.

--*/
{
    LPWSTR                          networkId = (LPWSTR) OmObjectId(Network);
    DWORD                           status;
    BOOLEAN                         lockAcquired = TRUE;
    BOOLEAN                         clearRunningFlag = FALSE;

    HDMKEY                          networkKey = NULL;
    HDMKEY                          netParamKey = NULL;
    HDMKEY                          clusParamKey = NULL;

    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS undoParams = { 0 };
    DWORD                           mcastAddrLength = 0;
    NM_MCAST_LEASE_STATUS           leaseStatus;
    NM_MCAST_CONFIG                 configType;
    DWORD                           disabled;
    BOOLEAN                         tryReconfigure = FALSE;


    if (Network->Flags &
        (NM_FLAG_NET_REFRESH_MCAST_RUNNING |
         NM_FLAG_NET_REFRESH_MCAST_ABORTING)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast configuration refresh for "
            "network %1!ws! already in progress.\n",
            networkId
            );
        status = ERROR_SUCCESS;
        goto error_exit;
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Refreshing multicast configuration for network %1!ws!.\n",
            networkId
            );
        Network->Flags |= NM_FLAG_NET_REFRESH_MCAST_RUNNING;
        clearRunningFlag = TRUE;
    }

    NmpReleaseLock();
    lockAcquired = FALSE;

    //
    // Check if multicast is disabled. This has the side-effect,
    // on success, of opening at least the network key, and
    // possibly the network parameters key (if it exists) and
    // the cluster parameters key.
    //
    status = NmpQueryMulticastDisabled(
                 Network,
                 &clusParamKey,
                 &networkKey,
                 &netParamKey,
                 &params.Disabled
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine whether multicast "
            "is disabled for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    if (params.Disabled > 0) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast is disabled for network %1!ws!.\n",
            networkId
            );
    }

    //
    // Determine what type of configuration this is.
    //
    status = NmpQueryMulticastConfigType(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.ConfigType
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine configuration type "
            "for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        tryReconfigure = TRUE;
        goto error_exit;
    }

    //
    // Read the multicast address.
    //
    status = NmpQueryMulticastAddress(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.Address,
                 &mcastAddrLength
                 );
    if ( (status == ERROR_SUCCESS &&
          !NmpMulticastValidateAddress(params.Address)) ||
         (status != ERROR_SUCCESS)
       ) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get valid multicast address "
            "for network %1!ws! from cluster database, "
            "status %2!u!, address %3!ws!.\n",
            networkId, status,
            ((params.Address != NULL) ? params.Address : L"<NULL>")
            );
        tryReconfigure = TRUE;
        goto error_exit;
    }

    //
    // Get the lease parameters.
    //
    status = NmpQueryMulticastAddressLease(
                 Network,
                 networkKey,
                 &netParamKey,
                 &leaseStatus,
                 &params.LeaseObtained,
                 &params.LeaseExpires
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get multicast address lease "
            "expiration for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        //
        // Not fatal.
        //
        params.LeaseObtained = 0;
        params.LeaseExpires = 0;
        status = ERROR_SUCCESS;
    }

    //
    // Remember parameters we will need later.
    //
    disabled = params.Disabled;
    configType = params.ConfigType;

    //
    // No longer need registry key handles.
    //
    if (clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    //
    // Process the configuration changes, but only if
    // there hasn't been a multicast configuration GUM
    // update since we read from the database. The GUM
    // update will set the aborting flag.
    //
    NmpAcquireLock();
    lockAcquired = TRUE;

    if (Network->Flags & NM_FLAG_NET_REFRESH_MCAST_ABORTING) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast configuration refresh for "
            "network %1!ws! trumped by global update.\n",
            networkId
            );
        //
        // Clear the aborting flag. We clear the running
        // flag as we exit.
        //
        Network->Flags &= ~NM_FLAG_NET_REFRESH_MCAST_ABORTING;
        status = ERROR_SUCCESS;
        goto error_exit;
    }


    if (!params.Disabled)
    {

        status = NmpGetMulticastKey(&params, Network);

        if (status== ERROR_SUCCESS)
        {
            if (Network->Flags & NM_FLAG_NET_REFRESH_MCAST_ABORTING)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Multicast configuration refresh for "
                    "network %1!ws! trumped by global update.\n",
                    networkId
                    );
                //
                // Clear the aborting flag. We clear the running
                // flag as we exit.
                //
                Network->Flags &= ~NM_FLAG_NET_REFRESH_MCAST_ABORTING;
                goto error_exit;
            }
        }
        else
        {
            if (NmpLeaderNodeId == NmLocalNodeId)
            {
                //
                // NM leader died while this node was trying to get multicast key
                // from it. And this node becomes new NM leader. It is this node's
                // respondibility to create multicast key and disseminate to all
                // cluster nodes.
                //


                ClRtlLogPrint(LOG_NOISE,
                    "[NM] New NM leader. Create and disseminate multicast key "
                    "for network %1!ws!.\n",
                    networkId
                    );

                if (params.Key != NULL)
                {
                    RtlSecureZeroMemory(params.Key, params.KeyLength);
                    LocalFree(params.Key);
                }

                status = NmpCreateRandomNumber(&(params.Key),
                                               MulticastKeyLen
                                               );
                if (status != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to create random number "
                        "for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                    goto error_exit;
                }
                params.KeyLength = MulticastKeyLen;

                NmpReleaseLock();
                lockAcquired = FALSE;


                //
                // Disseminate the configuration.
                //
                status = NmpMulticastNotifyConfigChange(
                             Network,
                             networkKey,
                             &netParamKey,
                             &params,
                             NULL,
                             0
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to disseminate multicast "
                        "configuration for network %1!ws!, "
                        "status %2!u!.\n",
                        networkId, status
                        );
                }

                goto error_exit;

            }  // if (NmpLeaderNodeId == NmLocalNodeId)
            else
            {
                goto error_exit;
            }
        }
    }

    status = NmpProcessMulticastConfiguration(
                 Network,
                 &params,
                 &undoParams
                 );

    //
    // Check the lease renew parameters if this was not a
    // manual configuration.
    //
    if (!disabled && configType != NmMcastConfigManual) {
        NmpShareMulticastAddressLease(Network, TRUE);
    }

    //
    // Share responsibility for key regeneration.
    //
    NmpShareMulticastKeyRegeneration(Network, TRUE);

error_exit:

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to refresh multicast configuration "
            "for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast configuration refresh for "
            "network %1!ws! was successful.\n",
            networkId
            );
    }

    if (clusParamKey != NULL || netParamKey != NULL || networkKey != NULL) {

        if (lockAcquired) {
            NmpReleaseLock();
            lockAcquired = FALSE;
        }

        if (clusParamKey != NULL) {
            DmCloseKey(clusParamKey);
            clusParamKey = NULL;
        }

        if (netParamKey != NULL) {
            DmCloseKey(netParamKey);
            netParamKey = NULL;
        }

        if (networkKey != NULL) {
            DmCloseKey(networkKey);
            networkKey = NULL;
        }
    }

    NmpMulticastFreeParameters(&params);
    NmpMulticastFreeParameters(&undoParams);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    if (tryReconfigure) {
        NmpMulticastCheckReconfigure(Network);
    }

    if (clearRunningFlag) {
        Network->Flags &= ~NM_FLAG_NET_REFRESH_MCAST_RUNNING;
    }

    return(status);

} // NmpRefreshMulticastConfiguration


DWORD
NmpMulticastValidatePrivateProperties(
    IN  PNM_NETWORK Network,
    IN  HDMKEY      NetworkKey,
    IN  PVOID       InBuffer,
    IN  DWORD       InBufferSize
    )
/*++

Routine Description:

    Called when a manual update to the private properties
    of a network is detected. Only called on the node
    that receives the clusapi clusctl request.

    Verifies that no read-only properties are being set.
    Determines whether the multicast configuration of
    the network will need to be refreshed after the
    update.

    This routine is a no-op in a mixed-mode cluster.

--*/
{
    DWORD                     status;
    LPCWSTR                   networkId = OmObjectId(Network);
    NM_NETWORK_MULTICAST_INFO mcastInfo;

    //
    // Enforce property-validation regardless of number of
    // nodes in cluster.
    //
    if (!NmpIsClusterMulticastReady(FALSE, FALSE)) {
        return(ERROR_SUCCESS);
    }

    //
    // Don't allow any read-only properties to be set.
    //
    RtlZeroMemory(&mcastInfo, sizeof(mcastInfo));

    status = ClRtlVerifyPropertyTable(
                 NmpNetworkMulticastProperties,
                 NULL,    // Reserved
                 TRUE,    // Allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) &mcastInfo
                 );
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Error verifying private properties for "
            "network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

error_exit:

    NmpFreeNetworkMulticastInfo(&mcastInfo);

    return(status);

} // NmpMulticastValidatePrivateProperties


DWORD
NmpStartMulticast(
    IN OPTIONAL PNM_NETWORK              Network,
    IN          NM_START_MULTICAST_MODE  Mode
    )
/*++

Routine Description:

    Start multicast on a network or all networks after
    performing cluster-wide checks.

Arguments:

    Network - network on which to start multicast. If NULL,
              start multicast on all networks.

    Mode - indicates caller mode

Notes:

    Must be called with NM lock held.

--*/
{
    PLIST_ENTRY                     entry;
    PNM_NETWORK                     network;

    if (!NmpMulticastRunInitialConfig) {

        if (Mode == NmStartMulticastDynamic) {
            //
            // Defer until initial configuration.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Deferring dynamic multicast start until "
                "initial configuration.\n"
                );

            return(ERROR_SUCCESS);

        } else {
            NmpMulticastRunInitialConfig = TRUE;
        }
    }

    if (!NmpIsClusterMulticastReady(TRUE, TRUE)) {
        return(ERROR_SUCCESS);
    }

    if (Network == NULL) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Starting multicast for all cluster networks.\n"
            );

        for (entry = NmpNetworkList.Flink;
             entry != &NmpNetworkList;
             entry = entry->Flink) {

            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            NmpStartMulticastInternal(network, Mode);
        }

    } else {
        NmpStartMulticastInternal(Network, Mode);
    }

    return(ERROR_SUCCESS);

} // NmpStartMulticast

DWORD
NmpStopMulticast(
    IN OPTIONAL PNM_NETWORK   Network
    )
/*++

Routine Description:

    Stop multicast on the local node by configuring clusnet
    with a NULL address. This routine should be called
    from a GUM update or another barrier.

Routine Description:

    Network - network on which to stop multicast. If NULL,
              stop multicast on all networks.

Notes:

    Must be called with NM lock held.

--*/
{
    DWORD                           status = ERROR_SUCCESS;
    PLIST_ENTRY                     entry;
    PNM_NETWORK                     network;
    LPWSTR                          networkId;
    DWORD                           disabled;
    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS undoParams = { 0 };

    if (Network == NULL) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Stopping multicast for all cluster networks.\n"
            );

        for (entry = NmpNetworkList.Flink;
             entry != &NmpNetworkList;
             entry = entry->Flink) {

            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            status = NmpStopMulticast(network);
        }

    } else {

        networkId = (LPWSTR) OmObjectId(Network);
        disabled = (NmpIsNetworkMulticastEnabled(Network) ? 0 : 1);

        //
        // Check if telling clusnet to stop multicast would
        // be redundant.
        //
        if (disabled != 0 ||
            Network->MulticastAddress == NULL ||
            !wcscmp(Network->MulticastAddress, NmpNullMulticastAddress)) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Not necessary to stop multicast for "
                "cluster network %1!ws! (disabled = %2!u!, "
                "multicast address = %3!ws!).\n",
                networkId, disabled,
                ((Network->MulticastAddress == NULL) ?
                 L"<NULL>" : Network->MulticastAddress)
                );
            status = ERROR_SUCCESS;

        } else {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Stopping multicast for cluster network %1!ws!.\n",
                networkId
                );

            //
            // Create parameters from the current state of the network.
            // However, don't use any lease info, since we are stopping
            // multicast and will not be renewing.
            //
            status = NmpMulticastCreateParameters(
                         disabled,
                         NULL,     // blank address initially
                         NULL, // MulticastKey,
                         0, // MulticastKeyLength,
                         0,        // lease obtained
                         0,        // lease expires
                         NULL,     // lease request id
                         NULL,     // lease server
                         NmMcastConfigManual, // doesn't matter
                         &params
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to create multicast configuration "
                    "parameter block for network %1!ws!, status %2!u!, "
                    "while stopping multicast.\n",
                    networkId, status
                    );
                goto error_exit;
            }

            //
            // Nullify the address.
            //
            NmpMulticastSetNullAddressParameters(Network, &params);

            //
            // Send the parameters to clusnet.
            //
            status = NmpProcessMulticastConfiguration(
                         Network,
                         &params,
                         &undoParams
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to set null multicast "
                    "configuration for network %1!ws! "
                    "while stopping multicast, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }
        }

        //
        // Cancel the lease renew timer, if set.
        //
        NmpStartNetworkMulticastAddressRenewTimer(Network, 0);

        //
        // Clear the retry timers, if set.
        //
        Network->McastAddressReconfigureRetryTimer = 0;
        Network->McastAddressRefreshRetryTimer = 0;

        //
        // Clear multicast configuration work flags. Note
        // that this is best effort -- we do not attempt
        // to prevent race conditions where a multicast
        // configuration operation may already be in
        // progress, since such conditions would not
        // affect the integrity of the cluster.
        //
        Network->Flags &= ~NM_FLAG_NET_RENEW_MCAST_ADDRESS;
        Network->Flags &= ~NM_FLAG_NET_RECONFIGURE_MCAST;
        Network->Flags &= ~NM_FLAG_NET_REFRESH_MCAST;
    }

error_exit:


    if (status != ERROR_SUCCESS && Network != NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to stop multicast for "
            "network %1!ws!, status %2!u!.\n",
            OmObjectId(Network), status
            );
    }

    NmpMulticastFreeParameters(&params);
    NmpMulticastFreeParameters(&undoParams);

    return(status);

} // NmpStopMulticast
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\nminit.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nminit.c

Abstract:

    Initialization, cluster join, and cluster form routines for the
    Node Manager.

Author:

    Mike Massa (mikemas)

Revision History:

    6/03/96   Created.

--*/

/*

General Implementation Notes:

    The functions DmBeginLocalUpdate, DmCommitLocalUpdate, and
    DmAbortLocalUpdate cannot be called while holding the NM lock, or
    a deadlock with the NmTimer thread may result during regroup when
    disk writes are stalled. These functions attempt to write to the
    quorum disk.

*/


#include "nmp.h"
#include <ntmsv1_0.h>

#define CLUSREG_NAME_DISABLE_TRY_CACHE_FIRST L"DisableLsaTryCacheFirst"
#define NM_TIMER_THREAD_PRIORITY             15 // same as MM timer thread

//
// External Data
//
extern BOOL CsNoQuorum;

//
// Public Data
//
HANDLE            NmClusnetHandle = NULL;
HCRYPTPROV        NmCryptServiceProvider = 0;


//
// Private Data
//
CRITICAL_SECTION  NmpLock;
NM_STATE          NmpState = NmStateOffline;
DWORD             NmpActiveThreadCount = 0;
HANDLE            NmpShutdownEvent = NULL;
CL_NODE_ID        NmpJoinerNodeId = ClusterInvalidNodeId;
CL_NODE_ID        NmpSponsorNodeId = ClusterInvalidNodeId;
DWORD             NmpJoinTimer = 0;
BOOLEAN           NmpJoinAbortPending = FALSE;
DWORD             NmpJoinSequence = 0;
BOOLEAN           NmpJoinerUp = FALSE;
BOOLEAN           NmpJoinBeginInProgress = FALSE;
BOOLEAN           NmpJoinerOutOfSynch = FALSE;
LPWSTR            NmpClusnetEndpoint = NULL;
WCHAR             NmpInvalidJoinerIdString[] = L"0";
CL_NODE_ID        NmpLeaderNodeId = ClusterInvalidNodeId;
BOOL              NmpCleanupIfJoinAborted = FALSE;
BOOL              NmpSuccessfulMMJoin = FALSE;
DWORD             NmpAddNodeId = ClusterInvalidNodeId;
LPWSTR            NmpClusterInstanceId = NULL;
BOOLEAN           NmpGumUpdateHandlerRegistered = FALSE;
HANDLE            NmpNetworkTimerThreadHandle = NULL;
HANDLE            NmpNetworkTimerThreadStopEvent = NULL;


//externs

extern DWORD CsMyHighestVersion;
extern DWORD CsMyLowestVersion;
extern DWORD CsClusterHighestVersion;
extern DWORD CsClusterLowestVersion;

GUM_DISPATCH_ENTRY NmGumDispatchTable[] = {
    {1,                          NmpUpdateCreateNode},
    {1,                          NmpUpdatePauseNode},
    {1,                          NmpUpdateResumeNode},
    {1,                          NmpUpdateEvictNode},
    {4, (PGUM_DISPATCH_ROUTINE1) NmpUpdateCreateNetwork},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkName},
    {1,                          NmpUpdateSetNetworkPriorityOrder},
    {3, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkCommonProperties},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateCreateInterface},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetInterfaceInfo},
    {3, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetInterfaceCommonProperties},
    {1,                          NmpUpdateDeleteInterface},
    {3, (PGUM_DISPATCH_ROUTINE1) NmpUpdateJoinBegin},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateJoinAbort},
    //
    // Version 2 (NT 5.0) extensions that are understood by NT4 SP4
    //
    {5, (PGUM_DISPATCH_ROUTINE1) NmpUpdateJoinBegin2},
    {4, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkAndInterfaceStates},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdatePerformFixups},
    {5, (PGUM_DISPATCH_ROUTINE1) NmpUpdatePerformFixups2},
    //
    // Version 2 (NT 5.0) extensions that are not understood by NT4 SP4
    // These may not be called in a mixed NT4/NT5 cluster.
    //
    {5, (PGUM_DISPATCH_ROUTINE1) NmpUpdateAddNode},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateExtendedNodeState},
    //
    // NT 5.1 extensions that are not understood by NT5 and
    // earlier. NT5 nodes will ignore these updates without
    // error.
    //
    {4, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkMulticastConfiguration},
    {8, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetServiceAccountPassword},
    };

//
// Local prototypes
//
DWORD
NmpCreateRpcBindings(
    IN PNM_NODE  Node
    );

DWORD
NmpCreateClusterInstanceId(
    VOID
    );

DWORD
NmpStartNetworkTimerThread(
    VOID
    );

VOID
NmpStopNetworkTimerThread(
    VOID
    );

//
// Component initialization routines.
//
DWORD
NmInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the Node Manager component.

Arguments:

    None

Return Value:

    A Win32 status code.

Notes:

    The local node object is created by this routine.

--*/
{
    DWORD                      status;
    OM_OBJECT_TYPE_INITIALIZE  nodeTypeInitializer;
    HDMKEY                     nodeKey = NULL;
    DWORD                      nameSize = CS_MAX_NODE_NAME_LENGTH + 1;
    HKEY                       serviceKey;
    DWORD                      nodeIdSize = (CS_MAX_NODE_ID_LENGTH + 1) *
                                            sizeof(WCHAR);
    LPWSTR                     nodeIdString = NULL;
    WSADATA                    wsaData;
    WORD                       versionRequested;
    int                        err;
    ULONG                      ndx;
    DWORD                      valueType;
    NM_NODE_INFO2              nodeInfo;
    WCHAR                      errorString[12];
    DWORD                      eventCode = 0;
    LPWSTR                     string;
    PVOID                      wTimer;

    ULONG                      lsaProcessOptions;
    HDMKEY                     clusParamKey = NULL;


    CL_ASSERT(NmpState == NmStateOffline);

    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing...\n");

    //
    // Initialize globals.
    //
    InitializeCriticalSection(&NmpLock);

    InitializeListHead(&NmpNodeList);
    InitializeListHead(&NmpNetworkList);
    InitializeListHead(&NmpInternalNetworkList);
    InitializeListHead(&NmpDeletedNetworkList);
    InitializeListHead(&NmpInterfaceList);
    InitializeListHead(&NmpDeletedInterfaceList);

    NmMaxNodes = ClusterDefaultMaxNodes;
    NmMaxNodeId = ClusterMinNodeId + NmMaxNodes - 1;


    //
    // Initializing the RPC Recording/cancelling mechanism
    // NOTE - This should move if NmMaxNodeId Definition above moves.
    //
    NmpIntraClusterRpcArr = LocalAlloc(LMEM_FIXED,
                            sizeof(NM_INTRACLUSTER_RPC_THREAD) * (NmMaxNodeId +1));

    if(NmpIntraClusterRpcArr == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for RPC monitoring.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        goto error_exit;
    }
    else {
        ZeroMemory(NmpIntraClusterRpcArr,
            sizeof(NM_INTRACLUSTER_RPC_THREAD) * (NmMaxNodeId + 1));
        for(ndx = 0;ndx <= NmMaxNodeId;ndx++)
            InitializeListHead(&NmpIntraClusterRpcArr[ndx]);

        InitializeCriticalSection(&NmpRPCLock);
    }



    //
    // Initialize the network configuration package.
    //
    ClNetInitialize(
        ClNetPrint,
        ClNetLogEvent,
        ClNetLogEvent1,
        ClNetLogEvent2,
        ClNetLogEvent3
        );

    //
    // Initialize WinSock
    //
    versionRequested = MAKEWORD(2,0);

    err = WSAStartup(versionRequested, &wsaData);

    if (err != 0) {
        status = WSAGetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, NM_EVENT_WSASTARTUP_FAILED, errorString);
        ClRtlLogPrint(LOG_NOISE,"[NM] Failed to initialize Winsock, status %1!u!\n", status);
        return(status);
    }

    if ( (LOBYTE(wsaData.wVersion) != 2) || (HIBYTE(wsaData.wVersion) != 0)) {
        status = WSAVERNOTSUPPORTED;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, NM_EVENT_WSASTARTUP_FAILED, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Found unexpected Windows Sockets version %1!u!\n",
            wsaData.wVersion
            );
        WSACleanup();
        return(status);
    }

    NmpShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (NmpShutdownEvent == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create shutdown event, status %1!u!\n",
            status
            );
        WSACleanup();
        return(status);
    }

    NmpState = NmStateOnlinePending;

    //
    // Get the name of this node.
    //
    if (!GetComputerName(&(NmLocalNodeName[0]), &nameSize)) {
        status = GetLastError();
        eventCode = NM_EVENT_GETCOMPUTERNAME_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to get local computername, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Local node name = %1!ws!.\n",
        NmLocalNodeName
        );

    //
    // Open a control channel to the Cluster Network driver
    //
    NmClusnetHandle = ClusnetOpenControlChannel(0);

    if (NmClusnetHandle == NULL) {
        status = GetLastError();
        eventCode = NM_EVENT_CLUSNET_UNAVAILABLE;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to open a handle to the Cluster Network driver, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Tell the Cluster Network driver to shutdown when our handle is closed
    // in case the Cluster Service crashes.
    //
    status = ClusnetEnableShutdownOnClose(NmClusnetHandle);

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CLUSNET_ENABLE_SHUTDOWN_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to register Cluster Network shutdown trigger, status %1!u!\n",
            status
            );

        goto error_exit;
    }

    //
    // Allocate the node ID array.
    //
    CL_ASSERT(NmpIdArray == NULL);

    NmpIdArray = LocalAlloc(
                     LMEM_FIXED,
                     (sizeof(PNM_NODE) * (NmMaxNodeId + 1))
                     );

    if (NmpIdArray == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        goto error_exit;
    }

    ZeroMemory(NmpIdArray, (sizeof(PNM_NODE) * (NmMaxNodeId + 1)));

    //
    // Create the node object type
    //
    ZeroMemory(&nodeTypeInitializer, sizeof(OM_OBJECT_TYPE_INITIALIZE));
    nodeTypeInitializer.ObjectSize = sizeof(NM_NODE);
    nodeTypeInitializer.Signature = NM_NODE_SIG;
    nodeTypeInitializer.Name = L"Node";
    nodeTypeInitializer.DeleteObjectMethod = NmpDestroyNodeObject;

    status = OmCreateType(ObjectTypeNode, &nodeTypeInitializer);

    if (status != ERROR_SUCCESS) {
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create node object type, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Get the local node ID from the local registry.
    //
    status = RegCreateKeyW(
                 HKEY_LOCAL_MACHINE,
                 CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                 &serviceKey
                 );

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open cluster service parameters key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    string = L"NodeId";
    status = RegQueryValueExW(
                 serviceKey,
                 string,
                 0,
                 &valueType,
                 (LPBYTE) &(NmLocalNodeIdString[0]),
                 &nodeIdSize
                 );

    RegCloseKey(serviceKey);

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to read local node ID from registry, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    if (valueType != REG_SZ) {
        status = ERROR_INVALID_PARAMETER;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Local Node ID registry value is not of type REG_SZ.\n"
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Local node ID = %1!ws!.\n",
        NmLocalNodeIdString
        );

    NmLocalNodeId = wcstoul(NmLocalNodeIdString, NULL, 10);

    //
    // Get information about the local node.
    //
    wcscpy(&(nodeInfo.NodeId[0]), NmLocalNodeIdString);

    status = NmpGetNodeDefinition(&nodeInfo);

    if (status != ERROR_SUCCESS) {
       goto error_exit;
    }

    //
    // Create the local node object. We must do this here because GUM
    // requires the local node object to initialize.
    //
    status = NmpCreateLocalNodeObject(&nodeInfo);

    ClNetFreeNodeInfo(&nodeInfo);

    if (status != ERROR_SUCCESS) {
       goto error_exit;
    }

    //
    // Initialize the network and interface object types
    //
    status = NmpInitializeNetworks();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpInitializeInterfaces();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Initialize net PnP handling
    //
    status = NmpInitializePnp();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // init the advise sink that tells when a connection object has been
    // renamed
    //

    // Wrapping this call with watchdog timeout of 3 mins. 411333
    wTimer = ClRtlSetWatchdogTimer(180000, L"Calling Initialize Connectoid Advise Sink");
    status = NmpInitializeConnectoidAdviseSink();
    ClRtlCancelWatchdogTimer(wTimer);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Set the LSA options for this process.
    //

    // When authenticating, try cached credentials first.
    lsaProcessOptions = MSV1_0_OPTION_TRY_CACHE_FIRST;

    // Check if a registry parameter commands us to disable the
    // try cache first option.
    clusParamKey = DmOpenKey(
                       DmClusterParametersKey,
                       CLUSREG_KEYNAME_PARAMETERS,
                       KEY_READ
                       );
    if (clusParamKey != NULL) {

        DWORD type = REG_DWORD;
        DWORD disabled = 0;
        DWORD len = sizeof(disabled);

        status = DmQueryValue(
                     clusParamKey,
                     CLUSREG_NAME_DISABLE_TRY_CACHE_FIRST,
                     &type,
                     (LPBYTE) &disabled,
                     &len
                     );
        if (status == ERROR_SUCCESS) {
            // The value was found. Make sure it is a DWORD.
            if (type == REG_DWORD) {
                // If disabled, turn off the cache first option.
                if (disabled != 0) {
                    lsaProcessOptions &= ~MSV1_0_OPTION_TRY_CACHE_FIRST;
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] The LSA cache-first process option will "
                        "not be enabled.\n"
                        );
                }
            } else {
                // Warn in the cluster log that the type
                // is incorrect.
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Ignoring cluster parameter %1!ws! "
                    "because it is not of type REG_DWORD (%2!u!).\n",
                    CLUSREG_NAME_DISABLE_TRY_CACHE_FIRST, type
                    );
            }
        }

    } else {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to open cluster parameters key, "
            "status %1!u!.\n",
            status
            );
        // Non-fatal error. Stick with default.
    }

    // Set password policy
    if ( CsRunningAsService) {

        // Set password policy to allow RPC authentication to ignore a WRONG_PASSWORD
        // message from a domain controller and try authentication against the current
        // in-memory credentials.
        //
        // The password change operation is only valid when running as a service.
        lsaProcessOptions |= MSV1_0_OPTION_ALLOW_OLD_PASSWORD;
    }

    // Call into LSA to set the options.
    if (lsaProcessOptions != 0) {
        status = NmpSetLsaProcessOptions(lsaProcessOptions);
        if (status != ERROR_SUCCESS) {

            if (!CsRunningAsService &&
                // Not a fatal error if running in debug mode and only trying
                // to set cache-first option.
                lsaProcessOptions == MSV1_0_OPTION_TRY_CACHE_FIRST) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to enable LSA cache-first process "
                    "option, status %1!u!.\n",
                    status
                    );
                status = ERROR_SUCCESS;
            } else {
                // Fatal error.
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to set LSA process options to %1!x!, "
                    "status %2!u!.\n",
                    lsaProcessOptions, status
                    );
                goto error_exit;
            }
        }
    }

    //
    //  Initialize NmCryptServiceProvider
    //
    status = NmpCreateCSPHandle(&NmCryptServiceProvider);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to initialize NmCryptServiceProvider, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,"[NM] Initialization complete.\n");

    return(ERROR_SUCCESS);


error_exit:

    if (clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    wsprintfW( &(errorString[0]), L"%u", status );
    CsLogEvent1(LOG_CRITICAL, NM_INIT_FAILED, errorString);

    ClRtlLogPrint(LOG_CRITICAL,"[NM] Initialization failed %1!d!\n",status);

    NmShutdown();

    return(status);

}  // NmInitialize


VOID
NmShutdown(
    VOID
    )
/*++

Routine Description:

    Terminates all processing - shuts down all sources of work for
    worker threads.

Arguments:



Return Value:



--*/
{
    DWORD status;


    if (NmpState == NmStateOffline) {
        return;
    }

    NmCloseConnectoidAdviseSink();

    NmpShutdownPnp();

    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,"[NM] Shutdown starting...\n");



    //
    // Release NmCryptServiceProvider.
    //
    if(NmCryptServiceProvider)
    {
       if (!CryptReleaseContext(NmCryptServiceProvider,0))
       {
           ClRtlLogPrint(
               LOG_UNUSUAL,
               "NM]  Failed to release "
               "crypto provider, status %1!u!\n",
               GetLastError()
               );
       }
    }


    NmpState = NmStateOfflinePending;

    if (NmpActiveThreadCount > 0) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Waiting for %1!u! active threads to terminate...\n",
            NmpActiveThreadCount
            );

        NmpReleaseLock();

        status = WaitForSingleObject(NmpShutdownEvent, INFINITE);

        CL_ASSERT(status == WAIT_OBJECT_0);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] All active threads have completed. Continuing shutdown...\n"
            );

    }
    else {
        NmpReleaseLock();
    }

    NmLeaveCluster();

    NmpCleanupPnp();

    if (NmLocalNode != NULL) {
        NmpDeleteNodeObject(NmLocalNode, FALSE);
        NmLocalNode = NULL;
    }

    if (NmpIdArray != NULL) {
        LocalFree(NmpIdArray); NmpIdArray = NULL;
    }

    NmpFreeClusterKey();

    if (NmpClusterInstanceId != NULL) {
        MIDL_user_free(NmpClusterInstanceId);
        NmpClusterInstanceId = NULL;
    }

    if (NmClusnetHandle != NULL) {
        ClusnetCloseControlChannel(NmClusnetHandle);
        NmClusnetHandle = NULL;
    }

    CloseHandle(NmpShutdownEvent); NmpShutdownEvent = NULL;

    WSACleanup();

    //
    // As long as the GUM and Clusapi RPC interfaces cannot be
    //          shutdown, it is not safe to delete this critical section.
    //
    // DeleteCriticalSection(&NmpLock);

    NmpState = NmStateOffline;

    ClRtlLogPrint(LOG_NOISE,"[NM] Shutdown complete.\n");

    return;

}  // NmShutdown


VOID
NmLeaveCluster(
    VOID
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD status;


    if (NmLocalNode != NULL) {
        if ( (NmLocalNode->State == ClusterNodeUp) ||
             (NmLocalNode->State == ClusterNodePaused) ||
             (NmLocalNode->State == ClusterNodeJoining)
           )
        {
            //
            // Leave the cluster.
            //
            ClRtlLogPrint(LOG_NOISE,"[NM] Leaving cluster.\n");

            MMLeave();

#ifdef MM_IN_CLUSNET

            status = ClusnetLeaveCluster(NmClusnetHandle);
            CL_ASSERT(status == ERROR_SUCCESS);

#endif // MM_IN_CLUSNET

        }
    }

    NmpStopNetworkTimerThread();

    NmpMembershipShutdown();

    NmpCleanupInterfaces();

    NmpCleanupNetworks();

    NmpCleanupNodes();

    //
    // Shutdown the Cluster Network driver.
    //
    if (NmClusnetHandle != NULL) {
        status = ClusnetShutdown(NmClusnetHandle);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Shutdown of the Cluster Network driver failed, status %1!u!\n",
                status
                );
        }
    }

    if (NmpClusnetEndpoint != NULL) {
        MIDL_user_free(NmpClusnetEndpoint);
        NmpClusnetEndpoint = NULL;
    }

    return;

}  // NmLeaveCluster


DWORD
NmpCreateClusterObjects(
    IN  RPC_BINDING_HANDLE  JoinSponsorBinding
    )
/*++

Routine Description:

    Creates objects to represent the cluster's nodes, networks, and
    interfaces.

Arguments:

    JoinSponsorBinding  - A pointer to an RPC binding handle for the sponsor
                          node if this node is joining a cluster. NULL if
                          this node is forming a cluster.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

Notes:

    This routine MUST NOT be called with the NM lock held.

--*/
{
    DWORD                status;
    PNM_NODE_ENUM2       nodeEnum = NULL;
    PNM_NETWORK_ENUM     networkEnum = NULL;
    PNM_INTERFACE_ENUM2  interfaceEnum = NULL;
    PNM_NODE             node = NULL;
    DWORD                matchedNetworkCount = 0;
    DWORD                newNetworkCount = 0;
    DWORD                InitRetry = 2;
    WCHAR                errorString[12];
    DWORD                eventCode = 0;
    BOOL                 renameConnectoids;


    do {
        //
        // Initialize the Cluster Network driver. This will clean up
        // any old state that was left around from the last run of the
        // Cluster Service. Note that the local node object is registered in
        // this call.
        //
        status = ClusnetInitialize(
                     NmClusnetHandle,
                     NmLocalNodeId,
                     NmMaxNodes,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     );

        if (status == ERROR_SUCCESS) {
            break;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Shutting down Cluster Network driver before retrying Initialization, status %1!u!\n",
                        status);

            ClusnetShutdown( NmClusnetHandle );
        }
    } while ( InitRetry-- );

    if ( status != ERROR_SUCCESS ) {
        eventCode = NM_EVENT_CLUSNET_INITIALIZE_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Initialization of the Cluster Network driver failed, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Tell the Cluster Network driver to reserve the Cluster Network
    // endpoint on this node.
    //
    status = ClusnetReserveEndpoint(
                 NmClusnetHandle,
                 NmpClusnetEndpoint
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to reserve Clusnet Network endpoint %1!ws!, "
            "status %2!u!\n", NmpClusnetEndpoint, status
            );
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_CLUSNET_RESERVE_ENDPOINT_FAILED,
            NmpClusnetEndpoint,
            errorString
            );
        goto error_exit;
    }

    //
    // Obtain the node portion of the cluster database.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Synchronizing node information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumNodeDefinitions(&nodeEnum);
    }
    else {
        status = NmRpcEnumNodeDefinitions2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &nodeEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to synchronize node information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Create the node objects.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating node objects.\n"
        );

    status = NmpCreateNodeObjects(nodeEnum);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Obtain the networks portion of the cluster database.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Synchronizing network information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumNetworkDefinitions(&networkEnum);
    }
    else {
        status = NmRpcEnumNetworkDefinitions(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &networkEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to synchronize network information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Obtain the interfaces portion of the cluster database.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Synchronizing interface information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumInterfaceDefinitions(&interfaceEnum);
    }
    else {
        status = NmRpcEnumInterfaceDefinitions2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &interfaceEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to synchronize interface information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    if ( CsUpgrade ) {
        //
        // If this is an upgrade from NT4 to Whistler, then fix up the
        // connectoid names so they align with the cluster network
        // names.
        //
        // REMOVE THIS PORTION AFTER WHISTLER HAS SHIPPED.
        //
        if ( CLUSTER_GET_MAJOR_VERSION( NmLocalNode->HighestVersion ) <= NT4SP4_MAJOR_VERSION ) {
            renameConnectoids = TRUE;
        } else {
            //
            // upgrade from W2K to Whistler. Nothing should have changed but
            // if it did, connectoids should have precedence
            //
            renameConnectoids = FALSE;
        }
    } else {
        //
        // THIS SECTION MUST ALWAYS BE HERE
        //
        // if forming, cluster network objects are renamed to its
        // corresponding connectoid name. During a join, the opposite is true.
        //
        if ( JoinSponsorBinding ) {
            renameConnectoids = TRUE;
        } else {
            renameConnectoids = FALSE;
        }
    }

    //
    // Post a PnP notification ioctl. If we receive a PnP notification
    // before we finish initializing, we must restart the process.
    //
    NmpWatchForPnpEvents();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Run the network configuration engine. This will update the
    // cluster database.
    //
    status = NmpConfigureNetworks(
                 JoinSponsorBinding,
                 NmLocalNodeIdString,
                 NmLocalNodeName,
                 &networkEnum,
                 &interfaceEnum,
                 NmpClusnetEndpoint,
                 &matchedNetworkCount,
                 &newNetworkCount,
                 renameConnectoids
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to configure networks & interfaces, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Matched %1!u! networks, created %2!u! new networks.\n",
        matchedNetworkCount,
        newNetworkCount
        );

    //
    // Get the updated network information from the database.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Resynchronizing network information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumNetworkDefinitions(&networkEnum);
    }
    else {
        status = NmRpcEnumNetworkDefinitions(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &networkEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to resynchronize network information, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Get the updated interface information from the database.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Resynchronizing interface information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumInterfaceDefinitions(&interfaceEnum);
    }
    else {
        status = NmRpcEnumInterfaceDefinitions2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &interfaceEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to resynchronize interface information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Create the network objects.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating network objects.\n"
        );

    status = NmpCreateNetworkObjects(networkEnum);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create network objects, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Fixup the priorities of the internal networks if we are forming
    // a cluster.
    //
    if (JoinSponsorBinding == NULL) {
        DWORD          networkCount;
        PNM_NETWORK *  networkList;

        status = NmpEnumInternalNetworks(&networkCount, &networkList);

        if ((status == ERROR_SUCCESS) && (networkCount > 0)) {
            DWORD             i;
            HLOCALXSACTION    xaction;


            //
            // Begin a transaction - this must not be done while holding
            //                       the NM lock.
            //
            xaction = DmBeginLocalUpdate();

            if (xaction == NULL) {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to start a transaction, status %1!u!\n",
                    status
                    );
                goto error_exit;
            }

            status = NmpSetNetworkPriorityOrder(
                         networkCount,
                         networkList,
                         xaction
                         );

            if (status == ERROR_SUCCESS) {
                DmCommitLocalUpdate(xaction);
            }
            else {
                DmAbortLocalUpdate(xaction);
                goto error_exit;
            }

            for (i=0; i<networkCount; i++) {
                if (networkList[i] != NULL) {
                    OmDereferenceObject(networkList[i]);
                }
            }

            LocalFree(networkList);
        }
    }

    //
    // Create the interface objects.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating interface objects.\n"
        );

    status = NmpCreateInterfaceObjects(interfaceEnum);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create interface objects, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    if (JoinSponsorBinding != NULL) {
        //
        // The node must have connectivity to all active cluster nodes
        // in order to join a cluster.
        //
        PNM_NODE unreachableNode;

        if (!NmpVerifyJoinerConnectivity(NmLocalNode, &unreachableNode)) {
            status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            CsLogEvent1(
                LOG_CRITICAL,
                NM_EVENT_NODE_UNREACHABLE,
                OmObjectName(unreachableNode)
                );
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Joining node cannot communicate with all other "
                "active nodes.\n"
                );
            goto error_exit;
        }
    }

    status = NmpMembershipInit();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpStartNetworkTimerThread();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    if (nodeEnum != NULL) {
        ClNetFreeNodeEnum(nodeEnum);
    }

    if (networkEnum != NULL) {
        ClNetFreeNetworkEnum(networkEnum);
    }

    if (interfaceEnum != NULL) {
        ClNetFreeInterfaceEnum(interfaceEnum);
    }

    return(status);

}  // NmpCreateClusterObjects



//
// Routines common to joining and forming.
//

DWORD
NmpCreateClusterInstanceId(
    VOID
    )
/*++

Routine Description:

    Checks the cluster database for the cluster instance id. Creates
    if not present.

--*/
{
    DWORD       status;
    LPWSTR      clusterInstanceId = NULL;
    DWORD       clusterInstanceIdBufSize = 0;
    DWORD       clusterInstanceIdSize = 0;
    BOOLEAN     found = FALSE;
    UUID        guid;

    do {

        status = NmpQueryString(
                     DmClusterParametersKey,
                     L"ClusterInstanceID",
                     REG_SZ,
                     &clusterInstanceId,
                     &clusterInstanceIdBufSize,
                     &clusterInstanceIdSize
                     );

        if (status == ERROR_SUCCESS) {
            found = TRUE;
        } else {

            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Cluster Instance ID not found in "
                "cluster database, status %1!u!.\n",
                status
                );

            status = UuidCreate(&guid);
            if (status == RPC_S_OK) {

                status = UuidToString(&guid, &clusterInstanceId);
                if (status == RPC_S_OK) {

                    status = DmSetValue(
                                 DmClusterParametersKey,
                                 L"ClusterInstanceID",
                                 REG_SZ,
                                 (PBYTE) clusterInstanceId,
                                 NM_WCSLEN(clusterInstanceId)
                                 );
                    if (status != ERROR_SUCCESS) {

                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NMJOIN] Failed to store Cluster Instance ID "
                            "in cluster database, status %1!u!.\n",
                            status
                            );
                    }

                    if (clusterInstanceId != NULL) {
                        RpcStringFree(&clusterInstanceId);
                        clusterInstanceId = NULL;
                    }
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Failed to convert Cluster Instance ID "
                        "GUID into string, status %1!u!.\n",
                        status
                        );
                }

            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Failed to create Cluster Instance ID GUID, "
                    "status %1!u!.\n",
                    status
                    );
            }
        }
    } while ( !found && (status == ERROR_SUCCESS) );

    if (status == ERROR_SUCCESS) {

        CL_ASSERT(clusterInstanceId != NULL);

        NmpAcquireLock();

        if (NmpClusterInstanceId == NULL) {
            NmpClusterInstanceId = clusterInstanceId;
            clusterInstanceId = NULL;
        }

        NmpReleaseLock();
    }

    if (clusterInstanceId != NULL) {
        midl_user_free(clusterInstanceId);
        clusterInstanceId = NULL;
    }

    return(status);

} // NmpCreateClusterInstanceId

//
// Routines for forming a new cluster.
//

DWORD
NmFormNewCluster(
    VOID
    )
{
    DWORD           status;
    DWORD           isPaused = FALSE;
    DWORD           pausedDefault = FALSE;
    HDMKEY          nodeKey;
    DWORD           valueLength, valueSize;
    WCHAR           errorString[12], errorString2[12];
    DWORD           eventCode = 0;
    PLIST_ENTRY     entry;
    PNM_NETWORK     network;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Beginning cluster form process.\n"
        );

    //
    // Since this node is forming the cluster, it is the leader.
    //
    NmpLeaderNodeId = NmLocalNodeId;

    //
    // Read the clusnet endpoint override value from the registry, if it
    // exists.
    //
    if (NmpClusnetEndpoint != NULL) {
        MIDL_user_free(NmpClusnetEndpoint);
        NmpClusnetEndpoint = NULL;
    }

    valueLength = 0;

    status = NmpQueryString(
                 DmClusterParametersKey,
                 L"ClusnetEndpoint",
                 REG_SZ,
                 &NmpClusnetEndpoint,
                 &valueLength,
                 &valueSize
                 );

    if (status == ERROR_SUCCESS) {
        USHORT  endpoint;

        //
        // Validate the value
        //
        status = ClRtlTcpipStringToEndpoint(
                     NmpClusnetEndpoint,
                     &endpoint
                     );

        if (status != ERROR_SUCCESS) {
            CsLogEvent2(
                LOG_UNUSUAL,
                NM_EVENT_INVALID_CLUSNET_ENDPOINT,
                NmpClusnetEndpoint,
                CLUSNET_DEFAULT_ENDPOINT_STRING
                );
            ClRtlLogPrint(
                LOG_CRITICAL,
                "[NM] '%1!ws!' is not valid endpoint value. Using default value %2!ws!.\n",
                NmpClusnetEndpoint,
                CLUSNET_DEFAULT_ENDPOINT_STRING
                );
            MIDL_user_free(NmpClusnetEndpoint);
            NmpClusnetEndpoint = NULL;
        }
    }

    if (status != ERROR_SUCCESS) {
        NmpClusnetEndpoint = MIDL_user_allocate(
                                 NM_WCSLEN(CLUSNET_DEFAULT_ENDPOINT_STRING)
                                 );

        if (NmpClusnetEndpoint == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
            return(status);
        }

        lstrcpyW(NmpClusnetEndpoint, CLUSNET_DEFAULT_ENDPOINT_STRING);
    }

    //
    // Create the node, network, and interface objects
    //
    status = NmpCreateClusterObjects(NULL);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Perform version checking - check if we are compatible with the rest of the cluster
    //
    status = NmpIsNodeVersionAllowed(NmLocalNodeId, CsMyHighestVersion,
            CsMyLowestVersion, FALSE);
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Version of Node %1!ws! is no longer compatible with other members of the cluster.\n",
            NmLocalNodeIdString);
        goto error_exit;

    }

    //If the forming node's version has changed, fix it up
    status = NmpValidateNodeVersion(
                 NmLocalNodeIdString,
                 CsMyHighestVersion,
                 CsMyLowestVersion
                 );

    if (status == ERROR_REVISION_MISMATCH)
    {
        //there was a version change, try and fix it up
        status = NmpFormFixupNodeVersion(
                     NmLocalNodeIdString,
                     CsMyHighestVersion,
                     CsMyLowestVersion
                     );
        NmLocalNodeVersionChanged = TRUE;
    }
    if (status != ERROR_SUCCESS)
    {
        goto error_exit;
    }


    //
    //at this point we ready to calculate the cluster version
    //all the node versions are in the registry, the fixups have
    //been made if neccessary
    //
    NmpResetClusterVersion(FALSE);

    NmpMulticastInitialize();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Forming cluster membership.\n"
        );

    status = MMJoin(
                 NmLocalNodeId,
                 NM_CLOCK_PERIOD,
                 NM_SEND_HB_RATE,
                 NM_RECV_HB_RATE,
                 NM_MM_JOIN_TIMEOUT
                 );

    if (status != MM_OK) {
        status = MMMapStatusToDosError(status);
        eventCode = NM_EVENT_MM_FORM_FAILED;
        ClRtlLogPrint(
            LOG_CRITICAL,
            "[NM] Membership form failed, status %1!u!. Unable to form a cluster.\n",
            status
            );
        goto error_exit;
    }

#ifdef MM_IN_CLUSNET

    status = ClusnetFormCluster(
                 NmClusnetHandle,
                 NM_CLOCK_PERIOD,
                 NM_SEND_HB_RATE,
                 NM_RECV_HB_RATE
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_CRITICAL,
            "[NM] Failed to form a cluster, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

#endif // MM_IN_CLUSNET

    //
    // Check to see if we should come up in the paused state.
    //
    nodeKey = DmOpenKey(
                  DmNodesKey,
                  NmLocalNodeIdString,
                  KEY_READ
                  );

    if (nodeKey != NULL) {
        status = DmQueryDword(
                     nodeKey,
                     CLUSREG_NAME_NODE_PAUSED,
                     &isPaused,
                     &pausedDefault
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(
                LOG_UNUSUAL,
                "[NM] Unable to query Paused value for local node, status %1!u!.\n",
                status
                );
        }

        DmCloseKey(nodeKey);
    }
    else {
        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[NM] Unable to open database key to local node, status %1!u!. Unable to determine Pause state.\n",
            status
            );
    }

    NmpAcquireLock();

    if (isPaused) {
        NmLocalNode->State = ClusterNodePaused;
    } else {
        NmLocalNode->State = ClusterNodeUp;
    }
    NmLocalNode->ExtendedState = ClusterNodeJoining;

    NmpState = NmStateOnline;

    NmpReleaseLock();

    //
    // If the cluster instance ID does not exist, create it now. The cluster
    // instance ID should be in the database unless this is the first uplevel
    // node.
    //
    NmpCreateClusterInstanceId();

    //
    // Derive the cluster key.
    //
    status = NmpRederiveClusterKey();
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to derive cluster key, status %1!u!. "
            "Aborting ...\n",
            status
            );
        goto error_exit;
    }

    //
    // Enable communication for the local node.
    //
    status = ClusnetOnlineNodeComm(NmClusnetHandle, NmLocalNodeId);

    if (status != ERROR_SUCCESS) {

        wsprintfW(&(errorString[0]), L"%u", NmLocalNodeId);
        wsprintfW(&(errorString2[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_CLUSNET_ONLINE_COMM_FAILED,
            errorString,
            errorString2
            );

        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to enable communication for local node, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    GumReceiveUpdates(FALSE,
                      GumUpdateMembership,
                      NmpGumUpdateHandler,
                      NULL,
                      sizeof(NmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      NmGumDispatchTable,
                      NULL
                      );

    // DavidDio 8/16/2001
    // Bug 456951: There is a race condition between the network and
    // interface state update and setting the NM state to online. If the
    // state is online but no GUM handler is registered, the update will
    // not be invoked. Hence, use the following flag to indicate that
    // a handler is ready.
    NmpGumUpdateHandlerRegistered = TRUE;

    //
    // Enable network PnP event handling.
    //
    // If a PnP event occured during the form process, an error code will
    // be returned, which will abort startup of the service.
    //
    status = NmpEnablePnpEvents();

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] A network PnP event occurred during form - abort.\n");
        goto error_exit;
    }

    //
    // Check if we formed without any viable networks. The form is still
    // allowed, but we record an entry in the system event log.
    //
    if (!NmpCheckForNetwork()) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Formed cluster with no viable networks.\n"
            );
        CsLogEvent(LOG_UNUSUAL, NM_EVENT_FORM_WITH_NO_NETWORKS);
    }

    //
    // Force a reconfiguration of multicast parameters and plumb
    // the results in clusnet.
    //
    NmpAcquireLock();

    status = NmpStartMulticast(NULL, NmStartMulticastForm);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to start multicast "
            "on cluster networks, status %1!u!.\n",
            status
            );
        //
        // Not a de facto fatal error.
        //
        status = ERROR_SUCCESS;
    }

    NmpReleaseLock();

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    return(status);

}  // NmFormNewCluster


//
//
// Client-side routines for joining a cluster.
//
//
DWORD
NmJoinCluster(
    IN RPC_BINDING_HANDLE  SponsorBinding
    )
{
    DWORD             status;
    DWORD             sponsorNodeId;
    PNM_INTERFACE     netInterface;
    PNM_NETWORK       network;
    PNM_NODE          node;
    PLIST_ENTRY       nodeEntry, ifEntry;
    WCHAR             errorString[12], errorString2[12];
    DWORD             eventCode = 0;
    DWORD             versionFlags = 0;
    extern BOOLEAN    bFormCluster;
    DWORD             retry;
    BOOLEAN           joinBegin3 = TRUE;
    LPWSTR            clusterInstanceId = NULL;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Beginning cluster join process.\n"
        );

    // GN: If a node tries to restart immediately after a clean shutdown,
    // NmRpcJoinBegin2 can fail with ERROR_CLUSTER_NODE_UP. Since the regroup
    // incident caused by this node might not be finished.
    //
    // If we are getting error CLUSTER_NODE_UP, we will keep retrying for
    // 12 seconds, hoping that regroup will finish.

    retry = 120 / 3; // We sleep for 3 seconds. Need to wait 2 minutes //
    for (;;) {
        //
        // Get the join sequence number so we can tell if the cluster
        // configuration changes during the join process. We overload the
        // use of the NmpJoinSequence variable since it isn't used in the
        // sponsor capacity until the node joins.
        //

        //
        // Try NmRpcJoinBegin3. If it fails with an RPC procnum out of
        // range error, the sponsor is a downlevel node. Revert to
        // NmRpcJoinBegin2.
        //
        if (joinBegin3) {

            // Only read the cluster instance ID from the registry on
            // the first try.
            if (clusterInstanceId == NULL) {

                DWORD       clusterInstanceIdBufSize = 0;
                DWORD       clusterInstanceIdSize = 0;

                status = NmpQueryString(
                             DmClusterParametersKey,
                             L"ClusterInstanceID",
                             REG_SZ,
                             &clusterInstanceId,
                             &clusterInstanceIdBufSize,
                             &clusterInstanceIdSize
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Failed to read cluster instance ID from database, status %1!u!.\n",
                        status
                        );
                    // Try to join with the downlevel interface. It is
                    // possible that this node was just upgraded and the
                    // last time it was in the cluster there was no
                    // cluster instance ID.
                    joinBegin3 = FALSE;
                    continue;
                }
            }

            status = NmRpcJoinBegin3(
                         SponsorBinding,
                         clusterInstanceId,
                         NmLocalNodeIdString,
                         NmLocalNodeName,
                         CsMyHighestVersion,
                         CsMyLowestVersion,
                         0,   // joiner's major node version
                         0,   // joiner's minor node version
                         L"", // joiner's CsdVersion
                         0,   // joiner's product suite
                         &sponsorNodeId,
                         &NmpJoinSequence,
                         &NmpClusnetEndpoint
                         );
            if (status == RPC_S_PROCNUM_OUT_OF_RANGE) {
                // retry immediately with JoinBegin2
                joinBegin3 = FALSE;
                continue;
            }
        } else {

            status = NmRpcJoinBegin2(
                         SponsorBinding,
                         NmLocalNodeIdString,
                         NmLocalNodeName,
                         CsMyHighestVersion,
                         CsMyLowestVersion,
                         &sponsorNodeId,
                         &NmpJoinSequence,
                         &NmpClusnetEndpoint
                         );
        }

        if ( ((status != ERROR_CLUSTER_NODE_UP
            && status != ERROR_CLUSTER_JOIN_IN_PROGRESS) ) || retry == 0 )
        {
            break;
        }
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Unable to begin join, status %1!u!. Retrying ...\n",
            status
            );
        CsServiceStatus.dwCheckPoint++;
        CsAnnounceServiceStatus();
        Sleep(3000);
        --retry;
    }

    // Free the cluster instance ID string, if necessary.
    if (clusterInstanceId != NULL) {
        midl_user_free(clusterInstanceId);
    }

    // [GORN Jan/7/2000]
    // If we are here, then we have already successfully talked to the sponsor
    // via JoinVersion interface.
    //
    // We shouldn't try to form the cluster if NmRpcJoinBegin2 fails.
    // Otherwise we may steal the quorum on the move [452108]

    //
    // Past this point we will not try to form a cluster
    //
    bFormCluster = FALSE;

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_BEGIN_JOIN_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NMJOIN] Unable to begin join, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Sponsor node ID = %1!u!. Join sequence number = %2!u!, endpoint = %3!ws!.\n",
        sponsorNodeId,
        NmpJoinSequence,
        NmpClusnetEndpoint
        );

    //
    // Create all of the cluster objects for which we are responsible.
    //
    status = NmpCreateClusterObjects(SponsorBinding);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    // The local node version might have changed, fix it
    // The sponsorer fixes it in the registry and tells other
    // nodes about it, however the joining node is not a part
    // of the cluster membership as yet.
    // The local node structure is created early on in NmInitialize()
    // hence it must get fixed up
    if ((NmLocalNode->HighestVersion != CsMyHighestVersion) ||
        (NmLocalNode->LowestVersion != CsMyLowestVersion))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Local Node version changed probably due to upgrade/deinstall\n");
        NmLocalNode->HighestVersion = CsMyHighestVersion;
        NmLocalNode->LowestVersion = CsMyLowestVersion;
        NmLocalNodeVersionChanged = TRUE;
    }

    //at this point we ready to calculate the cluster version
    //all the node objects contain the correct node versions
    NmpResetClusterVersion(FALSE);

    NmpMulticastInitialize();

    //
    // Enable communication for the local node.
    //
    status = ClusnetOnlineNodeComm(NmClusnetHandle, NmLocalNodeId);

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", NmLocalNodeId);
        wsprintfW(&(errorString2[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_CLUSNET_ONLINE_COMM_FAILED,
            errorString,
            errorString2
            );

        ClRtlLogPrint(LOG_CRITICAL,
            "[NMJOIN] Unable to enable communication for local node, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Fire up the intracluster RPC server so we can perform the membership
    // join.
    //
    status = ClusterRegisterIntraclusterRpcInterface();

    if ( status != ERROR_SUCCESS ) {
        eventCode = CS_EVENT_RPC_INIT_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "ClusSvc: Error starting intracluster RPC server, Status = %1!u!\n",
            status);
        goto error_exit;
    }

    //
    // Cycle through the list of cluster nodes and create mutual RPC bindings
    // for the intracluster interface with each.
    //
    for (nodeEntry = NmpNodeList.Flink;
         nodeEntry != &NmpNodeList;
         nodeEntry = nodeEntry->Flink
        )
    {
        node = CONTAINING_RECORD(nodeEntry, NM_NODE, Linkage);

        if ( (node != NmLocalNode)
             &&
             ( (node->State == ClusterNodeUp)
               ||
               (node->State == ClusterNodePaused)
             )
           )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] Creating RPC bindings for member node %1!u!\n",
                node->NodeId
                );

            //
            //
            // Cycle through the target node's interfaces
            //
            for (ifEntry = node->InterfaceList.Flink;
                 ifEntry != &(node->InterfaceList);
                 ifEntry = ifEntry->Flink
                )
            {
                netInterface = CONTAINING_RECORD(
                                   ifEntry,
                                   NM_INTERFACE,
                                   NodeLinkage
                                   );

                network = netInterface->Network;

                if (NmpIsNetworkForInternalUse(network)) {
                    if ( (network->LocalInterface != NULL) &&
                         NmpIsInterfaceRegistered(network->LocalInterface) &&
                         NmpIsInterfaceRegistered(netInterface)
                       )
                    {
                        PNM_INTERFACE localInterface = network->LocalInterface;

                        ClRtlLogPrint(LOG_NOISE,
                            "[NMJOIN] Attempting to use network %1!ws! to "
                            "create bindings for node %2!u!\n",
                            OmObjectName(network),
                            node->NodeId
                            );

                        status = NmpSetNodeInterfacePriority(
                                     node,
                                     0xFFFFFFFF,
                                     netInterface,
                                     1
                                     );

                        if (status == ERROR_SUCCESS) {

                            status = NmRpcCreateBinding(
                                         SponsorBinding,
                                         NmpJoinSequence,
                                         NmLocalNodeIdString,
                                         (LPWSTR) OmObjectId(localInterface),
                                         (LPWSTR) OmObjectId(node)
                                         );

                            if (status == ERROR_SUCCESS) {
                                //
                                // Create RPC bindings for the target node.
                                //
                               status = NmpCreateRpcBindings(node);

                                if (status == ERROR_SUCCESS) {
                                    ClRtlLogPrint(LOG_NOISE,
                                        "[NMJOIN] Created binding for node "
                                        "%1!u!\n",
                                        node->NodeId
                                        );
                                    break;
                                }

                                wsprintfW(&(errorString[0]), L"%u", status);
                                CsLogEvent3(
                                    LOG_UNUSUAL,
                                    NM_EVENT_JOIN_BIND_OUT_FAILED,
                                    OmObjectName(node),
                                    OmObjectName(network),
                                    errorString
                                    );
                                ClRtlLogPrint(LOG_UNUSUAL,
                                    "[NMJOIN] Unable to create binding for "
                                    "node %1!u!, status %2!u!.\n",
                                    node->NodeId,
                                    status
                                    );
                            }
                            else {
                                wsprintfW(&(errorString[0]), L"%u", status);
                                CsLogEvent3(
                                    LOG_UNUSUAL,
                                    NM_EVENT_JOIN_BIND_IN_FAILED,
                                    OmObjectName(node),
                                    OmObjectName(network),
                                    errorString
                                    );
                                ClRtlLogPrint(LOG_CRITICAL,
                                    "[NMJOIN] Member node %1!u! failed to "
                                    "create binding to us, status %2!u!\n",
                                    node->NodeId,
                                    status
                                    );
                            }
                        }
                        else {
                            wsprintfW(&(errorString[0]), L"%u", node->NodeId);
                            wsprintfW(&(errorString2[0]), L"%u", status);
                            CsLogEvent2(
                                LOG_UNUSUAL,
                                NM_EVENT_CLUSNET_SET_INTERFACE_PRIO_FAILED,
                                errorString,
                                errorString2
                                );
                            ClRtlLogPrint(LOG_CRITICAL,
                                "[NMJOIN] Failed to set interface priorities "
                                "for node %1!u!, status %2!u!\n",
                                node->NodeId,
                                status
                                );
                        }
                    }
                    else {
                        status = ERROR_CLUSTER_NODE_UNREACHABLE;
                        ClRtlLogPrint(LOG_NOISE,
                            "[NMJOIN] No matching local interface for "
                            "network %1!ws!\n",
                            OmObjectName(netInterface->Network)
                            );
                    }
                }
                else {
                    status = ERROR_CLUSTER_NODE_UNREACHABLE;
                    ClRtlLogPrint(LOG_NOISE,
                        "[NMJOIN] Network %1!ws! is not used for internal "
                        "communication.\n",
                        OmObjectName(netInterface->Network)
                        );
                }
            }

            if (status != ERROR_SUCCESS) {
                //
                // Cannot make contact with this node. The join fails.
                //
                CsLogEvent1(
                    LOG_CRITICAL,
                    NM_EVENT_NODE_UNREACHABLE,
                    OmObjectName(node)
                    );
                ClRtlLogPrint(LOG_NOISE,
                    "[NMJOIN] Cluster node %1!u! is not reachable. Join "
                    "failed.\n",
                    node->NodeId
                    );
                goto error_exit;
            }
        }
    }

    CL_ASSERT(status == ERROR_SUCCESS);

    //
    // run through the active nodes again, this time establishing
    // security contexts to use in signing packets
    //

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Establishing security contexts with all active nodes.\n"
        );

    for (nodeEntry = NmpNodeList.Flink;
         nodeEntry != &NmpNodeList;
         nodeEntry = nodeEntry->Flink
        )
    {
        node = CONTAINING_RECORD(nodeEntry, NM_NODE, Linkage);

        status = ClMsgCreateActiveNodeSecurityContext(NmpJoinSequence, node);

        if ( status != ERROR_SUCCESS ) {
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent2(
                LOG_UNUSUAL,
                NM_EVENT_CREATE_SECURITY_CONTEXT_FAILED,
                OmObjectName(node),
                errorString
                );
            ClRtlLogPrint(LOG_CRITICAL,
                "[NMJOIN] Unable to establish security context for node %1!u!, status 0x%2!08X!\n",
                 node->NodeId,
                 status
                 );
            goto error_exit;
        }
    }

    //
    // Finally, petition the sponsor for membership
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Petitioning to join cluster membership.\n"
        );

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailJoinPetitionForMembership) {
        status = 999999;
        goto error_exit;
    }
#endif

    status = NmRpcPetitionForMembership(
                 SponsorBinding,
                 NmpJoinSequence,
                 NmLocalNodeIdString
                 );

    if (status != ERROR_SUCCESS) {
        //
        // Our petition was denied.
        //
        eventCode = NM_EVENT_PETITION_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NMJOIN] Petition to join was denied %1!d!\n",
            status
            );
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmJoin) {
        status = 999999;
        goto error_exit;
    }
#endif

    //
    // Reset the interface priorities for all nodes to default to
    // the priorities of the associated networks.
    //
    NmpAcquireLock();

    for (ifEntry = NmpInterfaceList.Flink;
         ifEntry != &NmpInterfaceList;
         ifEntry = ifEntry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(ifEntry, NM_INTERFACE, Linkage);
        network = netInterface->Network;

        if ( NmpIsNetworkForInternalUse(network) &&
             NmpIsInterfaceRegistered(netInterface)
           )
        {
            status = ClusnetSetInterfacePriority(
                         NmClusnetHandle,
                         netInterface->Node->NodeId,
                         netInterface->Network->ShortId,
                         0
                         );

            CL_ASSERT(status == ERROR_SUCCESS);
        }
    }

    NmpState = NmStateOnline;

    NmpReleaseLock();

    //
    // Invoke other components to create RPC bindings for each node.
    //

    //
    // Enable our GUM update handler.
    //
    GumReceiveUpdates(
        TRUE,
        GumUpdateMembership,
        NmpGumUpdateHandler,
        NULL,
        sizeof(NmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
        NmGumDispatchTable,
        NULL
        );

    // DavidDio 8/16/2001
    // Bug 456951: There is a race condition in the form path between
    // the network and interface state update and setting the NM state
    // to online. If the state is online but no GUM handler is registered,
    // the update will not be invoked. Hence, use the following flag to
    // indicate that a handler is ready.
    NmpGumUpdateHandlerRegistered = TRUE;

    return(ERROR_SUCCESS);

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    return(status);

} // NmJoinCluster


BOOLEAN
NmpVerifyJoinerConnectivity(
    IN  PNM_NODE    JoiningNode,
    OUT PNM_NODE *  UnreachableNode
    )
{
    PLIST_ENTRY    entry;
    PNM_NODE       node;


    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Verifying connectivity to active cluster nodes\n"
        );

    *UnreachableNode = NULL;

    for (entry = NmpNodeList.Flink;
         entry != &NmpNodeList;
         entry = entry->Flink
        )
    {
        node = CONTAINING_RECORD(
                   entry,
                   NM_NODE,
                   Linkage
                   );

        if (NM_NODE_UP(node)) {
            if (!NmpVerifyNodeConnectivity(JoiningNode, node, NULL)) {
                *UnreachableNode = node;
                return(FALSE);
            }
        }
    }

    return(TRUE);

}  // NmpVerifyJoinerConnectivity


DWORD
NmGetJoinSequence(
    VOID
    )
{
    DWORD  sequence;


    NmpAcquireLock();

    sequence = NmpJoinSequence;

    NmpReleaseLock();

    return(sequence);

}  // NmGetJoinSequence



DWORD
NmJoinComplete(
    OUT DWORD *EndSeq
    )
/*++

Routine Description:

    This routine is called by the initialization sequence once a
    join has successfully completed and the node can transition
    from ClusterNodeJoining to ClusterNodeOnline.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.


--*/

{
    DWORD Sequence;
    DWORD Status;
    PNM_JOIN_UPDATE JoinUpdate = NULL;
    DWORD UpdateLength;
    HDMKEY NodeKey = NULL;
    DWORD Default = 0;
    DWORD NumRetries=50;
    DWORD eventCode = 0;
    WCHAR errorString[12];
    PNM_NETWORK_STATE_ENUM    networkStateEnum = NULL;
    PNM_NETWORK_STATE_INFO    networkStateInfo;
    PNM_INTERFACE_STATE_ENUM  interfaceStateEnum = NULL;
    PNM_INTERFACE_STATE_INFO  interfaceStateInfo;
    DWORD i;
    PNM_NETWORK   network;
    PNM_INTERFACE netInterface;
    PLIST_ENTRY entry;
    DWORD moveCount;


    UpdateLength = sizeof(NM_JOIN_UPDATE) +
                   (lstrlenW(OmObjectId(NmLocalNode))+1)*sizeof(WCHAR);

    JoinUpdate = LocalAlloc(LMEM_FIXED, UpdateLength);

    if (JoinUpdate == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        ClRtlLogPrint(LOG_CRITICAL, "[NMJOIN] Unable to allocate memory.\n");
        goto error_exit;
    }

    JoinUpdate->JoinSequence = NmpJoinSequence;

    lstrcpyW(JoinUpdate->NodeId, OmObjectId(NmLocalNode));

    NodeKey = DmOpenKey(DmNodesKey, OmObjectId(NmLocalNode), KEY_READ);

    if (NodeKey == NULL) {
        Status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", Status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            OmObjectId(NmLocalNode),
            errorString
            );
        ClRtlLogPrint(
            LOG_CRITICAL,
            "[NMJOIN] Unable to open database key to local node, status %1!u!.\n",
            Status
            );
        goto error_exit;
    }

retry:

    Status = GumBeginJoinUpdate(GumUpdateMembership, &Sequence);

    if (Status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_GENERAL_JOIN_ERROR;
        goto error_exit;
    }

    //
    // Get the leader node ID from the sponsor.
    //
    Status = NmRpcGetLeaderNodeId(
                 CsJoinSponsorBinding,
                 NmpJoinSequence,
                 NmLocalNodeIdString,
                 &NmpLeaderNodeId
                 );

    if (Status != ERROR_SUCCESS) {
        if (Status == ERROR_CALL_NOT_IMPLEMENTED) {
            //
            // The sponsor is an NT4 node. Make this node the leader.
            //
            NmpLeaderNodeId = NmLocalNodeId;
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NMJOIN] Failed to get leader node ID from sponsor, status %1!u!.\n",
                Status
                );
            goto error_exit;
        }
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Node %1!u! is the leader.\n",
        NmpLeaderNodeId
        );

    //
    // Fetch the network and interface states from the sponsor
    //
    Status = NmRpcEnumNetworkAndInterfaceStates(
                 CsJoinSponsorBinding,
                 NmpJoinSequence,
                 NmLocalNodeIdString,
                 &networkStateEnum,
                 &interfaceStateEnum
                 );

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NMJOIN] Failed to get network and interface state values from sponsor, status %1!u!.\n",
            Status
            );
        goto error_exit;
    }

    NmpAcquireLock();

    for (i=0; i<networkStateEnum->NetworkCount; i++) {
        networkStateInfo = &(networkStateEnum->NetworkList[i]);

        network = OmReferenceObjectById(
                        ObjectTypeNetwork,
                        networkStateInfo->Id
                        );

        if (network == NULL) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NMJOIN] Cannot find network %1!ws! to update state.\n",
                networkStateInfo->Id
                );
            NmpReleaseLock();
            NmpFreeNetworkStateEnum(networkStateEnum);
            LocalFree(JoinUpdate);
            DmCloseKey(NodeKey);
            return(ERROR_CLUSTER_NETWORK_NOT_FOUND);
        }

        network->State = networkStateInfo->State;

        OmDereferenceObject(network);
    }

    for (i=0; i<interfaceStateEnum->InterfaceCount; i++) {
        interfaceStateInfo = &(interfaceStateEnum->InterfaceList[i]);

        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           interfaceStateInfo->Id
                           );

        if (netInterface == NULL) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NMJOIN] Cannot find interface %1!ws! to update state.\n",
                interfaceStateInfo->Id
                );
            NmpReleaseLock();
            NmpFreeInterfaceStateEnum(interfaceStateEnum);
            LocalFree(JoinUpdate);
            DmCloseKey(NodeKey);
            return(ERROR_CLUSTER_NETINTERFACE_NOT_FOUND);
        }

        netInterface->State = interfaceStateInfo->State;

        OmDereferenceObject(netInterface);
    }

    NmpReleaseLock();

    NmpFreeInterfaceStateEnum(interfaceStateEnum);
    interfaceStateEnum = NULL;


    //
    // Check the registry to see if we should come up paused.
    //
    JoinUpdate->IsPaused = Default;

    Status = DmQueryDword(NodeKey,
                          CLUSREG_NAME_NODE_PAUSED,
                          &JoinUpdate->IsPaused,
                          &Default);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Unable to query Paused value for local node, status %1!u!.\n",
            Status
            );
    }

    Status = GumEndJoinUpdate(Sequence,
                              GumUpdateMembership,
                              NmUpdateJoinComplete,
                              UpdateLength,
                              JoinUpdate);

    if (Status != ERROR_SUCCESS) {
        if (Status == ERROR_CLUSTER_JOIN_ABORTED) {
            //
            // The join was aborted by the cluster members. Don't retry.
            //
            CsLogEvent(LOG_CRITICAL, NM_EVENT_JOIN_ABORTED);
            goto error_exit;
        }

        ClRtlLogPrint(LOG_UNUSUAL,
                   "[NMJOIN] GumEndJoinUpdate with sequence %1!d! failed %2!d!\n",
                   Sequence,
                   Status
                   );

        if (--NumRetries == 0) {
            CsLogEvent(LOG_CRITICAL, NM_EVENT_JOIN_ABANDONED);
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NMJOIN] Tried to complete join too many times. Giving up.\n"
                       );
            goto error_exit;
        }

        goto retry;
    }

    //
    // If the cluster instance ID does not exist, create it now. The cluster
    // instance ID should be in the database unless this is the first uplevel
    // node.
    //
    NmpCreateClusterInstanceId();

    //
    // Derive the cluster key.
    //
    Status = NmpRederiveClusterKey();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to derive cluster key, status %1!u!. "
            "Aborting ...\n",
            Status
            );
        goto error_exit;
    }

    NmpAcquireLock();

    if (JoinUpdate->IsPaused != 0) {
        //
        // We should be coming up paused.
        //
        NmLocalNode->State = ClusterNodePaused;
    } else {
        //
        // Set our state to online.
        //
        NmLocalNode->State = ClusterNodeUp;
    }

    //
    // Start multicast for all networks.
    //
    Status = NmpStartMulticast(NULL, NmStartMulticastJoin);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to refresh multicast configuration "
            "for cluster networks, status %1!u!.\n",
            Status
            );
        //
        // Not a fatal error.
        //
        Status = ERROR_SUCCESS;
    }

    NmpReleaseLock();

    //
    // Finally, enable network PnP event handling.
    //
    // If a PnP event occured during the join process, an error code will
    // be returned, which will abort startup of the service.
    //
    Status = NmpEnablePnpEvents();

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] A network PnP event occurred during join - abort.\n");
        goto error_exit;
    }

    //
    // Mark end sequence
    *EndSeq = Sequence;

    ClRtlLogPrint(LOG_NOISE, "[NMJOIN] Join complete, node now online\n");



error_exit:

    if (JoinUpdate != NULL) {
        LocalFree(JoinUpdate);
    }

    if (NodeKey != NULL) {
        DmCloseKey(NodeKey);
    }

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", Status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    return(Status);

}  // NmJoinComplete


//
// Server-side routines for sponsoring a joining node.
//
/*

Notes On Joining:

    Only a single node may join the cluster at any time. A join begins with
    a JoinBegin global update. A join completes successfully with a
    JoinComplete global update. A join is aborted with a JoinAbort global
    update.

    A timer runs on the sponsor during a join. The timer is suspended
    while the sponsor is performing work on behalf of the joiner. If the
    timer expires, a worker thread is scheduled to initiate the abort
    process.


    If the sponsor goes down while a join is in progress, the node
    down handling code on each remaining node will abort the join.

*/

error_status_t
s_NmRpcJoinBegin(
    IN  handle_t  IDL_handle,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
/*++

Routine Description:

    Called by a joining node to begin the join process.
    Issues a JoinBegin global update.

--*/
{

    DWORD   status=ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Request by node %1!ws! to begin joining, refused. Using obsolete join interface\n",
        JoinerNodeId
        );

    if ( status != ERROR_SUCCESS ) {
        WCHAR  errorCode[16];

        wsprintfW( errorCode, L"%u", status );

        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_JOIN_REFUSED,
            JoinerNodeId,
            errorCode
            );
    }

    return(status);

} // s_NmRpcJoinBegin

//
// Server-side routines for sponsoring a joining node.
//
/*

Notes On Joining:




*/
//#pragma optimize("", off)

DWORD
NmpJoinBegin(
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  DWORD     JoinerHighestVersion,
    IN  DWORD     JoinerLowestVersion,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
/*++

Routine Description:

    Called from s_NmRpcJoinBegin2 and s_NmRpcJoinBegin3.
    Contains functionality common to both JoinBegin versions.

Notes:

    Called with NM lock held and NmpLockedEnterApi already
    called.

--*/
{
    DWORD       status = ERROR_SUCCESS;
    PNM_NODE    joinerNode = NULL;
    LPWSTR      endpoint = NULL;

    joinerNode = OmReferenceObjectById(
                     ObjectTypeNode,
                     JoinerNodeId
                     );

    if (joinerNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Node %1!ws! is not a member of this cluster. Cannot join.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    endpoint = MIDL_user_allocate(NM_WCSLEN(NmpClusnetEndpoint));

    if (endpoint == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    lstrcpyW(endpoint, NmpClusnetEndpoint);

    if (NmpJoinBeginInProgress || NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Node %1!ws! cannot join because a join is already in progress (%2!d!).\n",
            JoinerNodeId,
            NmpJoinerNodeId
            );
        goto FnExit;
    }

    //
    //validate the nodes version's number
    //ie. check to see what the cluster database
    //claims this node's version is vs what the node
    //itself suggests
    status = NmpValidateNodeVersion(
                 JoinerNodeId,
                 JoinerHighestVersion,
                 JoinerLowestVersion
                 );

    //since this node joined, its version has changed
    //this may happen due to upgrades or reinstall
    //if this version cant join due to versioning,fail the join
    if (status == ERROR_REVISION_MISMATCH) {
        DWORD  id = NmGetNodeId(joinerNode);

        status = NmpIsNodeVersionAllowed(
                     id,
                     JoinerHighestVersion,
                     JoinerLowestVersion,
                     TRUE
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] The version of the cluster prevents Node %1!ws! from joining the cluster\n",
                JoinerNodeId
                );
            goto FnExit;
        }
    }
    else if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] The version of Node %1!ws! cannot be validated.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    // Lock out other join attempts with this sponsor.
    //
    NmpJoinBeginInProgress = TRUE;
    NmpSuccessfulMMJoin = FALSE;

    NmpReleaseLock();

    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateJoinBegin2,
                 5,
                 NM_WCSLEN(JoinerNodeId),
                 JoinerNodeId,
                 NM_WCSLEN(JoinerNodeName),
                 JoinerNodeName,
                 NM_WCSLEN(NmLocalNodeIdString),
                 NmLocalNodeIdString,
                 sizeof(DWORD),
                 &JoinerHighestVersion,
                 sizeof(DWORD),
                 &JoinerLowestVersion
                 );

    NmpAcquireLock();

    CL_ASSERT(NmpJoinBeginInProgress == TRUE);
    NmpJoinBeginInProgress = FALSE;

    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] JoinBegin2 update for node %1!ws! failed, status %2!u!\n",
            JoinerNodeId,
            status
            );
        goto FnExit;
    }
    //
    // Verify that the join is still in progress with
    // this node as the sponsor.
    //
    if ( (NmpJoinerNodeId == joinerNode->NodeId) &&
         (NmpSponsorNodeId == NmLocalNodeId)
       )
    {
        //
        // Give the joiner parameters for future
        // join-related calls.
        //
        *SponsorNodeId = NmLocalNodeId;
        *JoinSequenceNumber = NmpJoinSequence;

        //
        // Start the join timer
        //
        NmpJoinTimer = NM_JOIN_TIMEOUT;

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Node %1!ws! has begun the join process.\n",
            JoinerNodeId
            );
    }
    else
    {
        status = ERROR_CLUSTER_JOIN_ABORTED;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Begin join of node %1!ws! was aborted\n",
            JoinerNodeId
            );
    }

FnExit:
    if (joinerNode) {
        OmDereferenceObject(joinerNode);
    }

    if (status == ERROR_SUCCESS) {
        *ClusnetEndpoint = endpoint;
    }
    else {
        WCHAR  errorCode[16];

        if (endpoint) MIDL_user_free(endpoint);

        wsprintfW( errorCode, L"%u", status );

        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_JOIN_REFUSED,
            JoinerNodeId,
            errorCode
            );
    }

    return(status);

} // NmpJoinBegin

error_status_t
s_NmRpcJoinBegin2(
    IN  handle_t  IDL_handle,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  DWORD     JoinerHighestVersion,
    IN  DWORD     JoinerLowestVersion,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
/*++

Routine Description:

    Called by a joining node to begin the join process.
    Issues a JoinBegin global update.

--*/
{
    DWORD       status = ERROR_SUCCESS;

    status = FmDoesQuorumAllowJoin( JoinerNodeId );
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Quorum Characteristics prevent the node %1!ws! to from joining, Status=%2!u!.\n",
            JoinerNodeId,
            status
            );
        return(status);

    }

    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Processing request by node %1!ws! to begin joining (2).\n",
        JoinerNodeId
        );

    if (!NmpLockedEnterApi(NmStateOnline)) {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot sponsor a joining node at this time.\n"
            );
        NmpReleaseLock();
        return(status);
    }

    status = NmpJoinBegin(
                 JoinerNodeId,
                 JoinerNodeName,
                 JoinerHighestVersion,
                 JoinerLowestVersion,
                 SponsorNodeId,
                 JoinSequenceNumber,
                 ClusnetEndpoint
                 );

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return(status);

} // s_NmRpcJoinBegin2

error_status_t
s_NmRpcJoinBegin3(
    IN  handle_t  IDL_handle,
    IN  LPWSTR    JoinerClusterInstanceId,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  DWORD     JoinerHighestVersion,
    IN  DWORD     JoinerLowestVersion,
    IN  DWORD     JoinerMajorVersion,
    IN  DWORD     JoinerMinorVersion,
    IN  LPWSTR    JoinerCsdVersion,
    IN  DWORD     JoinerProductSuite,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
{
    DWORD       status = ERROR_SUCCESS;

    LPWSTR      clusterInstanceId = NULL;
    DWORD       clusterInstanceIdBufSize = 0;
    DWORD       clusterInstanceIdSize = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Processing request by node %1!ws! to begin joining (3).\n",
        JoinerNodeId
        );

    status = FmDoesQuorumAllowJoin( JoinerNodeId );
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Quorum Characteristics prevent node %1!ws! from joining, Status=%2!u!.\n",
            JoinerNodeId,
            status
            );
        return(status);

    }

    //
    // Check our cluster instance ID against the joiner's.
    //
    if (NmpClusterInstanceId == NULL ||
        lstrcmpiW(NmpClusterInstanceId, JoinerClusterInstanceId) != 0) {

        WCHAR  errorCode[16];

        status = ERROR_CLUSTER_INSTANCE_ID_MISMATCH;

        ClRtlLogPrint(LOG_CRITICAL,
            "[NMJOIN] Sponsor cluster instance ID %1!ws! does not match joiner cluster instance id %2!ws!.\n",
            ((NmpClusterInstanceId == NULL) ? L"<NULL>" : NmpClusterInstanceId),
            JoinerClusterInstanceId
            );

        wsprintfW( errorCode, L"%u", status );
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_JOIN_REFUSED,
            JoinerNodeId,
            errorCode
            );

        return(status);

    } else {

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Sponsor cluster instance ID matches joiner cluster instance id (%1!ws!).\n",
            JoinerClusterInstanceId
            );
    }

    NmpAcquireLock();

    if (!NmpLockedEnterApi(NmStateOnline)) {

        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot sponsor a joining node at this time.\n"
            );

    } else {

        status = NmpJoinBegin(
                     JoinerNodeId,
                     JoinerNodeName,
                     JoinerHighestVersion,
                     JoinerLowestVersion,
                     SponsorNodeId,
                     JoinSequenceNumber,
                     ClusnetEndpoint
                     );

        NmpLockedLeaveApi();
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcJoinBegin3

DWORD
NmpUpdateJoinBegin(
    IN  BOOL    SourceNode,
    IN  LPWSTR  JoinerNodeId,
    IN  LPWSTR  JoinerNodeName,
    IN  LPWSTR  SponsorNodeId
    )
{
    DWORD           status=ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Failing update to begin join of node %1!ws! with "
        "sponsor %2!ws!. Using obsolete join interface.\n",
        JoinerNodeId,
        SponsorNodeId
        );

    return(status);

} // NmpUpdateJoinBegin


DWORD
NmpUpdateJoinBegin2(
    IN  BOOL      SourceNode,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  LPWSTR    SponsorNodeId,
    IN  LPDWORD   JoinerHighestVersion,
    IN  LPDWORD   JoinerLowestVersion
    )
{
    DWORD           status = ERROR_SUCCESS;
    PNM_NODE        sponsorNode=NULL;
    PNM_NODE        joinerNode=NULL;
    HLOCALXSACTION  hXsaction=NULL;
    BOOLEAN         lockAcquired = FALSE;
    BOOLEAN         fakeSuccess = FALSE;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Received update to begin join (2) of node %1!ws! with "
        "sponsor %2!ws!.\n",
        JoinerNodeId,
        SponsorNodeId
        );

    //
    // If running with -noquorum flag or if not online, don't sponsor
    // any node.
    //
    if (CsNoQuorum || !NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to begin a join operation.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Find the sponsor node
    //
    sponsorNode = OmReferenceObjectById(
                        ObjectTypeNode,
                        SponsorNodeId
                        );

    if (sponsorNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] JoinBegin update for node %1!ws! failed because "
            "sponsor node %2!ws! is not a member of this cluster.\n",
            JoinerNodeId,
            SponsorNodeId
            );
        goto FnExit;
    }

    //
    // Find the joiner node
    //
    joinerNode = OmReferenceObjectById(
                    ObjectTypeNode,
                    JoinerNodeId
                    );

    if (joinerNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Node %1!ws! is not a member of this cluster. "
            "Cannot join.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    hXsaction = DmBeginLocalUpdate();

    if (hXsaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto FnExit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (!NM_NODE_UP(sponsorNode)) {
        //
        // [GorN 4/3/2000] See bug#98287
        // This hack is a kludgy solution to a problem that
        // a replay of this Gum update after the sponsor death
        // will fail on all the nodes that didn't see the update.
        //
        fakeSuccess = TRUE;
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Sponsor node %1!ws! is not up. Join of node %2!ws! "
            "failed.\n",
            SponsorNodeId,
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    // Check that the joiner is really who we think it is.
    //
    if (lstrcmpiW( OmObjectName(joinerNode), JoinerNodeName)) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Node %1!ws! is not a member of this cluster. "
            "Cannot join.\n",
            JoinerNodeName
            );
        goto FnExit;
    }

    //
    // Make sure the joiner is currently down.
    //
    if (joinerNode->State != ClusterNodeDown) {
        status = ERROR_CLUSTER_NODE_UP;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Node %1!ws! is not down. Cannot begin join.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    // Make sure we aren't already in a join.
    //
    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Node %1!ws! cannot begin join because a join is "
            "already in progress for node %2!u!.\n",
            JoinerNodeId,
            NmpJoinerNodeId
            );
        goto FnExit;
    }

    //
    // Perform the version compatibility check.
    //
    status = NmpIsNodeVersionAllowed(
             NmGetNodeId(joinerNode),
             *JoinerHighestVersion,
             *JoinerLowestVersion,
             TRUE
             );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] The version of the cluster prevents Node %1!ws! "
            "from joining the cluster\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    // Fix up the joiner's version number if needed.
    //

    status = NmpValidateNodeVersion(
                 JoinerNodeId,
                 *JoinerHighestVersion,
                 *JoinerLowestVersion
                 );

    if (status == ERROR_REVISION_MISMATCH) {
        //
        // At this point, the registry contains the new
        // versions for the joining code.
        // The new node information should be reread
        // from the registry before resetting the cluster
        // version
        // make sure the joiner gets the database from the
        //          sponsor after the fixups have occured
        //
        status = NmpJoinFixupNodeVersion(
                     hXsaction,
                     JoinerNodeId,
                     *JoinerHighestVersion,
                     *JoinerLowestVersion
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Node %1!ws! failed to fixup its node version\r\n",
                JoinerNodeId);
            goto FnExit;
        }
    }
    else if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] The verison of Node %1!ws! could not be validated\n",
            JoinerNodeId);
        goto FnExit;
    }

    //
    //at this point we ready to calculate the cluster version
    //all the node versions are in the registry, the fixups have
    //been made if neccessary
    //
    NmpResetClusterVersion(TRUE);

    //
    // Enable communication to the joiner.
    //
    // This must be the last test that can fail before the join is allowed
    // to proceed.
    //
    status = ClusnetOnlineNodeComm(NmClusnetHandle, joinerNode->NodeId);

    if (status != ERROR_SUCCESS) {
        if (status != ERROR_CLUSTER_NODE_ALREADY_UP) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NMJOIN] Failed to enable communication for node %1!u!, "
                "status %2!u!\n",
                JoinerNodeId,
                status
                );
            goto FnExit;
        }
        else {
            status = ERROR_SUCCESS;
        }
    }

    //
    // Officially begin the join process
    //
    CL_ASSERT(NmpJoinTimer == 0);
    CL_ASSERT(NmpJoinAbortPending == FALSE);
    CL_ASSERT(NmpJoinerUp == FALSE);
    CL_ASSERT(NmpSponsorNodeId == ClusterInvalidNodeId);

    NmpJoinerNodeId = joinerNode->NodeId;
    NmpSponsorNodeId = sponsorNode->NodeId;
    NmpJoinerOutOfSynch = FALSE;
    NmpJoinSequence = GumGetCurrentSequence(GumUpdateMembership);

    joinerNode->State = ClusterNodeJoining;

    ClusterEvent(
        CLUSTER_EVENT_NODE_JOIN,
        joinerNode
        );

    NmpCleanupIfJoinAborted = TRUE;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Node %1!ws! join sequence = %2!u!\n",
        JoinerNodeId,
        NmpJoinSequence
        );

    CL_ASSERT(status == ERROR_SUCCESS);

FnExit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (hXsaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(hXsaction);
        }
        else {
            DmAbortLocalUpdate(hXsaction);
        }
    }

    if (joinerNode != NULL) {
        OmDereferenceObject(joinerNode);
    }

    if (sponsorNode != NULL) {
        OmDereferenceObject(sponsorNode);
    }

    if (fakeSuccess) {
        status = ERROR_SUCCESS;
    }
    return(status);

} // NmpUpdateJoinBegin2


DWORD
NmpCreateRpcBindings(
    IN PNM_NODE  Node
    )
{
    DWORD  status;


    //
    // Create the default binding for the whole cluster service
    //
    status = ClMsgCreateDefaultRpcBinding(
                Node, &Node->DefaultRpcBindingGeneration);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    //
    // Create private bindings for the NM's use.
    // We create one for reporting network connectivity and one for
    // performing network failure isolation. The NM uses the
    // default binding for operations on behalf of joining nodes.
    //
    if (Node->ReportRpcBinding != NULL) {
        //
        // Reuse the old binding.
        //
        status = ClMsgVerifyRpcBinding(Node->ReportRpcBinding);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to verify RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }
    else {
        //
        // Create a new binding
        //
        status = ClMsgCreateRpcBinding(
                                Node,
                                &(Node->ReportRpcBinding),
                                0 );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to create RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }

    if (Node->IsolateRpcBinding != NULL) {
        //
        // Reuse the old binding.
        //
        status = ClMsgVerifyRpcBinding(Node->IsolateRpcBinding);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to verify RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }
    else {
        //
        // Create a new binding
        //
        status = ClMsgCreateRpcBinding(
                                Node,
                                &(Node->IsolateRpcBinding),
                                0 );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to create RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }

    //
    // Call other components to create their private bindings
    //
    status = GumCreateRpcBindings(Node);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = EvCreateRpcBindings(Node);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = FmCreateRpcBindings(Node);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    return(ERROR_SUCCESS);

} // NmpCreateRpcBindings


error_status_t
s_NmRpcCreateBinding(
    IN handle_t  IDL_handle,
    IN DWORD     JoinSequence,
    IN LPWSTR    JoinerNodeId,
    IN LPWSTR    JoinerInterfaceId,
    IN LPWSTR    MemberNodeId
    )
{
    DWORD  status;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Processing CreateBinding request from joining node %1!ws! for member node %2!ws!\n",
        JoinerNodeId,
        MemberNodeId
        );

    if (NmpLockedEnterApi(NmStateOnlinePending)) {

        PNM_NODE joinerNode = OmReferenceObjectById(
                                  ObjectTypeNode,
                                  JoinerNodeId
                                  );

        if (joinerNode != NULL) {
            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (NmpSponsorNodeId == NmLocalNodeId) &&
                 !NmpJoinAbortPending
               )
            {
                PNM_NODE memberNode;


                CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                CL_ASSERT(NmpJoinerUp == FALSE);
                CL_ASSERT(NmpJoinTimer != 0);

                //
                // Suspend the join timer while we are working on
                // behalf of the joiner. This precludes an abort
                // from occuring as well.
                //
                NmpJoinTimer = 0;

                memberNode = OmReferenceObjectById(
                                 ObjectTypeNode,
                                 MemberNodeId
                                 );

                if (memberNode != NULL) {
                    PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                                      ObjectTypeNetInterface,
                                                      JoinerInterfaceId
                                                      );

                    if (netInterface != NULL) {
                        if (memberNode == NmLocalNode) {
                            status = NmpCreateJoinerRpcBindings(
                                         joinerNode,
                                         netInterface
                                         );
                        }
                        else {
                            if (NM_NODE_UP(memberNode)) {
                                DWORD  joinSequence = NmpJoinSequence;
                                RPC_BINDING_HANDLE binding =
                                                   Session[memberNode->NodeId];

                                CL_ASSERT(binding != NULL);

                                NmpReleaseLock();

                                NmStartRpc(memberNode->NodeId);
                                status = NmRpcCreateJoinerBinding(
                                             binding,
                                             joinSequence,
                                             JoinerNodeId,
                                             JoinerInterfaceId
                                             );
                                NmEndRpc(memberNode->NodeId);
                                if(status != RPC_S_OK) {
                                    NmDumpRpcExtErrorInfo(status);
                                }

                                NmpAcquireLock();

                            }
                            else {
                                status = ERROR_CLUSTER_NODE_DOWN;
                                ClRtlLogPrint(LOG_UNUSUAL,
                                    "[NMJOIN] CreateBinding call for joining node %1!ws! failed because member node %2!ws! is down.\n",
                                    JoinerNodeId,
                                    MemberNodeId
                                    );
                            }
                        }

                        OmDereferenceObject(netInterface);
                    }
                    else {
                        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[NMJOIN] Can't create binding for joining node %1!ws! - interface %2!ws! doesn't exist.\n",
                            JoinerNodeId,
                            JoinerInterfaceId
                            );
                    }

                    OmDereferenceObject(memberNode);
                }
                else {
                    status = ERROR_CLUSTER_NODE_NOT_FOUND;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] CreateBinding call for joining node %1!ws! failed because member node %2!ws! does not exist\n",
                        JoinerNodeId,
                        MemberNodeId
                        );
                }

                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the join was aborted.\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process the request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcCreateBinding


error_status_t
s_NmRpcCreateJoinerBinding(
    IN handle_t  IDL_handle,
    IN DWORD     JoinSequence,
    IN LPWSTR    JoinerNodeId,
    IN LPWSTR    JoinerInterfaceId
    )
/*++

Notes:

   The sponsor is responsible for aborting the join on failure.

--*/
{
    DWORD   status;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Processing CreateBinding request for joining node %1!ws!.\n",
        JoinerNodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = OmReferenceObjectById(
                                  ObjectTypeNode,
                                  JoinerNodeId
                                  );

        if (joinerNode != NULL) {
            PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                              ObjectTypeNetInterface,
                                              JoinerInterfaceId
                                              );

            if (netInterface != NULL) {
                //
                // Verify that a join is still in progress.
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    status = NmpCreateJoinerRpcBindings(
                                 joinerNode,
                                 netInterface
                                 );

                    if (status != ERROR_SUCCESS) {
                        WCHAR errorString[12];

                        wsprintfW(&(errorString[0]), L"%u", status);
                        CsLogEvent3(
                            LOG_UNUSUAL,
                            NM_EVENT_JOINER_BIND_FAILED,
                            OmObjectName(joinerNode),
                            OmObjectName(netInterface->Network),
                            errorString
                            );
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Failing create bindings for joining node %1!ws! because the join was aborted\n",
                        JoinerNodeId
                        );
                }

                OmDereferenceObject(netInterface);
            }
            else {
                status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NMJOIN] Can't create binding for joining node %1!ws! - no corresponding interface for joiner interface %2!ws!.\n",
                    JoinerNodeId,
                    JoinerInterfaceId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process the request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcCreateJoinerBinding


DWORD
NmpCreateJoinerRpcBindings(
    IN PNM_NODE       JoinerNode,
    IN PNM_INTERFACE  JoinerInterface
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD          status;
    PNM_NETWORK    network = JoinerInterface->Network;
    CL_NODE_ID     joinerNodeId = JoinerNode->NodeId;


    CL_ASSERT(JoinerNode->NodeId == NmpJoinerNodeId);
    CL_ASSERT(JoinerNode->State == ClusterNodeJoining);

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Creating bindings for joining node %1!u! using network %2!ws!\n",
        joinerNodeId,
        OmObjectName(JoinerInterface->Network)
        );

    //
    // Make sure that this node has an interface on the target network.
    //

    if (NmpIsNetworkForInternalUse(network)) {
        if (network->LocalInterface != NULL) {
            if ( NmpIsInterfaceRegistered(JoinerInterface) &&
                 NmpIsInterfaceRegistered(network->LocalInterface)

               )
            {
                status = NmpSetNodeInterfacePriority(
                             JoinerNode,
                             0xFFFFFFFF,
                             JoinerInterface,
                             1
                             );

                if (status == ERROR_SUCCESS) {
                    PNM_INTERFACE  localInterface = network->LocalInterface;

                    //
                    // Create intracluster RPC bindings for the petitioner.
                    // The MM relies on these to perform the join.
                    //

                    OmReferenceObject(localInterface);
                    OmReferenceObject(JoinerNode);

                    NmpReleaseLock();

                    status = NmpCreateRpcBindings(JoinerNode);

                    NmpAcquireLock();

                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NMJOIN] Unable to create RPC binding for "
                            "joining node %1!u!, status %2!u!.\n",
                            joinerNodeId,
                            status
                            );
                    }

                    OmDereferenceObject(JoinerNode);
                    OmDereferenceObject(localInterface);
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NMJOIN] Failed to set interface priority for "
                        "network %1!ws! (%2!ws!), status %3!u!\n",
                        OmObjectId(network),
                        OmObjectName(network),
                        status
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_UNREACHABLE;
            }
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        }
    }
    else {
        status = ERROR_CLUSTER_NODE_UNREACHABLE;
    }

    if (status !=ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NMJOIN] Failed to create binding for joining node %1!u! "
            "on network %2!ws! (%3!ws!), status %4!u!\n",
            joinerNodeId,
            OmObjectId(network),
            OmObjectName(network),
            status
            );
    }

    return(status);

} // NmpCreateJoinerRpcBinding



error_status_t
s_NmRpcPetitionForMembership(
    IN handle_t  IDL_handle,
    IN DWORD     JoinSequence,
    IN LPCWSTR   JoinerNodeId
    )
/*++

Routine Description:

    Server side of a join petition.

Arguments:

    IDL_handle - RPC binding handle, not used.

    JoinSequence - Supplies the sequence returned from NmRpcJoinBegin

    JoinerNodeId - Supplies the ID of the node attempting to join.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD     status;
    PNM_NODE  joinerNode;


#ifdef CLUSTER_TESTPOINT
    TESTPT(TestpointJoinFailPetition) {
        return(999999);
    }
#endif

    NmpAcquireLock();

    ClRtlLogPrint(LOG_UNUSUAL,
        "[NMJOIN] Processing petition to join from node %1!ws!.\n",
        JoinerNodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {

        joinerNode = OmReferenceObjectById(ObjectTypeNode, JoinerNodeId);

        if (joinerNode != NULL) {
            //
            // Verify that the join is still in progress
            //
            //
            // DavidDio 6/13/2000
            // There is a small window where a begin join update can
            // succeed during a regroup, but the regroup ends before
            // the joining node petitions to join. In this case, the
            // node will be marked out of sync. Aborting the join
            // after MMJoin() is much more heavyweight than before,
            // so check for this condition now. (Bug 125778).
            //
            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (NmpSponsorNodeId == NmLocalNodeId) &&
                 (!NmpJoinAbortPending) &&
                 (!NmpJoinerOutOfSynch)
               )
            {
                ClRtlLogPrint(LOG_UNUSUAL, "[NMJOIN] Performing join.\n");

                CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                CL_ASSERT(NmpJoinerUp == FALSE);
                CL_ASSERT(NmpJoinTimer != 0);

                //
                // Call the MM to join this node to the cluster membership.
                // Disable the join timer. Once the node becomes an active
                // member, we won't need it anymore.
                //
                NmpJoinTimer = 0;

                NmpReleaseLock();

                status = MMJoin(
                             joinerNode->NodeId,
                             NM_CLOCK_PERIOD,
                             NM_SEND_HB_RATE,
                             NM_RECV_HB_RATE,
                             NM_MM_JOIN_TIMEOUT
                             );

                NmpAcquireLock();

                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    // GorN 3/22/2000
                    // We hit a case when MMJoin has succeeded after a regroup
                    // that killed one of the nodes (not joiner and not sponsor)
                    // thus leaving the joiner out of sync
                    // We need to abourt the join in this case too

                    if (status != MM_OK || NmpJoinerOutOfSynch) {
                        status = MMMapStatusToDosError(status);

                        if (NmpJoinerOutOfSynch) {
                            status = ERROR_CLUSTER_JOIN_ABORTED;
                        }

                        //
                        // Abort the join
                        //
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NMJOIN] Petition to join by node %1!ws! failed, status %2!u!.\n",
                            JoinerNodeId,
                            status
                            );
                        //
                        // If MMJoin was unsuccessful it initiates a banishing
                        // regroup. This regroup will deliver node down events
                        // on all nodes that saw hb's from the joiner.
                        //
                        // Calling MMBlockIfRegroupIsInProgress here will guarantee that
                        // Phase2 cleanup is complete on all nodes, before we
                        // call NmpJoinAbort.
                        //
                        NmpReleaseLock();
                        MMBlockIfRegroupIsInProgress();
                        NmpAcquireLock();

                        NmpJoinAbort(status, joinerNode);
                    }
                    else {
                        NmpSuccessfulMMJoin = TRUE;
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NMJOIN] Petition to join by node %1!ws! succeeded.\n",
                            JoinerNodeId
                            );
                    }

#ifdef MM_IN_CLUSNET

                    if (status == MM_OK) {

                        status = NmJoinNodeToCluster(joinerNodeId);

                        if (status != ERROR_SUCCESS) {

                            DWORD clusnetStatus;

                            ClRtlLogPrint(LOG_UNUSUAL,
                                "[NMJOIN] Join of node %1!ws! failed, status %2!u!.\n",
                                JoinerNodeId,
                                status
                                );

                            CL_LOGFAILURE( status );

                            NmpReleaseLock();

                            MMEject(joinerNodeId);

                            NmpAcquireLock();

                            clusnetStatus = ClusnetOfflineNodeComm(
                                                NmClusnetHandle,
                                                joinerNodeId
                                                );
                            CL_ASSERT(
                                (status == ERROR_SUCCESS) ||
                                (status == ERROR_CLUSTER_NODE_ALREADY_DOWN
                                );
                        }
                        else {
                            ClRtlLogPrint(LOG_UNUSUAL,
                                "[NMJOIN] Join completed successfully.\n"
                                );
                        }
                    }

#endif // MM_IN_CLUSNET

                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Petition to join by node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Petition by node %1!ws! failed because the join was aborted\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Petition to join by %1!ws! failed because the node is not a cluster member\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process the request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcPetitionForMembership


error_status_t
s_NmRpcGetLeaderNodeId(
    IN  handle_t                    IDL_handle,
    IN  DWORD                       JoinSequence,   OPTIONAL
    IN  LPWSTR                      JoinerNodeId,   OPTIONAL
    OUT LPDWORD                     LeaderNodeId
    )
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NODE       joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        joinerNode = OmReferenceObjectById(
                         ObjectTypeNode,
                         JoinerNodeId
                         );

        if (joinerNode != NULL) {
            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (NmpSponsorNodeId == NmLocalNodeId) &&
                 !NmpJoinAbortPending
               )
            {
                CL_ASSERT(joinerNode->State == ClusterNodeJoining);

                *LeaderNodeId = NmpLeaderNodeId;
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] GetLeaderNodeId call for joining node %1!ws! failed because the join was aborted.\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] GetLeaderNodeId call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process GetLeaderNodeId request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcGetLeaderNodeId


DWORD
NmpUpdateJoinComplete(
    IN PNM_JOIN_UPDATE  JoinUpdate
    )
{
    DWORD  status;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Processing JoinComplete update from node %1!ws!\n",
        JoinUpdate->NodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  joinerNode;
        LPWSTR    joinerIdString = JoinUpdate->NodeId;


        joinerNode = OmReferenceObjectById(ObjectTypeNode, joinerIdString);

        if (joinerNode != NULL) {

            CL_ASSERT(joinerNode != NmLocalNode);

            //
            // Verify that the join is still in progress and nothing has
            // changed.
            //
            if ( (JoinUpdate->JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (joinerNode->State == ClusterNodeJoining) &&
                 NmpJoinerUp &&
                 !NmpJoinerOutOfSynch
               )
            {
                PNM_INTERFACE  netInterface;
                PNM_NETWORK    network;
                PLIST_ENTRY    ifEntry;


                NmpJoinerNodeId = ClusterInvalidNodeId;
                NmpSponsorNodeId = ClusterInvalidNodeId;
                NmpJoinTimer = 0;
                NmpJoinAbortPending = FALSE;
                NmpJoinSequence = 0;
                NmpJoinerUp = FALSE;

                if (JoinUpdate->IsPaused != 0) {
                    //
                    // This node is coming up in the paused state.
                    //
                    joinerNode->State = ClusterNodePaused;
                } else {
                    joinerNode->State = ClusterNodeUp;
                }

                joinerNode->ExtendedState = ClusterNodeJoining;

                ClusterEvent(CLUSTER_EVENT_NODE_UP, (PVOID)joinerNode);

                //
                // Reset the interface priorities for this node.
                //
                for (ifEntry = joinerNode->InterfaceList.Flink;
                     ifEntry != &joinerNode->InterfaceList;
                     ifEntry = ifEntry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       ifEntry,
                                       NM_INTERFACE,
                                       NodeLinkage
                                       );

                    network = netInterface->Network;

                    if ( NmpIsNetworkForInternalUse(network) &&
                         NmpIsInterfaceRegistered(netInterface)
                       )
                    {
                        status = ClusnetSetInterfacePriority(
                                     NmClusnetHandle,
                                     joinerNode->NodeId,
                                     network->ShortId,
                                     0
                                     );

                        CL_ASSERT(status == ERROR_SUCCESS);
                    }
                }

                status = ERROR_SUCCESS;
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Join of node %1!ws! cannot complete because the join was aborted\n",
                    joinerIdString
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status =ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Join of node %1!ws! cannot complete because the node is not a cluster member.\n",
                joinerIdString
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Not in valid state to process JoinComplete update.\n"
            );
    }

    NmpReleaseLock();

    // DavidDio 10/27/2000
    // Bug 213781: NmpUpdateJoinComplete must always return ERROR_SUCCESS.
    // Otherwise, there is a small window whereby GUM sequence numbers on
    // remaining cluster nodes can fall out of sync. If the join should
    // be aborted, return ERROR_SUCCESS but poison the joiner out-of-band.
    if (status != ERROR_SUCCESS) {
        DWORD dwJoinerId;

        if (JoinUpdate->NodeId != NULL) {
            dwJoinerId = wcstoul(JoinUpdate->NodeId, NULL, 10);
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Join of node %1!u! failed with status %2!u!. Initiating banishment.\n",
                dwJoinerId,
                status
                );
            NmAdviseNodeFailure(dwJoinerId, status);
        } else {
            dwJoinerId = ClusterInvalidNodeId;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Join of node %1!ws! failed with status %2!u!. Cannot initiate banishment as node id is unknown.\n",
                dwJoinerId,
                status
                );
        }
    }

    return(ERROR_SUCCESS);

} // NmpUpdateJoinComplete


DWORD
NmpUpdateJoinAbort(
    IN  BOOL    SourceNode,
    IN  LPDWORD JoinSequence,
    IN  LPWSTR  JoinerNodeId
    )
/*++

Notes:


--*/
{
    DWORD   status = ERROR_SUCCESS;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Received update to abort join sequence %1!u! (joiner id %2!ws!).\n",
        *JoinSequence,
        JoinerNodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  joinerNode = OmReferenceObjectById(
                                   ObjectTypeNode,
                                   JoinerNodeId
                                   );

        if (joinerNode != NULL) {
            //
            // Check if the specified join is still in progress.
            //
            if ( (*JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId)
               )
            {
                CL_ASSERT(NmpSponsorNodeId != ClusterInvalidNodeId);
                CL_ASSERT(joinerNode->State == ClusterNodeJoining);

                //
                // Assumption:
                //
                // An abort cannot occur during the MM join process.
                // If the joiner is not already up, it cannot come up
                // during the abort processing.
                //
                // Assert condition may not be true with the current MM join code.
                // Some nodes might have got monitor node and set
                // NmpJoinerUp state to TRUE by the time the sponsor issued
                // an abort update
                //
                //CL_ASSERT(NmpJoinerUp == FALSE);

                if (NmpCleanupIfJoinAborted) {

                    NmpCleanupIfJoinAborted = FALSE;

                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Issuing a node down event for %1!u!.\n",
                        joinerNode->NodeId
                        );

                    //
                    // This node is not yet active in the membership.
                    // Call the node down event handler to finish the abort.
                    //

                    //
                    // We will not call NmpMsgCleanup1 and NmpMsgCleanup2,
                    // because we cannot guarantee that they will get executed
                    // in a barrier style fashion
                    //
                    // !!! Lock will be acquired by NmpNodeDownEventHandler
                    // second time. Is it OK?
                    //
                    NmpNodeDownEventHandler(joinerNode);
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Node down was already issued for %1!u!.\n",
                        joinerNode->NodeId
                        );
                }
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Ignoring old join abort update with sequence %1!u!.\n",
                    *JoinSequence
                    );
            }

            OmDereferenceObject(joinerNode);
            status = ERROR_SUCCESS;
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Join of node %1!ws! cannot be aborted because the node is not a cluster member.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Not in valid state to process JoinAbort update.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmpUpdateJoinAbort


VOID
NmpJoinAbort(
    DWORD      AbortStatus,
    PNM_NODE   JoinerNode
    )
/*++

Routine Description:

    Issues a JoinAbort update.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD    status;
    DWORD    joinSequence = NmpJoinSequence;
    WCHAR    errorString[12];

    // GorN 10/31/2001 #488486
    //   By the time we get to the NmpJoinAbort code
    //   we can have a node down event processed
    //   that clears up NmpJoinerNodeId.
    //   In this case just log the message and bail out

    //    CL_ASSERT(NmpJoinerNodeId != ClusterInvalidNodeId);
    //    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
    //    CL_ASSERT(JoinerNode->State == ClusterNodeJoining);

    if (AbortStatus == ERROR_TIMEOUT) {
        wsprintfW(&(errorString[0]), L"%u", AbortStatus);
        CsLogEvent1(
            LOG_CRITICAL,
            NM_EVENT_JOIN_TIMED_OUT,
            OmObjectName(JoinerNode)
            );
    }
    else {
        wsprintfW(&(errorString[0]), L"%u", AbortStatus);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_SPONSOR_JOIN_ABORTED,
            OmObjectName(JoinerNode),
            errorString
            );
    }

    //
    // Assumption:
    //
    // An abort cannot occur during the MM join process. If the joiner
    // is not already up, it cannot come up during the abort processing.
    //
    if (NmpSuccessfulMMJoin == FALSE) {
        //
        // The joining node has not become active yet. Issue
        // an abort update.
        //
        joinSequence = NmpJoinSequence;


        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Issuing update to abort join of node %1!u!.\n",
            NmpJoinerNodeId
            );

        NmpReleaseLock();

        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateJoinAbort,
                     2,
                     sizeof(DWORD),
                     &joinSequence,
                     NM_WCSLEN(OmObjectId(JoinerNode)),
                     OmObjectId(JoinerNode)
                     );

        NmpAcquireLock();
    }
    else {
        //
        // The joining node is already active in the membership.
        // Ask the MM to kick it out. The node down event will
        // finish the abort process.
        //
        CL_NODE_ID joinerNodeId = NmpJoinerNodeId;

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Ejecting joining node %1!u! from the cluster membership.\n",
            NmpJoinerNodeId
            );

        NmpReleaseLock();

        status = MMEject(joinerNodeId);

        NmpAcquireLock();
    }

    if (status != MM_OK) {
        status = MMMapStatusToDosError(status);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Update to abort join of node %1!u! failed, status %2!u!\n",
            JoinerNode->NodeId,
            status
            );

        //
        // If the join is still pending, and this is the sponsor node,
        // force a timeout to retry the abort. If we aren't the sponsor,
        // there isn't much we can do.
        //
        if ( (joinSequence == NmpJoinSequence) &&
             (NmpJoinerNodeId == JoinerNode->NodeId) &&
             (NmpSponsorNodeId == NmLocalNodeId)
           )
        {
            NmpJoinTimer = 1;
            NmpJoinAbortPending = FALSE;
        }
    }

    return;

}  // NmpJoinAbort


VOID
NmpJoinAbortWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker thread for aborting a join.

--*/
{
    DWORD joinSequence = PtrToUlong(WorkItem->Context);


    NmpAcquireLock();

    //
    // The active thread count was bumped up when this item was scheduled.
    // No need to call NmpEnterApi().
    //

    //
    // If the join is still pending, begin the abort process.
    //
    if ( (joinSequence == NmpJoinSequence) &&
         (NmpJoinerNodeId != ClusterInvalidNodeId) &&
         NmpJoinAbortPending
       )
    {
        PNM_NODE  joinerNode = NmpIdArray[NmpJoinerNodeId];

        if (joinerNode != NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] Worker thread initiating abort of joining node %1!u!\n",
                NmpJoinerNodeId
                );

            NmpJoinAbort(ERROR_TIMEOUT, joinerNode);
        }
        else {
            CL_ASSERT(joinerNode != NULL);
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Skipping join abort, sequence to abort %1!u!, current join sequence %2!u!, "
            "joiner node: %3!u! sponsor node: %4!u!\n",
            joinSequence,
            NmpJoinSequence,
            NmpJoinerNodeId,
            NmpSponsorNodeId
            );
    }

    NmpLockedLeaveApi();

    NmpReleaseLock();

    LocalFree(WorkItem);

    return;

}  // NmpJoinAbortWorker


VOID
NmpJoinTimerTick(
    IN DWORD  MsTickInterval
    )
/*++

Notes:
    Called with NmpLock held.

--*/
{
    if (NmpLockedEnterApi(NmStateOnline)) {
        //
        // If we are sponsoring a join, update the timer.
        //
        if ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
             (NmpSponsorNodeId == NmLocalNodeId) &&
             !NmpJoinAbortPending &&
             (NmpJoinTimer != 0)
           )
        {
            //ClRtlLogPrint(LOG_NOISE,
            //   "[NMJOIN] Timer tick (%1!u! ms)\n",
            //    Interval
            //    );

            if (NmpJoinTimer > MsTickInterval) {
                NmpJoinTimer -= MsTickInterval;
            }
            else {
                //
                // The join has timed out. Schedule a worker thread to
                // carry out the abort process.
                //
                PCLRTL_WORK_ITEM workItem;

                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Join of node %1!u! has timed out.\n",
                    NmpJoinerNodeId
                    );

                workItem = LocalAlloc(LMEM_FIXED, sizeof(CLRTL_WORK_ITEM));

                if (workItem != NULL) {
                    DWORD  status;

                    ClRtlInitializeWorkItem(
                        workItem,
                        NmpJoinAbortWorker,
                        ULongToPtr(NmpJoinSequence)
                        );

                    status = ClRtlPostItemWorkQueue(
                                 CsDelayedWorkQueue,
                                 workItem,
                                 0,
                                 0
                                 );

                    if (status == ERROR_SUCCESS) {
                        //
                        // Stop the timer, flag that an abort is in progress,
                        // and account for the thread we just scheduled.
                        //
                        NmpJoinTimer = 0;
                        NmpJoinAbortPending = TRUE;
                        NmpActiveThreadCount++;
                    }
                    else {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NMJOIN] Failed to schedule abort of join, status %1!u!.\n",
                            status
                            );
                        LocalFree(workItem);
                    }
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Failed to allocate memory for join abort.\n"
                        );
                }
            }
        }
        NmpLockedLeaveApi();
    }

    return;

}  // NmpJoinTimerTick

DWORD
NmpNetworkTimerThread(
    PVOID     Parameter
    )
/*++

Routine Description:

    Forked as the cluster is initializing, calls NmTimerTick to
    drive the NM timers. 

    Separated from the MM timer thread for bug 742997. Code is
    modeled after MM timer, except that we assume that the tick
    interval cannot change.

Arguments:

    Parameter - points to event that is signaled when thread
                should stop

Return value:

    SUCCESS

--*/
{
    HANDLE  stopEvent = (HANDLE) Parameter;
    DWORD   status;

    do {

        // Wait on the stop event. If the stop event is
        // signalled, clussvc is exiting and we break out
        // of the loop. Otherwise, the timeout will fire 
        // and we drive the NM timers.
        status = WaitForSingleObject(
                     stopEvent,
                     RGP_CLOCK_PERIOD
                     );
        if (status == WAIT_TIMEOUT) {
            NmTimerTick(RGP_CLOCK_PERIOD);
        }
    } while (status == WAIT_TIMEOUT);

    if (status != WAIT_OBJECT_0) {
        DWORD error = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] NM timer thread exiting with "
            "status %1!u!, last error %2!u!. Removing "
            "self from cluster.\n",
            status, error
            );
        // We cannot continue without the NM timer.
        CsInconsistencyHalt(status);
        
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] NM timer thread exiting.\n"
            );
    }

    return(status);
        
} // NmpNetworkTimerThread

DWORD
NmpStartNetworkTimerThread(
    VOID
    )
/*++

Routine Description:

    Starts the NM timer thread.

Arguments:

    None.

Return value:

    Status of event and thread creation.

--*/
{
    DWORD status;
    DWORD threadID = 0;
    
    NmpNetworkTimerThreadHandle = NULL;
    NmpNetworkTimerThreadStopEvent = NULL;
    
    NmpNetworkTimerThreadStopEvent = CreateEvent(
                                         NULL,  // No security
                                         FALSE, // Not autoreset
                                         FALSE, // Not initially signalled
                                         NULL   // No name
                                         );
    if (NmpNetworkTimerThreadStopEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create NM timer thread stop event, "
            "error %1!u!.\n",
            status
            );
        goto error_exit;
    }

    NmpNetworkTimerThreadHandle = 
        CreateThread(
            0,                // security
            0,                // stack size - use same as primary thread 
            (LPTHREAD_START_ROUTINE) NmpNetworkTimerThread, 
            (PVOID) NmpNetworkTimerThreadStopEvent, // stop event is parameter
            CREATE_SUSPENDED, // start it after setting prio
            &threadID         // thread ID returned here
            );
    if (NmpNetworkTimerThreadHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create NM timer thread, "
            "error %1!u!.\n",
            status
            );
        goto error_exit;
    }

    // Set the priority, just as done to the MM timer thread
    if (!SetThreadPriority(
             NmpNetworkTimerThreadHandle, 
             NM_TIMER_THREAD_PRIORITY
             )) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to set NM timer thread priority to %1!u!, "
            "error %2!u!.\n",
            NM_TIMER_THREAD_PRIORITY, status
            );
        goto error_exit;        
    }

    // Start the thread.
    if (ResumeThread(NmpNetworkTimerThreadHandle) == -1) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to resume NM timer thread, "
            "error %1!u!.\n",
            status
            );
        goto error_exit;        
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Started NM timer thread, thread id 0x%1!x!.\n",
        threadID
        );

    return(ERROR_SUCCESS);

error_exit:

    if (NmpNetworkTimerThreadStopEvent != NULL) {
        CloseHandle(NmpNetworkTimerThreadStopEvent);
        NmpNetworkTimerThreadStopEvent = NULL;
    }

    if (NmpNetworkTimerThreadHandle != NULL) {
        CloseHandle(NmpNetworkTimerThreadHandle);
        NmpNetworkTimerThreadHandle = NULL;
    }

    return(status);
    
} // NmpStartNetworkTimerThread

VOID
NmpStopNetworkTimerThread(
    VOID
    )
/*++

Routine Description:

    Stops the NM timer thread by signaling the stop event. 
    Waits maximum of 60 seconds before giving up and letting
    process cleanup sort out the mess (this is okay because
    the NM timer thread is stopped only when the clussvc process
    is exiting).

Arguments:

    None.

Return value:

    None.

--*/
{
    DWORD status;
    
    if (NmpNetworkTimerThreadStopEvent != NULL &&
        NmpNetworkTimerThreadHandle != NULL) {

        // Signal the thread to stop.
        SetEvent(NmpNetworkTimerThreadStopEvent);

        // Wait for the thread to exit.
        status = WaitForSingleObject(NmpNetworkTimerThreadHandle, 60 * 1000);
        if (status != WAIT_OBJECT_0) {
            DWORD error = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] NM network timer thread could not be gracefully "
                "stopped, status %1!u!, last error %2!u!.\n",
                status, error
                );
        }

        CloseHandle(NmpNetworkTimerThreadStopEvent);
        CloseHandle(NmpNetworkTimerThreadHandle);
    }

    NmpNetworkTimerThreadStopEvent = NULL;
    NmpNetworkTimerThreadHandle = NULL;

    return;
    
} // NmpStopNetworkTimerThread

VOID
NmTimerTick(
    IN DWORD  MsTickInterval
    )
/*++

Routine Description:

    Implements all of the NM timers. Called on every tick of
    the common NM/MM timer - currently every 300ms.

Arguments:

    MsTickInterval - The number of milliseconds that have passed
                     since the last tick.

ReturnValue:

    None.

--*/
{
    NmpAcquireLock();

    NmpNetworkTimerTick(MsTickInterval);

    NmpJoinTimerTick(MsTickInterval);

#if DBG

    // Addition for checking for hung RPC threads.
    NmpRpcTimerTick(MsTickInterval);

#endif // DBG

    NmpReleaseLock();

    return;

} // NmTimerTick

error_status_t
s_JoinAddNode4(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszNodeName,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion,
    IN DWORD    dwNodeProductSuite,
    IN BOOL     IsNodeRunningWin64,
    IN DWORD    dwNodeProcessorArchitecture
    )
/*++

Routine Description:

    Adds a new node to the cluster.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

    dwNodeHighestVersion - The highest cluster version number that the
                           new node can support.

    dwNodeLowestVersion - The lowest cluster version number that the
                          new node can support.

    dwNodeProductSuite - The product suite type identifier for the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This is a new routine in Whistler.  It will be invoked only by
    Whistler Setup.

    The cluster registry APIs cannot be called while holding the NmpLock,
    or a deadlock may occur.

--*/
{
    DWORD       status;
    DWORD       registryNodeLimit;
    SYSTEM_INFO SystemInfo;


    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Received request to add node '%1!ws!' to the cluster.\n",
        lpszNodeName
        );

    //
    // Read the necessary registry parameters before acquiring
    // the NM lock.
    //
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_MAX_NODES,
                 &registryNodeLimit,
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        registryNodeLimit = 0;
    }

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        DWORD retryCount = 0;

        //if this is the last node and it has been evicted
        //but the cleanup hasnt completed and hence the
        //service is up, then it should not entertain
        //any new join requests
        if (NmpLastNodeEvicted)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] This node was evicted and hence is not in a valid state to process a "
                "request to add a node to the cluster.\n"
                );
            status = ERROR_NODE_NOT_AVAILABLE;
            NmpLockedLeaveApi();
            goto FnExit;
        }

#if 0
        status = ClRtlCheck64BitCompatibility(ClRtlIsProcessRunningOnWin64(GetCurrentProcess),
                        IsNodeRunningWin64);
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] This joining node doesnt match the 32/64 bitness of the current cluster\n"
                );
            NmpLockedLeaveApi();
            goto FnExit;
        }

#endif
        GetSystemInfo(&SystemInfo);
        status = ClRtlCheckProcArchCompatibility(SystemInfo.wProcessorArchitecture,
            (WORD)dwNodeProcessorArchitecture);
        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] This joining node doesnt meet the processor architecture compatibility with this cluster\n"
                );
            NmpLockedLeaveApi();
            goto FnExit;
        }

        while (TRUE) {
            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader, call the internal
                // handler directly.
                //
                status = NmpAddNode(
                            lpszNodeName,
                            dwNodeHighestVersion,
                            dwNodeLowestVersion,
                            dwNodeProductSuite,
                            registryNodeLimit
                            );
            }
            else {
                //
                // Forward the request to the leader.
                //
                RPC_BINDING_HANDLE binding = Session[NmpLeaderNodeId];

                    ClRtlLogPrint(LOG_NOISE,
                        "[NMJOIN] Forwarding request to add node '%1!ws!' "
                        "to the cluster to the leader (node %2!u!).\n",
                        lpszNodeName,
                        NmpLeaderNodeId
                        );

                CL_ASSERT(binding != NULL);

                NmpReleaseLock();

                status = NmRpcAddNode(
                             binding,
                             lpszNodeName,
                             dwNodeHighestVersion,
                             dwNodeLowestVersion,
                             dwNodeProductSuite
                             );

                 NmpAcquireLock();
             }

            //
            // Check for the error codes that indicate either that
            // another AddNode operation is in progress or that the
            // leadership is changing. We will retry in these cases.
            //
            if ( (status != ERROR_CLUSTER_JOIN_IN_PROGRESS) &&
                 (status != ERROR_NODE_NOT_AVAILABLE)
               ) {
                    break;
            }

            //
            // Sleep for 3 seconds and try again. We will give up and
            // return the error after retrying for 2 minutes.
            //
            if (++retryCount > 40) {
                break;
            }

            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] AddNode operation for node '%1!ws! delayed "
                "waiting for competing AddNode operation to complete.\n",
                lpszNodeName
                );

            NmpReleaseLock();

            Sleep(3000);

            NmpAcquireLock();

        } // end while(TRUE)

        NmpLockedLeaveApi();
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] This system is not in a valid state to process a "
            "request to add a node to the cluster.\n"
            );
        status = ERROR_NODE_NOT_AVAILABLE;
    }

FnExit:
    NmpReleaseLock();

    return(status);

} // s_NmJoinAddNode4



error_status_t
s_JoinAddNode3(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszNodeName,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion,
    IN DWORD    dwNodeProductSuite
    )
/*++

Routine Description:

    Adds a new node to the cluster.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

    dwNodeHighestVersion - The highest cluster version number that the
                           new node can support.

    dwNodeLowestVersion - The lowest cluster version number that the
                          new node can support.

    dwNodeProductSuite - The product suite type identifier for the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This is a new routine in NT5. It performs the AddNode operation
    correctly. It will never be invoked by an NT4 system. It cannot
    be invoked if an NT4 node is in the cluster without violating
    the license agreement.

    The cluster registry APIs cannot be called while holding the NmpLock,
    or a deadlock may occur.

--*/
{
    return(s_JoinAddNode4(IDL_handle, lpszNodeName, dwNodeHighestVersion,
        dwNodeLowestVersion,dwNodeProductSuite,  FALSE, (DWORD)PROCESSOR_ARCHITECTURE_INTEL));
} // s_NmJoinAddNode3


//  This is used by setup of all highest major versions post 1.0
error_status_t
s_JoinAddNode2(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszNodeName,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion
    )
/*++

Routine Description:

    Adds a new node to the cluster database.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This routine was defined in NT4-SP4. JoinAddNode3 is used by NT5. Since
    it is impossible to install clustering using the NT4-SP4 software,
    this routine should never be invoked.

--*/

{
    CL_ASSERT(FALSE);

    return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);
}

error_status_t
s_JoinAddNode(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNodeName
    )
/*++

Routine Description:

    Adds a new node to the cluster database.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This is the routine that NT4-SP3 setup invokes to add a new node to
    a cluster. The combination of NT4-SP3 and NT5 is not supported.

--*/

{
    return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);
}

//
// The rest of the code is currently unused.
//
error_status_t
s_NmRpcDeliverJoinMessage(
    IN handle_t    IDL_handle,
    IN UCHAR *     Message,
    IN DWORD       MessageLength
    )
/*++

Routine Description:

    Server side of the RPC interface for delivering membership
    join messages.

Arguments:

    IDL_handle - RPC binding handle, not used.

    buffer - Supplies a pointer to the message data.

    length - Supplies the length of the message data.

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD  status = ERROR_SUCCESS;

#ifdef MM_IN_CLUSNET

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Delivering join message to Clusnet.\n"
        );

    status = ClusnetDeliverJoinMessage(
                 NmClusnetHandle,
                 Message,
                 MessageLength
                 );

#endif
    return(status);
}


#ifdef MM_IN_CLUSNET

DWORD
NmpSendJoinMessage(
    IN ULONG        DestNodeMask,
    IN PVOID        Message,
    IN ULONG        MessageLength
    )
{
    DWORD        status = ERROR_SUCCESS;
    CL_NODE_ID   node;


    CL_ASSERT(NmMaxNodeId != ClusterInvalidNodeId);

    for ( node = ClusterMinNodeId;
          node <= NmMaxNodeId;
          node++, (DestNodeMask >>= 1)
        )
    {

        if (DestNodeMask & 0x1) {
            if (node != NmLocalNodeId) {

                ClRtlLogPrint(LOG_NOISE,
                    "[NMJOIN] Sending join message to node %1!u!.\n",
                    node
                    );

                status = NmRpcDeliverJoinMessage(
                             Session[node->NodeId],
                             Message,
                             MessageLength
                             );

                if (status == RPC_S_CALL_FAILED_DNE) {
                    //
                    // Try again since the first call to a restarted
                    // RPC server will fail.
                    //
                    status = NmRpcDeliverJoinMessage(
                                 Session[node->NodeId],
                                 Message,
                                 MessageLength
                                 );
                }
            }
            else {
                ClRtlLogPrint(LOG_NOISE,
                    "[NMJOIN] Delivering join message to local node.\n"
                    );

                status = ClusnetDeliverJoinMessage(
                             NmClusnetHandle,
                             Message,
                             MessageLength
                             );
            }

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NMJOIN] send of join message to node %1!u! failed, status %2!u!\n",
                    node,
                    status
                    );
                break;
            }
        }
    }

    return(status);

}  // NmpSendJoinMessage


DWORD
NmJoinNodeToCluster(
    CL_NODE_ID  joinerNodeId
    )
{
    DWORD                status;
    PVOID                message = NULL;
    ULONG                messageLength;
    ULONG                destMask;
    CLUSNET_JOIN_PHASE   phase;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Joining node %1!u! to the cluster.\n",
        joinerNodeId
        );

    for (phase = ClusnetJoinPhase1; phase <= ClusnetJoinPhase4; phase++) {

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] JoinNode phase %1!u!\n",
            phase
            );

        status = ClusnetJoinCluster(
                     NmClusnetHandle,
                     joinerNodeId,
                     phase,
                     NM_MM_JOIN_TIMEOUT,
                     &message,
                     &messageLength,
                     &destMask
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] JoinNode phase %1!u! failed, status %2!u!\n",
                phase,
                status
                );

            break;
        }

        status = NmpSendJoinMessage(
                     destMask,
                     message,
                     messageLength
                     );

        if (status != ERROR_SUCCESS) {
            DWORD abortStatus;

            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] send join message failed %1!u!, aborting join of node %2!u!.\n",
                status,
                joinerNodeId
                );

            abortStatus = ClusnetJoinCluster(
                              NmClusnetHandle,
                              joinerNodeId,
                              ClusnetJoinPhaseAbort,
                              NM_MM_JOIN_TIMEOUT,
                              &message,
                              &messageLength,
                              &destMask
                              );

            if (abortStatus == ERROR_SUCCESS) {
                (VOID) NmpSendJoinMessage(
                           destMask,
                           message,
                           messageLength
                           );
            }

            break;
        }
    }

    if (message != NULL) {
        ClusnetEndJoinCluster(NmClusnetHandle, message);
    }

    return(status);

}  // NmJoinNodeToCluster


#endif  // MM_IN_CLUSNET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\nmp.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nmp.h

Abstract:

    Private interface definitions for the Node Manager component.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/


#ifndef _NMP_INCLUDED
#define _NMP_INCLUDED

#define UNICODE 1

#include "service.h"
#include <winsock2.h>
#include <clnetcfg.h>
#include <bitset.h>
#include <madcapcl.h>
#include <time.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wincrypt.h>

//
// Constants
//
#define LOG_CURRENT_MODULE LOG_MODULE_NM

#define NM_JOIN_TIMEOUT     60000       // 60 seconds
#define NM_MM_JOIN_TIMEOUT   3000       // 3 seconds
#define NM_CLOCK_PERIOD       300       // 300 milliseconds
#define NM_SEND_HB_RATE         4
#define NM_RECV_HB_RATE         3       // Changed 2=>3 to prolong min_stage_1 ticks from 8 to 12
#define MulticastKeyLen        16       // 128 bits

#define NMP_ENCRYPT_ALGORITHM CALG_RC2   // RC2 block encryption algorithm.
#define NMP_KEY_LENGTH 0x00800000        // Key length: 128 bits.
#define NMP_SALT_BUFFER_LEN 16           // 16 bytes. Length of salt for encryption
                                         // of password transferred on wire
#define NMP_MAC_DATA_LENGTH_EXPECTED 16  // 16 bytes


//
// Common Object Flags
//
#define NM_FLAG_OM_INSERTED               0x10000000
#define NM_FLAG_DELETE_PENDING            0x80000000


//
// Miscellaneous Macros
//
#define NM_WCSLEN(_string)    ((lstrlenW(_string) + 1) * sizeof(WCHAR))


//
// Common Object Management Macros
//
#define NM_OM_INSERTED(obj)         ((obj)->Flags & NM_FLAG_OM_INSERTED)
#define NM_DELETE_PENDING(obj)      ((obj)->Flags & NM_FLAG_DELETE_PENDING)

#define NM_FREE_OBJECT_FIELD(_object, _field)  \
            if ( (_object)->_field != NULL ) \
                LocalFree( (_object)->_field )

#define NM_MIDL_FREE_OBJECT_FIELD(_object, _field)    \
            if ( (_object)->_field != NULL )   {      \
                MIDL_user_free( (_object)->_field );  \
                (_object)->_field = NULL;             \
            }


//
// State of the NM component
//
// Note that the order is important. See NmpEnterApi().
//
typedef enum {
    NmStateOffline = 0,
    NmStateOfflinePending = 1,
    NmStateOnlinePending = 2,
    NmStateOnline = 3,
} NM_STATE, *PNM_STATE;


//
// Node definitions
//
typedef struct {
    DWORD  Status;
    DWORD  LocalOnly;
} NM_NODE_CREATE_CONTEXT, *PNM_NODE_CREATE_CONTEXT;

typedef struct _NM_NODE {
    LIST_ENTRY           Linkage;
    DWORD                NodeId;
    CLUSTER_NODE_STATE   State;
    CLUSTER_NODE_STATE   ExtendedState;
    DWORD                Flags;
    DWORD                InterfaceCount;
    LIST_ENTRY           InterfaceList;
    DWORD                HighestVersion;
    DWORD                LowestVersion;
    RPC_BINDING_HANDLE   ReportRpcBinding;  // for net connectivity reports
    RPC_BINDING_HANDLE   IsolateRpcBinding; // for net failure isolation
    SUITE_TYPE           ProductSuite;
    DWORD                DefaultRpcBindingGeneration;
    HANDLE               MmNodeStateDownEvent; // A manual reset event to track MM Node UP/Down
} NM_NODE;

#define NM_NODE_SIG  'edon'

typedef struct _NM_NODE_AUX_INFO{
    DWORD       dwSize;
    DWORD       dwVer;
    SUITE_TYPE  ProductSuite;
}NM_NODE_AUX_INFO, *PNM_NODE_AUX_INFO;

typedef struct {
    LPCWSTR          NodeId;
    HLOCALXSACTION   Xaction;
    DWORD            Status;
} NM_EVICTION_CONTEXT, *PNM_EVICTION_CONTEXT;


#define NM_NODE_UP(node)  \
            ( ( (node)->State == ClusterNodeUp ) ||  \
              ( (node)->State == ClusterNodePaused ) )


//
// Network definitions
//
typedef struct _NM_STATE_WORK_ENTRY {
    NM_STATE_ENTRY    State;
    DWORD             ReachableCount;
} NM_STATE_WORK_ENTRY, *PNM_STATE_WORK_ENTRY;

typedef PNM_STATE_WORK_ENTRY  PNM_STATE_WORK_VECTOR;

typedef PNM_STATE_ENTRY  PNM_CONNECTIVITY_MATRIX;

#define NM_SIZEOF_CONNECTIVITY_MATRIX(_VectorSize) \
          (sizeof(NM_STATE_ENTRY) * _VectorSize *_VectorSize)

#define NM_NEXT_CONNECTIVITY_MATRIX_ROW(_CurrentRowPtr, _VectorSize) \
          (_CurrentRowPtr + (_VectorSize * sizeof(NM_STATE_ENTRY)))

#define NM_GET_CONNECTIVITY_MATRIX_ROW(_MatrixPtr, _RowNumber, _VectorSize) \
          (_MatrixPtr + (_RowNumber * (_VectorSize * sizeof(NM_STATE_ENTRY))))

#define NM_GET_CONNECTIVITY_MATRIX_ENTRY( \
            _MatrixPtr, \
            _RowNumber, \
            _ColNumber, \
            _VectorSize \
            ) \
            ( _MatrixPtr + \
              (_RowNumber * (_VectorSize * sizeof(NM_STATE_ENTRY))) + \
              (_ColNumber * sizeof(NM_STATE_ENTRY)) \
            )


//
// Multicast configuration types.
// - Manual: administrator configured address
// - Madcap: lease obtained from MADCAP server
// - Auto: address chosen after no MADCAP server detected
//
typedef enum {
    NmMcastConfigManual = 0,
    NmMcastConfigMadcap,
    NmMcastConfigAuto
} NM_MCAST_CONFIG, *PNM_MCAST_CONFIG;


typedef struct _NM_NETWORK {
    LIST_ENTRY                  Linkage;
    CL_NETWORK_ID               ShortId;
    CLUSTER_NETWORK_STATE       State;
    DWORD                       Flags;
    CLUSTER_NETWORK_ROLE        Role;
    DWORD                       Priority;
    LPWSTR                      Transport;
    LPWSTR                      Address;
    LPWSTR                      AddressMask;
    LPWSTR                      Description;
    LPWSTR                      MulticastAddress;
    NM_MCAST_CONFIG             ConfigType;
    PVOID                       EncryptedMulticastKey;   // Encrypted by DP API
    DWORD                       EncryptedMulticastKeyLength;  // Encrypted by DP API
    time_t                      MulticastLeaseObtained;
    time_t                      MulticastLeaseExpires;
    MCAST_CLIENT_UID            MulticastLeaseRequestId;
    LPWSTR                      MulticastLeaseServer;
    DWORD                       MulticastKeyExpires;
    DWORD                       InterfaceCount;
    PNM_INTERFACE               LocalInterface;
    PNM_CONNECTIVITY_VECTOR     ConnectivityVector;
    PNM_CONNECTIVITY_MATRIX     ConnectivityMatrix;
    PNM_STATE_WORK_VECTOR       StateWorkVector;
    DWORD                       ConnectivityReportTimer;
    DWORD                       StateRecalcTimer;
    DWORD                       FailureIsolationTimer;
    DWORD                       RegistrationRetryTimer;
    DWORD                       RegistrationRetryTimeout;
    DWORD                       NameChangePendingTimer;
    DWORD                       McastAddressRenewTimer;
    DWORD                       McastAddressReleaseRetryTimer;
    DWORD                       McastAddressReconfigureRetryTimer;
    DWORD                       McastAddressRefreshRetryTimer;
    DWORD                       McastKeyRegenerateTimer;
    DWORD                       ConnectivityReportRetryCount;
    CLRTL_WORK_ITEM             WorkItem;
    CLRTL_WORK_ITEM             MadcapWorkItem;
    LIST_ENTRY                  McastAddressReleaseList;
    LIST_ENTRY                  InterfaceList;
    LIST_ENTRY                  InternalLinkage;
} NM_NETWORK;



#define NM_NETWORK_SIG  'ten'

//
// State flags
//
#define NM_FLAG_NET_WORKER_RUNNING            0x00000001
#define NM_FLAG_NET_REGISTERED                0x00000002
#define NM_FLAG_NET_MULTICAST_ENABLED         0x00000004
#define NM_FLAG_NET_MADCAP_WORKER_RUNNING     0x00000008
#define NM_FLAG_NET_REFRESH_MCAST_RUNNING     0x00000010
#define NM_FLAG_NET_REFRESH_MCAST_ABORTING    0x00000020
#define NM_FLAG_NET_NAME_CHANGE_PENDING       0x00000040
//
// Work Flags
//
#define NM_FLAG_NET_REPORT_LOCAL_IF_UP        0x00000100
#define NM_FLAG_NET_REPORT_CONNECTIVITY       0x00000200
#define NM_FLAG_NET_RECALC_STATE              0x00000400
#define NM_FLAG_NET_ISOLATE_FAILURE           0x00000800
#define NM_FLAG_NET_NEED_TO_REGISTER          0x00002000
#define NM_FLAG_NET_REPORT_LOCAL_IF_FAILED    0x00004000
#define NM_FLAG_NET_RENEW_MCAST_ADDRESS       0x00008000
#define NM_FLAG_NET_RELEASE_MCAST_ADDRESS     0x00010000
#define NM_FLAG_NET_RECONFIGURE_MCAST         0x00020000
#define NM_FLAG_NET_REFRESH_MCAST             0x00040000
#define NM_FLAG_NET_REGENERATE_MCAST_KEY      0x00080000



#define NM_NET_WORK_FLAGS \
            (NM_FLAG_NET_ISOLATE_FAILURE | \
             NM_FLAG_NET_RECALC_STATE | \
             NM_FLAG_NET_NEED_TO_REGISTER | \
             NM_FLAG_NET_REFRESH_MCAST)

#define NM_NET_IF_WORK_FLAGS \
            (NM_FLAG_NET_REPORT_LOCAL_IF_UP | \
             NM_FLAG_NET_REPORT_LOCAL_IF_FAILED)

#define NM_NET_MADCAP_WORK_FLAGS \
            (NM_FLAG_NET_RENEW_MCAST_ADDRESS | \
             NM_FLAG_NET_RELEASE_MCAST_ADDRESS | \
             NM_FLAG_NET_RECONFIGURE_MCAST | \
             NM_FLAG_NET_REGENERATE_MCAST_KEY)

#define NmpIsNetworkRegistered(_network) \
            ((_network)->Flags & NM_FLAG_NET_REGISTERED)

#define NmpIsNetworkForInternalUse(_network) \
            ((_network)->Role & ClusterNetworkRoleInternalUse)

#define NmpIsNetworkForClientAccess(_network) \
            ((_network)->Role & ClusterNetworkRoleClientAccess)

#define NmpIsNetworkForInternalAndClientUse(_network) \
            ((_network)->Role == ClusterNetworkRoleInternalAndClient)

#define NmpIsNetworkDisabledForUse(_network) \
            ((_network)->Role == ClusterNetworkRoleNone)

#define NmpIsNetworkEnabledForUse(_network) \
            ((_network)->Role != ClusterNetworkRoleNone)

#define NmpIsNetworkMulticastEnabled(_network) \
            ((_network)->Flags & NM_FLAG_NET_MULTICAST_ENABLED)

#define NmpIsNetworkNameChangePending(_network) \
            ((_network)->Flags & NM_FLAG_NET_NAME_CHANGE_PENDING)

//
// Network deferred-work timers.
//
// The timer fires every 300ms. One heartbeat (HB) period is 1200ms.
//
// An interface is declared unreachable by ClusNet after two missed HBs.
// On average, an interface will fail in the middle of a ClusNet HB period.
// So, the avg time for ClusNet to detect and report an interface failure
// is 600 + 2400 = 3000ms. The worst case is 1200 + 2400 = 3600ms.
// The best case is 2400ms.
//
// If there are >2 nodes active on a network, it is desirable to
// aggregate interface failure reports when an entire network fails;
// however, we do not know how long it took for ClusNet to make the first
// report. Thus, we assume that the first interface failure was detected
// in the avg time and wait the for the worst case time before reporting.
//
// In the 2 node case, there is no aggregation to be performed so we report
// failures immediately. We always report InterfaceUp and InterfaceFailed
// events immediately. We also report immediately after a NodeDown event.
//
// State recalculation should be performed only after all nodes have reported
// their connectivity changes after a failure. There is spread of 1200ms
// between the best and worst case reporting times. Arbitrary scheduling and
// communication delays can widen the spread even more in the worst case.
// The best we can do is make a good guess. Once in a while, we will
// recalculate too soon. This isn't a disaster since the state calculation
// algorithm will abort if it has partial information. Further, we wait an
// additional period before trying to isolate any connectivity failures that
// were detected. We do this in order to avoid inducing unnecessary
// cluster resource failures.
//
// Note that since we invalidate the connectivity vectors for dead nodes
// after regroup, we only need to delay long enough for each of the nodes
// to process the node down event and fire off a connectivity report.
//
#define NM_NET_CONNECTIVITY_REPORT_TIMEOUT        600  // 3600 - 3000
#define NM_NET_STATE_RECALC_TIMEOUT               2400 // 3600 - 2400 + 1200
#define NM_NET_STATE_RECALC_TIMEOUT_AFTER_REGROUP 900
#define NM_NET_STATE_FAILURE_ISOLATION_TIMEOUT    3600
#define NM_NET_STATE_FAILURE_ISOLATION_POLL       60000 // Change Default to 1 min after testing
#define NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT    3600
#define NM_NET_NAME_CHANGE_PENDING_TIMEOUT        15 * 60 * 1000 // 15 minutes
#define NM_NET_MULTICAST_KEY_REGEN_TIMEOUT        (12 * 60 * 60 * 1000) // 12 hours
#define NM_NET_MULTICAST_KEY_REGEN_TIMEOUT_WINDOW ( 4 * 60 * 60 * 1000) //  4 hours
#define NM_NET_MULTICAST_RECONFIGURE_TIMEOUT      (10 * 60 * 1000) // 10 minutes

#define NmpIsNetworkWorkerRunning(_network) \
            ((_network)->Flags & NM_FLAG_NET_WORKER_RUNNING)

#define NmpIsNetworkMadcapWorkerRunning(_network) \
            ((_network)->Flags & NM_FLAG_NET_MADCAP_WORKER_RUNNING)

#define NM_CONNECTIVITY_REPORT_RETRY_LIMIT  20    // 10 seconds

#define NM_NET_MIN_REGISTRATION_RETRY_TIMEOUT   500          // half a second
#define NM_NET_MAX_REGISTRATION_RETRY_TIMEOUT   (10*60*1000) // 10 minutes

//
// Network interface definitions
//
typedef struct _NM_INTERFACE {
    LIST_ENTRY                        Linkage;
    DWORD                             NetIndex;
    DWORD                             Flags;
    CLUSTER_NETINTERFACE_STATE        State;
    PNM_NODE                          Node;
    PNM_NETWORK                       Network;
    LPWSTR                            AdapterName;
    LPWSTR                            AdapterId;
    LPWSTR                            Address;
    ULONG                             BinaryAddress;
    LPWSTR                            ClusnetEndpoint;
    LPWSTR                            Description;
    LIST_ENTRY                        NetworkLinkage;
    LIST_ENTRY                        NodeLinkage;
} NM_INTERFACE;

#define NM_INTERFACE_SIG  '  fi'

#define NM_FLAG_IF_REGISTERED         0x00000002

#define NmpIsInterfaceRegistered(_interface) \
            ((_interface)->Flags & NM_FLAG_IF_REGISTERED)


//
// This structure is used to hook changes in the node leadership.
//
typedef struct _NM_LEADER_CHANGE_WAIT_ENTRY {
    LIST_ENTRY  Linkage;
    HANDLE      LeaderChangeEvent;
} NM_LEADER_CHANGE_WAIT_ENTRY, *PNM_LEADER_CHANGE_WAIT_ENTRY;


//
// This structure is used for asynchronous network connectivity reports.
//
typedef struct _NM_CONNECTIVITY_REPORT_CONTEXT {
    NM_LEADER_CHANGE_WAIT_ENTRY   LeaderChangeWaitEntry;
    HANDLE                        ConnectivityReportEvent;
} NM_CONNECTIVITY_REPORT_CONTEXT, *PNM_CONNECTIVITY_REPORT_CONTEXT;




// the fixup callback record stored by nm on behalf of other components to perform
//form or join fixups.
typedef struct _NM_FIXUP_CB_RECORD{
    NM_FIXUP_NOTIFYCB       pfnFixupNotifyCb;
    DWORD                   dwFixupMask;
}NM_FIXUP_CB_RECORD,*PNM_FIXUP_CB_RECORD;

//the fixup callback functions for updating in-memory structure after
//updatinbg the registry

typedef DWORD (WINAPI *NM_POST_FIXUP_CB)(VOID);


// fixup callback record used to pass argumnets to NmUpdatePerformFixups2
// update type handler
typedef struct _NM_FIXUP_CB_RECORD2{
    NM_FIXUP_NOTIFYCB       pfnFixupNotifyCb; // pointer to fn that builds up the fixup property list
    DWORD                   dwFixupMask;
    PRESUTIL_PROPERTY_ITEM  pPropertyTable;  // Property table for this key
} NM_FIXUP_CB_RECORD2,*PNM_FIXUP_CB_RECORD2;



//
// Global Data
//
extern CRITICAL_SECTION       NmpLock;
extern HANDLE                 NmpMutex;
extern NM_STATE               NmpState;
extern DWORD                  NmpActiveThreadCount;
extern HANDLE                 NmpShutdownEvent;
extern LIST_ENTRY             NmpNodeList;
extern PNM_NODE *             NmpIdArray;
extern BOOLEAN                NmpNodeCleanupOk;
extern LIST_ENTRY             NmpNetworkList;
extern LIST_ENTRY             NmpInternalNetworkList;
extern LIST_ENTRY             NmpDeletedNetworkList;
extern DWORD                  NmpNetworkCount;
extern DWORD                  NmpInternalNetworkCount;
extern DWORD                  NmpClientNetworkCount;
extern LIST_ENTRY             NmpInterfaceList;
extern LIST_ENTRY             NmpDeletedInterfaceList;
extern RESUTIL_PROPERTY_ITEM  NmpNetworkProperties[];
extern RESUTIL_PROPERTY_ITEM  NmpInterfaceProperties[];
extern CL_NODE_ID             NmpJoinerNodeId;
extern CL_NODE_ID             NmpSponsorNodeId;
extern DWORD                  NmpJoinTimer;
extern BOOLEAN                NmpJoinAbortPending;
extern DWORD                  NmpJoinSequence;
extern BOOLEAN                NmpJoinerUp;
extern BOOLEAN                NmpJoinBeginInProgress;
extern BOOLEAN                NmpJoinerOutOfSynch;
extern WCHAR                  NmpInvalidJoinerIdString[];
extern WCHAR                  NmpUnknownString[];
extern LPWSTR                 NmpClusnetEndpoint;
extern NM_STATE               NmpState;
extern CL_NODE_ID             NmpLeaderNodeId;
extern BITSET                 NmpUpNodeSet;
extern WCHAR                  NmpNullString[];
extern CLUSTER_NETWORK_ROLE   NmpDefaultNetworkRole;
extern BOOL                   NmpCleanupIfJoinAborted;
extern DWORD                  NmpAddNodeId;
extern LIST_ENTRY             NmpLeaderChangeWaitList;
extern LIST_ENTRY *           NmpIntraClusterRpcArr;
extern CRITICAL_SECTION       NmpRPCLock;
extern BOOL                   NmpLastNodeEvicted;
extern DWORD                  NmpNodeCount;
extern BOOLEAN                NmpIsNT5NodeInCluster;
extern LPWSTR                 NmpClusterInstanceId;
extern BOOLEAN                NmpGumUpdateHandlerRegistered;

#if DBG

extern DWORD                  NmpRpcTimer;

#endif //DBG


//
// Synchronization macros
//
#define NmpAcquireLock()  EnterCriticalSection(&NmpLock)
#define NmpReleaseLock()  LeaveCriticalSection(&NmpLock)

#define NmpAcquireMutex() \
            {  \
                DWORD _status = WaitForSingleObject(NmpMutex, INFINITE);  \
                CL_ASSERT(_status == WAIT_OBJECT_0);  \
            }  \

#define NmpReleaseMutex()    ReleaseMutex(NmpMutex);



//
// Node Intracluster RPC record/cancellation routines.
// Useful to terminate outstanding RPCs to failed nodes.
//

#define NM_RPC_TIMEOUT 45000  // 45 secs

typedef struct _NM_INTRACLUSTER_RPC_THREAD {
    LIST_ENTRY Linkage;
    BOOLEAN    Cancelled;
    HANDLE     Thread;
    DWORD      ThreadId;
}NM_INTRACLUSTER_RPC_THREAD, *PNM_INTRACLUSTER_RPC_THREAD;

#define NmpAcquireRPCLock() EnterCriticalSection(&NmpRPCLock);
#define NmpReleaseRPCLock() LeaveCriticalSection(&NmpRPCLock);

VOID
NmpTerminateRpcsToNode(
    DWORD NodeId
    );

VOID
NmpRpcTimerTick(
    DWORD MsTickInterval
    );

//
// IsolationPollTimerValue read routine
//
DWORD
NmpGetIsolationPollTimerValue(
    VOID
    );

//
// Miscellaneous Routines
//
BOOLEAN
NmpLockedEnterApi(
    NM_STATE  RequiredState
    );

BOOLEAN
NmpEnterApi(
    NM_STATE  RequiredState
    );

VOID
NmpLeaveApi(
    VOID
    );

VOID
NmpLockedLeaveApi(
    VOID
    );

LPWSTR
NmpLoadString(
    IN UINT        StringId
    );

VOID
NmpDbgPrint(
    IN ULONG  LogLevel,
    IN PCHAR  FormatString,
    ...
    );

DWORD
NmpCleanseRegistry(
    IN LPCWSTR          NodeId,
    IN HLOCALXSACTION   Xaction
    );

DWORD
NmpQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );

BOOL
NmpCleanseResTypeCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESTYPE pResType,
    IN LPCWSTR pszResTypeName
    );

BOOL
NmpCleanseResourceCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR ResourceName
    );

BOOL
NmpCleanseGroupCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR GroupName
    );

VOID
NmpIssueClusterPropertyChangeEvent(
    VOID
    );

DWORD
NmpMarshallObjectInfo(
    IN  const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN  PVOID                        ObjectInfo,
    OUT PVOID *                      PropertyList,
    OUT LPDWORD                      PropertyListSize
    );

BOOLEAN
NmpVerifyNodeConnectivity(
    PNM_NODE      Node1,
    PNM_NODE      Node2,
    PNM_NETWORK   ExcludedNetwork
    );

BOOLEAN
NmpVerifyConnectivity(
    PNM_NETWORK   ExcludedNetwork
    );

BOOLEAN
NmpVerifyJoinerConnectivity(
    IN  PNM_NODE    JoiningNode,
    OUT PNM_NODE *  UnreachableNode
    );

DWORD
NmpCreateClusterInstanceId(
    VOID
    );


DWORD
NmpSetLsaProcessOptions(
    IN ULONG ProcessOptions
    );


DWORD
NmpGetMulticastKeyFromNMLeader(
    IN DWORD LeaderNodeId,
    IN LPWSTR NodeIdString,
    IN LPWSTR NetworkId,
    IN PNM_NETWORK_MULTICASTKEY * MulticastKey
    );

DWORD
NmpCreateRandomNumber(OUT PVOID * RandonNumber,
                      IN DWORD  RandonNumberSize
                      );


//
// Node Management Routines
//
DWORD
NmpInitNodes(
    VOID
    );

VOID
NmpCleanupNodes(
    VOID
    );

DWORD
NmpGetNodeDefinition(
    IN OUT PNM_NODE_INFO2   NodeInfo
    );

DWORD
NmpEnumNodeDefinitions(
    PNM_NODE_ENUM2 *  NodeEnum
    );

DWORD
NmpCreateNodeObjects(
    IN PNM_NODE_ENUM2  NodeEnum2
    );

DWORD NmpRefreshNodeObjects(
);

DWORD
NmpCreateLocalNodeObject(
    IN PNM_NODE_INFO2  NodeInfo2
    );

PNM_NODE
NmpCreateNodeObject(
    IN PNM_NODE_INFO2  NodeInfo
    );

DWORD
NmpGetNodeObjectInfo(
    IN     PNM_NODE         Node,
    IN OUT PNM_NODE_INFO2   NodeInfo
    );

VOID
NmpDeleteNodeObject(
    IN PNM_NODE   Node,
    IN BOOLEAN    IssueEvent
    );

BOOL
NmpDestroyNodeObject(
    PNM_NODE  Node
    );

DWORD
NmpEnumNodeObjects(
    PNM_NODE_ENUM2 *  NodeEnum
    );

VOID
NmpNodeFailureHandler(
    CL_NODE_ID    NodeId,
    LPVOID        NodeFailureContext
    );

DWORD
NmpSetNodeInterfacePriority(
    IN  PNM_NODE Node,
    IN  DWORD Priority,
    IN  PNM_INTERFACE TargetInterface OPTIONAL,
    IN  DWORD TargetInterfacePriority OPTIONAL
    );

DWORD
NmpEnumNodeObjects(
    PNM_NODE_ENUM2 *  NodeEnum2
    );

DWORD
NmpAddNode(
    IN LPCWSTR  NewNodeName,
    IN DWORD    NewNodeHighestVersion,
    IN DWORD    NewNodeLowestVersion,
    IN DWORD    NewNodeProductSuite,
    IN DWORD    RegistryNodeLimit
);

BOOLEAN
NmpIsAddNodeAllowed(
    IN  DWORD    NewNodeProductSuite,
    IN  DWORD    RegistryNodeLimit,
    OUT LPDWORD  EffectiveNodeLimit   OPTIONAL
    );

VOID
NmpAdviseNodeFailure(
    IN PNM_NODE  Node,
    IN DWORD     ErrorCode
    );


//
// PnP Management Routines
//
DWORD
NmpInitializePnp(
    VOID
    );

VOID
NmpShutdownPnp(
    VOID
    );

VOID
NmpCleanupPnp(
    VOID
    );

VOID
NmpWatchForPnpEvents(
    VOID
    );

DWORD
NmpEnablePnpEvents(
    VOID
    );

DWORD
NmpPostPnpNotification(
    BOOLEAN    IsPnpLockHeld
    );

DWORD
NmpConfigureNetworks(
    IN     RPC_BINDING_HANDLE     JoinSponsorBinding,
    IN     LPWSTR                 LocalNodeId,
    IN     LPWSTR                 LocalNodeName,
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 DefaultEndpoint,
    IN OUT LPDWORD                MatchedNetworkCount,
    IN OUT LPDWORD                NewNetworkCount,
    IN     BOOL                   RenameConnectoids
    );

//
// Network Management Routines
//
DWORD
NmpInitializeNetworks(
    VOID
    );

VOID
NmpCleanupNetworks(
    VOID
    );

DWORD
NmpSetNetworkRole(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole,
    HLOCALXSACTION         Xaction,
    HDMKEY                 NetworkKey
    );

DWORD
NmpCreateNetwork(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpGlobalCreateNetwork(
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpCreateNetworkDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpSetNetworkNameDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpGetNetworkDefinition(
    IN  LPWSTR            NetworkId,
    OUT PNM_NETWORK_INFO  NetworkInfo
    );

DWORD
NmpEnumNetworkDefinitions(
    OUT PNM_NETWORK_ENUM *  NetworkEnum
    );

DWORD
NmpCreateNetworkObjects(
    IN  PNM_NETWORK_ENUM    NetworkEnum
    );

PNM_NETWORK
NmpCreateNetworkObject(
    IN  PNM_NETWORK_INFO   NetworkInfo
    );

DWORD
NmpGetNetworkObjectInfo(
    IN  PNM_NETWORK        Network,
    OUT PNM_NETWORK_INFO   NetworkInfo
    );

VOID
NmpDeleteNetworkObject(
    IN PNM_NETWORK  Network,
    IN BOOLEAN      IssueEvent
    );

BOOL
NmpDestroyNetworkObject(
    PNM_NETWORK  Network
    );

DWORD
NmpEnumNetworkObjects(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    );

DWORD
NmpRegisterNetwork(
    IN PNM_NETWORK   Network,
    IN BOOLEAN       RetryOnFailure
);

VOID
NmpDeregisterNetwork(
    IN  PNM_NETWORK   Network
    );

VOID
NmpInsertInternalNetwork(
    PNM_NETWORK   Network
    );

DWORD
NmpValidateNetworkRoleChange(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole
    );

DWORD
NmpNetworkValidateCommonProperties(
    IN  PNM_NETWORK               Network,
    IN  PVOID                     InBuffer,
    IN  DWORD                     InBufferSize,
    OUT PNM_NETWORK_INFO          NetworkInfo  OPTIONAL
    );

DWORD
NmpSetNetworkName(
    IN PNM_NETWORK_INFO     NetworkInfo
    );

DWORD
NmpGlobalSetNetworkName(
    IN PNM_NETWORK_INFO NetworkInfo
    );

VOID
NmpRecomputeNT5NetworkAndInterfaceStates(
    VOID
    );

BOOLEAN
NmpComputeNetworkAndInterfaceStates(
    PNM_NETWORK               Network,
    BOOLEAN                   IsolateFailure,
    CLUSTER_NETWORK_STATE *   NewNetworkState
    );

VOID
NmpStartNetworkConnectivityReportTimer(
    PNM_NETWORK Network
    );

VOID
NmpStartNetworkStateRecalcTimer(
    PNM_NETWORK  Network,
    DWORD        Timeout
    );

VOID
NmpStartNetworkFailureIsolationTimer(
    PNM_NETWORK Network,
    DWORD       Timeout
    );

VOID
NmpStartNetworkRegistrationRetryTimer(
    PNM_NETWORK Network
    );

VOID
NmpStartNetworkNameChangePendingTimer(
    IN PNM_NETWORK Network,
    IN DWORD       Timeout
    );

VOID
NmpScheduleNetworkConnectivityReport(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleNetworkStateRecalc(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleNetworkRegistration(
    PNM_NETWORK   Network
    );

DWORD
NmpScheduleConnectivityReportWorker(
    VOID
    );

DWORD
NmpScheduleNetworkWorker(
    PNM_NETWORK   Network
    );

VOID
NmpConnectivityReportWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );

VOID
NmpNetworkWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );

VOID
NmpNetworkTimerTick(
    IN DWORD  MsTickInterval
    );

VOID
NmpSetNetworkAndInterfaceStates(
    IN PNM_NETWORK                 Network,
    IN CLUSTER_NETWORK_STATE       NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN DWORD                       VectorSize
    );

VOID
NmpUpdateNetworkConnectivityForDownNode(
    PNM_NODE  Node
    );

DWORD
NmpEnumNetworkObjectStates(
    OUT PNM_NETWORK_STATE_ENUM *  NetworkStateEnum
    );


DWORD NmpGetNetworkMulticastKey(
    IN  LPWSTR                      NetworkId,
    OUT PNM_NETWORK_MULTICASTKEY  * NetworkMulticastKey
    );

VOID
NmpFreeNetworkStateEnum(
    PNM_NETWORK_STATE_ENUM   NetworkStateEnum
    );

DWORD
NmpReportNetworkConnectivity(
    IN PNM_NETWORK    Network
    );

DWORD
NmpGlobalSetNetworkAndInterfaceStates(
    PNM_NETWORK             Network,
    CLUSTER_NETWORK_STATE   NewNetworkState
    );

VOID
NmpReferenceNetwork(
    PNM_NETWORK  Network
    );

VOID
NmpDereferenceNetwork(
    PNM_NETWORK  Network
    );

PNM_NETWORK
NmpReferenceNetworkByAddress(
    LPWSTR  NetworkAddress,
    LPWSTR  NetworkMask
    );


PNM_NETWORK
NmpReferenceNetworkByRemoteAddress(
    LPWSTR  RemoteAddress
    );


DWORD
NmpEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    );

DWORD
NmpSetNetworkPriorityOrder(
    IN DWORD           NetworkCount,
    IN PNM_NETWORK *   NetworkList,
    IN HLOCALXSACTION  Xaction
    );

DWORD
NmpGetNetworkInterfaceFailureTimerValue(
    IN LPCWSTR  NetworkId
    );

BOOLEAN
NmpCheckForNetwork(
    VOID
    );

//
// Network Multicast Management Routines
//
typedef enum {
    NmStartMulticastForm = 0,
    NmStartMulticastJoin,
    NmStartMulticastDynamic
} NM_START_MULTICAST_MODE, *PNM_START_MULTICAST_MODE;

VOID
NmpMulticastInitialize(
    VOID
    );

DWORD
NmpMulticastCleanup(
    VOID
    );

DWORD
NmpStartMulticast(
    IN OPTIONAL PNM_NETWORK              Network,
    IN          NM_START_MULTICAST_MODE  Mode
    );

DWORD
NmpStopMulticast(
    IN OPTIONAL PNM_NETWORK   Network
    );

VOID
NmpMulticastProcessClusterVersionChange(
    VOID
    );


DWORD
NmpMulticastValidatePrivateProperties(
    IN  PNM_NETWORK Network,
    IN  HDMKEY      RegistryKey,
    IN  PVOID       InBuffer,
    IN  DWORD       InBufferSize
    );

VOID
NmpScheduleMulticastAddressRenewal(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleMulticastAddressRelease(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleMulticastRefresh(
    IN PNM_NETWORK   Network
    );

VOID
NmpScheduleMulticastKeyRegeneration(
    PNM_NETWORK   Network
    );


DWORD
NmpRefreshMulticastConfiguration(
    IN PNM_NETWORK  Network
    );

VOID
NmpFreeMulticastAddressReleaseList(
    IN     PNM_NETWORK       Network
    );

DWORD
NmpMulticastManualConfigChange(
    IN     PNM_NETWORK          Network,
    IN     HDMKEY               NetworkKey,
    IN     HDMKEY               NetworkParametersKey,
    IN     PVOID                InBuffer,
    IN     DWORD                InBufferSize,
       OUT BOOLEAN            * SetProperties
    );

DWORD
NmpUpdateSetNetworkMulticastConfiguration(
    IN    BOOL                          SourceNode,
    IN    LPWSTR                        NetworkId,
    IN    PVOID                         UpdateBuffer,
    IN    PVOID                         PropBuffer,
    IN    LPDWORD                       PropBufferSize
    );

//
// Interface Management Routines
//
DWORD
NmpInitializeInterfaces(
    VOID
    );

VOID
NmpCleanupInterfaces(
    VOID
    );

DWORD
NmpCreateInterface(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpGlobalCreateInterface(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    );

DWORD
NmpSetInterfaceInfo(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpLocalSetInterfaceInfo(
    IN  PNM_INTERFACE         Interface,
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    IN  HLOCALXSACTION        Xaction
    );

DWORD
NmpGlobalSetInterfaceInfo(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    );

DWORD
NmpDeleteInterface(
    IN     RPC_BINDING_HANDLE   JoinSponsorBinding,
    IN     LPWSTR               InterfaceId,
    IN     LPWSTR               NetworkId,
    IN OUT PBOOLEAN             NetworkDeleted
    );

DWORD
NmpGlobalDeleteInterface(
    IN     LPWSTR    InterfaceId,
    IN OUT PBOOLEAN  NetworkDeleted
    );

DWORD
NmpInterfaceValidateCommonProperties(
    IN PNM_INTERFACE         Interface,
    IN PVOID                 InBuffer,
    IN DWORD                 InBufferSize,
    OUT PNM_INTERFACE_INFO2  InterfaceInfo  OPTIONAL
    );

DWORD
NmpCreateInterfaceDefinition(
    IN PNM_INTERFACE_INFO2  InterfaceInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpGetInterfaceDefinition(
    IN  LPWSTR                InterfaceId,
    OUT PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpSetInterfaceDefinition(
    IN PNM_INTERFACE_INFO2  InterfaceInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpEnumInterfaceDefinitions(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    );

DWORD
NmpCreateInterfaceObjects(
    IN  PNM_INTERFACE_ENUM2    InterfaceEnum
    );

PNM_INTERFACE
NmpCreateInterfaceObject(
    IN PNM_INTERFACE_INFO2   InterfaceInfo,
    IN BOOLEAN               RetryOnFailure

    );

DWORD
NmpGetInterfaceObjectInfo1(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO   InterfaceInfo1
    );

DWORD
NmpGetInterfaceObjectInfo(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO2  InterfaceInfo
    );

VOID
NmpDeleteInterfaceObject(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        IssueEvent
    );

BOOL
NmpDestroyInterfaceObject(
    PNM_INTERFACE  Interface
    );

DWORD
NmpEnumInterfaceObjects1(
    OUT PNM_INTERFACE_ENUM *  InterfaceEnum1
    );

DWORD
NmpEnumInterfaceObjects(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    );

DWORD
NmpRegisterInterface(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        RetryOnFailure
    );

VOID
NmpDeregisterInterface(
    IN  PNM_INTERFACE   Interface
    );

DWORD
NmpPrepareToCreateInterface(
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    OUT PNM_NETWORK *         Network,
    OUT PNM_NODE *            Node
    );

PNM_INTERFACE
NmpGetInterfaceForNodeAndNetworkById(
    IN  CL_NODE_ID     NodeId,
    IN  CL_NETWORK_ID  NetworkId
    );

VOID
NmpFreeInterfaceStateEnum(
    PNM_INTERFACE_STATE_ENUM   InterfaceStateEnum
    );

DWORD
NmpEnumInterfaceObjectStates(
    OUT PNM_INTERFACE_STATE_ENUM *  InterfaceStateEnum
    );

VOID
NmpProcessLocalInterfaceStateEvent(
    IN PNM_INTERFACE                Interface,
    IN CLUSTER_NETINTERFACE_STATE   NewState
    );

DWORD
NmpReportInterfaceConnectivity(
    IN RPC_BINDING_HANDLE       RpcBinding,
    IN LPWSTR                   InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR  ConnectivityVector,
    IN LPWSTR                   NetworkId
    );

VOID
NmpProcessInterfaceConnectivityReport(
    IN PNM_INTERFACE               SourceInterface,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    );

DWORD
NmpInterfaceCheckThread(
    LPDWORD   Context
    );

VOID
NmpReportLocalInterfaceStateEvent(
    IN CL_NODE_ID     NodeId,
    IN CL_NETWORK_ID  NetworkId,
    IN DWORD          NewState
    );

DWORD
NmpConvertPropertyListToInterfaceInfo(
    IN PVOID              InterfacePropertyList,
    IN DWORD              InterfacePropertyListSize,
    PNM_INTERFACE_INFO2   InterfaceInfo
    );

VOID
NmpSetInterfaceConnectivityData(
    PNM_NETWORK                  Network,
    DWORD                        InterfaceNetIndex,
    CLUSTER_NETINTERFACE_STATE   State
    );

DWORD
NmpTestInterfaceConnectivity(
    PNM_INTERFACE  Interface1,
    PBOOLEAN       Interface1HasConnectivity,
    PNM_INTERFACE  Interface2,
    PBOOLEAN       Interfacet2HasConnectivity
    );

DWORD
NmpBuildInterfaceOnlineAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM *  OnlineAddressEnum
    );

DWORD
NmpBuildInterfacePingAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM    OnlineAddressEnum,
    PNM_ADDRESS_ENUM *  PingAddressEnum
    );

BOOLEAN
NmpVerifyLocalInterfaceConnected(
    IN  PNM_INTERFACE   Interface
    );

//
// Membership Management Routines
//

DWORD
NmpMembershipInit(
    VOID
    );

VOID
NmpMembershipShutdown(
    VOID
    );

VOID
NmpMarkNodeUp(
    CL_NODE_ID  NodeId
    );

VOID
NmpNodeUpEventHandler(
    IN PNM_NODE   Node
    );

VOID
NmpNodeDownEventHandler(
    IN PNM_NODE   Node
    );

DWORD
NmpMultiNodeDownEventHandler(
    IN BITSET DownedNodeSet
    );

DWORD
NmpNodeChange(
    DWORD NodeId,
    NODESTATUS newstatus
    );

BOOL
NmpCheckQuorumEventHandler(
    VOID
    );

VOID
NmpHoldIoEventHandler(
    VOID
    );

VOID
NmpResumeIoEventHandler(
    VOID
    );

VOID
NmpHaltEventHandler(
    IN DWORD HaltCode
    );

VOID
NmpJoinAbort(
    DWORD      AbortStatus,
    PNM_NODE   JoinerNode
    );


//
// Routines for joining nodes to a cluster
//
DWORD
NmpCreateJoinerRpcBindings(
    IN PNM_NODE       JoinerNode,
    IN PNM_INTERFACE  JoinerInterface
    );

//
// Gum update message types.
//
// The first entries in this list are auto-marshalled through Gum...Ex.
// Any updates that are not auto-marshalled must come after NmUpdateMaxAuto
//
typedef enum {
    NmUpdateCreateNode = 0,
    NmUpdatePauseNode,
    NmUpdateResumeNode,
    NmUpdateEvictNode,
    NmUpdateCreateNetwork,
    NmUpdateSetNetworkName,
    NmUpdateSetNetworkPriorityOrder,
    NmUpdateSetNetworkCommonProperties,
    NmUpdateCreateInterface,
    NmUpdateSetInterfaceInfo,
    NmUpdateSetInterfaceCommonProperties,
    NmUpdateDeleteInterface,
    NmUpdateJoinBegin,
    NmUpdateJoinAbort,
    //
    // Version 2 (NT 5.0) extensions that are understood by
    // NT4 SP4 4.
    //
    NmUpdateJoinBegin2,
    NmUpdateSetNetworkAndInterfaceStates,
    NmUpdatePerformFixups,
    NmUpdatePerformFixups2,
    //
    // Version 2 (NT 5.0) extensions that are not understood
    // by NT4 SP4. These may not be issued in a mixed NT4/NT5 cluster.
    //
    NmUpdateAddNode,
    NmUpdateExtendedNodeState,
    //
    // NT 5.1 extensions that are not understood by NT5 and
    // earlier. NT5 nodes will ignore these updates without
    // error.
    //
    NmUpdateSetNetworkMulticastConfiguration,
    NmUpdateSetServiceAccountPassword,


    //
    // Max handled automatically by GUM
    //
    NmUpdateMaxAuto = 0x10000,

    NmUpdateJoinComplete,

    NmUpdateMaximum
} NM_GUM_MESSAGE_TYPES;

#pragma warning( disable: 4200 )
typedef struct _NM_JOIN_UPDATE {
    DWORD JoinSequence;
    DWORD IsPaused;
    WCHAR NodeId[0];
} NM_JOIN_UPDATE, *PNM_JOIN_UPDATE;
#pragma warning( default: 4200 )

DWORD
NmpGumUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
NmpUpdateAddNode(
    IN BOOL       SourceNode,
    IN LPDWORD    NewNodeId,
    IN LPCWSTR    NewNodeName,
    IN LPDWORD    NewNodeHighestVersion,
    IN LPDWORD    NewNodeLowestVersion,
    IN LPDWORD    NewNodeProductSuite
    );

DWORD
NmpUpdateCreateNode(
    IN BOOL SourceNode,
    IN LPDWORD NodeId
    );

DWORD
NmpUpdatePauseNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeName
    );

DWORD
NmpUpdateResumeNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeName
    );

DWORD
NmpUpdateEvictNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeName
    );

DWORD
NmpUpdateSetServiceAccountPassword(
    IN BOOL SourceNode,
    IN LPWSTR DomainName,
    IN LPWSTR AccountName,
    IN LPBYTE NewPassword,
    IN LPDWORD NewPasswordLen,
    IN LPBYTE SaltBuf,
    IN LPDWORD SaltBufLen,
    IN LPBYTE MACData,
    IN LPDWORD MACDataLen
    );

DWORD
NmpUpdateCreateNetwork(
    IN BOOL     IsSourceNode,
    IN PVOID    NetworkPropertyList,
    IN LPDWORD  NetworkPropertyListSize,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    );

DWORD
NmpUpdateSetNetworkName(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN LPWSTR   Name
    );

DWORD
NmpUpdateSetNetworkPriorityOrder(
    IN BOOL      IsSourceNode,
    IN LPCWSTR   NetworkIdList
    );

DWORD
NmpUpdateSetNetworkCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    );

DWORD
NmpUpdateCreateInterface(
    IN BOOL     IsSourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    );

DWORD
NmpUpdateSetInterfaceInfo(
    IN BOOL     SourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    );

DWORD
NmpUpdateSetInterfaceCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    );

DWORD
NmpUpdateDeleteInterface(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId
    );

DWORD
NmpUpdateJoinBegin(
    IN  BOOL    SourceNode,
    IN  LPWSTR  JoinerNodeId,
    IN  LPWSTR  JoinerNodeName,
    IN  LPWSTR  SponsorNodeId
    );

DWORD
NmpUpdateJoinComplete(
    IN PNM_JOIN_UPDATE  JoinUpdate
    );

DWORD
NmpUpdateJoinAbort(
    IN  BOOL    SourceNode,
    IN  LPDWORD JoinSequence,
    IN  LPWSTR  JoinerNodeId
    );

DWORD
NmpUpdateJoinBegin2(
    IN  BOOL      SourceNode,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  LPWSTR    SponsorNodeId,
    IN  LPDWORD   JoinerHighestVersion,
    IN  LPDWORD   JoinerLowestVersion
    );

DWORD
NmpUpdateSetNetworkAndInterfaceStates(
    IN BOOL                        IsSourceNode,
    IN LPWSTR                      NetworkId,
    IN CLUSTER_NETWORK_STATE *     NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN LPDWORD                     InterfaceStateVectorSize
    );



DWORD
NmpDoInterfacePing(
    IN  PNM_INTERFACE        Interface,
    IN  PNM_ADDRESS_ENUM     PingAddressEnum,
    OUT BOOLEAN *            PingSucceeded
    );

//versioning functions
VOID
NmpResetClusterVersion(
    BOOL ProcessChanges
    );

DWORD NmpValidateNodeVersion(
    IN LPCWSTR  NodeId,
    IN DWORD    dwHighestVersion,
    IN DWORD    dwLowestVersion
    );

DWORD NmpFormFixupNodeVersion(
    IN LPCWSTR      NodeId,
    IN DWORD        dwHighestVersion,
    IN DWORD        dwLowestVersion
    );

DWORD NmpJoinFixupNodeVersion(
    IN HLOCALXSACTION   hXsaction,
    IN LPCWSTR          NodeId,
    IN DWORD            dwHighestVersion,
    IN DWORD            dwLowestVersion
    );

DWORD NmpIsNodeVersionAllowed(
    IN DWORD    dwExcludeNodeId,
    IN DWORD    NodeHighestVersion,
    IN DWORD    NodeLowestVersion,
    IN BOOL     bJoin
    );

DWORD NmpCalcClusterVersion(
    IN  DWORD       dwExcludeNodeId,
    OUT LPDWORD     pdwClusterHighestVersion,
    OUT LPDWORD     pdwClusterLowestVersion
    );


DWORD NmpUpdatePerformFixups(
    IN BOOL     IsSourceNode,
    IN PVOID    PropertyList,
    IN LPDWORD  PropertyListSize
    );

DWORD NmpUpdatePerformFixups2(
    IN BOOL     IsSourceNode,
    IN PVOID    PropertyList,
    IN LPDWORD  PropertyListSize,
    IN LPDWORD  lpdwFixupNum,
    IN PVOID    lpKeyName,
    IN PVOID    pPropertyBuffer
    );

DWORD NmpUpdateExtendedNodeState(
    IN BOOL SourceNode,
    IN LPWSTR NodeId,
    IN CLUSTER_NODE_STATE* ExtendedState
    );

VOID
NmpProcessClusterVersionChange(
    VOID
    );

VOID
NmpResetClusterNodeLimit(
    );

// Fixup routine for updating the node version info, used by nmperformfixups

DWORD
NmpBuildVersionInfo(
    IN  DWORD    dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD  pdwPropertyListSize,
    OUT LPWSTR * lpszKeyName
    );

//
// connectoid advise sink functions
//

HRESULT
NmpInitializeConnectoidAdviseSink(
    VOID
    );

//
// Routines that must be supplied by users of the ClNet package.
//
VOID
ClNetPrint(
    IN ULONG LogLevel,
    IN PCHAR FormatString,
    ...
    );

VOID
ClNetLogEvent(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    );

VOID
ClNetLogEvent1(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    );

VOID
ClNetLogEvent2(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    );

VOID
ClNetLogEvent3(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    );

//
// Shared key management routines.
//
DWORD
NmpGetClusterKey(
    OUT    PVOID    KeyBuffer,
    IN OUT DWORD  * KeyBufferLength
    );

DWORD
NmpRederiveClusterKey(
    VOID
    );

VOID
NmpFreeClusterKey(
    VOID
    );


DWORD
NmpDeriveSessionKey(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *SaltBuffer,
    IN DWORD SaltBufferLen,
    OUT HCRYPTKEY *CryptKey
    );

#ifdef MULTICAST_DEBUG
DWORD
NmpDbgPrintData(LPCWSTR InfoStr,
                PVOID Data,
                DWORD DataLen
                );
#endif


DWORD
NmpCreateCSPHandle(
    OUT HCRYPTPROV *CryptProvider
    );


DWORD
NmpProtectData(
    IN PVOID Data,
    IN DWORD DataLength,
    OUT PVOID *EncryptedData,
    OUT DWORD *EncryptedDataLength
    );


DWORD
NmpUnprotectData(
    IN PVOID EncryptedData,
    IN DWORD EncryptedDataLength,
    OUT PVOID     * Data,
    OUT DWORD     * DataLength
    );


DWORD
NmpEncryptDataAndCreateMAC(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN PBYTE Data,
    IN DWORD DataLength,
    IN PVOID EncryptionKey,
    IN DWORD EncryptionKeyLength,
    IN BOOL CreateSalt,
    OUT PBYTE *Salt,
    IN DWORD SaltLength,
    OUT PBYTE *EncryptedData,
    OUT DWORD *EncryptedDataLength,
    OUT PBYTE *MAC,
    IN OUT DWORD *MACLength
    );

DWORD
NmpVerifyMACAndDecryptData(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EcnryptionAlgoId,
    IN DWORD Flags,
    IN PBYTE MAC,
    IN DWORD MACLength,
    IN DWORD MACExpectedSize,
    IN PBYTE EncryptedData,
    IN DWORD EncryptedDataLength,
    IN PVOID EncryptionKey,
    IN DWORD EncryptionKeyLength,
    IN PBYTE Salt,
    IN DWORD SaltLength,
    OUT PBYTE *DecryptedData,
    OUT DWORD *DecryptedDataLength
    );



DWORD
NmpDeriveClusterKey(
    IN  PVOID   MixingBytes,
    IN  DWORD   MixingBytesSize,
    OUT PVOID * Key,
    OUT DWORD * KeyLength
    );

void
NmpFreeNetworkMulticastKey(
    PNM_NETWORK_MULTICASTKEY networkMulticastKey
    );

VOID
NmpScheduleMulticastReconfiguration(
    IN PNM_NETWORK   Network
    );


#endif  // _NMP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\nmpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nmpnp.c

Abstract:

    Network Plug 'N Play and interface state event handling for
    the Node Manager.

Author:

    Mike Massa (mikemas)

Revision History:

    2/23/98   Created.

--*/

#include "nmp.h"


//
// Private Types
//
typedef struct {
    LIST_ENTRY           Linkage;
    CLUSNET_EVENT_TYPE   Type;
    DWORD                Context1;
    DWORD                Context2;
} NM_PNP_EVENT, *PNM_PNP_EVENT;


//
// Private Data
//
PCRITICAL_SECTION       NmpPnpLock = NULL;
BOOLEAN                 NmpPnpEnabled = FALSE;
BOOLEAN                 NmpPnpChangeOccurred = FALSE;
BOOLEAN                 NmpPnpInitialized = FALSE;
PCLRTL_BUFFER_POOL      NmpPnpEventPool = NULL;
PNM_PNP_EVENT           NmpPnpShutdownEvent = NULL;
PCL_QUEUE               NmpPnpEventQueue = NULL;
HANDLE                  NmpPnpWorkerThreadHandle = NULL;
LPWSTR                  NmpPnpAddressString = NULL;


//
// Private Prototypes
//
DWORD
NmpPnpWorkerThread(
    LPVOID Context
    );


//
// Routines
//
DWORD
NmpInitializePnp(
    VOID
    )
{
    DWORD      status;
    HANDLE     handle;
    DWORD      threadId;
    DWORD      maxAddressStringLength;


    //
    // Create the PnP lock
    //
    NmpPnpLock = LocalAlloc(LMEM_FIXED, sizeof(CRITICAL_SECTION));

    if (NmpPnpLock == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Unable to allocate PnP lock.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    InitializeCriticalSection(NmpPnpLock);

    NmpPnpInitialized = TRUE;

    //
    // Allocate a buffer pool for PnP event contexts
    //
    NmpPnpEventPool = ClRtlCreateBufferPool(
                             sizeof(NM_PNP_EVENT),
                             5,
                             CLRTL_MAX_POOL_BUFFERS,
                             NULL,
                             NULL
                             );

    if (NmpPnpEventPool == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP event pool.\n"
            );
        goto error_exit;
    }

    //
    // Pre-allocate the shutdown event
    //
    NmpPnpShutdownEvent = ClRtlAllocateBuffer(NmpPnpEventPool);

    if (NmpPnpShutdownEvent == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP shutdown event.\n"
            );
        goto error_exit;
    }

    NmpPnpShutdownEvent->Type = ClusnetEventNone;

    //
    // Allocate the PnP event queue
    //
    NmpPnpEventQueue = LocalAlloc(LMEM_FIXED, sizeof(CL_QUEUE));

    if (NmpPnpEventQueue == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP event queue.\n"
            );
        goto error_exit;
    }

    ClRtlInitializeQueue(NmpPnpEventQueue);



    ClRtlQueryTcpipInformation(&maxAddressStringLength, NULL, NULL);

    NmpPnpAddressString = LocalAlloc(
                              LMEM_FIXED,
                              (maxAddressStringLength + 1) * sizeof(WCHAR)
                              );

    if (NmpPnpAddressString == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP address buffer.\n"
            );
        goto error_exit;
    }

    //
    // Create PnP worker thread
    //
    NmpPnpWorkerThreadHandle = CreateThread(
                                   NULL,
                                   0,
                                   NmpPnpWorkerThread,
                                   NULL,
                                   0,
                                   &threadId
                                   );

    if (NmpPnpWorkerThreadHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create PnP worker thread, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ERROR_SUCCESS;

error_exit:

    return(status);

} // NmpInitializePnp


VOID
NmpShutdownPnp(
    VOID
    )
{
    if (!NmpPnpInitialized) {
        return;
    }

    if (NmpPnpWorkerThreadHandle != NULL) {
        //
        // Post shutdown event to queue
        //
        ClRtlInsertTailQueue(
            NmpPnpEventQueue,
            &(NmpPnpShutdownEvent->Linkage)
            );

        //
        // Wait for the worker thread to terminate
        //
        WaitForSingleObject(NmpPnpWorkerThreadHandle, INFINITE);

        CloseHandle(NmpPnpWorkerThreadHandle);
        NmpPnpWorkerThreadHandle = NULL;
    }

    return;

} // NmpShutdownPnp


VOID
NmpCleanupPnp(
    VOID
    )
{
    if (!NmpPnpInitialized) {
        return;
    }

    if (NmpPnpEventQueue != NULL) {
        LIST_ENTRY      eventList;
        PLIST_ENTRY     entry;
        PNM_PNP_EVENT   event;


        ClRtlRundownQueue(NmpPnpEventQueue, &eventList);

        for ( entry = eventList.Flink;
              entry != &eventList;
            )
        {
            event = CONTAINING_RECORD(entry, NM_PNP_EVENT, Linkage);

            if (event == NmpPnpShutdownEvent) {
                NmpPnpShutdownEvent = NULL;
            }

            entry = entry->Flink;
            ClRtlFreeBuffer(event);
        }

        LocalFree(NmpPnpEventQueue);
        NmpPnpEventQueue = NULL;
    }

    if (NmpPnpEventPool != NULL) {
        if (NmpPnpShutdownEvent != NULL) {
            ClRtlFreeBuffer(NmpPnpShutdownEvent);
            NmpPnpShutdownEvent = NULL;

        }

        ClRtlDestroyBufferPool(NmpPnpEventPool);
        NmpPnpEventPool = NULL;
    }

    if (NmpPnpAddressString != NULL) {
        LocalFree(NmpPnpAddressString);
        NmpPnpAddressString = NULL;
    }

    DeleteCriticalSection(NmpPnpLock);
    NmpPnpLock = NULL;

    NmpPnpInitialized = FALSE;

    return;

} // NmpCleanupPnp


VOID
NmpWatchForPnpEvents(
    VOID
    )
{
    EnterCriticalSection(NmpPnpLock);

    NmpPnpChangeOccurred = FALSE;

    LeaveCriticalSection(NmpPnpLock);

    return;

}  // NmpWatchForPnpEvents


DWORD
NmpEnablePnpEvents(
    VOID
    )
{
    DWORD   status;


    EnterCriticalSection(NmpPnpLock);

    if (NmpPnpChangeOccurred) {
        status = ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED;
    }
    else {
        NmpPnpEnabled = TRUE;
        status = ERROR_SUCCESS;
    }

    LeaveCriticalSection(NmpPnpLock);

    return(status);

}  // NmpEnablePnpEvents


VOID
NmPostPnpEvent(
    IN  CLUSNET_EVENT_TYPE   EventType,
    IN  DWORD                Context1,
    IN  DWORD                Context2
    )
{
    PNM_PNP_EVENT  event;


    event = ClRtlAllocateBuffer(NmpPnpEventPool);

    if (event != NULL) {
        event->Type = EventType;
        event->Context1 = Context1;
        event->Context2 = Context2;

        ClRtlInsertTailQueue(NmpPnpEventQueue, &(event->Linkage));
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP event.\n"
            );
    }

    return;

} // NmPostPnpEvent


VOID
NmpProcessPnpAddAddressEvent(
    IN LPWSTR   Address
    )
{
    DWORD                status;
    PNM_NETWORK_ENUM     networkEnum;
    PNM_INTERFACE_ENUM2  interfaceEnum;
    DWORD                matchedNetworkCount;
    DWORD                newNetworkCount;
    DWORD                retryCount = 0;


    //
    // We will retry this operation a few times in case multiple nodes
    // race to create a network that has just been powered up.
    //
    do {
        networkEnum = NULL;
        interfaceEnum = NULL;
        matchedNetworkCount = 0;
        newNetworkCount = 0;

        NmpAcquireLock();

        //
        // Obtain the network and interface definitions.
        //
        status = NmpEnumNetworkObjects(&networkEnum);

        if (status == ERROR_SUCCESS) {
            status = NmpEnumInterfaceObjects(&interfaceEnum);

            NmpReleaseLock();

            if (status == ERROR_SUCCESS) {
                //
                // Run the network configuration engine. This will
                // update the cluster database.
                //
                status = NmpConfigureNetworks(
                             NULL,
                             NmLocalNodeIdString,
                             NmLocalNodeName,
                             &networkEnum,
                             &interfaceEnum,
                             NmpClusnetEndpoint,
                             &matchedNetworkCount,
                             &newNetworkCount,
                             TRUE                   // RenameConnectoids
                             );

                if (status == ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Matched %1!u! networks, created %2!u! new "
                        "networks.\n",
                        matchedNetworkCount,
                        newNetworkCount
                        );
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Failed to configure networks & interfaces, "
                        "attempt #%1!u!, status %2!u!.\n",
                        (retryCount + 1),
                        status
                        );
                }

                if (interfaceEnum != NULL) {
                    ClNetFreeInterfaceEnum(interfaceEnum);
                }
            }
            else {
                ClRtlLogPrint(
                    LOG_UNUSUAL, 
                    "[NM] Failed to obtain current interface configuration, "
                    "status %1!u!\n",
                    status
                    );
            }

            if (networkEnum != NULL) {
                ClNetFreeNetworkEnum(networkEnum);
            }
        }
        else {
            NmpReleaseLock();
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] Failed to obtain current network configuration, "
                "status %1!u!\n",
                status
                );
        }

    } while ((status != ERROR_SUCCESS) && (++retryCount <= 3));

    return;

} // NmpProcessPnpAddAddressEvent


VOID
NmpProcessPnpDelAddressEvent(
    IN LPWSTR   Address
    )
{
    PLIST_ENTRY     entry;
    PNM_INTERFACE   netInterface;
    BOOLEAN         networkDeleted;

    //
    // Check if this address corresponds to an interface for
    // the local node.
    //
    NmpAcquireLock();

    for (entry = NmLocalNode->InterfaceList.Flink;
         entry != &(NmLocalNode->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        if (lstrcmpW(
                Address,
                netInterface->Address
                ) == 0
            )
        {
            //
            // Delete the interface from the cluster.
            //
            NmpGlobalDeleteInterface(
                (LPWSTR) OmObjectId(netInterface),
                &networkDeleted
                );
            break;
        }
    }

    if (entry == &(NmLocalNode->InterfaceList)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Deleted address does not correspond to a cluster "
            "interface.\n"
            );
    }

    NmpReleaseLock();

    return;

} // NmpProcessPnpDelAddressEvent


DWORD
NmpPnpWorkerThread(
    LPVOID Context
    )
{
    PLIST_ENTRY     entry;
    PNM_PNP_EVENT   event;
    BOOL            again = TRUE;
    DWORD           status;


    while (again) {
        entry = ClRtlRemoveHeadQueue(NmpPnpEventQueue);

        if (entry == NULL) {
            //
            // Time to exit
            //
            NmpPnpShutdownEvent = NULL;
            break;
        }

        event = CONTAINING_RECORD(entry, NM_PNP_EVENT, Linkage);

        if (event->Type == ClusnetEventNone) {
            //
            // Time to exit
            //
            again = FALSE;
            NmpPnpShutdownEvent = NULL;
        }
        else if (event->Type == ClusnetEventNetInterfaceUp) {
            NmpReportLocalInterfaceStateEvent(
                event->Context1,
                event->Context2,
                ClusterNetInterfaceUp
                );
        }
        else if (event->Type == ClusnetEventNetInterfaceUnreachable) {
            NmpReportLocalInterfaceStateEvent(
                event->Context1,
                event->Context2,
                ClusterNetInterfaceUnreachable
                );
        }
        else if (event->Type == ClusnetEventNetInterfaceFailed) {
            NmpReportLocalInterfaceStateEvent(
                event->Context1,
                event->Context2,
                ClusterNetInterfaceFailed
                );
        }
        else if ( (event->Type == ClusnetEventAddAddress) ||
                  (event->Type == ClusnetEventDelAddress)
                )
        {
            //
            // This is a PnP event.
            //
            EnterCriticalSection(NmpPnpLock);

            if (NmpPnpEnabled) {
                LeaveCriticalSection(NmpPnpLock);

                status = ClRtlTcpipAddressToString(
                             event->Context1,
                             &NmpPnpAddressString
                             );

                if (status == ERROR_SUCCESS) {
                    if (event->Type == ClusnetEventAddAddress) {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Processing PnP add event for address "
                            "%1!ws!.\n",
                            NmpPnpAddressString
                            );

                        NmpProcessPnpAddAddressEvent(NmpPnpAddressString);
                    }
                    else {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Processing PnP delete event for address "
                            "%1!ws!.\n",
                            NmpPnpAddressString
                            );

                        NmpProcessPnpDelAddressEvent(NmpPnpAddressString);
                    }
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] Failed to convert PnP address %1!x! to string, "
                        "status %2!u!.\n",
                        event->Context1,
                        status
                        );
                }
            }
            else {
                //
                // We are not ready to handle PnP events yet.
                // Note that something changed. This will cause the join/form
                // process to eventually abort.
                //
                NmpPnpChangeOccurred = TRUE;

                LeaveCriticalSection(NmpPnpLock);

                ClRtlLogPrint(
                    LOG_NOISE, 
                    "[NM] Discarding Pnp notification - handling not "
                    "enabled.\n"
                    );
            }
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Received unknown PnP event type 0x%1!x!.\n",
                event->Type
                );
        }

        ClRtlFreeBuffer(event);
    }

    ClRtlLogPrint(LOG_NOISE, "[NM] Pnp worker thread terminating.\n");

    return(ERROR_SUCCESS);

} // NmpPnpWorkerThread


DWORD
NmpConfigureNetworks(
    IN     RPC_BINDING_HANDLE     JoinSponsorBinding,
    IN     LPWSTR                 LocalNodeId,
    IN     LPWSTR                 LocalNodeName,
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 DefaultEndpoint,
    IN OUT LPDWORD                MatchedNetworkCount,
    IN OUT LPDWORD                NewNetworkCount,
    IN     BOOL                   RenameConnectoids
    )
/*++

Notes:

    Must not be called with the NM lock held.

    RenameConnectoids is TRUE if connectoid names are to be aligned with
    cluster network names. If FALSE, rename the cluster network names to be
    like the connectoid names.

--*/
{
    DWORD                    status;
    CLNET_CONFIG_LISTS       lists;
    PLIST_ENTRY              listEntry;
    PCLNET_CONFIG_ENTRY      configEntry;
    BOOLEAN                  networkDeleted;
    WCHAR                    errorString[12];
    DWORD                    eventCode = 0;
    DWORD                    defaultRole = CL_DEFAULT_NETWORK_ROLE;


    *MatchedNetworkCount = 0;
    *NewNetworkCount = 0;

    ClNetInitializeConfigLists(&lists);

    //
    // Convert the enums to a list
    //
    status = ClNetConvertEnumsToConfigList(
                 NetworkEnum,
                 InterfaceEnum,
                 LocalNodeId,
                 &(lists.InputConfigList),
                 TRUE
                 );

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    //
    // Read the default network role from the database.
    //
    (VOID) DmQueryDword(
               DmClusterParametersKey,
               CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE,
               &defaultRole,
               &defaultRole
               );

    //
    // Run the configuration engine. Existing net names take
    // precedence over connectoid when joining, otherwise change
    // the net name to align with the changed connectoid name.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Running network configuration engine.\n"
        );

    status = ClNetConfigureNetworks(
                 LocalNodeId,
                 LocalNodeName,
                 NmpClusnetEndpoint,
                 defaultRole,
                 RenameConnectoids,
                 &lists,
                 MatchedNetworkCount,
                 NewNetworkCount
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Processing network configuration changes.\n"
        );

    //
    // Process the output - The order is important!
    //
    while (!IsListEmpty(&(lists.DeletedInterfaceList))) {
        listEntry = RemoveHeadList(&(lists.DeletedInterfaceList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpDeleteInterface(
                     JoinSponsorBinding,
                     configEntry->InterfaceInfo.Id,
                     configEntry->InterfaceInfo.NetworkId,
                     &networkDeleted
                     );

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    while (!IsListEmpty(&(lists.UpdatedInterfaceList))) {
        listEntry = RemoveHeadList(&(lists.UpdatedInterfaceList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpSetInterfaceInfo(
                     JoinSponsorBinding,
                     &(configEntry->InterfaceInfo)
                     );

        if (status == ERROR_SUCCESS && configEntry->UpdateNetworkName) {

            CL_ASSERT(JoinSponsorBinding == NULL);

            //
            // Note: this function must not be called with the NM lock
            // held.
            //
            status = NmpSetNetworkName(
                         &(configEntry->NetworkInfo)
                         );
        }

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    while (!IsListEmpty(&(lists.CreatedInterfaceList))) {
        listEntry = RemoveHeadList(&(lists.CreatedInterfaceList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpCreateInterface(
                     JoinSponsorBinding,
                     &(configEntry->InterfaceInfo)
                     );

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    while (!IsListEmpty(&(lists.CreatedNetworkList))) {
        listEntry = RemoveHeadList(&(lists.CreatedNetworkList));
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        status = NmpCreateNetwork(
                     JoinSponsorBinding,
                     &(configEntry->NetworkInfo),
                     &(configEntry->InterfaceInfo)
                     );

        ClNetFreeConfigEntry(configEntry);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    ClNetFreeConfigLists(&lists);

    return(status);

} // NmpConfigureNetworks

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\setpass.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    setpass.c

Abstract:

    Routines for setting the cluster service account password.

Author:

    Rui Hu (ruihu) 22-June-2001

Revision History:

--*/

#define UNICODE 1

#include "nmp.h"
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wincrypt.h>



/////////////////////////////////////////////////////////////////////////////
//
// General information about using the Crypto API
//
// Use CryptAcquireContext CRYPT_VERIFYCONTEXT for hashing and bulk 
// encryption. The verify-context makes this call a bit faster.
//
// Use CryptGenRandom to generate the salt for your encryption key.
//
// Grab 20 bytes of previously agreed base data.  
// Youll use it for your encryption key, and for the Mac key.
//
// To generate your MAC, hash the first 10 bytes of base data.  Then call 
// CryptDeriveKey CALG_RC2 and specify 128 bit key size.  Then call 
// CryptSetKeyParam KP_EFFECTIVE_KEYLEN and specify 128 bit effective key 
// size.  Then call CryptCreateHash CALG_MAC, and specify the rc2 key you 
// just created.  Then hash all of your message using this Mac, and extract 
// the 8 byte result.
//
// Calling CryptHashData() to hash all of your message. All of my 
// message = salt + encrypted message. Using CryptGetHashParam() to 
// extract the 8 byte result.
//
// To generate your encryption key, hash the second 10 bytes of base data.  
// Then hash 16 bytes of random salt.  The call CryptDeriveKey CALG_RC2 and 
// specify 128 bit key size.  Then encrypt your message data.  Dont encrypt 
// your salt or your Mac result; those can be sent in the clear.
//
//////////////////////////////////////////////////////////////////////////////


             
/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////

LPWSTR NmpLastNewPasswordEncrypted = NULL;
DWORD NmpLastNewPasswordEncryptedLength = 0;
             

/////////////////////////////////////////////////////////////////////////////
//
// Function Declaration
//
/////////////////////////////////////////////////////////////////////////////

DWORD 
NmpGetSharedCommonKey(
    OUT BYTE **SharedCommonKey,
    OUT DWORD *SharedCommonKeyLen,
    OUT BYTE **SharedCommonKeyFirstHalf,
    OUT DWORD *SharedCommonKeyFirstHalfLen,
    OUT BYTE **SharedCommonKeySecondHalf,
    OUT DWORD *SharedCommonKeySecondHalfLen
    );


DWORD 
NmpDeriveSessionKeyEx(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *BaseData, 
    IN DWORD BaseDataLen,
    IN BYTE *SaltBuffer,
    IN DWORD SaltBufferLen,
    OUT HCRYPTKEY *CryptKey
    );

/////////////////////////////////////////////////////////////////////////////
//
// Helper Functions
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpProtectData(IN PVOID Data,
               IN DWORD DataLength,
               OUT PVOID *EncryptedData,
               OUT DWORD *EncryptedDataLength
               )

/*++

Routine Description:

    Encrypt data using DP API.
    
Notes:

   The memory where EncryptedData points to is allocated by the system.
   User is responsible to call LocalFree(EncryptedData) to release the
   memory after its usage.     
    
--*/
{
    DWORD                  Status = ERROR_SUCCESS;
    BOOL                   Success;
    DATA_BLOB              DataIn;
    DATA_BLOB              DataOut;

    DataIn.pbData = Data;
    DataIn.cbData = DataLength;

    Success = CryptProtectData(&DataIn,  // data to be encrypted
                               NULL,  // description string
                               NULL,  
                               NULL,  
                               NULL,  
                               0, // flags
                               &DataOut  // encrypted data
                               );
    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to encrypt data using CryptProtectData, "
            "status %1!u!.\n",
            Status
            );
        goto error_exit;
    }

    *EncryptedData = DataOut.pbData;
    *EncryptedDataLength = DataOut.cbData;

error_exit:

    return (Status);
} // NmpProtectData()


DWORD
NmpUnprotectData(       
    IN PVOID EncryptedData,
    IN DWORD EncryptedDataLength,
    OUT PVOID     * Data,                        
    OUT DWORD     * DataLength
    )
/*++

Routine Description:

    Decrypt data using DP API.

Arguments:

    

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.
    
Notes:
  
   Memory is allocated for Data by the system. User is responsible to 
   release this memory using LocalFree(Data) after its usage.    

--*/
{
    BOOL                   Success;
    DATA_BLOB              DataIn;
    DATA_BLOB              DataOut;
    DWORD                  Status = ERROR_SUCCESS;

    ZeroMemory(&DataOut, sizeof(DataOut));

    DataIn.pbData = EncryptedData;
    DataIn.cbData = EncryptedDataLength;

    Success = CryptUnprotectData(&DataIn,  // data to be decrypted
                                 NULL, 
                                 NULL, 
                                 NULL, 
                                 NULL, 
                                 0, // flags
                                 &DataOut  // decrypted data
                                 );


    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to decrypt data using CryptUnprotectData, "
            "status %1!u!.\n",
            Status
            );
        goto error_exit;
    }

    *Data = DataOut.pbData;
    *DataLength = DataOut.cbData;

error_exit:

   return (Status);

} // NmpUnprotectData()

DWORD 
NmpCreateCSPHandle(
    OUT HCRYPTPROV *CryptProvider
    )
/*++

Routine Description:

 

Arguments:

    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    
--*/
{

    DWORD    ReturnStatus;
    BOOL     Success;

    //
    // Get a handle to default key container within CSP MS_ENHANCED_PROV. 
    //
    Success = CryptAcquireContext(
                  CryptProvider,        // output: handle to crypto provider
                  NULL,                 // default key container 
                  MS_ENHANCED_PROV,     // provider name
                  PROV_RSA_FULL,        // provider type
                  CRYPT_VERIFYCONTEXT   // don't need private keys
                  );

    if (!Success) 
    {
        ReturnStatus = GetLastError();

        if (ReturnStatus == NTE_BAD_KEYSET)
        {   //
            // Create a new key container
            //
            Success = CryptAcquireContext(
                          CryptProvider, 
                          NULL, 
                          MS_ENHANCED_PROV, 
                          PROV_RSA_FULL, 
                          CRYPT_NEWKEYSET | CRYPT_VERIFYCONTEXT 
                          );
        }

        if (!Success)
        {
            ReturnStatus = GetLastError();

            ClRtlLogPrint(
                LOG_CRITICAL, 
                "[NM] CreateCSPHandle: Failed to acquire crypto context, "
                "status %1!u!.\n",
                ReturnStatus
                ); 

            return ReturnStatus;
        }
    }

    return(ERROR_SUCCESS);

} // NmpCreateCSPHandle()


DWORD
NmpCreateRandomNumber(OUT PVOID * RandomNumber,
                      IN  DWORD  RandomNumberSize
                      )
/*++
Routine Description:

    Create a random number.

Arguments:
    
    RandomNumber - [OUT] A pointer to random number generated.
    RandomNumberSize - [IN] The size of random number to be generated in
                            number of bytes. 

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

Notes:

    On successful return, the system allocates memory for RandomNumber.
    User is responsible to release the memory using LocalFree() after its usage.
    
                                     
--*/
{
    DWORD status = ERROR_SUCCESS;
    BOOL GenRandomSuccess = FALSE;
    PBYTE randomNumber;

    randomNumber = LocalAlloc(0, RandomNumberSize);

    if (randomNumber == NULL) 
    {
        ClRtlLogPrint(LOG_CRITICAL, 
                      "[NM] Failed to allocate %1!u! bytes.\n",
                      RandomNumberSize
                      );
        status = ERROR_NOT_ENOUGH_MEMORY;
        return (status);
    }

    GenRandomSuccess = CryptGenRandom(NmCryptServiceProvider,
                                      RandomNumberSize,
                                      randomNumber
                                      );

    if (!GenRandomSuccess) 
    {
        status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] Unable to generate random number, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }


#ifdef MULTICAST_DEBUG
    NmpDbgPrintData(L"NmpCreateRandomNumber:",
                    randomNumber,
                    RandomNumberSize
                    );
#endif



error_exit:

    if (status == ERROR_SUCCESS)
    {
        *RandomNumber = randomNumber;
    }

    return status;

} // NmpCreateRandomNumber


DWORD 
NmpDeriveSessionKey(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *SaltBuffer,
    IN DWORD SaltBufferLen,
    OUT HCRYPTKEY *CryptKey
    )
/*++

Routine Description:

    This function derives a session key for encryption/decryption. 
    The derived session key is based on shared NM cluster key and
    SaltBuffer. 

Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                            key is to be generated.    

    Flags - [IN] Specifies the type of key generated.
    
    SaltBuffer - [IN] Pointer to Salt.
    
    CryptKey - [OUT] Pointer to session key. 
    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

   The hash algorithm used is CALG_MD5.
 
--*/
{
    HCRYPTHASH CryptHash = 0;
    DWORD Status;
    BOOL Success;
    BYTE *SharedCommonKey = NULL;
    DWORD SharedCommonKeyLen = 0;
    BYTE *SharedCommonKeyFirstHalf = NULL;
    DWORD SharedCommonKeyFirstHalfLen = 0;
    BYTE *SharedCommonKeySecondHalf = NULL;
    DWORD SharedCommonKeySecondHalfLen = 0;

    //
    // Get the base key to be used to encrypt the data
    //
    Status = NmpGetSharedCommonKey(
                 &SharedCommonKey,
                 &SharedCommonKeyLen,
                 &SharedCommonKeyFirstHalf,
                 &SharedCommonKeyFirstHalfLen,
                 &SharedCommonKeySecondHalf,
                 &SharedCommonKeySecondHalfLen
                 );

    if (Status != ERROR_SUCCESS) {
        goto ErrorExit;
    }


    Status = NmpDeriveSessionKeyEx(CryptProv,
                                     EncryptionAlgoId,
                                     Flags,
                                     SharedCommonKey, // BaseData
                                     SharedCommonKeyLen,  // BaseDataLen
                                     SaltBuffer,
                                     SaltBufferLen,
                                     CryptKey
                                     );


    if (Status != ERROR_SUCCESS) {
        goto ErrorExit;
    }

ErrorExit:

    if (SharedCommonKey != NULL)
    {
        RtlSecureZeroMemory(SharedCommonKey, SharedCommonKeyLen);
        HeapFree(GetProcessHeap(), 0, SharedCommonKey);  
        SharedCommonKey = NULL;
        SharedCommonKeyLen = 0;
        SharedCommonKeyFirstHalf = NULL;
        SharedCommonKeyFirstHalfLen = 0;
        SharedCommonKeySecondHalf = NULL;
        SharedCommonKeySecondHalfLen = 0;
    }

    return Status;

} // NmpDeriveSessionKey()



DWORD 
NmpDeriveSessionKeyEx(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *BaseData, 
    IN DWORD BaseDataLen,
    IN BYTE *SaltBuffer,
    IN DWORD SaltBufferLen,
    OUT HCRYPTKEY *CryptKey
    )
/*++

Routine Description:

    This function derives a session key for encryption/decryption.  

Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       key is to be generated.    

    Flags - [IN] Specifies the type of key generated.
    
    BaseData - [IN] The base data value from which a cryptographic session 
               key is derived.
               
    BaseDataLen - [IN] Length in bytes of the input BaseData buffer.
    
    SaltBuffer - [IN] Pointer to Salt.
    
    CryptKey - [OUT] Pointer to session key. 
    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    
--*/
{
    HCRYPTHASH CryptHash = 0;
    DWORD Status;
    BOOL Success;


    //
    // Create a hash object
    //
    Success = CryptCreateHash(
                  CryptProv, 
                  CALG_MD5,  // MD5 hashing algorithm.
                  0, 
                  0, 
                  &CryptHash  // output: a handle to the new hash object.
                  );

    if (!Success)
    {
        Status=GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DeriveSessionKey: Failed to create hash, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    //
    // Add BaseData to hash object
    //
    Success = CryptHashData(
                  CryptHash, 
                  BaseData,  
                  BaseDataLen, 
                  0 // Flags
                  );

    if (!Success)
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DeriveSessionKey: Failed to hash base data, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }
    
    //
    // Add Salt to hash object
    //
    Success = CryptHashData(CryptHash, SaltBuffer, SaltBufferLen, 0);

    if (!Success)
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DeriveSessionKey: Failed to hash salt data, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   
    
    //
    // Derive a session key from the hash object
    //
    Success = CryptDeriveKey(
                  CryptProv,  
                  EncryptionAlgoId, 
                  CryptHash, 
                  Flags,  
                  CryptKey // output: handle of the generated key
                  );

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DeriveSessionKey: Failed to derive key, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    Status = ERROR_SUCCESS;

ErrorExit:

    // Destroy hash object
    if (CryptHash)
    {
        if (!CryptDestroyHash(CryptHash))
        {
            ClRtlLogPrint(
                LOG_ERROR, 
                "[NM] DeriveSessionKey: Failed to destroy hash, " 
                "status %1!u!.\n",
                GetLastError()
                );
        }
    }

    return Status;

} // NmpDeriveSessionKeyEx()


DWORD
NmpEncryptMessage( 
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    OUT BYTE *SaltBuffer,
    IN DWORD SaltBufferLen,
    IN BYTE *BaseData, 
    IN DWORD BaseDataLen,
    IN BYTE *InputEncryptData, 
    IN OUT DWORD *EncryptDataLen,
    IN DWORD InputEncryptDataBufLen, 
    OUT BYTE **OutputEncryptData,
    IN BOOLEAN CreateSaltFlag 
    )

/*++

Routine Description:

    This function encrypts message (data).  

Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       key is to be generated.    

    Flags - [IN] Specifies the type of key generated.
    
    SaltBuffer - [OUT] Pointer to Salt.
    
    BaseData - [IN] The base data value from which a cryptographic session 
               key is derived.
               
    BaseDataLen - [IN] Length in bytes of the input BaseData buffer.
    
    InputEncryptData - [IN] Message (data) to be encrypted.
    
    EncryptDataLen - [IN/OUT] Before calling this function, the DWORD value 
                     is set to the number of bytes to be encrypted. Upon 
                     return, the DWORD value contains the length of the 
                     encrypted message (data) in bytes 
                     
    InputEncryptDataBufLen - [IN] Length in bytes of the input 
                             InputEncryptData buffer. This value may be 
                             bigger than EncryptDataLen when it is an 
                             input parameter.
                             
    OutputEncryptData - [OUT] Encrypted message (data).
    
    CreateSaltFlag - [IN] Flag indicating if salt should be generated.

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    
--*/
{

    
    HCRYPTKEY CryptKey = 0;
    DWORD Status;
    DWORD i;
    DWORD dwOriginalEncryptDataLen = 0;
    DWORD dwOutputEncryptDataBufLen = 0;
    BOOL Success;


    //
    // Create the random salt bytes if needed
    //
    if (CreateSaltFlag == TRUE) 
    {
        Success = CryptGenRandom(
                      CryptProv, 
                      SaltBufferLen, // bytes of random data to generate
                      SaltBuffer          // output buffer 
                      );

        if (!Success) 
        {
            Status = GetLastError();
            ClRtlLogPrint(
                LOG_CRITICAL, 
                "[NM] EncryptMessage: Unable to generate salt data, "
                "status %1!u!.\n",
                Status
                );
            goto ErrorExit;
        }
    }

    //
    // Derive the session key from the base data and salt
    //
    Status = NmpDeriveSessionKeyEx(
                 CryptProv,
                 EncryptionAlgoId,   // RC2 block encryption algorithm
                 Flags, // NMP_KEY_LENGTH,  // key length = 128 bits
                 BaseData, 
                 BaseDataLen,
                 SaltBuffer,
                 SaltBufferLen,
                 &CryptKey
                 );

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] EncryptMessage: Failed to derive session key, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }

    //
    // Encrypt data
    //
    
    //
    // Save length of data to be encrypted
    //
    dwOriginalEncryptDataLen = *EncryptDataLen;  

    //
    // Call CryptEncrypt() with pbData as NULL to determine the number of 
    // bytes required for the returned data.
    //
    Success = CryptEncrypt(
                  CryptKey,              // Handle to the encryption key.
                  0, 
                  TRUE,                  // Final
                  0, 
                  NULL,                  // Pointer to data to be encrypted
                  EncryptDataLen,        // Output: size of buffer required
                  InputEncryptDataBufLen // Length in bytes of input buffer
                  );

    if (!Success) 
    {
        Status=GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] EncryptMessage: First encryption pass failed, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }       
 
    dwOutputEncryptDataBufLen = *EncryptDataLen;

    //
    // Allocate a buffer sufficient to hold encrypted data.
    //
    *OutputEncryptData = HeapAlloc(
                             GetProcessHeap(), 
                             HEAP_ZERO_MEMORY, 
                             dwOutputEncryptDataBufLen
                             );

    if (*OutputEncryptData == NULL)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] EncryptMessage: Failed to allocate %1!u! bytes for "
            "encrypted data buffer.\n",
            dwOutputEncryptDataBufLen
            );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(*OutputEncryptData, InputEncryptData, dwOriginalEncryptDataLen);

    //
    // Set EncryptDataLen back to its original
    //
    *EncryptDataLen = dwOriginalEncryptDataLen; 

    Success = CryptEncrypt(
                  CryptKey, 
                  0, 
                  TRUE, 
                  0, 
                  (BYTE *)*OutputEncryptData, 
                  EncryptDataLen, 
                  dwOutputEncryptDataBufLen
                  );

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] EncryptMessage: second encryption pass failed, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }       

    Status = ERROR_SUCCESS;

ErrorExit:

    if ( (Status != ERROR_SUCCESS) && (*OutputEncryptData != NULL) )
    {
        if (!HeapFree(GetProcessHeap(), 0, *OutputEncryptData))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] EncryptMessage: Failed to free encryption buffer, "
                "status %1!u!.\n",
                GetLastError()
                );  
            
        }

        *OutputEncryptData = NULL;
    }
  
    // Destroy CryptKey
    if (CryptKey) 
    {
        if (!CryptDestroyKey(CryptKey))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] EncryptMessage: Failed to free encryption key, "
                "status %1!u!.\n",
                GetLastError()
                );
        }
    }

    return Status;

} //NmpEncryptMessage()


DWORD 
NmpCreateMAC(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *BaseData,
    IN DWORD BaseDataLen,
    IN BYTE *InputData1,
    IN DWORD InputData1Len,
    IN BYTE *InputData2,
    IN DWORD InputData2Len,
    OUT BYTE **ReturnData,
    OUT DWORD *ReturnDataLen
    )
/*++

Routine Description:

    This fucntion creates a MAC (Message Authorization Code) for InputData.
    
Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       key is to be generated.    

    Flags - [IN] Specifies the type of key generated.
    
    BaseData - [IN] The base data value from which a cryptographic session key is 
               derived.
               
    BaseDataLen - [IN] Length in bytes of the input BaseData buffer.
    
    InputData1 - [IN] Pointer to input data.
    
    InputData1Len - [IN] Length of input data.
    
    InputData2 - [IN] Pointer to input data.
    
    InputData2Len - [IN] Length of input data.
    
    ReturnData - [OUT] MAC created.
    
    ReturnDataLen - [OUT] Length of MAC created.
     
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    
--*/
{
    HCRYPTHASH CryptHash[2];
    HCRYPTKEY CryptKey = 0;
    DWORD dwKeyLen = 0;
    DWORD Status; 
    BOOL Success;


    CryptHash[0] = 0;
    CryptHash[1] = 0;

    //
    // Create a hash object
    //
    Success = CryptCreateHash(CryptProv, CALG_MD5, 0, 0, &CryptHash[0]);

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to create first hash, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    //
    // add BaseData to hash object
    //
    Success = CryptHashData(CryptHash[0], BaseData, BaseDataLen, 0);

    if (!Success)
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to add base data to hash, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }

    //
    // Derive a session key from the hash object
    //
    Success = CryptDeriveKey(
                  CryptProv, 
                  EncryptionAlgoId, 
                  CryptHash[0], 
                  Flags, 
                  &CryptKey
                  );

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to derive session key, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }

    //
    // Set effective key length to 128 bits
    //
    dwKeyLen = 128;

    Success = CryptSetKeyParam(
                  CryptKey, 
                  KP_EFFECTIVE_KEYLEN,  
                  (BYTE *) &dwKeyLen, 
                  0
                  );

    if (!Success)
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to set key length, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    //
    // Create a hash object
    //
    Success = CryptCreateHash(
                  CryptProv, 
                  CALG_MAC, 
                  CryptKey, 
                  0, 
                  &CryptHash[1]
                  );

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to create second hash, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    //
    // add InputData1 to hash object
    //
    Success = CryptHashData(CryptHash[1], InputData1, InputData1Len, 0);

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to add InputData1 to hash, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    //
    // add InputData2 to hash object
    //
    Success = CryptHashData(CryptHash[1], InputData2, InputData2Len, 0);

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to add InputData2 to hash, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    //
    // Retrieve hash value of hash object
    //
    Success = CryptGetHashParam(
                  CryptHash[1],  // Handle to the hash object being queried. 
                  HP_HASHVAL,    // Hash value 
                  *ReturnData,   // Output: the specified value data.
                  ReturnDataLen, // input buffer size, output bytes stored  
                  0              // Reserved
                  );

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] CreateMAC: Failed to retrieve hash value, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }   

    Status = ERROR_SUCCESS;

ErrorExit:

    // Destroy hash object
    if (CryptHash[0])
        if (!CryptDestroyHash(CryptHash[0]))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] CreateMAC: Failed to free first hash, status %1!u!.\n",
                GetLastError());
        }

    if (CryptHash[1])
        if (!CryptDestroyHash(CryptHash[1]))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] CreateMAC: Failed to free second hash, status %1!u!.\n",
                GetLastError());
        }

    // Destroy CryptKey
    if (CryptKey)
    {
        if (!CryptDestroyKey(CryptKey))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] CreateMAC: Failed to free key, status %1!u!.\n",
                GetLastError()
                );
        }
    }

    return Status;

} // NmpCreateMAC()


DWORD
NmpGetCurrentNumberOfUpAndPausedNodes(
    VOID
    )
/*++

Routine Description:

    Counts the number of nodes that are in the UP or PAUSED states.

Arguments:

    None                                                    
    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    Must be called with NmpLock held.
    
--*/
{
    DWORD       dwCnt = 0;
    PLIST_ENTRY pListEntry;
    PNM_NODE    node;


    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        node = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

        if (NM_NODE_UP(node))
        {
            dwCnt++;
        }
    }

    return(dwCnt);

} // NmpGetCurrentNumberOfUpAndPausedNodes()


DWORD 
NmpGetSharedCommonKey(
    OUT BYTE **SharedCommonKey,
    OUT DWORD *SharedCommonKeyLen,
    OUT BYTE **SharedCommonKeyFirstHalf,
    OUT DWORD *SharedCommonKeyFirstHalfLen,
    OUT BYTE **SharedCommonKeySecondHalf,
    OUT DWORD *SharedCommonKeySecondHalfLen
    )
/*++

Routine Description:

 

Arguments:

    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    
--*/
{
    DWORD Status;

    //
    // Figure out how much memory to allocate for the key buffer
    //
    Status = NmpGetClusterKey(NULL, SharedCommonKeyLen);

    if (Status == ERROR_FILE_NOT_FOUND)
    {
        Status = NmpCreateClusterInstanceId();

        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(
                LOG_CRITICAL, 
                "[NM] GetSharedCommonKey: Failed to create instance ID, "
                "status %1!u!.\n",
                Status
                );
            goto ErrorExit;
        }

        Status = NmpRederiveClusterKey();

        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(
                LOG_CRITICAL, 
                "[NM] GetSharedCommonKey: Failed to regenerate key, "
                "status %1!u!.\n",
                Status
                );
            goto ErrorExit;
        }

        Status = NmpGetClusterKey(NULL, SharedCommonKeyLen);
    }

    if (Status != ERROR_INSUFFICIENT_BUFFER)
    {
        CL_ASSERT(Status == ERROR_INSUFFICIENT_BUFFER);
        Status = ERROR_INVALID_DATA;
        goto ErrorExit;
    }
#ifdef SetServiceAccountPasswordDebug
    else
    {
        ClRtlLogPrint(
            LOG_ERROR, 
            "[NM] NmpGetSharedCommonKey(): *SharedCommonKeyLen=%1!u!.\n",
            *SharedCommonKeyLen
            );
    }
#endif

    *SharedCommonKey = HeapAlloc(
                           GetProcessHeap(), 
                           HEAP_ZERO_MEMORY, 
                           *SharedCommonKeyLen
                           );

    if (*SharedCommonKey == NULL)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] GetSharedCommonKey: Failed to allocate %1!u! bytes "
            "for key buffer.\n",
            *SharedCommonKeyLen
            );
        
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    Status = NmpGetClusterKey(*SharedCommonKey, SharedCommonKeyLen);

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] GetSharedCommonKey: Failed to get cluster key, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }

    *SharedCommonKeyFirstHalf = *SharedCommonKey;
    *SharedCommonKeyFirstHalfLen = *SharedCommonKeyLen/2;
    *SharedCommonKeySecondHalf = *SharedCommonKeyFirstHalf + 
                                 *SharedCommonKeyFirstHalfLen;
    *SharedCommonKeySecondHalfLen = *SharedCommonKeyLen - 
                                    *SharedCommonKeyFirstHalfLen;

    Status = ERROR_SUCCESS;
    
ErrorExit:

    if ( (Status != ERROR_SUCCESS) && (*SharedCommonKey != NULL) ) {
        if (!HeapFree(GetProcessHeap(), 0, *SharedCommonKey))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] GetSharedCommonKey: Failed to free key buffer, "
                "status %1!u!.\n",
                 GetLastError()
                );  
            
        }

        *SharedCommonKey = NULL;
    }

    return Status;

}   // NmpGetSharedCommonKey()



DWORD 
NmpVerifyMAC(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *BaseData,
    IN DWORD BaseDataLen,
    IN BYTE *InputData1,
    IN DWORD InputData1Len,
    IN BYTE *InputData2,
    IN DWORD InputData2Len,
    IN BYTE **ReturnData,
    IN DWORD *ReturnDataLen,
    IN BYTE* InputMACData,
    IN DWORD InputMACDataLen
    )
/*++

Routine Description:

    This fucntion checks if a message was corrupted on wire.
    
Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       key is to be generated.    

    Flags - [IN] Specifies the type of key generated.
    
    BaseData - [IN] The base data value from which a cryptographic session 
               key is derived.
    
    BaseDataLen - [IN] Length in bytes of the input BaseData buffer.
    
    InputData1 - [IN] Pointer to input data.
    
    InputData1Len - [IN] Length of input data.
    
    InputData2 - [IN] Pointer to input data.
    
    InputData2Len - [IN] Length of input data.
    
    InputMACData - [IN] MAC associated with input data.
    
    InputMACDataLan - [IN] Length of MAC.
     
Return Value:

    ERROR_SUCCESS if message was not corrupted.
    Win32 error code otherwise.

Notes:

    
--*/

{
    DWORD dwKeyLen = 0;
    DWORD Status; 
    DWORD i;

    Status = NmpCreateMAC(
                 CryptProv, 
                 EncryptionAlgoId,
                 Flags,
                 BaseData, 
                 BaseDataLen, 
                 InputData1, 
                 InputData1Len, 
                 InputData2, 
                 InputData2Len,
                 ReturnData, 
                 ReturnDataLen
                 );

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] VerifyMAC: Failed to create local MAC, status %1!u!.\n",
            Status
            );
        goto ErrorExit;

    }

    if (*ReturnDataLen != InputMACDataLen)
    {
        Status = CRYPT_E_HASH_VALUE; 
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] VerifyMAC: Verification failed because the MAC data length "
            "does not match.\n"
            );
        goto ErrorExit;
    }


    if (memcmp(*ReturnData, InputMACData, InputMACDataLen) != 0)
    {
        Status = ERROR_FILE_CORRUPT;
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] VerifyMAC: Verification failed because the MAC data does "
            "not match.\n"
            );
        goto ErrorExit;
    }


    Status = ERROR_SUCCESS;

ErrorExit:

    return Status;

} // NmpVerifyMAC()


DWORD
NmpDecryptMessage(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN BYTE *SaltBuffer,
    IN DWORD SaltBufferLen,
    IN BYTE *BaseData,
    IN DWORD BaseDataLen,
    IN BYTE *DecryptData,
    IN OUT DWORD *DecryptDataLen,
    OUT BYTE **RetData
    )

/*++

Routine Description:

    This function decrypts message (data).

Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).  
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       key is to be generated.    

    Flags - [IN] Specifies the type of key generated.
    
    SaltBuffer - [IN] Salt.
    
    BaseData - [IN] The base data value from which a cryptographic session key is derived.
    
    BaseDataLen - [IN] Length in bytes of the input BaseData buffer.
    
    DecryptData - [IN] Message (data) to be decrypted.
    
    DecryptDataLen - [IN/OUT] Before calling this function, the DWORD value is set to the number
                              of bytes to be decrypted. Upon return, the DWORD value contains the
                              number of bytes of the decrypted plaintext. 
    
    RetData - [OUT] Decrypted plaintext.


Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    
--*/
{
    HCRYPTKEY CryptKey = 0;
    DWORD Status;
    BOOL Success;


    Status = NmpDeriveSessionKeyEx(
                 CryptProv,
                 EncryptionAlgoId,
                 Flags,
                 BaseData, 
                 BaseDataLen,
                 SaltBuffer,
                 SaltBufferLen,
                 &CryptKey
                 );

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DecryptMessage: Failed to derive session key, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }

    //
    // Decrypt data
    //
    *RetData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *DecryptDataLen);

    if (*RetData == NULL)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DecryptMessage: Failed to allocate %1!u! bytes for "
            "decryption buffer.\n",
            *DecryptDataLen
            );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(*RetData, DecryptData, *DecryptDataLen);

    Success = CryptDecrypt(
                  CryptKey, 
                  0, 
                  TRUE,          // Final
                  0, 
                  *RetData,      // Buffer holding the data to be decrypted.
                  DecryptDataLen // input buffer length, output bytes decrypted
                  );

    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] DecryptMessage: Failed to decrypt message, status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }       
    
    Status = ERROR_SUCCESS;

ErrorExit:

    if ( (Status != ERROR_SUCCESS) && (*RetData != NULL) )
    {
        if (!HeapFree(GetProcessHeap(), 0, *RetData))
        {
            ClRtlLogPrint(
                LOG_ERROR, 
                "[NM] DecryptMessage: Failed to free decryption buffer, "
                "status %1!u!\n",
                GetLastError()
                );  
            
        }
        *RetData = NULL;
    }

    //
    // Destroy CyrptKey
    //
    if (CryptKey)
        if (!CryptDestroyKey(CryptKey))
        {
            ClRtlLogPrint(
                LOG_ERROR, 
                "[NM] DecryptMessage: Failed to free session key, "
                "status %1!u!.\n",
                GetLastError()
                );
        }

    return Status;

}  // NmpDecryptMessage()


DWORD 
NmpEncryptDataAndCreateMAC(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EncryptionAlgoId,
    IN DWORD Flags,
    IN PBYTE Data,
    IN DWORD DataLength,
    IN PVOID EncryptionKey,
    IN DWORD EncryptionKeyLength,
    IN BOOL CreateSalt,
    OUT PBYTE *Salt,  
    IN DWORD SaltLength,
    OUT PBYTE *EncryptedData,
    OUT DWORD *EncryptedDataLength,
    OUT PBYTE *MAC,  
    IN OUT DWORD *MACLength
    )

/*++

Routine Description:

    This function encrypts data and creates MAC.  

Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       session key is to be generated.    

    Flags - [IN] Specifies the type of session key to be generated.
    
    Data - [IN] Data to be encrypted.
    
    DataLength - [IN]  Length in bytes of Data.
    
    EncryptionKey - [IN] The base data value from which a cryptographic session 
                         key is derived.
               
    EncryptionKeyLength - [IN] Length in bytes of the input EncryptionKey.
        
    CreateSalt - [IN] Flag indicating if salt should be generated.

    Salt - [OUT] Salt created.
    
    SaltLength - [IN] Length in bytes of Salt.
        
    EncryptData - [OUT] Encrypted data. 
                     
    EncryptedDataLength - [OUT] Length in bytes of EncryptedData.
    
    MAC - [OUT] MAC (Message Authorization Code) created.
    
    MACLength - [IN/OUT] Before calling this function, the DWORD value 
                     is set to the expected number of bytes to be generated
                     for MAC. Upon return, the DWORD value contains the length  
                     of the MAC generated in bytes. 

                         
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

   On successful return, memory is allocated for Salt, EncryptedData, and 
   MAC. User is responsible to call HeapFree() to free the memory after usage. 
    
--*/
{
    PBYTE salt = NULL;
    PBYTE encryptedData = NULL;
    DWORD encryptedDataLength;
    PBYTE mac = NULL;
    DWORD macLength;
    DWORD Status = ERROR_SUCCESS;
    PBYTE EncryptionKeyFirstHalf;
    DWORD EncryptionKeyFirstHalfLength;
    PBYTE EncryptionKeySecondHalf;
    DWORD EncryptionKeySecondHalfLength;



    EncryptionKeyFirstHalf = EncryptionKey;
    EncryptionKeyFirstHalfLength = EncryptionKeyLength/2;
    EncryptionKeySecondHalf = EncryptionKeyFirstHalf + 
                                 EncryptionKeyFirstHalfLength;
    EncryptionKeySecondHalfLength = EncryptionKeyLength - 
                                    EncryptionKeyFirstHalfLength;



    //
    // Allocate space for Salt
    //
    if (CreateSalt == TRUE) 
    {
        salt = HeapAlloc(
                      GetProcessHeap(), 
                      HEAP_ZERO_MEMORY, 
                      SaltLength
                      );

        if (salt == NULL)
        {
            ClRtlLogPrint(
                LOG_CRITICAL, 
                "[NM] NmpEncryptDataAndCreateMAC: Failed to allocate %1!u! "
                "bytes of memory for encryption salt.\n",
                SaltLength
                );

            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }
    else
    {
        salt = *Salt;
    }


    //
    // Encrypt data
    //

    encryptedDataLength = DataLength;

    Status = NmpEncryptMessage(CryptProv,
                               EncryptionAlgoId,
                               Flags,
                               salt,
                               SaltLength,
                               EncryptionKeyFirstHalf,
                               EncryptionKeyFirstHalfLength,
                               Data,
                               &encryptedDataLength,
                               DataLength,
                               &encryptedData,
                               TRUE
                               );

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] NmpEncryptDataAndCreateMAC: Failed to encrypt password, "
            "status %1!u!.\n",
            Status
            );

        goto ErrorExit;
    }

  
    //
    // Allocate space for MAC
    //

    mac = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *MACLength);
    
    if (mac == NULL)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] NmpEncryptDataAndCreateMAC: Failed to allocate %1!u! "
            "bytes for MAC.\n",
            *MACLength
            );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }


    //
    // Create MAC 
    //
    macLength = *MACLength;

    Status = NmpCreateMAC(
                 CryptProv,
                 EncryptionAlgoId,
                 Flags,
                 EncryptionKeySecondHalf,
                 EncryptionKeySecondHalfLength,
                 salt,
                 SaltLength,
                 encryptedData,
                 encryptedDataLength,
                 &mac,
                 &macLength
                 );

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] NmpEncryptDataAndCreateMAC: Failed to create MAC, "
            "status %1!u!.\n",
            Status
            );
        goto ErrorExit;
    }

    if (CreateSalt == TRUE) 
    {
        *Salt = salt;
    }
    *EncryptedData = encryptedData;
    *EncryptedDataLength = encryptedDataLength;
    *MAC = mac;
    *MACLength = macLength;

ErrorExit:


    if (Status != ERROR_SUCCESS) 
    {
        if (salt != NULL) 
        {
            HeapFree(GetProcessHeap(), 0, salt);
        }
        if (mac != NULL) 
        {
            HeapFree(GetProcessHeap(), 0, mac);
        }
    }

    return (Status);
    
} // NmpEncryptDataAndCreateMAC

DWORD
NmpVerifyMACAndDecryptData(
    IN HCRYPTPROV CryptProv,
    IN ALG_ID EcnryptionAlgoId,
    IN DWORD Flags,
    IN PBYTE MAC,
    IN DWORD MACLength,
    IN DWORD MACExpectedSize,
    IN PBYTE EncryptedData,
    IN DWORD EncryptedDataLength,
    IN PVOID EncryptionKey,
    IN DWORD EncryptionKeyLength,
    IN PBYTE Salt,
    IN DWORD SaltLength,
    OUT PBYTE *DecryptedData,
    OUT DWORD *DecryptedDataLength
    )

/*++

Routine Description:

    This function verifies MAC and decrypts data.  

Arguments:

    CryptProv - [IN] Handle to CSP (Crypto Service Provider).
    
    EncryptionAlgoId - [IN] The symmetric encryption algorithm for which the 
                       session key is to be generated.    

    Flags - [IN] Specifies the type of session key to be generated.
    
    MAC - [IN] MAC (Message Authorization Code) received.
    
    MACLength - [IN] Length in bytes of received MAC. 
    
    MACExpectedSize - [IN] Expected size in bytes of MAC.
    
    EncryptedData - [IN] Encrypted data received.
    
    EncryptedDataLength - [IN]  Length in bytes of encrypted data received.
    
    EncryptionKey - [IN] The base data value from which a cryptographic session 
                         key is derived.
               
    EncryptionKeyLength - [IN] Length in bytes of the input EncryptionKey.
        
    Salt - [IN] Salt received.
    
    SaltLength - [IN] Length in bytes of Salt.
        
    DecryptedData - [OUT] Decrypted data.
    
    DecryptedDataLength - [OUT] Decrypted data length in bytes.
                         
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

   On successful return, memory is allocated for DecryptedData. User is 
   responsible to call HeapFree() to free the memory after usage. 
    
--*/
{
    DWORD ReturnStatus;
    DWORD GenMACDataLen;
    PBYTE GenMACData = NULL;
    PBYTE decryptedData;
    DWORD decryptedDataLength;
    PBYTE EncryptionKeyFirstHalf;
    DWORD EncryptionKeyFirstHalfLength;
    PBYTE EncryptionKeySecondHalf;
    DWORD EncryptionKeySecondHalfLength;


    EncryptionKeyFirstHalf = EncryptionKey;
    EncryptionKeyFirstHalfLength = EncryptionKeyLength/2;
    EncryptionKeySecondHalf = EncryptionKeyFirstHalf + 
                                 EncryptionKeyFirstHalfLength;
    EncryptionKeySecondHalfLength = EncryptionKeyLength - 
                                    EncryptionKeyFirstHalfLength;



    //
    // Verify MAC
    //
    GenMACDataLen = MACExpectedSize;
    GenMACData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, GenMACDataLen);

    if (GenMACData == NULL)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] NmpVerifyMACAndDecryptData: Failed to allocate "
            "%1!u! bytes for MAC.\n",
            GenMACDataLen
            );
        ReturnStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    ReturnStatus = NmpVerifyMAC(
                       CryptProv,
                       EcnryptionAlgoId,
                       Flags,
                       EncryptionKeySecondHalf,
                       EncryptionKeySecondHalfLength,
                       Salt,
                       SaltLength,
                       EncryptedData,
                       EncryptedDataLength,
                       &GenMACData,
                       &GenMACDataLen,
                       MAC,
                       MACLength
                       );

    if (ReturnStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] NmpVerifyMACAndDecryptData: Failed to verify MAC, "
            "status %1!u!\n",
            ReturnStatus
            );
        goto ErrorExit;
    }

    //
    // Decrypt Message
    //
    decryptedDataLength = EncryptedDataLength;

    ReturnStatus = NmpDecryptMessage(
                       CryptProv,
                       EcnryptionAlgoId,
                       Flags,
                       Salt,
                       SaltLength,
                       EncryptionKeyFirstHalf, 
                       EncryptionKeyFirstHalfLength,
                       EncryptedData,
                       &decryptedDataLength,
                       &decryptedData
                       );

    if (ReturnStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] NmpVerifyMACAndDecryptData: Failed to decrypt "
            "message, status %1!u!\n",
            ReturnStatus
            );
        goto ErrorExit;
    }

    *DecryptedData = decryptedData;
    *DecryptedDataLength = decryptedDataLength;

ErrorExit:

    if (GenMACData != NULL) 
    {
        HeapFree(GetProcessHeap(), 0, GenMACData);
    }

    return (ReturnStatus);

} //  NmpVerifyMACAndDecryptData()
                


DWORD NmpCheckDecryptedPassword(BYTE* NewPassword,
                                DWORD NewPasswordLen)
/*++

Routine Description:
    This routine checks if the decrypted new password returned by 
    NmpDecryptMessage (NewPassword) is an eligible UNICODE string 
    with length equal to NewPasswordLen/sizeof(WCHAR)-1.
     

Arguments:
   [IN] NewPassword - Decrypted new password returned by 
                      NmpDecryptMessage.
   [IN] NewPasswordLen - Decrypted new password length returned by 
                         NmpDecryptMessage.
    
Return Value:

    ERROR_SUCCESS if successful.
    ERROR_FILE_CORRUPT if NewPassword is not an eligible UNICODE string with 
    length equal to NewPasswordLen/sizeof(WCHAR)-1.

Notes:

--*/    
{
    DWORD Status = ERROR_SUCCESS;
    BYTE *byte_ptr;
    WCHAR *wchar_ptr;

    if (NewPasswordLen < sizeof(WCHAR)) {  
    // should contain at least UNICODE_NULL
        Status = ERROR_FILE_CORRUPT;
        goto ErrorExit;
    }

    if ( (NewPasswordLen % sizeof(WCHAR))!=0 ) {  
    // Number of bytes should be multiple of sizeof(WCHAR).
        Status = ERROR_FILE_CORRUPT;
        goto ErrorExit;
    }

    byte_ptr = NewPassword + (NewPasswordLen - sizeof(WCHAR));
    wchar_ptr = (WCHAR*) byte_ptr;

    if (*wchar_ptr != UNICODE_NULL) {   
    // UNICODE string should end by UNICODE_NULL
        Status = ERROR_FILE_CORRUPT;
        goto ErrorExit;
    }

    if (NewPasswordLen !=  
        (wcslen((LPWSTR) NewPassword) + 1) * sizeof(WCHAR))  
    // eligible UNICODE string with length equal to NewPasswordLen-1
    {
        Status = ERROR_FILE_CORRUPT;
        goto ErrorExit;
    }

ErrorExit:
    return Status;

} // NmpCheckDecryptedPassword




/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmSetServiceAccountPassword(
    IN LPCWSTR DomainName,
    IN LPCWSTR AccountName,
    IN LPWSTR NewPassword,
    IN DWORD dwFlags,
    OUT PCLUSTER_SET_PASSWORD_STATUS ReturnStatusBuffer,
    IN DWORD ReturnStatusBufferSize,
    OUT DWORD *SizeReturned,
    OUT DWORD *ExpectedBufferSize
    )
/*++

Routine Description:

    Change cluster service account password on Service Control Manager
    Database and LSA password cache on every node of cluster.
    Return execution status on each node.

Arguments:

    DomainName - Domain name of cluster service account
    
    AccountName - Account name of cluster service account
    
    NewPassword - New password for cluster service account.
    
    dwFlags -  Describing how the password update should be made to
               the cluster. The dwFlags parameter is optional. If set, the 
               following value is valid: 
             
                 CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES
                     Apply the update even if some nodes are not
                     actively participating in the cluster (i.e. not
                     ClusterNodeStateUp or ClusterNodeStatePaused).
                     By default, the update is only applied if all 
                     nodes are up.
                      
    ReturnStatusBuffer - Array that captures the return status of the 
                         update handler for each node that attempts to 
                         apply the update.
    
    ReturnStatusBufferSize - Size of ReturnStatusBuffer in number
                             of elements.
                             
    SizeReturned - Number of elements written into ReturnStatusBuffer.
    
    ExpectedBufferSize - specifies the minimum required size of 
                         ReturnStatusBuffer when ERROR_MORE_DATA
                         is returned.

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

--*/

{
    BYTE *SharedCommonKey = NULL;
    DWORD SharedCommonKeyLen = 0;
    BYTE *SharedCommonKeyFirstHalf = NULL;
    DWORD SharedCommonKeyFirstHalfLen = 0;
    BYTE *SharedCommonKeySecondHalf = NULL;
    DWORD SharedCommonKeySecondHalfLen = 0;
    DWORD Status;
    BYTE *EncryptedNewPassword = NULL;
    DWORD EncryptedNewPasswordLen = 0;
    HCRYPTPROV CryptProvider = 0;
    BYTE *SaltBuf = NULL;
    DWORD SaltBufLen = NMP_SALT_BUFFER_LEN;
    BYTE *MACData = NULL;
    DWORD MACDataLen = 0;
    PGUM_NODE_UPDATE_HANDLER_STATUS GumReturnStatusBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwNumberOfUpAndPausedNodes;


    ClRtlLogPrint(
        LOG_NOISE, 
        "[NM] Received a request to change the service account password.\n"
        );   

    NmpAcquireLock();

    if (!NmpLockedEnterApi(NmStateOnline)) 
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] Not in valid state to process request to change the "
             "service account password.\n"
            );

        NmpReleaseLock();

        return ERROR_NODE_NOT_AVAILABLE;
    }

    //
    // Check to see if it is a mixed cluster
    //
    if (NmpIsNT5NodeInCluster == TRUE)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] SetServiceAccountPassword: this cluster contains NT4 or W2K "
            "nodes. The password cannot be changed on this cluster.\n"
            );
        
        NmpReleaseLock();

        Status = ERROR_CLUSTER_OLD_VERSION; 
        goto ErrorExit;
    }
     
    //
    // Check to see if ReturnStatusBuffer is big enough. 
    //
    dwNumberOfUpAndPausedNodes = NmpGetCurrentNumberOfUpAndPausedNodes();


    if (ReturnStatusBufferSize < dwNumberOfUpAndPausedNodes)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] SetServiceAccountPassword: ReturnStatusBuffer is"
            "too small. Needs to be %1!u! bytes.\n",
            dwNumberOfUpAndPausedNodes * sizeof(CLUSTER_SET_PASSWORD_STATUS)
            ); 
    
        NmpReleaseLock();

        *ExpectedBufferSize =  dwNumberOfUpAndPausedNodes;
        Status = ERROR_MORE_DATA; 
        goto ErrorExit;
    }

    //
    // Check to see if all nodes are available
    //
    if ( (dwFlags != CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES) &&
         (dwNumberOfUpAndPausedNodes != NmpNodeCount) 
       )
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] SetServiceAccountPassword: All cluster nodes"
            " are not available. The password cannot be changed on"
            " this cluster.\n"
            ); 

        NmpReleaseLock();

        Status = ERROR_ALL_NODES_NOT_AVAILABLE; 
        goto ErrorExit;
    }

    NmpReleaseLock();


    //
    // Open the crypto provider
    //
    Status = NmpCreateCSPHandle(&CryptProvider);

    if (Status != ERROR_SUCCESS) {
        goto ErrorExit;
    }
    
    //
    // Encrypt the new password for transmission on the network as part of
    // a global update
    //

    //
    // Get the base key to be used to encrypt the data
    //
    Status = NmpGetSharedCommonKey(
                 &SharedCommonKey,
                 &SharedCommonKeyLen,
                 &SharedCommonKeyFirstHalf,
                 &SharedCommonKeyFirstHalfLen,
                 &SharedCommonKeySecondHalf,
                 &SharedCommonKeySecondHalfLen
                 );

    if (Status != ERROR_SUCCESS) {
        goto ErrorExit;
    }

    EncryptedNewPasswordLen = (wcslen(NewPassword) + 1) * sizeof(WCHAR);
    MACDataLen = NMP_MAC_DATA_LENGTH_EXPECTED;

    Status = 
        NmpEncryptDataAndCreateMAC(
            CryptProvider,
            NMP_ENCRYPT_ALGORITHM, // RC2 block encryption algorithm
            NMP_KEY_LENGTH,  // key length = 128 bits
            (BYTE *) NewPassword, // Data
            EncryptedNewPasswordLen, //DataLength
            SharedCommonKey, // EncryptionKey
            SharedCommonKeyLen, // EncryptionKeyLength
            TRUE, // CreateSalt
            &SaltBuf, // Salt
            NMP_SALT_BUFFER_LEN, // SaltLength
            &EncryptedNewPassword,  // EncryptedData
            &EncryptedNewPasswordLen, // EncryptedDataLength
            &MACData, // MAC
            &MACDataLen  // MACLength
            );
    
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] SetServiceAccountPassword: Failed to encrypt password "
            "or create MAC, status %1!u!.\n",
            Status
            );

        goto ErrorExit;
    }


    //
    // Allocate memory for GumReturnStatusBuffer
    //
    CL_ASSERT(NmMaxNodeId != 0);
    dwSize = (NmMaxNodeId + 1) * sizeof(GUM_NODE_UPDATE_HANDLER_STATUS);

    GumReturnStatusBuffer = HeapAlloc(
                                GetProcessHeap(), 
                                HEAP_ZERO_MEMORY, 
                                dwSize
                                );

    if (GumReturnStatusBuffer == NULL) 
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] SetServiceAccountPassword: Failed to allocate %1!u! bytes "
            "for global update status buffer.\n",
            dwSize
            ); 
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    //
    // Issue the global update
    //
    Status = GumSendUpdateExReturnInfo(
                 GumUpdateMembership,
                 NmUpdateSetServiceAccountPassword,
                 GumReturnStatusBuffer,
                 8,
                 (wcslen(DomainName) + 1) * sizeof(WCHAR),
                 DomainName,
                 (wcslen(AccountName) + 1) * sizeof(WCHAR),
                 AccountName,
                 EncryptedNewPasswordLen, 
                 EncryptedNewPassword, 
                 sizeof(EncryptedNewPasswordLen),
                 &EncryptedNewPasswordLen,
                 NMP_SALT_BUFFER_LEN,
                 SaltBuf,
                 sizeof(SaltBufLen),
                 &SaltBufLen,
                 MACDataLen,
                 MACData,
                 sizeof(MACDataLen),
                 &MACDataLen
                 );

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] SetServiceAccountPassword: Global update failed, "
            "status %1!u!.\n",
            Status
            ); 
    }
    else
    {
        //
        // Transfer return status from GumReturnStatusBuffer to 
        // ReturnStatusBuffer   
        //
        DWORD sizeRemaining = ReturnStatusBufferSize;
        DWORD nodeIndex, returnIndex;


        NmpAcquireLock();

        for ( nodeIndex = ClusterMinNodeId, returnIndex = 0; 
              nodeIndex <= NmMaxNodeId;
              nodeIndex++
            )
        {


            if (sizeRemaining < 1)  {
                break;
            } 

            if (GumReturnStatusBuffer[nodeIndex].UpdateAttempted)
            {
                //
                // An update was attempted for this node.
                // Capture the execution status.
                //
                ReturnStatusBuffer[returnIndex].NodeId = nodeIndex;
                ReturnStatusBuffer[returnIndex].SetAttempted = TRUE;
                ReturnStatusBuffer[returnIndex].ReturnStatus = 
                    GumReturnStatusBuffer[nodeIndex].ReturnStatus;
                sizeRemaining--;
                returnIndex++;
            }
            else if ( NmpIdArray[nodeIndex] != NULL ) {
                //
                // An update was not attempted but the node exists. 
                // Implies that the node was not up when the update 
                // was attempted.
                //
                ReturnStatusBuffer[returnIndex].NodeId = nodeIndex;
                ReturnStatusBuffer[returnIndex].SetAttempted = FALSE;
                ReturnStatusBuffer[returnIndex].ReturnStatus = 
                    ERROR_CLUSTER_NODE_DOWN;
                sizeRemaining--;
                returnIndex++;
            }
            //
            // else the node does not exist, so we do not add an
            // entry to the return status array.
            //

        } // endfor

        NmpReleaseLock();

        *SizeReturned = ReturnStatusBufferSize - sizeRemaining;

    }  //else

ErrorExit:

    // Zero out NewPassword
    RtlSecureZeroMemory(NewPassword, (wcslen(NewPassword) + 1) * sizeof(WCHAR));


    if (SharedCommonKey != NULL)
    {
        RtlSecureZeroMemory(SharedCommonKey, SharedCommonKeyLen);
        HeapFree(GetProcessHeap(), 0, SharedCommonKey);  
        SharedCommonKey = NULL;
        SharedCommonKeyLen = 0;
        SharedCommonKeyFirstHalf = NULL;
        SharedCommonKeyFirstHalfLen = 0;
        SharedCommonKeySecondHalf = NULL;
        SharedCommonKeySecondHalfLen = 0;
    }

    if (SaltBuf != NULL)
    {
        if (!HeapFree(GetProcessHeap(), 0, SaltBuf))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] SetServiceAccountPassword: Failed to free salt buffer, "
                "status %1!u!.\n",
                GetLastError()
                );  
            
        }
    }

    if (MACData != NULL)
    {
        if (!HeapFree(GetProcessHeap(), 0, MACData))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] SetServiceAccountPassword: Failed to free MAC buffer, "
                "status %1!u!.\n",
                GetLastError()
                );  
        }
    }
        
    if (EncryptedNewPassword != NULL)
    {
        if (!HeapFree(GetProcessHeap(), 0, EncryptedNewPassword))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] SetServiceAccountPassword: Failed to free password "
                "buffer, status %1!u!.\n",
                GetLastError()
                );  
        }
    }

    if (GumReturnStatusBuffer != NULL)
    {
         if (!HeapFree(GetProcessHeap(), 0, GumReturnStatusBuffer))
         {
             ClRtlLogPrint(
                 LOG_UNUSUAL, 
                 "[NM] SetServiceAccountPassword: Failed to free global "
                 "update status buffer, status %1!u!.\n",
                 GetLastError()
                 );  
         }
     }

    //
    // Release the CSP.
    //
    if(CryptProvider) 
    {
        if (!CryptReleaseContext(CryptProvider,0))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] SetServiceAccountPassword: Failed to free provider "
                "handle, status %1!u!\n",
                GetLastError()
                );  
        }
    }

    NmpLeaveApi();

    return(Status);

}  // NmSetServiceAccountPassword


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpUpdateSetServiceAccountPassword(
    IN BOOL SourceNode,
    IN LPWSTR DomainName,
    IN LPWSTR AccountName,
    IN LPBYTE EncryptedNewPassword,
    IN LPDWORD EncryptedNewPasswordLen,
    IN LPBYTE SaltBuf,
    IN LPDWORD SaltBufLen,
    IN LPBYTE MACData,
    IN LPDWORD MACDataLen
    )
/*++

Routine Description:

    This routine changes password for cluster service account on both Service
    Control Manager Database (SCM) and LSA password cache on local node.
    
Arguments:

    SourceNode - [IN] Specifies whether or not this is the source node for 
                 the update
                 
    DomainName - [IN] Domain name of cluster service account.
    
    AccountName - [IN] Account name of cluster service account.
    
    EncryptedNewPassword - [IN] New (encrypted) password for cluster service account.
    
    EncryptedNewPasswordLen - [IN] Length of new (encrypted) password for cluster service account.
    
    SaltBuf - [IN] Pointer to salt buffer.
    
    SaltBufLen - [IN] Length of salt buffer.
    
    MACData - [IN] Pointer to MAC data.
    
    MACDataLen - [IN] Length of MAC data.
    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:
 
--*/

{
    BYTE *SharedCommonKey = NULL;
    DWORD SharedCommonKeyLen = 0;
    BYTE *SharedCommonKeyFirstHalf = NULL;
    DWORD SharedCommonKeyFirstHalfLen = 0;
    BYTE *SharedCommonKeySecondHalf = NULL;
    DWORD SharedCommonKeySecondHalfLen = 0;
    SC_HANDLE ScmHandle = NULL;
    SC_HANDLE ClusSvcHandle = NULL;
    BOOL Success = FALSE;
    DWORD ReturnStatus;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    LSA_STRING LsaStringBuf;
    char *AuthPackage = MSV1_0_PACKAGE_NAME;
    HANDLE LsaHandle = NULL;
    ULONG PackageId;
    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    ULONG RequestSize;
    PBYTE Where;
    PVOID Response = NULL;
    ULONG ResponseSize;
    LPQUERY_SERVICE_LOCK_STATUS LpqslsBuf = NULL;
    DWORD DwBytesNeeded;
    DWORD LocalNewPasswordLen = 0;
    BYTE *DecryptedNewPassword = NULL;
    DWORD DecryptedNewPasswordLength = 0;
    HCRYPTPROV CryptProvider = 0;
    DATA_BLOB                   DataIn;
    DATA_BLOB                   DataOut;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(
            LOG_NOISE,
            "[NM] Not in valid state to process UpdateSetServiceAccountPassword "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(
        LOG_NOISE,
        "[NM] Received update to set the cluster service account password.\n"
        );    

    ClusterLogEvent0(LOG_NOISE,
                     LOG_CURRENT_MODULE,
                     __FILE__,
                     __LINE__,
                     SERVICE_PASSWORD_CHANGE_INITIATED,
                     0,
                     NULL
                     );


    
    //
    // Open crypto provider
    //
    ReturnStatus = NmpCreateCSPHandle(&CryptProvider);

    if (ReturnStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to aquire "
            "crypto provider handle, status %1!u!.\n",
            ReturnStatus
            );
        goto ErrorExit;
    }

    ReturnStatus = NmpGetSharedCommonKey(
                       &SharedCommonKey,
                       &SharedCommonKeyLen,
                       &SharedCommonKeyFirstHalf,
                       &SharedCommonKeyFirstHalfLen,
                       &SharedCommonKeySecondHalf,
                       &SharedCommonKeySecondHalfLen
                       );

    if (ReturnStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to get "
            "common key, status %1!u!.\n",
            ReturnStatus
            );
        goto ErrorExit;
    }


    ReturnStatus = NmpVerifyMACAndDecryptData(
                        CryptProvider,
                        NMP_ENCRYPT_ALGORITHM, // RC2 block encryption algorithm
                        NMP_KEY_LENGTH,  // key length = 128 bits
                        MACData,  // MAC
                        *MACDataLen,  // MAC length
                        NMP_MAC_DATA_LENGTH_EXPECTED, // MAC expected size
                        EncryptedNewPassword, // encrypted data
                        *EncryptedNewPasswordLen, // encrypted data length
                        SharedCommonKey,  // encryption key
                        SharedCommonKeyLen, // encryption key length
                        SaltBuf,   // salt
                        *SaltBufLen,  // salt length
                        &DecryptedNewPassword, // decrypted data
                        &LocalNewPasswordLen // decrypted data length
                        );


    if (ReturnStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to verify MAC "
            "or decrypt data, status %1!u!\n",
            ReturnStatus
            );
        goto ErrorExit;
    }



    ReturnStatus = NmpCheckDecryptedPassword(DecryptedNewPassword,
                                             LocalNewPasswordLen);
    if ( ReturnStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: decrypted new password "
            "is not an eligible UNICODE string with length equal to %1!u!.\n",
            LocalNewPasswordLen
            );
       goto ErrorExit;
    }
    DecryptedNewPasswordLength = LocalNewPasswordLen;

    //
    // Check if this is the same password that was used in the last change.
    // If so, we will ignore it to avoid flushing the old password cache.
    //


    if (NmpLastNewPasswordEncryptedLength != 0) 
    {
        DataIn.pbData = (BYTE *) NmpLastNewPasswordEncrypted; 
        DataIn.cbData = NmpLastNewPasswordEncryptedLength;     
        Success = CryptUnprotectData(&DataIn,  // data to be encrypted
                                   NULL,  // description string
                                   NULL,  
                                   NULL,  
                                   NULL,  
                                   0, // flags
                                   &DataOut  // encrypted data
                                   );


        if (!Success) 
        {
            ReturnStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] UpdateSetServiceAccountPassword: Failed to "
                "decrypt data using CryptUnprotectData, "
                "status %1!u!.\n",
                ReturnStatus
                );
            goto ErrorExit;
        }
    
        if (DataOut.cbData == DecryptedNewPasswordLength) 
        {
            if ( memcmp( DataOut.pbData, 
                         DecryptedNewPassword, 
                         DecryptedNewPasswordLength
                     ) 
                 == 0
               ) 
            {
                //
                // They are the same. No need to change again.
                //

                //
                // Release memory allocated by previous CryptProtectData().
                //
                RtlSecureZeroMemory(DataOut.pbData, DataOut.cbData);
                DataOut.cbData = 0;
                LocalFree(DataOut.pbData);

                ClRtlLogPrint(
                    LOG_NOISE, 
                    "[NM] UpdateSetServiceAccountPassword: New password is "
                    "identical to current password. Skipping password change.\n"
                    );
                ReturnStatus = ERROR_SUCCESS;
                goto ErrorExit;
            }
        }
    
        //
        // Release memory allocated by previous CryptProtectData().
        //
        RtlSecureZeroMemory(DataOut.pbData, DataOut.cbData);
        DataOut.cbData = 0;
        LocalFree(DataOut.pbData);

    }  // if (NmpLastNewPasswordEncryptedLength != 0) 

    
    //
    // Change password in SCM database
    //
    
    //
    // Establish a connection to the service control manager on local host 
    // and open service control manager database
    //
    ScmHandle = OpenSCManager( 
                    NULL,           // connect to local machine
                    NULL,           // open SERVICES_ACTIVE_DATABASE 
                    GENERIC_WRITE  
                    );

    if (ScmHandle == NULL)
    {
        ReturnStatus = GetLastError();

        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to connect to "
            "the SCM, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }
    
    //
    // Open a handle to the cluster service
    //
    ClusSvcHandle = OpenService(ScmHandle, L"clussvc", GENERIC_WRITE);
                                        
    if (ClusSvcHandle == NULL)
    {
        ReturnStatus = GetLastError();

        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to open a "
            "handle to the cluster service, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }

    //
    // Set the password property for the cluster service
    //
    Success = ChangeServiceConfig(
                  ClusSvcHandle,      // Handle to the service.
                  SERVICE_NO_CHANGE,  // type of service
                  SERVICE_NO_CHANGE,  // when to start service
                  SERVICE_NO_CHANGE,  // severity of start failure
                  NULL,
                  NULL,
                  NULL,
                  NULL,
                  NULL,
                  (LPCWSTR) DecryptedNewPassword,  
                  NULL
                  );

    if (!Success)
    {
        ReturnStatus = GetLastError();

        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to update the SCM "
            "database, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }

    //
    // Close the handle to cluster service. 
    //
    Success = CloseServiceHandle(ClusSvcHandle); 
    ClusSvcHandle = NULL;

    if (!Success)
    {
        ReturnStatus = GetLastError();

        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to close "
            "handle to the cluster service, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }

    //
    // Close the handle to Service Database 
    //
    Success = CloseServiceHandle(ScmHandle); 
    ScmHandle = NULL;
    
    if (!Success)
    {
        ReturnStatus=GetLastError();
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to close "
            "handle to the SCM, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }
    
    ClRtlLogPrint(
        LOG_NOISE, 
        "[NM] UpdateSetServiceAccountPassword: Updated the SCM database.\n"
        );  


    //
    // Change password in LSA cache
    //
    Status = LsaConnectUntrusted(&LsaHandle);

    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);

        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to connect to "
            "the LSA, status %1!u!.\n",
            ReturnStatus
            ); 
        
        goto ErrorExit;
    }
    
    RtlInitString(&LsaStringBuf, AuthPackage);

    Status = LsaLookupAuthenticationPackage(
                 LsaHandle,      // Handle
                 &LsaStringBuf,  // MSV1_0 authentication package 
                 &PackageId      // output: authentication package identifier
                 );
                                 

    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to lookup "
            "authentication package, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }

    //
    // Prepare to call LsaCallAuthenticationPackage() 
    //
    RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                  ( ( wcslen(AccountName) +
                      wcslen(DomainName) +
                      wcslen((LPWSTR) DecryptedNewPassword) + 3
                    ) * sizeof(WCHAR)
                  );

    Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) 
              HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, RequestSize);

    if (Request == NULL)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to allocate %1!u! "
            "bytes for LSA request buffer.\n",
            RequestSize
            );
        ReturnStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    
    Where = (PBYTE) (Request + 1);
    Request->MessageType = MsV1_0ChangeCachedPassword;
    wcscpy( (LPWSTR) Where, DomainName );
    RtlInitUnicodeString( &Request->DomainName,  (wchar_t *) Where );
    Where += Request->DomainName.MaximumLength;

    wcscpy((LPWSTR) Where, AccountName );
    RtlInitUnicodeString( &Request->AccountName,  (wchar_t *) Where );
    Where += Request->AccountName.MaximumLength;

    wcscpy((LPWSTR) Where, (LPWSTR) DecryptedNewPassword );
    RtlInitUnicodeString( &Request->NewPassword,  (wchar_t *) Where );
    Where += Request->NewPassword.MaximumLength;   



    Status = LsaCallAuthenticationPackage(
                 LsaHandle,  
                 PackageId,  
                 Request,    // MSV1_0_CHANGEPASSWORD_REQUEST
                 RequestSize,
                 &Response,  
                 &ResponseSize, 
                 &SubStatus  // Receives NSTATUS code indicating the 
                             // completion status of the authentication 
                             // package if ERROR_SUCCESS is returned. 
                 );


    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to update the "
            "LSA password cache, status %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    } 
    else if (LsaNtStatusToWinError(SubStatus) != ERROR_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(SubStatus);
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to update the "
            "LSA password cache, substatus %1!u!.\n",
            ReturnStatus
            ); 
        goto ErrorExit;
    }
    
    ClRtlLogPrint(
        LOG_NOISE, 
        "[NM] UpdateSetServiceAccountPassword: Updated the LSA password "
        "cache.\n"
        );  


    //
    // Rederive cluster encryption key based on new password
    //
    ReturnStatus = NmpRederiveClusterKey();

    if (ReturnStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] UpdateSetServiceAccountPassword: Failed to regenerate "
            "the cluster service encryption key, status %1!u!.\n",
            ReturnStatus
            );
        goto ErrorExit;
    }

    ClRtlLogPrint(
        LOG_NOISE, 
        "[NM] UpdateSetServiceAccountPassword: Regenerated cluster service "
        "encryption key.\n"
        );  


    //
    // Store the new password for comparison on the next change request
    //

    //
    // release last stored protected password
    // 
    if (NmpLastNewPasswordEncrypted != NULL)
    {
        // Release memory allocated by previous CryptProtectData().
        LocalFree(NmpLastNewPasswordEncrypted);
        NmpLastNewPasswordEncrypted = NULL;
        NmpLastNewPasswordEncryptedLength = 0;
    }

    //
    // Protect new password
    //
    ReturnStatus = NmpProtectData(DecryptedNewPassword,
                                  DecryptedNewPasswordLength,
                                  &NmpLastNewPasswordEncrypted,
                                  &NmpLastNewPasswordEncryptedLength
                                  );

    if (ReturnStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] UpdateSetServiceAccountPassword: Failed to encrypt data "
            "using CryptProtectData, "
            "status %1!u!.\n",
            ReturnStatus
            );
        goto ErrorExit;
    }



    // Log successful password change event
    ClusterLogEvent0(LOG_NOISE,
                     LOG_CURRENT_MODULE,
                     __FILE__,
                     __LINE__,
                     SERVICE_PASSWORD_CHANGE_SUCCESS,
                     0,
                     NULL
                     );


    ReturnStatus = ERROR_SUCCESS;

ErrorExit:
   

    NmpLeaveApi();

    if (DecryptedNewPassword != NULL)
    {
        // Zero DecryptedNewPassword
        RtlSecureZeroMemory(DecryptedNewPassword, DecryptedNewPasswordLength);

        if (!HeapFree(GetProcessHeap(), 0, DecryptedNewPassword))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] UpdateSetServiceAccountPassword: Failed to free "
                "decrypted password buffer, status %1!u!\n",
                GetLastError()
                );  
        }
        DecryptedNewPassword = NULL;
        DecryptedNewPasswordLength = 0;
    }


    if (SharedCommonKey != NULL)
    {
        RtlSecureZeroMemory(SharedCommonKey, SharedCommonKeyLen);
        HeapFree(GetProcessHeap(), 0, SharedCommonKey);
        SharedCommonKey = NULL;
        SharedCommonKeyLen = 0;
        SharedCommonKeyFirstHalf = NULL;
        SharedCommonKeyFirstHalfLen = 0;
        SharedCommonKeySecondHalf = NULL;
        SharedCommonKeySecondHalfLen = 0;
    }

    // Log failed password change event
    if ( ReturnStatus != ERROR_SUCCESS ) 
    {
        ClusterLogEvent0(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         SERVICE_PASSWORD_CHANGE_FAILED,
                         sizeof(ReturnStatus),
                         (PVOID) &ReturnStatus
                         );
    }

    // Close the handle to cluster service. 
    if (ClusSvcHandle != NULL)
    {
        Success = CloseServiceHandle(ClusSvcHandle); 
        if (!Success)
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] UpdateSetServiceAccountPassword: Failed to close "
                "handle to cluster service, status %1!u!.\n",
                GetLastError()
                ); 
        }
    }

    // Close the handle to Service Database 
    if (ScmHandle != NULL)
    {
        Success = CloseServiceHandle(ScmHandle); 
        if (!Success)
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] UpdateSetServiceAccountPassword: Failed to close "
                "handle to SCM, status %1!u!.\n",
                GetLastError()
                ); 
        }
    }

    if (LsaHandle != NULL)
    {
        Status = LsaDeregisterLogonProcess(LsaHandle);
        if (Status != STATUS_SUCCESS)
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] UpdateSetServiceAccountPassword: Failed to deregister "
                "with LSA, status %1!u!.\n",
                LsaNtStatusToWinError(Status)
                ); 
        }
    }

    if (Request != NULL)
    {
        if (!HeapFree(GetProcessHeap(), 0, Request))
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] UpdateSetServiceAccountPassword: Failed to free "
                "LSA request buffer, status %1!u!.\n",
                GetLastError()
                ); 
        }
    }

    if (Response != NULL)
    {
        Status = LsaFreeReturnBuffer(Response);
        if (Status != STATUS_SUCCESS)
        {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] UpdateSetServiceAccountPassword: Failed to free "
                "LSA return buffer, status %1!u!.\n",
                LsaNtStatusToWinError(Status)
                ); 
        }
    }
       


    // Release the CSP.
   if(CryptProvider) 
   {
       if (!CryptReleaseContext(CryptProvider,0))
       {
           ClRtlLogPrint(
               LOG_UNUSUAL, 
               "NM] UpdateSetServiceAccountPassword: Failed to release "
               "crypto provider, status %1!u!\n",
               GetLastError()
               );  
       }
   }
    
   return(ReturnStatus);

}  // NmpUpdateSetServiceAccountPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\node.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    node.c

Abstract:

    Private Node Manager routines.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/

#define UNICODE 1

#include "nmp.h"


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////
ULONG              NmMaxNodes = ClusterInvalidNodeId;
CL_NODE_ID         NmMaxNodeId = ClusterInvalidNodeId;
CL_NODE_ID         NmLocalNodeId = ClusterInvalidNodeId;
PNM_NODE           NmLocalNode = NULL;
WCHAR              NmLocalNodeIdString[CS_MAX_NODE_ID_LENGTH+1];
WCHAR              NmLocalNodeName[CS_MAX_NODE_NAME_LENGTH+1];
LIST_ENTRY         NmpNodeList = {NULL, NULL};
PNM_NODE *         NmpIdArray = NULL;
DWORD              NmpNodeCount = 0;
BOOL               NmpLastNodeEvicted = FALSE;
BOOL               NmLocalNodeVersionChanged = FALSE;
LIST_ENTRY *       NmpIntraClusterRpcArr=NULL;
CRITICAL_SECTION   NmpRPCLock;

// Use space hang detection parameters.
DWORD              NmClusSvcHeartbeatTimeout=0;
ClussvcHangAction  NmHangRecoveryAction;

#if DBG

DWORD              NmpRpcTimer=0;

#endif // DBG



///////////////////////////////////////////////////////////////////////////
//
// Initialization/Cleanup Routines
//
///////////////////////////////////////////////////////////////////////////
VOID
NmpCleanupNodes(
    VOID
    )
{
    PNM_NODE     node;
    PLIST_ENTRY  entry, nextEntry;
    DWORD        status;


    ClRtlLogPrint(LOG_NOISE,"[NM] Node cleanup starting...\n");

    NmpAcquireLock();

    while (!IsListEmpty(&NmpNodeList)) {
        entry = NmpNodeList.Flink;
        node = CONTAINING_RECORD(entry, NM_NODE, Linkage);

        if (node == NmLocalNode) {
            entry = node->Linkage.Flink;

            if (entry == &NmpNodeList) {
                break;
            }

            node = CONTAINING_RECORD(entry, NM_NODE, Linkage);
        }

        CL_ASSERT(NM_OM_INSERTED(node));
        CL_ASSERT(!NM_DELETE_PENDING(node));

        NmpDeleteNodeObject(node, FALSE);
    }

    NmpReleaseLock();


    ClRtlLogPrint(LOG_NOISE,"[NM] Node cleanup complete\n");

    return;

}  // NmpCleanupNodes


/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by joining nodes or on behalf of joining nodes.
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcEnumNodeDefinitions(
    IN  handle_t         IDL_handle,
    IN  DWORD            JoinSequence,   OPTIONAL
    IN  LPWSTR           JoinerNodeId,   OPTIONAL
    OUT PNM_NODE_ENUM *  NodeEnum1
    )
{
    DWORD     status = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

    ClRtlLogPrint(LOG_UNUSUAL,
        "[NMJOIN] Refusing node info to joining node nodeid=%1!ws!. Aborting join, obsolete interface.\n",
        JoinerNodeId
        );

    return(status);

} // s_NmRpcEnumNodeDefinitions


error_status_t
s_NmRpcEnumNodeDefinitions2(
    IN  handle_t          IDL_handle,
    IN  DWORD             JoinSequence,   OPTIONAL
    IN  LPWSTR            JoinerNodeId,   OPTIONAL
    OUT PNM_NODE_ENUM2 *  NodeEnum
    )
{
    DWORD     status = ERROR_SUCCESS;
    PNM_NODE  joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Supplying node information to joining node.\n"
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] EnumNodeDefinitions call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] EnumNodeDefinitions call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            status = NmpEnumNodeObjects(NodeEnum);

            if (joinerNode != NULL) {
                if (status == ERROR_SUCCESS) {
                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NMJOIN] EnumNodeDefinitions failed, status %1!u!.\n",
                        status
                        );

                    //
                    // Abort the join
                    //
                    NmpJoinAbort(status, joinerNode);
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process EnumNodeDefinitions request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcEnumNodeDefinitions2


error_status_t
s_NmRpcAddNode(
    IN handle_t IDL_handle,
    IN LPCWSTR  NewNodeName,
    IN DWORD    NewNodeHighestVersion,
    IN DWORD    NewNodeLowestVersion,
    IN DWORD    NewNodeProductSuite
    )
/*++

Routine Description:

    Adds a new node to the cluster by selecting an ID and
    issuing a global update.

Arguments:

    IDL_handle - RPC client interface handle.

    NewNodeName - A pointer to a string containing the name of the
                  new node.

    NewNodeHighestVersion - The highest cluster version number that the
                            new node can support.

    NewNodeLowestVersion - The lowest cluster version number that the
                            new node can support.

    NewNodeProductSuite - The product suite identifier for the new node.

Return Value:

    A Win32 status code.

Notes:

    Called with NmpLock held.

--*/
{
    DWORD  status;
    DWORD  registryNodeLimit;


    ClRtlLogPrint(LOG_UNUSUAL,
        "[NMJOIN] Received forwarded request to add node '%1!ws!' to the "
        "cluster.\n",
        NewNodeName
        );
    //
    // Read the registry override before acquiring the NM lock.
    //
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_MAX_NODES,
                 &registryNodeLimit,
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        registryNodeLimit = 0;
    }

    NmpAcquireLock();

    if (!NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] This node is not in a valid state to process a "
            "request to add node '%1!ws!' to the cluster.\n",
            NewNodeName
            );
        NmpReleaseLock();
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    if (NmpLeaderNodeId == NmLocalNodeId) {\
        //
        // Call the internal handler.
        //
        status = NmpAddNode(
                     NewNodeName,
                     NewNodeHighestVersion,
                     NewNodeLowestVersion,
                     NewNodeProductSuite,
                     registryNodeLimit
                     );
    }
    else {
        //
        // This node is not the leader.
        // Fail the request.
        //
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot process request to add node '%1!ws!' to the "
            "cluster because this node is not the leader.\n",
            NewNodeName
            );
    }

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return(status);

} // s_NmRpcAddNode


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Setting up ClusSvc to ClusNet Heartbeating.
//
/////////////////////////////////////////////////////////////////////////////

DWORD NmInitializeClussvcClusnetHb(VOID)
{
    DWORD status = ERROR_SUCCESS;
    DWORD hAct;
    LPWSTR actStr;
    HANDLE th;
    DWORD thId;

    // Initialize all the parameters with default values.
    NmClusSvcHeartbeatTimeout = CLUSTER_HEARTBEAT_TIMEOUT_DEFAULT;
    NmHangRecoveryAction = CLUSTER_HANG_RECOVERY_ACTION_DEFAULT;

    // Get the values of ClussvcClusnetHbTimeout and ClssvcClusnetHbTimeoutAction if present.
    // They are in HKLM\Cluster\Parameters

    DmQueryDword(
        DmClusterParametersKey,
        CLUSTER_HEARTBEAT_TIMEOUT_KEYNAME,
        &NmClusSvcHeartbeatTimeout,
        NULL
        );

    status = DmQueryDword(
                    DmClusterParametersKey,
                    CLUSTER_HANG_RECOVERY_ACTION_KEYNAME,
                    &hAct,
                    NULL
                    );
    if (status == ERROR_SUCCESS) {
        NmHangRecoveryAction = (ClussvcHangAction)hAct;
    }

    // Check that they are within limits else use default.
    if (NmClusSvcHeartbeatTimeout < CLUSTER_HEARTBEAT_TIMEOUT_MIN)
        NmClusSvcHeartbeatTimeout = CLUSTER_HEARTBEAT_TIMEOUT_DEFAULT;

    if (NmHangRecoveryAction >= ClussvcHangActionMax)
        NmHangRecoveryAction = CLUSTER_HANG_RECOVERY_ACTION_DEFAULT;

    if(NmHangRecoveryAction == ClussvcHangActionTerminateService)
        actStr = L"Terminate Service";
    else if(NmHangRecoveryAction == ClussvcHangActionLog)
        actStr = L"Log";
    else if(NmHangRecoveryAction == ClussvcHangActionDisable)
        actStr = L"Disabled";
    else
        actStr = L"BugCheck Node";

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Setting ClusSvc ClusNet HB params, Timeout=%1!u!(s) Action= %2!ws!.\n",
        NmClusSvcHeartbeatTimeout,
        actStr
        );

    // ClusSvc, ClusNet comes up with this feature in disabled state. So if the action is
    // diable then do nothing.
    if (NmHangRecoveryAction == ClussvcHangActionDisable)
        return ERROR_SUCCESS;

    // Tell Clusnet to start monitoring.
    // Note: Actual monitoring would not start till first HB is received by clusnet.
    status = ClusnetSetIamaliveParam(
                        NmClusnetHandle,
                        NmClusSvcHeartbeatTimeout,
                        NmHangRecoveryAction
                        );

    // Now tell RGP to start heartbeating.
    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Successfully initialized Clussvc to Clusnet heartbeating\n"
            );
        MMStartClussvcClusnetHb();
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Clussvc to Clusnet heartbeating initialization failed status=%1!u!\n",
            status
            );
    }

    return status;
}// NmInitializeClussvcClusnetHb

/////////////////////////////////////////////////////////////////////////////
//
// Rpc Extended error tracking.
//
/////////////////////////////////////////////////////////////////////////////

VOID NmDumpRpcExtErrorInfo(RPC_STATUS status)
{
        RPC_STATUS status2;
        RPC_ERROR_ENUM_HANDLE enumHandle;

        status2 = RpcErrorStartEnumeration(&enumHandle);

        if(status2 == RPC_S_ENTRY_NOT_FOUND) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] RpcExtErrorInfo: Error info not found.\n"
                );
        }
        else if(status2 != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] RpcExtErrorInfo: Couldn't get error info, status %1!u!\n",
                status2
                );
        }
        else {
            RPC_EXTENDED_ERROR_INFO errorInfo;
            int records;
            BOOL result;
            BOOL copyStrings=TRUE;
            BOOL fUseFileTime=TRUE;
            SYSTEMTIME *systemTimeToUse;
            SYSTEMTIME systemTimeBuffer;

            while(status2 == RPC_S_OK) {
                errorInfo.Version = RPC_EEINFO_VERSION;
                errorInfo.Flags = 0;
                errorInfo.NumberOfParameters = 4;

                if(fUseFileTime) {
                    errorInfo.Flags |= EEInfoUseFileTime;
                }

                status2 = RpcErrorGetNextRecord(&enumHandle, copyStrings, &errorInfo);

                if(status2 == RPC_S_ENTRY_NOT_FOUND) {
                    break;
                }
                else if(status2 != RPC_S_OK) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] RpcExtErrorInfo: Couldn't complete enumeration, status %1!u!\n",
                        status2
                        );
                    break;
                }
                else {
                    int i;

                    if(errorInfo.ComputerName) {
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] RpcExtErrorInfo: ComputerName= %1!ws!\n",
                            errorInfo.ComputerName
                            );
                    }
                    if(copyStrings) {
                        result = HeapFree(GetProcessHeap(), 0, errorInfo.ComputerName);
                        CL_ASSERT(result);
                    }
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: ProcessId= %1!u!\n",
                        errorInfo.ProcessID
                        );

                    if(fUseFileTime) {
                        result = FileTimeToSystemTime(&errorInfo.u.FileTime, &systemTimeBuffer);
                        CL_ASSERT(result);
                        systemTimeToUse = &systemTimeBuffer;
                    }
                    else {
                        systemTimeToUse = &errorInfo.u.SystemTime;
                    }

                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: SystemTime= %1!u!/%2!u!/%3!u! %4!u!:%5!u!:%6!u!:%7!u!\n",
                        systemTimeToUse->wMonth,
                        systemTimeToUse->wDay,
                        systemTimeToUse->wYear,
                        systemTimeToUse->wHour,
                        systemTimeToUse->wMinute,
                        systemTimeToUse->wSecond,
                        systemTimeToUse->wMilliseconds
                        );
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: GeneratingComponent= %1!u!\n",
                        errorInfo.GeneratingComponent
                        );
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: Status= 0x%1!x!\n",
                        errorInfo.Status
                        );
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: Detection Location= %1!u!\n",
                        (DWORD)errorInfo.DetectionLocation
                        );
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: Flags= 0x%1!x!\n",
                        errorInfo.Flags
                        );
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] RpcExtErrorInfo: Number of Parameters= %1!u!\n",
                        errorInfo.NumberOfParameters
                        );
                    for(i=0;i<errorInfo.NumberOfParameters;i++) {
                        switch(errorInfo.Parameters[i].ParameterType) {
                        case eeptAnsiString:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Ansi String= %1!s!\n",
                                errorInfo.Parameters[i].u.AnsiString
                                );
                            if(copyStrings) {
                                result = HeapFree(GetProcessHeap(), 0, errorInfo.Parameters[i].u.AnsiString);
                                CL_ASSERT(result);
                            }
                            break;
                        case eeptUnicodeString:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Unicode String= %1!S!\n",
                                errorInfo.Parameters[i].u.UnicodeString
                                );
                            if(copyStrings) {
                                result = HeapFree(GetProcessHeap(), 0, errorInfo.Parameters[i].u.UnicodeString);
                                CL_ASSERT(result);
                            }
                            break;
                        case eeptLongVal:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Long Val= %1!u!\n",
                                errorInfo.Parameters[i].u.LVal
                                );
                            break;
                        case eeptShortVal:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Short Val= %1!u!\n",
                                (DWORD)errorInfo.Parameters[i].u.SVal
                                );
                            break;
                        case eeptPointerVal:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Pointer Val= 0x%1!u!\n",
                                errorInfo.Parameters[i].u.PVal
                                );
                            break;
                        case eeptNone:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Truncated\n"
                                );
                            break;
                        default:
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] RpcExtErrorInfo: Invalid Type %1!u!\n",
                                errorInfo.Parameters[i].ParameterType
                                );
                        }
                    }
                }
            }
            RpcErrorEndEnumeration(&enumHandle);
        }
} //NmDumpRpcExtErrorInfo




///////////////////////////////////////////////////////////////////////////
//
// RPC Monitoring Routines
//
///////////////////////////////////////////////////////////////////////////


VOID
NmStartRpc(
    DWORD NodeId
    )
/*++

Routine Description:

    Registers the fact that an RPC is about to be made to the specified
    node by the current thread. This allows the call to be cancelled if
    the target node dies.

Arguments:

    NodeId - The ID of the node about to be called.

Return Value:

    None

Notes:

    This routine must not be called by a thread that makes concurrent
    asynch RPC calls.

--*/
{
    HANDLE thHandle;
    PNM_INTRACLUSTER_RPC_THREAD entry;

    CL_ASSERT((NodeId >= ClusterMinNodeId) && (NodeId <= NmMaxNodeId));
    CL_ASSERT(NmpIntraClusterRpcArr != NULL);

    thHandle = OpenThread(
                    THREAD_ALL_ACCESS,
                    FALSE,
                    GetCurrentThreadId()
                    );

    if(thHandle == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] NmStartRpc: Failed to open handle to current thread.\n"
            );
        return;
    }

    entry = LocalAlloc(LMEM_FIXED, sizeof(NM_INTRACLUSTER_RPC_THREAD));
    if(entry == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] NmStartRpc: Failed to allocate memory.\n"
            );
        CloseHandle(thHandle);
        return;
    }

    entry->ThreadId = GetCurrentThreadId();
    entry->Thread = thHandle;
    entry->Cancelled = FALSE;


    NmpAcquireRPCLock();

#if DBG
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Starting RPC to node %1!u!\n",
        NodeId
        );
#endif

    InsertHeadList(&NmpIntraClusterRpcArr[NodeId], &entry->Linkage);

    NmpReleaseRPCLock();

    return;

} // NmStartRpc


VOID
NmEndRpc(
    DWORD NodeId
    )
/*++

Routine Description:

    Cancels registration of an RPC to the specified node by the current
    thread.

Arguments:

    NodeId - The ID of the node that was called.

Return Value:

    None

Notes:

    This routine must be invoked even if the RPC was cancelled.

--*/
{
    DWORD threadId;
    LIST_ENTRY *pEntry;
    PNM_INTRACLUSTER_RPC_THREAD pRpcTh;

    CL_ASSERT((NodeId >= ClusterMinNodeId) && (NodeId <= NmMaxNodeId));
    CL_ASSERT(NmpIntraClusterRpcArr != NULL);

    threadId = GetCurrentThreadId();

    NmpAcquireRPCLock();
    pEntry = NmpIntraClusterRpcArr[NodeId].Flink;

    while(pEntry != &NmpIntraClusterRpcArr[NodeId]) {
        pRpcTh = CONTAINING_RECORD(pEntry, NM_INTRACLUSTER_RPC_THREAD, Linkage);
        if(pRpcTh->ThreadId == threadId) {
#if DBG
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Finished RPC to node %1!u!\n",
                NodeId
                );
#endif
            if (pRpcTh->Cancelled) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] RPC by this thread to node %1!u! is cancelled\n",
                    NodeId
                    );

                // Now sleep in alertable mode to drain any spurious Rpc Cancel APCs.
                // This is a workaround for 598037.
                if (SleepEx(50, TRUE) == WAIT_IO_COMPLETION) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Possibly spurious RPC Cancel APC detected.\n"
                        );
                }
            }

            RemoveEntryList(pEntry);
            CloseHandle(pRpcTh->Thread);
            LocalFree(pRpcTh);
            NmpReleaseRPCLock();
            return;
        }
        pEntry = pEntry->Flink;
    }

    ClRtlLogPrint(LOG_UNUSUAL,
        "[NM] No record of RPC by this thread to node %1!u!.\n",
        NodeId
        );
#if DBG
    CL_ASSERT(pEntry != &NmpIntraClusterRpcArr[NodeId]);
#endif

    NmpReleaseRPCLock();
    return;

} // NmEndRpc






DWORD
NmPauseNode(
    IN PNM_NODE Node
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPCWSTR nodeId = OmObjectId(Node);
    DWORD status;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to pause node %1!ws!.\n",
        nodeId
        );

    if (NmpEnterApi(NmStateOnline)) {
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdatePauseNode,
                     1,
                     (lstrlenW(nodeId)+1)*sizeof(WCHAR),
                     nodeId
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Global update to pause node %1!ws! failed, status %2!u!\n",
                nodeId,
                status
                );
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process PauseNode request.\n"
            );
    }

    return(status);

}  // NmPauseNode


DWORD
NmResumeNode(
    IN PNM_NODE  Node
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPCWSTR nodeId = OmObjectId(Node);
    DWORD status;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to resume node %1!ws!.\n",
        nodeId
        );

    if (NmpEnterApi(NmStateOnline)) {
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateResumeNode,
                     1,
                     (lstrlenW(nodeId)+1)*sizeof(WCHAR),
                     nodeId
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Global update to resume node %1!ws! failed, status %2!u!\n",
                nodeId,
                status
                );
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process ResumeNode request.\n"
            );
    }

    return(status);

}  // NmResumeNode


DWORD
NmEvictNode(
    IN PNM_NODE Node
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   The caller must be holding a reference on the node object.

--*/
{
    LPCWSTR nodeId = OmObjectId(Node);
    DWORD   status = ERROR_SUCCESS;
    LPCWSTR pcszNodeName = NULL;
    HRESULT hrStatus;
    BOOL    fRunEvictNotifications = TRUE;
    int     cNodes = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to evict node %1!ws!.\n",
        nodeId
        );

    if (NmpEnterApi(NmStateOnline)) {

        // Acquire NM lock (to ensure that the number of nodes does not change)
        NmpAcquireLock();

        // Get the node count while the ability to change it is locked...
        cNodes = NmpNodeCount;

        if (NmpNodeCount != 1 ) {

            NmpReleaseLock();

            // We are not evicting the last node.
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateEvictNode,
                         1,
                         (lstrlenW(nodeId)+1)*sizeof(WCHAR),
                         nodeId
                         );

            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Global update to evict node %1!ws! failed, status %2!u!\n",
                    nodeId,
                    status
                    );
            }
        }
        else {
            // We are evicting the last node. Set a flag to indicate this fact.
            if ( NmpLastNodeEvicted == FALSE ) {
                NmpLastNodeEvicted = TRUE;

                // If we are evicting the last node then we don't want the
                // evict notify processing to be called.
                //
                // It doesn't make any sense to run the evict notification
                // processing when we are evicting the last node in the
                // cluster.
                fRunEvictNotifications = FALSE;
            }
            else {
                // We have already evicted this node. This is an error.
                status = ERROR_NODE_NOT_AVAILABLE;
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Not in valid state to process EvictNode request.\n"
                    );
            }

            NmpReleaseLock();
        }

        //  ERROR_NODE_NOT_AVAILABLE can occur because of ClusApi reconnect.  We should still attempt to clean
        //  up the node and notify anyone who cares that the node was evicted.
        if (    (status == ERROR_SUCCESS)
            ||  (status == ERROR_NODE_NOT_AVAILABLE)) {

            // Get the name of the node...
            pcszNodeName = OmObjectName(Node);

            //  The node was successfully evicted. Now initiate cleanup on that node.
            //  However, specify that cleanup is to be started only after 60000 ms (1 minute).
            //
            //  This delay is to for anyone using the EvictClusterNodeEx() API.  This API will cleanup the
            //  remote node and return the clean up status as extended error reporting.  It is assumed that it
            //  will do the clean up and return before 60 seconds expires.   If a down level client
            //  is used, EvictClusterNode(), then this call will clean up the remote node after the delay time
            //  has expired.  It was decided to use this mechanism rather than a new RPC call from the API to
            //  the service.  Too much testing is required for this kind of a change.
            hrStatus =
                ClRtlCleanupNode(
                      cNodes == 1 ? NULL : pcszNodeName     // Name of the node to be cleaned up.  When it's the last node pass NULL.
                    , 60000                                 // Amount of time (in milliseconds) to wait before starting cleanup
                    , 0                                     // timeout interval in milliseconds
                    );

            if ( FAILED( hrStatus ) && ( hrStatus != RPC_S_CALLPENDING ) ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to initiate cleanup of evicted node %1!ws!, hrStatus 0x%2!x!\n",
                    nodeId,
                    hrStatus
                    );
                status = SCODE_CODE( hrStatus );
            }
            else {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Cleanup of evicted node %1!ws! successfully initiated.\n",
                    nodeId
                    );
            }

            // Should we run the evict notification processing?
            if ( fRunEvictNotifications ) {
                // Now that the node has been evicted and cleaned up we need to notify all who
                // care that this has happened.
                //
                // The evict notification will be sent even if the cleanup above
                // fails.  Status should not be changed in the block below as we
                // don't want a notification failure to show up as an evict error.

                hrStatus = ClRtlInitiateEvictNotification( pcszNodeName );
                if ( FAILED( hrStatus ) ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to initiate notification that node %1!ws! was evicted, hrStatus 0x%2!x!\n",
                        nodeId,
                        hrStatus
                        );
                    //status = SCODE_CODE( hrStatus );  // Don't want to send this failure on to the caller...
                }
                else {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Notification that node %1!ws! was evicted was successfully initiated.\n",
                        nodeId
                        );
                }
            }
        }

        CsLogEvent1(LOG_UNUSUAL, NM_NODE_EVICTED, OmObjectName(Node));

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process EvictNode request.\n"
            );
    }

    return(status);

}  // NmEvictNode



PNM_NODE
NmReferenceNodeById(
    IN DWORD NodeId
    )
/*++

Routine Description:

    Given a node id, returns a referenced pointer to the node object.
    The caller is responsible for calling OmDereferenceObject.

Arguments:

    NodeId - Supplies the node id

Return Value:

    A pointer to the node object if it exists

    NULL if there is no such node.

--*/

{
    PNM_NODE Node = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnlinePending)) {
        CL_ASSERT(NmIsValidNodeId(NodeId));
        CL_ASSERT(NmpIdArray != NULL);

        Node = NmpIdArray[NodeId];

        if (NmpIdArray[NodeId] != NULL) {
            OmReferenceObject(Node);
        }
        else {
            SetLastError(ERROR_CLUSTER_NODE_NOT_FOUND);
        }

        NmpLockedLeaveApi();
    }
    else {
        SetLastError(ERROR_NODE_NOT_AVAILABLE);
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process ReferenceNodeById request.\n"
            );
    }

    NmpReleaseLock();

    return(Node);

}  // NmReferenceNodeById



PNM_NODE
NmReferenceJoinerNode(
    IN DWORD       JoinSequence,
    IN CL_NODE_ID  JoinerNodeId
    )
/*++

Routine Description:

    Given a node id, returns a referenced pointer to the node object.
    The caller is responsible for calling OmDereferenceObject.
    Also validates the joiner's information

Arguments:

    NodeId - Supplies the node id

Return Value:

    A pointer to the node object if it exists

    NULL if there is no such node.

Notes:

    If the routine is successful, the caller must dereference the
    node object by calling NmDereferenceJoiningNode.

--*/

{
    PNM_NODE  joinerNode = NULL;
    DWORD     status;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {

        joinerNode = NmpIdArray[JoinerNodeId];

        if (joinerNode != NULL) {

            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == JoinerNodeId)
               )
            {
                OmReferenceObject(joinerNode);

                NmpReleaseLock();

                //
                // Return holding an active thread reference.
                //
                return(joinerNode);
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
            }
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
    }

    NmpReleaseLock();

    if (status != ERROR_SUCCESS) {
        SetLastError(status);
    }

    return(joinerNode);

}  // NmReferenceJoinerNode


VOID
NmDereferenceJoinerNode(
    PNM_NODE  JoinerNode
    )
{

    OmDereferenceObject(JoinerNode);

    NmpLeaveApi();

    return;

} // NmDereferenceJoinerNode


CLUSTER_NODE_STATE
NmGetNodeState(
    IN PNM_NODE  Node
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NODE_STATE  state;


    NmpAcquireLock();

    state = Node->State;

    NmpReleaseLock();

    return(state);

}  // NmGetNodeState


CLUSTER_NODE_STATE
NmGetExtendedNodeState(
    IN PNM_NODE  Node
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NODE_STATE  state;


    NmpAcquireLock();

    state = Node->State;

    if(NM_NODE_UP(Node) ) {
        //
        // We need to check whether the node is really up
        //
        switch( Node->ExtendedState ) {

            case ClusterNodeUp:
                //
                // The node explicitly set its extended state to UP immediately after
                // ClusterJoin / ClusterForm was complete.
                // We need to return either Up or Paused, depending on the node state
                //
                state = Node->State;
                break;

            case ClusterNodeDown:
                //
                // The node explicitly set its extended state to DOWN in the beginning of
                // the shutdown process. We will report the node state as down.
                //
                // It is better to have ClusterNodeShuttindDown state for this situation.
                //
                //              state = ClusterNodeDown;
                // We do not want to return NodeDown, we really want NodeShuttingDown.
                //
                // Return UP or Paused
                //
                state = Node->State;
                break;

            default:
                //
                // Node is up from NM standpoint, but other components are not up yet.
                //
                state = ClusterNodeJoining;
        }
    }


    NmpReleaseLock();

    return(state);

}  // NmGetExtendedNodeState


DWORD NmpUpdateExtendedNodeState(
    IN BOOL SourceNode,
    IN LPWSTR NodeId,
    IN CLUSTER_NODE_STATE* ExtendedState
    )
{
    DWORD status = ERROR_SUCCESS;

    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to set extended state for node %1!ws! "
        "to %2!d!\n",
        NodeId,
        *ExtendedState
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  node = OmReferenceObjectById(ObjectTypeNode, NodeId);

        if (node != NULL) {
            //
            // Extended State is valid only when the node is online.
            // Ignore the update otherwise.
            //
            if ( NM_NODE_UP(node) ) {
                CLUSTER_EVENT event;
                node->ExtendedState = *ExtendedState;

                if (*ExtendedState == ClusterNodeUp) {
                    event = CLUSTER_EVENT_API_NODE_UP;
                } else {
                    event = CLUSTER_EVENT_API_NODE_SHUTTINGDOWN;
                }

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Issuing event %1!x!.\n",
                    event
                    );

                ClusterEvent(event, node);
            }

            OmDereferenceObject(node);
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Node %1!ws! is not a cluster member. Rejecting request "
                "to set the node's extended state.\n",
                NodeId
                );
            status = ERROR_NODE_NOT_AVAILABLE;
        }

        NmpLockedLeaveApi();
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in a valid state to process request to set extended "
            "state for node %1!ws!\n",
            NodeId
            );
        status = ERROR_CLUSTER_NODE_NOT_READY;
    }

    NmpReleaseLock();

    return status;
} // NmpUpdateExtendedNodeState

DWORD
NmSetExtendedNodeState(
    IN CLUSTER_NODE_STATE State
    )
{
    DWORD Status;

    Status = GumSendUpdateEx(
                GumUpdateMembership,
                NmUpdateExtendedNodeState,
                2,
                sizeof(NmLocalNodeIdString),
                &NmLocalNodeIdString,
                sizeof(CLUSTER_NODE_STATE),
                &State
                );
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[INIT] NmUpdateExtendedNodeState node failed, status %1!d!.\n", Status);
    }

    return Status;
} // NmSetExtendedNodeState


DWORD
NmGetNodeId(
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Returns the given node's node ID.

Arguments:

    Node - Supplies a pointer to a node object.

Return Value:

    The node's node id.

Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/

{
    DWORD   nodeId;

    //
    // Since the caller has a reference on the object, and the node ID can't
    // be changed, it is safe to do this without taking a lock. It is also
    // necessary to prevent some deadlocks.
    //
    nodeId = Node->NodeId;

    return(nodeId);

}  // NmGetNodeId

HANDLE
NmGetNodeStateDownEvent(
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Returns the given node's Node down event.

Arguments:

    Node - Supplies a pointer to a node object.

Return Value:

    Handle of node down event.

Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/

{
    // Since caller has reference on the node object. It cannot vanish, the handle is only closed
    // in NmpDestroyNodeObject. Since this is a manual reset event no synchronization is needed.
    return Node->MmNodeStateDownEvent;

}//NmGetNodeStateDownEvent


DWORD
NmGetCurrentNumberOfNodes()
{
    DWORD       dwCnt = 0;
    PLIST_ENTRY pListEntry;

    NmpAcquireLock();

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        dwCnt++;
    }

    NmpReleaseLock();
    return(dwCnt);

}


DWORD
NmGetMaxNodeId(
)
/*++

Routine Description:

    Returns the max node's node ID.

Arguments:

    Node - Supplies a pointer to a node object.

Return Value:

    The node's node id.

Notes:

   Because the caller must have a reference on the node object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/

{

    return(NmMaxNodeId);

}  // NmGetMaxNodeId


VOID
NmpAdviseNodeFailure(
    IN PNM_NODE  Node,
    IN DWORD     ErrorCode
    )
/*++

Routine Description:

    Reports that a communication failure to the specified node has occurred.
    A poison packet will be sent to the failed node and regroup initiated.

Arguments:

    Node - Supplies a pointer to the node object for the failed node.

    ErrorCode - Supplies the error code that was returned from RPC

Return Value:

    None

Notes:

    Called with NM lock held.

--*/
{
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received advice that node %1!u! has failed with "
        "error %2!u!.\n",
        Node->NodeId,
        ErrorCode
        );

    if (Node->State != ClusterNodeDown) {
        LPCWSTR    nodeName = OmObjectName(Node);
        DWORD      status;

        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Banishing node %1!u! from active cluster membership.\n",
            Node->NodeId
            );

        OmReferenceObject(Node);

        NmpReleaseLock();

        status = MMEject(Node->NodeId);

        if (status == MM_OK) {
            CsLogEvent1(
                LOG_UNUSUAL,
                NM_EVENT_NODE_BANISHED,
                nodeName
                );
        }

        OmDereferenceObject(Node);

        NmpAcquireLock();
    }

    return;

}  // NmpAdviseNodeFailure


VOID
NmAdviseNodeFailure(
    IN DWORD NodeId,
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    Reports that a communication failure to the specified node has occurred.
    A poison packet will be sent to the failed node and regroup initiated.

Arguments:

    NodeId - Supplies the node id of the failed node.

    ErrorCode - Supplies the error code that was returned from RPC

Return Value:

    None

--*/
{
    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received advice that node %1!u! has failed with error %2!u!.\n",
        NodeId,
        ErrorCode
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE   node;

        CL_ASSERT(NmpIdArray != NULL);

        node = NmpIdArray[NodeId];

        NmpAdviseNodeFailure(node, ErrorCode);

        NmpLockedLeaveApi();
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process AdviseNodeFailure request.\n"
            );
    }

    NmpReleaseLock();

    return;

}  // NmAdviseNodeFailure


DWORD
NmEnumNodeInterfaces(
    IN  PNM_NODE          Node,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    )
/*++

Routine Description:

    Returns the list of interfaces associated with a specified node.

Arguments:

    Node - A pointer to the node object for which to enumerate interfaces.

    InterfaceCount - On output, contains the number of items in InterfaceList.

    InterfaceList - On output, points to an array of pointers to interface
                    objects. Each pointer in the array must be dereferenced
                    by the caller. The storage for the array must be
                    deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD             status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        if (Node->InterfaceCount > 0) {
            PNM_INTERFACE *  interfaceList = LocalAlloc(
                                                 LMEM_FIXED,
                                                 sizeof(PNM_INTERFACE) *
                                                 Node->InterfaceCount
                                                 );

            if (interfaceList != NULL) {
                PNM_INTERFACE     netInterface;
                PLIST_ENTRY       entry;
                DWORD             i;

                for (entry = Node->InterfaceList.Flink, i=0;
                     entry != &(Node->InterfaceList);
                     entry = entry->Flink, i++
                    )
                {
                    netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NodeLinkage);

                    OmReferenceObject(netInterface);
                    interfaceList[i] = netInterface;
                }

                *InterfaceCount = Node->InterfaceCount;
                *InterfaceList = interfaceList;
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            *InterfaceCount = 0;
            *InterfaceList = NULL;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process EnumNodeInterfaces request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // NmEnumNodeInterfaces


DWORD
NmGetNodeHighestVersion(
    IN PNM_NODE Node
    )
{
    return Node->HighestVersion;
}


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpUpdateAddNode(
    IN BOOL       SourceNode,
    IN LPDWORD    NewNodeId,
    IN LPCWSTR    NewNodeName,
    IN LPDWORD    NewNodeHighestVersion,
    IN LPDWORD    NewNodeLowestVersion,
    IN LPDWORD    NewNodeProductSuite
    )
/*++

Routine Description:

     GUM update handler for adding a new node to a cluster.

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the ID of the node.

    NewNodeName - A pointer to a string containing the name of the
                  new node.

    NewNodeHighestVersion - A pointer to the highest cluster version number
                            that the new node can support.

    NewNodeLowestVersion - A pointer to the lowest cluster version number
                           that the new node can support.

    NewNodeProductSuite - A pointer to the product suite identifier for
                          the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

     This routine is used to add an NT5 (or later) node to an NT5 (or
     later) cluster. It will never be invoked in a mixed NT4/NT5
     cluster.

--*/
{
    PNM_NODE          node = NULL;
    NM_NODE_INFO2     nodeInfo;
    HDMKEY            nodeKey = NULL;
    DWORD             disposition;
    DWORD             status;
    DWORD             registryNodeLimit;
    HLOCALXSACTION    xaction = NULL;
    BOOLEAN           lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] This node is not in a valid state to process a request "
            "to add node %1!ws! to the cluster.\n",
            NewNodeName
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Received an update to add node '%1!ws!' to "
        "the cluster with node ID %2!u!.\n",
        NewNodeName,
        *NewNodeId
        );

    if (*NewNodeId > NmMaxNodeId) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to add node %1!ws! to the cluster because the "
            "specified node ID, '%2!u!' , is not valid.\n",
            NewNodeName,
            *NewNodeId
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Read the registry override before acquiring the NM lock.
    //
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_MAX_NODES,
                 &registryNodeLimit,
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        registryNodeLimit = 0;
    }

    //
    // Begin a transaction - This must be done before acquiring the
    //                       NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to begin a transaction to add node %1!ws! "
            "to the cluster, status %2!u!.\n",
            NewNodeName,
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    //
    // Verify that we do not already have the maximum number of nodes
    // allowed in this cluster.
    //
    if (!NmpIsAddNodeAllowed(*NewNodeProductSuite, registryNodeLimit, NULL)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster. "
            "The cluster already contains the maximum number of nodes "
            "allowed by the product licenses of the current member nodes "
            "and the proposed new node. \n",
            NewNodeName
            );
        status = ERROR_LICENSE_QUOTA_EXCEEDED;
        goto error_exit;
    }

    //
    // Verify that the specified node ID is available.
    //
    if (NmpIdArray[*NewNodeId] != NULL) {
        status = ERROR_CLUSTER_NODE_EXISTS;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "node ID '%2!u!' is already in use.\n",
            NewNodeName,
            *NewNodeId
            );

        goto error_exit;
    }

    //
    // Try to create a key for the node in the cluster registry.
    //
    wsprintfW(&(nodeInfo.NodeId[0]), L"%u", *NewNodeId);

    nodeKey = DmLocalCreateKey(
                  xaction,
                  DmNodesKey,
                  nodeInfo.NodeId,
                  0,
                  KEY_READ | KEY_WRITE,
                  NULL,
                  &disposition
                  );

    if (nodeKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to create registry key for new "
            "node '%1!ws!' using node ID '%2!u!', status %3!u!\n",
            NewNodeName,
            *NewNodeId,
            status
            );
        goto error_exit;
    }

    if (disposition != REG_CREATED_NEW_KEY) {
        //
        // The key already exists. This must be
        // garbage leftover from a failed evict or oldstyle add.
        // We'll just overwrite the key.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] A partial definition exists for node ID '%1!u!'. "
            "A node addition or eviction operation may have failed.\n",
            *NewNodeId
            );
    }

    //
    // Add the rest of the node's parameters to the registry.
    //
    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_NAME,
                 REG_SZ,
                 (CONST BYTE *)NewNodeName,
                 NM_WCSLEN(NewNodeName)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to set registry value '%1!ws!', status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_NAME,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_HIGHEST_VERSION,
                 REG_DWORD,
                 (CONST BYTE *)NewNodeHighestVersion,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to set registry value '%1!ws!', status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_HIGHEST_VERSION,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_LOWEST_VERSION,
                 REG_DWORD,
                 (CONST BYTE *)NewNodeLowestVersion,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to set registry value %1!ws!, status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_LOWEST_VERSION,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 nodeKey,
                 CLUSREG_NAME_NODE_PRODUCT_SUITE,
                 REG_DWORD,
                 (CONST BYTE *)NewNodeProductSuite,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to set registry value %1!ws!, status %2!u!. "
            "Cannot add node '%3!ws!' to the cluster.\n",
            CLUSREG_NAME_NODE_PRODUCT_SUITE,
            status,
            NewNodeName
            );
        goto error_exit;
    }

    DmCloseKey(nodeKey); nodeKey = NULL;

    status = NmpGetNodeDefinition(&nodeInfo);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to read definition for node %1!ws! from the "
            "cluster database, status %2!u!.\n",
            NewNodeName,
            status
            );
        goto error_exit;
    }

    //
    // If a node happens to be joining right now, flag the fact that
    // it is now out of synch with the cluster config.
    //
    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Joiner (ID %1!u!) is now out of sync due to add of "
            "node %2!ws!.\n",
            NmpJoinerNodeId,
            NewNodeName
            );
        NmpJoinerOutOfSynch = TRUE;
    }

    //
    // Create the node object
    //
    NmpReleaseLock();

    node = NmpCreateNodeObject(&nodeInfo);

    ClNetFreeNodeInfo(&nodeInfo);

    NmpAcquireLock();

    if (node == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Failed to create object for node %1!ws!, "
            "status %2!u!.\n",
            NewNodeName,
            status
            );
        goto error_exit;
    }

    ClusterEvent(CLUSTER_EVENT_NODE_ADDED, node);
    CsLogEvent1(LOG_NOISE, NM_EVENT_NEW_NODE, NewNodeName);

    //
    // Remove the reference that NmpCreateNodeObject left on the node.
    //
    OmDereferenceObject(node);

    //
    // Reset the cluster version and node limit
    //
    NmpResetClusterVersion(FALSE);
    NmpResetClusterNodeLimit();

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Successfully added node %1!ws! to the cluster.\n",
        NewNodeName
        );

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction); xaction = NULL;
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (nodeKey != NULL) {
        DmCloseKey(nodeKey);
    }

    return(status);

} // NmpUpdateAddNode



DWORD
NmpUpdateCreateNode(
    IN BOOL SourceNode,
    IN LPDWORD NodeId
    )
/*++

Routine Description:

    GUM update handler for dynamically creating a new node

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the ID of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This handler was used by NT4 nodes. Since it is not possible to add
    an NT4 node to a cluster containing an NT5 node, this handler should
    never be called in an NT5 system.

--*/

{
    CL_ASSERT(FALSE);

    return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);

}  // NmpUpdateCreateNode



DWORD
NmpUpdatePauseNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for pausing a node

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the name of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    HLOCALXSACTION  xaction = NULL;
    PNM_NODE        node = NULL;
    BOOLEAN         lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process PauseNode update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to pause node %1!ws!\n",
        NodeId
        );

    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Node %1!ws! does not exist\n",
            NodeId
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (node->NodeId == NmpJoinerNodeId) {
        status = ERROR_CLUSTER_NODE_DOWN;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Cannot pause node %1!ws! because it is in the process "
            "of joining the cluster.\n",
            NodeId
            );
        goto error_exit;
    }

    if (node->State == ClusterNodeUp) {
        //
        // Update the registry to reflect the new state.
        //
        HDMKEY nodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_WRITE);

        if (nodeKey != NULL) {
            DWORD  isPaused = 1;

            status = DmLocalSetValue(
                         xaction,
                         nodeKey,
                         CLUSREG_NAME_NODE_PAUSED,
                         REG_DWORD,
                         (CONST BYTE *)&isPaused,
                         sizeof(isPaused)
                         );

#ifdef CLUSTER_TESTPOINT
            TESTPT(TpFailNmPauseNode) {
                status = 999999;
            }
#endif

            if (status == ERROR_SUCCESS) {
                node->State = ClusterNodePaused;
                ClusterEvent(CLUSTER_EVENT_NODE_CHANGE, node);

                //
                // If a node happens to be joining right now, flag the
                // fact that it is now out of synch with the cluster config.
                //
                if (NmpJoinerNodeId != ClusterInvalidNodeId) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NMJOIN] Joiner (ID %1!u!) is now out of sync due "
                        "to pause operation on node %2!ws!.\n",
                        NmpJoinerNodeId,
                        NodeId
                        );
                    NmpJoinerOutOfSynch = TRUE;
                }
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to set Paused value for node %1!ws!, "
                    "status %2!u!.\n",
                    NodeId,
                    status
                    );
            }

            DmCloseKey(nodeKey);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for node %1!ws!, status %2!u!.\n",
                NodeId,
                status
                );
        }
    }
    else if (node->State != ClusterNodePaused) {
        status = ERROR_CLUSTER_NODE_DOWN;
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    return(status);

}  // NmpUpdatePauseNode



DWORD
NmpUpdateResumeNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for resuming a node

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the name of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    HLOCALXSACTION  xaction = NULL;
    PNM_NODE        node = NULL;
    BOOLEAN         lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process ResumeNode update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to resume node %1!ws!\n",
        NodeId
        );

    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Node %1!ws! does not exist\n",
            NodeId
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (node->NodeId == NmpJoinerNodeId) {
        status = ERROR_CLUSTER_NODE_DOWN;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Cannot resume node %1!ws! because it is in the process "
            "of joining the cluster.\n",
            NodeId
            );
        goto error_exit;
    }

    if (node->State == ClusterNodePaused) {
        //
        // Update the registry to reflect the new state.
        //
        HDMKEY nodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_WRITE);

        if (nodeKey != NULL) {
            status = DmLocalDeleteValue(
                         xaction,
                         nodeKey,
                         CLUSREG_NAME_NODE_PAUSED
                         );

#ifdef CLUSTER_TESTPOINT
            TESTPT(TpFailNmResumeNode) {
                status = 999999;
            }
#endif

            if (status == ERROR_SUCCESS) {
                node->State = ClusterNodeUp;
                ClusterEvent(CLUSTER_EVENT_NODE_CHANGE, node);

                //
                // If a node happens to be joining right now, flag the
                // fact that it is now out of synch with the cluster config.
                //
                if (NmpJoinerNodeId != ClusterInvalidNodeId) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NMJOIN] Joiner (ID %1!u!) is now out of sync due "
                        "to resume operation on node %2!ws!.\n",
                        NmpJoinerNodeId,
                        NodeId
                        );
                    NmpJoinerOutOfSynch = TRUE;
                }
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to delete Paused value for node %1!ws!, "
                    "status %2!u!.\n",
                    NodeId,
                    status
                    );
            }

            DmCloseKey(nodeKey);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to open key for node %1!ws!, status %2!u!.\n",
                NodeId,
                status
                );
        }
    }
    else {
        status = ERROR_CLUSTER_NODE_NOT_PAUSED;
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    return(status);

}  // NmpUpdateResumeNode



DWORD
NmpUpdateEvictNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for evicting a node.

    The specified node is deleted from the OM.

    If the specified node is online, it is paused to prevent any other groups
    from moving there.

    If the specified node is the current node, it attempts to failover any
    owned groups.

Arguments:

    SourceNode - Specifies whether or not this is the source node for the update

    NodeId - Specifies the name of the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    It is very hard to make this operation abortable, so it isn't. If anything
    goes wrong past a certain point, the node will halt.

    Assumption: Since global updates are serialized, and local transactions
    guarantee exclusive access to the registry, no other updates can be made in
    parallel by the FM.

--*/

{
    DWORD            status = ERROR_SUCCESS;
    PNM_NODE         node = NULL;
    HLOCALXSACTION   xaction = NULL;
    PNM_NETWORK      network;
    LPCWSTR          networkId;
    PNM_INTERFACE    netInterface;
    LPCWSTR          interfaceId;
    PLIST_ENTRY      entry;
    BOOLEAN          lockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process EvictNode update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to evict node %1!ws!\n",
        NodeId
        );

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Node %1!ws! does not exist\n",
            NodeId
            );
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        goto error_exit;
    }

    //
    // Begin a transaction
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Cannot evict node because a join is in progress.\n"
            );
        goto error_exit;
    }

    //
    // Only continue if the node is down. Evicting a node while it
    // is actively participating in the cluster is way too tricky.
    //
    if (node->State != ClusterNodeDown) {
        status = ERROR_CANT_EVICT_ACTIVE_NODE;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Node %1!ws! cannot be evicted because it is not offline.\n",
            NodeId
            );
        goto error_exit;
    }

    //
    // Scrub the FM's portion of the registry of all references to this node.
    //
    status = NmpCleanseRegistry(NodeId, xaction);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to remove all resource database references to "
            "evicted node %1!ws!, status %2!u!\n",
            NodeId,
            status
            );
        goto error_exit;
    }

    //
    // Delete the node's interfaces from the database.
    //
    for (entry = node->InterfaceList.Flink;
         entry != &(node->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        interfaceId = OmObjectId(netInterface);
        network = netInterface->Network;
        networkId = OmObjectId(network);

        //
        // Delete the interface definition from the database.
        //
        status = DmLocalDeleteTree(xaction, DmNetInterfacesKey, interfaceId);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to delete definition for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        if (network->InterfaceCount == 1) {
            //
            // This is the last interface on the network.
            // Delete the network too.
            //
            status = DmLocalDeleteTree(xaction, DmNetworksKey, networkId);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to delete definition for network %1!ws!, "
                    "status %2!u!.\n",
                    networkId,
                    status
                    );
                goto error_exit;
            }
        }
    }

    //
    // Delete the node's database entry
    //
    status = DmLocalDeleteTree(xaction, DmNodesKey, NodeId);

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmEvictNodeAbort) {
        status = 999999;
    }
#endif

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to delete node's database key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // WARNING: From here on, operations cannot be reversed.
    // If any one of them fails, this node must halt to avoid being
    // inconsistent.
    //

    //
    // Delete the interface objects associated with this node.
    //
    while (!IsListEmpty(&(node->InterfaceList))) {
        entry = node->InterfaceList.Flink;

        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        network = netInterface->Network;
        networkId = OmObjectId(network);

        NmpDeleteInterfaceObject(netInterface, TRUE);

        if (network->InterfaceCount == 0) {
            //
            // This is the last interface on the network.
            // Delete the network too.
            //
            NmpDeleteNetworkObject(network, TRUE);
        }
    }

    //
    // Delete the node's object.
    //
    NmpDeleteNodeObject(node, TRUE);

    //after the node is deleted, recalculate the operational version of
    //the cluster
    NmpResetClusterVersion(TRUE);

    //calculate the operational limit on the number of nodes that
    //can be a part of this cluster
    NmpResetClusterNodeLimit();

    NmpReleaseLock(); lockAcquired = FALSE;

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmEvictNodeHalt) {
        status = 999999;
    }
#endif

    if (status != ERROR_SUCCESS ) {
        WCHAR  string[16];

        wsprintfW(&(string[0]), L"%u", status);

        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] FATAL ERROR: Failed to remove all resource references to evicted node %1!ws!, status %2!u!\n",
            NodeId,
            status
            );

        CsLogEvent3(
            LOG_CRITICAL,
            NM_EVENT_EVICTION_ERROR,
            NmLocalNodeName,
            OmObjectName(node),
            string
            );

        CsInconsistencyHalt(status);
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to evict node %1!ws!.\n",
            NodeId
            );
    }

    return(status);

}  // NmpUpdateEvictNode


/////////////////////////////////////////////////////////////////////////////
//
// Database management routines
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpGetNodeDefinition(
    IN OUT PNM_NODE_INFO2   NodeInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster node from the cluster database
    and stores the information in a supplied structure.

Arguments:

    NodeInfo  - A pointer to the structure into which to store the node
                information. The NodeId field of the structure contains
                the ID of the node for which to read information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD           status;
    HDMKEY          nodeKey = NULL;
    DWORD           valueLength;
    DWORD           valueType;
    LPWSTR          string;
    WCHAR           errorString[12];


    nodeKey = DmOpenKey(DmNodesKey, NodeInfo->NodeId, KEY_READ);

    if (nodeKey == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            NodeInfo->NodeId,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open node key, status %1!u!\n",
            status
            );
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto error_exit;
    }

    valueLength = sizeof(NodeInfo->NodeName);
    string = CLUSREG_NAME_NODE_NAME;

    status = DmQueryValue(
                 nodeKey,
                 string,
                 &valueType,
                 (LPBYTE) &(NodeInfo->NodeName[0]),
                 &valueLength
                 );

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to read node name, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    if (valueType != REG_SZ) {
        status = ERROR_INVALID_PARAMETER;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        goto error_exit;
    }

    //read the node's highest version
    string = CLUSREG_NAME_NODE_HIGHEST_VERSION;
    status = DmQueryDword(nodeKey, string, &NodeInfo->NodeHighestVersion,
                NULL);
    if (status != ERROR_SUCCESS)
    {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        //this can happen on an upgrade from sp3 to nt5
        //assume the node highest version is that of sp3
        //the fixup function will get this fixed
        NodeInfo->NodeHighestVersion = CLUSTER_MAKE_VERSION(1, 224);
    }

    //read the node's lowest version
    string = CLUSREG_NAME_NODE_LOWEST_VERSION;
    status = DmQueryDword(nodeKey, string, &NodeInfo->NodeLowestVersion,
                NULL);
    if (status != ERROR_SUCCESS)
    {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        //this can happen on upgrade from sp3 to nt5
        //if the nodelowestversion is not present assume it
        //was an sp3 node(lowest version is 1.224)
        NodeInfo->NodeLowestVersion = CLUSTER_MAKE_VERSION( 1, 224);
    }


    NodeInfo->State = ClusterNodeDown;

    DmCloseKey(nodeKey);

    return(ERROR_SUCCESS);


error_exit:

    ClNetFreeNodeInfo(NodeInfo);

    if (nodeKey != NULL) {
        DmCloseKey(nodeKey);
    }

    return(status);

}  // NmpGetNodeDefinition


DWORD
NmpGetNodeAuxInfo(
    IN LPCWSTR NodeId,
    IN OUT PNM_NODE_AUX_INFO   pNodeAuxInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster node from the cluster database
    and stores the information in a supplied structure.

Arguments:

    pNodeAuxInfo  - A pointer to the structure into which to store the node
                information. The NodeId field of the structure contains
                the ID of the node for which to read information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD           status;
    HDMKEY          nodeKey = NULL;
    DWORD           valueLength;
    DWORD           valueType;
    LPWSTR          string;
    WCHAR           errorString[12];


    nodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_READ);

    if (nodeKey == NULL)
    {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            NodeId,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] NmpGetNodeAuxInfo : Failed to open node key, "
             "status %1!u!\n",
             status);
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto error_exit;
    }


    //read the node's product suite
    string = CLUSREG_NAME_NODE_PRODUCT_SUITE;
    status = DmQueryDword(
                 nodeKey,
                 string,
                 (LPDWORD)&(pNodeAuxInfo->ProductSuite),
                NULL
                );
    if (status != ERROR_SUCCESS)
    {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_NOISE,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        //assume it is enterprise
        pNodeAuxInfo->ProductSuite = Enterprise;

    }


    DmCloseKey(nodeKey);

    return(ERROR_SUCCESS);


error_exit:
    if (nodeKey != NULL)
    {
        DmCloseKey(nodeKey);
    }

    return(status);

}  // NmpGetNodeAuxInfo



DWORD
NmpEnumNodeDefinitions(
    PNM_NODE_ENUM2 *  NodeEnum
    )
/*++

Routine Description:

    Reads information about all defined cluster nodes from the cluster
    database and builds an enumeration structure containing the information.

Arguments:

    NodeEnum -  A pointer to the variable into which to place a pointer to
                the allocated node enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine MUST NOT be called with the NM lock held.

--*/

{
    DWORD            status;
    PNM_NODE_ENUM2   nodeEnum = NULL;
    DWORD            i;
    DWORD            valueLength;
    DWORD            numNodes;
    DWORD            ignored;
    FILETIME         fileTime;
    WCHAR            errorString[12];
    HLOCALXSACTION   xaction;
    BOOLEAN          commitXaction = FALSE;


    *NodeEnum = NULL;

    //
    // Begin a transaction - this must not be done while holding
    //                       the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to begin a transaction, status %1!u!.\n",
            status
            );
    }

    NmpAcquireLock();

    //
    // First count the number of nodes.
    //
    status = DmQueryInfoKey(
                 DmNodesKey,
                 &numNodes,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_REG_OPERATION_FAILED, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to query Nodes key information, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    valueLength = sizeof(NM_NODE_ENUM2) +
                  (sizeof(NM_NODE_INFO2) * (numNodes - 1));

    nodeEnum = MIDL_user_allocate(valueLength);

    if (nodeEnum == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        goto error_exit;
   }

    ZeroMemory(nodeEnum, valueLength);

    for (i=0; i < numNodes; i++) {
        valueLength = sizeof(nodeEnum->NodeList[nodeEnum->NodeCount].NodeId);

        status = DmEnumKey(
                     DmNodesKey,
                     i,
                     &(nodeEnum->NodeList[nodeEnum->NodeCount].NodeId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent1(
                LOG_CRITICAL,
                CS_EVENT_REG_OPERATION_FAILED,
                errorString
                );
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to enumerate node key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetNodeDefinition(
                     &(nodeEnum->NodeList[nodeEnum->NodeCount])
                     );

        if (status != ERROR_SUCCESS) {
            if (status == ERROR_FILE_NOT_FOUND) {
                //
                // Partial node definition in the database.
                // Probably from a failed AddNode operation.
                //
                LPWSTR nodeIdString =
                           nodeEnum->NodeList[nodeEnum->NodeCount].NodeId;
                DWORD  nodeId = wcstoul(
                                    nodeIdString,
                                    NULL,
                                    10
                                    );

                //
                // Delete the key and ignore it in the enum struct if it
                // is safe to do so.
                //
                if ( (NmpIdArray[nodeId] == NULL) &&
                     (nodeId != NmLocalNodeId)
                   )
                {
                    if (xaction != NULL) {
                        DWORD status2;

                        ClRtlLogPrint(LOG_CRITICAL,
                            "[NM] Deleting partial definition for node "
                            "ID %1!ws!\n",
                            nodeIdString
                            );

                        status2 = DmLocalDeleteKey(
                                      xaction,
                                      DmNodesKey,
                                      nodeIdString
                                      );


                        if (status2 == ERROR_SUCCESS) {
                            commitXaction = TRUE;
                        }
                    }
                }

                continue;
            }

            goto error_exit;
        }

        nodeEnum->NodeCount++;
    }

    *NodeEnum = nodeEnum;

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    NmpReleaseLock();

    if (xaction != NULL) {
        if ((status == ERROR_SUCCESS) && commitXaction) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if ((status != ERROR_SUCCESS) && (nodeEnum != NULL)) {
        ClNetFreeNodeEnum(nodeEnum);
    }

    return(status);

}  // NmpEnumNodeDefinitions


/////////////////////////////////////////////////////////////////////////////
//
// Object management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNodeObjects(
    IN PNM_NODE_ENUM2  NodeEnum
    )
/*++

Routine Description:

    Processes a node information enumeration and creates node objects.

Arguments:

    NodeEnum - A pointer to a node information enumeration structure.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NODE_INFO2 nodeInfo;
    DWORD          i;
    PNM_NODE       node;
    BOOLEAN        foundLocalNode = FALSE;


    for (i=0; i < NodeEnum->NodeCount; i++) {
        nodeInfo = &(NodeEnum->NodeList[i]);

        //
        // The local node object was created during initialization.
        // Skip it.
        //
        if (wcscmp(NmLocalNodeIdString, nodeInfo->NodeId) != 0) {
            node = NmpCreateNodeObject(nodeInfo);

            if (node == NULL) {
                status = GetLastError();
                break;
            }
            else {
                OmDereferenceObject(node);
            }
        }
        else {
            foundLocalNode = TRUE;
        }
    }

    if ( !foundLocalNode ) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
    }

    return(status);

}  // NmpCreateNodeObjects


DWORD
NmpCreateLocalNodeObject(
    IN PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Creates a node object for the local node given information about the node.

Arguments:

    NodeInfo - A pointer to a structure containing a description of the node
               to create.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD       status;
    LPWSTR      string;

    CL_ASSERT(NmLocalNode == NULL);

    //
    // Verify that the node name matches the local computername.
    //
    if (wcscmp(NodeInfo->NodeName, NmLocalNodeName) != 0) {
        string = L"";
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_NODE_NOT_MEMBER,
            NmLocalNodeName,
            string
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Computername does not match node name in database.\n"
            );
        return(ERROR_INVALID_PARAMETER);
    }

    NmLocalNode = NmpCreateNodeObject(NodeInfo);

    if (NmLocalNode == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create local node (%1!ws!), status %2!u!.\n",
            NodeInfo->NodeId,
            status
            );
        return(status);
    }
    else {
        NmLocalNode->ExtendedState = ClusterNodeJoining;
        OmDereferenceObject(NmLocalNode);
    }

    return(ERROR_SUCCESS);
}


PNM_NODE
NmpCreateNodeObject(
    IN PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Creates a node object given information about the node.

Arguments:

    NodeInfo - A pointer to a structure containing a description of the node
               to create.

Return Value:

    A pointer to the created node object if successful.
    NULL if not successful. Extended error information is available
    from GetLastError().

--*/
{
    PNM_NODE    node = NULL;
    DWORD       status = ERROR_SUCCESS;
    BOOL        created = FALSE;
    DWORD       eventCode = 0;
    WCHAR       errorString[12];


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating object for node %1!ws! (%2!ws!)\n",
        NodeInfo->NodeId,
        NodeInfo->NodeName
        );

    //
    // Make sure that the node doesn't already exist.
    //
    node = OmReferenceObjectById(ObjectTypeNode, NodeInfo->NodeId);

    if (node == NULL) {
      //
      // Make sure that the node doesn't already exist, this time by name.
      //
      node = OmReferenceObjectByName(ObjectTypeNode, NodeInfo->NodeName);
    }

    if (node != NULL) {
        OmDereferenceObject(node);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Object already exists for node %1!ws!\n",
            NodeInfo->NodeId
            );
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
        return(NULL);
    }

    node = OmCreateObject(
               ObjectTypeNode,
               NodeInfo->NodeId,
               NodeInfo->NodeName,
               &created
               );

    if (node == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for node %1!ws! (%2!ws!), status %3!u!\n",
            NodeInfo->NodeId,
            NodeInfo->NodeName,
            status
            );
        SetLastError(status);
        return(NULL);
    }

    CL_ASSERT(created == TRUE);

    ZeroMemory(node, sizeof(NM_NODE));

    node->NodeId = wcstoul(NodeInfo->NodeId, NULL, 10);
    node->State = NodeInfo->State;

    // Create the MM node state down event. This event tracks what MM thinks of the node state.
    if (NM_NODE_UP(node)) {
        node->MmNodeStateDownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    }
    else {
        node->MmNodeStateDownEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    }

    if (node->MmNodeStateDownEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create node down event for node=%1!u! status=%2!u!.\n",
            node->NodeId,
            status
            );
        goto error_exit;
    }


    // A join cannot proceed if any of the current node's ExtendedState is not up. But the State might be paused.
    // So don't copy the State field into ExtendedState field. (#379170)
    node->ExtendedState = ClusterNodeUp;


    node->HighestVersion = NodeInfo->NodeHighestVersion;
    node->LowestVersion = NodeInfo->NodeLowestVersion;

    //for now assume enterprise
    //NmpRefresh will fixup this information later..
    node->ProductSuite = Enterprise;

    InitializeListHead(&(node->InterfaceList));

    CL_ASSERT(NmIsValidNodeId(node->NodeId));

    if (node->NodeId != NmLocalNodeId) {
        status = ClusnetRegisterNode(NmClusnetHandle, node->NodeId);

        if (status != ERROR_SUCCESS) {
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent2(
                LOG_CRITICAL,
                NM_EVENT_CLUSNET_REGISTER_NODE_FAILED,
                NodeInfo->NodeId,
                errorString
                );

            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to register node %1!ws! (%2!ws!) with the Cluster Network, status %3!u!\n",
                NodeInfo->NodeId,
                NodeInfo->NodeName,
                status
                );
            goto error_exit;
        }
    }

    //
    // Put a reference on the object for the caller.
    //
    OmReferenceObject(node);

    NmpAcquireLock();

    if (NM_NODE_UP(node)) {
        //
        // Add this node to the up nodes set
        //
        BitsetAdd(NmpUpNodeSet, node->NodeId);

        //
        // Enable communication with this node during the
        // join process.
        //
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Enabling communication for node %1!ws!\n",
            NodeInfo->NodeId
            );
        status = ClusnetOnlineNodeComm(NmClusnetHandle, node->NodeId);

        if (status != ERROR_SUCCESS) {
            NmpReleaseLock();
            OmDereferenceObject(node);

            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent2(
                LOG_CRITICAL,
                NM_EVENT_CLUSNET_ONLINE_COMM_FAILED,
                NodeInfo->NodeId,
                errorString
                );

            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to enable node %1!ws! (%2!ws!) for communication, status %3!u!\n",
                NodeInfo->NodeId,
                NodeInfo->NodeName,
                status
                );
            goto error_exit;
        }
    }

    CL_ASSERT(NmpIdArray != NULL);
    CL_ASSERT(NmpIdArray[node->NodeId] == NULL);
    NmpIdArray[node->NodeId] = node;
    InsertTailList(&NmpNodeList, &(node->Linkage));
    node->Flags |= NM_FLAG_OM_INSERTED;
    OmInsertObject(node);
    NmpNodeCount++;

    NmpReleaseLock();

    return(node);

error_exit:

    ClRtlLogPrint(LOG_CRITICAL,
        "[NM] Failed to create object for node %1!ws!, status %2!u!.\n",
        NodeInfo->NodeId,
        status
        );

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    if (node != NULL) {
        NmpAcquireLock();
        NmpDeleteNodeObject(node, FALSE);
        NmpReleaseLock();
    }

    SetLastError(status);

    return(NULL);

}  // NmpCreateNodeObject



DWORD
NmpGetNodeObjectInfo(
    IN     PNM_NODE        Node,
    IN OUT PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster node from the its cluster
    object and stores the information in a supplied structure.

Arguments:

    Node - A pointer to the node object to query.

    NodeInfo  - A pointer to the structure into which to store the node
                information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD           status;

    lstrcpyW(&(NodeInfo->NodeId[0]), OmObjectId(Node));
    lstrcpyW(&(NodeInfo->NodeName[0]), OmObjectName(Node));
    NodeInfo->State = Node->State;
    NodeInfo->NodeHighestVersion = Node->HighestVersion;
    NodeInfo->NodeLowestVersion = Node->LowestVersion;

    return(ERROR_SUCCESS);

}  // NmpGetNodeObjectInfo


VOID
NmpDeleteNodeObject(
    IN PNM_NODE   Node,
    IN BOOLEAN    IssueEvent
    )
/*++

Notes:

    Called with NM lock held.

--*/
{
    DWORD           status;
    PNM_INTERFACE   netInterface;
    PLIST_ENTRY     entry;
    LPWSTR          nodeId = (LPWSTR) OmObjectId(Node);


    if (NM_DELETE_PENDING(Node)) {
        CL_ASSERT(!NM_OM_INSERTED(Node));
        return;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Deleting object for node %1!ws!.\n",
        nodeId
        );

    Node->Flags |= NM_FLAG_DELETE_PENDING;

    //
    // Remove from the various object lists.
    //
    if (NM_OM_INSERTED(Node)) {
        status = OmRemoveObject(Node);
        CL_ASSERT(status == ERROR_SUCCESS);
        Node->Flags &= ~NM_FLAG_OM_INSERTED;
        RemoveEntryList(&(Node->Linkage));
        NmpIdArray[Node->NodeId] = NULL;
        CL_ASSERT(NmpNodeCount > 0);
        NmpNodeCount--;
    }

    //
    // Delete all of the interfaces on this node
    //
    while (!IsListEmpty(&(Node->InterfaceList))) {
        entry = Node->InterfaceList.Flink;
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NodeLinkage);

        NmpDeleteInterfaceObject(netInterface, IssueEvent);
    }

    status = ClusnetDeregisterNode(NmClusnetHandle, Node->NodeId);

    CL_ASSERT( (status == ERROR_SUCCESS) ||
               (status == ERROR_NOT_READY) ||
               (status == ERROR_CLUSTER_NODE_NOT_FOUND)
             );

    if (IssueEvent) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Issuing delete event for node %1!ws!.\n",
            nodeId
            );

        ClusterEvent(CLUSTER_EVENT_NODE_DELETED, Node);
    }

    OmDereferenceObject(Node);

    return;

}  // NmpDeleteNodeObject


BOOL
NmpDestroyNodeObject(
    PNM_NODE  Node
    )
{
    DWORD  status;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] destroying node %1!ws!\n",
        OmObjectId(Node)
        );

    CL_ASSERT(NM_DELETE_PENDING(Node));
    CL_ASSERT(!NM_OM_INSERTED(Node));

    ClMsgDeleteDefaultRpcBinding(Node, Node->DefaultRpcBindingGeneration);
    ClMsgDeleteRpcBinding(Node->ReportRpcBinding);
    ClMsgDeleteRpcBinding(Node->IsolateRpcBinding);

    // Delete the Node down event.
    if (Node->MmNodeStateDownEvent != NULL) {
        CloseHandle(Node->MmNodeStateDownEvent);
        Node->MmNodeStateDownEvent = NULL;
    }

    return(TRUE);

}  // NmpDestroyNodeObject


DWORD
NmpEnumNodeObjects(
    PNM_NODE_ENUM2 *  NodeEnum
    )
/*++

Routine Description:

    Reads information about all defined cluster nodes from the cluster
    object manager and builds an enumeration structure containing
    the information.

Arguments:

    NodeEnum -  A pointer to the variable into which to place a pointer to
                the allocated node enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    PNM_NODE_ENUM2  nodeEnum = NULL;
    DWORD           i;
    DWORD           valueLength;
    PLIST_ENTRY     entry;
    PNM_NODE        node;


    *NodeEnum = NULL;

    if (NmpNodeCount == 0) {
        valueLength = sizeof(NM_NODE_ENUM2);

    }
    else {
        valueLength = sizeof(NM_NODE_ENUM2) +
                      (sizeof(NM_NODE_INFO2) * (NmpNodeCount - 1));
    }

    nodeEnum = MIDL_user_allocate(valueLength);

    if (nodeEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(nodeEnum, valueLength);

    for (entry = NmpNodeList.Flink, i=0;
         entry != &NmpNodeList;
         entry = entry->Flink, i++
        )
    {
        node = CONTAINING_RECORD(entry, NM_NODE, Linkage);

        status = NmpGetNodeObjectInfo(
                     node,
                     &(nodeEnum->NodeList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeNodeEnum(nodeEnum);
            return(status);
        }
    }

    nodeEnum->NodeCount = NmpNodeCount;
    *NodeEnum = nodeEnum;
    nodeEnum = NULL;

    return(ERROR_SUCCESS);


}  // NmpEnumNodeObjects


DWORD
NmpSetNodeInterfacePriority(
    IN  PNM_NODE Node,
    IN  DWORD Priority,
    IN  PNM_INTERFACE TargetInterface OPTIONAL,
    IN  DWORD TargetInterfacePriority OPTIONAL
    )
/*++

    Called with the NmpLock held.

--*/
{
    PNM_INTERFACE netInterface;
    PNM_NETWORK   network;
    DWORD         status = ERROR_SUCCESS;
    PLIST_ENTRY   entry;


    for (entry = Node->InterfaceList.Flink;
         entry != &Node->InterfaceList;
         entry = entry->Flink
         )
    {
        netInterface = CONTAINING_RECORD( entry, NM_INTERFACE, NodeLinkage );
        network = netInterface->Network;

        if ( NmpIsNetworkForInternalUse(network) &&
             NmpIsInterfaceRegistered(netInterface)
           )
        {
            if ( netInterface == TargetInterface ) {

                status = ClusnetSetInterfacePriority(
                             NmClusnetHandle,
                             netInterface->Node->NodeId,
                             netInterface->Network->ShortId,
                             TargetInterfacePriority
                             );
            } else {

                status = ClusnetSetInterfacePriority(
                             NmClusnetHandle,
                             netInterface->Node->NodeId,
                             netInterface->Network->ShortId,
                             Priority
                             );

            }
        }

        if ( status != ERROR_SUCCESS ) {
            break;
        }
    }

    return(status);

} // NmpSetNodeInterfacePriority


/////////////////////////////////////////////////////////////////////////////
//
// Node eviction utilities
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpCleanseRegistry(
    IN LPCWSTR          NodeId,
    IN HLOCALXSACTION   Xaction
    )
/*++

Routine Description:

    Removes all references to the specified node from the cluster
    registry.

Arguments:

    Node - Supplies the node that is being evicted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    NM_EVICTION_CONTEXT   context;


    context.NodeId = NodeId;
    context.Xaction = Xaction;
    context.Status = ERROR_SUCCESS;

    //
    // Remove this node from the possible owner list of
    // each resource type.
    //
    OmEnumObjects(
        ObjectTypeResType,
        NmpCleanseResTypeCallback,
        &context,
        NULL
        );

    if (context.Status == ERROR_SUCCESS) {
        //
        // Remove this node from the preferred owner list of
        // each group.
        //
        OmEnumObjects(
            ObjectTypeGroup,
            NmpCleanseGroupCallback,
            &context,
            NULL
            );
    }

    if (context.Status == ERROR_SUCCESS) {
        //
        // Remove this node from the possible owner list of
        // each resource.
        //
        OmEnumObjects(
            ObjectTypeResource,
            NmpCleanseResourceCallback,
            &context,
            NULL
            );
    }

    return(context.Status);

}  // NmpCleanseRegistry



BOOL
NmpCleanseGroupCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR GroupName
    )
/*++

Routine Description:

    Group enumeration callback for removing an evicted node from the
    group's preferred owners list.

Arguments:

    Context - Supplies the node ID of the evicted node and other context info.

    Context2 - Not used

    Group - Supplies the group.

    GroupName - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    HDMKEY  groupKey;
    DWORD   status;


    //
    // Open the group's key.
    //
    groupKey = DmOpenKey(DmGroupsKey, GroupName, KEY_READ | KEY_WRITE);

    if (groupKey != NULL) {
        status = DmLocalRemoveFromMultiSz(
                     Context->Xaction,
                     groupKey,
                     CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                     Context->NodeId
                     );

        if (status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_SUCCESS;
        }

        DmCloseKey(groupKey);
    }
    else {
        status = GetLastError();
    }

    Context->Status = status;

    if (status != ERROR_SUCCESS) {
        return(FALSE);
    }
    else {
        return(TRUE);
    }

}  // NmpCleanseGroupCallback



BOOL
NmpCleanseResourceCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR ResourceName
    )
/*++

Routine Description:

    Group enumeration callback for removing an evicted node from the
    resource's possible owner's list.

    Also deletes any node-specific parameters from the resource's registry
    key.

Arguments:

    Context - Supplies the node ID of the evicted node and other context info.

    Context2 - Not used

    Resource - Supplies the resource.

    ResourceName - Supplies the resource's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    HDMKEY  resourceKey;
    HDMKEY  paramKey;
    HDMKEY  subKey;
    DWORD   status;


    //
    // Open the resource's key.
    //
    resourceKey = DmOpenKey(
                      DmResourcesKey,
                      ResourceName,
                      KEY_READ | KEY_WRITE
                      );

    if (resourceKey != NULL) {
        status = DmLocalRemoveFromMultiSz(
                     Context->Xaction,
                     resourceKey,
                     CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                     Context->NodeId
                     );

        if ((status == ERROR_SUCCESS) || (status == ERROR_FILE_NOT_FOUND)) {
            paramKey = DmOpenKey(
                           resourceKey,
                           CLUSREG_KEYNAME_PARAMETERS,
                           KEY_READ | KEY_WRITE
                           );

            if (paramKey != NULL) {

                status = DmLocalDeleteTree(
                             Context->Xaction,
                             paramKey,
                             Context->NodeId
                             );

                DmCloseKey(paramKey);
            }
            else {
                status = GetLastError();
            }
        }

        DmCloseKey(resourceKey);
    }
    else {
        status = GetLastError();
    }

    if (status == ERROR_FILE_NOT_FOUND) {
        status = ERROR_SUCCESS;
    }

    Context->Status = status;

    if (status != ERROR_SUCCESS) {
        return(FALSE);
    }
    else {
        return(TRUE);
    }

}  // NmpCleanseResourceCallback

BOOL
NmpCleanseResTypeCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESTYPE pResType,
    IN LPCWSTR pszResTypeName
    )
/*++

Routine Description:

    Group enumeration callback for removing an evicted node from the
    resource type's possible owner's list.

    Also deletes any node-specific parameters from the resource types's registry
    key.

Arguments:

    Context - Supplies the node ID of the evicted node and other context info.

    Context2 - Not used

    pResType - Supplies the resource type.

    pszResTypeeName - Supplies the resource type's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    HDMKEY  hResTypeKey;
    HDMKEY  paramKey;
    HDMKEY  subKey;
    DWORD   status;


    //
    // Open the resource's key.
    //
    hResTypeKey = DmOpenKey(
                      DmResourceTypesKey,
                      pszResTypeName,
                      KEY_READ | KEY_WRITE
                      );

    if (hResTypeKey != NULL) {
        status = DmLocalRemoveFromMultiSz(
                     Context->Xaction,
                     hResTypeKey,
                     CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                     Context->NodeId
                     );

        if ((status == ERROR_SUCCESS) || (status == ERROR_FILE_NOT_FOUND)) {
            paramKey = DmOpenKey(
                           hResTypeKey,
                           CLUSREG_KEYNAME_PARAMETERS,
                           KEY_READ | KEY_WRITE
                           );

            if (paramKey != NULL) {

                status = DmLocalDeleteTree(
                             Context->Xaction,
                             paramKey,
                             Context->NodeId
                             );

                DmCloseKey(paramKey);
            }
            else {
                status = GetLastError();
            }
        }

        DmCloseKey(hResTypeKey);
    }
    else {
        status = GetLastError();
    }

    if (status == ERROR_FILE_NOT_FOUND) {
        status = ERROR_SUCCESS;
    }

    Context->Status = status;

    if (status != ERROR_SUCCESS) {
        return(FALSE);
    }
    else {
        return(TRUE);
    }

}  // NmpCleanseResTypeCallback


/////////////////////////////////////////////////////////////////////////////
//
// Node failure handler
//
/////////////////////////////////////////////////////////////////////////////

VOID
NmpNodeFailureHandler(
    CL_NODE_ID    NodeId,
    LPVOID        NodeFailureContext
    )
{
    return;
}


/////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous routines
//
/////////////////////////////////////////////////////////////////////////////



//SS: when the node objects are created, their product suite is
//assumed to be Enterprise(aka Advanced Server) - This is because
//the joining interface doesnt allow the joiner to provide the node
//suite type and we didnt want to muck with it at a late state in
//shipping because it affects mixed mode clusters.
//SO, we fixup the structures after NmPerformFixups is called
//and calculate the cluster node limit
DWORD NmpRefreshNodeObjects(
)
{

    NM_NODE_AUX_INFO    NodeAuxInfo;
    PLIST_ENTRY         pListEntry;
    PNM_NODE            pNmNode;
    WCHAR               szNodeId[6];
    DWORD               dwStatus = ERROR_SUCCESS;

    NmpAcquireLock();

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

        wsprintf(szNodeId, L"%u", pNmNode->NodeId);
        //read the information from the registry
        NmpGetNodeAuxInfo(szNodeId, &NodeAuxInfo);
        //update the node structure
        pNmNode->ProductSuite = NodeAuxInfo.ProductSuite;

        //SS: This is ugly---we should pass in the product suits early on.
        //we dont know that the versions have changed, so should we  generate
        //a cluster_change_node_property event?
        //Also the fixup interface needs to to be richer so that the postcallback
        //function knows whether it is a form fixup or a join fixup and if it
        //is a join fixup, which node is joining.  This could certainly optimize
        //some of the fixup processing
        ClusterEvent(CLUSTER_EVENT_NODE_PROPERTY_CHANGE, pNmNode);

    }

    NmpReleaseLock();

    return(dwStatus);
}


BOOLEAN
NmpIsAddNodeAllowed(
    IN  DWORD    NewNodeProductSuite,
    IN  DWORD    RegistryNodeLimit,
    OUT LPDWORD  EffectiveNodeLimit  OPTIONAL
    )
/*++

Routine Description:

    Determines whether a new node can be added to the cluste membership.
    The membership size limit decision is based on the product suites
    of the cluster and the new node. If the registry override exists,
    we will use that limit instead.

Arguments:

    NewNodeProductSuite - The product suite identifier for the proposed
                          new member node.

    RegistryNodeLimit - The membership size override value stored in the
                        cluster database.

    EffectiveNodeLimit - On output, contains the membership size limit
                         that was calculated for this cluster.

Return Value:

    TRUE if the new node may be added to the cluster. FALSE otherwise.

Notes:

    Called with NmpLock held.

--*/
{
    DWORD   nodeLimit;
    DWORD   newNodeProductLimit;
    DWORD   currentNodeCount;


    //
    // Check if we already have the maximum number of nodes allowed in
    // this cluster, based on the the product suites of the cluster and
    // the joiner. If the registry override exists, we will use that
    // limit instead.
    //
    newNodeProductLimit = ClRtlGetDefaultNodeLimit(NewNodeProductSuite);
    currentNodeCount = NmGetCurrentNumberOfNodes();
    nodeLimit = RegistryNodeLimit;

    if (nodeLimit == 0) {
        //
        // No override in the registry.
        // Limit is minimum of cluster's limit and new node's limit
        //
        nodeLimit = min(CsClusterNodeLimit, newNodeProductLimit);
    }

    //
    // The runtime limit cannot exceed the compile time limit.
    //
    if (nodeLimit > NmMaxNodeId) {
        nodeLimit = NmMaxNodeId;
    }

    if (currentNodeCount >= nodeLimit) {
        return(FALSE);
    }

    if (EffectiveNodeLimit != NULL) {
        *EffectiveNodeLimit = nodeLimit;
    }

    return(TRUE);

} // NmpIsAddNodeAllowed


DWORD
NmpAddNode(
    IN LPCWSTR  NewNodeName,
    IN DWORD    NewNodeHighestVersion,
    IN DWORD    NewNodeLowestVersion,
    IN DWORD    NewNodeProductSuite,
    IN DWORD    RegistryNodeLimit
)
/*++

Routine Description:

    Adds a new node to the cluster by selecting an ID and
    issuing a global update.

Arguments:

    NewNodeName - A pointer to a string containing the name of the
                  new node.

    NewNodeHighestVersion - The highest cluster version number that the
                            new node can support.

    NewNodeLowestVersion - The lowest cluster version number that the
                            new node can support.

    NewNodeProductSuite - The product suite identifier for the new node.

Return Value:

    A Win32 status code.

Notes:

    Called with NmpLock held.

--*/
{
    DWORD     status;
    DWORD     nodeId;
    DWORD     nodeLimit;


    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Processing request to add node '%1!ws!' to "
        "the cluster.\n",
        NewNodeName
        );

    if (NmpAddNodeId != ClusterInvalidNodeId) {
        //
        // An add is already in progress. Return an error.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "another add node operation is in progress. Retry later.\n",
            NewNodeName
            );

        return(ERROR_CLUSTER_JOIN_IN_PROGRESS);
    }

    if (!NmpIsAddNodeAllowed(
            NewNodeProductSuite,
            RegistryNodeLimit,
            &nodeLimit
            )
       )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster. "
            "The cluster already contains the maximum number of nodes "
            "allowed by the product licenses of the current member nodes "
            "and the proposed new node.\n",
            NewNodeName
            );
        return(ERROR_LICENSE_QUOTA_EXCEEDED);
    }

    //
    // Find a free node ID.
    //
    for (nodeId=ClusterMinNodeId; nodeId<=nodeLimit; nodeId++) {
        if (NmpIdArray[nodeId] == NULL) {
            //
            // Found an available node ID.
            //
            NmpAddNodeId = nodeId;
            ClRtlLogPrint(LOG_NOISE,
                "[NMJOIN] Allocated node ID '%1!u!' for new node '%2!ws!'\n",
                NmpAddNodeId,
                NewNodeName
                );
            break;
        }
    }

    //
    // Since the license test passed, it should be impossible for us to
    // find no free slots in the node table.
    //
    CL_ASSERT(NmpAddNodeId != ClusterInvalidNodeId);

    if (NmpAddNodeId == ClusterInvalidNodeId) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Cannot add node '%1!ws!' to the cluster because "
            "no slots are available in the node table.\n",
            NewNodeName
            );
        return(ERROR_LICENSE_QUOTA_EXCEEDED);
    }

    NmpReleaseLock();

    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateAddNode,
                 5,
                 sizeof(NmpAddNodeId),
                 &NmpAddNodeId,
                 NM_WCSLEN(NewNodeName),
                 NewNodeName,
                 sizeof(NewNodeHighestVersion),
                 &NewNodeHighestVersion,
                 sizeof(NewNodeLowestVersion),
                 &NewNodeLowestVersion,
                 sizeof(NewNodeProductSuite),
                 &NewNodeProductSuite
                 );

    NmpAcquireLock();

    //
    // Reset the global serialization variable.
    //
    CL_ASSERT(NmpAddNodeId == nodeId);

    NmpAddNodeId = ClusterInvalidNodeId;

    return(status);

} // NmpAddNode


VOID
NmpTerminateRpcsToNode(
    DWORD NodeId
    )
/*++

Routine Description:

    Cancels all outstanding RPCs to the specified node.

Arguments:

    NodeId - The ID of the node for which calls should be cancelled.

Return Value:

    None

--*/
{
    LIST_ENTRY *pEntry, *pStart;
    PNM_INTRACLUSTER_RPC_THREAD pRpcTh;
    RPC_STATUS status;

#if DBG
    BOOLEAN  startTimer = FALSE;
#endif // DBG


    CL_ASSERT((NodeId >= ClusterMinNodeId) && (NodeId <= NmMaxNodeId));
    CL_ASSERT(NmpIntraClusterRpcArr != NULL);

    NmpAcquireRPCLock();
    pEntry = pStart = &NmpIntraClusterRpcArr[NodeId];
    pEntry = pEntry->Flink;
    while(pEntry != pStart) {
        pRpcTh = CONTAINING_RECORD(pEntry, NM_INTRACLUSTER_RPC_THREAD, Linkage);
        status = RpcCancelThreadEx(pRpcTh->Thread, 0);
        pRpcTh->Cancelled = TRUE;
        if(status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to cancel RPC to node %1!u! by thread "
                "x%2!x!, status %3!u!.\n",
                NodeId,
                pRpcTh->ThreadId,
                status
                );
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Cancelled RPC to node %1!u! by thread x%2!x!.\n",
                NodeId,
                pRpcTh->ThreadId
                );
#if DBG
            startTimer = TRUE;
#endif // DBG
        }

        pEntry = pEntry->Flink;
    }

#if DBG
    //
    // Now start a timer to make sure that all cancelled RPCs return to
    // their callers within a reasonable amount of time.
    //
    if (startTimer) {
        NmpRpcTimer = NM_RPC_TIMEOUT;
    }

#endif // DBG

    NmpReleaseRPCLock();

    return;

}  // NmTerminateRpcsToNode


#if DBG

VOID
NmpRpcTimerTick(
    DWORD MsTickInterval
    )
/*++

Routine Description:

    Decrements a timer used to ensure that all cancelled RPCs to a dead
    node return to their callers within a reasonable amount of time.

Arguments:

    MsTickInterval - The time, in milliseconds, that has elapsed since this
                     routine was last invoked.
Return Value:

    None

--*/
{
    DWORD ndx;
    LIST_ENTRY *pEntry, *pStart;
    PNM_INTRACLUSTER_RPC_THREAD pRpcTh;

    if(NmpRpcTimer == 0)
        return;

    NmpAcquireRPCLock();

    if (NmpRpcTimer > MsTickInterval) {
        NmpRpcTimer -= MsTickInterval;
    }
    else {
        BOOLEAN stopClusSvc=FALSE;

        NmpRpcTimer = 0;

        for(ndx=0;ndx<=NmMaxNodeId;ndx++) {
            pStart = pEntry = &NmpIntraClusterRpcArr[ndx];
            pEntry = pEntry->Flink;
            while(pEntry != pStart) {
                pRpcTh = CONTAINING_RECORD(
                             pEntry,
                             NM_INTRACLUSTER_RPC_THREAD,
                             Linkage
                             );
                if(pRpcTh->Cancelled == TRUE) {
                    ClRtlLogPrint( LOG_CRITICAL,
                        "[NM] Cancelled RPC to node %1!u! by thread x%2!x! "
                        "is still lingering after %3!u! seconds.\n",
                        ndx,
                        pRpcTh->ThreadId,
                        (NM_RPC_TIMEOUT/1000)
                        );
                    stopClusSvc = TRUE;
                }
                pEntry = pEntry->Flink;
            }
        }

        if(stopClusSvc) {
            DebugBreak();
        }
    }

    NmpReleaseRPCLock();

    return;

}  // NmpRpcTimerTick

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\om\ominit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ominit.c

Abstract:

    Initialization module for Object Manager

Author:

    John Vert (jvert) 16-Feb-1996

Revision History:

--*/
#include "omp.h"

//
// Local data
//
BOOL OmInited = FALSE;

#if	OM_TRACE_REF
	extern LIST_ENTRY	gDeadListHead;
#endif	


DWORD
OmInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the object manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status = ERROR_SUCCESS;

    if ( OmInited ) {
        return(ERROR_DUPLICATE_SERVICE_NAME);
    }

    //
    // Initialize locks
    //
    InitializeCriticalSection(&OmpObjectTypeLock);
#if	OM_TRACE_REF
    InitializeListHead(&gDeadListHead);
#endif

    //
    // open the log and write a start record
    //
    OmpOpenObjectLog();
    OmpLogStartRecord();

    OmInited = TRUE;

    return(Status);
}


VOID
OmShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the object manager

Arguments:

    None

Return Value:

    None.

--*/

{
    OmInited = FALSE;

#if	OM_TRACE_REF	
{
    POM_HEADER 		pHeader;
	PLIST_ENTRY 	pListEntry;
	
	ClRtlLogPrint(LOG_NOISE, "[OM] Scanning for objects on deadlist\r\n");
    //SS: dump the objects and their ref counts
    pListEntry = gDeadListHead.Flink;
	while (pListEntry != &gDeadListHead)
	{
        pHeader = CONTAINING_RECORD(pListEntry, OM_HEADER, DeadListEntry);
        
        ClRtlLogPrint(LOG_NOISE, "[OM] ObjBody= %1!lx! RefCnt=%2!d! ObjName=%3!ws! ObjId=%4!ws!\n",
        	&pHeader->Body, pHeader->RefCount,pHeader->Name, pHeader->Id);
		/*        	
		if (pHeader->Name)
		{
        	ClRtlLogPrint(LOG_NOISE, "[OM] ObjectName=%1!ws!\r\n", pHeader->Name);
		}        	
		*/        	
        pListEntry = pListEntry->Flink;
	}
}	
#endif    
    //
    // Maybe we should check that the object type table is empty and
    // deallocate ObjectType blocks if it isn't empty!
    // However, since we are shutting down and presumably exiting, this
    // really doesn't matter that much.
    //

    ZeroMemory( &OmpObjectTypeTable, sizeof(OmpObjectTypeTable) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\om\obmgmt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    objmgr.c

Abstract:

    Object Manager object management routines for the NT Cluster Service

Author:

    Rod Gamache (rodga) 13-Mar-1996

Revision History:

--*/
#include "omp.h"

//
// Global data defined by this module
//

//
// The Object Type table and lock.
//
POM_OBJECT_TYPE OmpObjectTypeTable[ObjectTypeMax] = {0};
CRITICAL_SECTION OmpObjectTypeLock;

#if OM_TRACE_REF
LIST_ENTRY	gDeadListHead;
#endif
//
// Functions local to this module
//

#if OM_TRACE_OBJREF
DWORDLONG *OmpMatchRef = NULL;

VOID
OmpReferenceHeader(
    POM_HEADER pOmHeader
    )
{
    InterlockedIncrement(&(pOmHeader)->RefCount);
    if (&(pOmHeader)->Body == OmpMatchRef) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[OM] Referencing %1!lx! - new ref %2!d!\n",
                   OmpMatchRef,
                   (pOmHeader)->RefCount);
    }
}

DWORD
OmpDereferenceHeader(
    IN POM_HEADER Header
    )
{
    if (&Header->Body == OmpMatchRef) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[OM] Dereferencing %1!lx! - old ref %2!d!\n",
                   OmpMatchRef,
                   Header->RefCount);
    }
    return(InterlockedDecrement(&Header->RefCount) == 0);
}
#endif



DWORD
WINAPI
OmCreateType(
    IN OBJECT_TYPE ObjectType,
    IN POM_OBJECT_TYPE_INITIALIZE ObjectTypeInitialize
    )

/*++

Routine Description:

    This routine creates an object of the type specified. This merely
    allocates an object type structure, and inserts a pointer to this
    structure into the OmpObjectTypeTable.

Arguments:
    ObjectType - The Object Type being created.
    ObjectTypeIntialize - The initialization info.

Returns:
    ERROR_SUCCESS if the request is successful.
    A Win32 error code on failure.

--*/

{
    POM_OBJECT_TYPE objType;
    DWORD objTypeSize;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( ARGUMENT_PRESENT(ObjectTypeInitialize) );
    CL_ASSERT( ObjectTypeInitialize->ObjectSize );

    //
    // Take out a lock, just in case there can be multiple threads.
    //

    EnterCriticalSection( &OmpObjectTypeLock );

    //
    // Check if this ObjectType is already allocated.
    //

    if ( OmpObjectTypeTable[ObjectType] != NULL ) {
        LeaveCriticalSection( &OmpObjectTypeLock );
        return(ERROR_OBJECT_ALREADY_EXISTS);
    }

    //
    // Allocate an object type block, plus its name.
    //

    objTypeSize = (sizeof(OM_OBJECT_TYPE) + sizeof(DWORDLONG)) &
                   ~sizeof(DWORDLONG);

    objType = LocalAlloc(LMEM_ZEROINIT, objTypeSize +
                          ((lstrlenW(ObjectTypeInitialize->Name) + 1) *
                            sizeof(WCHAR)));

    if ( objType == NULL ) {
        LeaveCriticalSection( &OmpObjectTypeLock );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Init the object type block.
    //

    InitializeListHead(&objType->ListHead);
    InitializeListHead(&objType->CallbackListHead);
    InitializeCriticalSection(&objType->CriticalSection);

    objType->Type = ObjectType;

    objType->ObjectSize = ObjectTypeInitialize->ObjectSize;
    objType->Signature = ObjectTypeInitialize->Signature;
    objType->DeleteObjectMethod = ObjectTypeInitialize->DeleteObjectMethod;

    objType->Name = (LPWSTR)((PCHAR)objType + objTypeSize);
    lstrcpyW(objType->Name, ObjectTypeInitialize->Name);

    OmpObjectTypeTable[ObjectType] = objType;

    LeaveCriticalSection( &OmpObjectTypeLock );

    OmpLogPrint( L"OTCREATE \"%1!ws!\"\n", objType->Name );

    return(ERROR_SUCCESS);

} // OmCreateType



PVOID
WINAPI
OmCreateObject(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR ObjectId,
    IN LPCWSTR ObjectName OPTIONAL,
    OUT PBOOL  Created OPTIONAL
    )

/*++

Routine Description:

    This routine creates an object of the type specified or opens an
    object if one of the same Id already exists. If the object is created
    its reference count is 1. If it is not create, then the reference count
    of the object is incremented.

Arguments:
    ObjectType - The type of object being created.
    ObjectId - The Id string for the object to find/create.
    ObjectName - The name to set for the object if found or created.
    Created - If present, returns TRUE if the object was created, returns
              FALSE otherwise.

Returns:
    A pointer to the created/opened object on success.
    A NULL on failure - use GetLastError to get the error code.

--*/

{
    DWORD status;
    PVOID object;
    PVOID tmpObject = NULL;
    LPWSTR objectName = NULL;
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;
    DWORD objSize;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( OmpObjectTypeTable[ObjectType] );

    //
    // Get our Object Type block.
    //
    objType = OmpObjectTypeTable[ObjectType];

    //
    // Calculate size of this object (round it to a DWORDLONG).
    // Note: we don't subtract the DWORDLONG Body for rounding purposes.
    //
    objSize = (sizeof(OM_HEADER) + objType->ObjectSize) & ~sizeof(DWORDLONG);

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Try to open the object first
    //
    object = OmReferenceObjectById( ObjectType, ObjectId );

    if ( object != NULL ) {
        status = ERROR_SUCCESS;
        if ( ARGUMENT_PRESENT(ObjectName) ) {
            //
            // Set the new ObjectName.
            //
            status = OmSetObjectName( object, ObjectName );

            //
            // If we failed, then return NULL.
            //
            if ( status != ERROR_SUCCESS ) {
				OmDereferenceObject( object );
				object = NULL;
            }
        }
        LeaveCriticalSection( &objType->CriticalSection );

        if ( ARGUMENT_PRESENT(Created) ) {
            *Created = FALSE;
        }

        SetLastError( status );
        return(object);
    }

    //
    // Attempt to allocate the object, plus its Id string.
    //
    objHeader = LocalAlloc(LMEM_ZEROINIT, objSize +
                           ((lstrlenW(ObjectId) + 1) * sizeof(WCHAR)));

    if ( objHeader == NULL ) {
        LeaveCriticalSection( &objType->CriticalSection );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    if ( ARGUMENT_PRESENT(ObjectName) ) {
        //
        // Make sure ObjectName is unique.
        //
        tmpObject = OmReferenceObjectByName( ObjectType, ObjectName );
        if ( tmpObject != NULL ) {
            LeaveCriticalSection( &objType->CriticalSection );
            LocalFree( objHeader );
            SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
            return(NULL);
        }

        objectName = LocalAlloc(LMEM_ZEROINIT,
                                (lstrlenW(ObjectName) + 1) * sizeof(WCHAR));

        if ( objectName == NULL ) {
            LeaveCriticalSection( &objType->CriticalSection );
            LocalFree( objHeader );
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }
        lstrcpyW( objectName, ObjectName );
    }

    //
    // Initialize the object.
    //
    InitializeListHead(&objHeader->ListEntry);
    objHeader->Signature = objType->Signature;
    objHeader->RefCount = 1;
    objHeader->ObjectType = objType;
    objHeader->Name = objectName;
    InitializeListHead(&objHeader->CbListHead);

    //
    // The Id string goes after the object header and body.
    //
    objHeader->Id = (LPWSTR)((PCHAR)objHeader + objSize);
    lstrcpyW(objHeader->Id, ObjectId);

    //
    // Tell the caller that we had to create this object.
    //
    if ( ARGUMENT_PRESENT(Created) ) {
        *Created = TRUE;
    }

#if  OM_TRACE_REF
	//SS: all objects are added to the dead list on creation
	// they are removed when the refcount goes to zero
    InitializeListHead(&objHeader->DeadListEntry);
    InsertTailList( &gDeadListHead, &objHeader->DeadListEntry );
#endif

    LeaveCriticalSection( &objType->CriticalSection );

    OmpLogPrint(L"OBCREATE \"%1!ws!\" \"%2!ws!\" \"%3!ws!\"\n",
                objType->Name,
                ObjectId,
                ObjectName == NULL ? L"" : ObjectName);

    return(&objHeader->Body);

} // OmCreateObject



DWORD
WINAPI
OmInsertObject(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine inserts an object into the object's list.

Arguments:

    Object - A pointer to the object to be inserted into its object type list.

Returns:

    ERROR_SUCCESS - if the request was successful.
    ERROR_OBJECT_ALREADY_EXISTS if this object is already in the list.

--*/

{
    POM_HEADER objHeader;
    POM_HEADER otherHeader;
    POM_OBJECT_TYPE objType;

    //
    // Get our Object Header.
    //

    objHeader = OmpObjectToHeader( Object );

    //
    // Get our Object Type block.
    //

    objType = objHeader->ObjectType;

    //
    // Now perform the insertion, but first check to see if someone else
    // snuck in ahead of us and inserted another object of the same name.
    //

    EnterCriticalSection( &objType->CriticalSection );

    CL_ASSERT( !(objHeader->Flags & OM_FLAG_OBJECT_INSERTED) );

    otherHeader = OmpFindIdInList( &objType->ListHead, objHeader->Id );

    if ( otherHeader != NULL ) {
        // We loose!
        LeaveCriticalSection( &objType->CriticalSection );
        return(ERROR_OBJECT_ALREADY_EXISTS);
    }

    //
    // We generate the enumeration key for this object, and we must insert
    // the object at the tail of the list, so the list is ordered by EnumKey.
    // By definition, this entry must go at the end of the list.
    //

    objHeader->EnumKey = ++objType->EnumKey;
    CL_ASSERT( objHeader->EnumKey > 0 );

    InsertTailList( &objType->ListHead, &objHeader->ListEntry );

    objHeader->Flags |= OM_FLAG_OBJECT_INSERTED;

    LeaveCriticalSection( &objType->CriticalSection );

    return(ERROR_SUCCESS);

} // OmInsertObject



DWORD
WINAPI
OmRemoveObject(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine removes an object from its object's list.

Arguments:

    Object - A pointer to the object to be removed from its object type list.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_RESOURCE_NOT_FOUND if the object is not in any list.

--*/

{
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;

    //
    // Get our Object Header.
    //

    objHeader = OmpObjectToHeader( Object );

    //
    // Get our Object Type block.
    //

    objType = objHeader->ObjectType;

    //
    // Now perform the removal.
    //

    EnterCriticalSection( &objType->CriticalSection );

    if ( !(objHeader->Flags & OM_FLAG_OBJECT_INSERTED) ) {
        LeaveCriticalSection( &objType->CriticalSection );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    RemoveEntryList( &objHeader->ListEntry );

    objHeader->Flags &= ~OM_FLAG_OBJECT_INSERTED;

    //
    // log while the lock is held so we don't lose our pointers
    //
    OmpLogPrint(L"OBDELETE \"%1!ws!\" \"%2!ws!\" \"%3!ws!\"\n",
                objType->Name,
                objHeader->Id,
                objHeader->Name == NULL ? L"" : objHeader->Name);

    LeaveCriticalSection( &objType->CriticalSection );

    return(ERROR_SUCCESS);

} // OmRemoveObject



PVOID
WINAPI
OmpReferenceObjectById(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    This routine opens an object of the name and type specified. It also
    increments the reference count on the object.

Arguments:
    ObjectType - The Object Type to open.
    Id - The Id string of the object to open.

Returns:
    A pointer to the object on success.
    NULL on error.

--*/

{
    DWORD status;
    POM_OBJECT_TYPE objType;
    POM_HEADER objHeader;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( OmpObjectTypeTable[ObjectType] );

    //
    // Get our Object Type block.
    //

    objType = OmpObjectTypeTable[ObjectType];

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Get the Object's header
    //
    objHeader = OmpFindIdInList( &objType->ListHead, Id );

    if ( objHeader == NULL ) {
        LeaveCriticalSection( &objType->CriticalSection );
        return(NULL);
    }

#if OM_TRACE_REF    
	OmReferenceObject(&objHeader->Body);
#else
    OmpReferenceHeader( objHeader );
#endif
    LeaveCriticalSection( &objType->CriticalSection );

    return(&objHeader->Body);

} // OmpReferenceObjectById



PVOID
WINAPI
OmpReferenceObjectByName(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    This routine opens an object of the name and type specified. It also
    increments the reference count on the object.

Arguments:
    ObjectType - The Object Type to open.
    Name - The name of the object to open.

Returns:
    A pointer to the object on success.
    NULL on error.

--*/

{
    DWORD status;
    POM_OBJECT_TYPE objType;
    POM_HEADER objHeader;

    CL_ASSERT( ObjectType < ObjectTypeMax );
    CL_ASSERT( OmpObjectTypeTable[ObjectType] );

    //
    // Get our Object Type block.
    //

    objType = OmpObjectTypeTable[ObjectType];

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Get the Object's header
    //

    objHeader = OmpFindNameInList( &objType->ListHead, Name );

    if ( objHeader == NULL ) {
        LeaveCriticalSection( &objType->CriticalSection );
        return(NULL);
    }

#if OM_TRACE_REF    
	OmReferenceObject(&objHeader->Body);
#else
    OmpReferenceHeader( objHeader );
#endif

    LeaveCriticalSection( &objType->CriticalSection );

    return(&objHeader->Body);

} // OmReferenceObjectByName


DWORD
WINAPI
OmCountObjects(
    IN OBJECT_TYPE ObjectType,
    OUT LPDWORD NumberOfObjects
    )

/*++

Routine Description:

    Returns the count of the number of objects of a particular type
    which exist in the database at this time.

Arguments:

    ObjectType - The object type to count.

    NumberOfObjects - On output, contains the number of objects of the
                      specified type in the database.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    POM_OBJECT_TYPE objType;
    PLIST_ENTRY listEntry;
    DWORD objectCount = 0;


    CL_ASSERT( ObjectType < ObjectTypeMax );

    objType = OmpObjectTypeTable[ObjectType];

    if ( !objType ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    EnterCriticalSection(&objType->CriticalSection);


    for ( listEntry = objType->ListHead.Flink;
          listEntry != &(objType->ListHead);
          listEntry = listEntry->Flink
        )
    {
        objectCount++;
    }

    LeaveCriticalSection(&objType->CriticalSection);

    *NumberOfObjects = objectCount;

    return(ERROR_SUCCESS);

} // OmCountObjects



DWORD
WINAPI
OmEnumObjects(
    IN OBJECT_TYPE ObjectType,
    IN OM_ENUM_OBJECT_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    Enumerates all objects of the specified type.

Arguments:

    ObjectType - The object type to enumerate.

    EnumerationRoutine - Supplies the enumeration routine to be
        called for each object.

    Context1 - Supplies a context pointer to be passed to the
        enumeration routine.

    Context2 - Supplies a second context pointer to be passed to the
        enumeration routine.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    POM_OBJECT_TYPE objType;
    POM_HEADER objHeader;
    PLIST_ENTRY listEntry;
    DWORD   enumKey = 0;

    CL_ASSERT( ObjectType < ObjectTypeMax );

    objType = OmpObjectTypeTable[ObjectType];

    if ( !objType ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Enumeration is a little tricky. First, we have to allow for multiple
    // entries in the enumeration list to be removed as a side effect of the
    // callout. Second, we have to allow the list lock to be released so the
    // first issue can be handled. We'll use a sort order key to remember where
    // we are in the enumeration and pick up from the next highest value.
    //

    while ( TRUE ) {

        EnterCriticalSection(&objType->CriticalSection);

        //
        // Skip to next entry to process in list.
        // We can treat this like an entry only after verifying it is not the
        // ListHeader.
        //

        listEntry = objType->ListHead.Flink;
        objHeader = CONTAINING_RECORD( listEntry, OM_HEADER, ListEntry );

        while ( listEntry != &objType->ListHead &&
                objHeader->EnumKey <= enumKey ) {
            listEntry = listEntry->Flink;
            objHeader = CONTAINING_RECORD( listEntry, OM_HEADER, ListEntry );
        }

        //
        // Save the enumeration key for next iteration.
        //

        enumKey = objHeader->EnumKey;

        //if it is a valid object, increment the reference count
        // so that it is not deleted while the call out is being
        // made
        if ( listEntry != &objType->ListHead ) {
            OmReferenceObject(&objHeader->Body);
        }
        //
        // Drop the lock to return or call out.
        //

        LeaveCriticalSection(&objType->CriticalSection);

        if ( listEntry == &objType->ListHead ) {
            return(ERROR_SUCCESS);
        }

        if (!(EnumerationRoutine)(Context1,
                                  Context2,
                                  &objHeader->Body,
                                  objHeader->Id)) {
            OmDereferenceObject(&objHeader->Body);
            break;
        }
        OmDereferenceObject(&objHeader->Body);
    }

    return(ERROR_SUCCESS);

} // OmEnumObject



VOID
OmpDereferenceObject(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine dereferences an object. If the reference count goes to
    zero, then the object is deallocated.

Arguments:
    Object - A pointer to the object to be dereferenced.

Returns:
    None

--*/

{
    DWORD status;
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;

    objHeader = OmpObjectToHeader( Object );

    objType = objHeader->ObjectType;

    CL_ASSERT( objHeader->RefCount != 0xfeeefeee );
    CL_ASSERT( objHeader->RefCount > 0 );

    if ( OmpDereferenceHeader(objHeader) ) {

        //
        // The reference count has gone to zero. Acquire the
        // lock, remove the object from the list, and perform
        // cleanup.
        //

        EnterCriticalSection( &objType->CriticalSection );

        //
        // Check the ref count again, to close the race condition between
        // open/create and this routine.
        //

        if ( objHeader->RefCount == 0 ) {
            //
            // If the object hasn't been previously removed from it's
            // object type list, then remove it now.
            //

            if ( objHeader->Flags & OM_FLAG_OBJECT_INSERTED ) {
                RemoveEntryList( &objHeader->ListEntry );
                objHeader->Flags &= ~OM_FLAG_OBJECT_INSERTED;
            }

            //
            // Call the object type's delete method (if present).
            //

            if ( ARGUMENT_PRESENT( objType->DeleteObjectMethod ) ) {
                (objType->DeleteObjectMethod)( &objHeader->Body );
            }

            objHeader->Signature = 'rFmO';
#if OM_TRACE_REF
			RemoveEntryList(&objHeader->DeadListEntry);
#endif			
            if ( objHeader->Name != NULL ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[OM] Deleting object %1!ws! (%2!ws!)\n",
                           objHeader->Name,
                           objHeader->Id);
                LocalFree( objHeader->Name );
            } else {
                ClRtlLogPrint(LOG_NOISE,
                           "[OM] Deleting object %1!ws!\n",
                           objHeader->Id);
            }
            LocalFree( objHeader );
        }
        LeaveCriticalSection( &objType->CriticalSection );
    }

} // OmpDereferenceObject



DWORD
WINAPI
OmSetObjectName(
    IN PVOID    Object,
    IN LPCWSTR  ObjectName
    )

/*++

Routine Description:

    Set the object name for an object. If the ObjectName already exists on a
    different object, then this call will fail.

Arguments:

    Object - A pointer to the object to set its name.
    ObjectName - The name to set for the object.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS;
    PVOID object = NULL;
    LPWSTR objectName;
    POM_HEADER objHeader;
    POM_OBJECT_TYPE objType;

    //
    // Make sure object name is valid (not empty)
    //
    if (ObjectName[0] == '\0') 
    {
        status = ERROR_INVALID_NAME;
        goto FnExit;
    }

    objHeader = OmpObjectToHeader( Object );

    objType = objHeader->ObjectType;

    EnterCriticalSection( &objType->CriticalSection );

    //
    // Make sure ObjectName is unique.
    //
    object = OmReferenceObjectByName( objType->Type, ObjectName );
    if ( object != NULL ) 
    {
        //
        // If our's is the other object, then nothing to do. Otherwise,
        // there is a duplicate.
        //
        if ( object != Object ) 
        {
            status = ERROR_OBJECT_ALREADY_EXISTS;
            goto FnUnlock;
        }
    } 
    else 
    {
        //
        // No other object with the new name, then set the new name.
        //
        objectName = LocalAlloc(LMEM_ZEROINIT,
                                (lstrlenW(ObjectName) + 1) * sizeof(WCHAR));
        if ( objectName == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            if ( objHeader->Name != NULL ) {
                LocalFree( objHeader->Name );
            }
            objHeader->Name = objectName;
            lstrcpyW( objectName, ObjectName );

            OmpLogPrint(L"OBRENAME \"%1!ws!\" \"%2!ws!\" \"%3!ws!\"\n",
                        objType->Name,
                        objHeader->Id,
                        ObjectName);
        }
    }

FnUnlock:
    LeaveCriticalSection( &objType->CriticalSection );
FnExit:
	if (object)
	{
		OmDereferenceObject(object);
	}    	
    return(status);

} // OmSetObjectName



DWORD
WINAPI
OmRegisterTypeNotify(
    IN OBJECT_TYPE          ObjectType,
    IN PVOID                pContext,
    IN DWORD                dwNotifyMask,
    IN OM_OBJECT_NOTIFYCB   pfnObjNotifyCb
    )

/*++

Routine Description:

    Registers a callback to be called by the FM on object state changes.

Arguments:

    ObjectType - The object type that notifications should be delivered for.

    pContext - A pointer to context information that is passed back into the callback.

    dwNotifyMask - The type of notifications that should be delivered

    pfnObjNotifyCb - a pointer to the callback.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD               dwError = ERROR_SUCCESS;
    POM_HEADER          pObjHeader;
    POM_OBJECT_TYPE     pObjType;
    POM_NOTIFY_RECORD   pNotifyRec;

    if ( !pfnObjNotifyCb ) {
        return(ERROR_INVALID_PARAMETER);
    }

    pObjType = OmpObjectTypeTable[ObjectType];

    //
    // The object type lock is used to serialize callbacks. This
    // is so that callees do not deadlock if they are waiting on
    // another thread that needs to enumerate objects.
    //
    EnterCriticalSection( &OmpObjectTypeLock );

    //
    // First, check if the same notification is being registered twice!
    // If so, then just change the notification mask and context.
    //
    pNotifyRec = OmpFindNotifyCbInList( &pObjType->CallbackListHead,
                                        pfnObjNotifyCb);
    if ( !pNotifyRec ) {
        pNotifyRec = (POM_NOTIFY_RECORD) LocalAlloc(LMEM_FIXED,sizeof(OM_NOTIFY_RECORD));

        if ( !pNotifyRec ) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            CsInconsistencyHalt(dwError);
            goto FnExit;
        }

        pNotifyRec->pfnObjNotifyCb = pfnObjNotifyCb;

        //insert the notification record at the tail
        InsertTailList(&pObjType->CallbackListHead, &pNotifyRec->ListEntry);
    }

    pNotifyRec->dwNotifyMask = dwNotifyMask;
    pNotifyRec->pContext = pContext;

FnExit:
    LeaveCriticalSection( &OmpObjectTypeLock );

    return(dwError);

} // OmRegisterTypeNotify



DWORD
WINAPI
OmRegisterNotify(
    IN PVOID                pObject,
    IN PVOID                pContext,
    IN DWORD                dwNotifyMask,
    IN OM_OBJECT_NOTIFYCB   pfnObjNotifyCb
    )

/*++

Routine Description:

    Registers a callback to be called by the FM on object state changes.

Arguments:

    pObject - A pointer to the object to set its name.
    pContext - A pointer to context information that is passed back into the callback.
    dwNotifyMask - The name to set for the object.
    pfnObjNotifyCb - a pointer to the callback.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD               dwError = ERROR_SUCCESS;
    POM_HEADER          pObjHeader;
    POM_OBJECT_TYPE     pObjType;
    POM_NOTIFY_RECORD   pNotifyRec;

    if ( !pfnObjNotifyCb ) {
        return(ERROR_INVALID_PARAMETER);
    }

    pObjHeader = OmpObjectToHeader( pObject );

    pObjType = pObjHeader->ObjectType;

    EnterCriticalSection( &OmpObjectTypeLock );

    //
    // First, check if the same notification is being registered twice!
    // If so, then just change the notification mask and context.
    //
    pNotifyRec = OmpFindNotifyCbInList(&pObjHeader->CbListHead, pfnObjNotifyCb);
    if ( !pNotifyRec ) {
        pNotifyRec = (POM_NOTIFY_RECORD) LocalAlloc(LMEM_FIXED,sizeof(OM_NOTIFY_RECORD));

        if ( !pNotifyRec ) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            CsInconsistencyHalt(dwError);
            goto FnExit;
        }

        pNotifyRec->pfnObjNotifyCb = pfnObjNotifyCb;

        //insert the notification record at the tail
        InsertTailList(&pObjHeader->CbListHead, &pNotifyRec->ListEntry);
    }

    pNotifyRec->dwNotifyMask = dwNotifyMask;
    pNotifyRec->pContext = pContext;

FnExit:
    LeaveCriticalSection( &OmpObjectTypeLock );

    return(dwError);

} // OmRegisterNotify


DWORD
WINAPI
OmDeregisterNotify(
    IN PVOID                    pObject,
    IN OM_OBJECT_NOTIFYCB       pfnObjNotifyCb
    )

/*++

Routine Description:

    Removes the callback registed with the object.

Arguments:

    pObject - A pointer to the object to set its name.
    pfnObjNotifyCb - a pointer to the callback.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD               dwError = ERROR_SUCCESS;
    POM_HEADER          pObjHeader;
    POM_OBJECT_TYPE     pObjType;
    POM_NOTIFY_RECORD   pNotifyRec;

    if ( !pfnObjNotifyCb ) {
        return(ERROR_INVALID_PARAMETER);
    }


    pObjHeader = OmpObjectToHeader( pObject );


        //SS: we use the same crit section for list manipulations
    pObjType = pObjHeader->ObjectType;

    //
    // The object type lock is used to serialize callbacks. This
    // is so that callees do not deadlock if they are waiting on
    // another thread that needs to enumerate objects.
    //
    EnterCriticalSection( &OmpObjectTypeLock );

    pNotifyRec = OmpFindNotifyCbInList(&pObjHeader->CbListHead, pfnObjNotifyCb);
    if (!pNotifyRec) {
            ClRtlLogPrint(LOG_UNUSUAL,
                    "[OM] OmRegisterNotify: OmpFindNotifyCbInList failed for 0x%1!08lx!\r\n",
                    pfnObjNotifyCb);

            dwError = ERROR_INVALID_PARAMETER;
            CL_LOGFAILURE(dwError);
            goto FnExit;
    }
    RemoveEntryList(&pNotifyRec->ListEntry);

FnExit:
    LeaveCriticalSection( &OmpObjectTypeLock );

    return(dwError);

} // OmRegisterNotify



DWORD
WINAPI
OmNotifyCb(
    IN PVOID pObject,
    IN DWORD dwNotification
    )
/*++

Routine Description:

    The callback registered with the quorum resource object.

Arguments:

    pContext - The resource whose call back list will be traversed.
        dwNotification - The notification to be passed to the callback.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    POM_HEADER              pObjHeader;
    POM_OBJECT_TYPE         pObjType;
    PLIST_ENTRY             ListEntry;
    DWORD                   dwError=ERROR_SUCCESS;
    POM_NOTIFY_RECORD       pNotifyRecList = NULL;
    DWORD                   dwCount;
    DWORD                   i;
    
    CL_ASSERT(pObject);

    //get the callback list
    pObjHeader = OmpObjectToHeader(pObject);
    pObjType = pObjHeader->ObjectType;

    //will walk the list of callbacks, do allow more registrations
    EnterCriticalSection(&OmpObjectTypeLock);
    dwError = OmpGetCbList(pObject, &pNotifyRecList, &dwCount);
    LeaveCriticalSection(&OmpObjectTypeLock);

    for (i=0; i < dwCount; i++)
    {
        if (pNotifyRecList[i].dwNotifyMask & dwNotification) {
            (pNotifyRecList[i].pfnObjNotifyCb)(pNotifyRecList[i].pContext,
                                         pObject,
                                         dwNotification);
        }
    }

    LocalFree(pNotifyRecList);
    return(dwError);
}    

DWORD OmpGetCbList(
    IN PVOID                pObject,
    OUT POM_NOTIFY_RECORD   *ppNotifyRecList,
    OUT LPDWORD             pdwCount
)    
{
    DWORD                   status = ERROR_SUCCESS;
    POM_NOTIFY_RECORD       pNotifyRecList;
    POM_NOTIFY_RECORD       pNotifyRec;
    DWORD                   dwAllocated;
    PLIST_ENTRY             ListEntry;
    DWORD                   dwRetrySize=1;
    POM_HEADER              pObjHeader;
    POM_OBJECT_TYPE         pObjType;
    DWORD                   i = 0;

    *ppNotifyRecList = NULL;
    *pdwCount = 0;

Retry:    
    dwAllocated = ENUM_GROW_SIZE * dwRetrySize;
    i = 0;
    
    pObjHeader = OmpObjectToHeader(pObject);
    pObjType = pObjHeader->ObjectType;

    pNotifyRecList = LocalAlloc(LMEM_FIXED, sizeof(OM_NOTIFY_RECORD) * dwAllocated);
    if ( pNotifyRecList == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    ZeroMemory( pNotifyRecList, sizeof(OM_NOTIFY_RECORD) * dwAllocated );

    //
    // First notify any type-specific callbacks
    //
    ListEntry = pObjType->CallbackListHead.Flink;
    while (ListEntry != &pObjType->CallbackListHead) {
        pNotifyRec = CONTAINING_RECORD(ListEntry,
                                       OM_NOTIFY_RECORD,
                                       ListEntry);
        if (i < dwAllocated)
        {
            CopyMemory(&pNotifyRecList[i++], pNotifyRec, sizeof(OM_NOTIFY_RECORD));
        }
        else
        {
            LocalFree(pNotifyRecList);
            dwRetrySize++;
            goto Retry;
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Next notify any resource-specific callbacks
    //
    ListEntry = pObjHeader->CbListHead.Flink;
    while (ListEntry != &(pObjHeader->CbListHead)) {
        pNotifyRec = CONTAINING_RECORD(ListEntry, OM_NOTIFY_RECORD, ListEntry);

        if (i < dwAllocated)
        {
            CopyMemory(&pNotifyRecList[i++], pNotifyRec, sizeof(OM_NOTIFY_RECORD));
        }
        else
        {
            LocalFree(pNotifyRecList);
            dwRetrySize++;
            goto Retry;
        }
        ListEntry = ListEntry->Flink;

    }

FnExit:
    *ppNotifyRecList = pNotifyRecList;
    *pdwCount = i;
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\nmutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nmutil.c

Abstract:

    Miscellaneous utility routines for the Node Manager component.

Author:

    Mike Massa (mikemas) 26-Oct-1996


Revision History:

--*/

#define UNICODE 1

#include "service.h"
#include "nmp.h"
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <Wincrypt.h>

PVOID   NmpEncryptedClusterKey = NULL;
DWORD   NmpEncryptedClusterKeyLength = 0;



DWORD
NmpQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

Notes:

    To avoid deadlock with DM, must not be called with NM lock held.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = DmQueryValue( Key,
                           ValueName,
                           &valueType,
                           (LPBYTE) *StringBuffer,
                           StringSize
                         );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = MIDL_user_allocate(*StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            MIDL_user_free(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = DmQueryValue( Key,
                               ValueName,
                               &valueType,
                               (LPBYTE) *StringBuffer,
                               StringSize
                             );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // NmpQueryString


//
// Routines to support the common network configuration code.
//
VOID
ClNetPrint(
    IN ULONG  LogLevel,
    IN PCHAR  FormatString,
    ...
    )
{
    CHAR      buffer[256];
    DWORD     bytes;
    va_list   argList;

    va_start(argList, FormatString);

    bytes = FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING,
                FormatString,
                0,
                0,
                buffer,
                sizeof(buffer),
                &argList
                );

    va_end(argList);

    if (bytes != 0) {
        ClRtlLogPrint(LogLevel, "%1!hs!", buffer);
    }

    return;

} // ClNetPrint

VOID
ClNetLogEvent(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    )
{
    CsLogEvent(LogLevel, MessageId);

    return;

}  // ClNetLogEvent

VOID
ClNetLogEvent1(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    )
{
    CsLogEvent1(LogLevel, MessageId, Arg1);

    return;

}  // ClNetLogEvent1


VOID
ClNetLogEvent2(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    )
{
    CsLogEvent2(LogLevel, MessageId, Arg1, Arg2);

    return;

}  // ClNetLogEvent2


VOID
ClNetLogEvent3(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    )
{
    CsLogEvent3(LogLevel, MessageId, Arg1, Arg2, Arg3);

    return;

}  // ClNetLogEvent3


BOOLEAN
NmpLockedEnterApi(
    NM_STATE  RequiredState
    )
{
    if (NmpState >= RequiredState) {
        NmpActiveThreadCount++;
        CL_ASSERT(NmpActiveThreadCount != 0);
        return(TRUE);
    }

    return(FALSE);

} // NmpLockedEnterApi


BOOLEAN
NmpEnterApi(
    NM_STATE  RequiredState
    )
{
    BOOLEAN  mayEnter;


    NmpAcquireLock();

    mayEnter = NmpLockedEnterApi(RequiredState);

    NmpReleaseLock();

    return(mayEnter);

} // NmpEnterApi


VOID
NmpLockedLeaveApi(
    VOID
    )
{
    CL_ASSERT(NmpActiveThreadCount > 0);

    NmpActiveThreadCount--;

    if ((NmpActiveThreadCount == 0) && (NmpState == NmStateOfflinePending)) {
        SetEvent(NmpShutdownEvent);
    }

    return;

} // NmpLockedLeaveApi


VOID
NmpLeaveApi(
    VOID
    )
{
    NmpAcquireLock();

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return;

} // NmpLeaveApi


//
// Routines to provide a cluster shared key for signing and encrypting
// data.
//

DWORD
NmpGetLogonId(
    OUT LUID * LogonId
    )
{
    HANDLE              tokenHandle = NULL;
    TOKEN_STATISTICS    tokenInfo;
    DWORD               bytesReturned;
    BOOL                success = FALSE;
    DWORD               status;

    if (LogonId == NULL) {
        status = STATUS_UNSUCCESSFUL;
        goto error_exit;
    }

    if (!OpenProcessToken(
             GetCurrentProcess(),
             TOKEN_QUERY,
             &tokenHandle
             )) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to open process token, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    if (!GetTokenInformation(
             tokenHandle,
             TokenStatistics,
             &tokenInfo,
             sizeof(tokenInfo),
             &bytesReturned
             )) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get token information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    RtlCopyMemory(LogonId, &(tokenInfo.AuthenticationId), sizeof(LUID));

    status = STATUS_SUCCESS;

error_exit:

    if (tokenHandle != NULL) {
        CloseHandle(tokenHandle);
    }

    return(status);

} // NmpGetLogonId


DWORD
NmpConnectToLsaPrivileged(
    OUT HANDLE  * LsaHandle,
    OUT BOOLEAN * Trusted
    )
/*++

Routine Description:

    Connect to LSA.

    If running as a service, there is no need to enable the TCB privilege.
    The fix for bug 337751 allows the cluster service account to issue
    a MSV1_0_XXX requests even if it does not have a trusted connection
    to LSA.

    If not running as a service, try to elevate the privilege to TCB to
    connect trusted. Fail the call if TCB privilege cannot be enabled.
    If TCB is enabled and was previously not enabled, it is restored prior
    to returning.

    Callers that need to connect to LSA without requiring service logon
    or TCB can simply use LsaConnectUntrusted.

Arguments:

    LsaHandle - returns LSA handle. Must be cleaned up by caller

    Trusted - returns whether connection is trusted

Return value:

    Win32 error code.

--*/
{
    DWORD                       status;
    BOOLEAN                     wasEnabled = FALSE;
    BOOLEAN                     trusted = FALSE;
    DWORD                       ignore;
    STRING                      name;
    HANDLE                      lsaHandle = NULL;

    //
    // Try to turn on TCB privilege if running in console mode.
    //
    if (!CsRunningAsService) {
        status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &wasEnabled);
        if (!NT_SUCCESS(status)) {
            status = LsaNtStatusToWinError(status);
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to turn on TCB privilege, status %1!u!.\n",
                status
                );
#endif // CLUSTER_BETA
            return(status);
        } else {
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Turned on TCB privilege, wasEnabled = %1!ws!.\n",
                (wasEnabled) ? L"TRUE" : L"FALSE"
                );
#endif // CLUSTER_BETA
            trusted = TRUE;
        }
    }

    //
    // Establish contact with LSA.
    //
    if (trusted) {
        RtlInitString(&name, "ClusSvcNM");
        status = LsaRegisterLogonProcess(&name, &lsaHandle, &ignore);

        //
        // Turn off TCB privilege
        //
        if (!wasEnabled) {

            DWORD subStatus;

            subStatus = RtlAdjustPrivilege(
                            SE_TCB_PRIVILEGE,
                            FALSE,
                            FALSE,
                            &wasEnabled
                            );
            if (!NT_SUCCESS(subStatus)) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to disable TCB privilege, "
                    "status %1!u!.\n",
                    subStatus
                    );
            } else {
#if CLUSTER_BETA
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Turned off TCB privilege.\n"
                    );
#endif // CLUSTER_BETA
            }
        }
    }
    else {
        status = LsaConnectUntrusted(&lsaHandle);
    }

    if (!NT_SUCCESS(status)) {
        status = LsaNtStatusToWinError(status);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to obtain LSA logon handle in %1!ws! mode, "
            "status %2!u!.\n",
            (trusted) ? L"trusted" : L"untrusted", status
            );
    } else {
        *LsaHandle = lsaHandle;
        *Trusted = trusted;
    }

    return(status);

} // NmpConnectToLsaPrivileged


DWORD
NmpDeriveClusterKey(
    IN  PVOID   MixingBytes,
    IN  DWORD   MixingBytesSize,
    OUT PVOID * Key,
    OUT DWORD * KeyLength
    )
/*++

Routine Description:

    Derive the cluster key using mixing bytes. Allocate a buffer
    for the key and return it.

Arguments:

    Key - set to buffer containing key

    KeyLength - length of resulting key

--*/
{
    LUID                        logonId;
    BOOLEAN                     trusted = FALSE;
    HANDLE                      lsaHandle = NULL;

    STRING                      name;
    DWORD                       packageId = 0;

    DWORD                       requestSize;
    PMSV1_0_DERIVECRED_REQUEST  request = NULL;
    DWORD                       responseSize;
    PMSV1_0_DERIVECRED_RESPONSE response = NULL;

    PUCHAR                      key;
    DWORD                       keyLength;

    DWORD                       status = STATUS_SUCCESS;
    DWORD                       subStatus = STATUS_SUCCESS;

    status = NmpGetLogonId(&logonId);
    if (!NT_SUCCESS(status)) {
        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[NM] Failed to determine logon ID, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = NmpConnectToLsaPrivileged(&lsaHandle, &trusted);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to connect to LSA, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Lookup the authentication package.
    //
    RtlInitString( &name, MSV1_0_PACKAGE_NAME );

    status = LsaLookupAuthenticationPackage(lsaHandle, &name, &packageId);
    if (!NT_SUCCESS(status)) {
        status = LsaNtStatusToWinError(status);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to local authentication package with "
            "name %1!ws!, status %2!u!.\n",
            name.Buffer, status
            );
        goto error_exit;
    }

    //
    // Build the derive credentials request with the provided
    // mixing bytes.
    //
    requestSize = sizeof(MSV1_0_DERIVECRED_REQUEST) + MixingBytesSize;

    request = LocalAlloc(LMEM_FIXED, requestSize);
    if (request == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate LSA request of size %1!u! bytes.\n",
            requestSize
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    request->MessageType = MsV1_0DeriveCredential;
    RtlCopyMemory(&(request->LogonId), &logonId, sizeof(logonId));
    request->DeriveCredType = MSV1_0_DERIVECRED_TYPE_SHA1;
    request->DeriveCredInfoLength = MixingBytesSize;
    RtlCopyMemory(
        &(request->DeriveCredSubmitBuffer[0]),
        MixingBytes,
        MixingBytesSize
        );

    //
    // Make the call through LSA to the authentication package.
    //
    status = LsaCallAuthenticationPackage(
                 lsaHandle,
                 packageId,
                 request,
                 requestSize,
                 &response,
                 &responseSize,
                 &subStatus
                 );
    if (!NT_SUCCESS(status)) {
        status = LsaNtStatusToWinError(status);
        subStatus = LsaNtStatusToWinError(subStatus);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] DeriveCredential call to authentication "
            "package failed, status %1!u!, auth package "
            "status %2!u!.\n", status, subStatus
            );
        goto error_exit;
    }

    //
    // Allocate a non-LSA buffer to store the key.
    //
    keyLength = response->DeriveCredInfoLength;
    key = MIDL_user_allocate(keyLength);
    if (key == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate buffer for cluster "
            "key of size %1!u!.\n",
            keyLength
            );
        goto error_exit;
    }

    //
    // Store the derived credentials in the key buffer.
    //
    RtlCopyMemory(key, &(response->DeriveCredReturnBuffer[0]), keyLength);

    //
    // Zero the derived credential buffer to be extra paranoid.
    //
    RtlZeroMemory(
        &(response->DeriveCredReturnBuffer[0]),
        response->DeriveCredInfoLength
        );

    status = STATUS_SUCCESS;
    *Key = key;
    *KeyLength = keyLength;

error_exit:

    if (lsaHandle != NULL) {
        LsaDeregisterLogonProcess(lsaHandle);
        lsaHandle = NULL;
    }

    if (request != NULL) {
        LocalFree(request);
        request = NULL;
    }

    if (response != NULL) {
        LsaFreeReturnBuffer(response);
        response = NULL;
    }

    return(status);

} // NmpDeriveClusterKey


DWORD
NmpGetClusterKey(
    OUT    PVOID    KeyBuffer,
    IN OUT DWORD  * KeyBufferLength
    )
/*++

Routine Description:

    Decrypt and copy the shared cluster key into the buffer provided.

Arguments:

    KeyBuffer - buffer to which key should be copied

    KeyBufferLength - IN: length of KeyBuffer
                      OUT: required buffer size, if input
                           buffer length is insufficient

Return value:

    ERROR_INSUFFICIENT_BUFFER if KeyBuffer is too small.
    ERROR_FILE_NOT_FOUND if NmpEncryptedClusterKey has not
        yet been generated.
    ERROR_SUCCESS on success.

Notes:

    Acquires and releases NM lock. Since NM lock is
    implemented as a critical section, calling thread
    is permitted to already hold NM lock.

--*/
{
    DWORD                  status;
    BOOL                   DecryptingDataSucceeded = FALSE;
    BOOL                   Success;
    DATA_BLOB              DataIn;
    DATA_BLOB              DataOut;

    RtlZeroMemory(&DataOut, sizeof(DataOut));

    NmpAcquireLock();

    if (NmpEncryptedClusterKey == NULL) {
        status = ERROR_FILE_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] The cluster key has not yet been derived.\n"
            );
    } else{
        //
        // Decrypt cluster key
        //
        DataIn.pbData = NmpEncryptedClusterKey;
        DataIn.cbData = NmpEncryptedClusterKeyLength;

        Success = CryptUnprotectData(&DataIn,  // data to be decrypted
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0, // flags
                                     &DataOut  // decrypted data
                                     );


        if (!Success)
        {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to decrypt data using CryptUnprotectData, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        DecryptingDataSucceeded = TRUE;

        if (KeyBuffer == NULL || DataOut.cbData > *KeyBufferLength) {
            status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            RtlCopyMemory(KeyBuffer, DataOut.pbData, DataOut.cbData);
            status = ERROR_SUCCESS;
        }

        *KeyBufferLength = DataOut.cbData;
    }

error_exit:

    NmpReleaseLock();

    if (DecryptingDataSucceeded)
    {
        //
        // Zero the encrypted data before releasing the memory.
        //
        RtlSecureZeroMemory(DataOut.pbData, DataOut.cbData);
    }

    if (DataOut.pbData != NULL)
    {
        LocalFree(DataOut.pbData);
    }

    // To be extra secure.
    RtlSecureZeroMemory(&DataOut, sizeof(DataOut));

    return(status);

} // NmpGetClusterKey



DWORD
NmpRederiveClusterKey(
    VOID
    )
/*++

Routine Description:

    Forces rederivation of cluster key.

    Must be called during cluster initialization to generate
    cluster key the first time.

    Otherwise called when cluster password changes, since the
    cluster key is based on the cluster service account password.

Notes:

    Acquires and releases NM lock.

--*/
{
    DWORD                  status;
    BOOLEAN                lockAcquired;
    PVOID                  key = NULL;
    DWORD                  keyLength = 0;
    PVOID                  oldEncryptedKey = NULL;
    DWORD                  oldEncryptedKeyLength = 0;
    PVOID                  mixingBytes = NULL;
    DWORD                  mixingBytesSize;

    NmpAcquireLock();
    lockAcquired = TRUE;

    NmpLockedEnterApi(NmStateOnlinePending);

    //
    // Form the mixing bytes.
    //
    if (NmpClusterInstanceId == NULL) {
        status = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Need cluster instance id in order to derive "
            "cluster key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    mixingBytesSize = NM_WCSLEN(NmpClusterInstanceId);
    mixingBytes = MIDL_user_allocate(mixingBytesSize);
    if (mixingBytes == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate buffer of size %1!u! "
            "for mixing bytes to derive cluster key.\n",
            mixingBytesSize
            );
        goto error_exit;
    }
    RtlCopyMemory(mixingBytes, NmpClusterInstanceId, mixingBytesSize);


    //
    // Make a copy of the old encrypted key to detect changes.
    //
    if (NmpEncryptedClusterKey != NULL) {

        CL_ASSERT(NmpEncryptedClusterKeyLength > 0);

        oldEncryptedKey = MIDL_user_allocate(NmpEncryptedClusterKeyLength);
        if (oldEncryptedKey == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer for cluster "
                "key copy.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
        oldEncryptedKeyLength = NmpEncryptedClusterKeyLength;
        RtlCopyMemory(oldEncryptedKey,
                      NmpEncryptedClusterKey,
                      NmpEncryptedClusterKeyLength
                      );
    }


    NmpReleaseLock();
    lockAcquired = FALSE;

    status = NmpDeriveClusterKey(
                 mixingBytes,
                 mixingBytesSize,
                 &key,
                 &keyLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to derive cluster key, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock();
    lockAcquired = TRUE;

    //
    // Make sure another thread didn't beat us in obtaining a key.
    // We replace the cluster key with the generated key if it is
    // not different from the old key (or somebody set it to NULL).
    //
    if (NmpEncryptedClusterKey != NULL &&
        (oldEncryptedKey == NULL ||
         NmpEncryptedClusterKeyLength != oldEncryptedKeyLength ||
         RtlCompareMemory(
             NmpEncryptedClusterKey,
             oldEncryptedKey,
             oldEncryptedKeyLength
             ) != oldEncryptedKeyLength
         )
        ) {

        //
        // Keep the current NmpEncryptedClusterKey.
        //
    } else {


        //
        // Encrypt derived credentials and store them
        //

        if (NmpEncryptedClusterKey != NULL)
        {
            RtlSecureZeroMemory(NmpEncryptedClusterKey, NmpEncryptedClusterKeyLength);
            LocalFree(NmpEncryptedClusterKey);
        }

        status = NmpProtectData(key,
                                keyLength,
                                &NmpEncryptedClusterKey,
                                &NmpEncryptedClusterKeyLength
                                );

        if (status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to encrypt data using CryptProtectData, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }


    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    } else {
        NmpLeaveApi();
    }

    if (oldEncryptedKey != NULL)
    {
        MIDL_user_free(oldEncryptedKey);
    }

    if (key != NULL) {
        RtlSecureZeroMemory(key, keyLength);
        MIDL_user_free(key);
        key = NULL;
        keyLength = 0;
    }

    if (mixingBytes != NULL) {
        MIDL_user_free(mixingBytes);
        mixingBytes = NULL;
    }

    return(status);

} // NmpRederiveClusterKey

VOID
NmpFreeClusterKey(
    VOID
    )
/*++

Routine Description:

    Called during NmShutdown.

--*/
{
    if (NmpEncryptedClusterKey != NULL) {
        RtlSecureZeroMemory(NmpEncryptedClusterKey, NmpEncryptedClusterKeyLength);
        LocalFree(NmpEncryptedClusterKey);
        NmpEncryptedClusterKey = NULL;
        NmpEncryptedClusterKeyLength = 0;
    }

    return;

} // NmpFreeClusterKey


DWORD
NmpSetLsaProcessOptions(
    IN ULONG ProcessOptions
    )
/*++

Routine Description:

    Set LSA options for this process.

Arguments:

    ProcessOptions - MSV1_0_OPTION_XXX process option bit flags

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:


--*/
{
    DWORD ReturnStatus;
    NTSTATUS Status;
    BOOLEAN trusted = FALSE;
    HANDLE hLsa = NULL;
    LSA_STRING LsaStringBuf;
    char *AuthPackage = MSV1_0_PACKAGE_NAME;
    ULONG PackageId;
    ULONG cbOptionsRequest, cbResponse;
    MSV1_0_SETPROCESSOPTION_REQUEST OptionsRequest;
    PVOID Response = NULL;
    ULONG ResponseSize;
    NTSTATUS SubStatus;


    ReturnStatus = NmpConnectToLsaPrivileged(&hLsa, &trusted);
    if (ReturnStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to connect to the LSA server while setting "
            "process options, status %1!u!.\n",
            ReturnStatus
            );
        goto ErrorExit;
    }

    RtlInitString(&LsaStringBuf, AuthPackage);

    Status = LsaLookupAuthenticationPackage(
                 hLsa,
                 &LsaStringBuf, // MSV1_0 authentication package
                 &PackageId     // output: authentication package identifier.
                 );

    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);
        ClRtlLogPrint(
            LOG_CRITICAL,
            "[NM] Authentication package lookup failed while "
            "setting LSA process options, status %1!u!.\n",
            ReturnStatus
            );
        goto ErrorExit;
    }

    cbOptionsRequest = sizeof(OptionsRequest);
    ZeroMemory(&OptionsRequest, sizeof(OptionsRequest));
    OptionsRequest.MessageType = MsV1_0SetProcessOption;
    OptionsRequest.ProcessOptions = ProcessOptions;

    Status = LsaCallAuthenticationPackage(
                 hLsa,
                 PackageId,
                 &OptionsRequest,
                 cbOptionsRequest,
                 &Response,
                 &ResponseSize,
                 &SubStatus
                 );

    if (Status != STATUS_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(Status);

        ClRtlLogPrint(
            LOG_CRITICAL,
            "[NM] Failed to set LSA process options (1) to %1!x! , "
            "status %2!u!.\n",
            ProcessOptions, ReturnStatus
            );
        goto ErrorExit;
    }
    else if (LsaNtStatusToWinError(SubStatus) != ERROR_SUCCESS)
    {
        ReturnStatus = LsaNtStatusToWinError(SubStatus);

        ClRtlLogPrint(
            LOG_CRITICAL,
            "[NM] Failed to set LSA process options (2) to %1!x! , "
            "status %2!u!.\n",
            ProcessOptions, ReturnStatus
            );
        goto ErrorExit;
    }

    ReturnStatus = ERROR_SUCCESS;


ErrorExit:

    if (hLsa != NULL) {
        LsaDeregisterLogonProcess(hLsa);
        hLsa = NULL;
    }

    return ReturnStatus;

} // NmpSetLsaProcessOptions


// Helper routines used for encryption on the wire data
// currently used only by dmsync.c to secure transfer of checkpoints

// Here the pattern how this routines should be used
// (Crafted to produce the least amout of code change in dm to encrypt/decrypt data going over an RPC pipe)
//
// Encryption:
//   NmCryptor_Init(Cryptor)
//
//   NmCryptor_PrepareEncryptionBuffer(Cryptor, Buffer, Size);
//    <Put upto Cryptor->PayloadSize bytes of data into Cryptor->PayloadBuffer (say X bytes)>
//   NmCryptor_Encrypt(&Cryptor, X);
//    <transmit/store encrypted bytes from Cryptor->EncryptedBuffer, Cryptor->EncryptedSize>
//
//   ... repeat PrepareEncryptionBuffer/Encrypt for as many time as you need
//
//   NmCryptor_Destroy(Cryptor)
//
// Decryption:
//
//   NmCryptor_Init(Cryptor)
//
//     <Copy the data to be decrypted into some buffer>
//     NmCryptor_Decrypt(Cryptor, Buffer, Size);
//     <Get the data from Cryptor->PayloadBuffer, Cryptor->PayloadSize>
//
//     ... repeat NmCryptor_Decrypt for as many packets you have to decrypt ...
//
//   NmCryptor_Destroy(Cryptor)


typedef struct _NMP_CRYPTOR_HEADER {
    BYTE Salt[16];             // random goo which is mixed with the shared secret to produce a key
    BYTE SaltQuickSig[16]; // simple xor of salt bytes with 0xFF used as a quick test whether stuff is encrypted or not
    BYTE SaltSlowSig[16];  // encrypted salt bytes to check for the valid encryption key
} NM_CRYPTOR_HEADER, *PNM_CRYPTOR_HEADER;

VOID
NmCryptor_Init(
    IN OUT PNM_CRYPTOR Cryptor,
    IN BOOL EnableEncryption)
{
    ZeroMemory(Cryptor, sizeof(*Cryptor));
    Cryptor->EncryptionDisabled = !EnableEncryption;
}

BOOL NmpVerifyQuickSig(IN PNM_CRYPTOR_HEADER hdr)
{
    int i;
    if (hdr->SaltQuickSig[0] != 'Q' || hdr->SaltQuickSig[1] != 'S') {
        return FALSE;
    }
    for (i = 2; i < sizeof(hdr->Salt); ++i) {
        if (hdr->SaltQuickSig[i] != (hdr->Salt[i] ^ 0xFF) ) {
            return FALSE;
        }
    }
    return TRUE;
}

VOID NmpMakeQuickSig(IN PNM_CRYPTOR_HEADER hdr)
{
    int i;
    for (i = 2; i < sizeof(hdr->Salt); ++i) {
        hdr->SaltQuickSig[i] = hdr->Salt[i] ^ 0xFF;
    }
    hdr->SaltQuickSig[0] = 'Q';  // to make it easier to spot in the sniff
    hdr->SaltQuickSig[1] = 'S';  //
}

DWORD NmpCryptor_PrepareKey(
    IN OUT PNM_CRYPTOR Cryptor,
    IN BOOL GenerateSalt)
/*++

Routine Description:

    Calls prepares the key for encrption/decryption.
    Creates a symmetric key by mixing random 128bit salt with cluster password derived secret

Arguments:

    GenerateSalt - if true, salt is generated, if false, salt is read from a buffer

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    DWORD ClusterKeyLen = 0;
    PBYTE ClusterKey = NULL;

    PNM_CRYPTOR_HEADER hdr = (PNM_CRYPTOR_HEADER)Cryptor->EncryptedBuffer;

    if (GenerateSalt) {
        // Check that a buffer is big enough
        // to hold encryption header

        if (Cryptor->EncryptedSize < sizeof(*hdr)) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Cryptor: No room for the header, buffer size is only %1!u!.\n",
                Cryptor->EncryptedSize
                );
           return ERROR_INSUFFICIENT_BUFFER;
        }

    } else {
        // Otherwise, do a quick check whether the incoming data
        // is encrypted

        if (Cryptor->EncryptedSize < sizeof(*hdr)) {
            Cryptor->EncryptionDisabled = TRUE;
            return ERROR_SUCCESS;
        }

        if ( !NmpVerifyQuickSig(hdr) ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Cryptor: Data is not encrypted.\n"
                );
            Cryptor->EncryptionDisabled = TRUE;
            return ERROR_SUCCESS;
        }
    }

    Status = NmpCreateCSPHandle(&Cryptor->CryptProv);
    if (Status != ERROR_SUCCESS) {
       return Status;
    }

    if (GenerateSalt) {
        if (!CryptGenRandom(Cryptor->CryptProv, sizeof(hdr->Salt), hdr->Salt)){
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Cryptor: CryptGenRandom failed %1!u!.\n",
                Status
                );
            goto exit_gracefully;
        }
    }

    Status = NmpDeriveSessionKey(
       Cryptor->CryptProv,
       CALG_RC4, 128 << 16, // algorithm, key length
       hdr->Salt, sizeof(hdr->Salt),
       &Cryptor->CryptKey);

    if (Status != ERROR_SUCCESS) {
        goto exit_gracefully; // error logged by NmpDeriveSessionKey
    }

    if (GenerateSalt) {
        DWORD Len = sizeof(hdr->SaltSlowSig);

        // Encrypt SlowSig so that the receiver can verify the validity
        // of an encryption key of a sender
        memcpy(hdr->SaltSlowSig, hdr->Salt, sizeof(hdr->SaltSlowSig));
        if (!CryptEncrypt(Cryptor->CryptKey, 0, FALSE, 0, // hash,final,flags
                   hdr->SaltSlowSig, &Len, Len))
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to Encrypt signature, status %1!u!.\n",
                Status
                );
            goto exit_gracefully;
        }

        // now make quick signature (to test whether the incoming data is encrypted)
        NmpMakeQuickSig(hdr);

    } else {
        DWORD Len = sizeof(hdr->SaltSlowSig);

        // Verify encrypted portion of the signature
        if (!CryptDecrypt(Cryptor->CryptKey, 0, FALSE, 0, // hash,final,flags
                   hdr->SaltSlowSig, &Len))
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to Decrypt signature, status %1!u!.\n",
                Status
                );
            goto exit_gracefully;
        }
        if (memcmp(hdr->Salt, hdr->SaltSlowSig, sizeof(hdr->SaltSlowSig)) != 0) {
            Status = ERROR_DECRYPTION_FAILED;
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Signatures don't match.\n"
                );
            goto exit_gracefully;
        }
    }
    Cryptor->KeyGenerated = TRUE;

exit_gracefully:

    return Status;
}

DWORD
NmCryptor_Decrypt(
    IN OUT PNM_CRYPTOR Cryptor,
    IN OUT PVOID Buffer,
    IN DWORD BufferSize)
/*++

Routine Description:

    Decrypts the supplied buffer

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

   If the routine succeeds, use

     Cryptor->PayloadBuffer
     Cryptor->PayloadSize

   fields to get to the decrypted data

--*/
{
    DWORD Status = ERROR_SUCCESS;

    Cryptor->PayloadBuffer = (PBYTE)Buffer;
    Cryptor->PayloadSize   = BufferSize;

    Cryptor->EncryptedBuffer = Cryptor->PayloadBuffer;
    Cryptor->EncryptedSize = BufferSize;

    if (Cryptor->EncryptionDisabled) {
        return ERROR_SUCCESS;
    }

    if (!Cryptor->KeyGenerated) {
        Status = NmpCryptor_PrepareKey(Cryptor, FALSE);
        if (Status != ERROR_SUCCESS) {
            return Status;
        }
        if (Cryptor->EncryptionDisabled) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Cryptor received unencrypted data.\n"
                );
            return ERROR_SUCCESS;
        }
        Cryptor->PayloadBuffer = Cryptor->PayloadBuffer + sizeof(NM_CRYPTOR_HEADER);
        Cryptor->PayloadSize -= sizeof(NM_CRYPTOR_HEADER);
    }

    if (!CryptDecrypt(Cryptor->CryptKey, 0, FALSE, 0,
            Cryptor->PayloadBuffer, &Cryptor->PayloadSize))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to Decrypt buffer, status %1!u!.\n",
            Status
            );
    }
    return Status;
}

VOID
NmCryptor_PrepareEncryptionBuffer(
    IN OUT PNM_CRYPTOR Cryptor,
    IN OUT PVOID Buffer,
    IN DWORD BufferSize)
/*++

Routine Description:

    Supplies the information about the buffer ti be used for encryption

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    When the function returns, use

    Cryptor->PayloadBuffer
    Cryptor->PayloadSize

    to figure out where to put the data to be encrypted

--*/
{
    Cryptor->PayloadBuffer = (PBYTE)Buffer;
    Cryptor->PayloadSize   = BufferSize;

    Cryptor->EncryptedBuffer = Cryptor->PayloadBuffer;
    Cryptor->EncryptedSize = BufferSize;

    if (Cryptor->EncryptionDisabled || Cryptor->KeyGenerated) {
        return;
    }

    if (NmpIsNT5NodeInCluster == FALSE) {

        // Create room for the header
        Cryptor->PayloadBuffer += sizeof(NM_CRYPTOR_HEADER);
        Cryptor->PayloadSize    -= sizeof(NM_CRYPTOR_HEADER);
    } else {
        Cryptor->EncryptionDisabled = TRUE;
    }
}

DWORD
NmCryptor_Encrypt(
    IN OUT PNM_CRYPTOR Cryptor,
    DWORD DataSize)
/*++

Routine Description:

    Encrypts DataSize bytes

Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

Notes:

    Input data are in the buffer pointed by
        Cryptor->PayloadSize (prepared by NmCryptor_PrepareEncryptionBuffer routine)

    Output data are in:

    Cryptor->EncryptedBuffer == Whatever buffer was supplied to NmCryptor_PrepareEncryptionBuffer
    Cryptor->EncryptedSize

--*/
{
    DWORD Status = ERROR_SUCCESS;

    if (Cryptor->EncryptionDisabled) {
        Cryptor->EncryptedSize = DataSize;
        return ERROR_SUCCESS;
    }

    if (!Cryptor->KeyGenerated) {
        Status = NmpCryptor_PrepareKey(Cryptor, TRUE);
        if (Status != ERROR_SUCCESS) {
            return Status;
        }
    }

    if (!CryptEncrypt(Cryptor->CryptKey, 0, FALSE, 0,
       Cryptor->PayloadBuffer, &DataSize, Cryptor->EncryptedSize))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to Encrypt buffer, status %1!u!.\n",
            Status
            );
    }
    Cryptor->EncryptedSize =
        DataSize + (int)(Cryptor->PayloadBuffer - Cryptor->EncryptedBuffer);
    return Status;
}

VOID
NmCryptor_Destroy(
    PNM_CRYPTOR Cryptor)
{
    if (Cryptor == NULL) {
       return;
    }
    if (Cryptor->CryptKey) {
       CryptDestroyKey(Cryptor->CryptKey);
    }
    if (Cryptor->CryptProv) {
       CryptReleaseContext(Cryptor->CryptProv, 0);
    }
}




void
NmpFreeNetworkMulticastKey(
    PNM_NETWORK_MULTICASTKEY networkMulticastKey
    )
{
    if (networkMulticastKey != NULL)
    {

        if (networkMulticastKey->EncryptedMulticastKey != NULL)
        {
            MIDL_user_free(networkMulticastKey->EncryptedMulticastKey);
        }

        if (networkMulticastKey->MAC != NULL)
        {
            MIDL_user_free(networkMulticastKey->MAC);
        }

        if (networkMulticastKey->Salt != NULL)
        {
            MIDL_user_free(networkMulticastKey->Salt);
        }

        MIDL_user_free(networkMulticastKey);
    }


} // NmpFreeNetworkMulticastKey()



DWORD
NmpGetMulticastKeyFromNMLeader(
    IN DWORD LeaderNodeId,
    IN LPWSTR NodeIdString,
    IN LPWSTR NetworkId,
    IN PNM_NETWORK_MULTICASTKEY * MulticastKey
    )
/*++

Routine Description:

    Issue a retrieve request for network multicast key to NM leader.

Arguments:


Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.

Notes:

    This routine mimics GumpUpdateRemoteNode. In Longhorn, there
    should be one generic async RPC call wrapper.

--*/
{
    DWORD Status;
    HANDLE hEventHandle;
    BOOL result;
    PNM_NODE Node = NULL;
    HANDLE handleArr[2];
    RPC_ASYNC_STATE AsyncState;
    RPC_BINDING_HANDLE rpcBinding;

    //
    // Prepare for async RPC. We do this here to avoid hitting a failure
    // after the update is already in progress.
    //
    ZeroMemory((PVOID) &AsyncState, sizeof(RPC_ASYNC_STATE));

    AsyncState.u.hEvent = CreateEvent(
                               NULL,  // no attributes
                               TRUE,  // manual reset
                               FALSE, // initial state unsignalled
                               NULL   // no object name
                               );

    if (AsyncState.u.hEvent == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] NmpGetMulticastKeyFromNMLeader: Failed to allocate event object for async "
            "RPC call, status %1!u!\n",
            Status
            );

        return (Status);
    }

    //
    // Initialize the async RPC tracking information
    //
    hEventHandle = AsyncState.u.hEvent;
    AsyncState.u.hEvent = NULL;


    Status = RpcAsyncInitializeHandle(&AsyncState, sizeof(RPC_ASYNC_STATE));
    AsyncState.u.hEvent = hEventHandle;

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] NmpGetMulticastKeyFromNMLeader: Failed to initialize async RPC status "
            "block, status %1!u!\n",
            Status
            );

        goto error_exit;
    }

    AsyncState.UserInfo = NULL;
    AsyncState.NotificationType = RpcNotificationTypeEvent;


    result = ResetEvent(AsyncState.u.hEvent);
    CL_ASSERT(result != 0);

    //
    // Now hook onto NM node state down event mechanism to detect node downs.
    //
    Node = NmReferenceNodeById(LeaderNodeId);
    CL_ASSERT(Node != NULL);
    if (Node == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_UNUSUAL,
            "[GUM] NmpGetMulticastKeyFromNMLeader: Failed to reference leader "
            "node id %1!u!, status %2!u!\n",
            LeaderNodeId, Status
            );

        goto error_exit;
    }
    
    handleArr[0] = AsyncState.u.hEvent;
    handleArr[1] = NmGetNodeStateDownEvent(Node);

    //
    // Get the RPC binding handle for the leader node.
    //
    // Note that there is a race condition here with
    // ClMsgCleanup. The Session array can be freed
    // before we dereference Session. This would lead
    // to an unfortunate AV exception, but it would not
    // be tragic since the service is already terminating
    // abnormally if ClMsgCleanup is executing.
    //
    if (Session != NULL) {
        rpcBinding = Session[LeaderNodeId];
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[GUM] NmpGetMulticastKeyFromNMLeader: No RPC "
            "binding handle for leader node id %1!u!.\n",
            LeaderNodeId
            );
        Status = ERROR_CLUSTER_NODE_UNREACHABLE;
        goto error_exit;
    }

    try {


        //
        // Get multicast key from the leader
        //
        Status = NmRpcGetNetworkMulticastKey(
                                          &AsyncState,
                                          rpcBinding,
                                          NodeIdString,
                                          NetworkId,
                                          MulticastKey
                                          );

        if (Status == RPC_S_OK) {
            DWORD RpcStatus;

            //
            // The call is pending. Wait for completion.
            //
            Status = WaitForMultipleObjects(
                        2,
                        handleArr,
                        FALSE,
                        INFINITE
                        );

            if (Status != WAIT_OBJECT_0) {
                //
                // Something went wrong.
                // Either this is a rpc failure or, the target node went down.
                //
                CL_ASSERT(Status != WAIT_OBJECT_0);
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[GUM] NmpGetMulticastKeyFromNMLeader: Wait for NmRpcGetNetworkMulticastKey"
                    " failed, status %1!u!\n",
                    Status
                    );

                //
                // Cancel the call, just to be safe.
                //
                RpcStatus = RpcAsyncCancelCall(
                                &AsyncState,
                                TRUE         // Abortive cancel
                                );
                if (RpcStatus != RPC_S_OK) {
                    ClRtlLogPrint(LOG_CRITICAL,
                    "[GUM] NmpGetMulticastKeyFromNMLeader: RpcAsyncCancelCall()= "
                    "  %1!u!\n",
                    RpcStatus
                    );
                }
                CL_ASSERT(RpcStatus == RPC_S_OK);

                //
                // Wait for the call to complete.
                //
                Status = WaitForSingleObject(
                             AsyncState.u.hEvent,
                             INFINITE
                             );
                if (Status != WAIT_OBJECT_0) {
                    ClRtlLogPrint(LOG_CRITICAL,
                    "[GUM] NmpGetMulticastKeyFromNMLeader: WaitForSingleObject()= "
                    "  %1!u!\n",
                    Status
                    );
                }
                CL_ASSERT(Status == WAIT_OBJECT_0);
            }

            //
            // The call should now be complete. Get the
            // completion status. Any RPC error will be
            // returned in 'RpcStatus'. If there was no
            // RPC error, then any application error will
            // be returned in 'Status'.
            //
            RpcStatus = RpcAsyncCompleteCall(
                            &AsyncState,
                            &Status
                            );

            if (RpcStatus != RPC_S_OK) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[GUM] NmpGetMulticastKeyFromNMLeader: Failed to get "
                    "completion status for async RPC call,"
                    "status %1!u!\n",
                    RpcStatus
                    );
                Status = RpcStatus;
            }
        }
        else {
            //
            // An error was returned synchronously.
            //
            ClRtlLogPrint(LOG_CRITICAL,
                "[GUM] NmpGetMulticastKeyFromNMLeader: NmRpcGetNetworkMulticastKey() "
                "failed synchronously, status %1!u!\n",
                Status
                );
        }

    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = GetExceptionCode();
    }

error_exit:

    if (AsyncState.u.hEvent != NULL) {
        CloseHandle(AsyncState.u.hEvent);
    }

    if (Node != NULL) {
        OmDereferenceObject(Node);
    }

    return(Status);

} // NmpGetMulticastKeyFromNMLeader


#ifdef MULTICAST_DEBUG
DWORD
NmpDbgPrintData(LPCWSTR InfoStr,
                PVOID Data,
                DWORD DataLen
                )
{
    DWORD i;


    ClRtlLogPrint(
        LOG_NOISE,
        "\n\n%1!ws!\n",
        InfoStr);


    for (i=0; i<DataLen/sizeof(DWORD); i++)
    {
        ClRtlLogPrint(
            LOG_NOISE,
            "%1!u! =    %2!u!\n",
            i,
            *((DWORD *)Data+i)
            );
    }


    ClRtlLogPrint(
        LOG_NOISE,
        "\n\n"
        );
    return ERROR_SUCCESS;

} // NmpDbgPrintData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\nmver.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nmver.c

Abstract:

    Version management functions used by rolling upgrade.

Author:

    Sunita Shrivastava (sunitas)

Revision History:

    1/29/98   Created.

--*/

#include "nmp.h"

#define       NMP_DEFAULT_JOIN_DELAY          3000

DWORD
NmpGetJoinVersionDelay(
    RPC_BINDING_HANDLE     ClientHandle
    )

/*++

Routine Description:

    Determine the delay to introduce before responding to a 
    join-version request. The delay is determined by network
    priority. The highest priority network has no delay.

Arguments:

    ClientHandle - client RPC binding handle

Return value:

    Delay in milliseconds

Notes:

    Called with NM lock held

--*/
{
    RPC_BINDING_HANDLE      serverBinding = NULL;
    LPWSTR                  serverStringBinding = NULL;
    LPWSTR                  networkAddressString = NULL;
    PNM_NETWORK             network = NULL;
    DWORD                   delay = NMP_DEFAULT_JOIN_DELAY;
    DWORD                   error;

    error = RpcBindingServerFromClient(ClientHandle, &serverBinding);
    if (error != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get server binding, error %1!u!.\n",
            error
            );
        goto error_exit;
    }

    error = RpcBindingToStringBinding(serverBinding, &serverStringBinding);
    if (error != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert server binding to string binding, "
            "error %1!u!.\n",
            error
            );
        goto error_exit;
    }

    error = RpcStringBindingParse(
                serverStringBinding,
                NULL, // object uuid
                NULL, // prot seq
                &networkAddressString,
                NULL, // endpoint
                NULL  // network options
                );
    if (error != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to parse network address from "
            "server binding string, error %1!u!.\n",
            error
            );
        goto error_exit;
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Received sponsorship request from client "
            "address %1!ws!.\n",
            networkAddressString
            );
    }

    network = NmpReferenceNetworkByRemoteAddress(networkAddressString);
    if (network == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to find network matching address %1!ws!, "
            "error %2!u!.\n",
            networkAddressString, error
            );
        goto error_exit;
    }

    if (network->Priority == 1) {
        delay = 0;
    }

error_exit:

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Calculated join-version delay of %1!u! milliseconds "
        "for request from address %2!ws!.\n",
        delay,
        ((networkAddressString == NULL) ? NmpUnknownString : networkAddressString)
        );
    
    if (network != NULL) {
        NmpDereferenceNetwork(network);
    }
    
    if (networkAddressString != NULL) {
        RpcStringFree(&networkAddressString);
    }

    if (serverStringBinding != NULL) {
        RpcStringFree(&serverStringBinding);
    }

    if (serverBinding != NULL) {
        RpcBindingFree(serverBinding);
    }

    return(delay);
    
} // NmpGetJoinVersionDelay

error_status_t
s_CsRpcGetJoinVersionData(
    handle_t  handle,
    DWORD     JoiningNodeId,
    DWORD     JoinerHighestVersion,
    DWORD     JoinerLowestVersion,
    LPDWORD   SponsorNodeId,
    LPDWORD   ClusterHighestVersion,
    LPDWORD   ClusterLowestVersion,
    LPDWORD   JoinStatus
    )

/*++

Routine Description:

    Get from and supply to the joiner, version information about the
    sponsor. Mostly a no-op for first version.

    Determine network priority. Delay response to clients over networks
    that are not top priority. This heuristic increases the chance that
    join will occur over a private, hence physically secure network.

Arguments:

    A pile...

Return Value:

    None

--*/

{
    *SponsorNodeId = NmLocalNodeId;

    NmpAcquireLock();

    if (JoiningNodeId == 0)
    {
        //called by setup join
        *ClusterHighestVersion = CsClusterHighestVersion;
        *ClusterLowestVersion = CsClusterLowestVersion;
        //dont exclude any node for version calculation and checking
        *JoinStatus = NmpIsNodeVersionAllowed(ClusterInvalidNodeId, JoinerHighestVersion,
            JoinerLowestVersion, TRUE);

        NmpReleaseLock();
    }
    else
    {
        //called by regular join
        DWORD delay;

        //SS:  we should verify this against the cluster version
        NmpCalcClusterVersion(
            JoiningNodeId,
            ClusterHighestVersion,
            ClusterLowestVersion
            );
        *JoinStatus = NmpIsNodeVersionAllowed(JoiningNodeId, JoinerHighestVersion,
            JoinerLowestVersion, TRUE);

        // Determine the delay.
        delay = NmpGetJoinVersionDelay((RPC_BINDING_HANDLE) handle);
        
        NmpReleaseLock();

        if (delay > 0) {
            Sleep(delay);
        }
    }

    return ERROR_SUCCESS;
}

/****
@func       HLOG | NmGetClusterOperationalVersion| This returns the
            operational version for the cluster.

@parm       LPDWORD | pdwClusterHighestVersion | A pointer to a DWORD where
            the Cluster Highest Version is returned.

@parm       LPDWORD | pdwClusterHighestVersion | A pointer to a DWORD where
            the Cluster Lowest Version is returned.

@parm       LPDWORD | pdwFlags | A pointer to a DWORD where the flags
            describing the cluster mode(pure vs fixed version etc) are
            returned.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm

@xref       <>
****/
DWORD NmGetClusterOperationalVersion(
    OUT LPDWORD pdwClusterHighestVersion, OPTIONAL
    OUT LPDWORD pdwClusterLowestVersion,  OPTIONAL
    OUT LPDWORD pdwFlags                  OPTIONAL
)
{

    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       flags = 0;

    //acquire the lock, we are going to be messing with the operational
    //versions for the cluster
    NmpAcquireLock();

    if (pdwClusterHighestVersion != NULL) {
        *pdwClusterHighestVersion = CsClusterHighestVersion;
    }

    if (pdwClusterLowestVersion != NULL) {
        *pdwClusterLowestVersion = CsClusterLowestVersion;
    }

    if (CsClusterHighestVersion == CsClusterLowestVersion) {
        //this is a mixed mode cluster, with the possible exception of
        //nt 4 release(which didnt quite understand anything about rolling
        //upgrades
        flags = CLUSTER_VERSION_FLAG_MIXED_MODE;
    }

    NmpReleaseLock();

    if (pdwFlags != NULL) {
        *pdwFlags = flags;
    }

    return (ERROR_SUCCESS);
}


/****
@func       HLOG | NmpResetClusterVersion| An operational version of the
            cluster is maintained in the service.  This function recalculates
            the operation version. The operational version describes the mode
            in which the cluster is running and prevents nodes which are two
            versions away from running in the same cluster.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called when a node forms a cluster(to initialize
            the operational version) OR when a node joins a cluster (to
            initialize its version) OR when a node is ejected from a
            cluster(to recalculate the clusterversion).

@xref       <>
****/
VOID
NmpResetClusterVersion(
    BOOL ProcessChanges
    )
{
    PNM_NODE    pNmNode;

    //acquire the lock, we are going to be messing with the operational
    //versions for the cluster
    NmpAcquireLock();

    //initialize the clusterhighestverion and clusterlowest version
    NmpCalcClusterVersion(
        ClusterInvalidNodeId,
        &CsClusterHighestVersion,
        &CsClusterLowestVersion
        );

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] [NmpResetClusterVersion] ClusterHighestVer=0x%1!08lx! ClusterLowestVer=0x%2!08lx!\r\n",
        CsClusterHighestVersion,
        CsClusterLowestVersion
        );

    if (ProcessChanges) {
        //
        // If the cluster operational version changed, adjust
        // algorithms and data as needed.
        //
        NmpProcessClusterVersionChange();
    }

    NmpReleaseLock();

    return;
}

/****
@func       HLOG | NmpValidateNodeVersion| The sponsor validates that the
            version of the joiner is still the same as before.

@parm       IN LPWSTR| NodeJoinerId | The Id of the node that is trying to
            join.

@parm       IN DWORD | NodeHighestVersion | The highest version with which
            this node can communicate.

@parm       IN DWORD | NodeLowestVersion | The lowest version with which this
            node can communicate.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called at join time to make sure that the
            joiner's version is still the same as when he last joined.  Due
            to uninstalls/upgrade, the cluster service version may change on
            a node.  Usually on a complete uninstall, one is expected to
            evict the node out before it may join again.

@xref       <>
****/
DWORD NmpValidateNodeVersion(
    IN LPCWSTR  NodeId,
    IN DWORD    dwHighestVersion,
    IN DWORD    dwLowestVersion
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNmNode = NULL;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpValidateNodeVersion: Node=%1!ws!, HighestVersion=0x%2!08lx!, LowestVersion=0x%3!08lx!\r\n",
        NodeId, dwHighestVersion, dwLowestVersion);

    //acquire the NmpLocks, we will be examining the node structure for
    // the joiner node
    NmpAcquireLock();

    pNmNode = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (!pNmNode)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto FnExit;
    }

    if ((pNmNode->HighestVersion != dwHighestVersion) ||
        (pNmNode->LowestVersion != dwLowestVersion))
    {
        dwStatus = ERROR_REVISION_MISMATCH;
        goto FnExit;
    }

FnExit:
    if (pNmNode) OmDereferenceObject(pNmNode);
    ClRtlLogPrint(LOG_NOISE, "[NM] NmpValidateNodeVersion: returns %1!u!\r\n",
        dwStatus);
    NmpReleaseLock();
    return(dwStatus);
}

/****
@func       DWORD | NmpFormFixupNodeVersion| This may be called by a node
            when it is forming a cluster to fix the registry reflect its
            correct version.

@parm       IN LPCWSTR| NodeId | The Id of the node that is trying to join.

@parm       IN DWORD | dwHighestVersion | The highest version of the cluster
            s/w running on this code.

@parm       IN DWORD | dwLowestVersion | The lowest version of the cluster
            s/w running on this node.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       If on a form, there is a mismatch between the versions of the
            cluster s/w and what is recorded as the version in the cluster
            database, the forming node checks to see if the version of
            its current s/w is compatible with the operational version of the
            cluster.  If so, it resets the registry to reflect the correct
            version.  Else,  the form is aborted.

@xref       <f NmpIsNodeVersionAllowed>
****/
DWORD NmpFormFixupNodeVersion(
    IN LPCWSTR      NodeId,
    IN DWORD        dwHighestVersion,
    IN DWORD        dwLowestVersion
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNmNode = NULL;
    HDMKEY      hNodeKey = NULL;

    //acquire the NmpLocks, we will be fixing up the node structure for
    // the joiner node
    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpFormFixupNodeVersion: Node=%1!ws! to HighestVer=0x%2!08lx!, LowestVer=0x%3!08lx!\r\n",
        NodeId, dwHighestVersion, dwLowestVersion);

    pNmNode = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (!pNmNode)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto FnExit;
    }

    hNodeKey = DmOpenKey(DmNodesKey, NodeId, KEY_WRITE);

    if (hNodeKey == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpFormFixupNodeVersion: Failed to open node key, status %1!u!\n",
            dwStatus);
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's highest version
    dwStatus = DmSetValue(hNodeKey, CLUSREG_NAME_NODE_HIGHEST_VERSION,
        REG_DWORD, (LPBYTE)&dwHighestVersion, sizeof(DWORD));

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpFormFixupNodeVersion: Failed to set the highest version\r\n");
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's lowest version
    dwStatus = DmSetValue(hNodeKey, CLUSREG_NAME_NODE_LOWEST_VERSION,
        REG_DWORD, (LPBYTE)&dwLowestVersion, sizeof(DWORD));

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpFormFixupNodeVersion: Failed to set the lowest version\r\n");
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    pNmNode->HighestVersion = dwHighestVersion;
    pNmNode->LowestVersion = dwLowestVersion;

FnExit:
    NmpReleaseLock();
    if (pNmNode)
        OmDereferenceObject(pNmNode);
    if (hNodeKey != NULL)
        DmCloseKey(hNodeKey);

    return(dwStatus);
}

/****
@func       DWORD | NmpJoinFixupNodeVersion| This may be called by a node
            when it is forming a cluster to fix the registry reflect its
            correct version.

@parm       IN LPCWSTR| NodeId | The Id of the node that is trying to join.

@parm       IN DWORD | dwHighestVersion | The highest version of this cluster
            s/w running on this code.

@parm       IN DWORD | dwLowestVersion | The lowest version of the cluster
            s/w running on this node.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       If on a form, their is a mismatch between the versions of the
            cluster s/w and what is recorded as the version in the cluster
            database, the forming node checks to see if the version of
            its current s/w compatible with the operational version of the
            cluster.  If so, it resets the registry to reflect the correct
            version.  Else,  the form is aborted.

@xref       <f NmpIsNodeVersionAllowed>
****/
DWORD NmpJoinFixupNodeVersion(
    IN HLOCALXSACTION   hXsaction,
    IN LPCWSTR          szNodeId,
    IN DWORD            dwHighestVersion,
    IN DWORD            dwLowestVersion
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNmNode = NULL;
    HDMKEY      hNodeKey = NULL;

    //acquire the NmpLocks, we will be fixing up the node structure for
    // the joiner node
    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpJoinFixupNodeVersion: Node=%1!ws! to HighestVer=0x%2!08lx!, LowestVer=0x%3!08lx!\r\n",
        szNodeId, dwHighestVersion, dwLowestVersion);

    pNmNode = OmReferenceObjectById(ObjectTypeNode, szNodeId);

    if (!pNmNode)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        goto FnExit;
    }

    hNodeKey = DmOpenKey(DmNodesKey, szNodeId, KEY_WRITE);

    if (hNodeKey == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpJoinFixupNodeVersion: Failed to open node key, status %1!u!\n",
            dwStatus);
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's highest version
    dwStatus = DmLocalSetValue(
                   hXsaction,
                   hNodeKey,
                   CLUSREG_NAME_NODE_HIGHEST_VERSION,
                   REG_DWORD,
                   (LPBYTE)&dwHighestVersion,
                   sizeof(DWORD)
                   );

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpJoinFixupNodeVersion: Failed to set the highest version\r\n"
            );
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //set the node's lowest version
    dwStatus = DmLocalSetValue(
                   hXsaction,
                   hNodeKey,
                   CLUSREG_NAME_NODE_LOWEST_VERSION,
                   REG_DWORD,
                   (LPBYTE)&dwLowestVersion,
                   sizeof(DWORD)
                   );

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpJoinFixupNodeVersion: Failed to set the lowest version\r\n"
            );
        CL_LOGFAILURE(dwStatus);
        goto FnExit;
    }

    //if written to the registry successfully, update the in-memory structures
    pNmNode->HighestVersion = dwHighestVersion;
    pNmNode->LowestVersion = dwLowestVersion;


    if (dwStatus == ERROR_SUCCESS)
    {
        ClusterEvent(CLUSTER_EVENT_NODE_PROPERTY_CHANGE, pNmNode);
    }
    

FnExit:
    NmpReleaseLock();
    if (pNmNode)
        OmDereferenceObject(pNmNode);
    if (hNodeKey != NULL)
        DmCloseKey(hNodeKey);

    return(dwStatus);
}

/****
@func       HLOG | NmpIsNodeVersionAllowed| This is called at join time
            (not setup join) e sponsor validates if a joiner
            should be allowed to join a  cluster at this time.  In a mixed
            mode cluster, a node may not be able to join a cluster if another
            node that is two versions away is already a part of the cluster.

@parm       IN DWORD | dwExcludeNodeId |  The node Id to exclude while
            evaluating the cluster operational version.

@parm       IN DWORD | NodeHighestVersion | The highest version with which
            this node can communicate.

@parm       IN DWORD | NodeLowestVersion | The lowest version with which this
            node can communicate.

@parm       IN BOOL |bJoin| If this is being invoked at join or form time.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called when a node requests a sponsor to allow
            it to join a cluster.

@xref       <>
****/
DWORD NmpIsNodeVersionAllowed(
    IN DWORD    dwExcludeNodeId,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion,
    IN BOOL     bJoin
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           ClusterHighestVersion;
    DWORD           ClusterLowestVersion;
    PLIST_ENTRY     pListEntry;
    DWORD           dwCnt;
    PNM_NODE        pNmNode;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpIsNodeVersionAllowed: Entry ExcludeNodeId=%1!u! HighestVersion=0x%2!08lx! LowestVersion=0x%3!08lx!\r\n",
        dwExcludeNodeId, dwNodeHighestVersion, dwNodeLowestVersion);


    //acquire the NmpLocks, we will be examining the node structures
    NmpAcquireLock();

    //if NoVersionCheckOption is true
    if (CsNoVersionCheck)
        goto FnExit;


    //if this is a single node cluster, and this is being called at form
    //the count of nodes is zero.
    //this will happen when the registry versions dont match with
    //cluster service exe version numbers and we need to allow the single
    //node to form
    for (dwCnt=0, pListEntry = NmpNodeList.Flink;
        pListEntry != &NmpNodeList; pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);
        if (NmGetNodeId(pNmNode) == dwExcludeNodeId)
            continue;
        dwCnt++;
    }

    if (!dwCnt)
    {
        //allow the node to form
        goto FnExit;
    }


    dwStatus = NmpCalcClusterVersion(
                   dwExcludeNodeId,
                   &ClusterHighestVersion,
                   &ClusterLowestVersion
                   );

    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //if the node is forming
    if (!bJoin)
    {

        DWORD       dwMinorVersion = 0x00000000;
        PNM_NODE    pFormingNode = NULL;
        DWORD       dwMaxHighestVersion = 0x00000000;

        for (pListEntry = NmpNodeList.Flink; pListEntry != &NmpNodeList;
            pListEntry = pListEntry->Flink )
        {
                pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

                if (NmGetNodeId(pNmNode) == dwExcludeNodeId)
                {
                    pFormingNode = pNmNode;
                    continue;
                }

                dwMaxHighestVersion = max( dwMaxHighestVersion, pNmNode->HighestVersion);
                if (CLUSTER_GET_MAJOR_VERSION(pNmNode->HighestVersion) ==
                     CLUSTER_GET_MAJOR_VERSION(dwNodeHighestVersion))
                {
                    //the minor version to check is the maximum of the
                    //build numbers amongst the nodes with the same major
                    //version
                    dwMinorVersion = max(dwMinorVersion,
                        CLUSTER_GET_MINOR_VERSION(pNmNode->HighestVersion));
                }
        }

        //on the form path, the forming node must be passed in as the node to 
        //exclude
        if (!pFormingNode)
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] NmpIsNodeVersionAllowed: Form requested without excluding the forming node\r\n");
            dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
            goto FnExit;        
        }
        //dont allow a node to form unless its minor(or build number)
        //is greater than or equal to all other nodes with the same
        //major number in the cluster
        //this is to prevent a lower build on a node to regress the cluster version
        // if other nodes have already upgraded to higher builds
        if ((dwMinorVersion != 0) &&
            (CLUSTER_GET_MINOR_VERSION(dwNodeHighestVersion) < dwMinorVersion))
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] NmpIsNodeVersionAllowed: Minor Version of forming node is lower\r\n");
            dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
            goto FnExit;
        }
        else
        {
            //there is no other node with the same major version in the cluster
            //or the forming node's minor version is higher than those of other
            //nodes with the same major version in which case it may form
            //Note: Do not use the CsUpgrade variable on the joining path
            //since it is local and this function is invoked from rpc calls
            //on join and that can have an unintended effect
            if (!CsUpgrade)
            {
                //if the service is not being upgraded the value in the registry
                //should be uptodate with the version of the executable
                if ((pFormingNode->HighestVersion != dwNodeHighestVersion) ||
                    (pFormingNode->LowestVersion != dwNodeLowestVersion))
                {
                    //this is not an upgrade
                    //somebody has just copied a different version of service
                    //without going through a proper upgrade
                    //dont allow that
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] NmpIsNodeVersionAllowed: Copied binary without proper upgrade??\r\n");
                    dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
                    goto FnExit;
                 }   
            }
            if (dwNodeHighestVersion >= dwMaxHighestVersion)
            {
                //allow the node to form if its highest version number is greater
                //than or equal to that of the node with the max highest version
                //irrespective of whether it is an upgrade or not..this will
                //allow a node that has just double upgraded and stopped and restarted
                //to be able to restart
                ClRtlLogPrint(LOG_UNUSUAL, 
                         "[NM] NmpIsNodeVersionAllowed: Allow a node that has double upgraded or stopped and restarted to form\r\n");
                goto FnExit;
            }
            //else we fall through to the regular check
        }
    }

    //if the joiners lowest version is equal the clusters highest
    //For instance 3/2, 2/1 and 4/3 can all join 3/2
    if ((dwNodeHighestVersion == ClusterHighestVersion) ||
        (dwNodeHighestVersion == ClusterLowestVersion) ||
        (dwNodeLowestVersion == ClusterHighestVersion))
    {

        PNM_NODE    pNmNode= NULL;
        DWORD       dwMinorVersion;

        //since the version numbers include build number as the minor part
        // and we disallow a node from operating with a cluster if its
        // major number is equal but its minor number is different from
        // any of the nodes in the cluster.
        // The CsClusterHighestVersion doesnt encapsulate this since it just
        // remembers the highest  version that the cluster as a whole can talk
        // to.
        // E.g 1.
        // 3.2003 should be able to join a cluster with nodes
        // 3.2002(not running and not upgraded as yet but a part of the cluster)and
        // 3.2003(running).
        // E.g 2
        //  3.2002 will not be able to join a cluster with nodes 3.2003(running)and
        // 3.2002 (not running  but a part of the cluster)
        // E.g 3.
        // 3.2003 will not able to join a cluster with nodes 3.2002(running) and
        // 3.2002(running)

        dwMinorVersion = 0x00000000;

        for (pListEntry = NmpNodeList.Flink; pListEntry != &NmpNodeList;
            pListEntry = pListEntry->Flink )
        {
                pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

                if (NmGetNodeId(pNmNode) == dwExcludeNodeId)
                    continue;

                if (CLUSTER_GET_MAJOR_VERSION(pNmNode->HighestVersion) ==
                     CLUSTER_GET_MAJOR_VERSION(dwNodeHighestVersion))
                {
                    //the minor version to check is the maximum of the
                    //build numbers amongst the nodes with the same major
                    //version
                    dwMinorVersion = max(dwMinorVersion,
                        CLUSTER_GET_MINOR_VERSION(pNmNode->HighestVersion));
                }
        }
        // if the joining node's build number is the same as max of build
        //number of all nodes within the cluster with the same major version
        //allow it to participate in this cluster, else dont allow it to participate in this cluster
        //take care of a single node case by checking the minor number against
        //0
        if ((dwMinorVersion != 0) &&
            (CLUSTER_GET_MINOR_VERSION(dwNodeHighestVersion) != dwMinorVersion))
        {
            dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
        }
    }
    else
    {
        dwStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
    }

FnExit:
    NmpReleaseLock();
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpIsNodeVersionAllowed: Exit, Status=%1!u!\r\n",
        dwStatus);

    return(dwStatus);
}


/****
@func       HLOG | NmpCalcClusterVersion| This is called to calculate the
            operational cluster version.

@parm       IN DWORD | dwExcludeNodeId |  The node Id to exclude while evaluating
            the cluster operational version.

@parm       OUT LPDWORD | pdwClusterHighestVersion | The highest version with which this node
            can communicate.

@parm       IN LPDWORD | pdwClusterLowestVersion | The lowest version with which this node can
            communicate.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function must be called with the NmpLock held.

@xref       <f NmpResetClusterVersion> <f NmpIsNodeVersionAllowed>
****/
DWORD NmpCalcClusterVersion(
    IN  DWORD       dwExcludeNodeId,
    OUT LPDWORD     pdwClusterHighestVersion,
    OUT LPDWORD     pdwClusterLowestVersion
    )
{

    WCHAR       Buffer[4];
    PNM_NODE    pExcludeNode=NULL;
    PNM_NODE    pNmNode;
    DWORD       dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY pListEntry;
    DWORD       dwCnt = 0;
    DWORD       dwMaxHighestVersion = 0x00000000;
    PNM_NODE    pNmNodeWithHighestVersion;
    
    //initialize the values such that min/max do the right thing
    *pdwClusterHighestVersion = 0xFFFFFFFF;
    *pdwClusterLowestVersion = 0x00000000;

    if (dwExcludeNodeId != ClusterInvalidNodeId)
    {
        wsprintfW(Buffer, L"%d", dwExcludeNodeId);
        pExcludeNode = OmReferenceObjectById(ObjectTypeNode, Buffer);
        if (!pExcludeNode)
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] NmpCalcClusterVersion :Node=%1!ws! to be excluded not found\r\n",
                Buffer);
            goto FnExit;
        }
    }

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);
        if ((pExcludeNode) && (pExcludeNode->NodeId == pNmNode->NodeId))
            continue;

        //Actually to fix upgrade scenarios, we must fix the cluster
        //version such that the node with the highest minor version
        //is able to form/join but others arent
        // This is needed for multinode clusters
        if (CLUSTER_GET_MAJOR_VERSION(pNmNode->HighestVersion) ==
            CLUSTER_GET_MAJOR_VERSION(*pdwClusterHighestVersion))
        {
            if (CLUSTER_GET_MINOR_VERSION(pNmNode->HighestVersion) >
                CLUSTER_GET_MINOR_VERSION(*pdwClusterHighestVersion))
            {
                *pdwClusterHighestVersion = pNmNode->HighestVersion;
            }

        }
        else
        {
            *pdwClusterHighestVersion = min(
                                        *pdwClusterHighestVersion,
                                        pNmNode->HighestVersion
                                        );

        }
        *pdwClusterLowestVersion = max(
                                       *pdwClusterLowestVersion,
                                       pNmNode->LowestVersion
                                       );
        dwCnt++;

        if (pNmNode->HighestVersion > dwMaxHighestVersion)
        {
            dwMaxHighestVersion = pNmNode->HighestVersion;
            pNmNodeWithHighestVersion = pNmNode;
        }

    }

    //SS: if there is a node which skipped a build while upgrading
    //the regular cluster version calculations dont make sense
    if (CLUSTER_GET_MAJOR_VERSION(*pdwClusterHighestVersion) < CLUSTER_GET_MAJOR_VERSION
        (*pdwClusterLowestVersion))
    {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] NmpCalcClusterVersion: One of the nodes skipped a build on upgrade\r\n");
        //We will pull the cluster version to be the highest of all nodes
        //except the excluded node
        *pdwClusterHighestVersion = dwMaxHighestVersion;
        *pdwClusterLowestVersion = pNmNodeWithHighestVersion->LowestVersion;
    }
            
    if (dwCnt == 0)
    {
        ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpCalcClusterVersion: Single node version. Setting cluster version to node version\r\n"
        );

        //single node cluster, even though the we were requested to
        //exclude this node, the cluster version must be calculated
        //using that node's version
        *pdwClusterHighestVersion = pExcludeNode->HighestVersion;
        *pdwClusterLowestVersion = pExcludeNode->LowestVersion;
    }
    CL_ASSERT(*pdwClusterHighestVersion != 0xFFFFFFFF);
    CL_ASSERT(*pdwClusterLowestVersion != 0x00000000);

FnExit:
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmpCalcClusterVersion: status = %1!u! ClusHighestVer=0x%2!08lx!, ClusLowestVer=0x%3!08lx!\r\n",
        dwStatus, *pdwClusterHighestVersion, *pdwClusterLowestVersion);

    if (pExcludeNode) OmDereferenceObject(pExcludeNode);
    return(dwStatus);
}


VOID
NmpProcessClusterVersionChange(
    VOID
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD   status;
    LPWSTR  szClusterName=NULL;
    DWORD   dwSize=0;

    NmpMulticastProcessClusterVersionChange();

    //rjain: issue CLUSTER_EVENT_PROPERTY_CHANGE to propagate new
    //cluster version  info
    DmQuerySz( DmClusterParametersKey,
                    CLUSREG_NAME_CLUS_NAME,
                    &szClusterName,
                    &dwSize,
                    &dwSize);
    if(szClusterName)
        ClusterEventEx(
            CLUSTER_EVENT_PROPERTY_CHANGE,
            EP_FREE_CONTEXT,
            szClusterName
            );

    return;

} // NmpProcessClusterVersionChange


/****
@func       DWORD | NmpBuildVersionInfo| Its a callback function used by
            NmPerformFixups to build a property list of the Major Version,
            Minor version, Build Number and CSDVersionInfo, This propertylist
            is used by NmUpdatePerformFixups Update type to store this info
            in registry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID*  | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@param      OUT LPWSTR* | pszKeyName. The name of registry key for which this
            property list is being constructed.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmpUpdatePerformFixups2>
****/


DWORD NmpBuildVersionInfo(
    IN  DWORD     dwFixUpType,
    OUT PVOID  *  ppPropertyList,
    OUT LPDWORD   pdwPropertyListSize,
    OUT LPWSTR *  pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    HDMKEY          hdmKey;
    DWORD           dwTemp;
    CLUSTERVERSIONINFO ClusterVersionInfo;
    LPWSTR          szTemp=NULL;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    //check we if need to send this information
    dwTemp=(lstrlenW(CLUSREG_KEYNAME_NODES) + lstrlenW(L"\\")+lstrlenW(NmLocalNodeIdString)+1)*sizeof(WCHAR);
    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,dwTemp);
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_NODES);
    lstrcatW(*pszKeyName,L"\\");
    lstrcatW(*pszKeyName,NmLocalNodeIdString);

    // Build the parameter list

    pInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,4*sizeof(DWORD)+sizeof(LPWSTR));
    if(pInParams==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }

    CsGetClusterVersionInfo(&ClusterVersionInfo);

    dwTemp=(DWORD)ClusterVersionInfo.MajorVersion;
    CopyMemory(pInParams,&dwTemp,sizeof(DWORD));

    dwTemp=(DWORD)ClusterVersionInfo.MinorVersion;
    CopyMemory(pInParams+sizeof(DWORD),&dwTemp,sizeof(DWORD));

    dwTemp=(DWORD)ClusterVersionInfo.BuildNumber;
    CopyMemory(pInParams+2*sizeof(DWORD),&dwTemp,sizeof(DWORD));

    if(ClusterVersionInfo.szCSDVersion==NULL)
        szTemp=NULL;
    else
    {
        szTemp=(LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,(lstrlenW(ClusterVersionInfo.szCSDVersion) +1)*sizeof(WCHAR));
        if (szTemp==NULL)
        {
            dwStatus=GetLastError();
            goto FnExit;
        }
        lstrcpyW(szTemp,ClusterVersionInfo.szCSDVersion);
        szTemp[lstrlenW(ClusterVersionInfo.szCSDVersion)]=L'\0';
    }
    CopyMemory(pInParams+3*sizeof(DWORD),&szTemp,sizeof(LPWSTR));

    //copy the suite information
    CopyMemory(pInParams+3*sizeof(DWORD)+sizeof(LPWSTR*),
            &CsMyProductSuite, sizeof(DWORD));

    Required=sizeof(DWORD);
AllocMem:
    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmFixupVersionInfo,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                         );
    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,"[NM] NmBuildVersionInfo - error = %1!u!\r\n",dwStatus);
            goto FnExit;
        }

FnExit:
// Cleanup
    if (szTemp)
        LocalFree(szTemp);
    if(pInParams)
        LocalFree(pInParams);
    return dwStatus;
}//NmpBuildVersionInfo

/****
@func       HLOG | NmpCalcClusterNodeLimit|This is called to calculate the
            operational cluster node limit.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This acquires/releases NmpLock.

@xref       <f NmpResetClusterVersion> <f NmpIsNodeVersionAllowed>
****/
DWORD NmpCalcClusterNodeLimit(
    )
{
    PNM_NODE    pNmNode;
    DWORD       dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY pListEntry;

    //acquire the lock, we are going to be messing with the operational
    //versions for the cluster
    NmpAcquireLock();

    CsClusterNodeLimit = NmMaxNodeId;

    for ( pListEntry = NmpNodeList.Flink;
          pListEntry != &NmpNodeList;
          pListEntry = pListEntry->Flink )
    {
        pNmNode = CONTAINING_RECORD(pListEntry, NM_NODE, Linkage);

        CsClusterNodeLimit = min(
                                 CsClusterNodeLimit,
                                 ClRtlGetDefaultNodeLimit(
                                     pNmNode->ProductSuite
                                     )
                                );
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Calculated cluster node limit = %1!u!\r\n",
        CsClusterNodeLimit);

    NmpReleaseLock();

    return (dwStatus);
}


/****
@func       VOID| NmpResetClusterNodeLimit| An operational node limit
            on the number of nodes that can join this cluster is maintained.

@rdesc      Returns ERROR_SUCCESS on success or a win32 error code on failure.

@comm       This function is called when a node forms a cluster(to initialize
            the operational version) OR when a node joins a cluster (to
            initialize its version) OR when a node is ejected from a
            cluster(to recalculate the clusterversion).

@xref       <>
****/
VOID
NmpResetClusterNodeLimit(
    )
{
    NmpCalcClusterNodeLimit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\om\omlist.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    omlist.c

Abstract:

    Object Manager list processing routines for the NT Cluster Service

Author:

    John Vert (jvert) 27-Feb-1996

Revision History:

--*/
#include "omp.h"


POM_HEADER
OmpFindIdInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Searches the specified list of objects for the given name.

Arguments:

    ListHead - Supplies the head of the object list.

    Id - Supplies the Id string of the object.

Return Value:

    A pointer to the specified object's OM_HEADER if it is found

    NULL if the given Id string was not found

Notes:

    This routine assumes the the critical section for the object type
    is held on entry.

--*/

{
    PLIST_ENTRY ListEntry;
    POM_HEADER Header;
    POM_HEADER FoundHeader = NULL;

    ListEntry = ListHead->Flink;
    while (ListEntry != ListHead) {
        Header = CONTAINING_RECORD(ListEntry, OM_HEADER, ListEntry);
        if (lstrcmpiW(Header->Id, Id) == 0) {
            FoundHeader = Header;
            break;
        }
        ListEntry = ListEntry->Flink;
    }

    return(FoundHeader);

} // OmpFindIdInList



POM_HEADER
OmpFindNameInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Searches the specified list of objects for the given name.

Arguments:

    ListHead - Supplies the head of the object list.

    Name - Supplies the name of the object.

Return Value:

    A pointer to the specified object's OM_HEADER if it is found

    NULL if the given name was not found

Notes:

    This routine assumes the the critical section for the object type
    is held on entry.

--*/
{
    PLIST_ENTRY ListEntry;
    POM_HEADER Header;
    POM_HEADER FoundHeader = NULL;

    ListEntry = ListHead->Flink;
    while (ListEntry != ListHead) {
        Header = CONTAINING_RECORD(ListEntry, OM_HEADER, ListEntry);
        if (lstrcmpiW(Header->Name, Name) == 0) {
            FoundHeader = Header;
            break;
        }
        ListEntry = ListEntry->Flink;
    }

    return(FoundHeader);

} // OmpFindNameInList



POM_NOTIFY_RECORD
OmpFindNotifyCbInList(
    IN PLIST_ENTRY 			ListHead,
    IN OM_OBJECT_NOTIFYCB	pfnObjNotifyCb
    )

/*++

Routine Description:

    Searches the specified list of objects for the given name.

Arguments:

    ListHead - Supplies the head of the object list.

    pfnObjNotifyCb - Supplies the callback fn that we are looking
    	for.

Return Value:

    A pointer to the specified object's OM_NOTIFY_RECORD if it is found

    NULL if the given Id string was not found

Notes:

    This routine assumes the the critical section for the object type
    is held on entry.

--*/

{
    PLIST_ENTRY 		ListEntry;
    POM_NOTIFY_RECORD 	pNotifyRec;
    POM_NOTIFY_RECORD	pFoundNotifyRec = NULL;

    ListEntry = ListHead->Flink;
    while (ListEntry != ListHead) {
        pNotifyRec = CONTAINING_RECORD(ListEntry, OM_NOTIFY_RECORD, ListEntry);
        if (pNotifyRec->pfnObjNotifyCb == pfnObjNotifyCb)
        {
            pFoundNotifyRec = pNotifyRec;
            break;
        }
        ListEntry = ListEntry->Flink;
    }

    return(pFoundNotifyRec);

} // OmpFindNotifyCbInList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\om\omlog.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    omlog.c

Abstract:

    logging routines for the object log stream

    this code was jumpstarted from the clusrtl logging code. Most notably, it
    is UTF-8 encoded which allows full Unicode without the cost of writing
    16b. for each character.

    remaining issues to solve: proper truncation of log file based on current
    starting session. We'd like to remember as many sessions as possible but
    since I've chosen UTF-8, I can't jump to the middle of the file and start
    looking around. One possibility strategy is using an alternate NTFS stream
    to record the starting offsets of sessions. If that stream didn't exist or
    we're on a FAT FS, then we'll continue with the current strategy.

Author:

    Charlie Wickham (charlwi) 07-May-2001

Environment:

    User Mode

Revision History:

--*/

#include "omp.h"

//
// when this sequence is at the beginning of the file, it indicates that the
// file is UTF8 encoded
//
#define UTF8_BOM    "\x0EF\x0BB\x0BF"

//
// Private Data
//

DWORD   OmpLogFileLimit;
DWORD   OmpCurrentSessionStart;
BOOL    OmpLogToFile = FALSE;
HANDLE  OmpLogFileHandle = NULL;
DWORD   OmpProcessId;
DWORD   OmpCurrentSessionOffset;

PCLRTL_WORK_QUEUE OmpLoggerWorkQueue;

//
// structure used to pass formatted buffers to work queue routine
//
typedef struct _OM_LOG_BUFFER_DESC {
    DWORD   TimeBytes;
    DWORD   MsgBytes;
    PCHAR   TimeBuffer;
    PCHAR   MsgBuffer;
} OM_LOG_BUFFER_DESC, *POM_LOG_BUFFER_DESC;

#define MAX_NUMBER_LENGTH 20

// Specify maximum file size ( DWORD / 1MB )

#define MAX_FILE_SIZE ( 0xFFFFF000 / ( 1024 * 1024 ) )

DWORD               OmpLogFileLimit = ( 1 * 1024 * 1024 ); // 1 MB default
DWORD               OmpLogFileLoWater = 0;

//
// internal functions
//
DWORD
OmpTruncateFile(
    IN HANDLE FileHandle,
    IN DWORD FileSize,
    IN LPDWORD LastPosition
    )

/*++

Routine Description:

    Truncate a file by copying the portion starting at LastPosition and ending
    at EOF to the front of the file and setting the file's EOF pointer to the
    end of the new chunk. We always keep the current session even that means
    growing larger than the file limit.

    For now, we have no good way of finding all the sessions within the file,
    so if the file must be truncated, we whack it back to the beginning of the
    current session. If time permits, I'll add something more intelligent
    later on.

Arguments:

    FileHandle - File handle.

    FileSize - Current End of File.

    LastPosition - On input, specifies the starting position in the file from
    which the copy begins. On output, it is set to the new EOF

Return Value:

    New end of file.

--*/

{
//
// The following buffer size should never be more than 1/4 the size of the
// file.
//
#define BUFFER_SIZE ( 64 * 1024 )
    DWORD   bytesLeft;
    DWORD   endPosition = sizeof( UTF8_BOM ) - 1;
    DWORD   bufferSize;
    DWORD   bytesRead;
    DWORD   bytesWritten;
    DWORD   fileSizeHigh = 0;
    DWORD   readPosition;
    DWORD   writePosition;
    PVOID   dataBuffer;

    //
    // current session is already at beginning of file so bale now...
    //
    if ( OmpCurrentSessionOffset == sizeof( UTF8_BOM ) - 1) {
        return FileSize;
    }

    //
    // don't truncate the current session, i.e., always copy from the start of
    // the current session
    //
    if ( *LastPosition > OmpCurrentSessionOffset ) {
        *LastPosition = OmpCurrentSessionOffset;
    }

    if ( *LastPosition > FileSize ) {
        //
        // something's confused; the spot we're supposed to copy from is at or
        // past the current EOF. reset the entire file
        //
        goto error_exit;
    }

    dataBuffer = LocalAlloc( LMEM_FIXED, BUFFER_SIZE );
    if ( !dataBuffer ) {
        goto error_exit;
    }

    //
    // calc number of bytes to move
    //
    bytesLeft = FileSize - *LastPosition;
    endPosition = bytesLeft + sizeof( UTF8_BOM ) - 1;

    //
    // Point back to last position for reading.
    //
    readPosition = *LastPosition;
    writePosition = sizeof( UTF8_BOM ) - 1;

    while ( bytesLeft ) {
        if ( bytesLeft >= BUFFER_SIZE ) {
            bufferSize = BUFFER_SIZE;
        } else {
            bufferSize = bytesLeft;
        }
        bytesLeft -= bufferSize;

        SetFilePointer( FileHandle,
                        readPosition,
                        &fileSizeHigh,
                        FILE_BEGIN );

        if ( ReadFile( FileHandle,
                       dataBuffer,
                       bufferSize,
                       &bytesRead,
                       NULL ) )
        {
            SetFilePointer( FileHandle,
                            writePosition,
                            &fileSizeHigh,
                            FILE_BEGIN );
            WriteFile( FileHandle,
                       dataBuffer,
                       bytesRead,
                       &bytesWritten,
                       NULL );
        } else {
            endPosition = sizeof( UTF8_BOM ) - 1;
            break;
        }
        readPosition += bytesRead;
        writePosition += bytesWritten;
    }

    LocalFree( dataBuffer );

    //
    // for now, we only only one truncate by setting the current position to
    // the beginning of file.
    //
    OmpCurrentSessionOffset = sizeof( UTF8_BOM ) - 1;

error_exit:

    //
    // Force end of file to get set.
    //
    SetFilePointer( FileHandle,
                    endPosition,
                    &fileSizeHigh,
                    FILE_BEGIN );

    SetEndOfFile( FileHandle );

    *LastPosition = endPosition;

    return(endPosition);

} // OmpTruncateFile

VOID
OmpLoggerWorkThread(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )

/*++

Routine Description:

    work queue worker routine. actually does the write to the file.

Arguments:

    standard ClRtl thread args; we only care about WorkItem

Return Value:

    None

--*/

{
    DWORD   fileSize;
    DWORD   fileSizeHigh;
    DWORD   tsBytesWritten;
    DWORD   msgBytesWritten;

    POM_LOG_BUFFER_DESC bufDesc = (POM_LOG_BUFFER_DESC)(WorkItem->Context);

    fileSize = GetFileSize( OmpLogFileHandle, &fileSizeHigh );
    ASSERT( fileSizeHigh == 0 );        // We're only using DWORDs!

    if ( fileSize > OmpLogFileLimit ) {
        fileSize = OmpTruncateFile( OmpLogFileHandle, fileSize, &OmpLogFileLoWater );
    }

    SetFilePointer( OmpLogFileHandle,
                    fileSize,
                    &fileSizeHigh,
                    FILE_BEGIN );

    WriteFile(OmpLogFileHandle,
              bufDesc->TimeBuffer,
              bufDesc->TimeBytes,
              &tsBytesWritten,
              NULL);

    WriteFile(OmpLogFileHandle,
              bufDesc->MsgBuffer,
              bufDesc->MsgBytes,
              &msgBytesWritten,
              NULL);

    //
    // if we haven't set the lo water mark, wait until the file size has
    // crossed the halfway mark and set it to the beginning of the line we
    // just wrote.
    //
    if ( OmpLogFileLoWater == 0 && (fileSize > (OmpLogFileLimit / 2)) ) {
        OmpLogFileLoWater = fileSize;

        ASSERT( OmpLogFileLoWater >= OmpCurrentSessionOffset );
    }

} // OmpLoggerWorkThread

VOID
OmpLogPrint(
    LPWSTR  FormatString,
    ...
    )

/*++

Routine Description:

    Prints a message to the object config log file.

Arguments:

    FormatString - The initial message string to print.

    Any FormatMessage-compatible arguments to be inserted in the message
    before it is logged.

 Return Value:

     None.

--*/

{
    PWCHAR  unicodeOutput = NULL;
    PCHAR   timestampBuffer;
    DWORD   timestampBytes;
    PCHAR   utf8Buffer;
    DWORD   utf8Bytes;
    PWCHAR  unicodeBuffer;
    DWORD   unicodeBytes;
    DWORD   status = ERROR_SUCCESS;

    SYSTEMTIME  Time;
    ULONG_PTR   ArgArray[9];
    va_list     ArgList;

    //
    // init the variable arg list
    //
    va_start(ArgList, FormatString);

    if ( !OmpLogToFile ) {
        va_end(ArgList);
        return;
    }

    GetSystemTime(&Time);

    ArgArray[0] = OmpProcessId;
    ArgArray[1] = GetCurrentThreadId();
    ArgArray[2] = Time.wYear;
    ArgArray[3] = Time.wMonth;
    ArgArray[4] = Time.wDay;
    ArgArray[5] = Time.wHour;
    ArgArray[6] = Time.wMinute;
    ArgArray[7] = Time.wSecond;
    ArgArray[8] = Time.wMilliseconds;

    //
    // we can get away with formatting it as ANSI since our data is all numbers
    //
    timestampBytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING |
                                    FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                    FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    "%1!08lx!.%2!08lx!::%3!02d!/%4!02d!/%5!02d!-%6!02d!:%7!02d!:%8!02d!.%9!03d! ",
                                    0,
                                    0,
                                    (LPSTR)&timestampBuffer,
                                    50,
                                    (va_list*)ArgArray);

    if ( timestampBytes == 0 ) {
        va_end(ArgList);
//        WmiTrace("Prefix format failed, %d: %!ARSTR!", GetLastError(), FormatString);
        return;
    }

    //
    // format the message in unicode
    //
    try {
        unicodeBytes = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                      | FORMAT_MESSAGE_FROM_STRING,
                                      FormatString,
                                      0,
                                      0,
                                      (LPWSTR)&unicodeOutput,
                                      512,
                                      &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        unicodeBytes = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                      | FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      L"LOGERROR(exception): Could not print message: %1!ws!",
                                      0,
                                      0,
                                      (LPWSTR)&unicodeOutput,
                                      512,
                                      (va_list *) &FormatString );
    }
    va_end(ArgList);

    if (unicodeBytes != 0) {
        PCLRTL_WORK_ITEM workQItem;

        //
        // convert the output to UTF-8; first get the size to see if it will
        // fit in our stack buffer.
        //
        utf8Bytes = WideCharToMultiByte(CP_UTF8,
                                        0,                     // dwFlags
                                        unicodeOutput,
                                        unicodeBytes,
                                        NULL,
                                        0,
                                        NULL,                  // lpDefaultChar
                                        NULL);                 // lpUsedDefaultChar

        utf8Buffer = LocalAlloc( LMEM_FIXED, utf8Bytes );
        if ( utf8Buffer == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        utf8Bytes = WideCharToMultiByte(CP_UTF8,
                                        0,                     // dwFlags
                                        unicodeOutput,
                                        unicodeBytes,
                                        utf8Buffer,
                                        utf8Bytes,
                                        NULL,                  // lpDefaultChar
                                        NULL);                 // lpUsedDefaultChar

        workQItem = (PCLRTL_WORK_ITEM)LocalAlloc(LMEM_FIXED,
                                                 sizeof( CLRTL_WORK_ITEM ) + sizeof( OM_LOG_BUFFER_DESC ));

        if ( workQItem != NULL ) {
            POM_LOG_BUFFER_DESC bufDesc = (POM_LOG_BUFFER_DESC)(workQItem + 1);

            bufDesc->TimeBytes = timestampBytes;
            bufDesc->TimeBuffer = timestampBuffer;
            bufDesc->MsgBytes = utf8Bytes;
            bufDesc->MsgBuffer = utf8Buffer;

            ClRtlInitializeWorkItem( workQItem, OmpLoggerWorkThread, bufDesc );
            status = ClRtlPostItemWorkQueue( OmpLoggerWorkQueue, workQItem, 0, 0 );

        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
//        WmiTrace("%!level! %!ARSTR!", *(UCHAR*)&LogLevel, AnsiString.Buffer + timestampBytes);
    } else {
//        WmiTrace("Format returned 0 bytes: %!ARSTR!", FormatString);
        status = GetLastError();
    }

error_exit:
    if ( unicodeOutput != NULL ) {
        LocalFree( unicodeOutput );
    }

    return;

} // OmpLogPrint


//
// exported (within OM) functions
//

VOID
OmpOpenObjectLog(
    VOID
    )

/*++

Routine Description:

    Use the clusterlog environment variable to open another file that contains
    object mgr name to ID mapping info. If the routine fails, the failure is
    logged in the cluster log but no logging will be done to the object log
    file.

    NOTE: access to the file is synchronized since this routine is assumed to
    be called only once by OmInit.  Arguments:

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR   logFileBuffer[MAX_PATH];
    LPWSTR  logFileName = NULL;
    WCHAR   objectLogExtension[] = L".oml";
    DWORD   status = ERROR_SUCCESS;
    DWORD   defaultLogSize = 1;           // in MB
    DWORD   envLength;
    DWORD   logFileNameChars;
    WCHAR   logFileSize[MAX_NUMBER_LENGTH];
    DWORD   logSize;
    LPWSTR  lpszBakFileName = NULL;
    DWORD   fileSizeHigh = 0;
    DWORD   fileSizeLow;
    DWORD   bytesWritten;
    PWCHAR  dot;

    UNICODE_STRING  logFileString;

    SECURITY_ATTRIBUTES logFileSecurityAttr;

    PSECURITY_DESCRIPTOR    logFileSecurityDesc;

    //
    // see if logging has been specified; get a buffer big enough that will
    // hold the object log name. If the supplied buffer to
    // GetEnvironmentVariable is too small, it will return a value that
    // includes the space for the trailing null, i.e., there is no need to add
    // one.
    //
    logFileNameChars = GetEnvironmentVariable(L"ClusterLog",
                                              logFileBuffer,
                                              RTL_NUMBER_OF( logFileBuffer ));

    if ( logFileNameChars > ( RTL_NUMBER_OF(logFileBuffer) + RTL_NUMBER_OF(objectLogExtension)) ) {
        //
        // allocate a larger buffer since our static one wasn't big enough
        //
        logFileName = LocalAlloc( LMEM_FIXED,
                                  (logFileNameChars + RTL_NUMBER_OF(objectLogExtension)) * sizeof( WCHAR ) );

        if ( logFileName == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[OM] Unable to get memory for Object log filename buffer\n");
            return;
        }

        logFileNameChars = GetEnvironmentVariable(L"ClusterLog",
                                                  logFileName,
                                                  logFileNameChars);
        if ( logFileNameChars == 0 ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[OM] Unable to read ClusterLog environment variable\n");

            goto error_exit;
        }
    } else if ( logFileNameChars != 0 ) {
        logFileName = logFileBuffer;
    }

    //
    // remove any trailing white space. go to the end of the string and scan
    // backwards; stop when we find the first non-white space char or we hit
    // the beginning of the buffer.
    //
    if ( logFileName != NULL ) {
        PWCHAR  p = logFileName + logFileNameChars - 1;

        while ( iswspace( *p )) {
            *p = UNICODE_NULL;

            if ( p == logFileName ) {
                break;
            }

            --p;
        }

        //
        // make sure something useful is left
        //
        if ( wcslen( logFileName ) == 0 ) {
            if ( logFileName != logFileBuffer ) {
                LocalFree( logFileName );
            }

            logFileName = NULL;
        }
    }

    if ( logFileName == NULL ) {
        //
        // logging is turned off or we can't determine where to put the file.
        //
        goto error_exit;
    }

    //
    // Try to get a limit on the log file size.  This number is the number of
    // MB.
    //
    envLength = GetEnvironmentVariable(L"ClusterLogSize",
                                       logFileSize,
                                       RTL_NUMBER_OF( logFileSize ));

    if ( envLength != 0 && envLength < MAX_NUMBER_LENGTH ) {
        RtlInitUnicodeString( &logFileString, logFileSize );
        status = RtlUnicodeStringToInteger( &logFileString,
                                            10,
                                            &logSize );
        if ( NT_SUCCESS( status ) ) {
            OmpLogFileLimit = logSize;
        }
    } else {
        OmpLogFileLimit = defaultLogSize;
    }

    status = ERROR_SUCCESS;

    if ( OmpLogFileLimit == 0 ) {
        goto error_exit;
    }

    //
    // make the file size no bigger than one-eighth the size of the normal log
    // file but no less than 256KB
    //
    if ( OmpLogFileLimit > MAX_FILE_SIZE ) {
        OmpLogFileLimit = MAX_FILE_SIZE;
    }
    OmpLogFileLimit = ( OmpLogFileLimit * ( 1024 * 1024 )) / 8;
    if ( OmpLogFileLimit < ( 256 * 1024 )) {
        OmpLogFileLimit = 256 * 1024;
    }

    //
    // replace the extension with the object log extension; scanning backwards
    // from the end of the string, find either the first occurance of a slash
    // (fwd or back) or a dot or the front of the string.
    //
    dot = logFileName + logFileNameChars - 1;
    while ( dot != logFileName && *dot != L'.' && *dot != L'/' && *dot != L'\\' ) {
        --dot;
    }

    if ( dot == logFileName ) {
        //
        // no dots, no slashes; append extension to end
        //
        wcscat( logFileName + logFileNameChars, objectLogExtension );
    }
    else if ( *dot == L'/' || *dot == L'\\' ) {
        //
        // found a slash before a dot; append extension to end
        //
        wcscat( logFileName + logFileNameChars, objectLogExtension );
    }
    else if ( *dot == L'.' ) {
        //
        // found a dot before a slash; make sure that the extension isn't
        // already in use; if so don't log.
        //
        if ( ClRtlStrICmp( dot, objectLogExtension ) != 0 ) {
            wcscpy( dot, objectLogExtension );
        } else {
            goto error_exit;
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[OM] Couldn't determine where to append object log extension. Object logging turned off.\n");
        goto error_exit;
    }

    //
    // create a SD giving only local admins and localsystem full access. DACL
    // is set to protected (P) meaning it is not affected by inheritable ACEs
    // in the parent (cluster directory) object.
    //
    if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
              L"D:P(A;;FA;;;BA)(A;;FA;;;SY)", 
              SDDL_REVISION_1, 
              &logFileSecurityDesc, 
              NULL
              )
       )
    {
        logFileSecurityDesc = NULL;
    }

    logFileSecurityAttr.nLength = sizeof( logFileSecurityAttr );
    logFileSecurityAttr.lpSecurityDescriptor = logFileSecurityDesc;
    logFileSecurityAttr.bInheritHandle = FALSE;

    OmpLogFileHandle = CreateFile(logFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  &logFileSecurityAttr,
                                  OPEN_ALWAYS,
                                  0,
                                  NULL );

    if ( OmpLogFileHandle == INVALID_HANDLE_VALUE ) {
        status = GetLastError();

        ClRtlLogPrint(LOG_UNUSUAL,
                      "[OM] Open of object log file failed. Error %1!u!\n",
                      status);
        goto error_exit;
    } else {

        //
        // write UTF-8 header to beginning of file and get the offset of the
        // EOF; we never want to reset the start of the file after this point.
        //
        WriteFile( OmpLogFileHandle, UTF8_BOM, sizeof( UTF8_BOM ) - 1, &bytesWritten, NULL );

        OmpCurrentSessionOffset = SetFilePointer( OmpLogFileHandle, 0, NULL, FILE_END );
        if ( OmpCurrentSessionOffset == INVALID_SET_FILE_POINTER ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[OM] Unable to get object log end of file position. error %1!u!.\n",
                          GetLastError());

            CloseHandle( OmpLogFileHandle );
            goto error_exit;
        }

        OmpLogToFile = TRUE;
        OmpProcessId = GetCurrentProcessId();

        //
        // determine the initial low water mark. We have 3 cases
        // we need to handle:
        // 1) log size is less than 1/2 limit
        // 2) log size is within limit but more than 1/2 limit
        // 3) log size is greater than limit
        //
        // case 1 requires nothing special; the low water mark will be updated
        // on the next log write.
        //
        // for case 2, we need to find the beginning of a line near 1/2 the
        // current limit. for case 3, the place to start looking is current
        // log size - 1/2 limit. In this case, the log will be truncated
        // before the first write occurs, so we need to take the last 1/2
        // limit bytes and copy them down to the front.
        //

        //
        // For now, set the low water mark to be the current offset. When it
        // is time to wrap, we'll lose everything but the current session.
        //
        // the problem is that we're dealing with UTF8 and we can't just jump
        // in the middle of the file and start looking around (we might hit
        // the 2nd byte of a DBCS sequence). For now, we'll leave
        // OmpLogFileLoWater set to zero. It will get updated when the 1/2 way
        // threshold is crossed.
        //
        OmpLogFileLoWater = OmpCurrentSessionOffset;
#if 0

        fileSizeLow = GetFileSize( OmpLogFileHandle, &fileSizeHigh );
        if ( fileSizeLow < ( OmpLogFileLimit / 2 )) {
            //
            // case 1: leave low water at zero; it will be updated with next
            // log write
            //
            ;
        } else {
#define LOGBUF_SIZE 1024                        
            CHAR    buffer[LOGBUF_SIZE];
            LONG    currentPosition;
            DWORD   bytesRead;

            if ( fileSizeLow < OmpLogFileLimit ) {
                //
                // case 2; start looking at the 1/2 the current limit to find
                // the starting position
                //
                currentPosition = OmpLogFileLimit / 2;
            } else {
                //
                // case 3: start at current size minus 1/2 limit to find our
                // starting position.
                //
                currentPosition  = fileSizeLow - ( OmpLogFileLimit / 2 );
            }

            //
            // backup from the initial file position, read in a block and look
            // for the start of a session. When we find one, backup to the
            // beginning of that line. Use that as the initial starting
            // position when we finally truncate the file.
            //
            OmpLogFileLoWater = 0;
            currentPosition -= LOGBUF_SIZE;

            SetFilePointer(OmpLogFileHandle,
                           currentPosition,
                           &fileSizeHigh,
                           FILE_BEGIN);

            do {

                if ( ReadFile(OmpLogFileHandle,
                              buffer,
                              LOGBUF_SIZE - 1,
                              &bytesRead,
                              NULL ) )                                                   
                    {
                        PCHAR p = buffer;
                        PCHAR newp;

                        buffer[ bytesRead ] = NULL;
                        while ( *p != 'S' && bytesRead-- != 0 ) {
                            newp = CharNextExA( CP_UTF8, p, 0 );
                            if ( newp == p ) {
                                break;
                            }
                            p = newp;
                        }

                        if ( p != newp ) {
                            if ( strchr( p, "START" )) {
                                //
                                // set pointer to beginning of line
                                //
                                p = currentLine;
                                break;
                            }
                        } else {
                            //
                            // not found in this block; read in the next one
                            //

                        }
                    }
            } while ( TRUE );

            if ( *p == '\n' ) {
                OmpLogFileLoWater = (DWORD)(currentPosition + ( p - buffer + 1 ));
            }

            if ( OmpLogFileLoWater == 0 ) {
                //
                // couldn't find any reasonable data. just set it to
                // initial current position.
                //
                OmpLogFileLoWater = currentPosition + LOGBUF_SIZE;
            }
        }
#endif
    }

    LocalFree( logFileSecurityDesc );

    //
    // finally, create the threadq that will handle the IO to the file
    //
    OmpLoggerWorkQueue = ClRtlCreateWorkQueue( 1, THREAD_PRIORITY_BELOW_NORMAL );
    if ( OmpLoggerWorkQueue == NULL ) {
        CloseHandle( OmpLogFileHandle );

        ClRtlLogPrint(LOG_UNUSUAL,
                      "[OM] Unable to logger work queue. error %1!u!.\n",
                      GetLastError());
    }

error_exit:
    if ( logFileName != logFileBuffer && logFileName != NULL ) {
        LocalFree( logFileName );
    }

} // OmpOpenObjectLog

VOID
OmpLogStartRecord(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    OSVERSIONINFOEXW    version;
    BOOL        success;
    PWCHAR      suiteAbbrev;
    SYSTEMTIME  localTime;

    GetLocalTime( &localTime );

    version.dwOSVersionInfoSize = sizeof(version);
    success = GetVersionExW((POSVERSIONINFOW)&version);

    if ( success ) {
        //
        // Log the System version number
        //
        if ( version.wSuiteMask & VER_SUITE_DATACENTER ) {
            suiteAbbrev = L"DTC";
        } else if ( version.wSuiteMask & VER_SUITE_ENTERPRISE ) {
            suiteAbbrev = L"ADS";
        } else if ( version.wSuiteMask & VER_SUITE_EMBEDDEDNT ) {
            suiteAbbrev  = L"EMB";
        } else if ( version.wProductType & VER_NT_WORKSTATION ) {
            suiteAbbrev = L"WS";
        } else if ( version.wProductType & VER_NT_DOMAIN_CONTROLLER ) {
            suiteAbbrev = L"DC";
        } else if ( version.wProductType & VER_NT_SERVER ) {
            suiteAbbrev = L"SRV";  // otherwise - some non-descript Server
        } else {
            suiteAbbrev = L"";
        }

        OmpLogPrint(L"START    %1!02d!/%2!02d!/%3!02d!-%4!02d!:%5!02d!:%6!02d!.%7!03d! %8!u! %9!u! "
                    L"%10!u! %11!u! %12!u! %13!u! \"%14!ws!\" "
                    L"%15!u! %16!u! %17!04X! (%18!ws!) %19!u!\n",
                    localTime.wYear,
                    localTime.wMonth,
                    localTime.wDay,
                    localTime.wHour,
                    localTime.wMinute,
                    localTime.wSecond,
                    localTime.wMilliseconds,
                    CLUSTER_GET_MAJOR_VERSION( CsMyHighestVersion ),
                    CLUSTER_GET_MINOR_VERSION( CsMyHighestVersion ),
                    version.dwMajorVersion,         // param 10
                    version.dwMinorVersion,
                    version.dwBuildNumber,
                    version.dwPlatformId,
                    version.szCSDVersion,
                    version.wServicePackMajor,      // param 15
                    version.wServicePackMinor,
                    version.wSuiteMask,
                    suiteAbbrev,
                    version.wProductType);
    }

} // OmpLogStartRecord

VOID
OmpLogStopRecord(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    OmpLogPrint( L"STOP\n" );

} // OmpLogStopRecord


/* end omlog.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\vss\cvssclusterp.h ===
#pragma once

//++
//
// Copyright (c) 2001 Microsoft Corporation
//
// FACILITY:
//
//      Cluster Service
//
// MODULE DESCRIPTION:
//
//      Private header for Vss support within cluster service.
//
// ENVIRONMENT:
//
//      User mode NT Service.
//
// AUTHOR:
//
//      Conor Morrison
//
// CREATION DATE:
//
//      18-Apr-2001
//
// Revision History:
//
// X-1	CM		Conor Morrison        				18-Apr-2001
//      Initial version.
//--
#include "CVssCluster.h"

#define LOG_CURRENT_MODULE LOG_MODULE_VSSCLUS

// Global data for our instance of the class and boolean to say if we
// subscribed or not.  This will be used in cluster service.
//
PCVssWriterCluster g_pCVssWriterCluster = NULL;
bool g_bCVssWriterClusterSubscribed = FALSE;

// Our VSS_ID a.k.a GUID

// {41E12264-35D8-479b-8E5C-9B23D1DAD37E}
const VSS_ID g_VssIdCluster = 
    { 0x41e12264, 0x35d8, 0x479b, { 0x8e, 0x5c, 0x9b, 0x23, 0xd1, 0xda, 0xd3, 0x7e } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\om\omp.h ===
#ifndef _OMP_H
#define _OMP_H
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    omp.h

Abstract:

    Private data structures and procedure prototypes for
    the Object Manager subcomponent of the NT Cluster
    Service

Author:

    John Vert (jvert) 16-Feb-1996

Revision History:

--*/
#define QFS_DO_NOT_UNMAP_WIN32
#include "service.h"
#include "sddl.h"

#define LOG_CURRENT_MODULE LOG_MODULE_OM


#define ENUM_GROW_SIZE    5
//
// Data structures for the ObjectTypes
//
extern POM_OBJECT_TYPE OmpObjectTypeTable[ObjectTypeMax];
extern CRITICAL_SECTION OmpObjectTypeLock;

//
// Macros
//


//
// Find the object type for an object
//

#define OmpObjectType(pObject) (((POM_HEADER)OmpObjectToHeader(pObject))->ObjectType)

//
// Dereference object header
//
#if OM_TRACE_OBJREF
DWORD
OmpDereferenceHeader(
    IN POM_HEADER Header
    );

#else
#define OmpDereferenceHeader(pOmHeader) (InterlockedDecrement(&(pOmHeader)->RefCount) == 0)
#endif

//
// Search object list.
//
POM_HEADER
OmpFindIdInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Id
    );

POM_HEADER
OmpFindNameInList(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Name
    );


POM_NOTIFY_RECORD
OmpFindNotifyCbInList(
    IN PLIST_ENTRY                      ListHead,
    IN OM_OBJECT_NOTIFYCB       lpfnObjNotifyCb
    );

//
// Enumerate object list.
//
typedef BOOL (*OMP_ENUM_LIST_ROUTINE)(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

VOID
OmpEnumerateList(
    IN PLIST_ENTRY ListHead,
    IN OMP_ENUM_LIST_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );

DWORD OmpGetCbList(
    IN PVOID                pObject,
    OUT POM_NOTIFY_RECORD   *ppNotifyRecList,
    OUT LPDWORD             pdwCount
    );

//
// object logging routines
//

VOID
OmpOpenObjectLog(
    VOID
    );

VOID
OmpLogPrint(
    LPWSTR  FormatString,
    ...
    );

VOID
OmpLogStartRecord(
    VOID
    );

VOID
OmpLogStopRecord(
    VOID
    );

#endif //_OMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterapi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterApi.cpp
//
//  Description:
//      Implementation of CClusterApi class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterApi.h"

#include "ClusterApi.tmh"

//****************************************************************************
//
//  CClusterApi
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterApi::GetObjectProperties(
//      const SPropMapEntryArray *   pArrayIn,
//      CClusPropList &             rPropListIn,
//      CWbemClassObject &          rInstOut,
//      BOOL                        fPrivateIn
//      )
//
//  Description:
//      Get object property from Property list, and save to WMI instance
//
//  Arguments:
//      pArrayIn        -- Array of property names whose value will be retrieve
//      rPropListIn     -- Reference to cluster object's proplist
//      rInstOut        -- Reference to WMI instance
//      fPrivateIn      -- TRUE = properties are private
//
//  Return Values:
//      none
//
//--
//////////////////////////////////////////////////////////////////////////////
void CClusterApi::GetObjectProperties(
    const SPropMapEntryArray *  pArrayIn,
    CClusPropList &             rPropListIn,
    CWbemClassObject &          rInstOut,
    BOOL                        fPrivateIn
    )
{
    DWORD   dwError;
    LPCWSTR pwszPropName;
    LPCWSTR pwszMofName;
    WCHAR   wsz[ MAX_PATH ];

    dwError = rPropListIn.ScMoveToFirstProperty();
    while ( dwError == ERROR_SUCCESS )
    {
        pwszPropName = NULL;
        pwszMofName = NULL;

        pwszPropName = rPropListIn.PszCurrentPropertyName();
        pwszMofName = pwszPropName;
        if ( pArrayIn )
        {
            pwszMofName = pArrayIn->PwszLookup( pwszPropName );
        }
        else if( fPrivateIn )
        {
            //
            // handle dynamic generate private property
            //
            pwszMofName = PwszSpaceReplace( wsz, pwszMofName, L'_' );
        }

        if ( pwszMofName != NULL )
        {
            try
            {
                switch ( rPropListIn.CpfCurrentValueFormat() )
                {
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pDwordValue->dw,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_DWORD && FORMAT_LONG
                
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    case CLUSPROP_FORMAT_EXPANDED_SZ:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pStringValue->sz,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_SZ && FORMAT_EXPAND_SZ && FORMAT_EXPANDED_SZ

                    case CLUSPROP_FORMAT_BINARY:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pBinaryValue->cbLength,
                            rPropListIn.CbhCurrentValue().pBinaryValue->rgb,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_BINARY

                    case CLUSPROP_FORMAT_MULTI_SZ:
                    {
                        rInstOut.SetProperty(
                            rPropListIn.CbhCurrentValue().pMultiSzValue->cbLength,
                            rPropListIn.CbhCurrentValue().pMultiSzValue->sz,
                            pwszMofName
                            );
                        break;
                    } // case: FORMAT_MULTI_SZ

                    default:
                    {   
                        throw CProvException(
                            static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
                    }

                } // switch : property type
            } // try
            catch ( ... )
            {
            }
        } // if: MOF name found
        dwError = rPropListIn.ScMoveToNextProperty();
    } // while: proplist not empty
    
} //*** CClusterApi::GetObjectProperties()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusterApi::SetObjectProperties(
//      const SPropMapEntryArray *  pArrayIn,
//      CClusPropList &             rPropListInout,
//      CClusPropList &             rOldPropListIn,
//      CWbemClassObject &          rInstIn,
//      BOOL                        fPrivateIn
//      )
//
//  Description:
//      set object property from Property list, and save to WMI instance
//
//  Arguments:
//      pArrayIn        -- Array of property names those value will be retrieve
//      rPropListInout  -- Reference to cluster object's proplist
//      rOldPropListIn  -- Reference to proplist with original value
//      rInstIn         -- Reference to WMI instance
//      fPrivateIn      -- TRUE = properties are private
//
//  Return Values:
//      none
//
//--
//////////////////////////////////////////////////////////////////////////////
void CClusterApi::SetObjectProperties(
    const SPropMapEntryArray *  pArrayIn,
    CClusPropList &             rPropListInout,
    CClusPropList &             rOldPropListIn,
    CWbemClassObject &          rInstIn,
    BOOL                        fPrivateIn
    )
{
    DWORD   dwError = 0;
    LPCWSTR pwszPropName = NULL;
    LPCWSTR pwszMofName = NULL;
    WCHAR   wsz[ MAX_PATH ];

    dwError = rOldPropListIn.ScMoveToFirstProperty();
    while ( ERROR_SUCCESS == dwError )
    {
        pwszPropName = NULL;
        pwszMofName = NULL;

        pwszPropName = rOldPropListIn.PszCurrentPropertyName();
        pwszMofName = pwszPropName;

        if ( pArrayIn )
        {
            pwszMofName = pArrayIn->PwszLookup( pwszPropName );
        }
        else if ( fPrivateIn )
        {
            //
            // handle dynamic generate private property
            //
            pwszMofName = PwszSpaceReplace( wsz, pwszMofName, L'_' );
        }

        if ( pwszMofName != NULL )
        {
            try {
                switch ( rOldPropListIn.CpfCurrentValueFormat() )
                {
                    case CLUSPROP_FORMAT_DWORD:
                    {
                        {
                            DWORD dwNewValue = 0;
                            // bugbug, need to handle NULL value for property
                            rInstIn.GetProperty( &dwNewValue, pwszMofName );

                            rPropListInout.ScAddProp(
                                pwszPropName,
                                dwNewValue,
                                rOldPropListIn.CbhCurrentValue().pDwordValue->dw
                                );
                        }
                        break;
                    } // case: FORMAT_DWORD

                    case CLUSPROP_FORMAT_LONG:
                    {
                        {
                            LONG lNewValue = 0;
                            // bugbug, need to handle NULL value for property
                            rInstIn.GetProperty( (DWORD *) &lNewValue, pwszMofName );

                            rPropListInout.ScAddProp(
                                pwszPropName,
                                lNewValue,
                                rOldPropListIn.CbhCurrentValue().pLongValue->l
                                );
                        }
                        break;
                    } // case: FORMAT_DWORD

                    case CLUSPROP_FORMAT_SZ:
                    {
                        {
                            _bstr_t bstrNewValue;
                            rInstIn.GetProperty( bstrNewValue, pwszMofName );
                            rPropListInout.ScAddProp( pwszPropName, bstrNewValue );
                        } 
                        break;
                    } // case: FORMAT_SZ

                    case CLUSPROP_FORMAT_EXPAND_SZ:
                    {
                        {
                            _bstr_t bstrNewValue;
                            rInstIn.GetProperty( bstrNewValue, pwszMofName );
                            rPropListInout.ScAddExpandSzProp( pwszPropName, bstrNewValue );
                        } 
                        break;
                    } // case: FORMAT_SZ

                    case CLUSPROP_FORMAT_MULTI_SZ:
                    {
                        
                        {
                            LPWSTR      pwsz = NULL;
                            DWORD       dwSize;

                            rInstIn.GetPropertyMultiSz(
                                &dwSize,
                                &pwsz,
                                pwszMofName
                                );
                            rPropListInout.ScAddMultiSzProp(
                                pwszPropName,
                                pwsz,
                                rOldPropListIn.CbhCurrentValue().pMultiSzValue->sz
                                );
                            delete [] pwsz;
                        }
                        break;
                    } // case: FORMAT_MULTI_SZ

                    case CLUSPROP_FORMAT_BINARY:
                    {
                        {
                            DWORD dwSize;
                            PBYTE pByte = NULL;

                            rInstIn.GetProperty(
                                &dwSize,
                                &pByte,
                                pwszMofName
                                );
                            rPropListInout.ScAddProp(
                                pwszPropName,
                                pByte,
                                dwSize,
                                rOldPropListIn.CbhCurrentValue().pBinaryValue->rgb,
                                rOldPropListIn.CbhCurrentValue().pBinaryValue->cbLength
                                );
                            delete [] pByte;
                        }
                        break;
                    } // case: FORMAT_BINARY

                    default:
                    {
                        TracePrint(("SetCommonProperties: unknown prop type %d", rOldPropListIn.CpfCurrentValueFormat() ));
                        throw CProvException( 
                            static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
                    }

                } // switch: on property type
            } catch (CProvException& eh) {
                if (eh.hrGetError() == WBEM_E_NOT_FOUND) {
                    TracePrint(("SetCommonProperties: Property %ws not found. Benign error. Continuing", pwszPropName));
                } else {
                    TracePrint(("SetCommonProperties: exception %x. PropName = %ws, MofName = %ws", 
                        eh.hrGetError(), pwszPropName, pwszMofName));
                    throw;
                }
            }
        }           
        dwError = rOldPropListIn.ScMoveToNextProperty();
    } // while: no error occurred

    return;

} //*** CClusterApi::SetObjectProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterapi.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterApi.h
//
//  Implementation File:
//      ClusterApi.cpp
//
//  Description:
//      Definition of the CClusterApi class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterApi;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusPropList;
class CWbemClassObject;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterApi
//
//  Description:
//      Wrap class for cluster Api
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterApi
{
public:

    static void GetObjectProperties(
        const SPropMapEntryArray *  pArrayIn,
        CClusPropList &             rPropListIn,
        CWbemClassObject &          rInstOut,
        BOOL                        fPrivateIn
        );

    static void SetObjectProperties(
        const SPropMapEntryArray *  rArrayIn,
        CClusPropList &             rPropListInout,
        CClusPropList &             rOldPropListIn,
        CWbemClassObject &          rInstIn,
        BOOL                        fPrivateIn
        );

/*  static void EnumClusterObject(
        DWORD               dwEnumTypeIn,
        IWbemClassObject *  pClassIn,
        IWbemObjectSink *   pHandlerIn,
        IWbemServices *     pServicesIn, 
        FPFILLWMI           pfnClusterToWmiIn
        );
*/

}; //*** class CClusterApi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\vss\cvsscluster.cpp ===
#define _MODULE_VERSION_STR "X-1.3"
#define _MODULE_STR "CVssCluster"
#define _AUTHOR_STR "Conor Morrison"

#pragma comment (compiler)
#pragma comment (exestr, _MODULE_STR _MODULE_VERSION_STR)
#pragma comment (user, _MODULE_STR _MODULE_VERSION_STR " Compiled on " __DATE__ " at " __TIME__ " by " _AUTHOR_STR)

//++
//
// Copyright (c) 2000 Microsoft Corporation
//
// FACILITY:
//
//      CVssCluster
//
// MODULE DESCRIPTION:
//
//      Implements cluster support for Vss (i.e. NT backup).
//
// ENVIRONMENT:
//
//      User mode as part of an NT service.  Adheres to the following state
//      transition diagram for CVssWriter:
//
//                   OnBackupComplete
// Backup Complete <----------------IDLE -------------->Create Writer Metadata
//        |                          ^|^                         |
//        +--------------------------+|+-------------------------+
//                                    |
//                                    |OnBackupPrepare
//                                    |
//                                    |         OnAbort
//                              PREPARE BACKUP ---------> to IDLE
//                                    |
//                                    |OnPrepareSnapshot
//                                    |
//                                    |           OnAbort
//                              PREPARE SNAPSHOT ---------> to IDLE
//                                    |
//                                    |OnFreeze
//                                    |
//                                    |      OnAbort
//                                  FREEZE  ---------> to IDLE
//                                    |
//                                    |OnThaw
//                                    |
//                                    |    OnAbort
//                                  THAW  ---------> to IDLE
//    
//
// AUTHOR:
//
//      Conor Morrison
//
// CREATION DATE:
//
//      18-Apr-2001
//
// Revision History:
//
// X-1	CM		Conor Morrison        				18-Apr-2001
//      Initial version to address bug #367566.
//   .1 Set restore method to custom and reboot required to false.
//      Check for component selected or bootable system state in
//      OnPrepareSnapshot and ignore if not.  Add cleanup to Abort and
//      Thaw.  Fix bug in RemoveDirectoryTree.
//   .2 Incorporate first review comments: change caption to be the component
//      name.  Set bRestoreMetadata to false.  Remove extraneous tracing.
//      Release the interface in the while loop.  Cleanup after a non-cleanly
//      terminated backup.  This is done in OnPrepareSnapshot.  Tolerate
//      error_file_not_found at various places.
//   .3 More review comments.  Reset g_bDoBackup in the prepare routine.
//      SetWriterFailure in more places - any time we veto we should set this.
//--

extern "C" {
#define QFS_DO_NOT_UNMAP_WIN32
#include "service.h"
//CMCM! Mask build breaks.
#define _LMERRLOG_
#define _LMHLOGDEFINED_
#define _LMAUDIT_
#include "lm.h"                 // for SHARE_INFO_502
}
#include "CVssClusterp.h"

// Up the warning level to 4 - we can survive...
//
#pragma warning( push, 4 )

//
// Globals
//
UNICODE_STRING		g_ucsBackupPathLocal, g_ucsClusdbBackupPathLocal;
bool                g_bDoBackup; // Assume we are not enabled until we find out otherwise.

//
// Forward declarations for static functions.
//
static HRESULT StringAllocate( PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes );
static void StringFree( PUNICODE_STRING pucsString );
static void StringAppendString( PUNICODE_STRING pucsTarget, PWCHAR pwszSource );
static void StringAppendString( PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource );
static HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars);
static HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars);
static HRESULT StringCreateFromExpandedString( PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars);
static HRESULT DoClusterDatabaseBackup( void );
static HRESULT ConstructSecurityAttributes( PSECURITY_ATTRIBUTES  psaSecurityAttributes,
                                            BOOL                  bIncludeBackupOperator );
static VOID CleanupSecurityAttributes( PSECURITY_ATTRIBUTES psaSecurityAttributes );
static HRESULT CreateTargetDirectory( OUT UNICODE_STRING* pucsTarget, IN BOOL fBootableSystemState );
static HRESULT CleanupTargetDirectory( LPCWSTR pwszTargetPath );
static HRESULT RemoveDirectoryTree (PUNICODE_STRING pucsDirectoryPath);

//
// Some useful macros.
//
#define LOGERROR( _hr, _func ) ClRtlLogPrint( LOG_CRITICAL, "VSS: Error: 0x%1!08lx! from: %2\n", (_hr), L#_func )

#ifdef DBG
#define LOGFUNCTIONENTRY( _name ) ClRtlLogPrint( LOG_NOISE, "VSS: Function: " #_name " Called.\n" )
#define LOGFUNCTIONEXIT( _name ) ClRtlLogPrint( LOG_NOISE, "VSS: Function: " #_name " Exiting.\n" )
#define LOGUNICODESTRING( _ustr ) ClRtlLogPrint( LOG_NOISE, "VSS: String %1!ws! == %2!ws!\n", L#_ustr, (_ustr).Buffer );
#define LOGSTRING( _str ) ClRtlLogPrint( LOG_NOISE, "VSS: String %1!ws! == %2!ws!\n", L#_str, _str );
#else
#define LOGFUNCTIONENTRY( _name ) 
#define LOGFUNCTIONEXIT( _name ) 
#define LOGUNICODESTRING( _ustr ) 
#define LOGSTRING( _str ) 
#endif

#define	GET_HR_FROM_BOOL(_bSucceed)	((_bSucceed)      ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define HandleInvalid(_Handle)      ((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))
#define GET_HR_FROM_HANDLE(_handle)	((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError( )))
#define GET_HR_FROM_POINTER(_ptr)	((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)

#define IS_VALID_PATH( _path ) ( ( ( pwszPathName[0] == DIR_SEP_CHAR )  && ( pwszPathName[1] == DIR_SEP_CHAR ) ) || \
                             ( isalpha( pwszPathName[0] ) && ( pwszPathName[1] == L':' ) && ( pwszPathName[2] == DIR_SEP_CHAR ) ) )

#define StringZero( _pucs ) ( (_pucs)->Buffer = NULL, (_pucs)->Length = 0, (_pucs)->MaximumLength = 0 )

//
// Defines that identify us as a product to VSS - these are the same as in the old shim
//
#define COMPONENT_NAME		L"Cluster Database"
#define APPLICATION_STRING	L"ClusterDatabase"
#define SHARE_NAME L"__NtBackup_cluster"

// Some borrowed defines from the shim stuff.
//
#ifndef DIR_SEP_STRING
#define DIR_SEP_STRING		L"\\"
#endif
#ifndef DIR_SEP_CHAR
#define DIR_SEP_CHAR		L'\\'
#endif

//
// Define some constants that are borrowed from the original shim.  These will
// be used to build the path to the directory in which the cluster files will
// be placed by the cluster backup.  TARGET_PATH gives this full directory.  In
// Identify we tell the backup app which directory we are using so it knows
// where to get the files from.
//
#define ROOT_REPAIR_DIR         L"%SystemRoot%\\Repair"
#define BACKUP_SUBDIR           L"\\Backup"
#define BOOTABLE_STATE_SUBDIR	L"\\BootableSystemState"

#define SERVICE_STATE_SUBDIR	L"\\ServiceState"

#define TARGET_PATH             ROOT_REPAIR_DIR BACKUP_SUBDIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

//++
// DESCRIPTION:                         CreateIfNotExistAndSetAttributes
//
//      Create the directory specified by pucsTarget if it does not
//      already exist and give it the security attributes supplied.
//
// PARAMETERS:
//      pucsTarget - string for the directory to create.  Full path, possibly
//                   with %var%
//      lpSecurityAttributes - Pointer to security attributes to apply to
//                             directories created.
//      dwExtraAttributes - Additional attributes to apply to the directory.
//
// PRE-CONDITIONS:
//      None
//
// POST-CONDITIONS:
//      Directory created (or it already existed).
//
// RETURN VALUE:
//      S_OK - All went OK, directory created and set with attributes and
//             security supplied.
//      Error status from creating directory or setting attributes.  Note that
//      ALREADY_EXISTS is not returned if the directory already exists.
//      However, if it a FILE of the same name as pucsTarget exists then this
//      error can be returned.
//--
static HRESULT CreateIfNotExistAndSetAttributes( UNICODE_STRING*           pucsTarget,
                                                 IN LPSECURITY_ATTRIBUTES  lpSecurityAttributes,
                                                 IN DWORD                  dwExtraAttributes)
{
    LOGFUNCTIONENTRY( CreateIfNotExistAndSetAttributes );

    HRESULT hr = S_OK;
    
    // Create the directory
    //
    LOGUNICODESTRING( *pucsTarget );
    GET_HR_FROM_BOOL( CreateDirectoryW (pucsTarget->Buffer, lpSecurityAttributes ) );
    ClRtlLogPrint( LOG_NOISE, "VSS: CreateIfNotExistAndSetAttributes: CreateDirectory returned: 0x%1!08lx!\n", hr );
    if ( hr == HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) ) {
        DWORD dwObjAttribs = GetFileAttributesW( pucsTarget->Buffer );
        if (( dwObjAttribs != 0xFFFFFFFF ) && ( dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY ))
            hr = S_OK;
    }
    // Note that we can fail with ALREADY_EXISTS if it is a file by the check above.
    //
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateDirectoryW );
        goto ErrorExit;
    }
    
    // Set the extra attributes
    //
    if ( dwExtraAttributes != 0 ) {
        GET_HR_FROM_BOOL( SetFileAttributesW (pucsTarget->Buffer, dwExtraAttributes ));
        if ( FAILED ( hr )) {
            LOGERROR( hr, SetFileAttributesW );
            goto ErrorExit;
        }
    }
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    LOGFUNCTIONEXIT( CreateIfNotExistAndSetAttributes );
    return hr;
}

//++
// DESCRIPTION:                         CreateTargetDirectory
//
//      Create a new target directory (hardcoded) and return it in
//      pucsTarget member variable if not NULL. It will create any
//      necessary.  Uses helper function that tolerates
//      ERROR_ALREADY_EXISTS.
//
// PARAMETERS:
//      pucsTarget - Address to receive unicode string giving path to
//                   directory.
//
// PRE-CONDITIONS:
//      pucsTarget must be all zeros.
//
// POST-CONDITIONS:
//      pucsTarget points to buffer containing dir string.  Memory was
//      allocated for this buffer.
//
// RETURN VALUE:
//      S_OK - all went well
//      Errors from creating directories or memory allocation failure.
//--
static HRESULT CreateTargetDirectory( OUT UNICODE_STRING* pucsTarget, IN BOOL fBootableSystemState )
{
    LOGFUNCTIONENTRY( CreateTargetDirectory );
    
    HRESULT		hr = NOERROR;
    SECURITY_ATTRIBUTES	saSecurityAttributes, *psaSecurityAttributes=&saSecurityAttributes;
    SECURITY_DESCRIPTOR	sdSecurityDescriptor;
    bool		bSecurityAttributesConstructed = false;

    const DWORD dwExtraAttributes = 
        FILE_ATTRIBUTE_ARCHIVE 
        | FILE_ATTRIBUTE_HIDDEN  
        | FILE_ATTRIBUTE_SYSTEM  
        | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    
    //
    // We really want a no access acl on this directory but because of various
    // problems with the EventLog and ConfigDir writers we will settle for
    // admin or backup operator access only. The only possible accessor is
    // Backup which is supposed to have the SE_BACKUP_NAME priv which will
    // effectively bypass the ACL. No one else needs to see this stuff.
    //
    saSecurityAttributes.nLength              = sizeof( saSecurityAttributes );
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = false;

    hr = ConstructSecurityAttributes( &saSecurityAttributes, false );
    if ( FAILED( hr )) {
        LOGERROR( hr, ConstructSecurityAttributes );
        goto ErrorExit;
    }
    bSecurityAttributesConstructed = true;

    // OK, now we have attributes we can do the directories.
    //
    // First expand the Root, checking that our input is NULL.
    //
    CL_ASSERT( pucsTarget->Buffer == NULL );
    hr = StringCreateFromExpandedString( pucsTarget, ROOT_REPAIR_DIR, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        goto ErrorExit;
    }

    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }
    
    StringAppendString( pucsTarget, BACKUP_SUBDIR );
    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }

    if ( fBootableSystemState ) {
        StringAppendString( pucsTarget, BOOTABLE_STATE_SUBDIR );
    } else
    { 
        StringAppendString( pucsTarget, SERVICE_STATE_SUBDIR );
    }

    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }

    StringAppendString( pucsTarget, DIR_SEP_STRING APPLICATION_STRING );
    hr = CreateIfNotExistAndSetAttributes( pucsTarget, psaSecurityAttributes, dwExtraAttributes );
    if ( FAILED ( hr )) {
        LOGERROR( hr, CreateIfNotExistAndSetAttributes );
        goto ErrorExit;
    }

    // At this point we have TARGET_PATH created.
    //    
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
    (void) CleanupTargetDirectory( pucsTarget->Buffer );
    
ret:
    // In all cases we don't need the security attributes any more.
    //
    if ( bSecurityAttributesConstructed )
        CleanupSecurityAttributes( &saSecurityAttributes );
    
    return hr ;
}

//
// There are only some valid statuses to pass to SetWriterFailure.  These are
// listed below.  For now we just return VSS_E_WRITEERROR_NONRETRYABLE. We
// could perhaps switch on the status and return something different depending
// on hr.
//      VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT The snapshot contains only a
//      subset of the volumes needed to correctly back up an application
//      component.
//      VSS_E_WRITERERROR_NONRETRYABLE The writer failed due to an error that
//      would likely occur if another snapshot is created.
//      VSS_E_WRITERERROR_OUTRESOURCES The writer failed due to a resource
//      allocation error.
//      VSS_E_WRITERERROR_RETRYABLE The writer failed due to an error that would
//      likely not occur if another snapshot is created.
//      VSS_E_WRITERERROR_TIMEOUT The writer could not complete the snapshot
//      creation process due to a time-out between the freeze and thaw states.

#if defined DBG
#define SETWRITERFAILURE( ) {               \
    HRESULT __hrTmp = SetWriterFailure( VSS_E_WRITERERROR_NONRETRYABLE );  \
    if ( FAILED( __hrTmp )) ClRtlLogPrint( LOG_CRITICAL, "VSS: Error from SetWriterFailure: %1!u!\n", (__hrTmp)); \
    CL_ASSERT( !FAILED( __hrTmp ));             \
}
#else
#define SETWRITERFAILURE( ) { \
    (void) SetWriterFailure( VSS_E_WRITERERROR_NONRETRYABLE );  \
}
#endif

#define NameIsDotOrDotDot(_ptszName)           \
    (( L'.'  == (_ptszName) [0])               \
     && ((L'\0' == (_ptszName) [1])            \
         || ((L'.'  == (_ptszName) [1])        \
             && (L'\0' == (_ptszName) [2]))))

//++
// DESCRIPTION:                         CVssWriterCluster::OnIdentify
//
//      Callback when a request for metadata comes in.  This routine
//      identifies this applications special needs to the backup
//      utility.
//
// PARAMETERS:
//      IVssCreateWriterMetadata - Interface for some methods we can call.
//
// PRE-CONDITIONS:
//      Called from Idle state
//
// POST-CONDITIONS:
//      Backup returns to idle state.
//
// RETURN VALUE:
//      true - continue with snapshot operation.
//      false - Veto the snapshot creation.
//--
bool STDMETHODCALLTYPE CVssWriterCluster::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
{
    LOGFUNCTIONENTRY( OnIdentify );

    HRESULT     hr = S_OK;
    bool        bRet = true;
 
    ClRtlLogPrint( LOG_NOISE, "VSS: OnIdentify.  CVssCluster.cpp version %1!hs! Add Component %2!hs!\n",
                   _MODULE_VERSION_STR, COMPONENT_NAME );

    // Add ourselves to the components.
    //
    hr = pMetadata->AddComponent (VSS_CT_FILEGROUP, // VSS_COMPONENT_TYPE enumeration value. 
                                  NULL,             // Pointer to a string containing the logical path of the DB or file group. 
                                  COMPONENT_NAME,   // Pointer to a string containing the name of the component. 
                                  COMPONENT_NAME,   // Pointer to a string containing the description of the component.
                                  NULL,             // Pointer to a bitmap of the icon representing the database (for UI)
                                  0,                // Number of bytes in bitmap.
                                  false,             // bRestoreMetadata - Boolean is true if there is writer metadata associated
                                                    // with the backup of the component and false if not.
                                  false,            // bNotifyOnBackupComplete 
                                  false);           // bSelectable - true if the component can be selectively backed up.
    if ( FAILED( hr )) {
        LOGERROR( hr, IVssCreateWriterMetadata::AddComponent );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }
    ClRtlLogPrint( LOG_NOISE, "VSS: OnIdentify.  Add Files To File Group target path: %1!ws!\n", TARGET_PATH );
    hr= pMetadata->AddFilesToFileGroup (NULL,
                                        COMPONENT_NAME,
                                        TARGET_PATH,
                                        L"*",
                                        true,
                                        NULL);
    if ( FAILED ( hr )) {
        LOGERROR( hr, IVssCreateWriterMetadata::AddFilesToFileGroup );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }
    
    // If we decide to go for copying the checkpoint file to the
    // CLUSDB for restore then we need to setup an alternate mapping.
    //
    //      IVssCreateWriterMetadata::AddAlternateLocationMapping
    //  [This is preliminary documentation and subject to change.] 
    //
    //  The AddAlternateLocationMapping method creates an alternate location mapping.
    //
    //  HRESULT AddAlternateLocationMapping(
    //    LPCWSTR wszPath,
    //    LPCWSTR wszFilespec,
    //    bool bRecursive,
    //    LPCWSTR wszDestination
    //  );


    // Now, set the restore method to custom.  This is because we need
    // special actions for restore.
    //
    hr = pMetadata->SetRestoreMethod( VSS_RME_CUSTOM,   // VSS_RESTOREMETHOD_ENUM Method,
                                      L"",              // LPCWSTR wszService,
                                      NULL,             // LPCWSTR wszUserProcedure,
                                      VSS_WRE_NEVER,    // VSS_WRITERRESTORE_ENUM wreWriterRestore,
                                      false             // bool bRebootRequired
                                      );
    // wszUserProcedure [out] String containing the URL of an HTML or
    // XML document describing to the user how the restore is to be
    // performed.
    if ( FAILED ( hr )) {
        LOGERROR( hr, IVssCreateWriterMetadata::SetRestoreMethod );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }

    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
    CL_ASSERT( bRet == false );
    SETWRITERFAILURE( );
ret:
    return bRet;
}

// callback for prepare backup event
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnPrepareBackup(IN IVssWriterComponents *pComponent)
{
    LOGFUNCTIONENTRY( OnPrepareBackup );
    bool bRet = true;
    UINT cComponents = 0;
    IVssComponent* pMyComponent = NULL;
    BSTR pwszName;
    
    g_bDoBackup = false;         // Assume false until the loop below or IsBootableSystemStateBackedUp tells us otherwise.

    HRESULT hr = pComponent->GetComponentCount( &cComponents );
    ClRtlLogPrint( LOG_NOISE, "VSS: GetComponentCount returned hr: 0x%1!08lx! cComponents: %2!u!\n", hr, cComponents );
    if ( FAILED( hr )) {
        LOGERROR( hr, GetComponentCount );
        bRet = false;
        goto ErrorExit;
    }
    
    // Now, loop over all the components and see if we are there.
    //
    for ( UINT iComponent = 0; !g_bDoBackup && iComponent < cComponents; ++iComponent ) {
        hr = pComponent->GetComponent( iComponent, &pMyComponent );
        if ( FAILED( hr )) {
            ClRtlLogPrint( LOG_CRITICAL, "VSS: Failed to get Component: %1!u! hr: 0x%2!08lx!\n", iComponent, hr );
            bRet = false;
            goto ErrorExit;
        }
        ClRtlLogPrint( LOG_CRITICAL, "VSS: Got Component: 0x%1!08lx!\n", pMyComponent );

        // Now check the name.
        //
        hr = pMyComponent->GetComponentName( &pwszName );
        if ( FAILED( hr )) {
            ClRtlLogPrint( LOG_CRITICAL, "VSS: Failed to get Component Name hr: 0x%1!08lx!\n", hr );
            bRet = false;
            pMyComponent->Release( );
            goto ErrorExit;
        }

        ClRtlLogPrint( LOG_CRITICAL, "VSS: Got component: %1!ws!\n", pwszName );

        if ( wcscmp ( pwszName, COMPONENT_NAME ) == 0 )
            g_bDoBackup = true;

        SysFreeString( pwszName );
        pMyComponent->Release( );
    }
        
    // OK, explicitly selected component count is 0 but we can be part
    // of a backup of bootable system state so check for that too.
    //
    if ( IsBootableSystemStateBackedUp( )) {
        ClRtlLogPrint( LOG_NOISE, "VSS: IsBootableSystemStateBackedUp returned true\n" );
        g_bDoBackup = true;
    }
    goto ret;

ErrorExit:
    CL_ASSERT( FAILED( hr ));
    CL_ASSERT( bRet == false );
    SETWRITERFAILURE( );
ret:
    LOGFUNCTIONEXIT( OnPrepareBackup );
    return bRet;
}

//++
// DESCRIPTION:                         CVssWriterCluster::OnPrepareSnapshot
//
//      Callback for prepare snapshot event.  Actually makes the call to backup
//      the cluster.  Uses the target path declared in Identify so that the
//      ntbackup will pickup our files for us.  Before doing anything the
//      directory is cleared out (if it exists) and the share deleted (if it
//      exists).
//
// PARAMETERS:
//      none
//
// PRE-CONDITIONS:
//      OnPrepareBackup was already called.
//
// POST-CONDITIONS: 
//      The cluster database is backed up and the data copied to another
//      location for backup to save.
//
// RETURN VALUE:
//      true - continue with snapshot operation.
//      false - Veto the snapshot creation.
//--
bool STDMETHODCALLTYPE CVssWriterCluster::OnPrepareSnapshot()
{
    NET_API_STATUS NetStatus = NERR_Success;
    HRESULT	hr = S_OK;
    bool    bRet = true;
    UNICODE_STRING ucsBackupDir;

    LOGFUNCTIONENTRY( OnPrepareSnapshot );
    if ( g_bDoBackup == false )
        goto ret;

    // Delete the share if it exists.  Tolerate errors but warns for anything
    // except NERR_NetNameNotFound.  Break if debug.
    //
    NetStatus = NetShareDel( NULL, SHARE_NAME, 0 );
    CL_ASSERT( NetStatus == NERR_Success || NetStatus == NERR_NetNameNotFound );
    if ( NetStatus != NERR_Success && NetStatus != NERR_NetNameNotFound ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: OnPrepareSnapshot: Tolerating error: %1!u! from NetShareDel\n", NetStatus );
        NetStatus = NERR_Success;
    }

    // Delete the directory if it exists.  This can only be the case if we
    // prematurely exited a previous backup.
    //
    // First expand the Root, checking that our input is NULL.
    //
    StringZero( &ucsBackupDir );
    hr = StringCreateFromExpandedString( &ucsBackupDir, ROOT_REPAIR_DIR, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }

    StringAppendString( &ucsBackupDir, BACKUP_SUBDIR );
    StringAppendString( &ucsBackupDir, BOOTABLE_STATE_SUBDIR );
    StringAppendString( &ucsBackupDir, DIR_SEP_STRING APPLICATION_STRING );

    ClRtlLogPrint( LOG_NOISE, "VSS: OnPrepareSnapshot: Cleaning up target directory: %1!ws!\n", ucsBackupDir.Buffer );
    hr = CleanupTargetDirectory( ucsBackupDir.Buffer );
    if ( FAILED( hr ) ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: Tolerating error 0x%1!08lx! from CleanupTargetDirectory.\n", hr );
        hr = S_OK;          // tolerate this failure.
    }
    StringFree( &ucsBackupDir );

    StringZero( &ucsBackupDir );
    hr = StringCreateFromExpandedString( &ucsBackupDir, ROOT_REPAIR_DIR, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }

    StringAppendString( &ucsBackupDir, BACKUP_SUBDIR );
    StringAppendString( &ucsBackupDir, SERVICE_STATE_SUBDIR );
    StringAppendString( &ucsBackupDir, DIR_SEP_STRING APPLICATION_STRING );

    ClRtlLogPrint( LOG_NOISE, "VSS: OnPrepareSnapshot: Cleaning up target directory: %1!ws!\n", ucsBackupDir.Buffer );
    hr = CleanupTargetDirectory( ucsBackupDir.Buffer );
    if ( FAILED( hr ) ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: Tolerating error 0x%1!08lx! from CleanupTargetDirectory.\n", hr );
        hr = S_OK;          // tolerate this failure.
    }
    
    StringFree( &ucsBackupDir );

    hr = DoClusterDatabaseBackup( );
    if ( FAILED( hr ) ) {
        LOGERROR( hr, DoClusterDatabaseBackup );
        SETWRITERFAILURE( );
        bRet = false;           // veto on failure
        goto ErrorExit;
    }
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
    CL_ASSERT( bRet == false );
    SETWRITERFAILURE( );
ret:
    LOGFUNCTIONEXIT( OnPrepareSnapshot );
    return bRet;
}

// callback for freeze event
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnFreeze()
{
    LOGFUNCTIONENTRY( OnFreeze );
    LOGFUNCTIONEXIT( OnFreeze );
    return true;
}

// callback for thaw event
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnThaw()
{
    LOGFUNCTIONENTRY( OnThaw );
    if ( g_bDoBackup == false )
        goto ret;

    if ( g_ucsBackupPathLocal.Buffer ) {

        ClRtlLogPrint( LOG_NOISE, "VSS: Cleaning up target directory: %1!ws!\n", g_ucsBackupPathLocal.Buffer );
        HRESULT hr = CleanupTargetDirectory( g_ucsBackupPathLocal.Buffer );
        if ( FAILED( hr ) ) {
            LOGERROR( hr, CVssWriterCluster::OnThaw );
            ClRtlLogPrint( LOG_CRITICAL, "VSS: 0x%1!08lx! from CleanupTargetDirectory. Mapping to S_OK and continuing\n", hr );
            hr = S_OK;          // tolerate this failure.
        }
    }

    if ( g_ucsClusdbBackupPathLocal.Buffer ) {

        ClRtlLogPrint( LOG_NOISE, "VSS: Cleaning up target directory: %1!ws!\n", g_ucsClusdbBackupPathLocal.Buffer );
        HRESULT hr = CleanupTargetDirectory( g_ucsClusdbBackupPathLocal.Buffer );
        if ( FAILED( hr ) ) {
            LOGERROR( hr, CVssWriterCluster::OnThaw );
            ClRtlLogPrint( LOG_CRITICAL, "VSS: 0x%1!08lx! from CleanupTargetDirectory. Mapping to S_OK and continuing\n", hr );
            hr = S_OK;          // tolerate this failure.
        }
    }

    // Free the buffer if non-NULL.
    //
    StringFree ( &g_ucsBackupPathLocal );
    StringFree ( &g_ucsClusdbBackupPathLocal );
   
    LOGFUNCTIONEXIT( OnThaw );
ret:
    return true;
}

// callback if current sequence is aborted
//
bool STDMETHODCALLTYPE CVssWriterCluster::OnAbort()
{
    LOGFUNCTIONENTRY( OnAbort );
    bool bRet = OnThaw( );
    LOGFUNCTIONEXIT( OnAbort );
    return bRet;
}

//++
// DESCRIPTION:                         DoClusterDatabaseBackup
//
//      Perform the backup of the cluster database.  This function wraps
//      FmBackupClusterDatabase which does the right thing to do the cluster
//      backup.  This function first creates a directory that will serve as the
//      destination for the backup.  Next it creates a network share to point
//      to this directory and starts the cluster backup.  After this is done it
//      cleans up.
//
// PARAMETERS:
//      none
//
// PRE-CONDITIONS:
//      . Called only from CVssWriterCluster::OnPrepareSnapshot.
//      . We must be the only call to backup in progress on this machine (the
//      share names will clash otherwise and clustering may not behave well
//      with multiple FmBackupClusterDatabase calls it the same time).
//
// POST-CONDITIONS:
//      Cluster database backed up to another location, ready for the backup tool to copy.
//
// RETURN VALUE:
//      S_OK  - all went well.
//      Error status from creating directories or net shares or from cluster backup.
//--
static HRESULT DoClusterDatabaseBackup( )
{
    LOGFUNCTIONENTRY( DoClusterDatabaseBackup );

    HRESULT             hr             = S_OK;
    bool                bNetShareAdded = false;
    SHARE_INFO_502      ShareInfo;
    UNICODE_STRING      ucsComputerName;
    UNICODE_STRING      ucsBackupPathNetwork;
    UNICODE_STRING      ucsCheckpointFile, ucsClusdbTargetFile;
    NET_API_STATUS      NetStatus;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;

    StringZero( &ucsComputerName );
    StringZero( &g_ucsBackupPathLocal );
    StringZero( &ucsBackupPathNetwork );
    StringZero( &g_ucsClusdbBackupPathLocal );
    StringZero( &ucsCheckpointFile );
    StringZero( &ucsClusdbTargetFile );

    // Create the directories and set the attributes and security and stuff.
    // Set g_ucsBackupPathLocal to the directory created.
    //
    hr = CreateTargetDirectory( &g_ucsBackupPathLocal, TRUE );
    if ( FAILED (hr )) {
        LOGERROR( hr, CreateTargetDirectory );
        goto ErrorExit;
    }

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes(1) returned 0x%1!08lx!  for path: %2!ws!\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif
    hr = StringAllocate (&ucsComputerName,
                         (MAX_COMPUTERNAME_LENGTH * sizeof (WCHAR)) + sizeof (UNICODE_NULL));
    
    if ( FAILED( hr )) {
        LOGERROR( hr, StringAllocate );
        goto ErrorExit;
    }        

    DWORD	dwNameLength = ucsComputerName.MaximumLength / sizeof (WCHAR);
    hr = GET_HR_FROM_BOOL( GetComputerNameW( ucsComputerName.Buffer, &dwNameLength ));
    if ( FAILED ( hr )) {
        LOGERROR( hr, GetComputerNameW );
        goto ErrorExit;
    }
    
    ucsComputerName.Length = (USHORT) (dwNameLength * sizeof (WCHAR));

    hr = StringAllocate (&ucsBackupPathNetwork,
                         (USHORT) (sizeof (L'\\')
                                   + sizeof (L'\\')
                                   + ucsComputerName.Length
                                   + sizeof (L'\\')
                                   + ( wcslen( SHARE_NAME ) * sizeof( WCHAR ) )
                                   + sizeof (UNICODE_NULL)));
    if ( FAILED ( hr )) {
        LOGERROR( hr, GetComputerNameW );
        goto ErrorExit;
    }

    ClRtlLogPrint( LOG_NOISE, "VSS: backup path network size: %1!u!\n", ucsBackupPathNetwork.Length );

    //
    // Should we uniquify the directory name at all here
    // to cater for the possiblity that we may be involved
    // in more than one snapshot at a time?
    //
    StringAppendString( &ucsBackupPathNetwork, L"\\\\" );
    StringAppendString( &ucsBackupPathNetwork, &ucsComputerName );
    StringAppendString( &ucsBackupPathNetwork, L"\\" );
    StringAppendString( &ucsBackupPathNetwork, SHARE_NAME );

    ClRtlLogPrint( LOG_NOISE, "VSS: backup path network: %1!ws!\n", ucsBackupPathNetwork.Buffer );

    ZeroMemory( &ShareInfo, sizeof( ShareInfo ));

    ShareInfo.shi502_netname     = SHARE_NAME;
    ShareInfo.shi502_type        = STYPE_DISKTREE;
    ShareInfo.shi502_permissions = ACCESS_READ | ACCESS_WRITE | ACCESS_CREATE;
    ShareInfo.shi502_max_uses    = 1;
    ShareInfo.shi502_path        = g_ucsBackupPathLocal.Buffer;

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes(2) returned 0x%1!08lx!  for path: %2!ws!\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif

    //
    // Make sure to try to delete the share first in case for some reason it exists.
    //
    NetStatus = NetShareDel( NULL, SHARE_NAME, 0 );
    ClRtlLogPrint( LOG_NOISE, "VSS: NetShareDel returned: %1!u!\n", NetStatus );
    if ( NetStatus == NERR_NetNameNotFound )
        NetStatus = NERR_Success;
    CL_ASSERT( NetStatus == NERR_Success );

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes(3) returned 0x%1!08lx!  for path: %2!ws!\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif

    ClRtlLogPrint( LOG_NOISE, "VSS: NetShareAdd: Adding share: %1!ws! with path: %2!ws!\n", SHARE_NAME, g_ucsBackupPathLocal.Buffer );

    NetStatus = NetShareAdd( NULL, 502, (LPBYTE)(&ShareInfo), NULL );
    ClRtlLogPrint( LOG_NOISE, "VSS: NetShareAdd completed: %1!u!\n", NetStatus );
    if ( NetStatus != NERR_Success ) {
        LOGERROR( NetStatus, NetShareAdd );
        if ( NetStatus == NERR_DuplicateShare ) {
            ClRtlLogPrint( LOG_NOISE, "VSS: Mapping NERR_DuplicateShare to success\n" );
            NetStatus = NERR_Success;
        } else {
            hr = HRESULT_FROM_WIN32( NetStatus );
            goto ErrorExit;
        }
    }
    bNetShareAdded = true;

#ifdef DBG
    {
        // Check that the directory does exist.
        //
        DWORD dwFileAttributes = GetFileAttributesW( g_ucsBackupPathLocal.Buffer );
        hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
        ClRtlLogPrint( LOG_NOISE, "VSS: GetFileAttributes returned 0x%1!08lx!  for path: %2!ws!\n", 
                       hr, g_ucsBackupPathLocal.Buffer );    
    }
#endif

    // If we are not logging to the quorum log then we don't do the backup.
    //
    if ( CsNoQuorumLogging || CsUserTurnedOffQuorumLogging ) {
        ClRtlLogPrint( LOG_NOISE, "VSS: Quorum logging is turned off.  Not attempting backup.\n" );
        //
        // CMCM!
        // We could opt to take a checkpoint and then setup alternate
        // path to ensure it is copied over CLUSDB on restore.
        //
        hr = S_OK;
    } else {
        ClRtlLogPrint( LOG_NOISE, "VSS: Calling FmBackupClusterDatabase with path: %1!ws!\n", ucsBackupPathNetwork.Buffer );

        DWORD dwStatus = FmBackupClusterDatabase( ucsBackupPathNetwork.Buffer );
        hr = HRESULT_FROM_WIN32( dwStatus );
        ClRtlLogPrint( LOG_NOISE, "VSS: FmBackupClusterDatabase completed. hr: 0x%1!08lx! \n", hr );
        if ( FAILED( hr ) ) {
            LOGERROR( hr, FmBackupClusterDatabase );
            goto ErrorExit;
        }

        //
        //  CAUTION: DO NOT CHANGE THE DROP LOCATION OF CLUSDB WITHOUT CONSULTING WITH NTBACKUP
        //  OWNERS. THIS LOCATION %SystemRoot%\Repair\Backup\ServiceState\ClusterDatabase is a
        //  MUTUALLY AGREED UPON LOCATION WHERE NTBACKUP.EXE WILL LOOK FOR CLUSDB.
        //
        //  Pick up the checkpoint file and copy it as CLUSDB to the service state subdir
        //
        hr = StringAllocate( &ucsCheckpointFile, 
                               ( USHORT ) ( ( lstrlen ( g_ucsBackupPathLocal.Buffer ) + 
                                                 lstrlen ( L"\\chk*.tmp" ) +
                                                 1 ) * sizeof ( WCHAR ) ) );
        if ( FAILED( hr )) {
            LOGERROR( hr, StringAllocate );
            goto ErrorExit;
        }

        StringAppendString( &ucsCheckpointFile, g_ucsBackupPathLocal.Buffer );
        StringAppendString( &ucsCheckpointFile, L"\\chk*.tmp" );

        hFind = FindFirstFile ( ucsCheckpointFile.Buffer, &FindData );

        StringFree ( &ucsCheckpointFile );

        if ( hFind == INVALID_HANDLE_VALUE ) {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            LOGERROR( hr, FindFirstFile );
            goto ErrorExit;
        }

        hr = StringAllocate( &ucsCheckpointFile, 
                             ( USHORT ) ( ( lstrlen ( g_ucsBackupPathLocal.Buffer ) + 
                                             lstrlen ( DIR_SEP_STRING ) +
                                             lstrlen ( FindData.cFileName ) +
                                             1 ) * sizeof ( WCHAR ) ) );
        if ( FAILED( hr )) {
            LOGERROR( hr, StringAllocate );
            goto ErrorExit;
        }

        hr = CreateTargetDirectory( &g_ucsClusdbBackupPathLocal, FALSE );
        if ( FAILED (hr )) {
            LOGERROR( hr, CreateTargetDirectory );
            StringFree ( &ucsCheckpointFile );      
            goto ErrorExit;
        }

        StringAppendString( &ucsCheckpointFile, g_ucsBackupPathLocal.Buffer );
        StringAppendString( &ucsCheckpointFile, DIR_SEP_STRING );
        StringAppendString( &ucsCheckpointFile, FindData.cFileName ); 

        hr = StringAllocate( &ucsClusdbTargetFile, 
                             ( USHORT ) ( ( lstrlen ( g_ucsClusdbBackupPathLocal.Buffer ) + 
                                             lstrlen ( DIR_SEP_STRING ) +
                                             lstrlen ( CLUSTER_DATABASE_NAME ) +
                                             1 ) * sizeof ( WCHAR ) ) );
        if ( FAILED( hr )) {
            StringFree ( &ucsCheckpointFile ); 
            LOGERROR( hr, StringAllocate );
            goto ErrorExit;
        }

        StringAppendString( &ucsClusdbTargetFile, g_ucsClusdbBackupPathLocal.Buffer );
        StringAppendString( &ucsClusdbTargetFile, DIR_SEP_STRING );
        StringAppendString( &ucsClusdbTargetFile, CLUSTER_DATABASE_NAME ); 

        if ( !CopyFile ( ucsCheckpointFile.Buffer, ucsClusdbTargetFile.Buffer, FALSE ) ) {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            LOGERROR( hr, CopyFile );
            StringFree ( &ucsCheckpointFile ); 
            StringFree ( &ucsClusdbTargetFile );
            goto ErrorExit;
        }
        StringFree ( &ucsCheckpointFile );      
        StringFree ( &ucsClusdbTargetFile );
    }
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
#ifdef DBG
    ClRtlLogPrint( LOG_NOISE, "VSS:\n" );
    ClRtlLogPrint( LOG_NOISE, "VSS: DEBUG - sleeping for 30s.  This would be a good time to test killing backup in progress...\n" );
    ClRtlLogPrint( LOG_NOISE, "VSS:\n" );
    Sleep( 30*1000 );
#endif

    // Common cleanup for success or failure.
    //
    if ( bNetShareAdded ) {
        NetStatus = NetShareDel (NULL, SHARE_NAME, 0);
        ClRtlLogPrint( LOG_NOISE, "VSS: NetShareDel returned: %1!u!\n", NetStatus );
        if ( NetStatus == NERR_NetNameNotFound )
            NetStatus = NERR_Success;
        CL_ASSERT( NetStatus == NERR_Success );
    }

    // Cleanup strings but leave the local path so we can cleanup the files later.
    // 
    StringFree( &ucsComputerName );
    StringFree( &ucsBackupPathNetwork );

    if ( hFind != INVALID_HANDLE_VALUE ) FindClose ( hFind );

    LOGFUNCTIONEXIT( DoClusterDatabaseBackup );
    return hr;
}

//++
// DESCRIPTION:                         ConstructSecurityAttributes
//
//      Routines to construct and cleanup a security descriptor which can be
//      applied to limit access to an object to member of either the
//      Administrators or Backup Operators group.
//
// PARAMETERS:
//      psaSecurityAttributes - Pointer to a SecurityAttributes structure which
//                              has already been setup to point to a blank
//                              security descriptor.
//      bIncludeBackupOperator - Whether or not to include an ACE to grant
//                               BackupOperator access
//
// PRE-CONDITIONS:
//      None.
//
// POST-CONDITIONS:
//      Security attributes created that are suitable for backup directory
//
// RETURN VALUE:
//      S_OK - Attributes created OK.
//      Error from setting up attributes or SID or ACL.
//--
static HRESULT ConstructSecurityAttributes( PSECURITY_ATTRIBUTES  psaSecurityAttributes,
                                            BOOL                  bIncludeBackupOperator )
{
    HRESULT			hr             = NOERROR;
    DWORD			dwStatus;
    DWORD			dwAccessMask         = FILE_ALL_ACCESS;
    PSID			psidBackupOperators  = NULL;
    PSID			psidAdministrators   = NULL;
    PACL			paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY	sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS		eaExplicitAccess [2];
    //
    // Initialise the security descriptor.
    //
    hr = GET_HR_FROM_BOOL( InitializeSecurityDescriptor( psaSecurityAttributes->lpSecurityDescriptor,
                                                         SECURITY_DESCRIPTOR_REVISION ));
    if ( FAILED( hr )) {
        LOGERROR( hr, InitializeSecurityDescriptor );
        goto ErrorExit;
    }

    if ( bIncludeBackupOperator ) {
        //
        // Create a SID for the Backup Operators group.
        //
        hr = GET_HR_FROM_BOOL( AllocateAndInitializeSid( &sidNtAuthority,
                                                         2,
                                                         SECURITY_BUILTIN_DOMAIN_RID,
                                                         DOMAIN_ALIAS_RID_BACKUP_OPS,
                                                         0, 0, 0, 0, 0, 0,
                                                         &psidBackupOperators ));
        if ( FAILED( hr )) {
            LOGERROR( hr, AllocateAndInitializeSid );
            goto ErrorExit;
        }
    }
    //
    // Create a SID for the Administrators group.
    //
    hr = GET_HR_FROM_BOOL( AllocateAndInitializeSid( &sidNtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &psidAdministrators ));
    if ( FAILED( hr )) {
        LOGERROR( hr, InitializeSecurityDescriptor );
        goto ErrorExit;
    }

    //
    // Initialize the array of EXPLICIT_ACCESS structures for an
    // ACEs we are setting.
    //
    // The first ACE allows the Backup Operators group full access
    // and the second, allowa the Administrators group full
    // access.
    //
    eaExplicitAccess[0].grfAccessPermissions             = dwAccessMask;
    eaExplicitAccess[0].grfAccessMode                    = SET_ACCESS;
    eaExplicitAccess[0].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    eaExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
    eaExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    eaExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    eaExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
    eaExplicitAccess[0].Trustee.ptstrName                =( LPTSTR ) psidAdministrators;
        
    if ( bIncludeBackupOperator ) {
        eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
        eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
        eaExplicitAccess[1].Trustee.ptstrName                =( LPTSTR ) psidBackupOperators;
    }

    //
    // Create a new ACL that contains the new ACEs.
    //
    dwStatus = SetEntriesInAcl( bIncludeBackupOperator ? 2 : 1,
                                eaExplicitAccess,
                                NULL,
                                &paclDiscretionaryAcl );
    hr = HRESULT_FROM_WIN32( dwStatus );
    if ( FAILED( hr )) {
        LOGERROR( hr, SetEntriesInAcl );
        goto ErrorExit;
    }

    //
    // Add the ACL to the security descriptor.
    //
    hr = GET_HR_FROM_BOOL( SetSecurityDescriptorDacl( psaSecurityAttributes->lpSecurityDescriptor,
                                                      true,
                                                      paclDiscretionaryAcl,
                                                      false ));
    if ( FAILED( hr )) {
        LOGERROR( hr, SetSecurityDescriptorDacl );
        goto ErrorExit;
    }

    paclDiscretionaryAcl = NULL;
    goto ret;

ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    // Cleanup (some may be NULL)
    
    FreeSid( psidAdministrators );
    FreeSid( psidBackupOperators );
    LocalFree( paclDiscretionaryAcl );    
    return hr;
}


//++
// DESCRIPTION:                         CleanupSecurityAttributes
//
//      Deallocate the ACL if present with the security attributes.
//
// PARAMETERS:
//      psaSecurityAttributes - Pointer to a SecurityAttributes structure which
//                              has already been setup to point to a blank
//                              security descriptor.
//
// PRE-CONDITIONS:
//      psaSecurityAttributes points to security attributes as allocated by
//      ConstructSecurityAttributes.
//
// POST-CONDITIONS:
//      Memory freed if it was in use.
//
// RETURN VALUE:
//      None.
//--
static VOID CleanupSecurityAttributes( PSECURITY_ATTRIBUTES psaSecurityAttributes )
{
    BOOL	bDaclPresent         = false;
    BOOL	bDaclDefaulted       = true;
    PACL	paclDiscretionaryAcl = NULL;

    BOOL bSucceeded = GetSecurityDescriptorDacl( psaSecurityAttributes->lpSecurityDescriptor,
                                                 &bDaclPresent,
                                                 &paclDiscretionaryAcl,
                                                 &bDaclDefaulted );

    if ( bSucceeded && bDaclPresent && !bDaclDefaulted && ( paclDiscretionaryAcl != NULL )) {

        LocalFree( paclDiscretionaryAcl );
    }
}

//++
// DESCRIPTION:                         CleanupTargetDirectory
//
//      Deletes all the files present in the directory pointed at by the target
//      path member variable if not NULL. It will also remove the target
//      directory itself, eg for a target path of c:\dir1\dir2 all files under
//      dir2 will be removed and then dir2 itself will be deleted.
//
// PARAMETERS:
//      pwszTargetPath - full path to the directory to cleanup.
//
// PRE-CONDITIONS:
//      pwszTargetPath non NULL.
//
// POST-CONDITIONS:
//      Directory and contained files deleted.
//
// RETURN VALUE:
//      S_OK - Directory and contained files all cleaned up OK.
//      Error status from RemoveDirectoryTree or from GetFileAttributesW
//--
static HRESULT CleanupTargetDirectory( LPCWSTR pwszTargetPath )
{
    LOGFUNCTIONENTRY( CleanupTargetDirectory );

    HRESULT		hr         = NOERROR;
    DWORD		dwFileAttributes = 0;
    BOOL		bSucceeded;
    WCHAR		wszTempBuffer [50];
    UNICODE_STRING	ucsTargetPath;
    UNICODE_STRING	ucsTargetPathAlternateName;

    CL_ASSERT( pwszTargetPath != NULL );

    StringZero( &ucsTargetPath );
    StringZero( &ucsTargetPathAlternateName );

    //
    // Create strings with extra space for appending onto later.
    //
    hr = StringCreateFromExpandedString( &ucsTargetPath, pwszTargetPath, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromExpandedString );
        goto ErrorExit;
    }

    hr = StringCreateFromString( &ucsTargetPathAlternateName, &ucsTargetPath, MAX_PATH );
    if ( FAILED( hr )) {
        LOGERROR( hr, StringCreateFromString );
        goto ErrorExit;
    }        

    dwFileAttributes = GetFileAttributesW( ucsTargetPath.Buffer );
    hr = GET_HR_FROM_BOOL( dwFileAttributes != -1 );
    if (( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND )) 
        || ( hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ))) {
        
		hr         = NOERROR;
		dwFileAttributes = 0;
    }

    if ( FAILED( hr )) {
        LOGERROR( hr, GetFileAttributesW );
        goto ErrorExit;
    }

    //
    // If there is a file there then blow it away, or if it's
    // a directory, blow it and all it's contents away. This
    // is our directory and no one but us gets to play there.
    // The random rename directory could exist but it's only for cleanup anyway...
    //
    hr = RemoveDirectoryTree( &ucsTargetPath );
    if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
        hr = S_OK;
    if ( FAILED( hr )) {
        srand( (unsigned) GetTickCount( ));
        _itow( rand (), wszTempBuffer, 16 );
        StringAppendString( &ucsTargetPathAlternateName, wszTempBuffer );
        bSucceeded = MoveFileW( ucsTargetPath.Buffer, ucsTargetPathAlternateName.Buffer );
        if (bSucceeded) {
			ClRtlLogPrint( LOG_UNUSUAL, "VSS: CleanupTargetDirectory failed to delete %1!ws! with hr: 0x%2!08lx! so renamed to %3!ws!\n",
                           ucsTargetPath.Buffer,
                           hr,
                           ucsTargetPathAlternateName.Buffer );
        } else {
			ClRtlLogPrint( LOG_UNUSUAL, "VSS: CleanupTargetDirectory failed to delete %1!ws! with hr: 0x%2!08lx!"
                           " failed to rename to %3!ws! with status 0x%4!08lx!\n",
                           ucsTargetPath.Buffer,
                           hr,
                           ucsTargetPathAlternateName.Buffer,
                           GET_HR_FROM_BOOL (bSucceeded) );
        }
	}
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    StringFree( &ucsTargetPathAlternateName );
    StringFree( &ucsTargetPath );
    LOGFUNCTIONEXIT( CleanupTargetDirectory );
    return hr;
}

//++
// DESCRIPTION:                         RemoveDirectoryTree
//
//      Deletes all the sub-directories and files in the specified directory
//      and then deletes the directory itself.
//
// PARAMETERS:
//      pucsDirectoryPath - pointer to the directory
//
// PRE-CONDITIONS:
//      Called only from CleanupTargetDirectory
//
// POST-CONDITIONS:
//      Directory tree deleted.
//
// RETURN VALUE:
//      S_OK - Directory tree deleted.
//      Error status from deleting directory or from allocating strings.
//--
static HRESULT RemoveDirectoryTree( PUNICODE_STRING pucsDirectoryPath )
{
    LOGFUNCTIONENTRY( RemoveDirectoryTree );

    HRESULT		hr                = NOERROR;
    HANDLE		hFileScan               = INVALID_HANDLE_VALUE;
    DWORD		dwSubDirectoriesEntered = 0;
    USHORT		usCurrentPathCursor     = 0;
    PWCHAR		pwchLastSlash           = NULL;
    bool		bContinue               = true;
    UNICODE_STRING	ucsCurrentPath;
    WIN32_FIND_DATAW	FileFindData;

    StringZero (&ucsCurrentPath);
    
    LOGUNICODESTRING( *pucsDirectoryPath );
    
    // Create the string with enough extra characters to allow all the
    // appending later on!
    //
	hr = StringCreateFromString (&ucsCurrentPath, pucsDirectoryPath, MAX_PATH);
    if ( FAILED ( hr )) {
        LOGERROR( hr, StringCreateFromString );
        goto ErrorExit;
    }
    
    pwchLastSlash = wcsrchr (ucsCurrentPath.Buffer, DIR_SEP_CHAR);
    usCurrentPathCursor = (USHORT)(pwchLastSlash - ucsCurrentPath.Buffer) + 1;

    while ( SUCCEEDED( hr ) && bContinue ) {
        if ( HandleInvalid( hFileScan )) {
            //
            // No valid scan handle so start a new scan
            //
            ClRtlLogPrint( LOG_NOISE, "VSS: Starting scan: %1!ws!\n", ucsCurrentPath.Buffer );
            hFileScan = FindFirstFileW( ucsCurrentPath.Buffer, &FileFindData );
            hr = GET_HR_FROM_HANDLE( hFileScan );
            if ( SUCCEEDED( hr )) {
                StringTruncate( &ucsCurrentPath, usCurrentPathCursor );
                StringAppendString( &ucsCurrentPath, FileFindData.cFileName );
            }
	    } else {
            //
            // Continue with the existing scan
            //
            hr = GET_HR_FROM_BOOL( FindNextFileW( hFileScan, &FileFindData ));
            if (SUCCEEDED( hr )) {

                StringTruncate( &ucsCurrentPath, usCurrentPathCursor );
                StringAppendString( &ucsCurrentPath, FileFindData.cFileName );

            } else if ( hr == HRESULT_FROM_WIN32( ERROR_NO_MORE_FILES )) {

                FindClose( hFileScan );
                hFileScan = INVALID_HANDLE_VALUE;
                
                if (dwSubDirectoriesEntered > 0) {
                    //
                    // This is a scan of a sub-directory that is now 
                    // complete so delete the sub-directory itself.
                    //
                    StringTruncate( &ucsCurrentPath, usCurrentPathCursor - 1 );
                    hr = GET_HR_FROM_BOOL( QfsRemoveDirectory( ucsCurrentPath.Buffer ));
                    dwSubDirectoriesEntered--;
                }
                if ( dwSubDirectoriesEntered == 0) {
                    //
                    // We are back to where we started except that the 
                    // requested directory is now gone. Time to leave.
                    //
                    bContinue = false;
                    hr = NOERROR;
                } else {
                    //
                    // Move back up one directory level, reset the cursor 
                    // and prepare the path buffer to begin a new scan.
                    //
                    pwchLastSlash = wcsrchr( ucsCurrentPath.Buffer, DIR_SEP_CHAR );
                    usCurrentPathCursor =( USHORT )( pwchLastSlash - ucsCurrentPath.Buffer ) + 1;
                    StringTruncate( &ucsCurrentPath, usCurrentPathCursor );
                    StringAppendString( &ucsCurrentPath, L"*" );
                }

                //
                // No files to be processed on this pass so go back and try to 
                // find another or leave the loop as we've finished the task. 
                //
                continue;
            }
	    }
        
        if (SUCCEEDED( hr )) {
            if ( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributesW( ucsCurrentPath.Buffer, 
                                    FileFindData.dwFileAttributes ^ (FILE_ATTRIBUTE_READONLY) );
            }

            if ( !NameIsDotOrDotDot( FileFindData.cFileName )) {
                if (( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) ||
                    !( FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )) {
                    ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: Deleting file: %1!ws!\n", ucsCurrentPath.Buffer );
                    hr = GET_HR_FROM_BOOL( QfsDeleteFile( ucsCurrentPath.Buffer ) );
                } else {
                    ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: RemoveDirectory: %1!ws!\n", ucsCurrentPath.Buffer );
                    hr = GET_HR_FROM_BOOL( QfsRemoveDirectory( ucsCurrentPath.Buffer ));
                    if (hr == HRESULT_FROM_WIN32( ERROR_DIR_NOT_EMPTY )) {
                        ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: dir not empty.  Restarting scan.\n" );
                        //
                        // The directory wasn't empty so move down one level, 
                        // close the old scan and start a new one. 
                        //
                        hr = S_OK;
                        FindClose( hFileScan );
                        hFileScan = INVALID_HANDLE_VALUE;                        
                        StringAppendString( &ucsCurrentPath, DIR_SEP_STRING L"*" );
                        usCurrentPathCursor =( ucsCurrentPath.Length / sizeof (WCHAR) ) - 1;
                        dwSubDirectoriesEntered++;
                    }
                }
            }
        }
        LOGUNICODESTRING( ucsCurrentPath );
	} // while 

    if ( FAILED( hr )) {
        ClRtlLogPrint( LOG_NOISE, "VSS: RemoveDirectoryTree: exited while loop due to failed hr: 0x%1!08lx!\n", hr );
        goto ErrorExit;
    }

    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    if ( !HandleInvalid( hFileScan ))
        FindClose( hFileScan );

    StringFree( &ucsCurrentPath );

    return hr;
}


//////////////////////////////////////////////////////////////////////////
// Some useful UNICODE string stuff.
//////////////////////////////////////////////////////////////////////////
//
static HRESULT StringAllocate( PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes )
{
    HRESULT	hr            = NOERROR;
    LPVOID	pvBuffer      = NULL;
    SIZE_T	cActualLength = 0;

    pvBuffer = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, usMaximumStringLengthInBytes );
    hr = GET_HR_FROM_POINTER( pvBuffer );
    if ( FAILED (hr )) {
        LOGERROR( hr, StringAllocate );
        goto ErrorExit;
    }
    
    pucsString->Buffer        = (PWCHAR)pvBuffer;
    pucsString->Length        = 0;
    pucsString->MaximumLength = usMaximumStringLengthInBytes;

    cActualLength = HeapSize ( GetProcessHeap( ), 0, pvBuffer );
    
    if ( ( cActualLength <= MAXUSHORT ) && ( cActualLength > usMaximumStringLengthInBytes ))
        pucsString->MaximumLength = (USHORT) cActualLength;

    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    ClRtlLogPrint( LOG_NOISE, "VSS: Allocated string at: 0x%1!08lx! Length: %2!u! MaxLength: %3!u!\n",
                   pucsString->Buffer, pucsString->Length, pucsString->MaximumLength );
    return hr;
}


static void StringFree( PUNICODE_STRING pucsString )
{
    HRESULT	hr = NOERROR;

    CL_ASSERT( pucsString->Length <= pucsString->MaximumLength );
    CL_ASSERT( ( pucsString->Buffer == NULL) ? pucsString->Length == 0 : pucsString->MaximumLength > 0 );

    if ( pucsString->Buffer == NULL ) {
        ClRtlLogPrint( LOG_UNUSUAL, "VSS: StringFree. Attempt to free NULL buffer.\n" );
        return;
    }

    ClRtlLogPrint( LOG_NOISE, "VSS: Freeing string at: %1!ws!\n", pucsString->Buffer );

    ClRtlLogPrint( LOG_NOISE, "VSS: Freeing string at: 0x%1!08lx! Length: %2!u! MaxLength: %3!u!\n",
                   pucsString->Buffer, pucsString->Length, pucsString->MaximumLength );

    hr = GET_HR_FROM_BOOL( HeapFree( GetProcessHeap( ), 0, pucsString->Buffer ));
    CL_ASSERT ( SUCCEEDED( hr ));

    pucsString->Buffer        = NULL;
    pucsString->Length        = 0;
    pucsString->MaximumLength = 0;
}

static HRESULT StringCreateFromExpandedString( PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
{
    HRESULT	hr = NOERROR;
    DWORD	dwStringLength;

    //
    // Remember, ExpandEnvironmentStringsW () includes the terminating null in the response.
    //
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString, NULL, 0) + dwExtraChars;

    hr = GET_HR_FROM_BOOL( dwStringLength != 0 );
    if ( FAILED ( hr )) {
        LOGERROR( hr, ExpandEnvironmentStringsW );
        goto ErrorExit;
    }

    if ( (dwStringLength * sizeof (WCHAR)) > MAXUSHORT ) {
        hr = HRESULT_FROM_WIN32( ERROR_BAD_LENGTH );
        LOGERROR( hr, ExpandEnvironmentStringsW );
        goto ErrorExit;        
    }

    hr = StringAllocate( pucsNewString, (USHORT)( dwStringLength * sizeof (WCHAR) ));
    if ( FAILED( hr )) {
        LOGERROR( hr, StringAllocate );
        goto ErrorExit;
    }

    //
    // Note that if the expanded string has gotten bigger since we
    // allocated the buffer then too bad, we may not get all the
    // new translation. Not that we really expect these expanded
    // strings to have changed any time recently.
    //
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString,
                                                pucsNewString->Buffer,
                                                pucsNewString->MaximumLength / sizeof (WCHAR));
    
    hr = GET_HR_FROM_BOOL( dwStringLength != 0 );
    if ( FAILED ( hr )) {
        LOGERROR( hr, ExpandEnvironmentStringsW );
        goto ErrorExit;
    }
    pucsNewString->Length = (USHORT) ((dwStringLength - 1) * sizeof (WCHAR));
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    CL_ASSERT( pucsNewString->Length <= pucsNewString->MaximumLength );
    return hr;
}

static HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, 
                                       PUNICODE_STRING pucsOriginalString, 
                                       DWORD dwExtraChars)
{
    HRESULT	hr       = NOERROR;
    ULONG	ulStringLength = pucsOriginalString->MaximumLength + (dwExtraChars * sizeof (WCHAR));

    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL))) {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
        goto ErrorExit;
	}

	hr = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
    if ( FAILED( hr ))
        goto ErrorExit;

	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);
	pucsNewString->Length = pucsOriginalString->Length;
	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
    goto ret;
ErrorExit:
    CL_ASSERT( FAILED( hr ));
ret:
    return hr;
}

static void StringAppendString( PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource )
{
    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
    CL_ASSERT( pucsSource->Length <= pucsSource->MaximumLength );
    CL_ASSERT( pucsTarget->Length + pucsSource->Length < pucsTarget->MaximumLength );

    memmove( &pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)], 
             pucsSource->Buffer,
             pucsSource->Length + sizeof( UNICODE_NULL ));
    pucsTarget->Length = pucsTarget->Length + pucsSource->Length;

    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
    CL_ASSERT( pucsSource->Length <= pucsSource->MaximumLength );
}

static void StringAppendString( PUNICODE_STRING pucsTarget, PWCHAR pwszSource )
{
    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
    CL_ASSERT( pucsTarget->Length + ( wcslen( pwszSource ) * sizeof( WCHAR )) < pucsTarget->MaximumLength );

    USHORT Length = (USHORT) wcslen( pwszSource ) * sizeof ( WCHAR );
    memmove( &pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)], pwszSource, Length + sizeof( UNICODE_NULL ));
    pucsTarget->Length = pucsTarget->Length + Length;

    CL_ASSERT( pucsTarget->Length <= pucsTarget->MaximumLength );
}

static HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars)
{
    HRESULT	hr    = NOERROR;
    USHORT	usNewLength = (USHORT)(usSizeInChars * sizeof (WCHAR));

    if (usNewLength > pucsString->Length) {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	} else {
        pucsString->Buffer [usSizeInChars] = UNICODE_NULL;
        pucsString->Length                 = usNewLength;
	}
    return hr;
}

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\cluster.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Cluster.cpp
//
//  Description:
//      Implementation of CCluster class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Cluster.h"
#include "clusrtl.h"

//****************************************************************************
//
//  CCluster
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CCluster
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCluster::CCluster(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CCluster::CCluster()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CCluster::S_CreateThis
//
//  Description:
//      Create a cluster object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CCluster::S_CreateThis( 
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CCluster( pwszNameIn, pNamespaceIn );

} //*** CCluster::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::GetPropMap
//
//  Description:
//      Retrieve the property maping table of the cluster.
//
//  Arguments:
//      None.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CCluster::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_CLUSTER_SECURITYDESCRIPTOR,
            CLUSREG_NAME_CLUS_SD,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_GROUPADMIN,
            CLUS_CLUS_GROUPADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_NETWORKADMIN,
            CLUS_CLUS_NETWORKADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_NETINTFACEADMIN,
            CLUS_CLUS_NETINTERFACEADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_NODEADMIN,
            CLUS_CLUS_NODEADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_RESADMIN,
            CLUS_CLUS_RESADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        },
        {
            PVD_PROP_CLUSTER_RESTYPEADMIN,
            CLUS_CLUS_RESTYPEADMIN,
            MULTI_SZ_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea (
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pmea;

} //*** CCluster::GetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::EnumInstance
//
//  Description:
//      Enum cluster instance.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::EnumInstance(  
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    SAFECLUSTER     shCluster;

    shCluster = OpenCluster( NULL );

    ClusterToWMI( shCluster, pHandlerIn );

    return WBEM_S_NO_ERROR;

} //*** CCluster::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ClusterToWMI
//
//  Description:
//      Translate a cluster objects to WMI object.
//
//  Arguments:
//      hClusterIn  -- Handle to cluster 
//      pHandlerIn  -- Pointer to WMI sink 
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CCluster::ClusterToWMI(
    HCLUSTER            hClusterIn,
    IWbemObjectSink *   pHandlerIn
    )
{   
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES,     FALSE },
        { CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES,        FALSE },
        { CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES,    TRUE },
        { CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES,       TRUE }
    };
    static UINT         s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    DWORD               dwError = ERROR_SUCCESS;
    CError              er;
    UINT                idx;
    CWbemClassObject    wco;

    m_pClass->SpawnInstance( 0, &wco );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        er = pl.ScGetClusterProperties(
                hClusterIn,
                s_rgControl[ idx ].dwControl,
                NULL,
                0
                );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );

    } // for: each common property type

    //
    // cluster name
    //
    {
        DWORD       cchClusterName = MAX_PATH;
        CWstrBuf    wsbClusterName;

        wsbClusterName.SetSize( cchClusterName );
        dwError = GetClusterInformation(
            hClusterIn,
            wsbClusterName,
            &cchClusterName,
            NULL
            );
        if ( dwError == ERROR_MORE_DATA )
        {
            wsbClusterName.SetSize( ++cchClusterName );
            er = GetClusterInformation(
                hClusterIn,
                wsbClusterName,
                &cchClusterName,
                NULL
                );
        } // if: buffer was too small

        wco.SetProperty( wsbClusterName, PVD_PROP_CLUSTER_NAME );

    }

    //
    // network priority
    //
    {
        LPCWSTR     pwszNetworks;
        BSTR        pbstrNetworks[ MAX_PATH ];
        UINT        cSize;
        
        idx = 0;
        CClusterEnum cluEnum( hClusterIn, (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK );

        // bugbug   can you always clean up
        while ( ( pwszNetworks =  cluEnum.GetNext() ) != NULL )
        {
            pbstrNetworks[ idx ]  = SysAllocString( pwszNetworks );
            idx++;
        }
        wco.SetProperty(
            idx,
            pbstrNetworks,
            PVD_PROP_CLUSTER_NETWORK
            );
        cSize = idx;
        for ( idx = 0 ; idx < cSize ; idx++ )
        {
            SysFreeString( pbstrNetworks[ idx ] );
        }
    }

    //
    // quorum resource
    //
    {
        CWstrBuf    wsbName;
        DWORD       cchName = MAX_PATH ;
        CWstrBuf    wsbDeviceName;
        DWORD       cchDeviceName = MAX_PATH;
        DWORD       dwLogSize;

        wsbName.SetSize( cchName );
        wsbDeviceName.SetSize( cchDeviceName );

        dwError = GetClusterQuorumResource(
                        hClusterIn,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        if ( dwError == ERROR_MORE_DATA )
        {
             wsbName.SetSize( ++cchName );
             wsbDeviceName.SetSize( ++cchDeviceName );
             er = GetClusterQuorumResource(
                        hClusterIn,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        }

        wco.SetProperty( wsbDeviceName, PVD_PROP_CLUSTER_FILE );
        wco.SetProperty( dwLogSize,     PVD_PROP_CLUSTER_LOGSIZE );
    }

    //
    // max nodes in cluster
    //
    {
        DWORD   maxNodesInCluster;

        maxNodesInCluster = ClRtlGetDefaultNodeLimit( ClRtlGetSuiteType() );
        wco.SetProperty( maxNodesInCluster, PVD_PROP_CLUSTER_MAX_NODES );

    }

    pHandlerIn->Indicate( 1, &wco );
    return;

} //*** CCluster::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::GetObject
//
//  Description:
//      retrieve cluster object based given object path
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    
    shCluster = OpenCluster( NULL );

    ClusterToWMI( shCluster, pHandlerIn );

    return WBEM_S_NO_ERROR;

} //*** CCluster::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ExecuteMethod
//
//  Description:
//      execute methods defined in the mof for cluster 
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    CWbemClassObject    InArgs( pParamsIn );
    IWbemClassObject *  pIOutClass = NULL;
    IWbemClassObject *  pIOutParams = NULL;
    HRESULT             hr = WBEM_S_NO_ERROR;
    CError              er;

    if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_CLUSTER_GETNODECLUSTERSTATE ) == 0 )
    {
        DWORD               dwState = 0;
        VARIANT             varClusterState;

        //
        // GetNodeClusterState Method: Get the current state of the node we are bound.
        //
        er = GetNodeClusterState( NULL, &dwState );

        //
        // Now we have the node state, we need to pass this information as an output parameter.
        //
        er = m_pClass->GetMethod( _bstr_t( PVD_MTH_CLUSTER_GETNODECLUSTERSTATE ), 0, NULL, &pIOutClass );

        //
        // We can not use er (we'll use hr) from this point on. We can't throw an exception since we need to release 
        // pIOutClass and pIOutParams before throwing an exception in case of a failure.
        //
        hr = pIOutClass->SpawnInstance( 0, &pIOutParams );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        
        VariantClear( &varClusterState );
        varClusterState.vt = VT_I4;
        varClusterState.lVal = dwState;
        
        hr = pIOutParams->Put(
                            _bstr_t( PVD_MTH_CLUSTER_PARM_CLUSTERSTATE ),
                            0, 
                            &varClusterState,
                            0
                            );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        
        hr = pHandlerIn->Indicate( 1, &pIOutParams );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: get node cluster state 
    else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_CLUSTER_RENAME ) == 0 )
    {
        _bstr_t bstrName;
        DWORD   dwReturn;

        //
        // Do not move OpenCluster above the GetNodeClusterState method. 
        // GetNodeClusterState method is supposed to work when there's no cluster.
        //
        shCluster = OpenCluster( NULL );

        InArgs.GetProperty( bstrName, PVD_MTH_CLUSTER_PARM_NEWNAME );
        dwReturn = SetClusterName( shCluster, bstrName );
        if ( dwReturn != ERROR_RESOURCE_PROPERTIES_STORED )
        {
            er = dwReturn;
        }
    } // if: create new group
    else if( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_CLUSTER_SETQUORUM ) == 0 )
    {
        _bstr_t         bstrName;
        SAFERESOURCE    hResource;

        //
        // Do not move OpenCluster above the GetNodeClusterState method. 
        // GetNodeClusterState method is supposed to work when there's no cluster.
        //
        shCluster = OpenCluster( NULL );

        InArgs.GetProperty( bstrName, PVD_MTH_CLUSTER_PARM_RESOURCE );
        hResource = OpenClusterResource( shCluster, bstrName );
        er = SetClusterQuorumResource(
            hResource,
            NULL,
            64000
            );
    } // else if: set quorum resource

Cleanup:

    //
    // Release the interfaces
    //
    if ( pIOutClass != NULL )
    {
        pIOutClass->Release();
    }

    if ( pIOutParams != NULL )
    {
        pIOutParams->Release();
    }

    //
    // Now throw an exception if hr is FAILED
    //
    if ( FAILED( hr ) )
    {
        er = hr;
    }
    
    return hr;

} //*** CCluster::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::PutInstance
//
//  Description:
//      save this instance
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CCluster::PutInstance( 
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static  SGetSetControl  s_rgControl[] =
    {
        {
            CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES,
            CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES,
            CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static  DWORD   s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    CError          er;
    DWORD           dwError;
    SAFECLUSTER     shCluster;
    UINT    idx;

    shCluster = OpenCluster( NULL );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;

        er = plOld.ScGetClusterProperties(
                shCluster,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL,
                0
                );

        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterControl(
                    shCluster,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    static_cast< DWORD >( plNew.CbPropList() ),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    //
    // network
    //
    {
        CClusPropList   plNetwork;
        DWORD           cNetworks = 0;
        _bstr_t *       pbstrNetworks = NULL;
        HNETWORK *      phNetworks = NULL;

        idx = 0;
        rInstToPutIn.GetProperty(
            &cNetworks,
            &pbstrNetworks,
            PVD_PROP_CLUSTER_NETWORK
            );
        try
        {
            phNetworks = new HNETWORK[ cNetworks ];

            for( idx = 0 ; idx < cNetworks ; idx++ )
            {
                *(phNetworks + idx) = NULL;
            }

            for ( idx = 0 ; idx < cNetworks ; idx++)
            {
                *( phNetworks + idx ) = OpenClusterNetwork(
                    shCluster,
                    *( pbstrNetworks + idx ) );
                if ( phNetworks == NULL )
                {
                    throw CProvException( GetLastError() );
                }
            }

            er = SetClusterNetworkPriorityOrder(
                shCluster,
                cNetworks,
                phNetworks
                );
        } // try
        catch ( ... )
        {
            for ( idx = 0 ; idx < cNetworks ; idx++)
            {
                if ( *( phNetworks + idx ) )
                {
                    CloseClusterNetwork( *( phNetworks + idx) );
                }
            }
            delete [] phNetworks;
            delete [] pbstrNetworks;
            throw;
        } // catch: ...

        //
        // clean up
        //
        for ( idx = 0 ; idx < cNetworks ; idx++)
        {
            if ( *( phNetworks + idx ) )
            {
                CloseClusterNetwork( *( phNetworks + idx) );
            }
        }
        delete [] phNetworks;
        delete [] pbstrNetworks;

    }

    //
    // quorum resource
    //
    {
        CWstrBuf        wsbName;
        DWORD           cchName = MAX_PATH;
        CWstrBuf        wsbDeviceName;
        DWORD           cchDeviceName = MAX_PATH;
        DWORD           dwLogSize;
        _bstr_t         bstrNewDeviceName;
        DWORD           dwNewLogSize;
        SAFERESOURCE    shResource;

        wsbName.SetSize( cchName );
        wsbDeviceName.SetSize( cchDeviceName );
        dwError = GetClusterQuorumResource(
                        shCluster,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        if ( dwError == ERROR_MORE_DATA )
        {
            wsbName.SetSize( ++cchName );
            wsbDeviceName.SetSize( ++cchDeviceName );
            er = GetClusterQuorumResource(
                        shCluster,
                        wsbName,
                        &cchName,
                        wsbDeviceName,
                        &cchDeviceName,
                        &dwLogSize
                        );
        } // if: buffer is too small

        rInstToPutIn.GetProperty( bstrNewDeviceName, PVD_PROP_CLUSTER_FILE );
        rInstToPutIn.GetProperty( &dwNewLogSize,    PVD_PROP_CLUSTER_LOGSIZE );
        if ( ClRtlStrICmp( wsbDeviceName, bstrNewDeviceName )
          || dwLogSize != dwNewLogSize )
        {
            shResource = OpenClusterResource( shCluster, wsbName );

            er = SetClusterQuorumResource(
                    shResource,
                    bstrNewDeviceName,
                    dwNewLogSize
                    );
        } // if:

    }

    return WBEM_S_NO_ERROR;

} //*** CCluster::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::DeleteInstance
//
//  Description:
//      save this instance
//
//  Arguments:
//      rObjPathIn  -- ObjPath for the instance to be deleted
//      lFlagIn     -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////

SCODE
CCluster::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CCluster::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\cluster.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.h
//
//  Implementation File:
//      Cluster.cpp
//
//  Description:
//      Definition of the CCluster class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CCluster;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluster
//
//  Description:
//      Provider Implement for cluster
//
//--
//////////////////////////////////////////////////////////////////////////////
class CCluster : public CProvBase
{
public:

    CCluster::CCluster(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HCLUSTER            hClusterIn,
        IWbemObjectSink *   pHandlerIn
      );

}; //*** class CCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterenum.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterEnum.cpp
//
//  Description:
//      Implementation of CClusterEnum class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterEnum.h"

//****************************************************************************
//
//  CClusterEnum
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterEnum::CClusterEnum(
//      HCLUSTER    hCluster,
//      DWORD       dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      hClusterIn      -- Cluster handle.
//      dwEnumTypeIn    -- Type of enumeration.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterEnum::CClusterEnum(
    HCLUSTER    hCluster,
    DWORD       dwEnumTypeIn
    )
    : m_pwszName( NULL )
    , m_hEnum( NULL )
    , m_Idx( 0 )
{
    m_hEnum = ClusterOpenEnum( hCluster, dwEnumTypeIn );

    m_cchName = 1024;
    m_pwszName = new WCHAR[ (m_cchName + 1) * sizeof( WCHAR ) ];

} //*** CClusterEnum::CClusterEnum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterEnum::~CClusterEnum( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterEnum::~CClusterEnum( void )
{
    if ( m_pwszName )
    {
        delete [] m_pwszName;
    }
    if ( m_hEnum )
    {
        ClusterCloseEnum( m_hEnum );
    }

} //*** CClusterEnum::~CClusterEnum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  const LPCWSTR
//  CClusterEnum::GetNext( void )
//
//  Description:
//      Get the next item from the enumeration.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to the next item name.
//
//--
//////////////////////////////////////////////////////////////////////////////
const LPCWSTR
CClusterEnum::GetNext( void )
{
    DWORD cchName = m_cchName;
    DWORD dwType;
    DWORD dwError;

    dwError = ClusterEnum(
                    m_hEnum,
                    m_Idx,
                    &dwType,
                    m_pwszName,
                    &cchName
                    );

    if ( dwError == ERROR_MORE_DATA )
    {
        delete [] m_pwszName;
        m_cchName = ++cchName;
        m_pwszName =  new WCHAR[ m_cchName * sizeof( WCHAR ) ];

        if ( m_pwszName != NULL )
        {
            dwError = ClusterEnum(
                            m_hEnum,
                            m_Idx,
                            &dwType,
                            m_pwszName,
                            &cchName
                            );
        } // if:
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        } // else:
    } // if: buffer is too small

    if ( dwError == ERROR_SUCCESS )
    {
        m_Idx++;
        return m_pwszName;
    }

    return NULL;

} //*** CClusterEnum::GetNext()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterenum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.h
//
//  Implementation File:
//      Cluster.cpp
//
//  Description:
//      Definition of the CClusterEnum class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterEnum;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterEnum
//
//  Description:
//      Enumerate cluster objects.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterEnum
{
public:
    CClusterEnum(
        HCLUSTER    hClusterIn,
        DWORD       dwEnumTypeIn
        );
    virtual ~CClusterEnum( void);
    const LPCWSTR GetNext( void );

protected:
    LPWSTR      m_pwszName;
    HCLUSENUM   m_hEnum;
    UINT        m_Idx;
    DWORD       m_cchName;
    DWORD       m_dwType;

}; //*** class CClusterEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clustergroupnode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterGroupNode.h
//
//  Implementation File:
//      ClusterGroupNode.cpp
//
//  Description:
//      Definition of the CClusterGroupNode class.
//
//  Author:
//      Ozan Ozhan (ozano)    02-JUN-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterGroupNode
//
//  Description:
//      Provider Implement for cluster Group Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterGroupNode : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterGroupNode::CClusterGroupNode(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterGroupNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clustergroupnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterGroupNode.cpp
//
//  Description:
//      Implementation of CClusterGroupNode class 
//
//  Author:
//      Ozan Ozhan (ozano)    02-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterGroupNode.h"

//****************************************************************************
//
//  CClusterGroupNode
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroupNode::CClusterGroupNode(
//
//  Description:
//      Constructor for 'cluster Group to node' object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterGroupNode::CClusterGroupNode(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterGroupNode::CClusterGroupNode()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterGroupNode::S_CreateThis(
//
//  Description:
//      Create a 'cluster Group to node' object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterGroupNode::S_CreateThis(
    LPCWSTR          pwszNameIn,
    CWbemServices *  pNamespaceIn,
    DWORD            dwEnumTypeIn
    )
{
    return new CClusterGroupNode(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterGroupNode::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterGroupNode::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances
//
//  Arguments:
//      lFlagsIn    -- 
//      pCtxIn      -- 
//      pHandlerIn  -- 
//
//  Return Values:
//      SCODE
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroupNode::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    SAFEGROUPENUM       shGroupEnum;
    LPCWSTR             pwszGroupName = NULL;
    DWORD               cchNodeName = MAX_PATH;
    CWstrBuf            wsbNodeName;
    DWORD               cch;
    DWORD               dwError;
    DWORD               dwIndex;
    DWORD               dwType;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    while ( ( pwszGroupName = clusEnum.GetNext() ) != NULL )
    {

        shGroup = OpenClusterGroup( shCluster, pwszGroupName );

        shGroupEnum = ClusterGroupOpenEnum(
                        shGroup,
                        CLUSTER_GROUP_ENUM_NODES
                        );
        dwIndex = 0;
        for( ; ; )
        {
            wsbNodeName.SetSize( cchNodeName );
            dwError = ClusterGroupEnum(
                        shGroupEnum,
                        dwIndex,
                        &dwType,
                        wsbNodeName,
                        &cch
                        );
            if ( dwError == ERROR_MORE_DATA )
            {
                cchNodeName = ++cch;
                wsbNodeName.SetSize( cch );
                dwError = ClusterGroupEnum(
                                shGroupEnum,
                                dwIndex,
                                &dwType,
                                wsbNodeName,
                                &cch
                                );
            } // if: more data

            if ( dwError == ERROR_SUCCESS )
            {
                m_wcoGroup.SpawnInstance( 0, & wcoGroup );
                m_wcoPart.SpawnInstance( 0, & wcoPart );
                wcoGroup.SetProperty( pwszGroupName, PVD_PROP_GROUP_NAME );
                wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );
                wcoPart.SetProperty( wsbNodeName, CLUSREG_NAME_GRP_NAME );
                wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

                m_pClass->SpawnInstance( 0, & wco );
                wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
                wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
                pHandlerIn->Indicate( 1, & wco );
        
            } // if: success

            else
            {
                break;
            } // else

            dwIndex++;

        } // for: Preferred Node List
   
    } // while: more items to enumerate

    return WBEM_S_NO_ERROR;

} //*** CClusterGroupNode::EnumInstance(()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternetinterface.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusterNetInterface.h
//
//  Implementation File:
//      CClusterNetInterface.cpp
//
//  Description:
//      Definition of the CClusterNetInterface class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNetInterface;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNetInterface
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNetInterface : public CProvBase
{
//
// constructor
//
public:
    CClusterNetInterface::CClusterNetInterface(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           // dwEnumTypeIn
        );

protected:
    
    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNETINTERFACE       hNetInterfaceIn,
        IWbemObjectSink *   pHandlerIn,
        LPCWSTR             pwszNameIn
        );

}; //*** class CClusterNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clustergroup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterGroup.cpp
//
//  Description:    
//      Implementation of CClusterGroup class 
//
//  Maintained by:
//      Ozan Ozhan  (OzanO)     26-NOV-2002
//      Henry Wang  (HenryWa)   24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterGroup.h"
#include "ClusterGroup.tmh"

//****************************************************************************
//
//  CClusterGroup
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::CClusterGroup
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterGroup::CClusterGroup(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{
} //*** CClusterGroup::CClusterGroup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterGroup::S_CreateThis
//
//  Description:
//      Create a CClusterGroup object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterGroup::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    TracePrint(("CClusterGroup::S_CreatThis for Name = %ws, EnumType %u\n", pwszNameIn, dwEnumTypeIn )); 
    return new CClusterGroup( pwszNameIn, pNamespaceIn );

} //*** CClusterGroup::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::GetPropMap
//
//  Description:
//      Retrieve the property maping table of the cluster group.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table.
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterGroup::RgGetPropMap( void )
{

    static SPropMapEntry s_rgpm[] =
    {
        {
            NULL,
            CLUSREG_NAME_GRP_LOADBAL_STATE,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pamea(
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pamea;

} //*** CClusterGroup::GetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::EnumInstance
//
//  Description:
//      Enum cluster instance.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    LPCWSTR         pwszGroup;

    TracePrint(( "CClusterGroup::EnumInstance, pHandlerIn = %p\n", pHandlerIn ));
    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_GROUP );

    while ( ( pwszGroup = cluEnum.GetNext() ) != NULL )
    {
        shGroup = OpenClusterGroup( shCluster, pwszGroup );

        ClusterToWMI( shGroup, pHandlerIn );

    } // while: more groups

    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::ClusterToWMI
//
//  Description:
//      Translate a cluster group object to WMI object.
//
//  Arguments:
//      hGroupIn    -- Handle to group
//      pHandlerIn  -- Handler
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterGroup::ClusterToWMI(
    HGROUP              hGroupIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES,   FALSE },
        { CLUSCTL_GROUP_GET_COMMON_PROPERTIES,      FALSE },
        { CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES,  TRUE },
        { CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES,     TRUE }
    };
    static UINT         s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CError              er;
    UINT                idx;
    CWbemClassObject    wco;

    m_pClass->SpawnInstance( 0, &wco );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        er = pl.ScGetGroupProperties(
                    hGroupIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );

    } // for: each common property type

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        DWORD   dwState;

        er = ClusterGroupControl( 
            hGroupIn,
            NULL,
            CLUSCTL_GROUP_GET_CHARACTERISTICS,
            NULL,
            0,
            &dwOut,
            sizeof( DWORD ),
            &cbReturned
            );
        wco.SetProperty(
            dwOut,
            PVD_PROP_CHARACTERISTIC
            );

        dwState = GetClusterGroupState(
                            hGroupIn,
                            NULL,
                            NULL
                            );
        wco.SetProperty( dwState, PVD_PROP_GROUP_STATE );
    }

    pHandlerIn->Indicate( 1, &wco );
    return;

} //*** CClusterGroup::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::GetObject
//
//  Description:
//      Retrieve cluster group object based given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    
    shCluster = OpenCluster( NULL );
    shGroup = OpenClusterGroup(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
        );

    ClusterToWMI( shGroup, pHandlerIn );

    return WBEM_S_NO_ERROR;
        
} //*** CClusterGroup::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::ExecuteMethod
//
//  Description:
//      Execute methods defined in the mof for cluster node.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    CWbemClassObject    InArgs( pParamsIn );
    CError              er;
    
    shCluster = OpenCluster( NULL );
    //
    // static method
    //
    if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_GROUP_CREATEGROUP ) == 0 )
    {
        
        _bstr_t bstrNewGroup;
        InArgs.GetProperty( bstrNewGroup, PVD_MTH_GROUP_PARM_GROUPNAME );
        shGroup = CreateClusterGroup( shCluster, bstrNewGroup );

        er = HrWrapOnlineClusterGroup( shCluster, shGroup );
    } // if: CREATEGROUP
    else
    {
        shGroup = OpenClusterGroup(
            shCluster,
            rObjPathIn.GetStringValueForProperty( PVD_PROP_GROUP_NAME )
            );
    
        if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_GROUP_DELETEGROUP ) == 0 )
        {
            er = DeleteClusterGroup( shGroup );
        }
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_GROUP_TAKEOFFLINE ) == 0 )
        {
            DWORD dwTimeOut = 0;
            InArgs.GetProperty( &dwTimeOut, PVD_MTH_GROUP_PARM_TIMEOUT );
            er = HrWrapOfflineClusterGroup( shCluster, shGroup, dwTimeOut );
        } // if: TAKEOFFLINE
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_GROUP_BRINGONLINE ) == 0 )
        {
            DWORD dwTimeOut = 0;
            InArgs.GetProperty( &dwTimeOut, PVD_MTH_GROUP_PARM_TIMEOUT );
            er = HrWrapOnlineClusterGroup( shCluster, shGroup, NULL, dwTimeOut );
        } // else if: BRINGONLINE
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_GROUP_MOVETONEWNODE ) == 0 )
        {
            _bstr_t     bstrNewNode;
            SAFENODE    shNode;
            DWORD       dwTimeOut = 0;

            InArgs.GetProperty( &dwTimeOut, PVD_MTH_GROUP_PARM_TIMEOUT );
            InArgs.GetProperty( bstrNewNode, PVD_MTH_GROUP_PARM_NODENAME );
            shNode = OpenClusterNode( shCluster, bstrNewNode );
            er = HrWrapMoveClusterGroup( shCluster, shGroup, shNode, dwTimeOut );
        } // else if: MOVETONEWNODE
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_GROUP_RENAME ) == 0 )
        {
            _bstr_t     bstrNewName;
            InArgs.GetProperty( bstrNewName, PVD_MTH_GROUP_PARM_NEWNAME );
            er = SetClusterGroupName( shGroup, bstrNewName );
        } // else if: RENAME
        else
        {
            er = static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
        }
    } // else: not create new group
    
    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::PutInstance
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        { 
            CLUSCTL_GROUP_GET_COMMON_PROPERTIES,
            CLUSCTL_GROUP_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES,
            CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shGroup = OpenClusterGroup( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        
        er = plOld.ScGetGroupProperties(
                shGroup,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL,
                0
                );

        CClusterApi::SetObjectProperties(
            NULL,
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterGroupControl( 
                shGroup,
                NULL,
                s_rgControl[ idx ].dwSetControl,
                plNew.PbPropList(),
                static_cast< DWORD >( plNew.CbPropList() ),
                NULL,
                0,
                NULL
                );
        }

    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroup::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroup::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFEGROUP       shGroup;
    CError          er;

    shCluster = OpenCluster( NULL );
    shGroup = OpenClusterGroup(
                    shCluster,
                    rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
                    );

    er = DeleteClusterGroup( shGroup );

    return WBEM_S_NO_ERROR;

} //*** CClusterGroup::DeleteInstance()

//****************************************************************************
//
//  CClusterGroupRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroupRes::CClusterGroupRes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterGroupRes::CClusterGroupRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterGroupRes::CClusterGroupRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterGroupRes::S_CreateThis
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterGroupRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterGroupRes(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterGroupRes::S_CreateThis()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGroupRes::EnumInstance
//
//  Description:
//      Retrieve the property maping table of the cluster node active resource.
//
//  Arguments:
//      lFlagsIn        -- 
//      pCtxIn          -- 
//      pHandlerIn      -- 
//
//  Return Values:
//      SCODE
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterGroupRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszName = NULL;
    DWORD               cchGroupName = MAX_PATH;
    CWstrBuf            wsbGroupName;
    DWORD               cch;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 
    wsbGroupName.SetSize( cchGroupName );
    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );


    m_wcoGroup.SpawnInstance( 0, &wcoGroup );
    m_wcoPart.SpawnInstance( 0, &wcoPart );


    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        CWbemClassObject    wco;
        DWORD               dwState;

        cch = cchGroupName;
        wcoPart.SetProperty( pwszName, PVD_PROP_RES_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        shResource = OpenClusterResource( shCluster, pwszName );

        dwState = GetClusterResourceState(
                        shResource,
                        NULL,
                        0,
                        wsbGroupName,
                        &cch
                        );
        if ( dwState == ClusterResourceStateUnknown )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_MORE_DATA )
            {
                cchGroupName = ++cch;
                wsbGroupName.SetSize( cch );
                dwState = GetClusterResourceState(
                                shResource,
                                NULL,
                                0,
                                wsbGroupName,
                                &cch
                                );
            } // if:  more data
            else
            {
                er = dwError;
            }
        } // if: state unknown

        wcoGroup.SetProperty( wsbGroupName, CLUSREG_NAME_GRP_NAME );
        wcoGroup.GetProperty( bstrGroup,    PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, &wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR) bstrPart,  PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, &wco );

    } // while: more resources

    return WBEM_S_NO_ERROR;

} //*** CClusterGroupRes::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clustergroup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterGroup.h
//
//  Implementation File:
//      ClusterGroup.cpp
//
//  Description:
//      Definition of the CClusterGroup class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterGroup;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterGroup
//
//  Description:
//      Provider Implement for cluster Group
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterGroup : public CProvBase
{

//
// constructor
//
public:
    CClusterGroup::CClusterGroup(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumType = 0
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HGROUP              hGroupIn,
        IWbemObjectSink *   pHandlerIn
        );

}; //*** class CClusterGroup

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterGroupRes
//
//  Description:
//      Provider Implement for cluster group resources
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterGroupRes : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterGroupRes::CClusterGroupRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterGroupRes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternetinterface.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name: CClusterNetInterface.cpp
//
//  Description:    
//      Implementation of CClusterNetInterface class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNetInterface.h"

#include "ClusterNetInterface.tmh"

//****************************************************************************
//
//  CClusterNetInterface
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::CClusterNetInterface
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNetInterface::CClusterNetInterface(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{
    
} //*** CClusterNetInterface::CClusterNetInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterNetInterface::S_CreateThis
//
//  Description:
//      Create a cluster network interface object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNetInterface::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNetInterface( pwszNameIn, pNamespaceIn );

} // CClusterNetInterface::S_CreateThis


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::RgGetPropMap
//
//  Description:
//      Retrieve the property maping table of the cluster node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterNetInterface::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_NETINTERFACE_DEVICEID,
            CLUSREG_NAME_NETIFACE_NAME,
            SZ_TYPE,
            READONLY
        },
        {
            PVD_PROP_NETINTERFACE_SYSTEMNAME,
            CLUSREG_NAME_NETIFACE_NODE,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NETIFACE_ADAPTER_ID,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NETIFACE_ENDPOINT,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) /sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pmea;

} //*** CClusterNetInterface::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::EnumInstance
//
//  Description:
//      Enum cluster instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENETINTERFACE    shNetInterface;
    LPCWSTR             pwszName;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum(
        shCluster,
        CLUSTER_ENUM_NETINTERFACE );


    while ( ( pwszName = cluEnum.GetNext() ) != NULL )
    {
        shNetInterface = OpenClusterNetInterface( shCluster, pwszName );

        ClusterToWMI( shNetInterface, pHandlerIn, pwszName );
    }

    return WBEM_S_NO_ERROR;

} //*** CClusterNetInterface::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::ClusterToWMI
//
//  Description:
//      Translate a cluster network interface object to WMI object.
//
//  Arguments:
//      hNetInterfaceIn     -- handle to network interface
//      pHandlerIn          -- Pointer to WMI sink
//      pwszNameIn          -- Name of the network interface
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNetInterface::ClusterToWMI(
    HNETINTERFACE       hNetInterfaceIn,
    IWbemObjectSink *   pHandlerIn,
    LPCWSTR             pwszNameIn
    )
{
    static SGetControl  s_rgControl[] = 
    {
        { CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CError              er;
    UINT                idx;

    m_pClass->SpawnInstance( 0, & wco);
    for( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        er = pl.ScGetNetInterfaceProperties(
            hNetInterfaceIn,
            s_rgControl[ idx ].dwControl,
            NULL,
            0 );
   
        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );
    } // for: each control code
    
    //
    // Set the network interface name 
    //
    wco.SetProperty(
        pwszNameIn,
        PVD_PROP_NETINTERFACE_NAME
        );

    wco.SetProperty(
        GetClusterNetInterfaceState( hNetInterfaceIn),
        PVD_PROP_NETINTERFACE_STATE
        );

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterNetInterfaceControl( 
                    hNetInterfaceIn,
                    NULL,
                    CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS,  // this control code
                    NULL,                                      // input buffer (not used)
                    0,                                         // input buffer size (not used)
                    & dwOut,
                    sizeof( DWORD ),
                    & cbReturned
                    );
        wco.SetProperty(
            dwOut,
            PVD_PROP_CHARACTERISTIC
            );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::GetObject
//
//  Description:
//      Retrieve cluster network interface object based given object path.
//
//  Arguments:
//      rObjPathIn      -- Object path to cluster object
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENETINTERFACE    shNetInterface;
    LPCWSTR             pwszName = rObjPathIn.GetStringValueForProperty( PVD_PROP_NETINTERFACE_DEVICEID );
    
    shCluster = OpenCluster( NULL ) ;
    shNetInterface = OpenClusterNetInterface( shCluster, pwszName );

    ClusterToWMI( shNetInterface, pHandlerIn, pwszName );
    return WBEM_S_NO_ERROR;

} //*** CClusterNetInterface::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::ExecuteMethod
//
//  Description:
//      Execute methods defined in the mof for cluster network interface.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNetInterface::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::PutInstance
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES,
            CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD            s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t            bstrName;
    SAFECLUSTER      shCluster;
    SAFENETINTERFACE shNetwork;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NETINTERFACE_DEVICEID );

    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetInterface( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;

        er = plOld.ScGetNetInterfaceProperties(
            shNetwork,
            s_rgControl[ idx ].dwGetControl,
            NULL,
            NULL,
            0
            );

        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNetInterfaceControl( 
                    shNetwork,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    static_cast< DWORD >( plNew.CbPropList() ),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterNetInterface::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetInterface::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn  -- ObjPath for the instance to be deleted
//      lFlagIn     -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetInterface::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNetInterface::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternetwork.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CClusterNetwork.h
//
//  Implementation File:
//      CClusterNetwork.cpp
//
//  Description:
//      Definition of the CCClusterNetwork class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNetwork;
class CClusterNetNetInterface;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNetwork
//
//  Description:
//      Provider Implement for cluster Node
//
//  Inheritance:
//      CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNetwork : public CProvBase  
{
//
// constructor
//
public:
    CClusterNetwork::CClusterNetwork(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:
    
    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNETWORK            hNetworkIn,
        IWbemObjectSink *   pHandlerIn
      );

}; //*** class CClusterNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNetNetInterface
//
//  Description:
//      Implement cluster network and netinterface association
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNetNetInterface : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNetNetInterface::CClusterNetNetInterface(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNetNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternetwork.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CClusterNetwork.cpp
//
//  Description:
//      Implementation of CClusterNetwork class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNetwork.h"

//****************************************************************************
//
//  CClusterNetwork
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::CClusterNetwork
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNetwork::CClusterNetwork(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    :CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterNetwork::CClusterNetwork()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterNetwork::S_CreateThis
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNetwork::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNetwork( pwszNameIn, pNamespaceIn );

} //*** CClusterNetwork::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::RgGetPropMap
//
//  Description:
//      Retrieve the property maping table of the cluster network.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table.
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterNetwork::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            NULL,
            CLUSREG_NAME_NET_PRIORITY,
            SZ_TYPE,
            READONLY
        }
        ,
        {
            NULL,
            CLUSREG_NAME_NET_TRANSPORT,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) /sizeof( SPropMapEntry ),
                s_rgpm
                );

    return & s_pmea;

} //*** CClusterNetwork::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::EnumInstance
//
//  Description:
//      enum cluster instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENETWORK     shNetwork;
    LPCWSTR         pwszName;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_NETWORK );

    while ( ( pwszName = cluEnum.GetNext() ) != NULL )
    {
        shNetwork = OpenClusterNetwork( shCluster, pwszName );

        ClusterToWMI( shNetwork, pHandlerIn );

    } // while: more networks

    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::ClusterToWMI
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- handle to resource 
//      pHandlerIn      -- Pointer to WMI sink 
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNetwork::ClusterToWMI(
    HNETWORK            hNetworkIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] = 
    {
        { CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES,     FALSE },
        { CLUSCTL_NETWORK_GET_COMMON_PROPERTIES,        FALSE },
        { CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES,    TRUE },
        { CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES,       TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CError              er;
    UINT                idx;

    m_pClass->SpawnInstance( 0, & wco );
    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList pl;
        er = pl.ScGetNetworkProperties(
                hNetworkIn,
                s_rgControl[ idx ].dwControl,
                NULL,
                0
                );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );
    } // for: each control code
    
    {
        DWORD dwState = GetClusterNetworkState( hNetworkIn );

        wco.SetProperty( dwState, PVD_PROP_NETWORK_STATE );
    }

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterNetworkControl( 
                hNetworkIn,
                NULL,
                CLUSCTL_NETWORK_GET_CHARACTERISTICS,    // this control code
                NULL,                                   // input buffer (not used)
                0,                                      // input buffer size (not used)
                & dwOut,
                sizeof( DWORD ),
                & cbReturned
                );
        wco.SetProperty(
                dwOut,
                PVD_PROP_CHARACTERISTIC
                );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::GetObject
//
//  Description:
//      Retrieve cluster node object based given object path.
//
//  Arguments:
//      rObjPathIn      -- Object path to cluster object
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENETWORK     shNetwork;
    
    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetwork(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
        );

    ClusterToWMI( shNetwork, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::ExecuteMethod
//
//  Description:
//      Execute methods defined in the mof for cluster network.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    CWbemClassObject    wcoInArgs( pParamsIn );
    CError              er;
    
    shCluster = OpenCluster( NULL );

    if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_NETWORK_RENAME ) == 0 )
    {
        
        _bstr_t     bstrName;
        SAFENETWORK shNetwork;
        
        wcoInArgs.GetProperty( bstrName, PVD_MTH_NETWORK_PARM_NEWNAME );
        shNetwork = OpenClusterNetwork(
            shCluster,
            rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
            );
        er = SetClusterNetworkName( shNetwork, bstrName );
        
    } // if: RENAME
    else
    {
       er = static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::PutInstance
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetwork::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NETWORK_GET_COMMON_PROPERTIES,
            CLUSCTL_NETWORK_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD            s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFENETWORK     shNetwork;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetwork( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        er = plOld.ScGetNetworkProperties(
            shNetwork,
            s_rgControl[ idx ].dwGetControl,
            NULL,
            NULL,
            0
            );

        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNetworkControl( 
                    shNetwork,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    static_cast< DWORD >( plNew.CbPropList() ),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterNetwork::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetwork::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CClusterNetwork::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNetwork::DeleteInstance()

//****************************************************************************
//
//  CClusterNetNetInterface
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ClusterNetNetInterface::CClusterNetNetInterface
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNetNetInterface::CClusterNetNetInterface(
    const WCHAR *   pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** ClusterNetNetInterface::ClusterNetNetInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  ClusterNetNetInterface::S_CreateThis
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNetNetInterface::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterNetNetInterface(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** ClusterNetNetInterface::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ClusterNetNetInterface::GetPropMap
//
//  Description:
//      Retrieve the property maping table of the cluster network net interface.
//
//  Arguments:
//      lFlagsIn    -- 
//      pCtxIn      -- 
//      pHandlerIn  -- 
//
//  Return Values:
//      Reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNetNetInterface::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wcoGroup;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
    DWORD               cbNetworkName = MAX_PATH;
    CWstrBuf            wsbNetworkName;
    HRESULT             hr;

    CComPtr< IEnumWbemClassObject > pEnum;

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );

    //
    // network interface objects
    //

    er = m_pNamespace->CreateInstanceEnum(
            _bstr_t( PVD_CLASS_NETWORKINTERFACE ),
            0,
            NULL,
            & pEnum
            );

    wsbNetworkName.SetSize( cbNetworkName );
    for ( ; ; )
    {
        CWbemClassObject    wcoNetInterface;
        DWORD               cWco;

        hr = pEnum->Next(
                5000,
                1,
                & wcoNetInterface,
                & cWco
                );
        if ( hr == WBEM_S_NO_ERROR )
        {
            SAFENETINTERFACE    shNetInterface;
            DWORD               cbReturn;
            CWbemClassObject    wco;

            wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_PROP_DEVICEID );
            shNetInterface = OpenClusterNetInterface( shCluster, bstrPart );

            dwError = ClusterNetInterfaceControl(
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NETWORK,
                            NULL,
                            0,
                            wsbNetworkName,
                            cbNetworkName,
                            & cbReturn
                            );
            if ( dwError == ERROR_MORE_DATA )
            {
                cbNetworkName = cbReturn;
                wsbNetworkName.SetSize( cbNetworkName );
                er = ClusterNetInterfaceControl(
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NETWORK,
                            NULL,
                            0,
                            wsbNetworkName,
                            cbNetworkName,
                            & cbReturn
                            );
            } // if: buffer is too small
            wcoGroup.SetProperty( wsbNetworkName, CLUSREG_NAME_NET_NAME );
            wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

            wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_RELPATH );
            m_pClass->SpawnInstance( 0, & wco );
            wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
            wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
            pHandlerIn->Indicate( 1, & wco );

        } // if: no error
        else
        {
            break;
        } // else S_FALSE, or error

    } // forever

    if ( FAILED ( hr ) )
    {
        er = hr;
    }

    return WBEM_S_NO_ERROR;

} //*** ClusterNetNetInterface::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNode.h
//
//  Implementation File:
//      ClusterNode.cpp
//
//  Description:
//      Definition of the CClusterNode class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CClusterNodeNetInterface;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNode
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNode : public CProvBase
{
//
// constructor
//
public:
    CClusterNode::CClusterNode(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNODE               hNodeIn,
        IWbemObjectSink *   pHandlerIn
      );

}; // class CClusterNode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNodeNetInterface
//
//  Description:
//      Implement cluster Node and netinterface association
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNodeNetInterface : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNodeNetInterface::CClusterNodeNetInterface(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );
    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNodeNetInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternodegroup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNodeGroup.cpp
//
//  Description:
//      Implementation of CClusterNodeGroup class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNodeGroup.h"

//****************************************************************************
//
//  CClusterNodeGroup
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNodeGroup::CClusterNodeGroup(
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNodeGroup::CClusterNodeGroup(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterNodeGroup::CClusterNodeGroup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNodeGroup::S_CreateThis(
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNodeGroup::S_CreateThis(
    const WCHAR *    pwszNameIn,
    CWbemServices *  pNamespaceIn,
    DWORD            dwEnumTypeIn
    )
{
    return new CClusterNodeGroup(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterNodeGroup::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeGroup::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances
//
//  Arguments:
//      lFlagsIn    -- 
//      pCtxIn      -- 
//      pHandlerIn  -- 
//
//  Return Values:
//      SCODE
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeGroup::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    LPCWSTR             pwszName = NULL;
    DWORD               cchNodeName = MAX_PATH;
    CWstrBuf            wsbNodeName;
    DWORD               cch;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 
    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );
    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );
    wsbNodeName.SetSize( cchNodeName );

    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        DWORD   dwState;
        cch = cchNodeName;
        wcoPart.SetProperty( pwszName, PVD_PROP_GROUP_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        shGroup = OpenClusterGroup( shCluster, pwszName );

        dwState = GetClusterGroupState( shGroup, wsbNodeName, & cch );
        if ( dwState == ClusterGroupStateUnknown )
        {
            dwError = GetLastError();
            if ( dwError == ERROR_MORE_DATA )
            {
                cchNodeName = ++ cch;
                wsbNodeName.SetSize( cch );
                GetClusterGroupState( shGroup, wsbNodeName, & cch );
            } // if: more data
            else
            {
                er = dwError;
            } // else 
        } // if: StateUnknown
        
        wcoGroup.SetProperty( wsbNodeName, CLUSREG_NAME_GRP_NAME );
        wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );
        
    } // while: more items to enumerate

    return WBEM_S_NO_ERROR;

} //*** CClusterNodeGroup::EnumInstance(()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternodegroup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterNodeGroup.h
//
//  Implementation File:
//      ClusterNodeGroup.cpp
//
//  Description:
//      Definition of the CClusterNodeGroup class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNodeGroup;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNodeGroup
//
//  Description:
//      Provider Implement for cluster Node Group
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNodeGroup : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNodeGroup::CClusterNodeGroup(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNodeGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternoderes.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterNodeRes.h
//
//  Implementation File:
//      ClusterNodeRes.cpp
//
//  Description:
//      Definition of the CClusterNodeRes class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterNodeRes;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNodeRes
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterNodeRes : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterNodeRes::CClusterNodeRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterNodeRes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternoderes.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name: CClusterNodeRes.cpp
//
//  Description:    
//      Implementation of CClusterNodeRes class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNodeRes.h"

//****************************************************************************
//
//  CClusterNodeRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNodeRes::CClusterNodeRes(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNodeRes::CClusterNodeRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterNodeRes::CClusterNodeRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterNodeRes::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           // dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node resource object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNodeRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterNodeRes(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterNodeRes::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum cluster Node resource instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszResName = NULL;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESOURCE );

    while ( ( pwszResName = cluEnum.GetNext() ) != NULL )
    {
        CClusPropList       theProp;
        CError              er;
        CWstrBuf            wsbNodeName;
        CWstrBuf            wsbResName;
        DWORD               cbNodeName = MAX_PATH;
        DWORD               cbResName = MAX_PATH;
        DWORD               cbBytesReturned;
        DWORD               dwState;
        DWORD               dwError;

        shResource = OpenClusterResource( shCluster, pwszResName );

        wsbNodeName.SetSize( cbNodeName  );
        wsbResName.SetSize( cbResName );

        dwError = ClusterResourceControl(
                        shResource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_NAME,                  // this control code
                        NULL,
                        0,
                        wsbResName,
                        cbResName,
                        & cbBytesReturned
                        );

        if ( dwError == ERROR_MORE_DATA )
        {
            cbResName = cbBytesReturned;
            wsbResName.SetSize( cbResName );
            er = ClusterResourceControl(
                        shResource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_NAME,
                        NULL,
                        0,
                        wsbResName,
                        cbResName,
                        & cbBytesReturned
                        );
        } // if: buffer was too small

        wcoPart.SetProperty( wsbResName, PVD_PROP_RES_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        dwState = GetClusterResourceState(
                        shResource,
                        wsbNodeName,
                        & cbNodeName,
                        NULL,
                        NULL
                        );
        if ( dwState == ClusterResourceStateUnknown )
        {
            er = GetLastError();
        }

        wcoGroup.SetProperty( wsbNodeName, PVD_PROP_NODE_NAME );
        wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR) bstrPart, PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );

    } // while more resources

    return WBEM_S_NO_ERROR;

} //*** CClusterNodeRes::EnumInstance()

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::GetObject(
//
//  Description:
//      Retrieve cluster node active resource object based given object path.
//
//  Arguments:
//      rObjPathIn      -- Object path to cluster object
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn 
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::ExecuteMethod(
//
//  Description:
//      Execute methods defined in the mof for cluster node resource.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::PutInstance(
//      CWbemClassObject &   rInstToPutIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterNodeRes::DeleteInstance(
//      CObjPath &           rObjPathIn,
//      long                 lFlagIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeRes::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNodeRes::DeleteInstance()
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusternode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name: CClusterNode.cpp
//
//  Description:    
//      Implementation of CClusterNode class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterNode.h"

//****************************************************************************
//
//  CClusterNode
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::CClusterNode
//
//  Description:
//      Constructor
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterNode::CClusterNode( 
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterNode::CClusterNode()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterNode::S_CreateThis
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNode::S_CreateThis( 
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterNode( pwszNameIn, pNamespaceIn );

} //*** CClusterNode::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RgGetPropMap
//
//  Description:
//      Retrieve the property mapping table of the cluster node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterNode::RgGetPropMap( void )
{

    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_NAME,
            CLUSREG_NAME_NODE_NAME,
            SZ_TYPE,
            READONLY
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return & s_pmea;

} //*** CClusterNode::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::EnumInstance
//
//  Description:
//      enum cluster instance
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    LPCWSTR         pwszNode;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum(
        shCluster,
        CLUSTER_ENUM_NODE );


    while ( ( pwszNode = cluEnum.GetNext() ) != NULL )
    {
        shNode = OpenClusterNode( shCluster, pwszNode );

        ClusterToWMI( shNode, pHandlerIn );

    } // while: more nodes

    return WBEM_S_NO_ERROR;

} //*** CClusterNode::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::ClusterToWMI
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hNodeIn         -- Handle to node
//      pHandlerIn      -- Pointer to WMI sink
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterNode::ClusterToWMI(
    HNODE               hNodeIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_NODE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CError              er;
    UINT                idx;

    m_pClass->SpawnInstance( 0, & wco );
    for ( idx = 0 ; idx < s_cControl; idx ++ )
    {
        CClusPropList pl;
        er = pl.ScGetNodeProperties(
                    hNodeIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );

    } // for: each control code

    {
        DWORD dwState = GetClusterNodeState( hNodeIn );

        wco.SetProperty( dwState, PVD_PROP_STATE );
    }

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;

        er = ClusterNodeControl( 
                hNodeIn,
                NULL,
                CLUSCTL_NODE_GET_CHARACTERISTICS,
                NULL,
                0,
                & dwOut,
                sizeof( DWORD ),
                & cbReturned
                );
        wco.SetProperty( dwOut, PVD_PROP_CHARACTERISTIC );

        er = ClusterNodeControl(
                hNodeIn,
                NULL,
                CLUSCTL_NODE_GET_FLAGS,
                NULL,
                0,
                & dwOut,
                sizeof( DWORD ),
                & cbReturned
                );
        wco.SetProperty( dwOut, PVD_PROP_FLAGS );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::GetObject
//
//  Description:
//      retrieve cluster node object based given object path
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    
    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode(
                shCluster,
                rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
                );

    ClusterToWMI( shNode, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterNode::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::ExecuteMethod
//      )
//
//  Description:
//      execute methods defined in the mof for cluster node
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNode::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::PutInstance
//
//  Description:
//      save this instance
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NODE_GET_COMMON_PROPERTIES,
            CLUSCTL_NODE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NODE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;

        er = plOld.ScGetNodeProperties(
                shNode,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL,
                0
                );
        
        CClusterApi::SetObjectProperties(
            RgGetPropMap(),
            plNew,
            plOld,
            rInstToPutIn,
            s_rgControl[ idx ].fPrivate
            );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNodeControl( 
                    shNode,
                    NULL,
                    s_rgControl[ idx ].dwSetControl,
                    plNew.PbPropList(),
                    static_cast< DWORD >( plNew.CbPropList() ),
                    NULL,
                    0,
                    NULL
                    );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterNode::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn  -- ObjPath for the instance to be deleted
//      lFlagIn     -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNode::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterNode::DeleteInstance()

//****************************************************************************
//
//  CClusterNodeNetInterface
//
//****************************************************************************

CClusterNodeNetInterface::CClusterNodeNetInterface(
    const WCHAR *   pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** ClusterNodeNetInterface::ClusterNodeNetInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  ClusterNodeNetInterface::S_CreateThis
//
//  Description:
//      Create a cluster Node Network Interface object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Str type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterNodeNetInterface::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterNodeNetInterface(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** ClusterNodeNetInterface::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ClusterNodeNetInterface::EnumInstance
//
//  Description:
//      Enumerate net interfaces for the node.
//
//  Arguments:
//      lFlagsIn        -- 
//      pCtxIn          -- 
//      pHandlerIn      -- 
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterNodeNetInterface::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER                     shCluster;
    CError                          er;
    DWORD                           dwError;
    CWbemClassObject                wcoGroup;
    _bstr_t                         bstrGroup;
    _bstr_t                         bstrPart;
    DWORD                           cbName = MAX_PATH;
    CWstrBuf                        wsbName;
    CComPtr< IEnumWbemClassObject > pEnum;
    HRESULT                         hr = WBEM_S_NO_ERROR;

    shCluster = OpenCluster( NULL );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );

    //
    // network interface objects
    //

    er = m_pNamespace->CreateInstanceEnum(
            _bstr_t( PVD_CLASS_NETWORKINTERFACE ),
            0,
            NULL,
            & pEnum
            );

    wsbName.SetSize( cbName );

    for( ; ; )
    {
        CWbemClassObject    wcoNetInterface;
        DWORD               cWco;

        hr = pEnum->Next(
                5000,
                1,
                & wcoNetInterface,
                & cWco
                );
        if ( hr == WBEM_S_NO_ERROR )
        {
            SAFENETINTERFACE    shNetInterface;
            DWORD               cbReturn;
            CWbemClassObject    wco;

            wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_PROP_DEVICEID );
            shNetInterface = OpenClusterNetInterface( shCluster, bstrPart );
            dwError = ClusterNetInterfaceControl( 
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbName,
                            cbName,
                            & cbReturn
                            );
            if ( dwError == ERROR_MORE_DATA )
            {
                cbName = cbReturn;
                wsbName.SetSize( cbName );
                er = ClusterNetInterfaceControl( 
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbName,
                            cbName,
                            & cbReturn
                            );
            } // if: more data

            wcoGroup.SetProperty( wsbName, PVD_PROP_NAME );
            wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

           wcoNetInterface.GetProperty( bstrPart, PVD_WBEM_RELPATH );
            m_pClass->SpawnInstance( 0, & wco );
            wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
            wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
            er = pHandlerIn->Indicate( 1, & wco );

        } // if: success
        else 
        {
            break;
        } // else: E_XXX, or S_FALSE

    } // forever

    if ( FAILED ( hr ) )
    {
       throw CProvException( hr );
    }

    return WBEM_S_NO_ERROR;

} //*** ClusterNodeNetInterface::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresdepres.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResDepRes.h
//
//  Implementation File:
//      ClusterResDepRes.cpp
//
//  Description:
//      Definition of the CClusterResDepRes class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResDepRes;
class CClusterToNode;
class CClusterHostedService;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResDepRes
//
//  Description:
//      Provider for cluster resource dependency
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResDepRes : public CClusterObjDep
{
//
// constructor
//
public:
    CClusterResDepRes::CClusterResDepRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterResDepRes

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterToNode
//
//  Description:
//      Provider for cluster resource dependency
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterToNode : public CClusterObjDep
{
//
// constructor
//
public:
    CClusterToNode::CClusterToNode(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterToNode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterHostedService
//
//  Description:
//      Provider for cluster resource dependency
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterHostedService : public CClusterObjDep
{
//
// constructor
//
public:
    CClusterHostedService::CClusterHostedService(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterHostedService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterobjassoc.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterObjAssoc.h
//
//  Implementation File:
//      ClusterObjAssoc.cpp
//
//  Description:
//      Definition of the CClusterObjAssoc class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ObjectPath.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterObjAssoc;
class CClusterObjDep;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterObjAssoc
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterObjAssoc : public CProvBaseAssociation
{
//
// constructor
//
public:
    CClusterObjAssoc::CClusterObjAssoc(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:
    
    DWORD               m_dwEnumType;
    _bstr_t             m_bstrPartComp;
    _bstr_t             m_bstrGroupComp;
    CWbemClassObject    m_wcoPart;
    CWbemClassObject    m_wcoGroup;

}; //*** class CClusterObjAssoc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterObjDep
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterObjDep : public CProvBaseAssociation
{
//
// constructor
//
public:
    CClusterObjDep::CClusterObjDep(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) = 0;

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

protected:
    DWORD               m_dwEnumType;
    CWbemClassObject    m_wcoAntecedent;
    CWbemClassObject    m_wcoDependent;

}; //*** class CClusterObjDep
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresnode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResNode.h
//
//  Implementation File:
//      ClusterResNode.cpp
//
//  Description:
//      Definition of the CClusterResNode class.
//
//  Author:
//      Ozan Ozhan (ozano)    1-JUN-2001
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResNode
//
//  Description:
//      Provider Implement for cluster Resource Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResNode : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterResNode::CClusterResNode(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance( 
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterResNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresdepres.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResDepRes.cpp
//
//  Description:    
//      Implementation of CClusterResDepRes class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResDepRes.h"

//****************************************************************************
//
//  CClusterResDepRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResDepRes::CClusterResDepRes(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResDepRes::CClusterResDepRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjDep( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterResDepRes::CClusterResDepRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResDepRes::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResDepRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterResDepRes(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterResDepRes::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResDepRes::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//    )
//
//  Description:
//      Enumerate dependencies of a resource.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResDepRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    LPCWSTR             pwszName = NULL;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoAntecedent;
    CWbemClassObject    wcoDependent;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
    DWORD               cchDepResName = MAX_PATH;
    CWstrBuf            wsbDepResName;


    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    m_wcoAntecedent.SpawnInstance( 0, & wcoAntecedent );
    m_wcoDependent.SpawnInstance( 0, & wcoDependent );

    wsbDepResName.SetSize( cchDepResName );
    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        DWORD           dwIndex = 0;
        DWORD           dwType;
        SAFERESOURCE    shResource;
        SAFERESENUM     shResEnum;

        shResource = OpenClusterResource( shCluster, pwszName );
        shResEnum = ClusterResourceOpenEnum( shResource, CLUSTER_RESOURCE_ENUM_DEPENDS );

        for ( ; ; )
        {
            DWORD cch = cchDepResName;

            dwError = ClusterResourceEnum(
                            shResEnum,
                            dwIndex++,
                            & dwType,
                            wsbDepResName,
                            & cch
                            );
            if ( dwError == ERROR_MORE_DATA )
            {
                cchDepResName = ++ cch ;
                wsbDepResName.SetSize( cch );
                dwError = ClusterResourceEnum(
                                shResEnum,
                                dwIndex++,
                                & dwType,
                                wsbDepResName,
                                & cch
                                );
            } // if: buffer was too small
            
            if ( dwError == ERROR_SUCCESS )
            {
                wcoAntecedent.SetProperty( pwszName, CLUSREG_NAME_RESTYPE_NAME );
                wcoAntecedent.GetProperty( bstrGroup, PVD_WBEM_RELPATH );
                
                wcoDependent.SetProperty( wsbDepResName, CLUSREG_NAME_RESTYPE_NAME );
                wcoDependent.GetProperty( bstrPart, PVD_WBEM_RELPATH );

                m_pClass->SpawnInstance( 0, & wco );
                wco.SetProperty( (LPWSTR) bstrGroup, PVD_WBEM_PROP_ANTECEDENT );
                wco.SetProperty( (LPWSTR) bstrPart,  PVD_WBEM_PROP_DEPENDENT );
                pHandlerIn->Indicate( 1, & wco );
            }
            else if ( dwError == ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            else
            {
                er = dwError;
            }
        } // forever
    } // while: more dependencies

    return WBEM_S_NO_ERROR;

} //*** CClusterResDepRes::EnumInstance()

//****************************************************************************
//
//  CClusterToNode
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterToNode::CClusterToNode(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterToNode::CClusterToNode(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjDep( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterToNode::CClusterToNode()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterToNode::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterToNode::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterToNode(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterToNode::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterToNode::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterToNode::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    LPCWSTR             pwszName = NULL;
    DWORD               cchClusterName = MAX_PATH;
    CWstrBuf            wsbClusterName;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wcoAntecedent;
    CWbemClassObject    wcoDependent;
    _bstr_t             bstrAntecedent;
    _bstr_t             bstrDependent;

    wsbClusterName.SetSize( cchClusterName );

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );
    dwError = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    & cchClusterName,
                    NULL
                    );

    if ( dwError == ERROR_MORE_DATA )
    {
        wsbClusterName.SetSize( ++ cchClusterName );
        er = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    & cchClusterName,
                    NULL
                    );
    }
    m_wcoAntecedent.SpawnInstance( 0, & wcoAntecedent );
    m_wcoDependent.SpawnInstance( 0, & wcoDependent );

    wcoAntecedent.SetProperty( wsbClusterName, PVD_PROP_NAME );
    wcoAntecedent.GetProperty( bstrAntecedent, PVD_WBEM_RELPATH );

    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        CWbemClassObject    wco;

        wcoDependent.SetProperty( pwszName, PVD_PROP_NAME );

        wcoDependent.GetProperty( bstrDependent, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrAntecedent, PVD_WBEM_PROP_ANTECEDENT );
        wco.SetProperty( (LPWSTR) bstrDependent,  PVD_WBEM_PROP_DEPENDENT );
        pHandlerIn->Indicate( 1, & wco );
    } // while: more properties

    return WBEM_S_NO_ERROR;

} //*** CClusterToNode::EnumInstance()

//****************************************************************************
//
//  CClusterHostedService
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterHostedService::CClusterHostedService(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumType
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterHostedService::CClusterHostedService(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjDep( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterHostedService::CClusterHostedService()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterHostedService::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a hostedservice.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterHostedService::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterHostedService(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterHostedService::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterHostedService::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enum instance of hostedservice
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterHostedService::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
//    SAFECLUSTER         shCluster;
    CError              er;
    CWbemClassObject    wcoAntecedent;
    _bstr_t             bstrAntecedent;
    _bstr_t             bstrDependent;
    CComPtr< IEnumWbemClassObject > pEnum;

//    shCluster = OpenCluster( NULL ); // DAVIDP: Why is this needed? 19-Jul-2000

    m_wcoAntecedent.SpawnInstance( 0, &wcoAntecedent );

    //
    // network interface objects
    //

    er = m_pNamespace->CreateInstanceEnum(
                _bstr_t( PVD_CLASS_SERVICES ),
                0,
                NULL,
                &pEnum
                );

    for( ; ; )
    {
        CWbemClassObject    wcoService;
        DWORD               cWco;
        HRESULT             hr;

        hr = pEnum->Next(
                5000,
                1,
                &wcoService,
                &cWco
                );
        if ( hr == WBEM_S_NO_ERROR )
        {
            CWbemClassObject    wco;

            wcoService.GetProperty( bstrAntecedent, PVD_PROP_SERVICE_SYSTEMNAME );

            wcoAntecedent.SetProperty( ( LPWSTR ) bstrAntecedent, PVD_PROP_NODE_NAME );
            wcoAntecedent.GetProperty( bstrAntecedent, PVD_WBEM_RELPATH );

            wcoService.GetProperty( bstrDependent, PVD_WBEM_RELPATH );
            m_pClass->SpawnInstance( 0, &wco );
            wco.SetProperty( ( LPWSTR ) bstrAntecedent, PVD_WBEM_PROP_ANTECEDENT );
            wco.SetProperty( ( LPWSTR ) bstrDependent, PVD_WBEM_PROP_DEPENDENT );
            pHandlerIn->Indicate( 1, &wco );
        }
        else
        {
            break;
        }

    } // forever

    return WBEM_S_NO_ERROR;

} //*** CClusterHostedService::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResNode.cpp
//
//  Description:
//      Implementation of CClusterResNode class 
//
//  Author:
//      Ozan Ozhan (ozano)    01-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResNode.h"

//****************************************************************************
//
//  CClusterResNode
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResNode::CClusterResNode(
//
//  Description:
//      Constructor for 'cluster resource to node' object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResNode::CClusterResNode(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterResNode::CClusterResNode()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResNode::S_CreateThis(
//
//  Description:
//      Create a 'cluster resource to node' object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResNode::S_CreateThis(
    LPCWSTR          pwszNameIn,
    CWbemServices *  pNamespaceIn,
    DWORD            dwEnumTypeIn
    )
{
    return new CClusterResNode(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterResNode::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResNode::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances
//
//  Arguments:
//      lFlagsIn    -- 
//      pCtxIn      -- 
//      pHandlerIn  -- 
//
//  Return Values:
//      SCODE
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResNode::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    SAFERESENUM         shResEnum;
    LPCWSTR             pwszResName = NULL;
    DWORD               cchNodeName = MAX_PATH;
    CWstrBuf            wsbNodeName;
    DWORD               cch;
    DWORD               dwError;
    DWORD               dwIndex;
    DWORD               dwType;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    while ( ( pwszResName = clusEnum.GetNext() ) != NULL )
    {

        shResource = OpenClusterResource( shCluster, pwszResName );

        shResEnum = ClusterResourceOpenEnum(
                        shResource,
                        CLUSTER_RESOURCE_ENUM_NODES
                        );
        dwIndex = 0;
        for( ; ; )
        {
            wsbNodeName.SetSize( cchNodeName );
            dwError = ClusterResourceEnum(
                        shResEnum,
                        dwIndex,
                        &dwType,
                        wsbNodeName,
                        &cch
                        );
            if ( dwError == ERROR_MORE_DATA )
            {
                cchNodeName = ++cch;
                wsbNodeName.SetSize( cch );
                dwError = ClusterResourceEnum(
                                shResEnum,
                                dwIndex,
                                &dwType,
                                wsbNodeName,
                                &cch
                                );
            } // if: more data

            if ( dwError == ERROR_SUCCESS )
            {
                m_wcoGroup.SpawnInstance( 0, & wcoGroup );
                m_wcoPart.SpawnInstance( 0, & wcoPart );
                wcoGroup.SetProperty( pwszResName, PVD_PROP_RES_NAME );
                wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );
                wcoPart.SetProperty( wsbNodeName, CLUSREG_NAME_RES_NAME );
                wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

                m_pClass->SpawnInstance( 0, & wco );
                wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
                wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
                pHandlerIn->Indicate( 1, & wco );
        
            } // if: success

            else
            {
                break;
            } // else

            dwIndex++;

        } // for: Possible Owners
   
    } // while: more items to enumerate

    return WBEM_S_NO_ERROR;

} //*** CClusterResNode::EnumInstance(()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterobjassoc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterObjAssoc.cpp
//
//  Description:    
//      Implementation of CClusterObjAssoc class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterObjAssoc.h"

//****************************************************************************
//
//  CClusterObjAssoc
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObjAssoc::CClusterObjAssoc(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
CClusterObjAssoc::CClusterObjAssoc(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CProvBaseAssociation( pwszNameIn, pNamespaceIn )
    , m_dwEnumType ( dwEnumTypeIn )
{
    _bstr_t bstrClassName;

    GetTypeName( bstrClassName, PVD_PROP_PARTCOMPONENT );
    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoPart,
        NULL
        );

    GetTypeName( bstrClassName, PVD_PROP_GROUPCOMPONENT );

    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoGroup,
        NULL
        );

} //*** CClusterObjAssoc::CClusterObjAssoc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterObjAssoc::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create an object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterObjAssoc::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterObjAssoc(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterObjAssoc::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterObjAssoc::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster object based on given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterObjAssoc::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    _bstr_t             bstrPart;
    _bstr_t             bstrGroup;
    CWbemClassObject    wco;

    bstrGroup = rObjPathIn.GetStringValueForProperty( PVD_PROP_GROUPCOMPONENT );
    bstrPart = rObjPathIn.GetStringValueForProperty( PVD_PROP_PARTCOMPONENT );

    m_pClass->SpawnInstance( 0, &wco );
    wco.SetProperty( ( LPWSTR ) bstrGroup, PVD_PROP_GROUPCOMPONENT );
    wco.SetProperty( ( LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
    pHandlerIn->Indicate( 1, &wco );
    
    return WBEM_S_NO_ERROR;

} //*** CClusterObjAssoc::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterObjAssoc::EnumInstance
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate instances.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      Status code.
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterObjAssoc::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszName = NULL;
    DWORD               cchClusterName = MAX_PATH;
    CWstrBuf            wsbClusterName;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CObjPath            opGroup;
    CWbemClassObject    wcoGroup;
    _bstr_t             bstrGroup;

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );
    wsbClusterName.SetSize( cchClusterName );
    dwError = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    & cchClusterName,
                    NULL
                    );
    if ( dwError == ERROR_MORE_DATA )
    {
        wsbClusterName.SetSize( ++ cchClusterName );
        er = GetClusterInformation(
                shCluster,
                wsbClusterName,
                & cchClusterName,
                NULL
                );
    } // if: buffer is too small

    m_wcoGroup.SpawnInstance( 0, &wcoGroup );
    wcoGroup.SetProperty( wsbClusterName, PVD_PROP_NAME );
    wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        CWbemClassObject    wcoPart;
        CWbemClassObject    wco;
        _bstr_t             bstrPart;

        m_wcoPart.SpawnInstance( 0, & wcoPart );
        
        if ( m_dwEnumType == CLUSTER_ENUM_NETINTERFACE )
        {
            SAFENETINTERFACE    shNetInterface;
            CWstrBuf            wsbNode;
            DWORD               cbNode = MAX_PATH;
            DWORD               cbReturn;

            wsbNode.SetSize( cbNode );
            shNetInterface = OpenClusterNetInterface( shCluster, pwszName );

            dwError = ClusterNetInterfaceControl(
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbNode,
                            cbNode,
                            & cbReturn
                            );

            if ( dwError == ERROR_MORE_DATA )
            {
                wsbNode.SetSize( cbReturn );
                er = ClusterNetInterfaceControl( 
                            shNetInterface,
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_NODE,
                            NULL,
                            0,
                            wsbNode,
                            cbNode,
                            & cbReturn
                            );
            } // if: buffer too small

            wcoPart.SetProperty( pwszName, PVD_PROP_NETINTERFACE_DEVICEID );
            wcoPart.SetProperty( wsbNode,  PVD_PROP_NETINTERFACE_SYSTEMNAME );
        } // if: found net interface
        else
        {
            wcoPart.SetProperty( pwszName, PVD_PROP_NAME );
        }

        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR ) bstrPart, PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );
        
    } // while: more net interfaces

    return WBEM_S_NO_ERROR;

} //*** CClusterObjAssoc::EnumInstance()

//****************************************************************************
//
//  CClusterObjDep
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObjDep::CClusterObjDep
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////
CClusterObjDep::CClusterObjDep(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CProvBaseAssociation( pwszNameIn, pNamespaceIn )
    , m_dwEnumType ( dwEnumTypeIn )
{
    _bstr_t bstrClassName;

    GetTypeName( bstrClassName, PVD_WBEM_PROP_ANTECEDENT );
    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoAntecedent,
        NULL
        );

    GetTypeName( bstrClassName, PVD_WBEM_PROP_DEPENDENT );

    pNamespaceIn->GetObject(
        bstrClassName,
        0,
        NULL,
        & m_wcoDependent,
        NULL
        );

} //*** CClusterObjDep::CClusterObjDep()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterObjDep::GetObject(
//      CObjPath &           rObjPathIn,
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Retrieve cluster object based on given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterObjDep::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    _bstr_t             bstrAntecedent;
    _bstr_t             bstrDependent;
    CWbemClassObject    wco;

    bstrAntecedent = rObjPathIn.GetStringValueForProperty( PVD_WBEM_PROP_ANTECEDENT );
    bstrDependent  = rObjPathIn.GetStringValueForProperty( PVD_WBEM_PROP_DEPENDENT );

    m_pClass->SpawnInstance( 0, & wco );
    wco.SetProperty( ( LPWSTR ) bstrAntecedent, PVD_WBEM_PROP_ANTECEDENT );
    wco.SetProperty( ( LPWSTR ) bstrDependent, PVD_WBEM_PROP_DEPENDENT );
    pHandlerIn->Indicate( 1, & wco );
    
    return WBEM_S_NO_ERROR;

} //*** CClusterObjDep::GetObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResource.h
//
//  Implementation File:
//      ClusterResource.cpp
//
//  Description:
//      Definition of the CClusterResource class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResource;
class CClusterClusterQuorum;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResource
//
//  Description:
//      Provider Implement for cluster resource
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResource : public CProvBase
{
//
// constructor
//
public:
    CClusterResource::CClusterResource(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:
//    static const PropMapEntryArray & RgGetPropMap( void );

    void ClusterToWMI(
        HRESOURCE            hResourceIn,
        IWbemObjectSink *    pHandlerIn
        );

}; //*** class CClusterResource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterClusterQuorum
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterClusterQuorum : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterClusterQuorum::CClusterClusterQuorum(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterClusterQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterResource.cpp
//
//  Description:    
//      Implementation of CClusterResource class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResource.h"
#include "ClusterResource.tmh"

#pragma warning( push )
#pragma warning( disable : 4663 ) // C++ language change: to explicitly specialize class template 'vector' use the following syntax:
#include <vector>
#pragma warning( pop )

//****************************************************************************
//
//  CClusterResource
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::CClusterResource
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResource::CClusterResource(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterResource::CClusterResource()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterResource::S_CreateThis
//
//  Description:
//      Create a resource object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResource::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterResource( pwszNameIn, pNamespaceIn );

} //*** CClusterResource::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::EnumInstance
//
//  Description:
//      Enumerate cluster resource instances.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CClusterResource::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shResource;
    LPCWSTR         pwszResName = NULL;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESOURCE );

    while ( ( pwszResName = cluEnum.GetNext() ) != NULL )
    {
        shResource = OpenClusterResource( shCluster, pwszResName );
        ClusterToWMI( shResource, pHandlerIn );

    } // while: more resources

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::EnumInstance()

// smart_bstr class to make LoadRegistryCheckpoints func exception safe
struct smart_bstr {
    BSTR data;
    smart_bstr():data(0){}
    ~smart_bstr() { SysFreeString(data); }
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LoadRegistryCheckpoints
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- Handle to resource
//      dwControlCode   -- show be one of the following
//          CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS
//          CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS
//      propName       -- property name to load checkpoints to
//      wco            -- property container
//
//  Return Values:
//      none
//--
//////////////////////////////////////////////////////////////////////////////

void
LoadRegistryCheckpoints(
    IN HRESOURCE          hResourceIn,
    IN DWORD dwControlCode,
    IN const WCHAR* propName,
    IN OUT CWbemClassObject &wco
    )
{
    DWORD cbReturned = 0;
    DWORD dwStatus;
    CError er;

    dwStatus = ClusterResourceControl(
                hResourceIn,
                NULL,
                dwControlCode,
                NULL,
                0,
                NULL,
                0,
                &cbReturned
                );
    if (dwStatus != ERROR_MORE_DATA) {
        er = dwStatus;
    }
    if (cbReturned == 0) {
        return; // no checkpoints
    }

    std::vector<WCHAR> checkpoints(cbReturned/sizeof(WCHAR)); 
    er = ClusterResourceControl(
                hResourceIn,
                NULL,
                dwControlCode,
                NULL,
                0,
                &checkpoints[0],
                (DWORD) ( checkpoints.size() * sizeof(WCHAR) ),
                &cbReturned
                );

    int nKeys = 0; // count how many keys are in the string
    for(UINT idx = 0; idx < checkpoints.size(); ++idx) {
        if (checkpoints[idx] == 0) {
            ++nKeys;
            if (idx > 0 && checkpoints[idx-1] == 0) {
                break; // double null
            }
        }
    }

    std::vector<smart_bstr> bstrs(nKeys);
    WCHAR* p = &checkpoints[0]; 
    for(int idx = 0; idx < nKeys; ++idx) {
        bstrs[idx].data = SysAllocString( p );
        p += wcslen(p) + 1;
    }

    wco.SetProperty(nKeys, &bstrs[0].data, propName);
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::ClusterToWMI
//
//  Description:
//      Translate a cluster resource objects to WMI object.
//
//  Arguments:
//      hResourceIn     -- Handle to resource
//      pHandlerIn      -- Pointer to WMI sink
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterResource::ClusterToWMI(
    HRESOURCE            hResourceIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    CWbemClassObject    wcoPrivate;
    CWbemClassObject    wcoClass;
    CError              er;
    DWORD               dwStatus;
    UINT                idx;
    CWstrBuf            wsbTypeName ;
    DWORD               cbTypeName = MAX_PATH;
    DWORD               cbTypeNameReturned = 0;

    //
    // get type name and corresponding property class
    //
    wsbTypeName.SetSize( cbTypeName );
    dwStatus = ClusterResourceControl(
                        hResourceIn,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        wsbTypeName,
                        cbTypeName,
                        &cbTypeNameReturned
                        );
    if ( dwStatus == ERROR_MORE_DATA )
    {
        cbTypeName = cbTypeNameReturned;
        wsbTypeName.SetSize( cbTypeName );
        er = ClusterResourceControl( 
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                    NULL,
                    0,
                    wsbTypeName,
                    cbTypeName,
                    &cbTypeNameReturned
                    );
    }
    er = dwStatus;
    er = m_pNamespace->GetObject(
                            g_TypeNameToClass[ static_cast<LPWSTR> ( wsbTypeName ) ],
                            0,
                            0,
                            &wcoClass,
                            NULL
                            );
    er = wcoClass.data()->SpawnInstance( 0, & wcoPrivate );
    m_pClass->SpawnInstance( 0, & wco );

    //
    // get properties from property list
    //
    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList       pl;
        CWbemClassObject    wcoTemp;
        er = pl.ScGetResourceProperties(
                    hResourceIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );
        if ( s_rgControl[ idx ].fPrivate )
        {
            wcoTemp = wcoPrivate;
        }
        else
        {
            wcoTemp = wco;
        }

        CClusterApi::GetObjectProperties(
            NULL,
            pl,
            wcoTemp,
            s_rgControl[ idx ].fPrivate
            );
    
    } // for: each control code

    wco.SetProperty(
        wcoPrivate.data(),
        PVD_PROP_RES_PRIVATE );

    {
        DWORD dwState = GetClusterResourceState(
                            hResourceIn,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            );
        wco.SetProperty( dwState, PVD_PROP_RES_STATE );
    }

    LoadRegistryCheckpoints(hResourceIn, 
        CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS, PVD_PROP_RES_CHECKPOINTS, wco);
    LoadRegistryCheckpoints(hResourceIn, 
        CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS, PVD_PROP_RES_CRYPTO_CHECKPOINTS, wco); 

    //
    // flags and characteristics
    //
    {
        DWORD   cbReturned;
        DWORD   dwOut;
        er = ClusterResourceControl(
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_CHARACTERISTIC );

        wco.SetProperty( dwOut & CLUS_CHAR_QUORUM, PVD_PROP_RESTYPE_QUORUM_CAPABLE );
        wco.SetProperty( dwOut & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES, PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES );
        wco.SetProperty( dwOut & CLUS_CHAR_LOCAL_QUORUM, PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE );

        er = ClusterResourceControl(
                    hResourceIn,
                    NULL,
                    CLUSCTL_RESOURCE_GET_FLAGS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_FLAGS );

        wco.SetProperty( dwOut & CLUS_FLAG_CORE, PVD_PROP_RES_CORE_RESOURCE );
    }

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::GetObject
//
//  Description:
//      Retrieve cluster resourcee object based on given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shRes;

    shCluster = OpenCluster( NULL );
    shRes = OpenClusterResource(
                shCluster,
                rObjPathIn.GetStringValueForProperty( CLUSREG_NAME_RES_NAME )
                );

    ClusterToWMI( shRes, pHandlerIn );
    return WBEM_S_NO_ERROR;

} //*** CClusterResource::GetObject()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  AddRemoveCheckpoint
//
//  Description:
//      Adds/Removes regular/crypto checkpoint.
//
//  Arguments:
//      hResourceIn     -- Handle to resource
//      dwControlCode   -- clusapi control code
//      wcoInputParam   -- property container
//
//  Return Values:
//      none
//--
//////////////////////////////////////////////////////////////////////////////
void AddRemoveCheckpoint(
    IN HRESOURCE          hResourceIn,
    IN CWbemClassObject& wcoInputParam, 
    IN DWORD dwControlCode
    )
{
    CError er;
    _bstr_t keyName;

    wcoInputParam.GetProperty( keyName, PVD_MTH_PARM_RES_CHECKPOINT_NAME );
    er = ClusterResourceControl(
                hResourceIn,
                NULL,
                dwControlCode,
                (wchar_t*)keyName,
                SysStringByteLen(keyName) + sizeof(WCHAR),
                NULL,
                0,
                NULL
                );

}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::ExecuteMethod
//
//  Description:
//      Execute methods defined in the mof for cluster resource.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    ) 
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shRes;
    CWbemClassObject    wcoInputParm( pParamsIn );

    shCluster = OpenCluster( NULL );

    //
    // static method
    //
    if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_CREATE_RESOURCE ) == 0 )
    {
        _bstr_t         bstrTargetGroup;
        _bstr_t         bstrResource;
        BOOL            bSeperateMonitor;
        _bstr_t         bstrResourceType;
        SAFERESOURCE    shNewResource;
        SAFEGROUP       shGroup;

        wcoInputParm.GetProperty( bstrTargetGroup, PVD_MTH_PARM_GROUP );
        wcoInputParm.GetProperty( bstrResource, PVD_MTH_PARM_RES_NAME );
        wcoInputParm.GetProperty( bstrResourceType, PVD_MTH_PARM_RES_TYPE );
        wcoInputParm.GetProperty( &bSeperateMonitor, PVD_MTH_PARM_SEP_MONITOR );

        shGroup = OpenClusterGroup( shCluster, bstrTargetGroup );
        shNewResource = CreateClusterResource(
                            shGroup,
                            bstrResource,
                            bstrResourceType,
                            bSeperateMonitor
                            );
    } // if: CREATE_RESOURCE
    else
    {
        shRes = OpenClusterResource(
                    shCluster,
                    rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME )
                    );

        if( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_DELETE_RESOURCE ) == 0 )
        {
            return DeleteClusterResource( shRes );
        }
        else if( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_OFFLINE ) == 0 )
        {
            DWORD dwTimeOut = 0;
            wcoInputParm.GetProperty( &dwTimeOut, PVD_MTH_PARM_RES_TIMEOUT );
            return HrWrapOfflineClusterResource( shCluster, shRes, dwTimeOut);
        } // if: OFFLINE
        else if( ClRtlStrICmp(  pwszMethodNameIn, PVD_MTH_RES_ONLINE ) == 0 )
        {
            DWORD dwTimeOut = 0;
            wcoInputParm.GetProperty( &dwTimeOut, PVD_MTH_PARM_RES_TIMEOUT );
            return HrWrapOnlineClusterResource( shCluster, shRes, dwTimeOut);
        } // else if: ONLINE
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_CHANGE_GROUP ) == 0 )
        {
            _bstr_t     bstrGroupObjpath;
            SAFEGROUP   shGroup;
            CError      er;

            wcoInputParm.GetProperty( bstrGroupObjpath, PVD_MTH_PARM_GROUP );
            shGroup = OpenClusterGroup( shCluster, bstrGroupObjpath );
            er = ChangeClusterResourceGroup( shRes, shGroup );
        } // else if: CHANGE_GROUP
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_ADD_DEPENDENCY ) == 0 )
        {
            _bstr_t         bstrDepResource;
            SAFERESOURCE    shDepResource;
            CError          er;

            wcoInputParm.GetProperty( bstrDepResource, PVD_MTH_PARM_RESOURCE );
            shDepResource = OpenClusterResource( shCluster, bstrDepResource );
            er = AddClusterResourceDependency( shRes, shDepResource );
        } // else if: ADD_DEPENDENCY
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_REMOVE_DEPENDENCY ) == 0 )
        {
            _bstr_t         bstrDepResource;
            SAFERESOURCE    shDepResource;
            CError          er;

            wcoInputParm.GetProperty( bstrDepResource, PVD_MTH_PARM_RESOURCE );
            shDepResource = OpenClusterResource( shCluster, bstrDepResource );
            er = RemoveClusterResourceDependency( shRes, shDepResource );
        } // else if: REMOVE_DEPENDENCY
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_ADD_REG_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT);
        }
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_DEL_REG_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT);
        }
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_ADD_CRYPTO_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT);
        }
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_DEL_CRYPTO_CHECKPOINT ) == 0 )
        {
            AddRemoveCheckpoint(shRes, wcoInputParm, CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT);
        }
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_FAIL_RESOURCE ) == 0 )
        {
           CError   er;
           er = FailClusterResource( shRes );
        } // if: FAIL_RESOURCE
        else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RES_RENAME ) == 0 )
        {
            _bstr_t         bstrName;
            CError          er;

            wcoInputParm.GetProperty( bstrName, PVD_MTH_PARM_NEWNAME );
            er = SetClusterResourceName( shRes, bstrName );
        } // if: RENAME
        else 
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    } // else: not CREATE_RESOURCE

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::PutInstance
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn 
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES,
            CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shResource;
    CError          er;
    UINT            idx;

    TracePrint(( "CClusterResource::PutInstance entry\n" ));

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );
    shResource = OpenClusterResource( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList       plOld;
        CClusPropList       plNew;
        CWbemClassObject    wco;

        if ( s_rgControl[ idx ].fPrivate )
        {
            rInstToPutIn.GetProperty( wco, PVD_PROP_RES_PRIVATE );
        }
        else
        {
            wco = rInstToPutIn;
        }
        er = plOld.ScGetResourceProperties(
                    shResource,
                    s_rgControl[ idx ].dwGetControl,
                    NULL,
                    NULL,
                    0
                    );

        CClusterApi::SetObjectProperties(
                    NULL,
                    plNew,
                    plOld,
                    wco,
                    s_rgControl[ idx ].fPrivate
                    );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterResourceControl(
                        shResource,
                        NULL,
                        s_rgControl[ idx ].dwSetControl,
                        plNew.PbPropList(),
                        static_cast< DWORD >( plNew.CbPropList() ),
                        NULL,
                        0,
                        NULL
                        );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResource::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResource::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFERESOURCE    shRes;
    CError          er;

    shCluster = OpenCluster( NULL );
    shRes = OpenClusterResource(
                shCluster,
                rObjPathIn.GetStringValueForProperty( CLUSREG_NAME_RES_NAME )
                );
    er = HrWrapOfflineClusterResource( shCluster, shRes );
    er = DeleteClusterResource( shRes );

    return WBEM_S_NO_ERROR;

} //*** CClusterResource::DeleteInstance()


//****************************************************************************
//
//  CClusterClusterQuorum
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterClusterQuorum::CClusterClusterQuorum
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterClusterQuorum::CClusterClusterQuorum(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterClusterQuorum::CClusterClusterQuorum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterClusterQuorum::S_CreateThis
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterClusterQuorum::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterClusterQuorum(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterClusterQuorum::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterClusterQuorum::EnumInstance
//
//  Description:
//      Enumerate instances of cluster quorum
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterClusterQuorum::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    DWORD               cchResName = MAX_PATH;
    CWstrBuf            wsbResName;
    DWORD               cchDeviceName = MAX_PATH;
    CWstrBuf            wsbDeviceName;
    DWORD               cchClusterName = MAX_PATH;
    CWstrBuf            wsbClusterName;
    DWORD               dwLogsize;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;
 
    wsbResName.SetSize( cchResName );
    wsbDeviceName.SetSize( cchDeviceName );
    wsbClusterName.SetSize( cchClusterName );

    shCluster = OpenCluster( NULL );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );


    dwError = GetClusterQuorumResource(
                    shCluster,
                    wsbResName,
                    &cchResName,
                    wsbDeviceName,
                    &cchDeviceName,
                    &dwLogsize
                    );
    if ( dwError == ERROR_MORE_DATA )
    {
        wsbResName.SetSize( ++cchResName );
        wsbDeviceName.SetSize( ++cchDeviceName );
        
        er = GetClusterQuorumResource(
                    shCluster,
                    wsbResName,
                    &cchResName,
                    wsbDeviceName,
                    &cchDeviceName,
                    &dwLogsize
                    );
    } // if: buffer was too small

   dwError = GetClusterInformation(
                    shCluster,
                    wsbClusterName,
                    &cchClusterName,
                    NULL
                    );
    if ( dwError == ERROR_MORE_DATA )
    {
        wsbClusterName.SetSize( ++cchClusterName );
        er = GetClusterInformation(
                shCluster,
                wsbClusterName,
                &cchClusterName,
                NULL
                );
    } // if: buffer was too small

    wcoPart.SetProperty( wsbResName, PVD_PROP_NAME );
    wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

    wcoGroup.SetProperty( wsbClusterName, PVD_PROP_NAME );
    wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

    m_pClass->SpawnInstance( 0, &wco );
    wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
    wco.SetProperty( (LPWSTR) bstrPart,  PVD_PROP_PARTCOMPONENT );
    pHandlerIn->Indicate( 1, &wco );
        
    return WBEM_S_NO_ERROR;

} //*** ClusterClusterQuorum::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterrestyperes.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResTypeRes.h
//
//  Implementation File:
//      ClusterResTypeRes.cpp
//
//  Description:
//      Definition of the CClusterResTypeRes class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResTypeRes;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResTypeRes
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResTypeRes : public CClusterObjAssoc
{
//
// constructor
//
public:
    CClusterResTypeRes::CClusterResTypeRes(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

}; //*** class CClusterResTypeRes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresourcetype.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResourceType.h
//
//  Implementation File:
//      ClusterResourceType.cpp
//
//  Description:
//      Definition of the CClusterResourceType class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterResourceType;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterResourceType
//
//  Description:
//      Provider Implement for cluster resource type
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterResourceType : public CProvBase
{
//
// constructor
//
public:
    CClusterResourceType::CClusterResourceType(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HCLUSTER             hClusterIn,
        LPCWSTR              pwszNameIn,
        IWbemObjectSink *    pHandlerIn
      );

}; //*** class CClusterResourceType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterrestyperes.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterResTypeRes.cpp
//
//  Description:
//      Implementation of CClusterResTypeRes class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResTypeRes.h"

//****************************************************************************
//
//  CClusterResTypeRes
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResTypeRes::CClusterResTypeRes(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResTypeRes::CClusterResTypeRes(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
    : CClusterObjAssoc( pwszNameIn, pNamespaceIn, dwEnumTypeIn )
{

} //*** CClusterResTypeRes::CClusterResTypeRes()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CProvBase *
//  CClusterResTypeRes::S_CreateThis(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn,
//      DWORD           dwEnumTypeIn
//      )
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResTypeRes::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           dwEnumTypeIn
    )
{
    return new CClusterResTypeRes(
                    pwszNameIn,
                    pNamespaceIn,
                    dwEnumTypeIn
                    );

} //*** CClusterResTypeRes::S_CreateThis()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CClusterResTypeRes::EnumInstance(
//      long                 lFlagsIn,
//      IWbemContext *       pCtxIn,
//      IWbemObjectSink *    pHandlerIn
//      )
//
//  Description:
//      Enumerate resources of a particular type.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResTypeRes::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    LPCWSTR             pwszName = NULL;
    DWORD               cbTypeName = MAX_PATH;
    CWstrBuf            wsbTypeName;
    CError              er;
    DWORD               dwError;
    CWbemClassObject    wco;
    CWbemClassObject    wcoGroup;
    CWbemClassObject    wcoPart;
    _bstr_t             bstrGroup;
    _bstr_t             bstrPart;

    wsbTypeName.SetSize( cbTypeName ); 

    shCluster = OpenCluster( NULL );
    CClusterEnum clusEnum( shCluster, m_dwEnumType );

    m_wcoGroup.SpawnInstance( 0, & wcoGroup );
    m_wcoPart.SpawnInstance( 0, & wcoPart );

    while ( ( pwszName = clusEnum.GetNext() ) != NULL )
    {
        DWORD cbTypeNameReturned = 0;
        shResource = OpenClusterResource( shCluster, pwszName );
        //
        // get resource type name
        //
        dwError = ClusterResourceControl(
                        shResource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        wsbTypeName,
                        cbTypeName,
                        & cbTypeNameReturned
                        );
        if ( dwError == ERROR_MORE_DATA )
        {
            cbTypeName = cbTypeNameReturned;
            wsbTypeName.SetSize( cbTypeNameReturned );
            er = ClusterResourceControl(
                        shResource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        wsbTypeName,
                        cbTypeName,
                        & cbTypeNameReturned
                        );
        } // if: buffer was too small

        wcoPart.SetProperty( pwszName, CLUSREG_NAME_RES_NAME );
        wcoPart.GetProperty( bstrPart, PVD_WBEM_RELPATH );

        
        wcoGroup.SetProperty( wsbTypeName, PVD_PROP_RESTYPE_NAME );
        wcoGroup.GetProperty( bstrGroup, PVD_WBEM_RELPATH );

        m_pClass->SpawnInstance( 0, & wco );
        wco.SetProperty( (LPWSTR) bstrGroup, PVD_PROP_GROUPCOMPONENT );
        wco.SetProperty( (LPWSTR) bstrPart,  PVD_PROP_PARTCOMPONENT );
        pHandlerIn->Indicate( 1, & wco );
        
    } // while: more resource types (??

    return WBEM_S_NO_ERROR;

} //*** CClusterResTypeRes::EnumInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterresourcetype.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterResourceType.cpp
//
//  Description:
//      Implementation of ClusterResourceType class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterResourceType.h"
#include "ClusterResourceType.tmh"

//****************************************************************************
//
//  CClusterResourceType
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::CClusterResourceType
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterResourceType::CClusterResourceType(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterResourceType::CClusterResourceType()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterResourceType::S_CreateThis
//
//  Description:
//      Create a CClusterResourceType object.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      Pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterResourceType::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterResourceType( pwszNameIn, pNamespaceIn );

} //*** CClusterResourceType::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::RgGetPropMap
//
//  Description:
//      Retrieve the property maping table of the cluster resource type.
//
//  Arguments:
//      none
//
//  Return Values:
//      Reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterResourceType::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            NULL,
            CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,
            SZ_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof ( s_rgpm ) / sizeof ( SPropMapEntry ),
                s_rgpm
                );

    return & s_pmea;

} //*** CClusterResourceType::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::EnumInstance
//
//  Description:
//      Enum resource types
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    LPCWSTR         pwszResType;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESTYPE );


    while ( ( pwszResType = cluEnum.GetNext() ) != NULL )
    {
        ClusterToWMI( shCluster, pwszResType, pHandlerIn );
    } // while: more resource types

    return WBEM_S_NO_ERROR;

} //*** CClusterResourceType::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::ClusterToWMI
//
//  Description:
//      translate a resource type object to WMI object
//
//  Arguments:
//      hClusterIn      -- Handle to cluster
//      pwszNameIn      -- Name of the cluster object
//      pHandlerIn      -- WMI sink
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterResourceType::ClusterToWMI(
    HCLUSTER             hClusterIn,
    LPCWSTR              pwszNameIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES,   FALSE },
        { CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES,      FALSE },
        { CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES,  TRUE },
        { CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES,     TRUE },
    };
    static UINT         s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    DWORD               nStatus = ERROR_SUCCESS;
    CError              er;
    UINT                idx;
    CWbemClassObject    wco;

    TracePrint(( "ClusterToWMI entry for %ws\n", pwszNameIn ));

    m_pClass->SpawnInstance( 0, &wco );
    for ( idx = 0 ; idx < s_cControl ; idx++ )
    {
        CClusPropList pl;
        nStatus = pl.ScGetResourceTypeProperties(
                    hClusterIn,
                    pwszNameIn,
                    s_rgControl[ idx ].dwControl,
                    NULL,
                    0
                    );

        if ( nStatus == ERROR_SUCCESS )
        {
            CClusterApi::GetObjectProperties(
                RgGetPropMap(),
                pl,
                wco,
                s_rgControl[ idx ].fPrivate
                );
        }
        else
        {
            TracePrint(( "ScGetResourceTypeProps failed - throw exception, status = %u\n", nStatus ));
            CProvException prove( nStatus );
            wco.SetProperty( prove.PwszErrorMessage(), PVD_WBEM_STATUS );
        }

    } // for: each control code

    //
    // flags and characteristics
    //
    if ( nStatus == ERROR_SUCCESS )
    {
        DWORD   cbReturned;
        DWORD   dwOut;

        er = ClusterResourceTypeControl( 
                    hClusterIn,
                    pwszNameIn,
                    NULL,
                    CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_CHARACTERISTIC );

        wco.SetProperty( dwOut & CLUS_CHAR_QUORUM, PVD_PROP_RESTYPE_QUORUM_CAPABLE );
        wco.SetProperty( dwOut & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES, PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES );
        wco.SetProperty( dwOut & CLUS_CHAR_LOCAL_QUORUM, PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE );

        er = ClusterResourceTypeControl( 
                    hClusterIn,
                    pwszNameIn,
                    NULL,
                    CLUSCTL_RESOURCE_TYPE_GET_FLAGS,
                    NULL,
                    0,
                    &dwOut,
                    sizeof( DWORD ),
                    &cbReturned
                    );
        wco.SetProperty( dwOut, PVD_PROP_FLAGS );
    } // for: each control code


    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResourceType::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::GetObject
//
//  Description:
//      Retrieve cluster group object based given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;

    shCluster = OpenCluster( NULL );
        
    ClusterToWMI(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_NAME ),
        pHandlerIn
        );

    return WBEM_S_NO_ERROR;
        
} //*** CClusterResourceType::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::ExecuteMethod
//
//  Description:
//      Execute methods defined in the mof for cluster resource type.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    CWbemClassObject    InArgs( pParamsIn );
    CError              er;
    _bstr_t             bstrNewResType;

    shCluster = OpenCluster( NULL );
    //
    // static method
    //
    if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RESTYPE_CREATE_RESOURCETYPE ) == 0 )
    {
        _bstr_t         bstrDisplayName;
        _bstr_t         bstrDLLName;
        DWORD           dwLooksAlivePollInterval = 0;
        DWORD           dwIsAlivePollInterval = 0;

        InArgs.GetProperty( bstrNewResType, PVD_MTH_RESTYPE_PARM_RESTYPE_NAME );
        InArgs.GetProperty( bstrDisplayName, PVD_MTH_RESTYPE_PARM_RESTYPE_DISPLAYNAME );
        InArgs.GetProperty( bstrDLLName, PVD_MTH_RESTYPE_PARM_RESTYPE_DLLNAME );
        InArgs.GetProperty( &dwLooksAlivePollInterval, PVD_MTH_RESTYPE_PARM_RESTYPE_LOOKSALIVE );
        InArgs.GetProperty( &dwIsAlivePollInterval, PVD_MTH_RESTYPE_PARM_RESTYPE_ISALIVE );

        er = CreateClusterResourceType( 
                      shCluster
                    , bstrNewResType
                    , bstrDisplayName
                    , bstrDLLName
                    , dwLooksAlivePollInterval
                    , dwIsAlivePollInterval
                    );
        
    }
    else if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_RESTYPE_DELETE_RESOURCETYPE ) == 0 )
    {
        er = DeleteClusterResourceType( shCluster,  rObjPathIn.GetStringValueForProperty( PVD_PROP_RESTYPE_NAME ) );
    }
    
    return WBEM_S_NO_ERROR;

} //*** CClusterResourceType::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::PutInstance
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        { 
            CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES,
            CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES,
            FALSE
        },
        { 
            CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static  DWORD   s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    CError          er;
    UINT    idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_NAME );

    shCluster = OpenCluster( NULL );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        er = plOld.ScGetResourceTypeProperties(
                shCluster,
                bstrName,
                s_rgControl[ idx ].dwGetControl,
                NULL,
                NULL
                );

        CClusterApi::SetObjectProperties(
                RgGetPropMap(),
                plNew,
                plOld,
                rInstToPutIn,
                s_rgControl[ idx ].fPrivate
                );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterResourceTypeControl( 
                        shCluster,
                        bstrName,
                        NULL,
                        s_rgControl[ idx ].dwSetControl,
                        plNew.PbPropList(),
                        static_cast< DWORD >( plNew.CbPropList() ),
                        NULL,
                        0,
                        NULL
                        );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterResourceType::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterResourceType::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterResourceType::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterResourceType::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterservice.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterService.h
//
//  Implementation File:
//      ClusterService.cpp
//
//  Description:
//      Definition of the CClusterService class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ProvBase.h"
#include "ClusterObjAssoc.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CClusterService;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterService
//
//  Description:
//      Provider Implement for cluster Node
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusterService : public CProvBase
{
//
// constructor
//
public:
    CClusterService::CClusterService(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

//
// methods
//
public:

    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    virtual SCODE PutInstance( 
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        );

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ); 

    static CProvBase * S_CreateThis(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn,
        DWORD           dwEnumTypeIn
        );

protected:

    static const SPropMapEntryArray * RgGetPropMap( void );

    void ClusterToWMI(
        HNODE               hNodeIn,
        IWbemObjectSink *   pHandlerIn
        );

}; //*** class CClusterService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterservice.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterService.cpp
//
//  Description:    
//      Implementation of CClusterService class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusterService.h"

//****************************************************************************
//
//  CClusterService
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::CClusterService
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusterService::CClusterService(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : CProvBase( pwszNameIn, pNamespaceIn )
{

} //*** CClusterService::CClusterService()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterService::S_CreateThis
//
//  Description:
//      Create a cluster node object
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//      dwEnumTypeIn    -- Type id
//
//  Return Values:
//      pointer to the CProvBase
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase *
CClusterService::S_CreateThis(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn,
    DWORD           // dwEnumTypeIn
    )
{
    return new CClusterService( pwszNameIn, pNamespaceIn );

} //*** CClusterService::S_CreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::RgGetPropMap
//
//  Description:
//      Retrieve the property mapping table of the cluster node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Reference to the array of property maping table.
//
//--
//////////////////////////////////////////////////////////////////////////////
const SPropMapEntryArray *
CClusterService::RgGetPropMap( void )
{
    static SPropMapEntry s_rgpm[] =
    {
        {
            PVD_PROP_SERVICE_SYSTEMNAME,
            CLUSREG_NAME_NODE_NAME, 
            SZ_TYPE,
            READONLY
        },
        {
            NULL,
            CLUSREG_NAME_NODE_DESC,
            SZ_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NODE_MAJOR_VERSION,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NODE_MINOR_VERSION,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL, 
            CLUSREG_NAME_NODE_BUILD_NUMBER,
            DWORD_TYPE,
            READWRITE
        },
        {
            NULL,
            CLUSREG_NAME_NODE_CSDVERSION,
            DWORD_TYPE,
            READWRITE
        }
    };

    static SPropMapEntryArray   s_pmea(
                sizeof( s_rgpm ) / sizeof( SPropMapEntry ),
                s_rgpm
                );

    return &s_pmea;

} //*** CClusterService::RgGetPropMap()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::EnumInstance
//
//  Description:
//      Enumerate cluster instance.
//
//  Arguments:
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::EnumInstance(
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    LPCWSTR         pwszNode;

    shCluster = OpenCluster( NULL );
    CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_NODE );

    while ( ( pwszNode = cluEnum.GetNext() ) != NULL )
    {
        shNode = OpenClusterNode( shCluster, pwszNode );

        ClusterToWMI( shNode, pHandlerIn );

    } // while: more nodes

    return WBEM_S_NO_ERROR;

} //*** CClusterService::EnumInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::ClusterToWMI
//
//  Description:
//      Translate a cluster node object to WMI object.
//
//  Arguments:
//      hNodeIn         -- Handle to node.
//      pHandlerIn      -- WMI sink 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusterService::ClusterToWMI(
    HNODE               hNodeIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    static SGetControl  s_rgControl[] =
    {
        { CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES,    FALSE },
        { CLUSCTL_NODE_GET_COMMON_PROPERTIES,       FALSE },
        { CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES,   TRUE },
        { CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,      TRUE }
    };
    static DWORD        s_cControl = sizeof( s_rgControl ) / sizeof( SGetControl );

    CWbemClassObject    wco;
    UINT                idx;
    CError              er;

    m_pClass->SpawnInstance( 0, & wco );
    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList pl;
        er = pl.ScGetNodeProperties(
                hNodeIn,
                s_rgControl[ idx ].dwControl,
                NULL,
                0
                );

        CClusterApi::GetObjectProperties(
            RgGetPropMap(),
            pl,
            wco,
            s_rgControl[ idx ].fPrivate
            );
        
    } // for: each control code
    
    wco.SetProperty( L"ClusterService", PVD_PROP_SERVICE_NAME );

    pHandlerIn->Indicate( 1, & wco );
    return;

} //*** CClusterResource::ClusterToWMI()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::GetObject
//
//  Description:
//      Retrieve cluster node object based given object path.
//
//  Arguments:
//      rObjPathIn  -- Object path to cluster object
//      lFlagsIn    -- WMI flag
//      pCtxIn      -- WMI context
//      pHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::GetObject(
    CObjPath &           rObjPathIn,
    long                 lFlagsIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn 
    )
{
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode(
                shCluster,
                rObjPathIn.GetStringValueForProperty( PVD_PROP_SERVICE_SYSTEMNAME )
                );

    ClusterToWMI( shNode, pHandlerIn );

    return WBEM_S_NO_ERROR;

} //*** CClusterService::GetObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::ExecuteMethod
//
//  Description:
//      Execute methods defined in the mof for cluster node.
//
//  Arguments:
//      rObjPathIn          -- Object path to cluster object
//      pwszMethodNameIn    -- Name of the method to be invoked
//      lFlagIn             -- WMI flag
//      pParamsIn           -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::ExecuteMethod(
    CObjPath &           rObjPathIn,
    WCHAR *              pwszMethodNameIn,
    long                 lFlagIn,
    IWbemClassObject *   pParamsIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENODE            shNode;
    CError              er;
    
    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode(
        shCluster,
        rObjPathIn.GetStringValueForProperty( PVD_PROP_SERVICE_SYSTEMNAME )
        );

    if ( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_SERVICE_PAUSE ) == 0 )
    {
        er = PauseClusterNode( shNode );
    } // if: PAUSE
    else if( ClRtlStrICmp( pwszMethodNameIn, PVD_MTH_SERVICE_RESUME ) == 0 ) 
    {
        er = ResumeClusterNode( shNode );
    } // else if: RESUME
    else
    {
        er = static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    return WBEM_S_NO_ERROR;

} //*** CClusterService::ExecuteMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::PutInstance
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      rInstToPutIn    -- WMI object to be saved
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::PutInstance(
    CWbemClassObject &   rInstToPutIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    static SGetSetControl   s_rgControl[] =
    {
        {
            CLUSCTL_NODE_GET_COMMON_PROPERTIES,
            CLUSCTL_NODE_SET_COMMON_PROPERTIES,
            FALSE
        },
        {
            CLUSCTL_NODE_GET_PRIVATE_PROPERTIES,
            CLUSCTL_NODE_SET_PRIVATE_PROPERTIES,
            TRUE
        }
    };
    static DWORD    s_cControl = sizeof( s_rgControl ) / sizeof( SGetSetControl );

    _bstr_t         bstrName;
    SAFECLUSTER     shCluster;
    SAFENODE        shNode;
    CError          er;
    UINT            idx;

    rInstToPutIn.GetProperty( bstrName, PVD_PROP_SERVICE_SYSTEMNAME );

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode( shCluster, bstrName );

    for ( idx = 0 ; idx < s_cControl ; idx ++ )
    {
        CClusPropList   plOld;
        CClusPropList   plNew;
        er = plOld.ScGetNodeProperties(
                    shNode,
                    s_rgControl[ idx ].dwGetControl,
                    NULL,
                    NULL,
                    0
                    );

        CClusterApi::SetObjectProperties(
                        RgGetPropMap(),
                        plNew,
                        plOld,
                        rInstToPutIn,
                        s_rgControl[ idx ].fPrivate
                        );

        if ( plNew.Cprops() > 0 )
        {
            er = ClusterNodeControl(
                        shNode,
                        NULL,
                        s_rgControl[ idx ].dwSetControl,
                        plNew.PbPropList(),
                        static_cast< DWORD >( plNew.CbPropList() ),
                        NULL,
                        0,
                        NULL
                        );
        }
    } // for: each control code

    return WBEM_S_NO_ERROR;

} //*** CClusterService::PutInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterService::DeleteInstance
//
//  Description:
//      Delete the object specified in rObjPathIn.
//
//  Arguments:
//      rObjPathIn      -- ObjPath for the instance to be deleted
//      lFlagIn         -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CClusterService::DeleteInstance(
    CObjPath &           rObjPathIn,
    long                 lFlagIn,
    IWbemContext *       pCtxIn,
    IWbemObjectSink *    pHandlerIn
    )
{
    return WBEM_E_NOT_SUPPORTED;

} //*** CClusterService::DeleteInstance()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\clusterwmiprovider.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterWMIProvider.cpp
//
//  Description:
//      Implementation of the provider registration and entry point.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <initguid.h>
#include "ProvFactory.h"
#include "InstanceProv.h"
#include "EventProv.h"
#include "ClusterWMIProvider.tmh"

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////


// {598065EA-EDC9-4b2c-913B-5104D04D098A}
DEFINE_GUID( CLSID_CLUSTER_WMI_PROVIDER,
0x598065ea, 0xedc9, 0x4b2c, 0x91, 0x3b, 0x51, 0x4, 0xd0, 0x4d, 0x9, 0x8a );

// {6A52C339-DCB0-4682-8B1B-02DE2C436A6D}
DEFINE_GUID( CLSID_CLUSTER_WMI_CLASS_PROVIDER,
0x6a52c339, 0xdcb0, 0x4682, 0x8b, 0x1b, 0x2, 0xde, 0x2c, 0x43, 0x6a, 0x6d );

// {92863246-4EDE-4eff-B606-79C1971DB230}
DEFINE_GUID( CLSID_CLUSTER_WMI_EVENT_PROVIDER,
0x92863246, 0x4ede, 0x4eff, 0xb6, 0x6, 0x79, 0xc1, 0x97, 0x1d, 0xb2, 0x30 );

// Count number of objects and number of locks.

long        g_cObj = 0;
long        g_cLock = 0;
HMODULE     g_hModule;

FactoryData g_FactoryDataArray[] =
{
    {
        &CLSID_CLUSTER_WMI_PROVIDER,
        CInstanceProv::S_HrCreateThis,
        L"Cluster service WMI instance provider"
    },
    {
        &CLSID_CLUSTER_WMI_CLASS_PROVIDER,
        CClassProv::S_HrCreateThis,
        L"Cluster service WMI class provider"
    },
    {
        &CLSID_CLUSTER_WMI_EVENT_PROVIDER,
        CEventProv::S_HrCreateThis,
        L"Cluster service WMI event provider"
    },
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  WINAPI
//  DllMain(
//      HANDLE  hModule,
//      DWORD   ul_reason_for_call,
//      LPVOID  lpReserved
//      )
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      hModule             -- DLL module handle.
//      ul_reason_for_call  -- 
//      lpReserved          -- 
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HANDLE  hModule,
    DWORD   ul_reason_for_call,
    LPVOID  lpReserved
    )
{


// begin_wpp config
// CUSTOM_TYPE(dllreason, ItemListLong(DLL_PROCESS_DETACH, DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH) );
//
// CUSTOM_TYPE(EventIdx, ItemSetLong(NODE_STATE, NODE_DELETED, NODE_ADDED, NODE_PROPERTY, REGISTRY_NAME,REGISTRY_ATTRIBUTES, REGISTRY_VALUE, REGISTRY_SUBTREE, RESOURCE_STATE, RESOURCE_DELETED, RESOURCE_ADDED, RESOURCE_PROPERTY, GROUP_STATE, GROUP_DELETED, GROUP_ADDED, GROUP_PROPERTY, RESOURCE_TYPE_DELETED, RESOURCE_TYPE_ADDED, RESOURCE_TYPE_PROPERTY, CLUSTER_RECONNECT, NETWORK_STATE, NETWORK_DELETED, NETWORK_ADDED, NETWORK_PROPERTY, NETINTERFACE_STATE, NETINTERFACE_DELETED, NETINTERFACE_ADDED, NETINTERFACE_PROPERTY, QUORUM_STATE, CLUSTER_STATE, CLUSTER_PROPERTY, HANDLE_CLOSE));
//
// CUSTOM_TYPE(GroupState, ItemListLong(Online, Offline, Failed, PartialOnline, Pending) );
// CUSTOM_TYPE(ResourceState, ItemListLong(Initing, Initializing, Online, Offline, Failed) );
// end_wpp
//
// Cluster event filter flags.
//
/*
    NODE_STATE               = 0x00000001,
    NODE_DELETED             = 0x00000002,
    NODE_ADDED               = 0x00000004,
    NODE_PROPERTY            = 0x00000008,

    REGISTRY_NAME            = 0x00000010,
    REGISTRY_ATTRIBUTES      = 0x00000020,
    REGISTRY_VALUE           = 0x00000040,
    REGISTRY_SUBTREE         = 0x00000080,

    RESOURCE_STATE           = 0x00000100,
    RESOURCE_DELETED         = 0x00000200,
    RESOURCE_ADDED           = 0x00000400,
    RESOURCE_PROPERTY        = 0x00000800,

    GROUP_STATE              = 0x00001000,
    GROUP_DELETED            = 0x00002000,
    GROUP_ADDED              = 0x00004000,
    GROUP_PROPERTY           = 0x00008000,

    RESOURCE_TYPE_DELETED    = 0x00010000,
    RESOURCE_TYPE_ADDED      = 0x00020000,
    RESOURCE_TYPE_PROPERTY   = 0x00040000,

    CLUSTER_RECONNECT        = 0x00080000,

    NETWORK_STATE            = 0x00100000,
    NETWORK_DELETED          = 0x00200000,
    NETWORK_ADDED            = 0x00400000,
    NETWORK_PROPERTY         = 0x00800000,

    NETINTERFACE_STATE       = 0x01000000,
    NETINTERFACE_DELETED     = 0x02000000,
    NETINTERFACE_ADDED       = 0x04000000,
    NETINTERFACE_PROPERTY    = 0x08000000,

    QUORUM_STATE             = 0x10000000,
    CLUSTER_STATE            = 0x20000000,
    CLUSTER_PROPERTY         = 0x40000000,

    
    HANDLE_CLOSE             = 0x80000000,
*/


//#ifdef _DEBUG
//    _CrtSetBreakAlloc( 228 );
//#endif

    TracePrint(("ClusWMI: DllMain entry, reason = %!dllreason!", ul_reason_for_call));
    g_hModule = static_cast< HMODULE >( hModule );

    switch ( ul_reason_for_call ) {

    case DLL_PROCESS_ATTACH:

    WPP_INIT_TRACING( NULL );
    break;

    case DLL_PROCESS_DETACH:

    WPP_CLEANUP();
    break;

    default:
    break;

    }

    return TRUE;

} //*** DllMain()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllCanUnloadNow( void )
//
//  Description:
//      Called periodically by Ole in order to determine if the
//      DLL can be freed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = ( (0L == g_cObj) && (0L == g_cLock) ) ? S_OK : S_FALSE;
    TracePrint(("ClusWMI: DllCanUnloadNow is returning %d", sc));
    return sc;

} //*** DllCanUnloadNow()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllRegisterServer( void )
//
//  Description:
//      Called during setup or by regsvr32.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{   
    WCHAR               wszID[ 128 ];
    WCHAR               wszCLSID[ 128 ];
    WCHAR               wszModule[ MAX_PATH ];
    INT                 idx;
    WCHAR *             pwszModel       = L"Both";
    HKEY                hKey1 = NULL;
    HKEY                hKey2 = NULL;
    DWORD               dwRt            =  ERROR_SUCCESS;
    INT                 cArray          = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    TracePrint(("ClusWMI: DllRegisterServer entry"));

    // Create the path.
    try
    {
        DWORD                           cbModuleNameSize    = 0;

        if ( GetModuleFileNameW( g_hModule, wszModule, MAX_PATH ) == 0 )
        {
            dwRt = GetLastError();
            throw( dwRt );
        }
        wszModule[ MAX_PATH - 1 ] = L'\0';

        cbModuleNameSize = (DWORD) ( wcslen( wszModule ) + 1 ) * sizeof( wszModule[ 0 ] );

        for ( idx = 0 ; idx < cArray && dwRt == ERROR_SUCCESS ; idx++ )
        {
            LPCWSTR pwszName = g_FactoryDataArray[ idx ].m_pwszRegistryName;

            StringFromGUID2(
                *g_FactoryDataArray[ idx ].m_pCLSID,
                wszID,
                128
                );
            HRESULT hr = StringCchPrintfW( wszCLSID, RTL_NUMBER_OF( wszCLSID ), L"Software\\Classes\\CLSID\\%ws", wszID );
            dwRt = (DWORD) hr;
            if ( dwRt != ERROR_SUCCESS )
            {
                throw( dwRt );
            }

            // Create entries under CLSID

            dwRt = RegCreateKeyExW( 
                                 HKEY_LOCAL_MACHINE,
                                 wszCLSID,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hKey1,
                                 NULL
                                 );
                
            if ( dwRt != ERROR_SUCCESS )
            {
                throw( dwRt );
            }

            dwRt = RegSetValueExW(
                        hKey1,
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) pwszName,
                        (DWORD) ( sizeof( WCHAR ) * ( wcslen( pwszName ) + 1 ) )
                        );
            if ( dwRt != ERROR_SUCCESS )
            {
                throw( dwRt );
            }

            dwRt = RegCreateKeyExW( 
                                 hKey1,
                                 L"InprocServer32",
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hKey2,
                                 NULL
                                 );
                
            if ( dwRt != ERROR_SUCCESS )
            {
                throw( dwRt );
            }

            dwRt = RegSetValueExW(
                        hKey2,
                        NULL,
                        0,
                        REG_SZ,
                        (BYTE *) wszModule,
                        cbModuleNameSize
                        );

            if ( dwRt != ERROR_SUCCESS )
            {
                throw( dwRt );
            }

            dwRt = RegSetValueExW(
                        hKey2,
                        L"ThreadingModel",
                        0,
                        REG_SZ,
                        (BYTE *) pwszModel,
                        (DWORD) ( sizeof( WCHAR ) * ( wcslen( pwszModel ) + 1 ) )
                        );
            if ( dwRt != ERROR_SUCCESS )
            {
                throw( dwRt );
            }
        } // for: each entry in factory entry array 

        if ( dwRt  != ERROR_SUCCESS )
        {
            throw( dwRt );
        }

    }
    catch ( DWORD sc )
    {
        dwRt = sc;
    }
    catch ( ... )
    {
        dwRt = (DWORD) SELFREG_E_CLASS;
    }

    TracePrint(("ClusWMI: RegisterServer returned %d", dwRt));

    if ( hKey1 != NULL )
    {
        RegCloseKey( hKey1 );
    }
    
    if ( hKey2 != NULL ) 
    {
        RegCloseKey( hKey2 );
    }


    return dwRt;

} //*** DllRegisterServer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllUnregisterServer( void )
//
//  Description:
//      Called when it is time to remove the registry entries.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      SELFREG_E_CLASS
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
    WCHAR   wszID[ 128 ];
    WCHAR   wszCLSID[ 128 ];
    HKEY    hKey;
    INT     idx;
    DWORD   dwRet   = ERROR_SUCCESS;

    for ( idx = 0 ; idx < 2 && dwRet == ERROR_SUCCESS ; idx++ )
    {
       StringFromGUID2(
            *g_FactoryDataArray[ idx ].m_pCLSID,
            wszID,
            128
            );

        HRESULT hr = StringCchPrintfW( wszCLSID, RTL_NUMBER_OF( wszCLSID ), L"Software\\Classes\\CLSID\\%ws", wszID );
        dwRet = (DWORD) hr;
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }

        // First delete the InProcServer subkey.

        dwRet = RegOpenKeyExW( 
                HKEY_LOCAL_MACHINE,
                wszCLSID,
                0,
                KEY_ALL_ACCESS,
                &hKey
                );
        
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
        
        dwRet = RegDeleteKeyW( hKey, L"InProcServer32" );
        RegCloseKey( hKey );

        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }

        dwRet = RegOpenKeyExW( 
                HKEY_LOCAL_MACHINE,
                L"Software\\Classes\\CLSID",
                0,
                KEY_ALL_ACCESS,
                &hKey
                );
        
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
        
        dwRet = RegDeleteKeyW( hKey,wszID );
        RegCloseKey( hKey );
        if ( dwRet != ERROR_SUCCESS )
        {
            break;
        }
    } // for: each object
    
    if ( dwRet != ERROR_SUCCESS )
    {
        dwRet = (DWORD) SELFREG_E_CLASS;
    }

    return dwRet;

} //*** DllUnregisterServer()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDAPI
//  DllGetClassObject(
//      REFCLSID    rclsidIn,
//      REFIID      riidIn,
//      PPVOID      ppvOut
//      )
//
//  Description:
//      Called by Ole when some client wants a class factory.  Return
//      one only if it is the sort of class this DLL supports.
//
//  Arguments:
//      rclsidIn    --
//      riidIn      --
//      ppvOut      --
//
//  Return Values:
//      NOERROR if registration successful, error otherwise.
//      E_OUTOFMEMORY
//      E_FAIL
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    PPVOID      ppvOut
    )
{

    HRESULT         hr;
    CProvFactory *  pObj = NULL;
    UINT            idx;
    UINT            cDataArray = sizeof ( g_FactoryDataArray ) / sizeof ( FactoryData );

    for ( idx = 0 ; idx < cDataArray ; idx++ )
    {
        if ( rclsidIn == *g_FactoryDataArray[ idx ].m_pCLSID )
        {
            pObj= new CProvFactory( &g_FactoryDataArray[ idx ] );
            if ( NULL == pObj )
            {
                return E_OUTOFMEMORY;
            }

            hr = pObj->QueryInterface( riidIn, ppvOut );

            if ( FAILED( hr ) )
            {
                delete pObj;
            }

            return hr;
        }
    }
    return E_FAIL;

} //*** DllGetClassObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\eventprov.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusterService.cpp
//
//  Description:    
//      Implementation of CClusterService class 
//
//  Author:
//      Henry Wang (HenryWa) 19-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "EventProv.h"
#include "EventProv.tmh"
#include "clustergroup.h"

//****************************************************************************
//
//  CEventProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEventProv::CEventProv( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEventProv::CEventProv( void )
    : m_pNs( 0 )
    , m_pSink( 0 )
    , m_cRef( 0 )
    , m_pEventAdd( 0 )
    , m_pEventRemove( 0 )
    , m_pEventState( 0 )
    , m_pEventGroupState( 0 )
    , m_pEventResourceState( 0 )
    , m_pEventProperty( 0 )
    , m_hThread( 0 )
    , m_esStatus( esPENDING )
{
    UINT idx;
    for ( idx = 0; idx < EVENT_TABLE_SIZE ; idx++ )
    {
        m_EventTypeTable[ idx ].m_pwco = NULL;
        m_EventTypeTable[ idx ].m_pfn = NULL;
    }
    InterlockedIncrement( &g_cObj );

} //*** CEventProv::CEventProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEventProv::!CEventProv( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEventProv::~CEventProv( void )
{
    InterlockedDecrement( &g_cObj );

    if ( m_hThread != NULL )
    {
        CloseHandle( m_hThread );
    }

    if ( m_pNs != NULL )
    {
        m_pNs->Release();
    }

    if ( m_pSink != NULL )
    {
        m_pSink->Release();
    }

    if ( m_pEventAdd != NULL )
    {
        m_pEventAdd->Release();
    }

    if ( m_pEventRemove != NULL )
    {
        m_pEventRemove->Release();
    }

    if ( m_pEventState != NULL )
    {
        m_pEventState->Release();
    }

    if ( m_pEventGroupState != NULL )
    {
        m_pEventGroupState->Release();
    }

    if ( m_pEventResourceState != NULL )
    {
        m_pEventResourceState->Release();
    }

    if ( m_pEventProperty != NULL )
    {
        m_pEventProperty->Release();
    }

} //*** CEventProv::~CEventProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CEventProv::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//  Description:
//      Query for interfaces supported by this COM object.
//
//  Arguments:
//      riid    -- Interface being queried for.
//      ppv     -- Pointer in which to return interface pointer.
//
//  Return Values:
//      NOERROR
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEventProv::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    *ppv = 0;

    if ( IID_IUnknown == riid || IID_IWbemEventProvider == riid )
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if ( IID_IWbemEventProviderSecurity == riid )
    {
        *ppv = (IWbemEventProviderSecurity *) this;
        AddRef();
        return NOERROR;
    }

    if ( IID_IWbemProviderInit == riid )
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

} //*** CEventProv::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEventProv::AddRef( void )
//
//  Description:
//      Add a reference to the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEventProv::AddRef( void )
{
    return InterlockedIncrement( (LONG *) &m_cRef );

} //*** CEventProv::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEventProv::Release( void )
//
//  Description:
//      Release a reference on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CEventProv::Release( void )
{
    LONG cRef = InterlockedDecrement( (LONG *) &m_cRef );
    if ( 0L ==  cRef )
    {
        m_esStatus = esPENDING_STOP;
        CancelIo( m_hChange );
        //
        // wait for the thread completely stopped
        //
        while ( ! m_fStopped )
        {
            Sleep( 100 );
        }
        delete this;
    }
    
    return cRef;

} //*** CEventProv::Release()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEventProv::ProvideEvents(
//      IWbemObjectSink *   pSinkIn,
//      long                lFlagsIn
//      )
//
//  Description:
//      Start the provider to generate event
//      Called by wmi
//
//  Arguments:
//      pSinkIn     -- WMI sink pointer to send event back
//      lFlagsIn    -- WMI flag
//
//  Return Values:
//      WBEM_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEventProv::ProvideEvents(
    IWbemObjectSink *   pSinkIn,
    long                lFlagsIn
    )
{
    DWORD dwTID;
    HRESULT hr = WBEM_NO_ERROR;
    
    // Copy the sink.
    // ==============
    m_pSink = pSinkIn;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    m_hThread = CreateThread(
                    0,
                    0,
                    CEventProv::S_EventThread,
                    this,
                    0,
                    &dwTID
                    );


    // Wait for provider to be 'ready'.
    // ================================
    
    while ( m_esStatus != esRUNNING )
    {
        Sleep( 100 );
    }

    return hr;

} //*** CEventProv::ProvideEvents


//////////////////////////////////////////////////////////////////////////////
//++
//
// HRESULT
// CEventProv::AccessCheck(
//      WBEM_CWSTR wszQueryLanguage,
//      WBEM_CWSTR wszQuery,
//      long lSidLength,
//      const BYTE* pSid
//      )
//
//  Description:
//      Checks the access permissions when a consumer attempts to subscribe to the event specified in wszQuery. 
//      The consumer is permitted to subscribe to the event if it has access permission for the event, 
//      otherwise subscription is prevented.
//
//  Arguments:
//      wszQueryLanguageIn  -- Language of the following query filter. For this version of WMI, it will be "WQL". 
//      wszQueryIn          -- Text of the event query filter, which was registered by a logical consumer. 
//      lSidLengthIn        -- Integer that contains the SID length, or 0 if the subscription builder's token is available. 
//      pSidIn              -- Pointer to the constant byte integer type that contains the SID, or NULL if the subscription 
//                             builder's token is available. 
//
//  Return Values:
//      WBEM_S_NO_ERROR         -- The user has permission to subscribe to the event. 
//      WBEM_E_ACCESS_DENIED    -- The user does not have permission to access the event. 
//      WBEM_E_FAILED           -- Indicates a provider failure. 
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CEventProv::AccessCheck(
    WBEM_CWSTR      wszQueryLanguageIn,
    WBEM_CWSTR      wszQueryIn,
    long            lSidLengthIn,
    const BYTE *    pSidIn
    )
{
    HRESULT         hr = WBEM_S_NO_ERROR;
    SAFECLUSTER     shCluster;

    //
    // Impersonate the client and call OpenCluster
    //
    hr = CoImpersonateClient();
    if( FAILED( hr ) )
    {
        goto Cleanup;
    }

    try 
    {
        //
        // OpenCluster should fail with ERROR_ACCESS_DENIED if the client in unprivileged.
        // Otherwise it should succeed.
        //
        
        shCluster = OpenCluster( NULL );
    }
    catch ( CProvException provException )
    {
        hr = provException.hrGetError();
    }

Cleanup:

    //
    // Based on the MSDN definition, this function has to return 1 of the 3 return values 
    // listed above in the function header, so let's make it happen.
    //
    
    if ( FAILED( hr ) )
    {
        if ( hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
        {
            hr = WBEM_E_ACCESS_DENIED;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    } // if: FAILED( hr )
    else 
    {
        hr = WBEM_S_NO_ERROR;
    } // else: hr succeeded
 
    return hr;

} //*** CEventProv::AccessCheck

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  DWORD
//  WINAPI
//  CEventProv::S_EventThread(
//      LPVOID  pArgIn
//      )
//
//  Description:
//      Event thread proc.
//
//  Arguments:
//      pArgIn  -- 
//
//  Return Values:
//      Any return values from CEventProv::InstanceThread().
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
CEventProv::S_EventThread(
    LPVOID pArgIn
    )
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CEventProv *) pArgIn)->InstanceThread();
    return 0;

} //*** CEventProv::S_EventThread()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CEventProv::InstanceThread( void )
//
//  Description:
//      This function is started as seperated thread, waiting for cluster
//      event notification and then send event back to wmi
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::InstanceThread( void )
{
    SAFECLUSTER     shCluster;
    //SAFECHANGE      shChange;
    DWORD           dwError;
    DWORD_PTR       dwpNotifyKey;
    DWORD           cchName = MAX_PATH;
    DWORD           dwFilterType;
    CWstrBuf        wsbName;
    CError          er;
    DWORD           cchReturnedName;

    try
    {
        m_esStatus = esRUNNING;
        m_fStopped = FALSE;
        shCluster = OpenCluster( NULL );
        m_hChange = CreateClusterNotifyPort(
                        (HCHANGE) INVALID_HANDLE_VALUE,
                        shCluster,
                        ( cntCLUSTER_STATE_CHANGE | cntOBJECT_ADD | cntOBJECT_REMOVE
                        | cntPROPERTY_CHANGE | cntGROUP_STATE_CHANGE
                        | cntRESOURCE_STATE_CHANGE ),
                        1
                        );

        wsbName.SetSize( cchName );

        while ( m_esStatus == esRUNNING )
        {
            cchReturnedName = cchName;
            wsbName.Empty();    // Null out the name field
            //TracePrint(("Call GetClusterNotify to get next notification event\n"));
            dwError = GetClusterNotify(
                            m_hChange,
                            &dwpNotifyKey,
                            &dwFilterType,
                            wsbName,
                            &cchReturnedName,
                            400
                            ); 

            if ( dwError == ERROR_MORE_DATA )
            {
                cchName =  ++cchReturnedName;
                wsbName.SetSize( cchName );
                dwError = GetClusterNotify(
                                m_hChange,
                                &dwpNotifyKey,
                                &dwFilterType,
                                wsbName,
                                &cchReturnedName,
                                400
                                );
            } // if: more data

            if ( dwError == ERROR_SUCCESS )
            {
                CWbemClassObject    wco;
                UINT                idx;
                DWORD               dwType;
                SEventTypeTable *   pTypeEntry = NULL;
            
                //
                // locate table index for the event type
                //
                dwType = dwFilterType;
                for ( idx = 0 ; (idx < EVENT_TABLE_SIZE) && ! ( dwType & 0x01 ) ; idx++ )
                {
                    dwType = dwType >> 1;
                }
                TracePrint(("Received <%ws> event, ChangeEvent = %!EventIdx!", wsbName, dwFilterType));
            
                pTypeEntry = &m_EventTypeTable[ idx ];
                if ( pTypeEntry->m_pwco != NULL )
                {
                    pTypeEntry->m_pwco->SpawnInstance( 0, &wco );

                    try
                    {
                        pTypeEntry->m_pfn(
                                wco,
                                pTypeEntry->m_pwszMof,
                                //pwszName,
                                wsbName,
                                pTypeEntry->m_eotObjectType,
                                dwFilterType
                                );
                    } // try
                        catch ( ... )
                    {
                        TracePrint(("  ****  Exception on last Event call\n"));
                    } // catch
                } // if: 

                er = m_pSink->Indicate( 1, &wco );

            } // if: success

        } // while: running
    } // try
    catch( ... )
    {
        TracePrint(("Exiting event provider loop! %lx\n", m_esStatus));
        // bugbug: when error occured, event provider should be shut down, 
        // the provider should notify wmi and clean up. 
        // wmi doesn't handle this release call correctly.
        m_pSink->Release();
        //
        // set it to null to provent being released again by destructor
        //
        m_pSink = NULL;
    } // catch

    m_fStopped = TRUE;
      
} //*** CEventProv::InstanceThread()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetEventProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set an event property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetEventProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    CObjPath op;

    TracePrint(("Set event property for <%ws>:<%ws>, Event = %!EventIdx!", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
    
    pwcoInout.SetProperty( pwszObjectNameIn, PVD_PROP_EVENT_NAME );
    pwcoInout.SetProperty( static_cast< DWORD >( eotObjectTypeIn ), PVD_PROP_EVENT_TYPE );
    pwcoInout.SetProperty( static_cast< DWORD >( 0 ), PVD_PROP_EVENT_TYPEMAJOR );
    pwcoInout.SetProperty( dwEventMinorIn, PVD_PROP_EVENT_TYPEMINOR );

    //
    // setting object path
    //
    if ( ! op.Init( NULL ) )
    {
        TracePrint(("  ****  Out of memory! Throwing exception.\n"));
        throw WBEM_E_OUT_OF_MEMORY;
    }
    op.SetClass( pwszMofClassNameIn );

    //
    // net interface objectpath is different from all the other objects
    //
    if ( eotObjectTypeIn == eotNET_INTERFACE )
    {
        SAFECLUSTER         shCluster;
        SAFENETINTERFACE    shNetInterface;
        DWORD               cbName = MAX_PATH;
        CWstrBuf            wsbName;
        DWORD               cbReturn;
        CError              er;

        shCluster = OpenCluster( NULL );
        wsbName.SetSize( cbName );
        shNetInterface = OpenClusterNetInterface( shCluster, pwszObjectNameIn );

        //
        // NOTE - I didn't handle error_more_data, since max_path should be 
        // large enough for node name
        //
        er = ClusterNetInterfaceControl(
                    shNetInterface,
                    NULL,
                    CLUSCTL_NETINTERFACE_GET_NODE,
                    NULL,
                    0,
                    wsbName,
                    cbName,
                    &cbReturn
                    );

        op.AddProperty( PVD_PROP_NETINTERFACE_SYSTEMNAME, wsbName );
        op.AddProperty( PVD_PROP_NETINTERFACE_DEVICEID,   pwszObjectNameIn );
    } //if: event is net interface
    else
    {
        op.AddProperty( PVD_PROP_NAME, pwszObjectNameIn );
    }

    pwcoInout.SetProperty(
        static_cast< LPCWSTR >( op.GetObjectPathString() ),
        PVD_PROP_EVENT_PATH
        );

} //*** CEventProv::S_SetEventProperty()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_AddEvent(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set an event property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_AddEvent(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{

    switch ( eotObjectTypeIn )
    {
        case eotGROUP:
        case eotRESOURCE:
        case eotRESOURCE_TYPE:
        case eotNODE:
        case eotNETWORK:
        case eotNET_INTERFACE:
        {

            TracePrint(("Add event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));

            S_SetEventProperty(
                pwcoInout,
                pwszMofClassNameIn,
                pwszObjectNameIn,
                eotObjectTypeIn,
                dwEventMinorIn
                );

            break;
        }


        default:
            TracePrint(("Add object event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            TracePrint(("  ****  Unknown Object Type!\n"));
            throw WBEM_E_INVALID_PARAMETER;
    }

    return;

} //*** CEventProv::S_AddEvent()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_DeleteEvent(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set an event property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_DeleteEvent(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{

    switch ( eotObjectTypeIn )
    {
        case eotGROUP:
        case eotRESOURCE:
        case eotRESOURCE_TYPE:
        case eotNODE:
        case eotNETWORK:
        case eotNET_INTERFACE:
        {

            TracePrint(("Delete event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));

            S_SetEventProperty(
                pwcoInout,
                pwszMofClassNameIn,
                pwszObjectNameIn,
                eotObjectTypeIn,
                dwEventMinorIn
                );

            break;
        }

        default:
            TracePrint(("Delete object event for <%ws>:<%ws>, Event = %!EventIdx!\n", pwszMofClassNameIn, pwszObjectNameIn, dwEventMinorIn ));
            TracePrint(("  ****  Unknown Object Type!\n"));
            throw WBEM_E_INVALID_PARAMETER;
    }

    return;

} //*** CEventProv::S_DeleteEvent()

#if 0
//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetClusterStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a node state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetClusterStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    DWORD       dwState;
    DWORD       dwError;

    dwError = GetNodeClusterState( NULL, &dwState );

    if ( dwError != ERROR_SUCCESS )
    {
        TracePrint(("  ****  Failed to get the node cluster state. Throwing exception!\n"));
        throw CProvException( dwError );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetClusterStateProperty()
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetNodeStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a node state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetNodeStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER shCluster;
    SAFENODE    shNode;
    DWORD       dwState;

    shCluster = OpenCluster( NULL );
    shNode = OpenClusterNode( shCluster, pwszObjectNameIn );
    dwState = GetClusterNodeState( shNode );

    if ( dwState == ClusterNodeStateUnknown )
    {
        TracePrint(("  ****  SetNodeStateProperty... node state unknown. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetNodeStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetNetworkStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a network state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetNetworkStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER shCluster;
    SAFENETWORK shNetwork;
    DWORD       dwState;

    shCluster = OpenCluster( NULL );
    shNetwork = OpenClusterNetwork( shCluster, pwszObjectNameIn );
    dwState = GetClusterNetworkState( shNetwork );
    if ( dwState == ClusterNetworkStateUnknown )
    {
        TracePrint(("  ****  SetNetworkStateProperty... network state unknown. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetNetworkStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetNetInterfaceStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a network interface state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn      -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetNetInterfaceStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER         shCluster;
    SAFENETINTERFACE    shNetInterface;
    DWORD               dwState;

    shCluster = OpenCluster( NULL );
    shNetInterface = OpenClusterNetInterface( shCluster, pwszObjectNameIn );
    dwState = GetClusterNetInterfaceState( shNetInterface );
    if ( dwState == ClusterNetInterfaceStateUnknown )
    {
        TracePrint(("  ****  SetNetInterfaceStateProperty... network interface state unknown. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    }

    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetNetInterfaceStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetGroupStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a group state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn     -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetGroupStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER         shCluster;
    SAFEGROUP           shGroup;
    DWORD               dwState;
    DWORD               cchName = MAX_PATH;
    CWstrBuf            wsbNodeName;

    wsbNodeName.SetSize( cchName );
    shCluster = OpenCluster( NULL );
    shGroup  = OpenClusterGroup( shCluster, pwszObjectNameIn );

    dwState = GetClusterGroupState( shGroup, wsbNodeName, &cchName );
    if ( dwState == ClusterGroupStateUnknown )
    {
        //
        // BUGBUG I am not handling error_more_data here, since it's not possible that
        // nodeName exceed MAX_PATH, assuming it use netbios name
        //
        TracePrint(("ClusterGroup State is UNKNOWN. Throwing exception!\n"));
        throw CProvException( GetLastError() );
    } else {
        TracePrint(("Setting group state for group <%ws> to %!GroupState!\n", pwszObjectNameIn, dwState ));
        pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
        pwcoInout.SetProperty( wsbNodeName, PVD_PROP_EVENT_NODE );
    }

    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetGroupStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  void
//  CEventProv::S_SetResourceStateProperty(
//      CWbemClassObject &  pwcoInout,
//      LPCWSTR             pwszMofClassNameIn,
//      LPCWSTR             pwszObjectNameIn,
//      EEventObjectType    eotObjectTypeIn,
//      DWORD               dwEventMinorIn
//      )
//
//  Description:
//      Set a resource state property.
//
//  Arguments:
//      pwcoInout           -- 
//      pwszMofClassNameIn  -- 
//      pwszObjectNameIn    -- 
//      eotObjectTypeIn      -- 
//      dwEventMinorIn      -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::S_SetResourceStateProperty(
    CWbemClassObject &  pwcoInout,
    LPCWSTR             pwszMofClassNameIn,
    LPCWSTR             pwszObjectNameIn,
    EEventObjectType    eotObjectTypeIn,
    DWORD               dwEventMinorIn
    )
{
    SAFECLUSTER         shCluster;
    SAFERESOURCE        shResource;
    DWORD               dwState;
    DWORD               cchNodeName = MAX_PATH;
    CWstrBuf            wsbNodeName;
    DWORD               cchGroupName = MAX_PATH;
    CWstrBuf            wsbGroupName;

    shCluster = OpenCluster( NULL );
    wsbNodeName.SetSize( cchNodeName );
    wsbGroupName.SetSize( cchGroupName );
    shResource = OpenClusterResource( shCluster, pwszObjectNameIn );
    if ( !shResource.BIsNULL() ) {
        dwState = GetClusterResourceState(
                        shResource,
                        wsbNodeName,
                        &cchNodeName,
                        wsbGroupName,
                        &cchGroupName
                        );
    } else {
        dwState = (DWORD) ClusterResourceStateUnknown;
    }

    TracePrint(("Setting resource state for resource <%ws> to %!ResourceState!\n", pwszObjectNameIn, dwState ));
    pwcoInout.SetProperty( dwState, PVD_PROP_EVENT_NEWSTATE );
    pwcoInout.SetProperty( wsbNodeName, PVD_PROP_EVENT_NODE );
    pwcoInout.SetProperty( wsbGroupName, PVD_PROP_EVENT_GROUP );

    S_SetEventProperty(
        pwcoInout,
        pwszMofClassNameIn,
        pwszObjectNameIn,
        eotObjectTypeIn,
        dwEventMinorIn
        );

    return;

} //*** CEventProv::S_SetResourceStateProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CEventProv::InsertTable(
//      DWORD               dwIdxIn,
//      CLUSTER_CHANGE      eTypeIn,
//      EEventObjectType    eotObjectTypeIn,
//      LPCWSTR             pwszMofIn,
//      IWbemClassObject *  pwcoIn,
//      FPSETPROP           pfnIn
//      )
//
//  Description:
//      Insert values in the event table.
//
//  Arguments:
//      dwIdxIn         -- 
//      eTypeIn         -- 
//      eotObjectTypeIn  -- 
//      pwszMofIn       -- 
//      pwcoIn          -- 
//      pfnIn           -- 
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CEventProv::InsertTable(
    DWORD               dwIdxIn,
    CLUSTER_CHANGE      eTypeIn,
    EEventObjectType    eotObjectTypeIn,
    LPCWSTR             pwszMofIn,
    IWbemClassObject *  pwcoIn,
    FPSETPROP           pfnIn
    )
{
    m_EventTypeTable[ dwIdxIn ].m_eType = eTypeIn;
    m_EventTypeTable[ dwIdxIn ].m_eotObjectType = eotObjectTypeIn;
    m_EventTypeTable[ dwIdxIn ].m_pwszMof = pwszMofIn;
    m_EventTypeTable[ dwIdxIn ].m_pwco = pwcoIn;
    m_EventTypeTable[ dwIdxIn ].m_pfn= pfnIn;

    return;

} //*** CEventProv::InsertTable()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CEventProv::Initialize(
//      LPWSTR                  pwszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pwszNamespaceIn,
//      LPWSTR                  pwszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initializing the provider by setting up a lookup table.
//      called by wmi only once to create provider object.
//
//  Arguments:
//      pwszUserIn          -- User name 
//      lFlagsIn            -- WMI flag
//      pwszNamespaceIn     -- Name space
//      pwszLocaleIn        -- Locale string
//      pCtxIn              -- WMI context
//      pInitSinkIn         -- WMI sink pointer
//
//  Return Values:
//      WBEM_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEventProv::Initialize(
    LPWSTR                  pwszUserIn,
    LONG                    lFlagsIn,
    LPWSTR                  pwszNamespaceIn,
    LPWSTR                  pwszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT hr;
    CError  er;

    UNREFERENCED_PARAMETER( pwszUserIn );
    UNREFERENCED_PARAMETER( lFlagsIn );
    UNREFERENCED_PARAMETER( pwszNamespaceIn );
    UNREFERENCED_PARAMETER( pwszLocaleIn );

    m_pNs = pNamespaceIn;
    m_pNs->AddRef();

    //
    // Grab the class definition for the event.
    //
    try
    {
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_ADD ),
                0,
                pCtxIn,
                &m_pEventAdd,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_REMOVE ),
                0,
                pCtxIn,
                &m_pEventRemove,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_STATECHANGE ),
                0,
                pCtxIn,
                &m_pEventState,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_GROUPSTATECHANGE ),
                0,
                pCtxIn,
                &m_pEventGroupState,
                0
                );
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_RESOURCESTATECHANGE ),
                0,
                pCtxIn,
                &m_pEventResourceState,
                0
                );
#if 0
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_NODESTATECHANGE ),
                0,
                pCtxIn,
                &m_pEventNodeState,
                0
                );
#endif
        er = m_pNs->GetObject(
                _bstr_t( PVD_CLASS_EVENT_PROP ),
                0,
                pCtxIn,
                &m_pEventProperty,
                0
                );

        //
        // initialize mapping table
        //

        //
        // node events
        //
        InsertTable(
            0,
            CLUSTER_CHANGE_NODE_STATE,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventState,
            S_SetNodeStateProperty
            );
        InsertTable(
            1,
            CLUSTER_CHANGE_NODE_DELETED,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            2,
            CLUSTER_CHANGE_NODE_ADDED,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            3,
            CLUSTER_CHANGE_NODE_PROPERTY,
            eotNODE,
            PVD_CLASS_NODE,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // registry event, don't care
       //

       //
       // Resource
       //
       InsertTable(
            8,
            CLUSTER_CHANGE_RESOURCE_STATE,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventResourceState,
            S_SetResourceStateProperty
            );
       InsertTable(
            9,
            CLUSTER_CHANGE_RESOURCE_DELETED,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventRemove,
            S_DeleteEvent
            );
       InsertTable(
            10,
            CLUSTER_CHANGE_RESOURCE_ADDED,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventAdd,
            S_AddEvent
            );
       InsertTable(
            11,
            CLUSTER_CHANGE_RESOURCE_PROPERTY,
            eotRESOURCE,
            PVD_CLASS_RESOURCE,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // group
       //
       InsertTable(
            12,
            CLUSTER_CHANGE_GROUP_STATE,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventGroupState,
            S_SetGroupStateProperty
            );
       InsertTable(
            13,
            CLUSTER_CHANGE_GROUP_DELETED,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventRemove,
            S_DeleteEvent
            );
       InsertTable(
            14,
            CLUSTER_CHANGE_GROUP_ADDED,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventAdd,
            S_AddEvent
            );
       InsertTable(
            15,
            CLUSTER_CHANGE_GROUP_PROPERTY,
            eotGROUP,
            PVD_CLASS_GROUP,
            m_pEventProperty,
            S_SetEventProperty
            );

       //
       // Resource Type 
       //
       InsertTable(
            16,
            CLUSTER_CHANGE_RESOURCE_TYPE_DELETED,
            eotRESOURCE_TYPE,
            PVD_CLASS_RESOURCETYPE,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            17,
            CLUSTER_CHANGE_RESOURCE_TYPE_ADDED,
            eotRESOURCE_TYPE,
            PVD_CLASS_RESOURCETYPE,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            18,
            CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY,
            eotRESOURCE_TYPE,
            PVD_CLASS_RESOURCETYPE,
            m_pEventProperty,
            S_SetEventProperty
            );

       //
       // skip 19 - CLUSTER_CHANGE_CLUSTER_RECONNECT
       //

       //
       // network
       //
       InsertTable(
            20,
            CLUSTER_CHANGE_NETWORK_STATE,
            eotNETWORK,
            PVD_CLASS_NETWORK,
            m_pEventState,
            S_SetNetworkStateProperty
            );
       InsertTable(
            21,
            CLUSTER_CHANGE_NETWORK_DELETED,
            eotNETWORK,
            PVD_CLASS_NETWORK,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            22,
            CLUSTER_CHANGE_NETWORK_ADDED,
            eotNETWORK,
            PVD_CLASS_NETWORK,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            23,
            CLUSTER_CHANGE_NETWORK_PROPERTY,
            eotNETWORK,
            PVD_CLASS_NETWORK,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // net interface
       //
       InsertTable(
            24,
            CLUSTER_CHANGE_NETINTERFACE_STATE,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKINTERFACE,
            m_pEventState,
            S_SetNetInterfaceStateProperty
            );
       InsertTable(
            25,
            CLUSTER_CHANGE_NETINTERFACE_DELETED,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKINTERFACE,
            m_pEventRemove,
            S_SetEventProperty
            );
       InsertTable(
            26,
            CLUSTER_CHANGE_NETINTERFACE_ADDED,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKINTERFACE,
            m_pEventAdd,
            S_SetEventProperty
            );
       InsertTable(
            27,
            CLUSTER_CHANGE_NETINTERFACE_PROPERTY,
            eotNET_INTERFACE,
            PVD_CLASS_NETWORKINTERFACE,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // other
       //
       InsertTable(
            28,
            CLUSTER_CHANGE_QUORUM_STATE,
            eotQUORUM,
            PVD_CLASS_RESOURCE,
            m_pEventState,
            S_SetResourceStateProperty
            );
/*       InsertTable(
            29,
            CLUSTER_CHANGE_CLUSTER_STATE,
            eotCLUSTER,
            PVD_CLASS_CLUSTER,
            m_pEventState,
            S_SetClusterStateProperty );
*/
        InsertTable(
            30,
            CLUSTER_CHANGE_CLUSTER_PROPERTY,
            eotCLUSTER,
            PVD_CLASS_CLUSTER,
            m_pEventProperty,
            S_SetEventProperty
            );
       //
       // skip 31 - CLUSTER_CHANGE_HANDLE_CLOSE
       //

        // Tell CIMOM that we're up and running.
        // =====================================
        hr = WBEM_S_INITIALIZED;
    } // try
    catch ( ... )
    {
        hr = WBEM_E_FAILED;
    } // catch
    
    pInitSinkIn->SetStatus( hr, 0 );
    return WBEM_S_NO_ERROR;

} //*** CEventProv::Initialize()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  HRESULT
//  CEventProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create a CEventProv object.
//
//  Arguments:
//      pUnknownOutIn   -- 
//      ppvOut          -- 
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEventProv::S_HrCreateThis(
    IUnknown *  pUnknownOuterIn,
    VOID **     ppvOut
    )
{
    *ppvOut = new CEventProv();
    return S_OK;

} //*** CEventProv::S_HrCreateThis()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\eventprov.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      EventProv.h
//
//  Implementation File:
//      EventProv.cpp
//
//  Description:
//      Definition of event provider class
//
//  Author:
//      Henry Wang (HenryWa)    19-JAN-2000
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////
#define EVENT_TABLE_SIZE 32

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CEventProv;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEventProv
//
//  Description:
//      Event provider
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEventProv
    : public IWbemEventProvider
    , public IWbemEventProviderSecurity
    , public IWbemProviderInit
{
public:
    enum EEventStatus
    {
        esPENDING,
        esRUNNING,
        esPENDING_STOP,
        esSTOPPPED,

        esMX
    };

    enum EClusterNotificationType
    {
        cntCLUSTER_STATE_CHANGE =
            CLUSTER_CHANGE_NODE_STATE               |
            CLUSTER_CHANGE_RESOURCE_STATE           |
            CLUSTER_CHANGE_NETWORK_STATE            |
            CLUSTER_CHANGE_NETINTERFACE_STATE       |
            CLUSTER_CHANGE_QUORUM_STATE             |
            CLUSTER_CHANGE_CLUSTER_STATE,
        cntGROUP_STATE_CHANGE =
            CLUSTER_CHANGE_GROUP_STATE,
        cntRESOURCE_STATE_CHANGE =
            CLUSTER_CHANGE_RESOURCE_STATE,
        cntOBJECT_ADD =
            CLUSTER_CHANGE_NODE_ADDED               |
            CLUSTER_CHANGE_RESOURCE_ADDED           |
            CLUSTER_CHANGE_GROUP_ADDED              |
            CLUSTER_CHANGE_RESOURCE_TYPE_ADDED      |
            CLUSTER_CHANGE_NETWORK_ADDED            |
            CLUSTER_CHANGE_NETINTERFACE_ADDED,
        cntOBJECT_REMOVE =
            CLUSTER_CHANGE_NODE_DELETED             |
            CLUSTER_CHANGE_RESOURCE_DELETED         |
            CLUSTER_CHANGE_GROUP_DELETED            |
            CLUSTER_CHANGE_RESOURCE_TYPE_DELETED    |
            CLUSTER_CHANGE_NETWORK_DELETED          |
            CLUSTER_CHANGE_NETINTERFACE_DELETED,
        cntPROPERTY_CHANGE =
            CLUSTER_CHANGE_NODE_PROPERTY            |
            CLUSTER_CHANGE_RESOURCE_PROPERTY        |
            CLUSTER_CHANGE_GROUP_PROPERTY           |
            CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY   |
            CLUSTER_CHANGE_NETWORK_PROPERTY         |
            CLUSTER_CHANGE_NETINTERFACE_PROPERTY    |
            CLUSTER_CHANGE_CLUSTER_PROPERTY
    };

    enum EEventObjectType
    {
        eotHANDLE = 0,
        eotCLUSTER,
        eotNODE,
        eotGROUP,
        eotRESOURCE,
        eotRESOURCE_TYPE,
        eotNETWORK,
        eotNET_INTERFACE,
        eotREGISTRY,
        eotQUORUM,

        eotMX
    };

    typedef void (*FPSETPROP)(
        CWbemClassObject &  pwcoIn,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    struct SEventTypeTable
    {
        CLUSTER_CHANGE      m_eType;
        EEventObjectType    m_eotObjectType;
        LPCWSTR             m_pwszMof;
        IWbemClassObject *  m_pwco;
        FPSETPROP           m_pfn;
    };

    void InsertTable(
        DWORD               dwIdxIn,
        CLUSTER_CHANGE      eTypeIn,
        EEventObjectType    eotObjectTypeIn,
        LPCWSTR             pwszMofIn,
        IWbemClassObject *  pwcoIn,
        FPSETPROP           pfnIn
        );

    SEventTypeTable  m_EventTypeTable[ 32 ];

    CEventProv( void );
    ~CEventProv( void );

    //
    // IUnknown members
    //
    STDMETHODIMP            QueryInterface( REFIID riid, LPVOID * ppv );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

    // Inherited from IWbemEventProvider

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
        IWbemObjectSink *   pSinkIn,
        long                lFlagsIn
        );

    // Inherited from IWbemEventProviderSecurity

    HRESULT STDMETHODCALLTYPE AccessCheck(
        WBEM_CWSTR          wszQueryLanguageIn,
        WBEM_CWSTR          wszQueryIn,
        long                lSidLengthIn,
        const BYTE *        pSidIn
        );
    
    // Inherited from IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize( 
        LPWSTR                  pwszUserIn,
        LONG                    lFlagsIn,
        LPWSTR                  pwszNamespaceIn,
        LPWSTR                  pwszLocaleIn,
        IWbemServices *         pNamespaceIn,
        IWbemContext *          pCtxIn,
        IWbemProviderInitSink * pInitSinkIn
        );

    static HRESULT S_HrCreateThis(
        IUnknown *  pUnknownOuterIn,
        VOID **     ppvOut
        );

protected:
    ULONG               m_cRef;
    IWbemServices *     m_pNs;
    IWbemObjectSink *   m_pSink;
    IWbemClassObject *  m_pEventAdd;
    IWbemClassObject *  m_pEventRemove;
    IWbemClassObject *  m_pEventProperty;
    IWbemClassObject *  m_pEventState;
    IWbemClassObject *  m_pEventGroupState;
    IWbemClassObject *  m_pEventResourceState;
    EEventStatus        m_esStatus;
    HANDLE              m_hThread;
    BOOL                m_fStopped;
    HCHANGE             m_hChange;

    static void S_SetEventProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_AddEvent(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_DeleteEvent(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_SetNodeStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );
    
    static void S_SetGroupStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );
    
    static void S_SetResourceStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );
 
    static void S_SetNetworkStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static void S_SetNetInterfaceStateProperty(
        CWbemClassObject &  pwcoInout,
        LPCWSTR             pwszMofClassNameIn,
        LPCWSTR             pwszObjectNameIn,
        EEventObjectType    eotObjectTypeIn,
        DWORD               dwEventMinorIn
        );

    static DWORD WINAPI S_EventThread(
        LPVOID pArgIn
        );

    void InstanceThread( void );

}; //*** class CEventProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\ntrkcomm.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NtRkComm.cpp
//
//  Description:
//      Implementation of CWbemServices, CImpersonatedProvider, CInstanceMgr
//      class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "NtRkComm.h"
#include "ObjectPath.h"

//****************************************************************************
//
//  CWbemServices
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemServices::CWbemServices(
//      IWbemServices * pNamespace
//    )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pNamespace  --
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemServices::CWbemServices(
    IWbemServices * pNamespace
    )
    : m_pWbemServices( NULL )
{
    m_pWbemServices = pNamespace;
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->AddRef( );
    }

} //*** CWbemServices::CWbemServices()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemServices::~CWbemServices( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemServices::~CWbemServices( void )
{
    if ( m_pWbemServices != NULL )
    {
        m_pWbemServices->Release();
    }

} //*** CWbemServices::~CWbemServices()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::CreateClassEnum(
//      BSTR                    bstrSuperclassIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      Returns an enumerator for all classes satisfying the
//      selection criteria
//
//  Arguments:
//      bstrSuperclassIn
//          Specifies a superclass name
//
//      lFlagsIn
//          accepts WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_
//          RETURN_IMMEDIATELY, WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_
//          BIDIRECTIONAL
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the pointer to the enumerator
//
//  Return Value:
//      WBEM stand error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::CreateClassEnum(
    BSTR                    bstrSuperclassIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->CreateClassEnum(
                bstrSuperclassIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::CreateClassEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::CreateInstanceEnum(
//      BSTR                    bstrClassIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      creates an enumerator that returns the instances of a
//      specified class according to user-specified selection
//      criteria
//
//  Arguments:
//      bstrClassIn
//          Specifies a superclass name
//
//      lFlagsIn
//          accepts WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_
//          RETURN_IMMEDIATELY, WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_
//          BIDIRECTIONAL
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the pointer to the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::CreateInstanceEnum(
    BSTR                    bstrClassIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->CreateInstanceEnum(
                bstrClassIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::CreateInstanceEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::DeleteClass(
//      BSTR                bstrClassIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//    )
//
//  Description:
//      Deletes the specified class from the current namespace.
//
//  Arguments:
//      bstrClassIn
//          The name of the class targeted for deletion.
//
//      lFlagsIn
//          accepts WBEM_FLAG_RETURN_IMMEDIATELY, WBEM_FLAG_
//          OWNER_UPDATE
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          Receives the call result
//
//  Return Value:
//      WBEM stand error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::DeleteClass(
    BSTR                bstrClassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->DeleteClass(
                bstrClassIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::DeleteClass()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::DeleteInstance(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      deletes an instance of an existing class in the current namespace
//
//  Arguments:
//      bstrObjectPathIn
//          object path to the instance to be deleted.
//
//      lFlagsIn
//          accepts WBEM_FLAG_RETURN_IMMEDIATELY
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          Receives the call result
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::DeleteInstance(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->DeleteInstance(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::DeleteInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecMethod(
//      BSTR                bstrObjectPathIn,
//      BSTR                bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemClassObject ** ppOurParamsOut,
//      IWbemCallResult **  ppCallResultOut
//      )
//
//  Description:
//      execute methods for the given object
//
//  Arguments:
//      bstrObjectPathIn
//          object path of the object for which the method is executed
//
//      bstrMethodNameIn
//          name of the method to be invoked
//
//      lFlagsIn
//          zero to make this a synchronous call
//
//      pCtxIn
//          Typically NULL
//
//      pInParamsIn
//          Input parameters for the method
//
//      ppOurParamsOut
//          output parameters for the method
//
//      ppCallResultOut
//          To receive call result
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecMethod(
    BSTR                bstrObjectPathIn,
    BSTR                bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemClassObject ** ppOurParamsOut,
    IWbemCallResult **  ppCallResultOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecMethod(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                ppOurParamsOut,
                ppCallResultOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecMethod()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecNotificationQuery(
//      BSTR                    bstrQueryLanguageIn,
//      BSTR                    bstrQueryIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      Executes a query to receive events.
//
//  Arguments:
//      bstrQueryLanguageIn
//          BSTR containing one of the query languages supported by WMI
//
//      bstrQueryIn
//          text of the event-related query
//
//      lFlagsIn
//          WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          Receives the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecNotificationQuery(
    BSTR                    bstrQueryLanguageIn,
    BSTR                    bstrQueryIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecNotificationQuery(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecNotificationQuery()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::ExecQuery(
//      BSTR                    bstrQueryLanguageIn,
//      BSTR                    bstrQueryIn,
//      long                    lFlagsIn,
//      IWbemContext *          pCtxIn,
//      IEnumWbemClassObject ** ppEnumOut
//      )
//
//  Description:
//      executes a query to retrieve objects.
//
//  Arguments:
//      bstrQueryLanguageIn
//          BSTR containing one of the query languages supported by WMI
//
//      bstrQueryIn
//          containing the text of the query
//
//      lFllFlagsIn
//          WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY
//          WBEM_FLAG_BIDIRECTIONAL, WBEM_FLAG_ENSURE_LOCATABLE
//          WBEM_FLAG_PROTOTYPE
//
//      pCtxIn
//          Typically NULL
//
//      ppEnumOut
//          receives the enumerator
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::ExecQuery(
    BSTR                    bstrQueryLanguageIn,
    BSTR                    bstrQueryIn,
    long                    lFlagsIn,
    IWbemContext *          pCtxIn,
    IEnumWbemClassObject ** ppEnumOut
    )
{
    HRESULT hr;

    hr = m_pWbemServices->ExecQuery(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                ppEnumOut
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::ExecQuery()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::GetObject(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject ** ppObjectInout,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      retrieves a class or instance
//
//  Arguments:
//      bstrObjectPathIn
//          The object path of the object to retrieve
//
//      lFlagsIn
//          0
//
//      pCtxIn
//          Typically NULL
//
//      ppObjectInout
//          If not NULL, this receives the object
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::GetObject(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject ** ppObjectInout,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->GetObject(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                ppObjectInout,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::GetObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::PutClass(
//      IWbemClassObject *  pObjectIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      Creates a new class or updates an existing one
//
//  Arguments:
//      pObjectIn
//          point to a valid class definition
//
//      lFlagsIn
//          WBEM_FLAG_CREATE_OR_UPDATE,WBEM_FLAG_UPDATE_ONLY,
//          WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY,
//          WBEM_FLAG_OWNER_UPDATE, WBEM_FLAG_UPDATE_COMPATIBLE,
//          WBEM_FLAG_UPDATE_SAFE_MODE, WBEM_FLAG_UPDATE_FORCE_MODE
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::PutClass(
    IWbemClassObject *  pObjectIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->PutClass(
                pObjectIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::PutClass()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CWbemServices::PutInstance(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemCallResult **  ppCallResultInout
//      )
//
//  Description:
//      Creates or updates an instance of an existing class.
//
//  Arguments:
//      pInstIn
//          Points to the instance to be written
//
//      lFlagsIn
//          WBEM_FLAG_CREATE_OR_UPDATE,WBEM_FLAG_UPDATE_ONLY,
//          WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_RETURN_IMMEDIATELY,
//
//      pCtxIn
//          Typically NULL
//
//      ppCallResultInout
//          If the lFlags parameter contains WBEM_FLAG_RETURN_IMMEDIATELY,
//          this call will return immediately with WBEM_S_NO_ERROR. The
//          ppCallResult parameter will receive a pointer to a new
//          IWbemCallResult object
//
//  Return Value:
//      WBEM standard error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWbemServices::PutInstance(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemCallResult **  ppCallResultInout
    )
{
    HRESULT hr;

    hr = m_pWbemServices->PutInstance(
                pInstIn,
                lFlagsIn,
                pCtxIn,
                ppCallResultInout
                );
    if ( SUCCEEDED( hr ) )
    {
        hr = CoImpersonateClient();
    } // if:

    return hr;

} //*** CWbemServices::PutInstance()

//****************************************************************************
//
//  CImpersonatedProvider
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonatedProvider::CImpersonatedProvider(
//      BSTR            bstrObjectPathIn    = NULL,
//      BSTR            bstrUserIn          = NULL,
//      BSTR            bstrPasswordIn      = NULL,
//      IWbemContext *  pCtxIn              = NULL
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrUserIn          --
//      bstrPasswordIn      --
//      pCtxIn              --
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CImpersonatedProvider::CImpersonatedProvider(
    BSTR            ,// bstrObjectPathIn.
    BSTR            ,// bstrUserIn,
    BSTR            ,// bstrPasswordIn,
    IWbemContext *  // pCtxIn
    )
    : m_cRef( 0 ), m_pNamespace( NULL )
{

} //*** CImpersonatedProvider::CImpersonatedProvider()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CImpersonatedProvider::~CImpersonatedProvider( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CImpersonatedProvider::~CImpersonatedProvider( void )
{
    delete m_pNamespace;

} //*** CImpersonatedProvider::~CImpersonatedProvider()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CImpersonatedProvider::AddRef( void )
//
//  Description:
//      Increment the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CImpersonatedProvider::AddRef( void )
{
    return InterlockedIncrement( ( long * ) & m_cRef );

} //*** CImpersonatedProvider::AddRef()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CImpersonatedProvider::Release( void )
//
//  Description:
//      Release a reference on the COM object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      New reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CImpersonatedProvider::Release( void )
{
    ULONG nNewCount = InterlockedDecrement( ( long * ) & m_cRef  );
    if ( 0L == nNewCount )
        delete this;

    return nNewCount;

} //*** CImpersonatedProvider::Release()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::QueryInterface(
//      REFIID  riid,
//      PPVOID  ppv
//      )
//
//  Description:
//      Initialize the provider.
//
//  Arguments:
//      riidIn      -- Interface ID being queried.
//      ppvOut      -- Pointer in which to return interface pointer.
//
//  Return Value:
//      NOERROR
//      E_NOINTERFACE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CImpersonatedProvider::QueryInterface(
    REFIID  riid,
    PPVOID  ppv
    )
{
    *ppv = NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if ( riid == IID_IWbemServices )
    {
       *ppv = static_cast< IWbemServices * >( this );
    }

    if ( IID_IUnknown == riid || riid == IID_IWbemProviderInit )
    {
        *ppv = static_cast< IWbemProviderInit * >( this );
    }


    if ( NULL != *ppv )
    {
        AddRef();
        return NOERROR;
    }
    else
    {
        return E_NOINTERFACE;
    }

} //*** CImpersonatedProvider::QueryInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        --
//      pszNamespaeIn   --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          --
//      pInitSinkIn     --
//
//  Return Value:
//      WBEM_S_NO_ERROR
//      WBEM_E_OUT_OF_MEMORY
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CImpersonatedProvider::Initialize(
    LPWSTR                  ,// pszUserIn,
    LONG                    ,// lFlagsIn,
    LPWSTR                  ,// pszNamespaceIn,
    LPWSTR                  ,// pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          ,// pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;

    m_pNamespace = new CWbemServices( pNamespaceIn );
    if ( m_pNamespace == NULL )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        lStatus = WBEM_E_FAILED;
    } // if: error allocating memory

    //Let CIMOM know you are initialized
    //==================================

    pInitSinkIn->SetStatus( lStatus, 0 );
    return hr;

} //*** CImpersonatedProvider::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::CreateInstanceEnumAsync(
//      const BSTR          bstrClassIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Create an instance asynchronously.
//
//  Arguments:
//      bstrClassIn         --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoCreateInstanceEnumAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    const BSTR          bstrClassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoCreateInstanceEnumAsync(
                    bstrClassIn,
                    lFlagsIn,
                    pCtxIn,
                    pResponseHandlerIn
                    );
    } // if:

    return hr;

} //*** CImpersonatedProvider::CreateInstanceEnumAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::DeleteInstanceAsync(
//      const BSTR          bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Delete an instance asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoDeleteInstanceAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    const BSTR          bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoDeleteInstanceAsync(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::DeleteInstanceAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::ExecMethodAsync(
//      const BSTR          bstrObjectPathIn,
//      const BSTR          bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Execute a method asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrMethodNameIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pInParamsIn         --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoExecMethodAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::ExecMethodAsync(
    const BSTR          bstrObjectPathIn,
    const BSTR          bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoExecMethodAsync(
                bstrObjectPathIn,
                bstrMethodNameIn,
                lFlagsIn,
                pCtxIn,
                pInParamsIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::ExecMethodAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::ExecQueryAsync(
//      const BSTR          bstrQueryLanguageIn,
//      const BSTR          bstrQueryIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Execute a query asynchronously.
//
//  Arguments:
//      bstrQueryLanguageIn --
//      bstrQueryIn         --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoExecQueryAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::ExecQueryAsync(
    const BSTR          bstrQueryLanguageIn,
    const BSTR          bstrQueryIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoExecQueryAsync(
                bstrQueryLanguageIn,
                bstrQueryIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::ExecQueryAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::GetObjectAsync(
//      const BSTR          bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Get an instance asynchronously.
//
//  Arguments:
//      bstrObjectPathIn    --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoGetObjectAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::GetObjectAsync(
    const BSTR          bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext  *     pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoGetObjectAsync(
                bstrObjectPathIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::GetObjectAsync()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CImpersonatedProvider::PutInstanceAsync(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext  *     pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Save an instance asynchronously.
//
//  Arguments:
//      pInstIn             --
//      lFlagsIn            --
//      pCtxIn              --
//      pResonseHandlerIn   --
//
//  Return Value:
//      Any return values fro DoPutInstanceAsync().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CImpersonatedProvider::PutInstanceAsync(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext  *     pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    HRESULT hr;

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        hr = DoPutInstanceAsync(
                pInstIn,
                lFlagsIn,
                pCtxIn,
                pResponseHandlerIn
                );
    } // if:

    return hr;

} //*** CImpersonatedProvider::PutInstanceAsync()

//****************************************************************************
//
//  CWbemInstanceMgr
//
//****************************************************************************

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::CWbemInstanceMgr(
//      IWbemObjectSink *   pHandlerIn,
//      DWORD               dwSizeIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pHandlerIn      -- WMI sink.
//      dwSizeIn        --
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemInstanceMgr::CWbemInstanceMgr(
    IWbemObjectSink *   pHandlerIn,
    DWORD               dwSizeIn    // = 50
    )
    : m_pSink( NULL )
    , m_ppInst( NULL )
    , m_dwIndex( 0 )
{
    DWORD dwIndex = 0;

    m_pSink = pHandlerIn;
    if ( m_pSink == NULL )
    {
        throw static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    } // if: no sink specified

    m_pSink->AddRef( );
    m_dwThreshHold = dwSizeIn;
    m_ppInst = new IWbemClassObject*[ dwSizeIn ];
    for ( dwIndex = 0 ; dwIndex < dwSizeIn ; dwIndex++ )
    {
        m_ppInst[ dwIndex ] = NULL;
    } // for each in m_ppInst

} //*** CWbemInstanceMgr::CWbemInstanceMgr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::CWbemInstanceMgr( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWbemInstanceMgr::~CWbemInstanceMgr( void )
{
    if ( m_ppInst != NULL )
    {
        if ( m_dwIndex > 0 )
        {
            m_pSink->Indicate( m_dwIndex, m_ppInst );
        }
        DWORD dwIndex = 0;
        for ( dwIndex = 0; dwIndex < m_dwIndex; dwIndex++ )
        {
            if ( m_ppInst[ dwIndex ] != NULL )
            {
                ( m_ppInst[ dwIndex ] )->Release( );
            }
        }
        delete [] m_ppInst;
    }

    m_pSink->Release( );

} //*** CWbemInstanceMgr::~CWbemInstanceMgr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CWbemInstanceMgr::Indicate(
//      IN IWbemClassObject *   pInstIn
//    )
//
//  Description:
//      Notify an instance to WMI sink
//
//  Arguments:
//      pInstIn     -- Instance to send to WMI
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWbemInstanceMgr::Indicate(
    IN IWbemClassObject *   pInstIn
    )
{
    if ( pInstIn == NULL )
    {
        throw static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER );
    }

    m_ppInst[ m_dwIndex++ ] = pInstIn;
    pInstIn->AddRef( );
    if ( m_dwIndex == m_dwThreshHold )
    {
        HRESULT sc = WBEM_S_NO_ERROR;
        sc = m_pSink->Indicate( m_dwIndex, m_ppInst );
        if( FAILED( sc ) )
        {
            if ( sc == WBEM_E_CALL_CANCELLED )
            {
                sc = WBEM_S_NO_ERROR;
            }
            throw CProvException( sc );
        }

        // reset state
        DWORD dwIndex = 0;
        for ( dwIndex = 0; dwIndex < m_dwThreshHold; dwIndex++ )
        {
            if ( m_ppInst[ dwIndex ] != NULL )
            {
                ( m_ppInst[ dwIndex ] )->Release( );
            } //*** if m_ppInst[ _dwIndex ] != NULL

            m_ppInst[ dwIndex ] = NULL;

        } //*** for each in m_ppInst

        m_dwIndex = 0;

    } //*** if( m_dwIndex == m_dwThreshHold )
    return;

} //*** CWbemInstanceMgr::Indicate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemInstanceMgr::SetStatus
//
//  Description:
//      send status to WMI sink
//
//  Arguments:
//      lFlagsIn        -- WMI flag
//      hrIn            -- HResult
//      bstrParamIn     -- Message
//      pObjParamIn     -- WMI extended error object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWbemInstanceMgr::SetStatus(
    LONG                lFlagsIn,
    HRESULT             hrIn,
    BSTR                bstrParamIn,
    IWbemClassObject *  pObjParamIn
    )
{
    m_pSink->SetStatus(
        lFlagsIn,
        hrIn,
        bstrParamIn,
        pObjParamIn
        );

} //*** CWbemInstanceMgr::SetStatus()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\ntrkcomm.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      NtRkComm.h
//
//  Implementation File:
//      NtRkComm.cpp
//
//  Description:
//      Definition of the CWbemServices, CImpersonatedProvider and 
//      CInstanceMgr class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemServices
//
//  Description:
//      Wraps for IWbemServices. security impersonation is implemented here
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWbemServices
{
protected:
    IWbemServices * m_pWbemServices;

public:
    CWbemServices( IWbemServices * );
    virtual ~CWbemServices( void );

    HRESULT STDMETHODCALLTYPE GetObject(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject ** ppObjectInout,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE PutClass(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE DeleteClass(
        BSTR                bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE CreateClassEnum(
        BSTR                    bstrSuperclassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE PutInstance(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE DeleteInstance(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        );

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
        BSTR                    bstrClassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
        BSTR                    bstrQueryLanguageIn,
        BSTR                    bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
        BSTR                    bstrQueryLanguageIn,
        BSTR                    bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        );

    HRESULT STDMETHODCALLTYPE ExecMethod(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemClassObject ** ppOurParamsOut,
        IWbemCallResult **  ppCallResultOut
        );

}; //*** class CWbemServices

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CImpersonatedProvider
//
//  Description:
//      a middle layer between IWbemservices and actual provider. It takes
//      care of security impersonation
//
//--
//////////////////////////////////////////////////////////////////////////////
class CImpersonatedProvider
    : public IWbemServices
    , public IWbemProviderInit
{
protected:
    ULONG               m_cRef;         //Object reference count
    CWbemServices *     m_pNamespace;

public:
    CImpersonatedProvider(
        BSTR            bstrObjectPathIn    = NULL,
        BSTR            bstrUserIn          = NULL,
        BSTR            bstrPasswordIn      = NULL,
        IWbemContext *  pCtxIn              = NULL
        );
    virtual ~CImpersonatedProvider( void );

    //Non-delegating object IUnknown

    STDMETHODIMP            QueryInterface( REFIID riid, PPVOID ppv );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         LPWSTR                     pszUserIn,
         LONG                       lFlagsIn,
         LPWSTR                     pszNamespaceIn,
         LPWSTR                     pszLocaleIn,
         IWbemServices *            pNamespaceIn,
         IWbemContext *             pCtxIn,
         IWbemProviderInitSink *    pInitSinkIn
         );

     //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace(
        const BSTR          bstrNamespaceIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemServices **    ppWorkingNamespaceInout,
        IWbemCallResult **  ppResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CancelAsyncCall(
        IWbemObjectSink  *  pSinkIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE QueryObjectSink(
        long                lFlagsIn,
        IWbemObjectSink **  ppResponseHandlerOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE GetObject(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject ** ppObjectInout,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE GetObjectAsync(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE PutClass(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutClassAsync(
        IWbemClassObject *  pObjectIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteClass(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteClassAsync(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnum(
        const BSTR              bstrSuperclassIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutInstance(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE PutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DeleteInstance(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemCallResult **  ppCallResultInout
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
        const BSTR          bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
        const BSTR               bstrClassIn,
        long                     lFlagsIn,
        IWbemContext *           pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
        const BSTR          bstrClassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
        const BSTR              bstrQueryLanguageIn,
        const BSTR              bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecQueryAsync(
        const BSTR           bstrQueryLanguageIn,
        const BSTR           bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pResponseHandlerIn
        );

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
        const BSTR              bstrQueryLanguageIn,
        const BSTR              bstrQueryIn,
        long                    lFlagsIn,
        IWbemContext*           pCtxIn,
        IEnumWbemClassObject ** ppEnumOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
        const BSTR           bstrQueryLanguageIn,
        const BSTR           bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethod(
        const BSTR          bstrObjectPathIn,
        const BSTR          bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemClassObject ** ppOurParamsOut,
        IWbemCallResult **  ppCallResultOut
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        const BSTR          bstrObjectPathIn,
        const BSTR          bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pResponseHandlerIn
        );

protected:
    virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                bstrRefStrIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                bstrQueryLanguageIn,
        BSTR                bstrQueryIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;
    virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                    bstrObjectPathIn,
        long                    lFlagsIn,
        IWbemContext *          pCtxIn,
        IWbemObjectSink FAR *   pHandlerIn
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

}; //*** class CImpersonatedProvider

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemInstanceMgr
//
//  Description:
//      Manage WMI instance, allow block indicate
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWbemInstanceMgr
{
protected:
    IWbemObjectSink *   m_pSink;
    IWbemClassObject ** m_ppInst;
    DWORD               m_dwThreshHold;
    DWORD               m_dwIndex;

public:

    CWbemInstanceMgr(
        IWbemObjectSink *   pHandlerIn,
        DWORD               dwSizeIn = 50
        );
    
    virtual ~CWbemInstanceMgr( void );

    void Indicate(
        IN IWbemClassObject * pInst
        );

    void SetStatus(
        LONG                lFlagsIn,
        HRESULT             hrIn,
        BSTR                bstrParamIn,
        IWbemClassObject *  pObjParamIn
        );

}; //*** class CWbemInstanceMgr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\instanceprov.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.h
//
//  Implementation File:
//      InstanceProv.cpp
//
//  Description:
//      Definition of the CInstanceProv class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CInstanceProv;
class CClassProv;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

class CWbemClassObject;
class CProvException;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CInstanceProv
//
//  Description:
//      Implement the Instance and method provider entry point class. WMI 
//      holds a pointer to this object, and invoking its member functions 
//      based client request
//
//--
//////////////////////////////////////////////////////////////////////////////
class CInstanceProv : public CImpersonatedProvider
{
protected:
    SCODE SetExtendedStatus(
        CProvException &    rpeIn,
        CWbemClassObject &  rwcoInstOut
        );
 
public:
    CInstanceProv(
        BSTR            bstrObjectPathIn    = NULL,
        BSTR            bstrUserIn          = NULL,
        BSTR            bstrPasswordIn      = NULL,
        IWbemContext *  pCtxIn              = NULL
        );
    virtual ~CInstanceProv( void );

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *   pInstIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                 bstrObjectPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                 bstrRefStrIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        );

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                 bstrQueryLanguageIn,
        BSTR                 bstrQueryIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) ;

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        );

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        ) ;

    STDMETHODIMP Initialize(
         LPWSTR                  pszUserIn,
         LONG                    lFlagsIn,
         LPWSTR                  pszNamespaceIn,
         LPWSTR                  pszLocaleIn,
         IWbemServices *         pNamespaceIn,
         IWbemContext *          pCtxIn,
         IWbemProviderInitSink * pInitSinkIn
         );

    static HRESULT S_HrCreateThis(
        IUnknown *  pUnknownOuterIn,
        VOID **     ppvOut
        );

}; //*** CInstanceProv

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClassProv
//
//  Description:
//      Implement the Class provider entry point class. WMI
//      holds a pointer to this object, and invoking its member functions
//      based client request
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClassProv : public CImpersonatedProvider
{
public:
    CClassProv( void );
    virtual ~CClassProv( void );

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        BSTR                bstrObjectPathIN,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync(
        IWbemClassObject *  pInstIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync(
        BSTR                bstrObjectPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync(
        BSTR                bstrRefStrIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync(
        BSTR                bstrQueryLanguageIn,
        BSTR                bstrQueryIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        BSTR                bstrObjectPathIn,
        BSTR                bstrMethodNameIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemClassObject *  pInParamsIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
        const BSTR          bstrSuperclassIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pResponseHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHODIMP Initialize(
         LPWSTR                  pszUserIn,
         LONG                    lFlagsIn,
         LPWSTR                  pszNamespaceIn,
         LPWSTR                  pszLocaleIn,
         IWbemServices *         pNamespaceIn,
         IWbemContext *          pCtxIn,
         IWbemProviderInitSink * pInitSinkIn
         );

    static HRESULT S_HrCreateThis(
        IUnknown *  pUnknownOuterIn,
        VOID **     ppvOut
        );

protected:
    void CreateMofClassFromResource(
        HRESOURCE           hResourceIn,
        LPCWSTR             pwszTypeNameIn,
        CWbemClassObject &  pClassInout
        );

    void CreateMofClassFromResType(
        HCLUSTER            hCluster,
        LPCWSTR             pwszTypeNameIn,
        CWbemClassObject &  pClassInout
        );

}; //*** class CClassProv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\instanceprov.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      InstanceProv.cpp
//
//  Description:
//      Implementation of CInstanceProv class
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InstanceProv.h"
#include "ClusterResource.h"
#include "Cluster.h"
#include "ClusterNode.h"
#include "ClusterGroup.h"
#include "ClusterNodeRes.h"
#include "ClusterResourceType.h"
#include "ClusterEnum.h"
#include "Clusternetwork.h"
#include "ClusterNetInterface.h"
#include "ClusterObjAssoc.h"
#include "ClusterNodeGroup.h"
#include "ClusterResTypeRes.h"
#include "ClusterResDepRes.h"
#include "ClusterResNode.h"
#include "ClusterGroupNode.h"
#include "ClusterService.h"
#include "InstanceProv.tmh"

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

long                g_lNumInst = 0;
ClassMap            g_ClassMap;
TypeNameToClass     g_TypeNameToClass;

//****************************************************************************
//
//  CInstanceProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CInstanceProv::CInstanceProv(
//      BSTR            bstrObjectPathIn    = NULL,
//      BSTR            bstrUserIn          = NULL,
//      BSTR            bstrPasswordIn      = NULL,
//      IWbemContext *  pCtxIn              = NULL
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      bstrObjectPathIn    --
//      bstrUserIn          --
//      bstrPasswordIn      --
//      pCtxIn              --
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CInstanceProv::CInstanceProv(
    BSTR            ,// bstrObjectPathIn,
    BSTR            ,// bstrUserIn,
    BSTR            ,// bstrPasswordIn,
    IWbemContext *  // pCtxIn
    )
{
 //   m_pNamespace = NULL;
 //   m_cRef = 0;
    InterlockedIncrement( &g_cObj );
    return;

} //*** CInstanceProv::CInstanceProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CInstanceProv::~CInstanceProv( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CInstanceProv::~CInstanceProv( void )
{
    InterlockedDecrement( &g_cObj );
#ifdef _DEBUG
    _CrtDumpMemoryLeaks();
#endif

    return;

} //*** CInstanceProv::~CInstanceProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoExecQueryAsync(
//      BSTR                bstrQueryLanguageIn,
//      BSTR                bstrQueryIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Enumerate instance for a given class.
//
//  Arguments:
//      bstrQueryLanguageIn
//           A valid BSTR containing one of the query languages
//           supported by Windows Management. This must be WQL.
//
//      bstrQueryIn
//          A valid BSTR containing the text of the query
//
//      lFlagsIn
//          WMI flag
//
//      pCtxIn
//          WMI context
//
//      pHandlerIn
//          WMI sink pointer
//
//  Return Values:
//      WBEM_E_NOT_SUPPORTED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoExecQueryAsync(
    BSTR                ,// bstrQueryLanguageIn,
    BSTR                ,// bstrQueryIn,
    long                ,// lFlagsIn,
    IWbemContext *      ,// pCtxIn,
    IWbemObjectSink *   // pHandlerIn
    )
{
//  pHandler->SetStatus( WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL );
//  return sc;
//  pHandler->SetStatus( WBEM_E_PROVIDER_NOT_CAPABLE, S_OK, NULL, NULL );
    return WBEM_E_NOT_SUPPORTED;
//  return WBEM_E_PROVIDER_NOT_CAPABLE;
    //WBEM_E_PROVIDER_NOT_CAPABLE;

} //*** CInstanceProv::DoExecQueryAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoCreateInstanceEnumAsync(
//      BSTR                bstrRefStrIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Enumerate instance for a given class.
//
//  Arguments:
//      bstrRefStrIn    -- Name the class to enumerate
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoCreateInstanceEnumAsync(
    BSTR                bstrRefStrIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE                   sc      = WBEM_S_NO_ERROR;
    IWbemClassObject *      pStatus = NULL;
    CWbemClassObject        Status;
    auto_ptr< CProvBase >   pProvBase;

    // Do a check of arguments and make sure we have pointer to Namespace

    if ( pHandlerIn == NULL || m_pNamespace == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {

        CreateClass(
            bstrRefStrIn,
            m_pNamespace,
            pProvBase
            );
        sc = pProvBase->EnumInstance(
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    } // try
    catch ( CProvException prove )
    {
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = prove.hrGetError();
            pStatus = Status.data();
        }
    } // catch
    catch( ... )
    {
        sc =  WBEM_E_FAILED;
    }

    sc =  pHandlerIn->SetStatus(
                WBEM_STATUS_COMPLETE,
                sc,
                NULL,
                pStatus
                );

    return WBEM_S_NO_ERROR;

} //*** CInstanceProv::DoCreateInstanceEnumAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoGetObjectAsync(
//      BSTR                bstrObjectPathIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Creates an instance given a particular path value.
//
//  Arguments:
//      bstrObjectPathIn    -- Object path to an object
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoGetObjectAsync(
    BSTR                bstrObjectPathIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE                   sc;
    CObjPath                ObjPath;
    auto_ptr< CProvBase >   pProvBase;

    // Do a check of arguments and make sure we have pointer to Namespace

    if ( bstrObjectPathIn == NULL || pHandlerIn == NULL || m_pNamespace == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify

    try
    {

        if ( ObjPath.Init( bstrObjectPathIn ) != TRUE )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CreateClass(
            ObjPath.GetClassName(),
            m_pNamespace,
            pProvBase
            );

        sc = pProvBase->GetObject(
                ObjPath,
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    } // try
    catch ( CProvException  prove )
    {
        CWbemClassObject Status;
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = pHandlerIn->SetStatus(
                    WBEM_STATUS_COMPLETE,
                    WBEM_E_FAILED,
                    NULL,
                    Status.data( )
                    );

            return sc;
        }

    }
    catch( ... )
    {
        sc = WBEM_E_FAILED;
    }

    pHandlerIn->SetStatus(
        WBEM_STATUS_COMPLETE,
        sc,
        NULL,
        NULL
        );

    return sc;

} //*** CInstanceProv::DoGetObjectAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoPutInstanceAsync(
//      IWbemClassObject *  pInstIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Save this instance.
//
//  Arguments:
//      pInstIn         -- WMI object to be saved
//      lFlagsIn        -- WMI flag
//      pCtxIn          -- WMI context
//      pHandlerIn      -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoPutInstanceAsync(
    IWbemClassObject *  pInstIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE               sc      = WBEM_S_NO_ERROR;
    IWbemClassObject *  pStatus = NULL;
    CWbemClassObject    Status;

    if ( pInstIn == NULL || pHandlerIn == NULL  )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // get class name
        _bstr_t                 bstrClass;
        CWbemClassObject        wcoInst( pInstIn );
        auto_ptr< CProvBase >   pProvBase;

        wcoInst.GetProperty( bstrClass, PVD_WBEM_CLASS );

        CreateClass( bstrClass, m_pNamespace, pProvBase );

        sc = pProvBase->PutInstance(
                wcoInst,
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    }
    catch ( CProvException prove )
    {
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = prove.hrGetError();
            pStatus = Status.data();
        }
    }
    catch ( ... )
    {
        sc = WBEM_E_FAILED;
    }

    return pHandlerIn->SetStatus(
                WBEM_STATUS_COMPLETE,
                sc,
                NULL,
                pStatus
                );

} //*** CInstanceProv::DoPutInstanceAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoDeleteInstanceAsync(
//       BSTR               bstrObjectPathIn,
//       long               lFlagsIn,
//       IWbemContext *     pCtxIn,
//       IWbemObjectSink *  pHandlerIn
//       )
//
//  Description:
//      Delete this instance.
//
//  Arguments:
//      bstrObjectPathIn    -- ObjPath for the instance to be deleted
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//      Win32 error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoDeleteInstanceAsync(
     BSTR               bstrObjectPathIn,
     long               lFlagsIn,
     IWbemContext *     pCtxIn,
     IWbemObjectSink *  pHandlerIn
     )
{
    SCODE                   sc;
    CObjPath                ObjPath;
    _bstr_t                 bstrClass;
    auto_ptr< CProvBase >   pProvBase;

    // Do a check of arguments and make sure we have pointer to Namespace

    if ( bstrObjectPathIn == NULL || pHandlerIn == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify

    try
    {
        if ( ! ObjPath.Init( bstrObjectPathIn ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName();
        CreateClass( bstrClass, m_pNamespace, pProvBase );

        sc = pProvBase->DeleteInstance(
                ObjPath,
                lFlagsIn,
                pCtxIn,
                pHandlerIn
                );
    } // try
    catch ( CProvException prove )
    {
        CWbemClassObject    Status;

        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = pHandlerIn->SetStatus(
                    WBEM_STATUS_COMPLETE,
                    WBEM_E_FAILED,
                    NULL,
                    Status.data()
                    );
            return sc;
        }
    }
    catch ( ... )
    {
        sc = WBEM_E_FAILED;
    }

    pHandlerIn->SetStatus(
        WBEM_STATUS_COMPLETE,
        sc,
        NULL,
        NULL
        );

    return sc;

} //*** CInstanceProv::DoDeleteInstanceAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::DoExecMethodAsync(
//      BSTR                bstrObjectPathIn,
//      BSTR                bstrMethodNameIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemClassObject *  pInParamsIn,
//      IWbemObjectSink *   pHandlerIn
//      )
//
//  Description:
//      Execute methods for the given object.
//
//  Arguments:
//      bstrObjectPathIn    -- Object path to a given object
//      bstrMethodNameIn    -- Name of the method to be invoked
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pInParamsIn         -- Input parameters for the method
//      pHandlerIn          -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::DoExecMethodAsync(
    BSTR                bstrObjectPathIn,
    BSTR                bstrMethodNameIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemClassObject *  pInParamsIn,
    IWbemObjectSink *   pHandlerIn
    )
{
    SCODE sc = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    
    if ( bstrObjectPathIn == NULL || pHandlerIn == NULL || m_pNamespace == NULL
        || bstrMethodNameIn == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        CObjPath                ObjPath;
        _bstr_t                 bstrClass;
        auto_ptr< CProvBase >   pProvBase;

        if ( ! ObjPath.Init( bstrObjectPathIn ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        bstrClass = ObjPath.GetClassName( );

        CreateClass( bstrClass, m_pNamespace, pProvBase );

        sc = pProvBase->ExecuteMethod(
                ObjPath,
                bstrMethodNameIn,
                lFlagsIn,
                pInParamsIn,
                pHandlerIn
                );
    } // try

    catch ( CProvException prove )
    {
        CWbemClassObject Status;
        sc = SetExtendedStatus( prove, Status );
        if ( SUCCEEDED( sc ) )
        {
            sc = pHandlerIn->SetStatus(
                    WBEM_STATUS_COMPLETE,
                    WBEM_E_FAILED,
                    NULL,
                    Status.data( )
                    );
            return sc;
        }
    }
    catch ( ... )
    {
        sc = WBEM_E_FAILED;
    }

    if ( sc != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32( sc );
    }
    
    pHandlerIn->SetStatus(
        WBEM_STATUS_COMPLETE,
        hr,
        NULL,
        NULL );

    return sc;

} //*** CInstanceProv::DoExecMethodAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::CreateClassEnumAsync(
//      const BSTR          bstrSuperclassIn,
//      long                lFlagsIn,
//      IWbemContext *      pCtxIn,
//      IWbemObjectSink *   pResponseHandlerIn
//      )
//
//  Description:
//      Create a class enumerator.
//
//  Arguments:
//      bstrSuperclassIn    -- Class to create
//      lFlagsIn            -- WMI flag
//      pCtxIn              -- WMI context
//      pResponseHandlerIn  -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::CreateClassEnumAsync(
    const BSTR          bstrSuperclassIn,
    long                lFlagsIn,
    IWbemContext *      pCtxIn,
    IWbemObjectSink *   pResponseHandlerIn
    )
{
    return WBEM_S_NO_ERROR;

} //*** CInstanceProv::CreateClassEnumAsync()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CInstanceProv::SetExtendedStatus(
//      CProvException &    rpeIn,
//      CWbemClassObject &  rwcoInstOut
//      )
//
//  Description:
//      Create and set extended error status.
//
//  Arguments:
//      rpeIn       -- Exception object.
//      rwcoInstOut -- Reference to WMI instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CInstanceProv::SetExtendedStatus(
    CProvException &    rpeIn,
    CWbemClassObject &  rwcoInstOut
    )
{
    SCODE               sc = WBEM_S_NO_ERROR;
    IWbemClassObject *  pStatus = NULL;

    sc =  m_pNamespace->GetObject(
                _bstr_t( PVD_WBEM_EXTENDEDSTATUS ),
                0,
                NULL,
                &pStatus,
                NULL
                );
    if ( SUCCEEDED( sc ) )
    {
        sc = pStatus->SpawnInstance( 0, &rwcoInstOut );
        if ( SUCCEEDED( sc ) )
        {
            rwcoInstOut.SetProperty( rpeIn.PwszErrorMessage(), PVD_WBEM_DESCRIPTION );
            rwcoInstOut.SetProperty( rpeIn.DwGetError(),       PVD_WBEM_STATUSCODE );
        }
    }

    return sc;

} //*** CInstanceProv::SetExtendedStatus()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CInstanceProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pUnknownOuterIn -- Outer IUnknown pointer.
//      ppvOut          -- Receives the created instance pointer.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CInstanceProv::S_HrCreateThis(
    IUnknown *  ,// pUnknownOuterIn,
    VOID **     ppvOut
    )
{
    *ppvOut = new CInstanceProv();
    return S_OK;

} //*** CInstanceProv::S_HrCreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CInstanceProv::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the instance provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        -- WMI flag
//      pszNamespaceIn  --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          -- WMI context
//      pInitSinkIn     -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CInstanceProv::Initialize(
    LPWSTR                  pszUserIn,
    LONG                    lFlagsIn,
    LPWSTR                  pszNamespaceIn,
    LPWSTR                  pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{

    g_ClassMap[ PVD_CLASS_CLUSTER ] =
        CClassCreator( (FPNEW) CCluster::S_CreateThis, PVD_CLASS_CLUSTER , 0 );
    g_ClassMap[ PVD_CLASS_NODE ] =
        CClassCreator( (FPNEW) CClusterNode::S_CreateThis, PVD_CLASS_NODE , 0 );
    g_ClassMap[ PVD_CLASS_RESOURCE ] =
        CClassCreator( (FPNEW) CClusterResource::S_CreateThis, PVD_CLASS_RESOURCE , 0 );
    g_ClassMap[ PVD_CLASS_RESOURCETYPE ] =
        CClassCreator( (FPNEW) CClusterResourceType::S_CreateThis, PVD_CLASS_RESOURCETYPE , 0 );
    g_ClassMap[ PVD_CLASS_GROUP ] =
        CClassCreator( (FPNEW) CClusterGroup::S_CreateThis, PVD_CLASS_GROUP , 0 );
    g_ClassMap[ PVD_CLASS_NODETOACTIVERES ] =
        CClassCreator( (FPNEW) CClusterNodeRes::S_CreateThis, PVD_CLASS_NODETOACTIVERES , 0 );
    g_ClassMap[ PVD_CLASS_NETWORKINTERFACE ] =
        CClassCreator( (FPNEW) CClusterNetInterface::S_CreateThis, PVD_CLASS_NETWORKINTERFACE, 0 );
    g_ClassMap[ PVD_CLASS_NETWORK ] =
        CClassCreator( (FPNEW) CClusterNetwork::S_CreateThis, PVD_CLASS_NETWORK , 0 );

    g_ClassMap[ PVD_CLASS_CLUSTERTONETWORK ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTONETWORK , CLUSTER_ENUM_NETWORK );
    g_ClassMap[ PVD_CLASS_CLUSTERTONETINTERFACE ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTONETINTERFACE , CLUSTER_ENUM_NETINTERFACE );
    g_ClassMap[ PVD_CLASS_CLUSTERTONODE ] =
        CClassCreator( (FPNEW) CClusterToNode::S_CreateThis, PVD_CLASS_CLUSTERTONODE , CLUSTER_ENUM_NODE );
    g_ClassMap[ PVD_CLASS_CLUSTERTORES ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTORES , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_CLUSTERTORESTYPE ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTORESTYPE , CLUSTER_ENUM_RESTYPE );
    g_ClassMap[ PVD_CLASS_CLUSTERTOGROUP ] =
        CClassCreator( (FPNEW) CClusterObjAssoc::S_CreateThis, PVD_CLASS_CLUSTERTOGROUP , CLUSTER_ENUM_GROUP  );
    g_ClassMap[ PVD_CLASS_NODETOACTIVEGROUP ] =
        CClassCreator( (FPNEW) CClusterNodeGroup::S_CreateThis, PVD_CLASS_NODETOACTIVEGROUP , CLUSTER_ENUM_GROUP  );
    g_ClassMap[ PVD_CLASS_RESTYPERESOURCE ] =
        CClassCreator( (FPNEW) CClusterResTypeRes::S_CreateThis, PVD_CLASS_RESTYPERESOURCE , CLUSTER_ENUM_RESOURCE );

    
    g_ClassMap[ PVD_CLASS_RESOURCENODE ] =
        CClassCreator( (FPNEW) CClusterResNode::S_CreateThis, PVD_CLASS_RESOURCENODE , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_GROUPNODE ] =
        CClassCreator( (FPNEW) CClusterGroupNode::S_CreateThis, PVD_CLASS_GROUPNODE , CLUSTER_ENUM_GROUP );
    
    
    g_ClassMap[ PVD_CLASS_RESDEPRES ] =
        CClassCreator( (FPNEW) CClusterResDepRes::S_CreateThis, PVD_CLASS_RESDEPRES , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_GROUPTORES ] =
        CClassCreator( (FPNEW) CClusterGroupRes::S_CreateThis, PVD_CLASS_GROUPTORES , CLUSTER_ENUM_RESOURCE );
    g_ClassMap[ PVD_CLASS_NETTONETINTERFACE ] =
        CClassCreator( (FPNEW) CClusterNetNetInterface::S_CreateThis, PVD_CLASS_NETTONETINTERFACE , CLUSTER_ENUM_NETINTERFACE );
    g_ClassMap[ PVD_CLASS_NODETONETINTERFACE ] =
        CClassCreator( (FPNEW) CClusterNodeNetInterface::S_CreateThis, PVD_CLASS_NODETONETINTERFACE , CLUSTER_ENUM_NETINTERFACE );
    g_ClassMap[ PVD_CLASS_CLUSTERTOQUORUMRES ] =
        CClassCreator( (FPNEW) CClusterClusterQuorum::S_CreateThis, PVD_CLASS_CLUSTERTOQUORUMRES , 0 );
    g_ClassMap[ PVD_CLASS_SERVICES ] =
        CClassCreator( (FPNEW) CClusterService::S_CreateThis, PVD_CLASS_SERVICES , 0 );
    g_ClassMap[ PVD_CLASS_HOSTEDSERVICES ] =
        CClassCreator( (FPNEW) CClusterHostedService::S_CreateThis, PVD_CLASS_HOSTEDSERVICES , 0 );

    return CImpersonatedProvider::Initialize(
                pszUserIn,
                lFlagsIn,
                pszNamespaceIn,
                pszLocaleIn,
                pNamespaceIn,
                pCtxIn,
                pInitSinkIn
                );

} //*** CInstanceProv::Initialize()

//****************************************************************************
//
//  CClassProv
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClassProv::CClassProv( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClassProv::CClassProv( void )
{
    InterlockedIncrement( &g_cObj );

} //*** CClassProv::CClassProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClassProv::~CClassProv( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CClassProv::~CClassProv( void )
{
    InterlockedDecrement( &g_cObj );

} //*** CClassProv::~CClassProv()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClassProv::Initialize(
//      LPWSTR                  pszUserIn,
//      LONG                    lFlagsIn,
//      LPWSTR                  pszNamespaceIn,
//      LPWSTR                  pszLocaleIn,
//      IWbemServices *         pNamespaceIn,
//      IWbemContext *          pCtxIn,
//      IWbemProviderInitSink * pInitSinkIn
//      )
//
//  Description:
//      Initialize the class provider.
//
//  Arguments:
//      pszUserIn       --
//      lFlagsIn        -- WMI flag
//      pszNamespaceIn  --
//      pszLocaleIn     --
//      pNamespaceIn    --
//      pCtxIn          -- WMI context
//      pInitSinkIn     -- WMI sink pointer
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClassProv::Initialize(
    LPWSTR                  pszUserIn,
    LONG                    lFlagsIn,
    LPWSTR                  pszNamespaceIn,
    LPWSTR                  pszLocaleIn,
    IWbemServices *         pNamespaceIn,
    IWbemContext *          pCtxIn,
    IWbemProviderInitSink * pInitSinkIn
    )
{
    HRESULT                     hr;
    static map< _bstr_t, bool > mapResourceType;
    SAFECLUSTER                 shCluster;
    SAFERESOURCE                shResource;
    DWORD                       dwReturn            = ERROR_SUCCESS;
    LPCWSTR                     pwszResName         = NULL;
    LPCWSTR                     pwszResTypeName     = NULL;
    DWORD                       cbTypeName          = 1024;
    DWORD                       cbTypeNameReturned  = 0;
    CWstrBuf                    wsbTypeName;
    CWbemClassObject            wco;
    CWbemClassObject            wcoChild;
    CError                      er;

    TracePrint(( "CClassProv:Initialize entry - do resources first\n" ));

    UNREFERENCED_PARAMETER( pszUserIn );
    UNREFERENCED_PARAMETER( pszNamespaceIn );
    UNREFERENCED_PARAMETER( pszLocaleIn );

    hr = CoImpersonateClient();
    if ( SUCCEEDED( hr ) )
    {
        try
        {
            wsbTypeName.SetSize( cbTypeName );
            er = pNamespaceIn->GetObject(   
                    _bstr_t( PVD_CLASS_PROPERTY ),
                    lFlagsIn,
                    pCtxIn,
                    &wco,
                    NULL
                    );

            shCluster = OpenCluster( NULL );

            CClusterEnum cluEnum( shCluster, CLUSTER_ENUM_RESOURCE );

            //
            // First enumerate all of the resources.
            //
            while ( ( pwszResName = cluEnum.GetNext() ) != NULL )
            {
                TracePrint(( "CClassProv:Initialize found resource = %ws\n", pwszResName ));

                shResource = OpenClusterResource( shCluster, pwszResName );

                //
                // Get resource type name.
                //
                dwReturn = ClusterResourceControl(
                                shResource,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                wsbTypeName,
                                cbTypeName,
                                &cbTypeNameReturned
                                );

                if ( dwReturn == ERROR_MORE_DATA )
                {
                    cbTypeName = cbTypeNameReturned;
                    wsbTypeName.SetSize( cbTypeName );
                    er = ClusterResourceControl(
                                shResource,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                wsbTypeName,
                                cbTypeName,
                                &cbTypeNameReturned
                                );
                } // if: buffer was too small

                //
                // Check if type name already handled.
                //
                if ( mapResourceType[ (LPCWSTR) wsbTypeName ] )
                {
                    continue;
                }

                mapResourceType[ (LPCWSTR) wsbTypeName ] = true;

                wco.SpawnDerivedClass( 0, &wcoChild );

                CreateMofClassFromResource( shResource, wsbTypeName, wcoChild );
                er = pNamespaceIn->PutClass(
                           wcoChild.data(),
                           WBEM_FLAG_OWNER_UPDATE,
                           pCtxIn,
                           NULL
                           );
            } // while: more resources


            cbTypeNameReturned  = 0;

            TracePrint(( "CClassProv:Initialize - now find resource types\n" ));

            //
            // Now enumerate all of the resource types.
            //
            CClusterEnum cluEnumResType( shCluster, CLUSTER_ENUM_RESTYPE );

            while ( ( pwszResTypeName = cluEnumResType.GetNext() ) != NULL )
            {
                //
                // Check if type name already handled.
                //
                if ( mapResourceType[ (LPCWSTR) pwszResTypeName ] )
                {
                    TracePrint(( "CClassProv:Initialize found existing restype = %ws\n", pwszResTypeName ));
                    continue;
                }

                mapResourceType[ (LPCWSTR) pwszResTypeName ] = true;

                TracePrint(( "CClassProv:Initialize Creating new restype = %ws\n", pwszResTypeName ));

                wco.SpawnDerivedClass( 0, &wcoChild );

                CreateMofClassFromResType( shCluster, pwszResTypeName, wcoChild );
                er = pNamespaceIn->PutClass(
                           wcoChild.data(),
                           WBEM_FLAG_OWNER_UPDATE,
                           pCtxIn,
                           NULL
                           );
                //TracePrint(( "CClassProv:Initialize PutClass for %ws returned %u\n", pwszResTypeName, er ));

            } // while: more resource types

            // Tell CIMOM that we're up and running.
            // =====================================
            hr = WBEM_S_INITIALIZED;
        } // try
        catch ( CProvException & cpe )
        {
            hr = cpe.hrGetError();
            TracePrint(( "CClassProv:Initialize Caught CProvException = %x\n", hr ));
        }
        catch (...)
        {
            TracePrint(( "CClassProv:Initialize Caught Unknown Exception\n" ));
            hr = WBEM_E_FAILED;
        }
    } // if: CoImpersonateClient succeeded

    //TracePrint(( "CClassProv:Initialize exit\n" ));

    pInitSinkIn->SetStatus( hr, 0 );
    return WBEM_S_NO_ERROR;

} //*** CClassProv::Initialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CClassProv::S_HrCreateThis(
//      IUnknown *  pUnknownOuterIn,
//      VOID **     ppvOut
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pUnknownOuterIn -- Outer IUnknown pointer.
//      ppvOut          -- Receives the created instance pointer.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClassProv::S_HrCreateThis(
    IUnknown *  ,// pUnknownOuterIn,
    VOID **     ppvOut
    )
{
    *ppvOut = new CClassProv();
    return S_OK;

} //*** CClassProv::S_HrCreateThis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClassProv::CreateMofClassFromResource(
//      HRESOURCE           hResourceIn,
//      LPCWSTR             pwszTypeNameIn,
//      CWbemClassObject &  rClassInout
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      hResourceIn     -- Cluster resource handle.
//      pwszTypeNameIn  -- Type name (??).
//      rClassInout     -- WMI class object.
//
//  Return Values:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClassProv::CreateMofClassFromResource(
    HRESOURCE           hResourceIn,
    LPCWSTR             pwszTypeNameIn,
    CWbemClassObject &  rClassInout
    )
{
    WCHAR               wszClass[ MAX_PATH ];
    LPWSTR              pwsz;
    HRESULT             hr = S_OK;

    TracePrint(( "CreateMofClassFromResource: entry, TypeName = %ws\n", pwszTypeNameIn ));

    //
    // form new class name
    //
    hr = StringCchCopyW( wszClass, sizeof( wszClass ) / sizeof( wszClass[0] ) , L"MSCluster_Property_"  );
    if ( SUCCEEDED( hr ) )
    {
        pwsz = wcschr( wszClass, L'\0' );
        PwszSpaceReplace( pwsz, pwszTypeNameIn, L'_');
        rClassInout.SetProperty( wszClass, PVD_WBEM_CLASS );
        g_TypeNameToClass[ pwszTypeNameIn ] = wszClass ;

        //
        // setup class property
        //

        {
            static DWORD s_rgdwControl[] =
            {
                CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES,
                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
            };
            static DWORD s_cControl = sizeof( s_rgdwControl ) / sizeof( DWORD );

            DWORD   dwRt = ERROR_SUCCESS;
            VARIANT var;
            UINT    idx;

            var.vt =  VT_NULL;

            for ( idx = 0 ; idx < s_cControl ; idx++ )
            {
                CClusPropList pl;

                dwRt = pl.ScGetResourceProperties(
                            hResourceIn,
                            s_rgdwControl[ idx ],
                            NULL,
                            0 );

                dwRt = pl.ScMoveToFirstProperty();
                while ( dwRt == ERROR_SUCCESS )
                {
                    LPCWSTR             pwszPropName = NULL;
                    WCHAR               pwszPropMof[MAX_PATH];
                    CIMTYPE             cimType = CIM_EMPTY;

                    pwszPropName = pl.PszCurrentPropertyName();
                    PwszSpaceReplace( pwszPropMof, pwszPropName, L'_' );

                    switch ( pl.CpfCurrentValueFormat() )
                    {
                        case CLUSPROP_FORMAT_WORD:
                        {
                            cimType =  CIM_UINT16;
                            break;
                        } // case: CLUSPROP_FORMAT_WORD

                        case CLUSPROP_FORMAT_DWORD:
                        {
                            cimType = CIM_UINT32;
                            break;
                        } // case: CLUSPROP_FORMAT_DWORD:

                        case CLUSPROP_FORMAT_LONG:
                        {
                            cimType = CIM_SINT32;
                            break;
                        } // case: CLUSPROP_FORMAT_LONG:

                        case CLUSPROP_FORMAT_SZ:
                        case CLUSPROP_FORMAT_EXPAND_SZ:
                        case CLUSPROP_FORMAT_EXPANDED_SZ:
                        {
                            cimType = CIM_STRING;
                            break;
                        } // case: CLUSPROP_FORMAT_SZ, etc.

                        case CLUSPROP_FORMAT_BINARY:
                        {
                            cimType = CIM_UINT8 | CIM_FLAG_ARRAY;
                            break;
                        } // case: CLUSPROP_FORMAT_BINARY

                        case CLUSPROP_FORMAT_MULTI_SZ:
                        {
                            cimType = CIM_STRING | CIM_FLAG_ARRAY;
                            break;
                        } // case: CLUSPROP_FORMAT_BINARY

                        case CLUSPROP_FORMAT_LARGE_INTEGER:
                        {
                            cimType = CIM_SINT64;
                            break;
                        } // case: CLUSPROP_FORMAT_LARGE_INTEGER

                        case CLUSPROP_FORMAT_ULARGE_INTEGER:
                        {
                            cimType = CIM_UINT64;
                            break;
                        } // case: CLUSPROP_FORMAT_ULARGE_INTEGER

                        case CLUSPROP_FORMAT_SECURITY_DESCRIPTOR:
                        {
                            cimType = CIM_UINT8 | CIM_FLAG_ARRAY;
                            break;
                        }

                        default:
                        {
                            TracePrint(( "CreateMofClassFromResource: Unknown format value %lx\n",  pl.CpfCurrentValueFormat() ));
                            break;
                        }

                    } // switch : property type

                    rClassInout.data()->Put(
                        pwszPropMof,
                        0,
                        &var,
                        cimType
                        );

                    dwRt = pl.ScMoveToNextProperty();
                } // while: proplist not empty

            } // for: readwrite and readonly property
        } // set properties
    }// if: SUCCEEDED( hr )

} //*** CClassProv::CreateMofClassFromResource()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClassProv::CreateMofClassFromResType(
//      HCLUSTER            hCluster,
//      LPCWSTR             pwszTypeNameIn,
//      CWbemClassObject &  rClassInout
//      )
//
//  Description:
//      Create an instance of the instance provider.
//
//  Arguments:
//      pwszTypeNameIn  -- Type name (??).
//      rClassInout     -- WMI class object.
//
//  Return Values:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClassProv::CreateMofClassFromResType(
    HCLUSTER            hCluster,
    LPCWSTR             pwszTypeNameIn,
    CWbemClassObject &  rClassInout
    )
{
    WCHAR               wszClass[ MAX_PATH ];
    LPWSTR              pwsz;
    HRESULT             hr = S_OK;

    //
    // form new class name
    //
    hr = StringCchCopyW( wszClass, sizeof( wszClass ) / sizeof( wszClass[0] ) , L"MSCluster_Property_"  );
    if ( SUCCEEDED( hr ) )
    {
        pwsz = wcschr( wszClass, L'\0' );
        PwszSpaceReplace( pwsz, pwszTypeNameIn, L'_');
        rClassInout.SetProperty( wszClass, PVD_WBEM_CLASS );
        g_TypeNameToClass[ pwszTypeNameIn ] = wszClass ;

        TracePrint(( "CreateMofClassFromResType: entry\n" ));

        //
        // setup class property
        //

        {
            static DWORD s_rgdwControl[] =
            {
                CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS,
            };
            static DWORD s_cControl = sizeof( s_rgdwControl ) / sizeof( DWORD );

            DWORD   dwRt = ERROR_SUCCESS;
            VARIANT var;
            UINT    idx;

            var.vt =  VT_NULL;

            for ( idx = 0 ; idx < s_cControl ; idx++ )
            {
                CClusPropList pl;

                dwRt = pl.ScGetResourceTypeProperties(
                            hCluster,
                            pwszTypeNameIn,
                            s_rgdwControl[ idx ],
                            NULL,
                            NULL,
                            0 );

                if ( dwRt != ERROR_SUCCESS ) {
                    TracePrint(( "CreateMofClassFromResType: error = %lx reading restype format types\n", dwRt ));
                    continue;
                }

                dwRt = pl.ScMoveToFirstProperty();
                while ( dwRt == ERROR_SUCCESS )
                {
                    LPCWSTR             pwszPropName = NULL;
                    WCHAR               pwszPropMof[MAX_PATH];
                    CIMTYPE             cimType = CIM_EMPTY;
                    DWORD               formatType;

                    pwszPropName = pl.PszCurrentPropertyName();
                    formatType = pl.CpfCurrentFormatListSyntax();
                    TracePrint(( "CreateMofClassFromResType: Found name = %ws, format type = %lx\n", pwszPropName, formatType ));

                    PwszSpaceReplace( pwszPropMof, pwszPropName, L'_' );

                    switch ( formatType )
                    {
                        case CLUSPROP_FORMAT_WORD:
                        {
                            cimType =  CIM_UINT16;
                            break;
                        } // case: CLUSPROP_FORMAT_WORD

                        case CLUSPROP_FORMAT_DWORD:
                        {
                            cimType = CIM_UINT32;
                            break;
                        } // case: CLUSPROP_FORMAT_DWORD:

                        case CLUSPROP_FORMAT_LONG:
                        {
                            cimType = CIM_SINT32;
                            break;
                        } // case: CLUSPROP_FORMAT_LONG:

                        case CLUSPROP_FORMAT_SZ:
                        case CLUSPROP_FORMAT_EXPAND_SZ:
                        case CLUSPROP_FORMAT_EXPANDED_SZ:
                        {
                            cimType = CIM_STRING;
                            break;
                        } // case: CLUSPROP_FORMAT_SZ, etc.

                        case CLUSPROP_FORMAT_BINARY:
                        {
                            cimType = CIM_UINT8 | CIM_FLAG_ARRAY;
                            break;
                        } // case: CLUSPROP_FORMAT_BINARY

                        case CLUSPROP_FORMAT_MULTI_SZ:
                        {
                            cimType = CIM_STRING | CIM_FLAG_ARRAY;
                            break;
                        } // case: CLUSPROP_FORMAT_BINARY

                        default:
                        {
                            TracePrint(( "CreateMofClassFromResType: Unknown format type = %lx", formatType ));
                            break;
                        }

                    } // switch : property type

                    //TracePrint(( "CreateMofClassFromResType: MofProp = %ws, CIMType = %lx\n", pwszPropMof, cimType ));
                    rClassInout.data()->Put(
                        pwszPropMof,
                        0,
                        &var,
                        cimType
                        );

                    dwRt = pl.ScMoveToNextProperty();
                } // while: proplist not empty

            } // for: readwrite and readonly property
        } // set properties
    }// if: SUCCEEDED( hr )

} //*** CClassProv::CreateMofClassFromResType()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\objectpath.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ObjectPath.cpp
//
//  Description:    
//      Implementation of class CObjpath, CProvException, CProvExceptionHr,
//      and CProvExceptionWin32.
//
//  Maintained By:
//      Ozan Ozhan  (OzanO)     06-DEC-2002
//      Henry Wang  (HenryWa)   24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ObjectPath.h"

//****************************************************************************
//
//  CObjPath
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjPath::CObjPath( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CObjPath::CObjPath( void )
    : m_parsedObj( NULL )
{

} //*** CObjPath::CObjPath()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CObjPath::~CObjPath( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CObjPath::~CObjPath( void )
{
    delete m_parsedObj;

} //*** CObjPath::~CObjPath()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetStringValueForProperty(
//      LPCWSTR     pwszIn
//      )
//
//  Description:
//      Retrieve the string value for the given property.
//
//  Arguments:
//      pwszIn      -- Name of the property
//
//  Return Values:
//      The property's value.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetStringValueForProperty(
    LPCWSTR     pwszIn
    )
{
    UINT        idx;
    KeyRef *    pKey;

    for( idx = 0 ; idx < m_parsedObj->m_dwNumKeys ; idx++ )
    {
        pKey = m_parsedObj->m_paKeys[ idx ];
        if( ClRtlStrICmp( pKey->m_pName, pwszIn ) == 0 )
        {
            if( pKey->m_vValue.vt == VT_BSTR )
            {
                return pKey->m_vValue.bstrVal;
            }
        }
    }

    return L"";

} //*** CObjPath::GetStringValueForProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetClassName( void )

//
//  Description:
//      Get the class name.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Class name string.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetClassName( void )
{
    return m_parsedObj->m_pClass;

} //*** CObjPath::GetClassName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::Init(
//      LPCWSTR     pwszPathIn
//      )
//
//  Description:
//      Initialize the object.
//
//  Arguments:
//      pwszPathIn  -- Object path string
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::Init(
    LPCWSTR     pwszPathIn
    )
{
    if ( pwszPathIn == NULL )
    {
        m_parsedObj = new ParsedObjectPath;
    }
    else
    {
        CObjectPathParser objParser( e_ParserAcceptRelativeNamespace );
        objParser.Parse(
            const_cast< WCHAR * >( pwszPathIn ),
            &m_parsedObj
            );
    }

    if ( m_parsedObj == NULL )
    {
        return FALSE;
    } // if:

    return TRUE;

} //*** CObjPath::Init()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::SetClass(
//      LPCWSTR     pwszValueIn
//      )
//
//  Description:
//      Set the name of the class for the object path.
//
//  Arguments:
//      pwszValueIn     -- Class name string.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::SetClass(
    LPCWSTR     pwszValueIn
    )
{
    return m_parsedObj->SetClassName( pwszValueIn );

} //*** CObjPath::SetClass()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::AddProperty(
//      IN LPCWSTR pwszNameIn,
//      IN LPCWSTR pwszValueIn
//      )
//
//  Description:
//      Add property to object path.
//
//  Arguments:
//      pwszNameIn      -- Name of the property.
//      pwszValueIn     -- Value of the property in WCHAR* format.
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::AddProperty(
    IN LPCWSTR pwszNameIn,
    IN LPCWSTR pwszValueIn
    )
{
    VARIANT v;
    BOOL    bRt = FALSE;

    VariantInit( & v );
    v.vt = VT_BSTR;
    v.bstrVal = _bstr_t( pwszValueIn ).copy(  );
    bRt = m_parsedObj->AddKeyRef(
                pwszNameIn,
                & v
                );
    VariantClear( & v );
    return bRt;
    
} //*** CObjPath::AddProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  _bstr_t
//  CObjPath::GetObjectPathString( void )
//
//  Description:
//      Retrieve object path string.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Object path string in _bstr_t.
//
//--
//////////////////////////////////////////////////////////////////////////////
_bstr_t
CObjPath::GetObjectPathString( void )
{
    LPWSTR  pwszPath = NULL;
    _bstr_t bstrResult;

    try
    {
        CObjectPathParser::Unparse( m_parsedObj, & pwszPath );
        bstrResult = pwszPath;
    }
    catch( ... )   //catch _com_error
    {
        delete [] pwszPath;
        throw;
    }

    delete [] pwszPath;
    return bstrResult;

} //*** CObjPath::GetObjectPathString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  CObjPath::AddProperty(
//      LPCWSTR     pwszNameIn,
//      VARIANT *   pvValueIn
//      )
//
//  Description:
//      Add a property to this instance.
//
//  Arguments:
//      pwszNameIn      -- Name of the property.
//      pvValueIn       -- Value of the property in VARIANT format
//
//  Return Values:
//      TRUE
//      FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CObjPath::AddProperty(
    LPCWSTR     pwszNameIn,
    VARIANT *   pvValueIn
    )
{
    return m_parsedObj->AddKeyRef( pwszNameIn, pvValueIn );

} //*** CObjPath::AddProperty

//****************************************************************************
//
//  CProvException
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  CProvException::PwszErrorMessage( void ) const
//
//  Description:
//      retrieve Error message 
//
//  Arguments:
//      None.
//
//  Return Values:
//      Null-terminated Unicode error message from the exception.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
CProvException::PwszErrorMessage( void ) const
{
    if ( m_bstrError.length( ) == 0 )
    {
        LPWSTR pError = NULL;
        DWORD rt = FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        HRESULT_CODE( m_hr ),
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPWSTR) &pError,
                        0,
                        NULL
                        );

        if ( rt != 0 )
        {
            m_bstrError = pError;
        }
        LocalFree( pError );
    } // if: string is empty
    return m_bstrError;

} //*** CProvException::PwszErrorMessage()

//****************************************************************************
//
//  CWbemClassObject
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::CWbemClassObject( void )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject( void )
    : m_pClassObject( NULL )
{
    VariantInit( &m_v );

} //*** CWbemClassObject::CWbemClassObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::CWbemClassObject(
//      IWbemClassObject *  pInstIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pInstIn     -- WMI class object interface.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::CWbemClassObject(
    IWbemClassObject *  pInstIn
    )
    : m_pClassObject( NULL )
{
    m_pClassObject = pInstIn;
    if ( m_pClassObject )
    {
        m_pClassObject->AddRef();
    }
    VariantInit( &m_v );

} //*** CWbemClassObject::CWbemClassObject( pInstIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWbemClassObject::~CWbemClassObject( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CWbemClassObject::~CWbemClassObject( void )
{
    if ( m_pClassObject )
    {
        m_pClassObject->Release();
    }
    VariantClear( &m_v );

} //*** CWbemClassObject::~CWbemClassObject()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      DWORD       dwValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set dword value of a property.
//
//  Arguments:
//      dwValueIn       -- Property dword value
//      pwszPropNameIn  -- Property Name
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;

    VariantClear( &m_v );
    m_v.vt = VT_I4;
    m_v.lVal = dwValueIn;
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0, 
                &m_v,
                0
                );

    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( dwValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      LPCWSTR     pwszValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set wstring value of a property.
//
//  Arguments:
//      pwszValueIn     -- Property string value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::SetProperty(
    LPCWSTR     pwszValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;
    if ( pwszValueIn == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    VariantClear( &m_v );
//  _bstr_t bstrValue( pwszValueIn );
    m_v.vt = VT_BSTR;
    m_v.bstrVal = _bstr_t( pwszValueIn ).copy();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                0
                );
    VariantClear( &m_v );


    if( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;
 
} //*** CWbemClassObject::SetProperty( pwszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      DWORD       dwSizeIn,
//      PBYTE       pByteIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set binary value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pByteIn.
//      pByteIn         -- Pointer to byte.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    PBYTE       pByteIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LONG            idx;
    LONG            ix;

    rgsabound[ 0 ].lLbound = 0;
    rgsabound[ 0 ].cElements = dwSizeIn;

    if( pByteIn == NULL )
    {
        return sc;
    }
    
    VariantClear( &m_v );

    psa = SafeArrayCreate( VT_UI1, 1, rgsabound );
    if(psa == NULL)
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    for( idx = 0 ; idx < (LONG) dwSizeIn ; idx++ )
    {
        ix = idx;
        sc = SafeArrayPutElement(
                psa,
                &ix,
                static_cast< void * >( pByteIn+idx )
                );

        if ( sc != S_OK )
        {
            throw CProvException( sc );
        }
    }

    m_v.vt = ( VT_ARRAY | VT_UI1 );

    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            0
            );

    if ( sc != S_OK )
    {
        throw CProvException( sc );
    }

    return sc;


} //*** CWbemClassObject::SetProperty( pByteIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      DWORD       dwSizeIn,
//      BSTR *      pbstrIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set wstring array value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pByteIn.
//      pbstrIn         -- Pointer to BSTR array.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    BSTR *      pbstrIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LONG            idx;
    LONG            ix;

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwSizeIn;

    if ( pbstrIn == NULL )
    {
        return sc;
    }

    VariantClear( &m_v );

    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    if ( psa == NULL )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    for( idx = 0 ; idx < (LONG) dwSizeIn ; idx++)
    {
        ix = idx;
        sc = SafeArrayPutElement(
                psa,
                &ix,
                pbstrIn[ idx ]
                );

        if ( sc != S_OK)
        {
            throw CProvException( sc );
        }
    }

    m_v.vt = (VT_ARRAY | VT_BSTR );

    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            0
            );
    
    if ( sc != S_OK)
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pbstrIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//
//  Description:
//      Set MultiSz value of a property.
//
//  Arguments:
//      dwSizeIn        -- Size of block pointed by pwszMultiSzIn.
//      pwszMultiSzIn   -- Pointer to MultiSz.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    DWORD       dwSizeIn,
    LPCWSTR     pwszMultiSzIn,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE           sc = WBEM_S_NO_ERROR;
    SAFEARRAY *     psa;
    SAFEARRAYBOUND  rgsabound[ 1 ];
    LPCWSTR         pwsz = NULL;
    LONG            idx;
    LONG            ix;

    if( pwszMultiSzIn == NULL )
    {
        return sc;
    }
    VariantClear( &m_v );

    //
    // find out the number of string
    //
    DWORD cMultiSz = 1;
    for ( pwsz = pwszMultiSzIn; *pwsz || *pwsz ++ ; pwsz ++ )
    {
        if ( ! ( *pwsz ) )
        {
            cMultiSz ++ ;
        }
    }
    rgsabound[ 0 ].lLbound = 0;
    rgsabound[ 0 ].cElements = cMultiSz;

    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound);
    if ( psa == NULL )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

    pwsz = pwszMultiSzIn;
    for( idx = 0 ; idx < (LONG) cMultiSz ; idx++ )
    {
        ix = idx;
        sc = SafeArrayPutElement(
                    psa,
                    &ix,
                    (BSTR) _bstr_t( pwsz )
                    );

        if ( sc != S_OK )
        {
            throw CProvException( sc );
        }
        pwsz = wcschr( pwsz, L'\0' );
        pwsz ++;
    }

    m_v.vt = (VT_ARRAY | VT_BSTR );
    //
    // no need to clear psa, managed by destructor
    //
    m_v.parray = psa;
    sc = m_pClassObject->Put(
            _bstr_t( pwszPropNameIn ),
            0, 
            &m_v,
            0
            );

    if ( sc != S_OK )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pwszMultiSzIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      LPCSTR      pszValueIn,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Set ansi string value of a property.
//
//  Arguments:
//      pszValueIn      -- Property string value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    LPCSTR      pszValueIn,
    LPCWSTR     pwszPropNameIn
    )
{
    if ( pszValueIn == NULL )
    {
        return S_OK;
    }
    return SetProperty(
                static_cast< WCHAR * >( _bstr_t( pszValueIn ) ),
                pwszPropNameIn
                );

} //*** CWbemClassObject::SetProperty( pszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SetProperty(
//      IWbemClassObject *  pWbemClassObject,
//      LPCWSTR             pwszPropNameIn
//      )
//
//  Description:
//      Set wbem class object of a property.
//
//  Arguments:
//      pWbemClassObject    -- Property wbem class object 
//      pwszPropNameIn      -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SetProperty(
    IWbemClassObject *  pWbemClassObjectIn,
    LPCWSTR             pwszPropNameIn
    )
{
    SCODE   sc = S_OK;
    if ( pWbemClassObjectIn == NULL )
    {
        return sc;
    }
    VariantClear( & m_v );
    
    m_v.vt = VT_UNKNOWN  ;
    m_v.punkVal = pWbemClassObjectIn;
    pWbemClassObjectIn->AddRef();
    sc = m_pClassObject->Put(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                0
                );
    VariantClear( &m_v );


    if( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

    return sc;

} //*** CWbemClassObject::SetProperty( pszValueIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SpawnInstance(
//      LONG                lFlagIn,
//      IWbemClassObject ** ppNewOut
//      )
//
//  Description:
//      Spawn a instance of IWbemClassObject.
//
//  Arguments:
//      lFlagIn     -- WMI flag, reserved, must be 0.
//      ppNewOut    -- Created new instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SpawnInstance(
    LONG                lFlagIn,
    IWbemClassObject ** ppNewOut
    )
{
    return m_pClassObject->SpawnInstance( lFlagIn, ppNewOut );

} //*** CWbemClassObject::SpawnInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::SpawnDerivedClass(
//      LONG                lFlagIn,
//      IWbemClassObject ** ppNewOut
//      )
//
//  Description:
//      Spawn a derived class.
//
//  Arguments:
//      lFlagIn     -- WMI flag, reserved, must be 0.
//      ppNewOut    -- Created new instance.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::SpawnDerivedClass(
    LONG                lFlagIn,
    IWbemClassObject ** ppNewOut
    )
{
    return m_pClassObject->SpawnDerivedClass( lFlagIn, ppNewOut );

} //*** CWbemClassObject::SpawnInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetMethod(
//      BSTR                bstrMethodNameIn,
//      LONG                lFlagIn,
//      IWbemClassObject ** ppINOut,
//      IWbemClassObject ** ppOUTOut
//      )
//
//  Description:
//      Retrieve the method for an WMI object.
//
//  Arguments:
//      bstrMethodNameIn
//          Method Name.
//
//      lFlagIn
//          WMI flag, Reserved. It must be zero.
//
//      ppINOut
//          IWbemClassObject pointer which describes the in-parameters 
//          to the method.
//
//      ppOUTOut
//          an IWbemClassObject pointer which describes the 
//          out-parameters to the method
//
//  Return Values:
//      WBEM stand error
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetMethod(
    BSTR                bstrMethodNameIn,
    LONG                lFlagIn,
    IWbemClassObject ** ppINOut,
    IWbemClassObject ** ppOUTOut
    )
{
    return m_pClassObject->GetMethod(
                bstrMethodNameIn,
                lFlagIn,
                ppINOut,
                ppOUTOut
                );

} //*** CWbemClassObject::GetMethod()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the DWORD property for this WMI object.
//
//  Arguments:
//      pdwValueOut     -- DWORD variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::GetProperty(
    DWORD *     pdwValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    VariantClear( &m_v );
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            &m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_I4 )
        {
            *pdwValueOut = m_v.lVal;
            return sc;
        }
        else if ( m_v.vt == VT_BOOL)
        {
            if ( m_v.boolVal == VARIANT_TRUE )
            {
                *pdwValueOut = 1;
            }
            else
            {
                *pdwValueOut = 0;
            }
            return sc;
        }
        else if ( m_v.vt == VT_UI1 )
        {
            *pdwValueOut = ( DWORD ) m_v.bVal;
        }
        else if ( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    // raise exception if sc is not S_OK or vt is not expected
    CProvException e( sc );
    throw e;
    
} //*** CWbemClassObject::GetProperty( pdwValueOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      _bstr_t &   rBstrOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BSTR property for this WMI object.
//
//  Arguments:
//      rBstrOut        -- bstr_t variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    _bstr_t &   rBstrOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );
    if ( SUCCEEDED( sc ) )
    {
        if( m_v.vt == VT_BSTR )
        {
            rBstrOut = m_v.bstrVal;
            return sc;
        }
        else if( m_v.vt == VT_NULL )
        {
            return WBEM_E_FAILED;
        }
    }

    CProvException e( sc );
    throw e;
} //*** CWbemClassObject::GetProperty( rBstrOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      BOOL *      pfValueOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BOOL property for this WMI object.
//
//  Arguments:
//      pfValueOut      -- BOOL variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//      WBEM_E_FAILED
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::GetProperty(
    BOOL *      pfValueOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    VariantClear( &m_v );
    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );

    if ( m_v.vt == VT_BOOL )
    {
        *pfValueOut = m_v.boolVal;
        return sc;
    }

    return WBEM_E_FAILED;

} //*** CWbemClassObject::GetProperty

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      PBYTE *     ppByteOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the binary property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppByteOut       -- Output buffer.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE 
CWbemClassObject::GetProperty(
    DWORD *     pdwSizeOut,
    PBYTE *     ppByteOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;
    VariantClear(&m_v);
    *pdwSizeOut = 0;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                & m_v,
                NULL,
                NULL
                );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_UI1 ) )
        {
            PBYTE   pByte;

            * pdwSizeOut = m_v.parray->rgsabound[ 0 ].cElements;
            * ppByteOut = new BYTE[ *pdwSizeOut ];
            if ( *ppByteOut == NULL )
            {
                throw CProvException( static_cast< HRESULT > ( WBEM_E_OUT_OF_MEMORY) );
            } // if: ( * ppByteOut == NULL )

            sc = SafeArrayAccessData( m_v.parray, ( void ** ) &pByte );
            if ( SUCCEEDED ( sc ) )
            {    
                UINT idx;
                for ( idx = 0; idx < *pdwSizeOut; idx ++ )
                {
                    *( (* ppByteOut ) + idx ) = *( pByte + idx );
                }
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppByteOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      _bstr_t **  ppbstrOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the BSTR array property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppbstrOut       -- BSTR variable to receive property value.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    DWORD *     pdwSizeOut,
    _bstr_t **  ppbstrOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE sc;
    VariantClear( &m_v );
    *pdwSizeOut = 0;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                & m_v,
                NULL, 
                NULL
                );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_BSTR ) )
        {
            BSTR * pBstr;

            *pdwSizeOut = m_v.parray->rgsabound[0].cElements;
            *ppbstrOut = new _bstr_t[ *pdwSizeOut ];
            if ( *ppbstrOut == NULL )
            {
                throw CProvException( static_cast< HRESULT > ( WBEM_E_OUT_OF_MEMORY) );
            } // if: ( *ppbstrOut == NULL )

            sc = SafeArrayAccessData( m_v.parray, (void **) & pBstr );
            if ( SUCCEEDED ( sc ) )
            {
                UINT idx;
                for( idx = 0; idx < *pdwSizeOut; idx ++)
                {
                    *( (*ppbstrOut) + idx ) = *( pBstr + idx );
                }
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppbstrOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      DWORD *     pdwSizeOut,
//      LPWSTR *    ppwszMultiSzOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the MultiSz property for this WMI object.
//
//  Arguments:
//      pdwSizeOut      -- Size of the output buffer.
//      ppwszMultiSzOut -- MultiSz output buffer.
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetPropertyMultiSz(
    DWORD *     pdwSizeOut,
    LPWSTR *    ppwszMultiSzOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE       sc;
    DWORD       cElements;
    DWORD       cMultiSz = 0;

    VariantClear(&m_v);
    *pdwSizeOut = 0;
//    *ppOut = NULL;
    sc = m_pClassObject->Get(
            _bstr_t( pwszPropNameIn ),
            0,
            & m_v,
            NULL,
            NULL
            );

    if ( SUCCEEDED ( sc ) )
    {
        if ( m_v.vt == ( VT_ARRAY | VT_BSTR ) )
        {
            LPWSTR * ppwsz = NULL;

            cElements = m_v.parray->rgsabound[ 0 ].cElements;
            sc = SafeArrayAccessData( m_v.parray, ( void ** ) & ppwsz );
            if ( SUCCEEDED ( sc ) )
            {    
                UINT idx;
                for ( idx = 0; idx < cElements; idx ++ )
                {
                   cMultiSz += (DWORD) ( wcslen( *(ppwsz + idx) ) ) + (DWORD) ( sizeof (WCHAR) ); 
                }
                cMultiSz += sizeof( WCHAR ) * 2;
                *ppwszMultiSzOut = new WCHAR[ cMultiSz ];
                if ( *ppwszMultiSzOut == NULL )
                {
                    throw CProvException( static_cast< HRESULT > ( WBEM_E_OUT_OF_MEMORY) );
                }

                LPWSTR pwszDst = *ppwszMultiSzOut;
                LPWSTR pwszSrc;
                for ( idx = 0; idx < cElements ; idx ++ )
                {
                    for( pwszSrc = *( ppwsz + idx); *pwszSrc ; pwszDst++, pwszSrc ++ )
                    {
                        *pwszDst = *pwszSrc;
                    }
                    *(pwszDst++) = L'\0';
                }
                *pwszDst = L'\0';
                *pdwSizeOut = cMultiSz;
                SafeArrayUnaccessData( m_v.parray );
            }
        }
        else
        {
            throw CProvException( static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER) );
        }
    }
    else
    {
        throw CProvException( sc );
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( ppwszMultiSzOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//      VARIANT *   pVariantOut,
//      LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the variant property for this WMI object.
//
//  Arguments:
//      pVariantOut     -- Variant variable to receive property value
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    VARIANT *   pVariantOut,
    LPCWSTR     pwszPropNameIn
    )
{
    SCODE   sc;

    sc = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                pVariantOut,
                NULL,
                NULL
                );
    if ( FAILED( sc ) )
    {
        CProvException e( sc );
        throw e;
    }

    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( pVariantOut )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SCODE
//  CWbemClassObject::GetProperty(
//  CWbemClassObject & rWcoInout,
//  LPCWSTR     pwszPropNameIn
//      )
//
//  Description:
//      Retrieve the embeded object property for this WMI object.
//
//  Arguments:
//      rWcoInout       -- class object variable to receive property value
//      pwszPropNameIn  -- Property Name.
//
//  Return Values:
//      WBEM_S_NO_ERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
SCODE
CWbemClassObject::GetProperty(
    CWbemClassObject & rWcoInout,
    LPCWSTR     pwszPropNameIn
    )
{
    
    CError  er;
    VariantClear( &m_v );
    er = m_pClassObject->Get(
                _bstr_t( pwszPropNameIn ),
                0,
                &m_v,
                NULL,
                NULL
                );
    if ( m_v.vt != VT_UNKNOWN )
    {
        er = static_cast< HRESULT > ( WBEM_E_INVALID_PARAMETER );
        
    }
    IWbemClassObject * pwco = NULL;
    er = m_v.punkVal->QueryInterface( & pwco );
    rWcoInout = pwco;
    VariantClear( & m_v );
    return WBEM_S_NO_ERROR;

} //*** CWbemClassObject::GetProperty( rWcoInout )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\objectpath.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ObjectPath.h
//
//  Implementation File:
//      ObjectPath.cpp
//
//  Description:
//      Definition of the CObjpath class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "genlex.h"     //wbem sdk header
#include "objpath.h"    //wbem sdk header

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CObjPath;
class CProvException;
class CWbemClassObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CObjPath
//
//  Description:
//      CObjpath class make it easier to work with Object path string
//
//--
/////////////////////////////////////////////////////////////////////////////
class CObjPath
{
//
// constructor and desctructor
//
public:

    CObjPath( void );
    virtual ~CObjPath( void );

public:
    _bstr_t GetObjectPathString( void );

    BOOL AddProperty(
        LPCWSTR     pwszNameIn,
        LPCWSTR     pwszValueIn
        );
    
    BOOL AddProperty(
        LPCWSTR     pwszNameIn,
        VARIANT *   pvValueIn
        );
    
    BOOL SetClass(
        IN LPCWSTR pwszValue
        );
    
    _bstr_t GetStringValueForProperty(
        LPCWSTR pwszIn
        );

    _bstr_t GetClassName( void );
    
    BOOL Init(
        LPCWSTR     pwszPathIn
        );
    
protected:
    ParsedObjectPath *  m_parsedObj;

}; //*** class CObjPath

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvException
//
//  Description:
//      Base exception class, declares common interface and member data
//      for all exception subclass
//  
//--
/////////////////////////////////////////////////////////////////////////////
class CProvException
{
public:
    CProvException(
        HRESULT hrIn
        )
        : m_hr( hrIn )
    {
    }

    CProvException(
        DWORD   nWin32ErrorIn
        )
        : m_hr( 0 )
    {
        m_hr = HRESULT_FROM_WIN32( nWin32ErrorIn );
    }

    virtual ~CProvException( void )
    {
    }

    CProvException(
        const CProvException & rhsIn
        )
        : m_hr( 0 )
    {
        m_bstrError = rhsIn.m_bstrError;
        m_hr = rhsIn.m_hr;
    }

    CProvException & operator=(
        const CProvException & rhsIn
        )
    {
        m_bstrError = rhsIn.m_bstrError;
        m_hr = rhsIn.m_hr;
        return *this;
    }

    LPCWSTR PwszErrorMessage( void ) const;

    BOOL BIsWmiError( void ) const
    {
        return HRESULT_FACILITY( m_hr ) == 4;
    }

    DWORD DwGetError( void ) const throw()
    {
        return HRESULT_CODE( m_hr );
    }

    HRESULT hrGetError( void ) const throw()
    {
        return m_hr;
    }

protected:
    mutable _bstr_t m_bstrError;
    HRESULT         m_hr;

}; //*** class CProvException

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWbemClassObject
//
//  Description:
//      Wrap for IWbemClassObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWbemClassObject
{
protected:
    IWbemClassObject *  m_pClassObject;
    VARIANT             m_v;

public:
    CWbemClassObject( void );
    CWbemClassObject( IWbemClassObject * pInstIn );
    virtual ~CWbemClassObject( void );

    IWbemClassObject ** operator&( void )
    {
        return &m_pClassObject;
    }

    CWbemClassObject & operator=( IWbemClassObject * pInstIn )
    {
        if( pInstIn != NULL )
        {
            pInstIn->AddRef();
            if ( m_pClassObject != NULL )
            {
                m_pClassObject->Release();
            }
            m_pClassObject = pInstIn;
        }
        return *this;
    }

    CWbemClassObject & operator=( CWbemClassObject & rInstIn )
    {
        
        if ( m_pClassObject != NULL )
        {
            m_pClassObject->Release();
        }
        
        m_pClassObject = rInstIn.m_pClassObject;
        if ( m_pClassObject != NULL )
        {
            m_pClassObject->AddRef();
        }
        
        return *this;
    }

    SCODE SetProperty(
        LPCSTR      pszValueIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE SetProperty(
        DWORD       dwValueIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE SetProperty(
        LPCWSTR     pwszValueIn,
        LPCWSTR     pwszPropNameIn
        );
    SCODE SetProperty(
        IWbemClassObject * pWbemClassObjectIn,
        LPCWSTR     pwszPropNameIn
        );
    SCODE SetProperty(
        DWORD       dwSizeIn,
        PBYTE       pByteIn,
        LPCWSTR     pwszPropNameIn
        );
    SCODE SetProperty(
        DWORD       dwSizeIn,
        LPCWSTR     pwszMultiSzIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE SetProperty(
        DWORD       dwSizeIn,
        BSTR *      pbstrIn,
        LPCWSTR     pwszPropNameIn
        );

    SCODE GetProperty(
        DWORD *     pdwValueOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        DWORD *     pdwSizeOut,
        PBYTE *     ppByteOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        DWORD *     pdwSizeOut,
        _bstr_t **  ppbstrOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetPropertyMultiSz(
        DWORD *     pdwSizeOut,
        LPWSTR *    ppwszMultiSzOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        _bstr_t &   rBstrOut,
        LPCWSTR     pwszPropNameIn
    );

    SCODE GetProperty(
        BOOL *      pfValueOut,
        LPCWSTR     pwszPropNameIn
        );

    SCODE GetProperty(
        VARIANT *   pVariantOut,
        LPCWSTR     pwszPropNameIn
        );
    SCODE GetProperty(
        CWbemClassObject & rWcoInout,
        LPCWSTR     pwszPropNameIn
        );

    SCODE GetMethod(
        BSTR                bstrMethodNameIn,
        LONG                lFlagIn,
        IWbemClassObject ** ppINOut,
        IWbemClassObject ** ppOUTOut
        );
    SCODE SpawnInstance(
        LONG                lFlagIn,
        IWbemClassObject ** ppNewOut
        );
    SCODE SpawnDerivedClass(
        LONG                lFlagIn,
        IWbemClassObject ** ppNewOut
        );

    IWbemClassObject * data( void )
    {
        return m_pClassObject;
    }

}; //*** class CWbemClassObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter (DavidP) 05-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG

//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG


//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <pragmas.h>
#include <crtdbg.h>
#include <wbemprov.h>
#include <objbase.h>
#include "ntrkcomm.h"

// 
//STL related issues, can't fix this, not in our code.
//
#pragma warning( push )
#pragma warning( disable : 4244 ) // In STL code: 'return' : conversion from 'int' to 'wchar_t', possible loss of data 
#pragma warning( disable : 4512 ) // assignment operator could not be generated

#include <memory>
#include <map>
#include <list>

#include <comdef.h>
#include <wchar.h>
#include <atlbase.h>
#include <StrSafe.h>

#include <clusapi.h>
#include <resapi.h>
#include <clusudef.h>
#include <PropList.h>
#include <cluswrap.h>

#include "Common.h"
#include "ClusterApi.h"
#include "ClusterEnum.h"
#include "ObjectPath.h"
#include "ProvBase.h"
#include "SafeHandle.h"
#include "clstrcmp.h"

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\proplist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      PropList.cpp
//
//  Description:
//      Sucks in the CClusPropList library.
//
//  Maintained By:
//      Galen Barbee (GalenB) 14-JUN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\common.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Definition of common type, constant and header files.
//
//  Maintained by:
//      Ozan Ozhan  (OzanO)     26-NOV-2002
//      Henry Wang  (HenryWa)   24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once
#pragma warning( disable : 4786 )

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

using namespace std;

class CProvBase;
class CObjPath;
class CWbemClassObject;

extern long       g_cObj;
extern long       g_cLock;

typedef LPVOID * PPVOID;

typedef CProvBase * ( * FPNEW )(
    IN LPCWSTR          pwszName,
    IN CWbemServices *  pNamespace,
    DWORD               dwEnumType
    );

typedef void ( * FPFILLWMI )(
    IN PVOID                phCluster,
    IN PVOID                phClusterObj,
    IN LPCWSTR              pwszName,
    IN IWbemClassObject *   pClass,
    IN IWbemServices *      pServices, 
    IN IWbemObjectSink *    pHandler
    );

LPWSTR PwszSpaceReplace(
    LPWSTR      pwszTrgInout,
    LPCWSTR     pwszSrcIn,
    WCHAR       wchArgIn
    );

enum PROP_TYPE
{
    DWORD_TYPE,
    SZ_TYPE,
    MULTI_SZ_TYPE
};

enum ACCESS_TYPE
{   
    READONLY,
    READWRITE
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  typedef struct SPropMapEntry
//
//  Description:
//      structure to map property name defined in mof
//      to the property name defined in wolfpack header.
//      PropertyType indicate the type of wolfpack properties.
//      Mof property is always in VARIANT format and it's type 
//      is in vt field
//
//--
//////////////////////////////////////////////////////////////////////////////

struct SPropMapEntry
{
    LPCWSTR     mofName;
    LPCWSTR     clstName;
    PROP_TYPE   PropertyType;
    ACCESS_TYPE Access;

};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  struct SPropMapEntryArray
//
//  Description:
//      Array of SPropMapEntry
//
//--
//////////////////////////////////////////////////////////////////////////////
struct SPropMapEntryArray
{
    SPropMapEntryArray(
        DWORD           dwSizeIn,
        SPropMapEntry * pArrayIn
        )
        : m_dwSize( dwSizeIn )
        , m_pArray( pArrayIn )
    {
    }

    LPCWSTR PwszLookup( LPCWSTR pwszIn ) const;

    DWORD           m_dwSize;
    SPropMapEntry * m_pArray;

};

struct SGetSetControl
{
    DWORD   dwGetControl;
    DWORD   dwSetControl;
    BOOL    fPrivate;
};

struct SGetControl
{
    DWORD   dwControl;
    BOOL    fPrivate;
};

void CreateClass(
    const WCHAR *           pwszClassNameIn,
    CWbemServices *         pNamespaceIn, 
    auto_ptr<CProvBase>&    rNewClassInout
    );

// CLUSTER
extern const WCHAR * const PVD_CLASS_CLUSTER;
extern const WCHAR * const PVD_CLASS_CLUSTERTONETWORK;
extern const WCHAR * const PVD_CLASS_CLUSTERTONETINTERFACE;
extern const WCHAR * const PVD_CLASS_CLUSTERTONODE;
extern const WCHAR * const PVD_CLASS_CLUSTERTOQUORUMRES;
extern const WCHAR * const PVD_CLASS_CLUSTERTORES;
extern const WCHAR * const PVD_CLASS_CLUSTERTORESTYPE;
extern const WCHAR * const PVD_CLASS_CLUSTERTOGROUP;

extern const WCHAR * const PVD_PROP_CLUSTER_SECURITY;
extern const WCHAR * const PVD_PROP_CLUSTER_SECURITYDESCRIPTOR;
extern const WCHAR * const PVD_PROP_CLUSTER_NAME;
extern const WCHAR * const PVD_PROP_CLUSTER_GROUPADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_NODEADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_RESADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_RESTYPEADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_NETWORKADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_NETINTFACEADMIN;
extern const WCHAR * const PVD_PROP_CLUSTER_FILE;
extern const WCHAR * const PVD_PROP_CLUSTER_LOGSIZE;
extern const WCHAR * const PVD_PROP_CLUSTER_NETWORK;
extern const WCHAR * const PVD_PROP_CLUSTER_MAX_NODES;

extern const WCHAR * const CLUS_CLUS_GROUPADMIN;
extern const WCHAR * const CLUS_CLUS_NETWORKADMIN;
extern const WCHAR * const CLUS_CLUS_NETINTERFACEADMIN;
extern const WCHAR * const CLUS_CLUS_NODEADMIN;
extern const WCHAR * const CLUS_CLUS_RESADMIN;
extern const WCHAR * const CLUS_CLUS_RESTYPEADMIN;

extern const WCHAR * const PVD_MTH_CLUSTER_RENAME;
extern const WCHAR * const PVD_MTH_CLUSTER_SETQUORUM;
extern const WCHAR * const PVD_MTH_CLUSTER_GETNODECLUSTERSTATE;

extern const WCHAR * const PVD_MTH_CLUSTER_PARM_NEWNAME;
extern const WCHAR * const PVD_MTH_CLUSTER_PARM_RESOURCE;
extern const WCHAR * const PVD_MTH_CLUSTER_PARM_CLUSTERSTATE;

// NODE
extern const WCHAR * const PVD_CLASS_NODE;
extern const WCHAR * const PVD_CLASS_NODETOACTIVEGROUP;
extern const WCHAR * const PVD_CLASS_NODETONETINTERFACE;
extern const WCHAR * const PVD_CLASS_NODETOACTIVERES;

extern const WCHAR * const PVD_PROP_NODE_NAME;

// RESOURCE
extern const WCHAR * const PVD_CLASS_RESOURCE;
extern const WCHAR * const PVD_CLASS_RESDEPRES;
extern const WCHAR * const PVD_CLASS_RESTYPERESOURCE;
extern const WCHAR * const PVD_CLASS_RESOURCENODE;

extern const WCHAR * const PVD_PROP_RES_NAME;
extern const WCHAR * const PVD_PROP_RES_STATE;
extern const WCHAR * const PVD_PROP_RES_PRIVATE;
extern const WCHAR * const PVD_PROP_RES_CHECKPOINTS;
extern const WCHAR * const PVD_PROP_RES_CRYPTO_CHECKPOINTS;
extern const WCHAR * const PVD_PROP_RES_CORE_RESOURCE;

extern const WCHAR * const PVD_MTH_RES_ONLINE;
extern const WCHAR * const PVD_MTH_RES_OFFLINE;
extern const WCHAR * const PVD_MTH_RES_ADD_DEPENDENCY;
extern const WCHAR * const PVD_MTH_RES_CHANGE_GROUP;
extern const WCHAR * const PVD_MTH_RES_CREATE_RESOURCE;
extern const WCHAR * const PVD_MTH_RES_FAIL_RESOURCE;
extern const WCHAR * const PVD_MTH_RES_REMOVE_DEPENDENCY;
extern const WCHAR * const PVD_MTH_RES_RENAME;
extern const WCHAR * const PVD_MTH_RES_DELETE_RESOURCE;
extern const WCHAR * const PVD_MTH_RES_ADD_REG_CHECKPOINT;
extern const WCHAR * const PVD_MTH_RES_DEL_REG_CHECKPOINT;
extern const WCHAR * const PVD_MTH_RES_ADD_CRYPTO_CHECKPOINT;
extern const WCHAR * const PVD_MTH_RES_DEL_CRYPTO_CHECKPOINT;


extern const WCHAR * const PVD_MTH_PARM_RESOURCE;
extern const WCHAR * const PVD_MTH_PARM_GROUP;
extern const WCHAR * const PVD_MTH_PARM_NEWNAME;
extern const WCHAR * const PVD_MTH_PARM_RES_NAME;
extern const WCHAR * const PVD_MTH_PARM_RES_TYPE;
extern const WCHAR * const PVD_MTH_PARM_SEP_MONITOR;
extern const WCHAR * const PVD_MTH_PARM_RES_CHECKPOINT_NAME;
extern const WCHAR * const PVD_MTH_PARM_RES_TIMEOUT;


// RESOURCETYPE
extern const WCHAR * const PVD_CLASS_RESOURCETYPE;

extern const WCHAR * const PVD_PROP_RESTYPE_NAME;
extern const WCHAR * const PVD_PROP_RESTYPE_DLLNAME;
extern const WCHAR * const PVD_PROP_RESTYPE_ADMINEXTENSIONS;
extern const WCHAR * const PVD_PROP_RESTYPE_ISALIVE;
extern const WCHAR * const PVD_PROP_RESTYPE_LOOKSALIVE;
extern const WCHAR * const PVD_PROP_RESTYPE_DESCRIPTION;
extern const WCHAR * const PVD_PROP_RESTYPE_QUORUM_CAPABLE;
extern const WCHAR * const PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE;
extern const WCHAR * const PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES;

extern const WCHAR * const PVD_MTH_RESTYPE_CREATE_RESOURCETYPE;
extern const WCHAR * const PVD_MTH_RESTYPE_DELETE_RESOURCETYPE;
extern const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_NAME;
extern const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_DISPLAYNAME;
extern const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_DLLNAME;
extern const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_LOOKSALIVE;
extern const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_ISALIVE;

// GROUP
extern const WCHAR * const PVD_CLASS_GROUP;
extern const WCHAR * const PVD_CLASS_GROUPTORES;
extern const WCHAR * const PVD_CLASS_GROUPNODE;

extern const WCHAR * const PVD_PROP_GROUP_NAME;
extern const WCHAR * const PVD_PROP_GROUP_STATE;
extern const WCHAR* const PVD_PROP_NODELIST;

extern const WCHAR * const PVD_MTH_GROUP_CREATEGROUP;
extern const WCHAR * const PVD_MTH_GROUP_DELETEGROUP;
extern const WCHAR * const PVD_MTH_GROUP_TAKEOFFLINE;
extern const WCHAR * const PVD_MTH_GROUP_BRINGONLINE;
extern const WCHAR * const PVD_MTH_GROUP_MOVETONEWNODE;
extern const WCHAR * const PVD_MTH_GROUP_DELETE;
extern const WCHAR * const PVD_MTH_GROUP_RENAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_GROUPNAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_NODENAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_NEWNAME;
extern const WCHAR * const PVD_MTH_GROUP_PARM_TIMEOUT;


// NetworkInterface
extern const WCHAR * const PVD_CLASS_NETWORKINTERFACE;

extern const WCHAR * const PVD_PROP_NETINTERFACE_DEVICEID;
extern const WCHAR * const PVD_PROP_NETINTERFACE_SYSTEMNAME;
extern const WCHAR * const PVD_PROP_NETINTERFACE_STATE;

// NetworkName
extern const WCHAR * const PVD_CLASS_NETWORKNAME;

// networks
extern const WCHAR * const PVD_CLASS_NETWORK;
extern const WCHAR * const PVD_CLASS_NETTONETINTERFACE;

extern const WCHAR * const PVD_PROP_NETINTERFACE_NAME;
extern const WCHAR * const PVD_PROP_NETWORK_STATE;
extern const WCHAR * const PVD_MTH_NETWORK_RENAME;
extern const WCHAR * const PVD_MTH_NETWORK_PARM_NEWNAME;

// service
extern const WCHAR * const PVD_CLASS_SERVICES;
extern const WCHAR * const PVD_CLASS_HOSTEDSERVICES;

extern const WCHAR * const PVD_PROP_SERVICE_NAME;
extern const WCHAR * const PVD_PROP_SERVICE_SYSTEMNAME;

extern const WCHAR * const PVD_MTH_SERVICE_PAUSE;
extern const WCHAR * const PVD_MTH_SERVICE_RESUME;

// event

extern const WCHAR * const PVD_CLASS_EVENT;
extern const WCHAR * const PVD_PROP_EVENT_NAME;
extern const WCHAR * const PVD_PROP_EVENT_PATH;
extern const WCHAR * const PVD_PROP_EVENT_TYPE;
extern const WCHAR * const PVD_PROP_EVENT_TYPEMAJOR;
extern const WCHAR * const PVD_PROP_EVENT_TYPEMINOR;
extern const WCHAR * const PVD_PROP_EVENT_NEWSTATE;
extern const WCHAR * const PVD_PROP_EVENT_NODE;
extern const WCHAR * const PVD_PROP_EVENT_GROUP;

extern const WCHAR * const PVD_CLASS_EVENT_ADD;
extern const WCHAR * const PVD_CLASS_EVENT_REMOVE;
extern const WCHAR * const PVD_CLASS_EVENT_STATECHANGE;
extern const WCHAR * const PVD_CLASS_EVENT_GROUPSTATECHANGE;
extern const WCHAR * const PVD_CLASS_EVENT_RESOURCESTATECHANGE;
extern const WCHAR * const PVD_CLASS_EVENT_PROP;

extern const WCHAR * const PVD_CLASS_PROPERTY;

extern const WCHAR * const PVD_PROP_NAME;
extern const WCHAR * const PVD_PROP_STATE;
extern const WCHAR * const PVD_PROP_GROUPCOMPONENT;
extern const WCHAR * const PVD_PROP_PARTCOMPONENT;
extern const WCHAR * const PVD_PROP_CHARACTERISTIC;
extern const WCHAR * const PVD_PROP_FLAGS;


extern const WCHAR * const PVD_WBEM_EXTENDEDSTATUS;
extern const WCHAR * const PVD_WBEM_DESCRIPTION;
extern const WCHAR * const PVD_WBEM_STATUSCODE;
extern const WCHAR * const PVD_WBEM_STATUS;
extern const WCHAR * const PVD_WBEM_CLASS;
extern const WCHAR * const PVD_WBEM_RELPATH;
extern const WCHAR * const PVD_WBEM_PROP_ANTECEDENT;
extern const WCHAR * const PVD_WBEM_PROP_DEPENDENT;
extern const WCHAR * const PVD_WBEM_PROP_DEVICEID;
extern const WCHAR * const PVD_WBEM_QUA_DYNAMIC;
extern const WCHAR * const PVD_WBEM_QUA_CIMTYPE;

extern const WCHAR * const PVD_WBEM_QUA_PROV_VALUE;
extern const WCHAR * const PVD_WBEM_QUA_PROV_NAME;


class CClassData
{
public:
    const WCHAR * wszClassName;
    FPNEW pfConstruct;
    const char * szType;

}; // *** class CClassData

class CClassCreator
{
public:
    CClassCreator( void )
        : m_pfnConstructor( NULL )
        , m_pbstrClassName( L"" )
        { };
    CClassCreator(
        FPNEW           pfnIn,
        const WCHAR *   pwszClassNameIn,
        DWORD           dwEnumTypeIn
        )
        : m_pfnConstructor( pfnIn )
        , m_pbstrClassName( pwszClassNameIn )
        , m_dwEnumType( dwEnumTypeIn )
        { };
    FPNEW           m_pfnConstructor;
    _bstr_t         m_pbstrClassName;
    DWORD           m_dwEnumType;

}; //*** class CClassCreator

template< class _Ty >
struct strLessThan : binary_function< _Ty, _Ty, bool >
{
    bool operator()( const _Ty& _X, const _Ty& _Y ) const
    {
        return ( _wcsicmp( _X, _Y ) < 0 );
    }

}; //*** struct strLessThan

typedef map< _bstr_t, CClassCreator, strLessThan< _bstr_t > > ClassMap;
typedef map< _bstr_t, _bstr_t, strLessThan< _bstr_t > > TypeNameToClass;
extern TypeNameToClass  g_TypeNameToClass;
extern ClassMap         g_ClassMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\provbase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CProvBase.cpp
//
//  Description:    
//      Implementation of CProvBase class 
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ProvBase.h"

//****************************************************************************
//
//  CProvBase
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProvBase::CProvBase(
//      LPCWSTR         pwszNameIn,
//      CWbemServices * pNamespaceIn
//      )
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pwszNameIn      -- Class name
//      pNamespaceIn    -- Namespace
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase::CProvBase(
    LPCWSTR         pwszNameIn,
    CWbemServices * pNamespaceIn
    )
    : m_pNamespace( NULL )
    , m_pClass( NULL )
{
    SCODE   sc;

    m_pNamespace = pNamespaceIn;
    m_bstrClassName = pwszNameIn;

    sc = m_pNamespace->GetObject(
            m_bstrClassName,
            0,
            0,
            &m_pClass,
            NULL
            );

    // failed to construct object,
    if ( FAILED( sc ) )
    {
        throw CProvException( sc );
    }

} //*** CProvBase::CProvBase()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProvBase::~CProvBase( void )
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProvBase::~CProvBase( void )
{
    if ( m_pClass != NULL )
    {
        m_pClass->Release();
    }

} //*** CProvBase::~CProvBase()

//****************************************************************************
//
//  CProvBaseAssociation
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CProvBaseAssociation::GetTypeName(
//      _bstr_t &   rbstrClassNameOut,
//      _bstr_t     bstrPropertyIn
//      )
//
//  Description:
//      Get the type of a property.
//
//  Arguments:
//      rbstrClassNameOut   -- Receives type name string.
//      bstrPropertyIn      -- Property name.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CProvBaseAssociation::GetTypeName(
    _bstr_t &   rbstrClassNameOut,
    _bstr_t     bstrPropertyIn
    )
{
    CError              er;
    IWbemQualifierSet * pQualifier;
    _variant_t          var;
    _bstr_t             bstrTemp;
    LPCWSTR             pwsz, pwsz1;

    er = m_pClass->GetPropertyQualifierSet(
        bstrPropertyIn,
        &pQualifier
        );
    
	if ( er != WBEM_S_NO_ERROR ) {
        return;
    }

    er = pQualifier->Get(
        PVD_WBEM_QUA_CIMTYPE,
        0,
        &var,
        NULL
        );

    if ( er != WBEM_S_NO_ERROR ) {
        goto ERROR_EXIT;
    }


    bstrTemp = var;
	pwsz1 = bstrTemp;
	if (pwsz1==NULL)
		goto ERROR_EXIT;
    pwsz = wcschr( bstrTemp, L':' );
    if ( pwsz != NULL)
    {
        pwsz++;
        rbstrClassNameOut = pwsz;
    }
ERROR_EXIT:
    pQualifier->Release();
    return;

} //*** CProvBaseAssociation::GetTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\provfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvFactory.cpp
//
//  Description:
//      Implementation of CProvFactory class.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ProvFactory.h"

//****************************************************************************
//
//  CProvFactory
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::QueryInterface(
//      REFIID  riidIn,
//      PPVOID  ppvOut
//      )
//
//  Description:
//      Query for an interface supported by this COM object.
//
//  Arguments:
//      riidIn      -- Interface ID.
//      ppvOut      -- Receives the interface pointer.
//
//  Return Values:
//      NOERROR
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::QueryInterface(
    REFIID  riidIn,
    PPVOID  ppvOut
    )
{
    *ppvOut = NULL;

    if ( IID_IUnknown == riidIn || IID_IClassFactory == riidIn )
    {
        *ppvOut = this;
    }

    if ( NULL != *ppvOut )
    {
        ( (LPUNKNOWN) *ppvOut )->AddRef( );
        return NOERROR;
    }

    return E_NOINTERFACE;

} //*** CProvFactory::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProvFactory::AddRef ( void )
//
//  Description:
//      Increment the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProvFactory::AddRef ( void )
{
    //return ++m_cRef;
    return InterlockedIncrement( (long *) &m_cRef );

} //*** CProvFactory::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProvFactory::Release( void )
//
//  Description:
//      Decrement the reference count on the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      New count of references.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CProvFactory::Release( void )
{
    ULONG nNewCount = InterlockedDecrement( (long *) & m_cRef );
    if ( 0L == nNewCount )
    {
        delete this;
    } // if: 0L == nNewCount
    
    return nNewCount;

} //*** CProvFactory::Release()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::CreateInstance(
//      LPUNKNOWN   pUnkOuterIn,
//      REFIID      riidIn,
//      PPVOID      ppvObjOut
//      )
//
//  Description:
//      Instantiates a Locator object returning an interface pointer.
//
//  Arguments:
//      pUnkOuterIn
//          LPUNKNOWN to the controlling IUnknown if we are being used in
//          an aggregation.
//
//      riidIn
//          REFIID identifying the interface the caller desires to have
//          for the new object.
//
//      ppvObjOut
//          PPVOID in which to store the desired interface pointer for the
//          new object.
//
//  Return Values:
//      NOERROR
//      E_OUTOFMEMORY
//      E_NOINTERFACE
//      CLASS_E_NOAGGREGATION
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::CreateInstance(
    LPUNKNOWN   pUnkOuterIn,
    REFIID      riidIn,
    PPVOID      ppvObjOut
    )
{
    IUnknown *  pObj = NULL;
    HRESULT     hr;

    *ppvObjOut = NULL;

    // This object doesnt support aggregation.

    if ( NULL != pUnkOuterIn )
    {
        return CLASS_E_NOAGGREGATION;
    } /// if: not pUnkOuter

    
    hr = m_pFactoryData->pFnCreateInstance(
                NULL,
                reinterpret_cast< VOID ** >( &pObj )
                );

    if ( NULL == pObj )
    {
        return E_OUTOFMEMORY;
    } // if: pObj is NULL

    hr = pObj->QueryInterface( riidIn, ppvObjOut );

    //Kill the object if initial creation or Init failed.

    if ( FAILED( hr ) )
    {
        delete pObj;
    } // if: failed

    return hr;

} //*** CProvFactory::CreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CProvFactory::LockServer(
//      BOOL    fLockIn
//      )
//
//  Description:
//      Increments or decrements the lock count of the DLL.  If the lock
//      count goes to zero and there are no objects, the DLL is allowed to
//      unload.  See DllCanUnloadNow.
//
//  Arguments:
//      fLockIn
//          BOOL specifying whether to increment or decrement the lock count.
//
//  Return Values:
//      NOERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProvFactory::LockServer(
    BOOL    fLockIn
    )
{
    if ( fLockIn )
    {
        InterlockedIncrement( & g_cLock );
    } /// if: lock
    else
    {
        InterlockedDecrement( & g_cLock );
    } /// else:

    return NOERROR;

} //*** CProvFactory::LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\provbase.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvBase.h
//
//  Implementation File:
//      ProvBase.cpp
//
//  Description:
//      Definition of the CProvBase class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CProvBase;
class CProvBaseAssociation;

//////////////////////////////////////////////////////////////////////////////
//  External Declarations
//////////////////////////////////////////////////////////////////////////////

/* main interface class, this class defines all operations can be performed
   on this provider
*/
//class CSqlEval;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvBase
//
//  Description:
//  interface class defines all operations can be performed
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProvBase
{
public:
    virtual SCODE EnumInstance(
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual SCODE GetObject(
        CObjPath &          rObjPathIn,
        long                lFlagsIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn 
        ) = 0;

    virtual SCODE ExecuteMethod(
        CObjPath &          rObjPathIn,
        WCHAR *             pwszMethodNameIn,
        long                lFlagIn,
        IWbemClassObject *  pParamsIn,
        IWbemObjectSink *   pHandlerIn
        ) = 0;

    virtual SCODE PutInstance( 
        CWbemClassObject &  rInstToPutIn,
        long                lFlagIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE DeleteInstance(
        CObjPath &          rObjPathIn,
        long                lFlagIn,
        IWbemContext *      pCtxIn,
        IWbemObjectSink *   pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CProvBase(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        );

    virtual  ~CProvBase( void );

protected:
    CWbemServices *     m_pNamespace;
    IWbemClassObject *  m_pClass;
    _bstr_t             m_bstrClassName;

}; //*** class CProvBase

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvBaseAssociation
//
//  Description:
//  interface class defines all operations can be performed
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProvBaseAssociation
    : public CProvBase
{
public:
    virtual SCODE EnumInstance(
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        ) = 0;

    virtual SCODE GetObject(
        CObjPath &           rObjPathIn,
        long                 lFlagsIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE ExecuteMethod(
        CObjPath &           rObjPathIn,
        WCHAR *              pwszMethodNameIn,
        long                 lFlagIn,
        IWbemClassObject *   pParamsIn,
        IWbemObjectSink *    pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE PutInstance(
        CWbemClassObject &   rInstToPutIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn 
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    virtual SCODE DeleteInstance(
        CObjPath &           rObjPathIn,
        long                 lFlagIn,
        IWbemContext *       pCtxIn,
        IWbemObjectSink *    pHandlerIn
        )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CProvBaseAssociation(
        LPCWSTR         pwszNameIn,
        CWbemServices * pNamespaceIn
        )
        : CProvBase( pwszNameIn, pNamespaceIn )
    {
    }

    virtual  ~CProvBaseAssociation( void )
    {
    }

protected:
    void GetTypeName(
        _bstr_t &   bstrClassNameOut,
        _bstr_t     bstrProperty 
        );

}; //*** class CProvBaseAssociation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cchcp.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cchcp.c

Abstract:

    Not-immplemented messages for changing code page

--*/

#include "cmd.h"


int Chcp( command_line )
TCHAR *command_line;
{
	DBG_UNREFERENCED_PARAMETER( command_line );
    PutStdOut(MSG_NOT_IMPLEMENTED, NOARGS);

    return( SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\safehandle.h ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      SafeHandle.h
//
//  Description:
//      Implementation of safe handle and pointer classes.
//
//  Author:
//      Henry Wang (HenryWa) 24-AUG-1999
//
//////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "ObjectPath.h"

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations
//////////////////////////////////////////////////////////////////////////////

class CError;
template< class T > class SafePtr;
class CWstrBuf;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterApi
//
//  Description:
//      Wrap class for cluster Api
//
//--
//////////////////////////////////////////////////////////////////////////////
class CError
{
public:
    CError( void )
        : m_hr( 0 )
    {
    }

    inline CError & operator=( DWORD dw )
    {
        if ( dw != ERROR_SUCCESS ) 
        {
            throw CProvException ( dw );
        }
        m_hr = HRESULT_FROM_WIN32( dw );
        return *this;
    }

    inline CError & operator=( HRESULT hr )
    {
        if ( FAILED ( hr ) )
        {
            throw CProvException ( hr );
        }
        m_hr = hr;
        return *this;
    }

    operator DWORD( void )
    {
        return HRESULT_CODE( m_hr );
    }

protected:
    HRESULT m_hr;

}; //*** CError

//////////////////////////////////////////////////////////////////////////////
//++
//
//  template< class T >
//  class SafePtr
//
//  Description:
//      Safe handle/pointer class.
//
//  Template Arguments:
//      T       -- Type of handle or pointer.
//
//--
//////////////////////////////////////////////////////////////////////////////
template< class T >
class SafePtr
{
public:
    SafePtr( void )
        : m_handle( NULL )
    {
    }

    SafePtr( T h )
        : m_handle( h )
    {
        h = NULL;
    }
    
    virtual ~SafePtr( void )
    {
        deleteHandle( m_handle );
    }

    T operator&( void )
    {
        return m_handle;
    }
    
    BOOL BIsNULL( void )
    {
        return m_handle == NULL;
    }

    operator T( void )
    {
        return m_handle;
    }
    
    operator void * ( void )
    { 
        return static_cast< void * >( m_handle );
    }

    SafePtr< T > & operator=( T tRhs )
    {
        if ( tRhs == NULL )
        {
            throw CProvException ( GetLastError() );
        }
         
        if ( m_handle != NULL )
        {
            deleteHandle( m_handle );
        }
        m_handle = tRhs;
        tRhs = NULL;
        return *this;
    }

protected:

    T m_handle;

    void deleteHandle( HCLUSTER hCluster )
    {
        if ( hCluster && ( CloseCluster( hCluster ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HNODE hNode ) 
    {
        if ( hNode && ( CloseClusterNode( hNode ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HCLUSENUM hEnum ) 
    {
        if ( hEnum && ( ClusterCloseEnum( hEnum ) != ERROR_SUCCESS ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HRESOURCE hRes )
    {
        if ( hRes && ( CloseClusterResource( hRes ) == FALSE ))
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HGROUP hGroup )
    {
        if ( hGroup && ( CloseClusterGroup( hGroup ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HNETWORK hNetwork )
    {
        if ( hNetwork && ( CloseClusterNetwork( hNetwork ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HNETINTERFACE hNetInterface )
    {
        if ( hNetInterface && ( CloseClusterNetInterface( hNetInterface ) == FALSE ) )
        {
            throw CProvException( GetLastError() );
        }
    }

    void deleteHandle( HRESENUM hResEnum )
    {
        DWORD   dwReturn;
        if ( hResEnum  )
        {
            dwReturn = ClusterResourceCloseEnum( hResEnum ) ;
            if ( dwReturn != ERROR_SUCCESS )
            {
                throw CProvException( dwReturn );
            }
        }
    }

    void deleteHandle( HGROUPENUM hGroupEnum )
    {   
        DWORD   dwReturn;
        if ( hGroupEnum )
        {
            dwReturn = ClusterGroupCloseEnum( hGroupEnum );
            if ( dwReturn != ERROR_SUCCESS )
            {
                throw CProvException( dwReturn );
            }
        }
    }

    void deleteHandle( HCHANGE hChange )
    {
        BOOL fReturn;
        if ( hChange )
        {
            fReturn = CloseClusterNotifyPort( hChange );
            if ( ! fReturn )
            {
                throw CProvException( GetLastError() );
            }
        }
    }

private:
    SafePtr( SafePtr< T > & cT )
    {
    }

}; //*** class SafePtr

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWstrBuf
//
//  Description:
//      Wrap class for Unicode strings.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CWstrBuf
{
public:
     
    CWstrBuf( void )
        : m_pwsz( NULL )
    {
    }

    ~CWstrBuf( void )
    {
        delete [] m_pwsz;
    };

    void SetSize( DWORD dwSize )
    {
        delete [] m_pwsz;
        m_pwsz = new WCHAR[ sizeof( WCHAR ) * dwSize ];
        if ( m_pwsz == NULL )
        {
            throw WBEM_E_OUT_OF_MEMORY;
        } else {
            m_pwsz[0] = UNICODE_NULL;
        }
    }

    operator WCHAR*( void )
    {
        return m_pwsz;
    }

    void Empty( VOID )
    {
        m_pwsz[0] = UNICODE_NULL;
    }

protected:

    LPWSTR  m_pwsz;

}; //*** class CWstrBuf

typedef SafePtr< HRESOURCE >    SAFERESOURCE;
typedef SafePtr< HGROUP >       SAFEGROUP;
typedef SafePtr< HCLUSENUM >    SAFECLUSENUM;
typedef SafePtr< HNODE >        SAFENODE;
typedef SafePtr< HCLUSTER >     SAFECLUSTER;
typedef SafePtr< HNETWORK >     SAFENETWORK;
typedef SafePtr< HNETINTERFACE> SAFENETINTERFACE;
typedef SafePtr< HRESENUM >     SAFERESENUM;
typedef SafePtr< HGROUPENUM >   SAFEGROUPENUM;
typedef SafePtr< HCHANGE >      SAFECHANGE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\provfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ProvFactory.h
//
//  Implementation File:
//      ProvFactory.cpp
//
//  Description:
//      Definition of the CProvFactory class.
//
//  Author:
//      Henry Wang (HenryWa)    24-AUG-1999
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include "InstanceProv.h"

typedef HRESULT ( * PFNCREATEINSTANCE )(
    IUnknown *,
    VOID **
    );

struct FactoryData
{
    const CLSID *       m_pCLSID;
    PFNCREATEINSTANCE   pFnCreateInstance;
    LPCWSTR             m_pwszRegistryName;

}; //*** struct FactoryData

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProvFactory
//
//  Description:
//      Handle class creation
//
//--
/////////////////////////////////////////////////////////////////////////////
class CProvFactory
    : public IClassFactory
{
protected:
    ULONG           m_cRef;
    FactoryData *   m_pFactoryData;

public:
    CProvFactory( FactoryData *   pFactoryDataIn )
        : m_pFactoryData( pFactoryDataIn )
        , m_cRef( 0 )
    {
    }

    virtual ~CProvFactory( void )
    {
    }

    STDMETHODIMP            QueryInterface( REFIID riidIn, PPVOID ppvOut );
    STDMETHODIMP_( ULONG )  AddRef( void );
    STDMETHODIMP_( ULONG )  Release( void );

    //IClassFactory members
    STDMETHODIMP CreateInstance(
        LPUNKNOWN   pUnknownOuterIn,
        REFIID      riidIn,
        PPVOID      ppvObjOut
        );
    STDMETHODIMP LockServer( BOOL fLockIn );

}; //*** class CProvFactory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cbatch.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cbatch.c

Abstract:

    Batch file processing

--*/

#include "cmd.h"


struct batdata *CurrentBatchFile = NULL;

int EchoFlag = E_ON;           /* E_ON = commands are to be echoed        */
int EchoSave;                  /* M016 - Save echo status here            */

extern int Necho;

BOOLEAN GotoFlag = FALSE;      /* TRUE = eGoto() found a label            */

TCHAR *Fvars = NULL;
TCHAR **Fsubs = NULL;
TCHAR *save_Fvars = NULL; /* @@ */
TCHAR **save_Fsubs = NULL; /* @@ */
int  FvarsSaved = FALSE; /* @@ */

extern UINT CurrentCP;
extern ULONG DCount;                   /* M031 */
extern unsigned DosErr;                /* M033 */
extern unsigned flgwd;                 /* M040 */

/*  M011 - Removed RemStr, BatSpecStr, NewBatName and OldBatName from
 *         external declarations below.
 */

extern TCHAR CurDrvDir[];

extern TCHAR Fmt02[], Fmt11[], Fmt12[], Fmt13[], Fmt15[], Fmt17[], Fmt18[]; /* M024 */
extern TCHAR Fmt20[];                  /* M017/M024                       */
extern TCHAR Fmt00[]; /* @@4 */

extern TCHAR TmpBuf[];                 /* M030 - Used for GOTO search     */
extern CHAR  AnsiBuf[];
extern TCHAR GotoStr[];
extern TCHAR GotoEofStr[];
extern TCHAR ForStr[];
extern TCHAR ForLoopStr[];
extern TCHAR ForDirTooStr[];
extern TCHAR ForParseStr[];
extern TCHAR ForRecurseStr[];

extern int LastRetCode;
extern TCHAR chCompletionCtrl;
extern TCHAR chPathCompletionCtrl;
extern unsigned global_dfvalue; /* @@4 */
extern TCHAR LexBuffer[];       /* @@4 */

extern TCHAR SwitChar;         /* M020 - Reference global switch byte     */

extern BOOL CtrlCSeen;
void    CheckCtrlC();

extern jmp_buf MainEnv;

#define BIG_BAT_NEST             200
#define MAX_STACK_USE_PERCENT     90

BOOLEAN flChkStack;
int     CntBatNest;
PVOID   FixedPtrOnStack;

typedef struct {
    PVOID   Base;
    PVOID   GuardPage;
    PVOID   Bottom;
    PVOID   ApprxSP;
} STACK_USE;

STACK_USE   GlStackUsage;


#define DEFAULT_DELIMS  TEXT( " \t" )

// to handle OS/2 vs DOS errorlevel setting rules in a script files.

int  glBatType = NO_TYPE;

/***    ChkStack - check the stack usage
 *
 *  Args:
 *      pFixed    - fixed pointer on stack
 *      pStackUse - struct stack info to return to caller
 *
 *  Returns:
 *      FAILURE   - if stack info is not good
 *      SUCCESS   - otherwise
 *
 *  Notes:
 *      See the comments below about Stack Pointer
 *
 *
 */

int ChkStack (PVOID pFixed, STACK_USE *pStackUse )

{
    MEMORY_BASIC_INFORMATION    Mbi;
    PVOID                       BasePtr;
    PCHAR                       WalkPtr;
    int                         cnt;
    PVOID                       ThreadStackBase,
    ThreadStackLimit;
    CHAR                        VarOnStack;            // keep this automatic var. here !


    // 950119 the best (right) way to find the Current Stack Pointer is
    // to write assembly code for all platforms.
    // I implemented the most portable code. It should work OK with current NT
    // memory models. If NT memory models change then a lot of code will have to
    // be re-written anyway. Several NT projects rely on same assumption.
    // I also have consistency test for all pointers.

    pStackUse->ApprxSP = (VOID *) &VarOnStack;    // address of automatic variable
                                                  // should be close to current SP


    // suggested by MarkL 950119

    ThreadStackBase =  (PVOID) (NtCurrentTeb()->NtTib.StackBase );
    ThreadStackLimit = (PVOID) (NtCurrentTeb()->NtTib.StackLimit );

    if ( (pStackUse->ApprxSP >= ThreadStackBase) ||
         (pStackUse->ApprxSP <= ThreadStackLimit ) )

        return(FAILURE);


    if ( (pFixed >= ThreadStackBase) ||
         (pFixed <= ThreadStackLimit ) )

        return(FAILURE);



    // 1. Pass fixed on-the-stack pointer to find out the base address.

    if ( (VirtualQuery (pFixed, &Mbi, sizeof(Mbi) ) ) != sizeof (Mbi) )
        return(FAILURE);


    BasePtr = Mbi.AllocationBase;



    // 2. walk all the Virtual Memory Regions with same Allocation Base Address.

    cnt = 0;

    for (WalkPtr = (CHAR *)BasePtr;  Mbi.AllocationBase == BasePtr;  WalkPtr += Mbi.RegionSize) {

        if ( (VirtualQuery ( (PVOID) WalkPtr, &Mbi, sizeof(Mbi) ) ) != sizeof (Mbi) )
            return(FAILURE);

        if (cnt == 0) {
            if (Mbi.BaseAddress != Mbi.AllocationBase)
                return(FAILURE);
        }



        if (Mbi.Protect & PAGE_GUARD)
            pStackUse->GuardPage = Mbi.BaseAddress;

        if (Mbi.AllocationBase == BasePtr)
            pStackUse->Bottom =  (PVOID) ( ( (CHAR *) Mbi.BaseAddress) + Mbi.RegionSize);


        cnt++;

        if (cnt >= 1000)               // normally there are 3 regions : committed, guard, reserved.
            return(FAILURE);

    }


    pStackUse->Base = BasePtr;


    if ( pStackUse->Bottom != ThreadStackBase)
        return(FAILURE);


    if ( ( pStackUse->Base   != GlStackUsage.Base) ||
         ( pStackUse->Bottom != GlStackUsage.Bottom ) ||
         ( pStackUse->Bottom <= pStackUse->Base ) )

        return(FAILURE);



    return(SUCCESS);

}


/***    BatAbort - terminate the batch processing unconditionally.
 *
 *  Notes:
 *      Similar to CtrlCAbort()
 *
 *
 */

void BatAbort ()

{

    struct batdata *bdat;


    //
    //  End local environments ( Otherwise we can end up with garbage
    //  in the main environment if any batch file used the setlocal
    //  command ).
    //

    if (CurrentBatchFile) {

        bdat = CurrentBatchFile;
        while ( bdat ) {
            EndAllLocals( bdat );
            bdat = bdat->backptr;
        }
    }

    SigCleanUp();

    CntBatNest = 0;

    longjmp(MainEnv, 1);

}



//
// Used to set and reset ctlcseen flag
//
VOID    SetCtrlC();
VOID    ResetCtrlC( );


/***    BatProc - does the set up before and the cleanup after batch processing
 *
 *  Purpose:
 *      Set up for the execution of a batch job.  If this job is being
 *      chained, (will come here only if part of compound statement),
 *      use the existing batch data structure thereby ending execution
 *      of the existing batch job (though still keeping its stack and data
 *      usage).  If this is the first job or this job is being called,
 *      allocate a new batch data structure.  In either case, use SetBat
 *      to fill the structure and prepare the job, then call BatLoop to
 *      at least begin the execution.  When this returns at completion,
 *      check the env and dircpy fields of the data structure to see if
 *      the current directory and environment need to be reset.  Finally,
 *      turn on the echoflag if no more batch jobs are on the stack.
 *
 *      There are 3 ways to execute a batch job.  They are:
 *              1.  Exactly as DOS 3.x.  This is the default method and
 *                  occurs whenever a batch file is simply executed at the
 *                  command line or chained by another batch file.  In the
 *                  former case, it is the first job and will go through
 *                  BatProc, else it will be detected in BatLoop and will
 *                  will simply replace its parent.
 *              2.  Nested via the CALL statement.  This is new functionality
 *                  and provides the means of executing the child batch
 *                  file and returning to the parent.
 *              3.  Invocation of an external batch processor via ExtCom()
 *                  which then executes the batch file.  This is accomplished
 *                  by the first line of the batch file being of the form:
 *
 *                      ExtProc <batch processor name> [add'l args]
 *
 *  int BatProc(struct cmdnode *n, TCHAR *fname, int typflag)
 *
 *  Args:
 *      n - parse tree node containing the batch job command
 *      fname - the name of the batch file (MUST BE MAX_PATH LONG!)
 *      typflg - 0 = Normal batch file execution
 *               1 = Result of CALL statement
 *
 *  Returns:
 *      FAILURE if the batch processor cannot execute the batch job.
 *      Otherwise, the retcode of the last command in which was executed.
 *
 */

int BatProc(n, fname, typflg)
struct cmdnode *n;
TCHAR *fname;
int typflg;                            /* M011 - "how called" flag        */
{
    struct batdata *bdat;          /* Ptr to new batch data struct    */
    int batretcode;                 /* Retcode - last batch command    */
    int istoplevel;
    SIZE_T         StackUsedPerCent;
    STACK_USE      StackUsage;

#ifdef USE_STACKAVAIL                     // unfortunately not available
    if ( stackavail() < MINSTACKNEED ) { /*  If not enough stack @@4 */
        /*  space, stop processing  */
        PutStdErr(MSG_TRAPC,ONEARG,Fmt00); /* @@4 */
        return(FAILURE);
    }
#endif

    DEBUG((BPGRP,BPLVL,"BP: fname = %ws  argptr = %ws", fname, n->argptr));




/*  M016 - If this is the first batch file executed, the interactive echo
 *         status is saved for later restoration.
 */

    if (!CurrentBatchFile) {
        EchoSave = EchoFlag;
        istoplevel = 1;
        CntBatNest = 0;
    } else
        istoplevel = 0;


    // to check stack only if we are looping too much,
    // to avoid unnecessary overhead

    if (flChkStack && ( CntBatNest > BIG_BAT_NEST ) ) {
        if ( ChkStack (FixedPtrOnStack, &StackUsage) == FAILURE ) {
            flChkStack = 0;
        } else {
            GlStackUsage.GuardPage = StackUsage.GuardPage;
            GlStackUsage.ApprxSP   = StackUsage.ApprxSP;

            StackUsedPerCent = ( ( (UINT_PTR)StackUsage.Bottom - (UINT_PTR)StackUsage.ApprxSP) * 100 ) /
                               ( (UINT_PTR)StackUsage.Bottom - (UINT_PTR)StackUsage.Base );

            if ( StackUsedPerCent >= MAX_STACK_USE_PERCENT ) {
                PutStdErr(MSG_ERROR_BATCH_RECURSION,
                          TWOARGS,
                          CntBatNest,
                          StackUsedPerCent );

                // if ^C was reported by "^C thread" then handle it here, before calling BatAbort().

                CheckCtrlC();

                BatAbort();
            }
        }
    }


    if (typflg)
        CntBatNest++;


/*  M011 - Altered to conditionally build a new data structure based on the
 *         values of typflg and CurrentBatchFile.  Provided the first structure has
 *         been built, chained files no longer cause a new structure, while
 *         CALLed files do.  Also, backpointer and CurrentBatchFile are set here
 *         rather than in BatLoop() as before.  Finally, note that the
 *         file position indicator bdat->filepos must be reset to zero now
 *         when a new file is exec'd. Otherwise a chained file using the old
 *         structure would start off where the last one ended.
 */
    if (typflg || !CurrentBatchFile) {

        DEBUG((BPGRP,BPLVL,"BP: Making new structure"));

        bdat = (struct batdata *) mkstr(sizeof(struct batdata));
        if ( ! bdat )
            return( FAILURE );
        bdat->backptr = CurrentBatchFile;

    } else {

        DEBUG((BPGRP,BPLVL,"BP: Using old structure"));
        bdat = CurrentBatchFile;
    }

    CurrentBatchFile = bdat;         /* Takes care of both cases                */

/*  M011 ends   */
    bdat->stackmin = DCount;               /* M031 - Fix datacount    */
    mystrcpy(TmpBuf,fname);                        /* Put where expected      */


    if (SetBat(n, fname))                   /* M031 - All work done    */
        return(FAILURE);               /* ...in SetBat now        */

#ifndef WIN95_CMD
    // Following two CmdBatNotification calls are being made to
    // let NTVDM know that the binary is coming from a .bat/.cmd
    // file. Without this all those DOS .bat programs are broken which
    // first run a TSR and then run a real DOS app. There are a lot
    // of such cases, Ventura Publisher, Civilization and many more
    // games which first run a TSR. If .bat/.cmd does'nt have any
    // DOS binary these calls dont have any effect.

    if (istoplevel) {

        // to determine the type of the script file: CMD or BAT
        // to decide how to handle the errorlevel

        glBatType = BAT_TYPE;           // default


        if (fname && (mystrlen(fname) >= 5) ) {
            PTCHAR         tmp;

            tmp = fname + mystrlen(fname) - 1;

            if ( ( (*tmp     == TEXT ('D')) || (*tmp     == TEXT ('d')) ) &&
                 ( (*(tmp-1) == TEXT ('M')) || (*(tmp-1) == TEXT ('m')) ) &&
                 ( (*(tmp-2) == TEXT ('C')) || (*(tmp-2) == TEXT ('c')) ) &&
                 ( *(tmp-3) == DOT ) ) {

                glBatType = CMD_TYPE;
            }
        }

        CmdBatNotification (CMD_BAT_OPERATION_STARTING);
    }
#endif // WIN95_CMD

    batretcode = BatLoop(bdat,n);                          /* M039    */

    if (istoplevel) {
#ifndef WIN95_CMD
        CmdBatNotification (CMD_BAT_OPERATION_TERMINATING);
#endif // WIN95_CMD
        CntBatNest = 0;
        glBatType  = NO_TYPE;
    }


    DEBUG((BPGRP, BPLVL, "BP: Returned from BatLoop"));
    DEBUG((BPGRP, BPLVL, "BP: bdat = %lx CurrentBatchFile = %lx",bdat,CurrentBatchFile));

/*  M011 - Now that setlocal and endlocal control the saving and restoring
 *         of environments and current directories, it is necessary to
 *         check each batch data structure before popping it off the stack
 *         to see if its file issued a SETLOCAL command.  EndAllLocals() tests
 *         the env and dircpy fields, doing nothing if no localization
 *         needs to be reset.  No tests need be done before calling it.
 */
    if (CurrentBatchFile == bdat) {
        DEBUG((BPGRP, BPLVL, "BP: bdat=CurrentBatchFile, calling EndAllLocals"));
        EndAllLocals(bdat);
        CurrentBatchFile = bdat->backptr;
        if (CntBatNest > 0)
            CntBatNest--;
    }

    if (CurrentBatchFile == NULL) {
        EchoFlag = EchoSave;   /* M016 - Restore echo status      */
        CntBatNest = 0;
    }

    DEBUG((BPGRP, BPLVL, "BP: Exiting, CurrentBatchFile = %lx", CurrentBatchFile));

    return(batretcode);
}




/***    BatLoop - controls the execution of batch files
 *
 *  Purpose:
 *      Loop through the statements in a batch file.  Do the substitution.
 *      If this is the first statement and it is a REM command, call eRem()
 *      directly to check for possible external batch processor invocation.
 *      Otherwise, call Dispatch() to execute it and continue.
 *
 *  BatLoop(struct batdata *bdat, struct cmdnode *c) (M031)
 *
 *  Args:
 *      bdat - Contains info needed to execute the current batch job
 *      c    - The node for this batch file (M031)
 *
 *  Returns:
 *      The retcode of the last command in the batch file.
 *
 *  Notes:
 *      Execution should end if the target label of a Goto command is not
 *      found, a signal is received or an unrecoverable error occurs.  It
 *      will be indicated by the current batch data structure being
 *      popped off the batch jobs stack and is detected by comparing
 *      CurrentBatchFile and bdat.  If they aren't equal, something happened so
 *      return.
 *
 *      GotoFlag is reset everytime through the loop to make sure that
 *      execution resumes after a goto statement is executed.
 *
 */

BatLoop(bdat,c)
struct batdata *bdat;
struct cmdnode *c;
{
    struct node *n;                /* Ptr to next statement           */
    BOOL fSilentNext;

    int firstline = TRUE;           /* TRUE = first valid line         */
    CRTHANDLE       fh;            /* Batch job file handle           */
    int batretcode = SUCCESS;      /* Last Retcode (M008 init)        */
    fSilentNext = FALSE;

    for (; CurrentBatchFile == bdat; ) {

        CheckCtrlC();
        GotoFlag = FALSE;

        //
        // If extensions are enabled, this is the first line in the
        // file and it begins with a COLON, then we got here via
        // CALL :label, so turn this into a GOTO :label command
        // as BatProc/SetBat have already done the work of pushing
        // our state and parsing the arguments.
        //
        if (fEnableExtensions && firstline && *c->cmdline == COLON) {
            struct cmdnode *c1;
            c1 = (struct cmdnode *)mknode();
            if (c1 == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                return( FAILURE );
            }

            c1->type = CMDTYP;

            c1->cmdline = mkstr((mystrlen(GotoStr)+1)*sizeof(TCHAR));
            if (c1->cmdline == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                return FAILURE;
            }

            mystrcpy(c1->cmdline, GotoStr);

            c1->argptr = mkstr((mystrlen(c->cmdline)+1)*sizeof(TCHAR));
            if (c1->argptr == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                return FAILURE;
            }

            mystrcpy(c1->argptr, c->cmdline);

            *(c1->argptr) = SPACE;

            //
            // Set a flag so eGoTo does not try to abort a FOR loop
            // because of one of these new CALL forms.
            //
            c1->flag = CMDNODE_FLAG_GOTO;

            //
            // Then again, maybe not.  I have to think about this some
            // more.
            //
            c1->flag = 0;
            n = (struct node *)c1;
            //
            // Since we generated this GOTO statement, dont let the user
            // know
            //
            fSilentNext = TRUE;
        } else {
            //
            // Open and position the batch file to where next statement
            //
            if ((fh = OpenPosBat(bdat)) == BADHANDLE)
                return( FAILURE);              /* Ret if error    */


            DEBUG((BPGRP, BPLVL, "BLOOP: fh = %d", (ULONG)fh));


            n = Parser(READFILE, (INT_PTR)fh, bdat->stacksize); /* Parse   */
            bdat->filepos = _tell(fh); // next statement
            Cclose(fh);

            if ((n == NULL) || (n == (struct node *) EOS)) {
                continue;
            }

            DEBUG((BPGRP, BPLVL, "BLOOP: node = %x", n));
            DEBUG((BPGRP, BPLVL, "BLOOP: fpos = %lx", bdat->filepos));

/*  If syntax error, it is impossible to continue so abort.  Note that
 *  the Abort() function doesn't return.
 */
            if ( ( n == (struct node *)PARSERROR) ||   /* If error...*/
/* @@4 */               ( global_dfvalue == MSG_SYNERR_GENL ) )
            /* @@4 */
            {
                PSError();

                if ((EchoFlag == E_ON) && !Necho) {

                    DEBUG((BPGRP, BPLVL, "BLOOP: Displaying Statement."));

                    PrintPrompt();
                    PutStdOut(MSG_LITERAL_TEXT,ONEARG,&LexBuffer[1]);
                }
                Abort();                       /* ...quit         */
            }

            if (n == (struct node *) EOF)           /* If EOF...       */
                return(batretcode);            /* ...return also  */
        }

        DEBUG((BPGRP, BPLVL, "BLOOP: type = %d", n->type));

/*  M008 - By the addition of the second conditional term (&& n), any
 *         leading NULL lines in the batch file will be skipped without
 *         penalty.
 */
        if (firstline && n)             /* Kill firstline...       */
            firstline = FALSE;     /* ...when passed          */

/*  M008 - Don't prompt, display or dispatch if statement is label for Goto
 *  M009 - Altered second conditional below to test for REMTYP.  Was a test
 *         for CMDTYP and a strcmpi with the RemStr string.
 */
        if (n->type == CMDTYP &&
            *(((struct cmdnode *) n)->cmdline) == COLON)
            continue;

/*  M019 - Added extra conditional to test for leading SILent node
 */

        if (fSilentNext)
            fSilentNext = FALSE;
        else
            if (EchoFlag == E_ON && n->type != SILTYP && !Necho) {

            DEBUG((BPGRP, BPLVL, "BLOOP: Displaying Statement."));

            PrintPrompt();
            DisplayStatement(n, DSP_SIL);          /* M019    */
            cmd_printf(CrLf);                      /* M026    */
        }

        if ( n->type == SILTYP ) {       /*  @@ take care of */
            n = n->lhs;                 /*  @@ recursive batch files */
        } /* endif */

/* M031 - Chained batch files no longer go through dispatch.  They become
 *        simply an extention of the current one by adding their redirection
 *        and replacing the current batch data information with their own.
 */
        if ( n == NULL ) {
            batretcode = SUCCESS;
        } else if (n->type == CMDTYP &&
                   FindCmd(CMDHIGH, ((struct cmdnode *)n)->cmdline, TmpBuf) == -1 &&
/* M035 */          !mystrchr(((struct cmdnode *)n)->cmdline, STAR) &&
/* M035 */          !mystrchr(((struct cmdnode *)n)->cmdline, QMARK) &&
                   SearchForExecutable((struct cmdnode *)n, TmpBuf) == SFE_ISBAT) {

            DEBUG((BPGRP, BPLVL, "BLOOP: Chaining to %ws", bdat->filespec));
            if ((n->rio && AddRedir(c,(struct cmdnode *)n)) ||
                SetBat((struct cmdnode *)n, bdat->filespec)) {
                return(FAILURE);
            }
            firstline = TRUE;
            batretcode = SUCCESS;
        } else {

            DEBUG((BPGRP, BPLVL, "BLOOP: Calling Dispatch()..."));
            DEBUG((BPGRP, BPLVL, "BLOOP: ...node type = %d",n->type));

            batretcode = Dispatch(RIO_BATLOOP, n);
            {
                extern CPINFO CurrentCPInfo;

                ResetConsoleMode();
                //
                // Get current CodePage Info.  We need this to decide whether
                // or not to use half-width characters.
                //
                GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);
                //
                // Maybe console output code page was changed by CHCP or MODE,
                // so need to reset LanguageID to correspond to code page.
                //
#if !defined( WIN95_CMD )
                CmdSetThreadUILanguage(0);
#endif
        
            }

        }
    }

    DEBUG((BPGRP, BPLVL, "BLOOP: At end, returning %d", batretcode));
    DEBUG((BPGRP, BPLVL, "BLOOP: At end, CurrentBatchFile = %lx", CurrentBatchFile));
    DEBUG((BPGRP, BPLVL, "BLOOP: At end, bdat = %lx", bdat));

    return(batretcode);
}




/***    SetBat - Replaces current batch data with new. (M031)
 *
 *  Purpose:
 *      Causes a chained batch file's information to replace its parent's
 *      in the current batch data structure.
 *
 *  SetBat(struct cmdnode *n, TCHAR *fp)
 *
 *  Args:
 *      n  - pointer to the node for the chained batch file target.
 *      fp - pointer to filename found for batch file.
 *      NOTE: In addition, the batch filename will be in TmpBuf at entry.
 *
 *  Returns:
 *      FAILURE if memory could not be allocated
 *      SUCCESS otherwise
 *
 *  Notes:
 *    - WARNING - No allocation of memory must occur above the call to
 *      FreeStack().  When this call occurs, all allocated heap space
 *      is freed back to the empty batch data structure and its filespec
 *      string.  Any allocated memory would also be freed.
 *    - The string used for "->filespec" is that malloc'd by ECWork or
 *      eCall during the search for the batch file.  In the case of
 *      calls from BatLoop, the existing "->filespec" string is used
 *      by copying the new batch file name into it.  THIS STRING MUST
 *      NOT BE RESIZED!
 *
 */

int
SetBat(struct cmdnode *n, PTCHAR fp)
{
    int i;                 // Index counters
    int j;
    TCHAR *s;                      // Temp pointer

    SAFER_CODE_PROPERTIES CodeProps = {sizeof(SAFER_CODE_PROPERTIES), SAFER_CRITERIA_IMAGEPATH, 0};
    SAFER_LEVEL_HANDLE Level = NULL;

    DEBUG((BPGRP,BPLVL,"SETBAT: Entered"));
    CurrentBatchFile->hRestrictedToken = NULL; // Restricted token for batchfile

    //
    //  We delay load these routines in order to allow CMD to work on downlevel versions
    //

    ReportDelayLoadErrors = FALSE;
    
    try {

        //
        // Now get the restricted token to be used for this batch file. The batch file
        // may appear in TmpBuf (for normal batch execution or calls) or, in the case of
        //  CALL :LABEL
        // the name appears in CurrentBatchFile->backptr->filespec
        //

        CodeProps.ImagePath = (WCHAR *) TmpBuf;
        if (fEnableExtensions && *n->cmdline == COLON) {
            CodeProps.ImagePath = (WCHAR *)CurrentBatchFile->backptr->filespec;
        }

        //
        // Identify the level at which the code should be run.
        //

        if (SaferIdentifyLevel(1, &CodeProps, &Level, NULL)) {

            //
            // Compute the token from the level.
            //

// Temp until Safer gets fixed
//            BOOL FailAlways = _tcsstr( TmpBuf, TEXT( "disallowed" )) != NULL;

            if (
//                !FailAlways && 
                SaferComputeTokenFromLevel(Level, NULL, &CurrentBatchFile->hRestrictedToken, SAFER_TOKEN_NULL_IF_EQUAL, NULL)) {

                //
                // All is well. We have successfuly computed a restricted token for
                // the batch file. Close the handle to authorization level.
                //

                SaferCloseLevel(Level);

                //
                // Impersonate if a restricted token was returned by authorization.
                // The revert happens in EndAllLocals.
                //

                if (CurrentBatchFile->hRestrictedToken != NULL) {
                    if (!ImpersonateLoggedOnUser(CurrentBatchFile->hRestrictedToken)) {

                        // 
                        // We failed to impersonate. Close the token handle and 
                        // return failure.
                        //

                        CloseHandle(CurrentBatchFile->hRestrictedToken);
                        CurrentBatchFile->hRestrictedToken = NULL;
                        return(FAILURE);
                    }
                }


            } else {

                DWORD dwLastError = GetLastError();
                
//                if (FailAlways) dwLastError = ERROR_ACCESS_DISABLED_BY_POLICY;
                
                if (dwLastError == ERROR_ACCESS_DISABLED_BY_POLICY) {
                    SaferRecordEventLogEntry(
                        Level, 
                        (WCHAR *) fp, 
                        NULL);
                                            
                        PutStdErr(ERROR_ACCESS_DISABLED_BY_POLICY, NOARGS );

                }

                //
                // We failed to compute the restricted token from the authorization level.
                // We will not run the batchfile.
                //

                CurrentBatchFile->hRestrictedToken = NULL;
                SaferCloseLevel(Level);
                return(FAILURE);

            }

        } else {

            //
            // In case of errors, return failure.
            //

            return(FAILURE);

        }
    } except (LastRetCode = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
         if (LastRetCode != VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND)) {
             ReportDelayLoadErrors = TRUE;
             return FAILURE;
         }
    }

    ReportDelayLoadErrors = TRUE;
    
    CurrentBatchFile->filepos = 0;   // Zero position pointer
    CurrentBatchFile->filespec = fp; // Insure correct str
    
    //
    // If extensions are enabled and the command line begins with
    // a COLON then we got here via CALL :label, so update our
    // CurrentBatchFile file spec with our parents file spec, since we are
    // in the same file.
    //
    if (fEnableExtensions && *n->cmdline == COLON) {
        struct batdata *bdat;

        bdat = CurrentBatchFile->backptr;
        mystrcpy(CurrentBatchFile->filespec, bdat->filespec);
        CurrentBatchFile->filepos = bdat->filepos;
    } else {
        //
        // Otherwise old behavior is going to a new file.  Get its full name
        //
        if (FullPath(CurrentBatchFile->filespec, TmpBuf,MAX_PATH)) /* If bad name,   */
            return(FAILURE);               /* ...return failure       */
    }


    mystrcpy(TmpBuf, n->cmdline);          /* Preserve cmdline and    */
    *(s = TmpBuf+mystrlen(TmpBuf)+1) = NULLC; /* ...argstr in case this  */
    if (n->argptr)
        mystrcpy(s, n->argptr);            /* ...is a chain and node  */

    FreeStack(CurrentBatchFile->stackmin);           /* ...gets lost here       */

    DEBUG((BPGRP,BPLVL,"SETBAT: fspec = `%ws'",CurrentBatchFile->filespec));
    DEBUG((BPGRP,BPLVL,"SETBAT: orgargs = `%ws'",s));
    DEBUG((BPGRP,BPLVL,"SETBAT: Making arg0 string"));

    CurrentBatchFile->alens[0] = mystrlen(TmpBuf);
    CurrentBatchFile->aptrs[0] = mkstr( (CurrentBatchFile->alens[0]+1) * sizeof( TCHAR ) );
    if (CurrentBatchFile->aptrs[0] == NULL) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return(FAILURE);
    }
    mystrcpy(CurrentBatchFile->aptrs[0], TmpBuf);
    CurrentBatchFile->orgaptr0 = CurrentBatchFile->aptrs[0];

    DEBUG((BPGRP, BPLVL, "SETBAT: arg 0 = %ws", CurrentBatchFile->aptrs[0]));
    DEBUG((BPGRP, BPLVL, "SETBAT: len 0 = %d", CurrentBatchFile->alens[0]));
    DEBUG((BPGRP, BPLVL, "SETBAT: Zeroing remaining arg elements"));

    for (i = 1; i < 10; i++) {            /* Zero any previous       */
        CurrentBatchFile->aptrs[i] = 0;          /* ...arg pointers and     */
        CurrentBatchFile->alens[i] = 0;          /* ...length values        */
    }

    if (*s) {

        DEBUG((BPGRP,BPLVL,"SETBAT: Making orgargs string"));

        CurrentBatchFile->orgargs = mkstr( (mystrlen( s ) + 1) * sizeof( TCHAR ) );
        if (CurrentBatchFile->orgargs == NULL) {
            PutStdErr(MSG_NO_MEMORY, NOARGS );
            return(FAILURE);
        }

        //
        //  Strip leading spaces from orgargs
        //

        s += _tcsspn( s, TEXT( " \t" ));

        mystrcpy( CurrentBatchFile->orgargs, s );

        //
        //  Strip trailing spaces from orgargs
        //

        s = CurrentBatchFile->orgargs + mystrlen( CurrentBatchFile->orgargs );
        while (s != CurrentBatchFile->orgargs) {
            if (s[-1] != TEXT( ' ' ) && s[-1] != TEXT( '\t' )) {
                break;
            }
            s--;
        }

        *s = TEXT( '\0' );

        if (!fEnableExtensions) {
            //
            // /Q on batch script invocation only supported when extensions disabled
            //
            s = CurrentBatchFile->orgargs;
            while (s = mystrchr(s, SwitChar)) {
                if (_totupper(*(++s)) == QUIETCH) {
                    EchoFlag = E_OFF;
                    mystrcpy(s-1,s+1);
                    DEBUG((BPGRP,BPLVL,"SETBAT: Found Q switch, orgargs now = %ws",CurrentBatchFile->orgargs));
                    break;
                }
            }
        }

        DEBUG((BPGRP,BPLVL,"SETBAT: Tokenizing orgargs string"));

        s = TokStr(CurrentBatchFile->orgargs, NULL, TS_NOFLAGS);

        for (i = 1; *s && i < 10; s += j+1, i++) {
            CurrentBatchFile->aptrs[i] = s;
            CurrentBatchFile->alens[i] = j = mystrlen(s);
            DEBUG((BPGRP, BPLVL, "SETBAT: arg %d = %ws", i, CurrentBatchFile->aptrs[i]));
            DEBUG((BPGRP, BPLVL, "SETBAT: len %d = %d", i, CurrentBatchFile->alens[i]));
        }

        CurrentBatchFile->args = s;
    } else {

        DEBUG((BPGRP, BPLVL, "SETBAT: No args found, ptrs = 0"));

        CurrentBatchFile->orgargs = CurrentBatchFile->args = NULL;
    }

    CurrentBatchFile->stacksize = DCount;            /* Protect from parser     */


    DEBUG((BPGRP, BPLVL, "SETBAT: Stack set: Min = %d, size = %d",CurrentBatchFile->stackmin,CurrentBatchFile->stacksize));

    return(SUCCESS);
}




/***    DisplayStatement - controls the displaying of batch file statements
 *
 *  Purpose:
 *      Walk a parse tree to display the statement contained in it.
 *      If n is null, the node contains a label, or the node is SILTYP
 *      and flg is DSP_SIL, do nothing.
 *
 *  void DisplayStatement(struct node *n, int flg)
 *
 *  Args:
 *      n   - pointer to root of the parse tree
 *      flg - flag indicates "silent" or "verbose" mode
 *
 */

void DisplayStatement(n, flg)
struct node *n;
int flg;               /* M019 - New flag argument                */
{
    TCHAR *eqstr = TEXT("");

    void DisplayOperator(),
    DisplayRedirection();     /* M008 - Made void                */

/*  M019 - Added extra conditionals to determine whether or not to display
 *         any part of the tree that following a SILent node.  This is done
 *         based on a new flag argument which indicates SILENT or VERBOSE
 *         mode (DSP_SIL or DSP_VER).
 *         NOTE: When this routine is combined with pipes to xfer statements
 *         to a child Command.com via STDOUT, it will have to be changed in
 *         order to discriminate between the two purposes for which it is
 *         called.  Flag definitions already exist in CMD.H for this purpose
 *         (DSP_SCN & DSP_PIP).
 */
    if (!n ||
        (n->type == SILTYP && flg == DSP_SIL) ||
        ((((struct cmdnode *) n)->cmdline) &&
         *(((struct cmdnode *) n)->cmdline) == COLON))
        return;

    switch (n->type) {
    case LFTYP:
        DisplayOperator(n, CrLf);
        break;

    case CSTYP:
        DisplayOperator(n, CSSTR);
        break;

    case ORTYP:
        DisplayOperator(n, ORSTR);
        break;

    case ANDTYP:
        DisplayOperator(n, ANDSTR);
        break;

    case PIPTYP:
        DisplayOperator(n, PIPSTR);
        break;

    case SILTYP:
        CmdPutString( SILSTR );
        DisplayStatement(n->lhs, DSP_VER);
        DisplayRedirection(n);
        break;

    case PARTYP:

        DEBUG((BPGRP, BPLVL, "DST: Doing parens"));

        CmdPutString( LEFTPSTR );
        if (n->lhs->type == LFTYP)
            cmd_printf( CrLf );
        DisplayStatement(n->lhs, DSP_SIL);     /* M019    */
        if (n->lhs->type == LFTYP)
            cmd_printf( CrLf );
        cmd_printf(Fmt11, RPSTR);              /* M013 */
        DisplayRedirection(n);
        break;

    case FORTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying FOR."));

        //
        // If extensions are enabled, handle displaying the new
        // optional switches on the FOR statement.
        //
        if (fEnableExtensions) {
            cmd_printf(TEXT("%.3s"), ((struct fornode *) n)->cmdline);
            if (((struct fornode *)n)->flag & FOR_LOOP)
                cmd_printf(TEXT(" %s"), ForLoopStr);
            else
                if (((struct fornode *)n)->flag & FOR_MATCH_DIRONLY)
                cmd_printf(TEXT(" %S"), ForDirTooStr);
            else
                if (((struct fornode *)n)->flag & FOR_MATCH_PARSE) {
                cmd_printf(TEXT(" %s"), ForParseStr);
                if (((struct fornode *)n)->parseOpts)
                    cmd_printf(TEXT(" %s"), ((struct fornode *)n)->parseOpts);
            } else
                if (((struct fornode *)n)->flag & FOR_MATCH_RECURSE) {
                cmd_printf(TEXT(" %s"), ForRecurseStr);
                if (((struct fornode *)n)->recurseDir)
                    cmd_printf(TEXT(" %s"), ((struct fornode *)n)->recurseDir );
            }
            cmd_printf(TEXT(" %s "), ((struct fornode *) n)->cmdline+_tcslen(ForStr)+1);
        } else
            cmd_printf(Fmt11, ((struct fornode *) n)->cmdline);

        cmd_printf(Fmt13, ((struct fornode *) n)->arglist, ((struct fornode *) n)->cmdline+DOPOS);              
/* M019 */DisplayStatement(((struct fornode *) n)->body, DSP_VER);
        break;

    case IFTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying IF."));

        cmd_printf(Fmt11, ((struct ifnode *) n)->cmdline); /* M013 */
        //
        // If extensions are enabled, handle displaying the new
        // optional /I switch on the IF statement.
        //
        if (fEnableExtensions) {
            if (((struct ifnode *)n)->cond->type != NOTTYP) {
                if (((struct ifnode *)n)->cond->flag == CMDNODE_FLAG_IF_IGNCASE)
                    cmd_printf(TEXT("/I "));
            } else
                if (((struct cmdnode *)(((struct ifnode *)n)->cond->argptr))->flag == CMDNODE_FLAG_IF_IGNCASE)
                cmd_printf(TEXT("/I "));
        }

/* M019 */DisplayStatement((struct node *)(((struct ifnode *) n)->cond), DSP_SIL);              
/* M019 */DisplayStatement(((struct ifnode *) n)->ifbody, DSP_SIL);
        if (((struct ifnode *) n)->elsebody) {
            cmd_printf(Fmt02, ((struct ifnode *) n)->elseline);                      /* M013 */
/* M019 */DisplayStatement(((struct ifnode *) n)->elsebody, DSP_SIL);
        }
        break;

    case NOTTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying NOT."));

/*  M002 - Removed '\n' from printf statement below.
 */
        cmd_printf(Fmt11, ((struct cmdnode *) n)->cmdline);              /* M013 */
/*  M002 ends   */
/* M019 */DisplayStatement((struct node *)(((struct cmdnode *) n)->argptr), DSP_SIL);
        break;

    case STRTYP:
    case CMPTYP:
        eqstr = TEXT("== ");
        //
        // If extensions are enabled, handle displaying the
        // new forms of comparison operators.
        //
        if (fEnableExtensions) {
            if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_EQU)
                eqstr = TEXT("EQU ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_NEQ)
                eqstr = TEXT("NEQ ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_LSS)
                eqstr = TEXT("LSS ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_LEQ)
                eqstr = TEXT("LEQ ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_GTR)
                eqstr = TEXT("GTR ");
            else
                if (((struct cmdnode *) n)->cmdarg == CMDNODE_ARG_IF_GEQ)
                eqstr = TEXT("GEQ ");
        }
        cmd_printf(Fmt12, ((struct cmdnode *) n)->cmdline, eqstr, ((struct cmdnode *) n)->argptr); /* M013 */
        break;

    case ERRTYP:
    case EXSTYP:
    case CMDVERTYP:
    case DEFTYP:
        cmd_printf(Fmt15, ((struct cmdnode *) n)->cmdline, ((struct cmdnode *) n)->argptr); /* M013 */
        break;

    case REMTYP:            /* M009 - Rem now seperate type    */
    case CMDTYP:

        DEBUG((BPGRP, BPLVL, "DST: Displaying command."));
        CmdPutString( ((struct cmdnode *) n)->cmdline );
        if (((struct cmdnode *) n)->argptr)
            cmd_printf(Fmt11, ((struct cmdnode *) n)->argptr); /* M013 */
        DisplayRedirection(n);
    }
}




/***    DisplayOperator - controls displaying statments containing operators
 *
 *  Purpose:
 *      Diplay an operator and recurse on its left and right hand sides.
 *
 *  void DisplayOperator(struct node *n, TCHAR *opstr)
 *
 *  Args:
 *      n - node of operator to be displayed
 *      opstr - the operator to print
 *
 */

void DisplayOperator(n, opstr)
struct node *n;
TCHAR *opstr;
{

    void DisplayStatement();       /* M008 - made void                */

    DEBUG((BPGRP, BPLVL, "DOP"));

    DisplayStatement(n->lhs, DSP_SIL);                     /* M019    */

    if (n->rhs) {
        cmd_printf(Fmt02, opstr);
        DisplayStatement(n->rhs, DSP_SIL);             /* M019    */
    }
}




/***    DisplayRedirection - displays statements' I/O redirection
 *
 *  Purpose:
 *      Display the type and file names of any redirection associated with
 *      this node.
 *
 *  void DisplayRedirection(struct node *n)
 *
 *  Args:
 *      n - the node to check for redirection
 *
 *  Notes:
 *      M017 - This function has been extensively modified to conform
 *      to new data structures for redirection.
 *      M018 - Modified for redirection of handles other than 0 for input.
 */

void DisplayRedirection(n)
struct node *n;
{
    struct relem *tmp;

    DEBUG((BPGRP, BPLVL, "DRD"));

    tmp = n->rio;

    while (tmp) {

        cmd_printf(Fmt18, TEXT('0')+tmp->rdhndl, tmp->rdop);

        if (tmp->flag)
            cmd_printf(Fmt20);

        cmd_printf(Fmt11, tmp->fname);
        tmp = tmp->nxt;
    }
}




/***    OpenPosBat - open a batch file and position its file pointer
 *
 *  Purpose:
 *      Open a batch file and position the file pointer to the location at
 *      which the next statement is to be read.
 *
 *  int OpenPosBat(struct batdata *bdat)
 *
 *  Args:
 *      bdat - pointer to current batch job structure
 *
 *  Returns:
 *      The handle of the file if everything is successful.  Otherwise,
 *      FAILURE.
 *
 *  Notes:
 *      M033 - Now reports sharing violation errors if appropriate.
 *
 */

CRTHANDLE OpenPosBat(bdat)
struct batdata *bdat;
{
    CRTHANDLE fh;          /* Batch file handle               */
    int DriveIsFixed();

    DEBUG((BPGRP, BPLVL, "OPB: fspec = %ws", bdat->filespec));

    while ((fh = Copen(bdat->filespec, O_RDONLY|O_BINARY)) == BADHANDLE) {

        if (DosErr != ERROR_FILE_NOT_FOUND) {           /* M037    */
            PrtErr(ERROR_OPEN_FAILED);     /* M037    */
            return(fh);
        } else if ( DriveIsFixed( bdat->filespec ) ) {   /* @@4 */
            PutStdErr( MSG_CMD_BATCH_FILE_MISSING, NOARGS); /* @@4 */
            return(fh);                            /* @@4 */
        } else {
            PutStdErr(MSG_INSRT_DISK_BAT, NOARGS);
            if (0x3 == _getch()) {
                SetCtrlC();
                return(fh);
            }
        }
    }

    SetFilePointer(CRTTONT(fh), bdat->filepos, NULL, FILE_BEGIN);
    return(fh);
}




/***    eEcho - execute an Echo command
 *
 *  Purpose:
 *      To either print a message, change the echo status, or display the
 *      echo status.
 *
 *  int eEcho(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the echo command
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int eEcho(
         struct cmdnode *n
         )
{
    int oocret;
    int rc;

    DEBUG((BPGRP, OTLVL, "eECHO: Entered."));

    switch (oocret = OnOffCheck(n->argptr, OOC_NOERROR)) {
    case OOC_EMPTY:

        rc = PutStdOut(((EchoFlag == E_ON) ? MSG_ECHO_ON : MSG_ECHO_OFF), NOARGS);
        if (rc != 0) {
            if (FileIsPipe(STDOUT)) {
                PutStdErr( MSG_CMD_INVAL_PIPE, NOARGS );
            } else if ( !FileIsDevice( STDOUT ) ) {
                PutStdErr( rc, NOARGS );
            } else if (!(flgwd & 2)) {
                PutStdErr( ERROR_WRITE_FAULT, NOARGS );
            }
        }
        break;

    case OOC_OTHER:
        cmd_printf(Fmt17, n->argptr+1);
        break;
    default:
        EchoFlag = oocret;
    }

    return(SUCCESS);
}




/***    eFor - controls the execution of a For loop
 *
 *  Purpose:
 *      Loop through the elements in a FOR loop arg list.  Expand those that
 *      contain wildcards.
 *
 *  int eFor(struct fornode *n)
 *
 *  Args:
 *      n - the FOR loop parse tree node
 *
 *  Returns:
 *      The retcode of the last command executed in the FOR body.
 *
 *  Notes:
 *      *** IMPORTANT ***
 *      Each iteration through the FOR loop being executed causes more memory
 *      to be allocated.  This can cause Command to run out of memory.  To
 *      keep this from happening, we use DCount to locate the end of the data
 *      stack after the first iteration through the FOR loop.  At the end of
 *      each successive iteration through the loop, memory is freed that was
 *      allocated during that iteration of the loop.  The first iterations'
 *      memory is NOT freed because there is data allocated there that must
 *      be kept for successive iterations; namely, the save structure in the
 *      for loop node.
 *
 */

void FvarRestore()
{
    if ( FvarsSaved ) {       /* @@ */
        FvarsSaved = FALSE;   /* @@ */
        Fvars = save_Fvars;  /* @@ */
        Fsubs = save_Fsubs;  /* @@ */
    }                     /* @@ */
}

FRecurseWork(
            TCHAR *path,
            TCHAR *filepart,
            struct fornode *pForNode,
            PCPYINFO fsinfo,
            int i,
            TCHAR *argtoks
            );

FParseWork(
          struct fornode *pForNode,
          int i,
          BOOL bFirstLoop
          );

FLoopWork(
         struct fornode *pForNode,
         PCPYINFO fsinfo,
         int i,
         TCHAR *argtoks,
         BOOL bFirstLoop
         );

int eFor(struct fornode *pForNode)
{
    TCHAR *argtoks;        /* Tokenized argument list         */
    int i = 0;                     /* Temp                            */
    int datacount;                 /* Elts on data stack not to free  */
    int forretcode = SUCCESS;
/*509*/int argtoklen;
    BOOL bFirstLoop;
    PCPYINFO fsinfo;        /* Used for expanded fspec */

    FvarsSaved = FALSE; /* @@ */
    bFirstLoop = TRUE;

    fsinfo = (PCPYINFO) mkstr(sizeof(CPYINFO));

    if (!fsinfo) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return(FAILURE);
    }

    if (Fvars) {
        Fvars = (TCHAR*)resize(Fvars,((i = mystrlen(Fvars))+2)*sizeof(TCHAR));
        Fsubs = (TCHAR **)resize(Fsubs,(i+1)*(sizeof(TCHAR *)) );
    } else {
        Fvars = (TCHAR*)mkstr(2*sizeof(TCHAR));                /* If no str, make one     */
        Fsubs = (TCHAR **)mkstr(sizeof(TCHAR *));      /* ...also a table         */
    }

    if (Fvars == NULL || Fsubs == NULL) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return FAILURE;
    }

    Fvars[i] = (TCHAR)(pForNode->forvar);            /* Add new var to str  */
    Fvars[i+1] = NULLC;

    //
    // Check for the new forms of the FOR loop.  None of these flags
    // will be set if extensions are not enabled
    //
    if (pForNode->flag & FOR_LOOP) {
        TCHAR ForLoopBuffer[32];
        int ForLoopValue, ForLoopStep, ForLoopLimit;

        //
        // Handle the loop for of the FOR statement, where the set
        // is described by a starting number and step value (+ or -)
        // and an end number
        //
        // FOR /L %i in (start,step,end) do
        //
        argtoks = TokStr(pForNode->arglist, NULL, TS_NOFLAGS);
        ForLoopValue = _tcstol( argtoks, NULL, 0 );
        argtoklen = mystrlen( argtoks );
        argtoks += argtoklen+1;
        ForLoopStep = _tcstol( argtoks, NULL, 0 );
        argtoklen = mystrlen( argtoks );
        argtoks += argtoklen+1;
        ForLoopLimit = _tcstol( argtoks, NULL, 0 );

        //
        // We have the three numbers, now run the body of the FOR
        // loop with each value described
        //
        datacount = 0;
        while (TRUE) {
            //
            // If step is negative, go until loop value is less
            // than limit.  Otherwise go until it is greater than
            // limit.
            //
            if (ForLoopStep < 0) {
                if (ForLoopValue < ForLoopLimit)
                    break;
            } else {
                if (ForLoopValue > ForLoopLimit)
                    break;
            }

            FvarRestore();
            DEBUG((BPGRP, FOLVL, "FOR: element %d = `%ws'",i ,argtoks));
            CheckCtrlC();

            //
            // Convert the loop value to text and set the value of the loop
            // variable
            //
            _sntprintf(ForLoopBuffer, 32, TEXT("%d"), ForLoopValue);
            Fsubs[i] = ForLoopBuffer;

            //
            // Run the body of the FOR Loop
            //
            forretcode = FWork(pForNode->body,bFirstLoop);
            datacount = ForFree(datacount);
            bFirstLoop = FALSE;

            //
            // Step to next value
            //
            ForLoopValue += ForLoopStep;
        }
    } else
        if (pForNode->flag & FOR_MATCH_PARSE) {
        //
        // Handle the new parse form of the FOR loop
        //
        //  FOR /F "parameters" %i in (filelist) do ...
        //  FOR /F "parameters" %i in (`command to execute`) do ...
        //  FOR /F "parameters" %i in ('literal string') do ...
        //

        forretcode = FParseWork(pForNode,
                                i,
                                TRUE
                               );
    } else
        if (pForNode->flag & FOR_MATCH_RECURSE) {
        TCHAR pathbuf[MAX_PATH];
        TCHAR *filepart;
        TCHAR *p;
        DWORD Length;

        //
        // Handle the new recurse form of the FOR loop
        //
        //  FOR /R directory %i in (filespecs) do ...
        //
        // Where directory is an optional directory path of where to start
        // walking the directory tree.  Default is the current directory.
        // filespecs is one or more file name specifications, wildcards
        // allowed.
        //

        //
        // Get the full path of the directory to start walking, defaulting
        // to the current directory.
        //

        p = StripQuotes( pForNode->recurseDir ? pForNode->recurseDir : TEXT(".\\"));

        Length = GetFullPathName( p, MAX_PATH, pathbuf, &filepart );
        if (Length == 0 || Length >= MAX_PATH ) {
            PutStdErr( MSG_FULL_PATH_TOO_LONG, ONEARG, p );
            forretcode = FAILURE;
        } else {

            if (filepart == NULL) {
                filepart = lastc(pathbuf);
                if (*filepart != BSLASH) {
                    *++filepart = BSLASH;
                }
                *++filepart = NULLC;
            } else {
                //
                //  A directory is present.  Append a path sep
                //

                mystrcat( pathbuf, TEXT( "\\" ));
                filepart = lastc( pathbuf ) + 1;
            }

            //
            // Tokenize the list of file specifications
            //
            argtoks = TokStr(pForNode->arglist, NULL, TS_NOFLAGS);

            //
            // Do the work
            //
            forretcode = FRecurseWork(pathbuf, filepart, pForNode, fsinfo, i, argtoks);
        }
    } else {
        //
        // If none of the new flags specified, then old style FOR statement
        // Tokenize the elements of the set and loop over them
        //
        argtoks = TokStr(pForNode->arglist, NULL, TS_NOFLAGS);
        DEBUG((BPGRP, FOLVL, "FOR: initial argtok = `%ws'", argtoks));
        forretcode = FLoopWork(pForNode, fsinfo, i, argtoks, TRUE);
        DEBUG((BPGRP, FOLVL, "FOR: Exiting."));
    }

    //
    // All done, deallocate the FOR variable
    //
    if (i) {
        if (Fvars || (*Fvars)) {
            *(Fvars+mystrlen(Fvars)-1) = NULLC;
        }
        Fsubs[i] = NULL;
    } else {
        Fvars = NULL;
        Fsubs = NULL;
    }
    return(forretcode);
}


/***    FRecurseWork - controls the execution of a For loop with the /R option
 *
 *  Purpose:
 *      Execute a FOR loop statement for recursive walk of a directory tree
 *
 *  FRecurseWork(TCHAR *path, TCHAR *filepart,
 *               struct fornode *pForNode, PCPYINFOfsinfo,
 *               int i, TCHAR *argtoks)
 *
 *  Args:
 *      path - full path of directory to start recursing down
 *      filepart - tail portion of full path where file name portion is
 *      pForNode - pointer to the FOR parse tree node
 *      fsinfo - work buffer for expanding file specification wildcards
 *      i - FOR variable index in Fvars and Fsubs arrays
 *      argtoks - the tokenized data set to loop over.  This set is presumed
 *                to be file names with possible wild cards.  This set is
 *                evaluated for each directory seen by the recusive walk of the
 *                the directory tree.  So FOR /R "." %i in (*.c *.h) do echo %i
 *                would echo all the .c and .h files in a directory tree
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FRecurseWork(
            TCHAR *path,
            TCHAR *filepart,
            struct fornode *pForNode,
            PCPYINFO fsinfo,
            int i,
            TCHAR *argtoks
            )
{
    WIN32_FIND_DATA buf;           /* Buffer for find first/next    */
    HANDLE hnFirst;                        /* handle from ffirst()            */
    int forretcode = FORERROR;
    int npfxlen, ntoks;
    TCHAR *s1;
    TCHAR *s2;
    TCHAR *tmpargtoks;

    //
    // Calculate the length of the path and find the end of the
    // tokenized data set and the number of tokens in the set.
    //
    npfxlen = _tcslen(path);
    ntoks = 0;
    s1 = argtoks;
    while (*s1) {
        ntoks += 1;
        while (*s1++) {
            NOTHING;
        }
    }

    //
    // Now allocate space for a copy of the tokenized data set with room to prefix
    // each element of the set with the path string.  Construct the copy of the set
    //
    tmpargtoks = mkstr( ntoks * ((npfxlen + ((int)(s1 - argtoks) + 1)) * sizeof(TCHAR)) );
    if (tmpargtoks == NULL) {
        PutStdErr(MSG_NO_MEMORY, NOARGS );
        return FAILURE;
    }
    s1 = argtoks;
    s2 = tmpargtoks;
    while (*s1) {
        _tcsncpy(s2, path, npfxlen);
        _tcscpy(s2+npfxlen, s1);
        s2 += npfxlen;
        while (*s1++)
            s2 += 1;
        s2 += 1;
    }
    *s2++ = NULLC;

    //
    // Now run the body of the FOR loop with the new data set, then free it.
    //
    forretcode = FLoopWork(pForNode, fsinfo, i, tmpargtoks, TRUE);

    //
    // Now find any subdirectories in path and recurse on them
    //
    filepart[0] = STAR;
    filepart[1] = NULLC;
    hnFirst = FindFirstFile( path, &buf );
    filepart[0] = NULLC;
    if (hnFirst != INVALID_HANDLE_VALUE) {
        do {
            _tcscpy(filepart, buf.cFileName);
            if (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                _tcscmp(buf.cFileName, TEXT(".")) &&
                _tcscmp(buf.cFileName, TEXT(".."))) {

                s1 = lastc(filepart);
                *++s1 = BSLASH;
                *++s1 = NULLC;
                forretcode = FRecurseWork(path, s1, pForNode, fsinfo, i, argtoks);
            }

        } while (FindNextFile( hnFirst, &buf ));
        FindClose(hnFirst);
    }

    return(forretcode);
}

/***    FParseWork - controls the execution of a For loop with the /F option
 *
 *  Purpose:
 *      Execute a FOR loop statement for parsing the contents of a file
 *
 *  FParseWork(struct fornode *pForNode, PCPYINFOfsinfo,
 *             int i, TCHAR *argtoks, BOOL bFirstLoop)
 *
 *  Args:
 *      pForNode - pointer to the FOR parse tree node
 *      i - FOR variable index in Fvars and Fsubs arrays
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FParseWork(
          struct fornode *pForNode,
          int i,
          BOOL bFirstLoop
          )
{
    HANDLE hFile;                  /* handle from ffirst()            */
    DWORD dwFileSize, dwBytesRead;
    int datacount;                 /* Elts on data stack not to free  */
    int argtoklen;
    int forretcode = FORERROR;
    TCHAR *argtoks;
    TCHAR *s1;
    TCHAR *s2;
    TCHAR *sToken;
    TCHAR *sEnd;
    TCHAR *tmpargtoks = NULL;
    TCHAR eol=TEXT(';');
    TCHAR quoteChar;
    TCHAR *delims;
    TCHAR chCmdLine, chLiteralString;
    int nVars;
    int nSkip;
    int nSkipSave;
    int nTok, nTokEnd, nTokBits, nTokStar;
    DWORD nTokenMask;
    BOOL bNewSemantics;

    //
    // First see if we have any parse options present.  Possible parse options are:
    //
    //  eol=c               // c is the end of line comment character
    //  delims=cccc         // cccc specifies one or more delimeter characters
    //  skip=n              // n specifies how many lines at the begin of each file
    //                      // to skip (defaults to zero).
    //  tokens=m,n-o        // m is a token number to pass to the body of the FOR loop
    //                      // n-o is a range of token numbers to pass. (defaults
    //                      // to tokens=1
    //  usebackq            // If present, allows new back quotes for command line,
    //                      // single quote for literal strings, which frees up double
    //                      // quotes for quoting file names
    //
    //

    delims = (TCHAR *) gmkstr( (_tcslen( DEFAULT_DELIMS ) + 1) * sizeof( TCHAR ) );
    mystrcpy( delims, DEFAULT_DELIMS );

    nSkip = 0;
    nVars = 1;
    nTokenMask = 1;
    nTokStar = 0;
    bNewSemantics = FALSE;
    if (pForNode->parseOpts) {
        s1 = pForNode->parseOpts;
        if (*s1 == QUOTE || *s1 == TEXT('\'')) {
            quoteChar = *s1++;
        } else {
            quoteChar = NULLC;
        }
        nTokBits = 1;
        while (s1 && *s1) {
            while (*s1 && *s1 <= SPACE)
                s1 += 1;

            if (*s1 == quoteChar)
                break;

            if (!_tcsnicmp(s1, TEXT("usebackq"), 8)) {
                bNewSemantics = TRUE;
                s1 += 8;
            } else
                if (!_tcsnicmp(s1, TEXT("useback"), 7)) {
                bNewSemantics = TRUE;
                s1 += 7;
            } else
                if (!_tcsnicmp(s1, TEXT("eol="), 4)) {
                eol=s1[4];
                s1 += 5;
            } else
                if (!_tcsnicmp(s1, TEXT("delims="), 7)) {
                s1 += 7;
                s2 = s1;

                //
                //  Advance to the next space or end of string
                //

                while (*s1 && *s1 != quoteChar) {
                    if (*s1 == SPACE && s1[1] != quoteChar)
                        break;
                    else
                        s1 += 1;
                }

                //
                //  New delimiter characters
                //

                FreeStr( delims );
                delims = (TCHAR *) gmkstr( ((int)(s1 - s2) + 1) * sizeof( TCHAR ));

                _tcsncpy(delims, s2, (UINT)(s1-s2));
                delims[s1-s2] = NULLC;

                if (*s1)
                    s1 += 1;
            } else
                if (!_tcsnicmp(s1, TEXT("skip="), 5)) {
                s1 += 5;
                nSkip = _tcstol(s1, &s1, 0);
                if (nSkip <= 0)
                    goto badtokens;
            } else
                if (!_tcsnicmp(s1, TEXT("tokens="), 7)) {
                s1 += 7;
                nTokenMask = 0;
                nTokBits = 0;
                while (*s1 && *s1 != quoteChar) {
                    if (*s1 == STAR) {
                        s1 += 1;
                        nTokBits += 1;
                        nTokStar = nTokBits;
                        break;
                    }

                    nTok = _tcstol(s1, &s1, 0);
                    if (nTok <= 0)
                        goto badtokens;

                    if (*s1 == MINUS) {
                        nTokEnd = _tcstol(s1+1, &s1, 0);
                        if (nTokEnd <= 0)
                            goto badtokens;
                    } else
                        nTokEnd = nTok;

                    if (nTok > 0 && nTokEnd < 32)
                        while (nTok <= nTokEnd) {
                            nTokBits += 1;
                            nTokenMask |= 1 << (nTok - 1);
                            nTok += 1;
                        }

                    if (*s1 == COMMA)
                        s1 += 1;
                    else
                        if (*s1 != STAR)
                        break;
                }

                if (nTokBits > nVars)
                    nVars = nTokBits;
            } else {
                badtokens:
                PutStdErr(MSG_SYNERR_GENL,ONEARG,s1);
                return(FAILURE);
            }
        }

        //
        // If user specified more than one token then we need to allocate
        // additional FOR variable names to pass them to the body of the
        // FOR loop.  The variables names are the next nVars-1 letters after
        // the one the user specified in the FOR statement.  So if they specified
        // %i as the variable name and requested 3 tokens, then %j and %k would
        // be allocated here.
        //
        if (nVars > 1) {
            Fvars = (TCHAR*)resize(Fvars,(i+nVars)*sizeof(TCHAR) );
            Fsubs = (TCHAR **)resize(Fsubs,(i+nVars)*sizeof(TCHAR *) );

            if (Fvars == NULL || Fsubs == NULL) {
                PutStdErr(MSG_NO_MEMORY, NOARGS );
                Abort( );
            }

            for (nTok=1; nTok<nVars; nTok++) {
                Fvars[i+nTok] = (TCHAR)(pForNode->forvar+nTok);
                Fsubs[i+nTok] = NULL;
            }
            Fvars[i+nTok] = NULLC;
        }
    }

    //
    // Parse string between parenthesis.  Only parse it if present and
    // not either the Command Line or Literal String mode
    //
    argtoks = pForNode->arglist;
    if (bNewSemantics) {
        chCmdLine = TEXT('`');
        chLiteralString = TEXT('\'');
    } else {
        chCmdLine = TEXT('\'');
        chLiteralString = QUOTE;
    }

    if (!argtoks || (*argtoks != chCmdLine && *argtoks != chLiteralString))
        //
        // If not the command line form, then tokenize the set of file names
        //
        argtoks = TokStr(argtoks, NULL, TS_NOFLAGS);


    // Now loop over the set of files, opening and parsing each one.
    //
    nSkipSave = nSkip;
    for (datacount = 0; *argtoks && !GotoFlag; argtoks += argtoklen+1) {
        FvarRestore();
        CheckCtrlC();
        s1 = sEnd = NULL;
        tmpargtoks = NULL;
        nSkip = nSkipSave;
        argtoklen = mystrlen( argtoks );
        if (*argtoks == chCmdLine && argtoklen > 1 && argtoks[argtoklen-1] == chCmdLine) {
            FILE *pChildOutput;
            char *spBegin;
            size_t cbUsed, cbTotal;

            //
            //  If the file name is a quoted string, with single quotes, then it is a command
            //  line to execute.  So strip off the quotes. Note that the for() loop expects
            //  there to be a double NUL at the end.  However, we DON'T have such a thing here
            //  since we never called TokStr.  We fake this by putting in a NUL to terminate
            //  the command line and then lie about the length
            //

            argtoks += 1;
            argtoklen -= 2;
            argtoks[argtoklen] = NULLC;

            //
            // Execute the command line, getting a handle to its standard output
            // stream.
            //

            pChildOutput = _tpopen( argtoks, TEXT( "rb" ));
            if (pChildOutput == NULL) {
                PutStdErr(MSG_DIR_BAD_COMMAND_OR_FILE, ONEARG, argtoks);
                return(GetLastError());
            }

            //
            // Now read the standard output stream, collecting it into allocated
            // memory so we can parse it when the command finishes.  Read until
            // we hit EOF or an error on the child output handle.
            //
            cbUsed = cbTotal = 0;
            spBegin = NULL;
            while (!feof(pChildOutput) && !ferror(pChildOutput)) {
                if ((cbTotal-cbUsed) < 512) {
                    cbTotal += 256;
                    if (spBegin)
                        spBegin = resize(spBegin, cbTotal);
                    else
                        spBegin = mkstr(cbTotal);
                    if (spBegin == NULL) {
                        PutStdErr(MSG_NO_MEMORY, ONEARG, argtoks);
                        _pclose(pChildOutput);
                        return(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                spBegin[cbUsed] = TEXT( '\0' );
                if (!fgets(spBegin+cbUsed, (int)(cbTotal-cbUsed), pChildOutput))
                    break;

                cbUsed = strlen(spBegin);
            }
            //
            // All done.  Close the child output handle, which will actually wait
            // for the child process to terminate.
            //
            _pclose(pChildOutput);

            //
            // Reallocate memory to what we actually need for the UNICODE representation
            //
            spBegin = resize(spBegin, (cbUsed+2) * sizeof(TCHAR));
            if (Fvars == NULL || Fsubs == NULL) {
                PutStdErr(MSG_NO_MEMORY, ONEARG, argtoks);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            //
            // Move the ANSI data to the second half of the buffer so we can convert it
            // to UNICODE
            //
            memmove(spBegin+cbUsed, spBegin, cbUsed);
            tmpargtoks = (TCHAR *)spBegin;
            dwFileSize = dwBytesRead = cbUsed;

            //
            // No go treat the in memory buffer we have created as if it were a
            // file read in from disk.
            //
            goto gotfileinmemory;
        
        } else if (*argtoks == chLiteralString 
                   && argtoklen > 1 
                   && argtoks[argtoklen-1] == chLiteralString) {
            //
            // If the file name is a literal string then it is an immediate
            // string to be parsed.  Fake things up for the parsing logic
            // and fall through to it.
            //
            
            argtoks[argtoklen - 1] = NLN;
            
            argtoks += 1;
            argtoklen -= 2;
            s1 = argtoks;
            sEnd = s1 + argtoklen + 1;
          
        } else {
            if (*argtoks == QUOTE) {
                argtoks += 1;
                argtoklen -= 1;
                s1 = lastc(argtoks);
                if (*s1 == QUOTE) {
                    do {
                        *s1-- = NULLC;
                    }
                    while (s1 >= argtoks && *s1 == SPACE);
                }
            }

            //
            // We have an actual file name to try to open and read.  So do it
            //
            hFile = CreateFile( argtoks,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_DELETE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                              );
            if (hFile == INVALID_HANDLE_VALUE) {
                PutStdErr(MSG_CMD_FILE_NOT_FOUND, ONEARG, argtoks);
                return GetLastError();
            } else {
                BOOL b;
                dwFileSize = SetFilePointer(hFile, 0, NULL, FILE_END);
                SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                tmpargtoks = mkstr((dwFileSize+2) * sizeof( TCHAR ));
                if (tmpargtoks == NULL) {
                    PutStdErr(MSG_NO_MEMORY, ONEARG, argtoks);
                    CloseHandle( hFile );
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                dwBytesRead = 0xFFFFFFFF;
                b = ReadFile( hFile,
#ifdef UNICODE
                              (LPSTR)tmpargtoks+dwFileSize,
#else
                              tmpargtoks,
#endif
                              dwFileSize,
                              &dwBytesRead,
                              NULL
                            );
                CloseHandle(hFile);
                if (!b) {
                    dwBytesRead = 0;
                }
gotfileinmemory:
                if (dwBytesRead == dwFileSize) {
                    //
                    // Successfully opened and read the data.  Convert it to UNICODE
                    // and setup the variables for the parsing loop
                    //
#ifdef UNICODE
#ifdef FE_SB
                    dwFileSize =
#endif
                    MultiByteToWideChar(CurrentCP,
                                        MB_PRECOMPOSED,
                                        (LPSTR)tmpargtoks+dwFileSize,
                                        dwFileSize,
                                        tmpargtoks,
                                        dwFileSize);
#endif
                    s1 = tmpargtoks;
                    sEnd = s1 + dwFileSize;
                    if (sEnd == s1 || sEnd[-1] != NLN)
                        *sEnd++ = NLN;
                    *sEnd = NULLC;
                }
            }
        }

        //
        // This is the parsing loop
        //
        //  s1 points to next character.
        //  sEnd points just after the last valid character to parse
        //
        // Loop isolates next line in input buffer, parse that line,
        // Passes any tokens from the line to body of the FOR loop and
        // then loops.
        //
        while (s1 < sEnd && !GotoFlag) {
            CheckCtrlC();

            //
            // Not past the end of the buffer.  Find the next
            // newline
            //
            s1 = _tcschr(s2=s1, NLN);

            //
            // If no newline, then done parsing
            //
            if (s1 == NULL)
                break;

            //
            // If CRLF, nuke the CR and the LF
            //
            if (s1 > s2 && s1[-1] == CR)
                s1[-1] = NULLC;
            *s1++ = NULLC;

            //
            // Done skipping input lines?
            //
            if (!nSkip) {
                //
                // Yes, parse this line
                //
                for (nTok=1; nTok<nVars; nTok++) {
                    Fsubs[i+nTok] = NULL;
                }
                nTok = 0;
                nTokBits = 0;

                //
                // Null is the end of line marker now
                //
                while (*s2) {
                    //
                    // Skip any leading delimeters
                    //

                    while (*s2 && _tcschr(delims, *s2) != NULL)
                        s2++;

                    //
                    // If first character is eol comment character than
                    // skip this line
                    //
                    if (nTok == 0 && *s2==eol)
                        break;

                    //
                    // Remember start of token
                    //
                    sToken = s2;

                    if (nTokStar != 0 && (nTokBits+1) == nTokStar) {
                        Fsubs[i+nTokBits] = sToken;
                        nTokBits += 1;
                        break;
                    }

                    //
                    // Find the end of the token
                    //
                    while (*s2 && !_tcschr(delims, *s2))
                        s2 += 1;
                    
                    //
                    // If we got a token, and it is not more than we can
                    // handle, then see if they want this token.  If so,
                    // set the value of the appropriate FOR variable
                    //
                    
                    if (sToken != s2 && nTok < 32) {
                        if ((nTokenMask & (1 << nTok++)) != 0) {
                            Fsubs[i+nTokBits] = sToken;
                            nTokBits += 1;
                        }
                    }
                    
                    //
                    //  If we're not at the end of the string, terminate this
                    //  token and advance
                    //
                    
                    if (*s2 != NULLC) {
                        *s2++ = NULLC;
                    }

                }
                
                //
                // If we set any FOR variables, then run the body of the FOR loop
                //
                
               if (nTokBits) {
                    forretcode = FWork(pForNode->body,bFirstLoop);
                    datacount = ForFree(datacount);
                    bFirstLoop = FALSE;
                }
            } else
                nSkip -= 1;
        }

        //
        // If we allocated memory for the output of the command line, free it up
        //
        if (tmpargtoks != NULL) {
            FreeStr( tmpargtoks );
            tmpargtoks = NULL;
        }
    }

    //
    // If we used any additonal FOR variables, clear them here as we are done with them,
    //
    if (nVars > 1 && Fvars && (*Fvars)) {
        Fvars[i+1] = NULLC;
        Fsubs[i+1] = NULL;
    }
    return(forretcode);
}

/***    FLoopWork - controls the execution of a For loop
 *
 *  Purpose:
 *      Execute a FOR loop statement for a given set
 *
 *  FLoopWork(struct fornode *pForNode, PCPYINFOfsinfo, int i, TCHAR *argtoks, BOOL bFirstLoop
 *
 *  Args:
 *      pForNode - pointer to the FOR parse tree node
 *      fsinfo - work buffer for expanding file specification wildcards
 *      i - FOR variable index in Fvars and Fsubs arrays
 *      argtoks - the tokenized data set to loop over
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FLoopWork(
         struct fornode *pForNode,
         PCPYINFO fsinfo,
         int i,
         TCHAR *argtoks,
         BOOL bFirstLoop
         )
{
    TCHAR *forexpname;             /* Used to hold expanded fspec     */
    WIN32_FIND_DATA buf;           /* Buffer for find first/next    */
    HANDLE hnFirst;                        /* handle from ffirst()            */
    int datacount;                 /* Elts on data stack not to free  */
    int forretcode = SUCCESS;
    int catspot;                   /* Add fnames to forexpname here   */
    int argtoklen;
    DWORD forexpnamelen;
    DWORD dwMatchAttributes;

    //
    // Loop, processing each string in the argtoks set
    //
    for (datacount = 0; *argtoks && !GotoFlag; argtoks += argtoklen+1) {
        FvarRestore();
        DEBUG((BPGRP, FOLVL, "FOR: element %d = `%ws'",i ,argtoks));
        CheckCtrlC();

        //
        // Save the length of next string in set so we can skip over it
        //
        argtoklen = mystrlen( argtoks );
        if (!(mystrchr(argtoks, STAR) || mystrchr(argtoks, QMARK))) {
            //
            // String contains no wildcard characters, so set the value of
            // the FOR variable to the string and evaluate the body of the
            // FOR loop
            //
            Fsubs[i] = argtoks;
            forretcode = FWork(pForNode->body,bFirstLoop);
            datacount = ForFree(datacount);
            bFirstLoop = FALSE;
        } else {                /* Else, expand wildcards          */
            forexpnamelen = 0;
            forexpname = NULL;
            //
            // String contains file specification wildcard characters.
            // Expand the reference into one or more file or directory names,
            // processing each name as a string
            //
            dwMatchAttributes = (pForNode->flag & FOR_MATCH_DIRONLY) ? A_AEVH : A_AEDVH;
            mystrcpy( argtoks, StripQuotes( argtoks ) );
            if (ffirst(argtoks, dwMatchAttributes, &buf, &hnFirst)) {
                //
                // Found at least one file.  Parse it as a file name.
                //
                fsinfo->fspec = argtoks;
                ScanFSpec(fsinfo);
                //
                // Remember where the file name portion is so we can append each
                // matching file name to create a full path.
                //
                catspot = (fsinfo->pathend) ? (int)(fsinfo->pathend-fsinfo->fspec+1) : 0;
                if (forexpnamelen < mystrlen(fsinfo->fspec)) {
                    forexpnamelen = mystrlen(fsinfo->fspec)+1;
                    if (forexpname == NULL)
                        forexpname = mkstr(forexpnamelen*sizeof(TCHAR));
                    else
                        forexpname = resize(forexpname, forexpnamelen*sizeof(TCHAR));
                }
                if (forexpname == NULL) {
                    PutStdErr( MSG_NO_MEMORY, NOARGS );
                    Abort( );
                }

                mystrcpy(forexpname, fsinfo->fspec);
                do {
                    FvarRestore();         /* @@ */

                    //
                    // Copy current file name into full path buffer
                    //
                    if (forexpnamelen < (forexpnamelen+mystrlen(buf.cFileName))) {
                        forexpnamelen += mystrlen(buf.cFileName);
                        if (forexpname == NULL)
                            forexpname = mkstr(forexpnamelen*sizeof(TCHAR));
                        else
                            forexpname = resize(forexpname, forexpnamelen*sizeof(TCHAR));

                        if (forexpname == NULL) {
                            PutStdErr( MSG_NO_MEMORY, NOARGS );
                            Abort( );
                        }
                    }
                    mystrcpy(&forexpname[catspot], buf.cFileName);

                    //
                    // See if user wants files or directories and what we have
                    // and evaluate the body of the FOR loop if we have what the
                    // user wants.  Ignore the bogus . and .. directory names
                    // returned by file systems.
                    //
                    if (!(pForNode->flag & FOR_MATCH_DIRONLY) ||
                        (buf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                         _tcscmp(buf.cFileName, TEXT(".")) &&
                         _tcscmp(buf.cFileName, TEXT("..")))) {

                        DEBUG((BPGRP, FOLVL, "FOR: forexpname = `%ws'", forexpname));
                        //
                        // User wants this file or directory name, so set
                        // the value of the FOR variable and evaluate the
                        // body of the FOR loop.
                        //
                        Fsubs[i] = forexpname;
                        forretcode = FWork(pForNode->body,bFirstLoop);
                        bFirstLoop = FALSE;
                    }

                    //
                    // Check for CtrlC and then get next matching file name
                    //
                    CheckCtrlC();
                } while (fnext(&buf, dwMatchAttributes, hnFirst) && !GotoFlag);

                datacount = ForFree(datacount);
                //
                //  No more matching files, close the find handle
                //  Even though we've completed an iteration, we may NOT be the first
                //  pass through the loop since nothing may have been enumerated
                //

                findclose(hnFirst);    /* @@4-@@M1 */
            }
        }
    }

    return(forretcode);
}

/***    FWork - controls the execution of 1 iteration of a For loop
 *
 *  Purpose:
 *      Execute a FOR loop statement.
 *
 *  FWork(struct node *n, TCHAR var, TCHAR *varval)
 *
 *  Args:
 *      n - pointer to the body of the FOR loop
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      The retcode of the last statement executed in the for body or FORERROR.
 *
 */

FWork(n,bFirstLoop)
struct node *n;
BOOL bFirstLoop;
{
    int forretcode;                /* Dispatch Retcode or FORERROR    */
    void DisplayStatement();       /* M008 - made void                */

    DEBUG((BPGRP, FOLVL, "FW: Entered; Substituting variable"));

    if (SubFor(n,bFirstLoop)) {
        return(FORERROR);
    } else {

        DEBUG((BPGRP, FOLVL, "FW: EchoFlag = %d", EchoFlag));

        if (EchoFlag == E_ON && n->type != SILTYP && !Necho) {
            PrintPrompt();
            DisplayStatement(n, DSP_SIL);          /* M019    */
            cmd_printf(CrLf);                      /* M026    */
        }
        forretcode = Dispatch(RIO_OTHER,n);    /* M000            */
    }

    DEBUG((BPGRP, FOLVL, "FW: Returning %d", forretcode));

    return(forretcode);
}




/***    SubFor - controls FOR variable substitutions
 *
 *  Purpose:
 *      To walk a parse tree and make FOR variable substitutions on
 *      individual nodes.  SFWork() is called to do individual string
 *      substitutions.
 *
 *  int SubFor(struct node *n)
 *
 *  Args:
 *      n - pointer to the statement subtree in which the substitutions are
 *          to be made
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      SUCCESS if all goes well.
 *      FAILURE if an oversized command is found.
 *
 *  Note:
 *      The variables to be substituted for are contained in Fvars and
 *      Fsubs is an array of string pointers to corresponding replacement
 *      strings.  For I/O redirection, the list contained in the node
 *      must also be walked and its filespec strings examined.
 *
 */

int SubFor(n,bFirstLoop)
struct node *n;
BOOL bFirstLoop;
{
    int j; /* Temps used to make substitutions...     */
    struct relem *io;      /* M017 - Pointer to redir list            */

    DEBUG((BPGRP, FOLVL, "SUBFOR: Entered."));

    if (!n) {

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found NULL node."));

        return(0);
    }

    switch (n->type) {
    case LFTYP:
    case CSTYP:
    case ORTYP:
    case ANDTYP:
    case PIPTYP:
    case PARTYP:
    case SILTYP:                    /* M019 - New type         */

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found operator."));

        if (SubFor(n->lhs,bFirstLoop) ||
            SubFor(n->rhs,bFirstLoop))
            return(FAILURE);

        for (j=0, io=n->rio; j < 10 && io; j++, io=io->nxt) {

            // can't pass freed io->fname
            DEBUG((BPGRP, FOLVL, "SUBFOR: s = %lx", &io->fname));
            if (SFWork(n, &io->fname, j,bFirstLoop))
                return(FAILURE);

            DEBUG((BPGRP, FOLVL, "SUBFOR: *s = `%ws'  &*s = %lx", io->fname, &io->fname));

        }
        return(SUCCESS);
/*  M017 ends   */

    case FORTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found FOR."));

        if (SFWork(n, &((struct fornode *) n)->arglist, 0,bFirstLoop))
            return(FAILURE);

        return(SubFor(((struct fornode *)n)->body,bFirstLoop));

    case IFTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found IF."));

        if (SubFor((struct node *)((struct ifnode *) n)->cond,bFirstLoop) ||
            SubFor((struct node *)((struct ifnode *) n)->ifbody,bFirstLoop))
            return(FAILURE);

        return(SubFor(((struct ifnode *)n)->elsebody,bFirstLoop));

    case NOTTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found NOT."));

        return(SubFor((struct node *)((struct cmdnode *)n)->argptr,bFirstLoop));

    case REMTYP:            /* M009 - Rem now separate type    */
    case CMDTYP:
    case CMDVERTYP:
    case ERRTYP:
    case DEFTYP:
    case EXSTYP:
    case STRTYP:
    case CMPTYP:

        DEBUG((BPGRP, FOLVL, "SUBFOR: Found command."));

        if (SFWork(n, &((struct cmdnode *)n)->cmdline, 0,bFirstLoop) ||
            SFWork(n, &((struct cmdnode *)n)->argptr, 1,bFirstLoop))
            return(FAILURE);

        for (j=2, io=n->rio; j < 12 && io; j++, io=io->nxt) {

            // can't pass freed io->fname
            DEBUG((BPGRP, FOLVL, "SUBFOR: s = %lx ", &io->fname) );
            if (SFWork(n, &io->fname, j,bFirstLoop))
                return(FAILURE);

            DEBUG((BPGRP, FOLVL, "SUBFOR: *s = `%ws'  &*s = %lx", io->fname, &io->fname));

        }
/*  M017 ends   */
        return(SUCCESS);
    }

    // If we get here we have an invalid node type.  All case entries should
    // return themselfs.
    DEBUG((BPGRP, FOLVL, "SUBFOR: Invalid Node type"));
    return(0);
}




/***    SFWork - does batch file variable substitutions
 *
 *  Purpose:
 *      Make FOR variable substitutions in a single string.  If a FOR loop
 *      substitution is being made, a pointer to the original string is
 *      saved so that it can be used for subsequent iterations.
 *
 *  SFWork(struct node *n, TCHAR **src, int index)
 *
 *  Args:
 *      n     - parse tree node containing the string being substituted
 *      src   - the string being examined
 *      index - index in save structure
 *      bFirstLoop - TRUE if first time through loop
 *
 *  Returns:
 *      SUCCESS if substitutions could be made.
 *      FAILURE if the new string is too long.
 *
 *  Notes:
 *
 */

SFWork(n, src, index, bFirstLoop)
struct node *n;
TCHAR **src;
int index;
BOOL bFirstLoop;
{
    TCHAR *dest;   /* Destination string pointer              */
    TCHAR *srcstr,          /* Source string pointer                   */
    *srcpy,            /* Copy of srcstr                          */
    *t,                /* Temp pointer                            */
    c;                /* Current character being copied          */
    int dlen;      /* Length of dest string                   */
    int sslen,              /* Length of substr                        */
    i;                 /* Work variable                           */

    DEBUG((BPGRP, FOLVL, "SFW: Entered."));

    if (*src == NULL) {

        DEBUG((BPGRP, FOLVL, "SFW: Passed null ptr, returning now."));

        return(SUCCESS);
    }

/*  If this string has been previously substituted, get the original string.
 *  Else, "*src" is the original.
 */
    if (n->save.saveptrs[index]) {
        srcpy = n->save.saveptrs[index];
        DEBUG((BPGRP, FOLVL, "SFW: Src is saved string `%ws'",srcpy));
    } else {
        if (!bFirstLoop) {
            // arg got created.  get rid of it.
            *src = NULL;
            return(SUCCESS);
        }

        srcpy = *src;
        DEBUG((BPGRP, FOLVL, "SFW: Src is passed string `%ws'",srcpy));
    }

    srcstr = srcpy;

    if (!(dest = mkstr((MAXTOKLEN+1)*sizeof(TCHAR))))
        return(FAILURE);

    DEBUG((BPGRP, FOLVL, "SFW: dest = %lx", dest));

    for (dlen = 0; (c = *srcstr++) && dlen <= MAXTOKLEN; ) {
        //
        // See if we have a percent character indicating a variable
        // reference.  If not, continue scanning.
        //
        if ( (c != PERCENT) || ( !(*srcstr)) || *srcstr == PERCENT) { /* @@4 */

            DEBUG((BPGRP, FOLVL, "  SFW: No PERCENT adding `%c'", c));

            *dest++ = c;
            dlen++;

            continue;
        }

        //
        // Found a percent character which might represent a for loop
        // variable reference.
        //
        // If extensions are enabled then use the new substitution routine
        // that supports path manipulation, etc.  If it succeeds, accept
        // its substitution.
        //
        if (fEnableExtensions && (t = MSCmdVar(NULL, srcstr, &sslen, Fvars, Fsubs))) {
            srcstr += sslen;
            sslen = mystrlen(t);    /* Calc length     */

            if (dlen+sslen > MAXTOKLEN)     /* Too long?       */
                return(FAILURE);       /* ...yes, quit    */

            mystrcpy(dest, t);
            dlen += sslen;
            dest += sslen;
            continue;
        }

        //
        // Either extensions are disabled or new code could not
        // resolve the variable references, so let the old code
        // do it.
        //
        c = *srcstr++;

        DEBUG((BPGRP, FOLVL, "  SFW: Got PERCENT next is `%c'", c));
        DEBUG((BPGRP, FOLVL, "  SFW: Fvars are `%ws' @ %lx", Fvars, Fvars));

        if (t = mystrrchr(Fvars,c)) {   /* @@4 */  /* If c is var     */
            i = (int)(t - Fvars);          /* ...make index   */

            DEBUG((BPGRP, FOLVL, "  SFW: Found @ %lx", t));
            DEBUG((BPGRP, FOLVL, "  SFW: Index is %d", i));
            DEBUG((BPGRP, FOLVL, "  SFW: Substitute is `%ws'", Fsubs[i]));
            sslen = mystrlen(Fsubs[i]);    /* Calc length     */

            if (dlen+sslen > MAXTOKLEN)     /* Too long?       */
                return(FAILURE);       /* ...yes, quit    */

            DEBUG((BPGRP, FOLVL, "  SFW: Copying to dest."));

            mystrcpy(dest, Fsubs[i]);
            dlen += sslen;
            dest += sslen;

            DEBUG((BPGRP, FOLVL, "SFW: Forsub, dest = `%ws'", dest-dlen));

        } else {

            DEBUG((BPGRP, FOLVL, "  SFW: Not a var adding PERCENT and `%c'",c));

            *dest++ = PERCENT;
            *dest++ = c;
            dlen += 2;
        }
    }

    DEBUG((BPGRP, FOLVL, "SFW: Done, dlen = %d  dest = `%ws'", dlen, dest-dlen));

    if (dlen > MAXTOKLEN) {

        DEBUG((BPGRP, FOLVL, "SFW: Error, too long."));

        return(FAILURE);
    }

    DEBUG((BPGRP, FOLVL, "SFW: Saving FOR string."));
    if (bFirstLoop) {
        n->save.saveptrs[index] = srcpy;
    }

    if (!(*src = (TCHAR*)resize(dest-dlen, (dlen+1)*sizeof(TCHAR*))))       /* Free unused spc   */
        return(FAILURE);

    DEBUG((BPGRP, FOLVL, "SFW: After resize *src = `%ws'", *src));

    return(SUCCESS);
}




/***    ForFree - controls memory freeing during For loop execution
 *
 *  Purpose:
 *      To free up space used during the execution of a for loop body as
 *      explained in the note in the comments for eFor().  If datacount
 *      is 0, this is the first time ForFree() has been called so DCount
 *      is used to get the number of elements on the data stack that must
 *      stay there for the corect execution of the loop.  If datacount is
 *      not 0, it is the number discussed above.  In this case, this number
 *      is passed to FreeStack().
 *
 *  int ForFree(int datacount)
 *
 *  Args:
 *      datacount - see above
 *
 *  Returns:
 *      Datacount
 *
 */

int ForFree(datacount)
int datacount;
{
    if (datacount)
        FreeStack(datacount);
    else
        datacount = DCount;

    return(datacount);
}




/***    eGoto - executes a Goto statement
 *
 *  Purpose:
 *      Find the label associated with the goto command and set the file
 *      position field in the current batch job structure to the position
 *      right after the label.  After the label is found, set the GotoFlag.
 *      This tells function eFor() to stop executing a for loop and it
 *      tells Dispatch() that no more commands are to be executed until
 *      the flag is reset.  This way, if the goto command is buried inside
 *      of any kind of compound statement, Command will be able to work its
 *      way out of the statement and reset I/O redirection before continuing
 *      with the statement after the label which was found.
 *
 *      If the label isn't found, an error message is printed and the
 *      current batch job is terminated by popping its structure of the
 *      stack.
 *
 *      If no batch job is in progress, this command is a nop.
 *
 *  int eGoto(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the goto command
 *
 *  Returns:
 *      SUCCESS if the label is found.
 *      FAILURE otherwise.
 *
 *  Notes:
 *      M030 - This function has been completely rewritten for speed-up
 *      of GOTO label searches.  Now uses complete 257 byte temporary
 *      buffer.
 *      M031 - Function altered to speed up GOTO's.  Optimized for
 *      forward searches and buffer increased to 512 bytes.
 *
 */

//
//  BUFFERLENGTH is the amount we read from the batch file each
//  time we fill the internal buffer
//

#define BUFFERLENGTH    512

int eGoto(n)
struct cmdnode *n;
{
    struct batdata *bdat;
    unsigned cnt;                  /* Count of bytes read from file   */
    TCHAR s[128],                    /* Ptr to search label             */
    t[128],                    /* Ptr to found label              */
    *p1,                       /* Place keeper ptr 1              */
    *p2,                       /* Place keeper ptr 2              */
    *p3;                       /* Place keeper ptr 3              */
    CRTHANDLE fh;                   /* Batch file handle               */
    int frstpass = TRUE,            /* First time through indicator    */
    gotoretcode = SUCCESS;      /* Just what it says               */
    long Backup,                    /* Rewind count for seek           */
    savepos;                  /* Save location for file pos      */
    DWORD filesize;


    DEBUG((BPGRP, OTLVL, "GOTO: CurrentBatchFile = %lx", CurrentBatchFile));

    if (!(bdat = CurrentBatchFile))
        return(FAILURE);

    //
    // If no target of goto is present, then treat it like a label-not-found
    //

    if ( n->argptr == NULL) {
        EndAllLocals(bdat);
        CurrentBatchFile = bdat->backptr;
        PutStdErr(MSG_NO_BAT_LABEL, NOARGS);

        DEBUG((BPGRP, OTLVL, "GOTO: No label to goto, returning FAILURE, CurrentBatchFile = %lx", CurrentBatchFile));
        return FAILURE;
    }

    ParseLabel( n->argptr, s, sizeof( s ) / sizeof( s[0] ), TRUE );  /* TRUE indicates source label     */

    savepos = bdat->filepos;
    if ((fh = OpenPosBat( bdat )) == BADHANDLE)
        return(FAILURE);               /* Err if can't open       */

    DEBUG((BPGRP, OTLVL, "GOTO: label = %ws", s));
    DEBUG((BPGRP, OTLVL, "GOTO: fh = %d", fh));
    filesize = GetFileSize(CRTTONT(fh), NULL);

    //
    // If extensions are enabled, see if they are using the command script
    // equivalent of return, which is GOTO :EOF.  If so, set the current
    // position to the end of file and fall through to the normal end of
    // command script logic.
    //
    p2 = EatWS(n->argptr,NULL);
    if (fEnableExtensions &&
        !_tcsnicmp( p2, GotoEofStr, 4 ) &&
        (!p2[4] || _istspace( p2[4] ))
       ) {
        bdat->filepos = filesize;
        GotoFlag = TRUE;
    } else
        for (;;) {
            CheckCtrlC();
            if (
               //
               //  If we've read beyond where we started in the file and it's the second pass
               //

               ((bdat->filepos = SetFilePointer( CRTTONT( fh ), 0, NULL, FILE_CURRENT )) >= savepos
                && !frstpass)

               //
               //  or if we couldn't read from the batch file
               //

               || ReadBufFromInput( CRTTONT( fh ), TmpBuf, BUFFERLENGTH, (LPDWORD)&cnt ) == 0

               //
               //  or if there was nothing to read in the batch file (i.e., EOF)
               //

               || cnt == 0

               //
               //  or we detected EOF some other way
               //

               || cnt == EOF

               //
               //  or if we read a NULL line ???
               //

               || TmpBuf[0] == NULLC

               //
               //  or if the label to go to is empty
               //

               || s[0] == NULLC) {

                //
                //  If we are at EOF for the first time, then seek back to the beginning of the
                //  CMD file and continue  scanning
                //

                if (cnt == 0 && frstpass) {
                    SetFilePointer( CRTTONT( fh ), 0L, NULL, FILE_BEGIN );
                    frstpass = FALSE;
                    continue;
                }

                //
                //  Terminate this batch file
                //

                EndAllLocals(bdat);
                CurrentBatchFile = bdat->backptr;
                PutStdErr(MSG_MISSING_BAT_LABEL, ONEARG, s);

                DEBUG((BPGRP, OTLVL, "GOTO: Returning FAILURE, CurrentBatchFile = %lx", CurrentBatchFile));
                gotoretcode = FAILURE;
                break;
            }

            //
            //  Make sure input line is NUL terminated
            //

            TmpBuf[cnt] = NULLC;

            DEBUG((BPGRP, OTLVL, "GOTO: Got %d bytes @ %lx", cnt, TmpBuf));

            //
            //  If there's no :, then we just skip off to the next block of input
            //

            if (!(p1 = mystrchr( TmpBuf, COLON )))
                continue;

            DEBUG((BPGRP, OTLVL, "GOTO: Seeking through the buffer"));

            //
            //  Walk through the input buffer looking for end-of-lines and
            //  testing to see if there's a label next
            //

            do {

                DEBUG((BPGRP, OTLVL, "GOTO: Found COLON @ %lx.",p1));
                DEBUG((BPGRP, OTLVL, "GOTO: Backing up to NLN."));

                //
                //  Back up to the position of the previous EOL or beginning
                //  of the buffer
                //

                p2 = p1++;
                while (*p2 != NLN && p2 != &TmpBuf[0]) {
                    --p2;
                }

                DEBUG((BPGRP, OTLVL, "GOTO: Found NLN @ %lx.",p1));
                DEBUG((BPGRP, OTLVL, "GOTO: Trashing white space."));

                if (*p2 != COLON)
                    ++p2;
                p3 = EatWS(p2,NULL);   /* Fwd to 1st non-whtspc   */

                DEBUG((BPGRP,OTLVL,"GOTO: Found '%c' @ %lx.",*p2,p2));

                if (*p3 == COLON) {

                    DEBUG((BPGRP, OTLVL, "GOTO: Possible label."));

                    //
                    //  Scan forward for the end of the current line
                    //

                    p1 = mystrchr( p2, NLN );

                    //
                    //  If we don't have a newline and we haven't read up to EOF, then we need to
                    //  back up to the beginning of the line in the file and attempt to read it in
                    //  in one entire block.  Of course, there's a problem if the line is longer
                    //  than the buffer.  In this case, we simply treat the longer chars as being
                    //  in the next line.  Tough.
                    //

                    if (p1 == NULL
                        && SetFilePointer( CRTTONT( fh ), 0, NULL, FILE_CURRENT ) != filesize
                        && cnt != BUFFERLENGTH ) {

                        DEBUG((BPGRP, OTLVL, "GOTO: No NLN!"));

                        Backup = (long)(cnt - (p2 - &TmpBuf[0]));
#if defined(FE_SB) && defined(UNICODE) // eGoto()
                        if (IsDBCSCodePage()) {
                            // We should decrement file pointer in MBCS byte count.
                            // Because the file is described by MBCS string.
                            Backup = WideCharToMultiByte( CurrentCP, 0, TmpBuf, Backup, NULL, 0, NULL, NULL);
                        }
#endif // defined(FE_SB) && defined(UNICODE)
                        SetFilePointer(CRTTONT(fh), -Backup, NULL, FILE_CURRENT);

                        DEBUG((BPGRP, OTLVL, "GOTO: Rewound %ld", Backup));
                        break;         /* Read more       */
                    }

                    ParseLabel( p3, t, sizeof( t ) / sizeof( t[0] ), FALSE ); /* FALSE = target  */

                    DEBUG((BPGRP,OTLVL,"GOTO: Found label %ws at %lx.",t,p1));
                    if (_tcsicmp(s, t) == 0) {

                        DEBUG((BPGRP,OTLVL,"GOTO: A match!"));

                        GotoFlag = (n->flag & CMDNODE_FLAG_GOTO) != 0;

                        DEBUG((BPGRP,OTLVL,"GOTO: NLN at %lx",p1));
                        DEBUG((BPGRP,OTLVL,"GOTO: File pos is %04lx",bdat->filepos));
                        DEBUG((BPGRP,OTLVL,"GOTO: Adding %lx - %lx = %lx bytes",p1+1,&TmpBuf[0],(p1+1)-&TmpBuf[0]));

#if defined(FE_SB) // eGoto()
                        // We should increment file pointer in MBCS byte count.
                        // Because the file is described by MBCS string.
                        if ( !p1 ) {
#ifdef UNICODE
                            if (IsDBCSCodePage()) {
                                long cbMbcs;
                                cbMbcs = WideCharToMultiByte( CurrentCP, 0, TmpBuf, cnt,
                                                              NULL, 0, NULL, NULL);
                                bdat->filepos += cbMbcs;
                            } else
                                bdat->filepos += (long)cnt; /* @@4 */
#else
                            bdat->filepos += (long)cnt; /* @@4 */
#endif
                        } else {
#ifdef UNICODE
                            if (IsDBCSCodePage()) {
                                long cbMbcs;
                                cbMbcs = WideCharToMultiByte(CurrentCP,0,TmpBuf,(int)(++p1 - &TmpBuf[0]),
                                                             NULL,0,NULL,NULL);
                                bdat->filepos += cbMbcs;
                            } else
                                bdat->filepos += (long)(++p1 - &TmpBuf[0]);
#else
                            bdat->filepos += (long)(++p1 - &TmpBuf[0]);
#endif
                        }
#else
                        if ( !p1 ) { /* @@4 */
                            bdat->filepos += (long)cnt; /* @@4 */
                        } else {  /* @@4 */
                            bdat->filepos += (long)(++p1 - &TmpBuf[0]);
                        }
#endif // defined(FE_SB)
                        DEBUG((BPGRP,OTLVL,"GOTO: File pos changed to %04lx",bdat->filepos));
                        break;
                    }
                }

                DEBUG((BPGRP,OTLVL,"GOTO: Next do loop iteration."));

            } while (p1 = mystrchr(p1,COLON));

            DEBUG((BPGRP,OTLVL,"GOTO: Out of do loop GotoFlag = %d.",GotoFlag));

            if (GotoFlag == TRUE)
                break;

            DEBUG((BPGRP,OTLVL,"GOTO: Next for loop iteration."));

        }

    DEBUG((BPGRP,OTLVL,"GOTO: Out of for loop retcode = %d.",gotoretcode));

    Cclose(fh);                    /* M023 */
    return(gotoretcode);
}




/***    eIf - controls the execution of an If statement
 *
 *  Purpose:
 *      Execute the IF conditional.  If the conditional function returns a
 *      nonzero value, execute the body of the if statement.  Otherwise,
 *      execute the body of the else.
 *
 *  int eIf(struct ifnode *n)
 *
 *  Args:
 *      n - the node containing the if statement
 *
 *  Returns:
 *      The retcode from which ever body (ifbody or elsebody) is executed.
 *
 */

int eIf(struct ifnode *pIfNode)
{

    int     i;
    struct cmdnode *n;
    BOOLEAN bNot;

    DEBUG((BPGRP, IFLVL, "IF: cond type = %d", pIfNode->cond->type));

    /*  The following checks the syntax of an errorlevel arg
        to ensure that only numeric digits are specified.
    */
    n = pIfNode->cond;
    if (n->type == NOTTYP) {
        bNot = TRUE;
        n = (struct cmdnode *)n->argptr;
    } else {
        bNot = FALSE;
    }

    if (n->type == ERRTYP || n->type == CMDVERTYP) {
        for (i = 0; n->argptr[i] != 0; i++) {
            if (i == 0 && n->type == ERRTYP && n->argptr[i] == MINUS) {
                continue;
            }

            if (!_istdigit(n->argptr[i])) {
                PutStdErr(MSG_SYNERR_GENL, ONEARG, n->argptr);
                return(FAILURE);
            }
        }
    }

    if (bNot ^ (BOOLEAN)((*GetFuncPtr(n->type))(n) != 0)) {

        DEBUG((BPGRP, IFLVL, "IF: Executing IF body."));

        return(Dispatch(RIO_OTHER,pIfNode->ifbody)); /* M000      */

    } else {

        DEBUG((BPGRP, IFLVL, "IF: Executing ELSE body."));

        return(Dispatch(RIO_OTHER,pIfNode->elsebody)); /* M000    */
    }

    return(SUCCESS);
}




/***    eErrorLevel - executes an errrorlevel If conditional
 *
 *  Purpose:
 *      If LastRetCode >= the errorlevel in the node, return 1.  If not,
 *      return 0.
 *
 *  int eErrorLevel(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the errorlevel command
 *
 *  Returns:
 *      See above.
 *
 */

int eErrorLevel(n)
struct cmdnode *n;
{
    DEBUG((BPGRP, IFLVL, "ERRORLEVEL: argptr = `%ws'  LRC = %d", n->argptr, LastRetCode));

    return(_tcstol(n->argptr, NULL, 10) <= LastRetCode);
}



/***    eCmdExtVer - executes an CMDEXTVERSION If conditional
 *
 *  Purpose:
 *      If CMDEXTVERSION >= the value in the node, return 1.  If not,
 *      return 0.  This routine is never called unless command extensions
 *      are enabled.
 *
 *  int eCmdExtVer(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the CMDEXTVERSION command
 *
 *  Returns:
 *      See above.
 *
 */

int eCmdExtVer(n)
struct cmdnode *n;
{
    DEBUG((BPGRP, IFLVL, "CMDEXTVERSION: argptr = `%ws'  VER = %d", n->argptr, CMDEXTVERSION));

    return(_tcstol(n->argptr, NULL, 10) <= CMDEXTVERSION);
}



/***    eDefined - execute the DEFINED conditional of an if statement
 *
 *  Purpose:
 *      Return 1 if the environment variable in node n exists.  Otherwise return 0.
 *      This routine is never called unless command extensions are enabled.
 *
 *  int eDefined(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the exist command
 *
 *  Returns:
 *      See above.
 *
 */

int eDefined(n)
struct cmdnode *n;
{
    return(GetEnvVar(n->argptr)!= NULL);
}



/***    eExist - execute the exist conditional of an if statement
 *
 *  Purpose:
 *      Return 1 if the file in node n exists.  Otherwise return 0.
 *
 *  int eExist(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the exist command
 *
 *  Returns:
 *      See above.
 *
 */

int eExist(n)
struct cmdnode *n;
{
    return(exists(n->argptr));
}




/***    eNot - execute the not condition of an if statement
 *
 *  Purpose:
 *      Return the negated result of the if conditional pointed to by
 *      n->argptr.
 *
 *  int eNot(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the not command
 *
 *  Returns:
 *      See above.
 *
 */

int eNot(n)
struct cmdnode *n;
{
    UNREFERENCED_PARAMETER( n );
#if DBG
    cmd_printf( TEXT("CMD: should never get here\n") );
    DebugBreak();
#endif
    return 0;
}




/***    eStrCmp - execute an if statement string comparison
 *
 *  Purpose:
 *      Return a nonzero value if the 2 strings in the node are equal.
 *      Otherwise return 0.
 *
 *  int eStrCmp(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the string comparison command
 *
 *  Returns:
 *      See above.
 *
 */

int eStrCmp(n)
struct cmdnode *n;
{
    DEBUG((BPGRP, IFLVL, "STRCMP: returning %d", !_tcscmp(n->cmdline, n->argptr)));

    //
    // If the parse node says to ignore case, do a case insensitive compare
    // otherwise case sensitive.  The ignore case will never be set unless
    // command extensions are enabled.
    //
    if (n->flag & CMDNODE_FLAG_IF_IGNCASE)
        return(!lstrcmpi(n->cmdline, n->argptr));
    else
        return(!lstrcmp(n->cmdline, n->argptr));
}



/***    eGenCmp - execute an if statement comparison - general case
 *
 *  Purpose:
 *      Return a nonzero value if comparison condition is met.
 *      Otherwise return 0.  This routine is never called unless
 *      command extensions are enabled.
 *
 *  int eStrCmp(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the string comparison command
 *
 *  Returns:
 *      See above.
 *
 */

int eGenCmp(n)
struct cmdnode *n;
{
    TCHAR *s1, *s2;
    LONG n1, n2, iCompare;

    n1 = _tcstol(n->cmdline, &s1, 0);
    n2 = _tcstol(n->argptr, &s2, 0);
    if (*s1 == NULLC && *s2 == NULLC)
        iCompare = n1 - n2;
    else
        if (n->flag & CMDNODE_FLAG_IF_IGNCASE)
        iCompare = lstrcmpi(n->cmdline, n->argptr);
    else
        iCompare = lstrcmp(n->cmdline, n->argptr);

    switch (n->cmdarg) {
    case CMDNODE_ARG_IF_EQU:
        return iCompare == 0;

    case CMDNODE_ARG_IF_NEQ:
        return iCompare != 0;

    case CMDNODE_ARG_IF_LSS:
        return iCompare < 0;

    case CMDNODE_ARG_IF_LEQ:
        return iCompare <= 0;

    case CMDNODE_ARG_IF_GTR:
        return iCompare > 0;

    case CMDNODE_ARG_IF_GEQ:
        return iCompare >= 0;
    }

    return 0;
}




/***    ePause - execute the Pause command
 *
 *  Purpose:
 *      Print a message and pause until a character is typed.
 *
 *  int ePause(struct cmdnode *n)
 *
 *  Args:
 *      n - parse tree node containing the pause command
 *
 *  Returns:
 *      SUCCESS always.
 *
 *  Notes:
 *      M025 - Altered to use DOSREAD for pause response and to use
 *      new function SetKMode to insure that if STDIN is KBD, it will
 *      will be in raw mode when DOSREAD accesses it.
 *      M041 - Changed to use single byte var for input buffer.
 *           - Changed to do direct KB read if STDIN == KBD.
 *
 */

int ePause(n)
struct cmdnode *n;
{
    ULONG cnt;      // Count of response bytes
    TCHAR c;               // Retrieval buffer


    UNREFERENCED_PARAMETER( n );
    DEBUG((BPGRP, OTLVL, "PAUSE"));

    PutStdOut(MSG_STRIKE_ANY_KEY, NOARGS);

    if (FileIsDevice(STDIN) && (flgwd & 1)) {
        FlushConsoleInputBuffer( GetStdHandle(STD_INPUT_HANDLE) );
        c = (TCHAR)_getch();
        if (c == 0x3) {
            SetCtrlC();
        }
    } else {
        ReadBufFromInput(
                        GetStdHandle(STD_INPUT_HANDLE),
                        (TCHAR*)&c, 1, (LPDWORD)&cnt);
    }

    cmd_printf(CrLf);
    return(SUCCESS);
}




/***    eShift - execute the Shift command
 *
 *  Purpose:
 *      If a batch job is being executed, shift the batch job's vars one to the
 *      left.  The value for %0 is never shifted.  The value for %1 is lost.
 *      If there are args that have not been assigned to a variable, the next
 *      one is assigned to %9.  Otherwise, %9's value is NULLed.
 *
 *      If no batch job is in progress, just return.
 *
 *  int eShift(struct cmdnode *n)
 *
 *  Returns:
 *      SUCCESS always.
 *
 *  Notes:
 *      As of Modification number M004, the value of %0 is now included in
 *      in the shift command.
 */

int eShift(n)
struct cmdnode *n;
{
    struct batdata *bdat;
    TCHAR *s;
    int iStart;
    int i;

    DEBUG((BPGRP, OTLVL, "SHIFT: CurrentBatchFile = %lx", CurrentBatchFile));

    if (CurrentBatchFile) {
        bdat = CurrentBatchFile;

        //
        // If extensions are enabled, look for /n switch that specifies
        // the starting index of the shift.  Zero is the default starting
        // index.
        //
        iStart = 0;
        if (fEnableExtensions && n->argptr) {
            s = EatWS( n->argptr, NULL );
            if (s[0] == SWITCHAR && (s[1] >= L'0' && s[1] < L'9')) {
                iStart = s[1] - L'0';
            } else if (_tcslen(s)) {
                PutStdErr(MSG_SHIFT_BAD_ARG, NOARGS);
                LastRetCode = FAILURE;
                return FAILURE;
            }
        }
        for (i = iStart; i < 9; i++) {
            bdat->aptrs[i] = bdat->aptrs[i+1];
            bdat->alens[i] = bdat->alens[i+1];

            DEBUG((BPGRP, OTLVL, "SHIFT: #%d  addr = %lx  len = %d", i, bdat->aptrs[i], bdat->alens[i]));
        }

        if ((bdat->args) && (*bdat->args)) {
            bdat->aptrs[9] = bdat->args;
            bdat->alens[9] = i = mystrlen(bdat->args);
            bdat->args += i+1;

            DEBUG((BPGRP, OTLVL, "SHIFT: #9  %lx  len = %d  args = %ws", bdat->aptrs[9], bdat->alens[9], bdat->args));

        } else {
            bdat->aptrs[9] = NULL;
            bdat->alens[9] = 0;

            DEBUG((BPGRP, OTLVL, "SHIFT: #9  was NULLed."));
        }
    }

    return(SUCCESS);
}




/***    eSetlocal - Begin Local treatment of environment commands
 *
 *  Purpose:
 *      To prevent the export of environment alterations to COMMAND's
 *      current environment by saving copies of the current directory
 *      and environment in use at the time.
 *
 *  int eSetlocal(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the SETLOCAL command
 *
 *  Returns:
 *      Always returns SUCCESS.
 *
 *  Notes:
 *    - All directory and environment alterations occuring after the
 *      execution of this command will affect only the copies made and
 *      hence will be local to this batch file (and child processes
 *      invoked by this batch file) until a subsequent ENDLOCAL command
 *      is executed.
 *    - The data stack level, referenced by CurrentBatchFile->stacksize, does not
 *      include the memory malloc'd for saving the directory & environment.
 *      As a result, the next call to Parser() would free up these items.
 *      To prevent this, the data stack pointer in the current batch data
 *      structure, is set to a level beyond these two items; including also
 *      some memory malloc'd in functions between the last call to Parser()
 *      and the current execution of eSetlocal().  This memory will only be
 *      freed when Parser() is called following termination of the current
 *      batch file.  To attempt to save the current stack level and restore
 *      it in eEndlocal() works only if both commands occur in the same
 *      file.  If eEndlocal() comes in a nested file, the resulting freeing
 *      of memory by Parser() would also eliminate even the batch data
 *      structures occuring between the two.
 *
 */

int eSetlocal(n)
struct cmdnode *n;
{
    struct batsaveddata *p;
    TCHAR *tas;            /* Tokenized argument list         */

    if (CurrentBatchFile) {
        if (CurrentBatchFile->SavedEnvironmentCount < CMD_MAX_SAVED_ENV) {      // Check also CurrentBatchFile

            DEBUG((BPGRP, OTLVL, "SLOC: Performing localizing"));

            p = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( *p ));
            if (!p)
                return FAILURE;

            p->dircpy = HeapAlloc( GetProcessHeap( ),
                                   HEAP_ZERO_MEMORY,
                                   mystrlen( CurDrvDir )*sizeof( TCHAR )+sizeof( TCHAR ));
            if (!p->dircpy)
                return FAILURE;
            else
                mystrcpy(p->dircpy, CurDrvDir);

            p->envcpy = CopyEnv();
            if (!p->envcpy)
                return FAILURE;

            //
            // Save this in case it is modified, so it can be
            // restored when the matching ENDLOCAL is executed.
            //

            p->fEnableExtensions = fEnableExtensions;
            p->fDelayedExpansion = fDelayedExpansion;

            CurrentBatchFile->saveddata[CurrentBatchFile->SavedEnvironmentCount] = p;
            CurrentBatchFile->SavedEnvironmentCount += 1;

            if (CurrentBatchFile->stacksize < (CurrentBatchFile->stackmin = DCount)) {
                CurrentBatchFile->stacksize = DCount;
            }

            //
            //  If there is addional text on the command line, see
            //  if it matches various keywords that enable or disable
            //  features inside scripts.
            //
            //  We do this regardless
            //  of where extensions are currently enabled, so we can
            //  use this mechanism to temporarily turn on/off extensions
            //  from inside of a command script as needed.  The original
            //  CMD.EXE ignored any extra text on the SETLOCAL command
            //  line, did not declare an error and did not set ERRORLEVEL
            //  Now it looks for the extra text and declares and error
            //  if it does not match one of the acceptable keywords and
            //  sets ERRORLEVEL to 1 if it does not.
            //
            //  Very minor incompatibility with old command scripts that
            //  that should not effect anybody.
            //

            tas = TokStr(n->argptr, NULL, TS_NOFLAGS);
            LastRetCode = SUCCESS;

            while (*tas != NULLC) {
                if (!_tcsicmp( tas, TEXT("ENABLEEXTENSIONS"))) {
                    fEnableExtensions = TRUE;
                } else if (!_tcsicmp( tas, TEXT("DISABLEEXTENSIONS"))) {
                    fEnableExtensions = FALSE;
                } else if (!_tcsicmp( tas, TEXT( "ENABLEDELAYEDEXPANSION" ))) {
                    fDelayedExpansion = TRUE;
                } else if (!_tcsicmp( tas, TEXT( "DISABLEDELAYEDEXPANSION" ))) {
                    fDelayedExpansion = FALSE;
                } else if (*tas != NULLC) {
                    PutStdErr(MSG_SETLOCAL_BAD_ARG, NOARGS);
                    LastRetCode = FAILURE;
                    return FAILURE;
                }

                tas += mystrlen( tas ) + 1;
            }

        } else {
            PutStdErr(MSG_MAX_SETLOCAL,NOARGS);
            return FAILURE;
        }
    }

    DEBUG((BPGRP, OTLVL, "SLOC: Exiting"));

    return(SUCCESS);
}




/***    eEndlocal - End Local treatment of environment commands
 *
 *  Purpose:
 *      To reestablish the export of environment alterations to COMMAND's
 *      current environment.  Once this command is encountered, the current
 *      directory and the current environment in use at the time of the
 *      initial SETLOCAL command will be restored from their copies.
 *
 *  int eEndlocal(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the ENDLOCAL command
 *
 *  Returns:
 *      Always returns SUCCESS.
 *
 *  Notes:
 *      Issuance of an ENDLOCAL command without a previous SETLOCAL command
 *      is bad programming practice but not considered an error.
 *
 */

int eEndlocal(n)
struct cmdnode *n;
{
    struct batdata *bdat = CurrentBatchFile;

    UNREFERENCED_PARAMETER( n );

    ElclWork( bdat );

    return(SUCCESS);
}

void EndAllLocals( struct batdata *bdat )
{
    //
    // If a restricted token was created to run this batch file then close it.
    // Also, revert to the process token. The matching impersonate was done in
    // SetBat.
    //

    if (bdat->hRestrictedToken != NULL) {
        RevertToSelf();
        CloseHandle(bdat->hRestrictedToken);
        bdat->hRestrictedToken = NULL;
    }

    while (bdat->SavedEnvironmentCount != 0) {
        ElclWork( bdat );
    }
}

/***    ElclWork - Restore copied directory and environment
 *
 *  Purpose:
 *      If the current batch data structure contains valid pointers to
 *      copies of the current directory and environment, restore them.
 *
 *  int ElclWork(struct batdata *bdat)
 *
 *  Args:
 *      bdat - the batch data structure containing copied dir/env pointers
 *
 *  Returns:
 *      Always returns SUCCESS.
 *
 *  Notes:
 *      The level of stacked data, ie. CurrentBatchFile->stacksize, cannot be restored
 *      to its pre-SETLOCAL level in case this command is occuring in a
 *      later nested batch file.  To do so would free the memory containing
 *      its own batch data structure.  Only when the current batch file
 *      terminates and is popped off the stack, will Parser() free up the
 *      memory containing the copies.  Issuance of an ENDLOCAL command
 *      without a previous SETLOCAL command is bad programming practice
 *      but not considered an error.
 *
 */

void ElclWork( struct batdata *bdat )
{
    TCHAR c;
    struct batsaveddata *p;

    if (bdat == NULL) {
        return;
    }

    if (bdat->SavedEnvironmentCount == 0) {
        return;
    }

    bdat->SavedEnvironmentCount--;
    p = bdat->saveddata[bdat->SavedEnvironmentCount];

    bdat->saveddata[bdat->SavedEnvironmentCount] = NULL;

    if (p == NULL) {
        return;
    }

    c = _toupper( *p->dircpy );
    if (CurDrvDir[0] != c) {
        ChangeDrive( c - 0x20 );
    }
    
    //
    //  Restore the state saved in the setlocal
    //
    
    ChangeDir( p->dircpy);
    HeapFree( GetProcessHeap( ), 0, p->dircpy );
    
    ResetEnv( p->envcpy );
    FreeEnv( p->envcpy );

    fEnableExtensions = p->fEnableExtensions;
    fDelayedExpansion = p->fDelayedExpansion;

    HeapFree( GetProcessHeap( ), 0, p );
}

/***    eCall - begin the execution of the Call command
 *
 *  Purpose:
 *      This is Command's interface to the Call function.  It just calls
 *      CallWork with its command node, and sets LastRetCode.
 *
 *  int eCall(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the copy command
 *
 *  Returns:
 *      Whatever CallWork() returns.
 *
 */


int eCall(n)
struct cmdnode *n;
{
    int CallWork();

    return(LastRetCode = CallWork(n->argptr)); /* @@ */
}


/***    CallWork - Execute another batch file as a subroutine (M009 - New)
 *
 *  Purpose:
 *      Parse the argument portion of the current node.  If it is a batch
 *      file invocation, call BatProc() with the newly parsed node.
 *
 *  int CallWork(TCHAR *fname)
 *
 *  Args:
 *      fname - pointer to the batch file to be CALLed
 *
 *  Returns:
 *      The process return code of the child batch file or
 *      SUCCESS if null node or
 *      FAILURE if PARSERROR or unable to exec as batch file.
 *
 *  Notes:
 *      The CALLing of batch files is much the same as the proposed
 *      "new-style" batch file concept, except with regard to localizing
 *      environment and directory alterations.
 *
 */

int ColonIsToken;

int CallWork(fname)
TCHAR *fname;
{
    struct node *c;        /* New node for CALL statement     */
    TCHAR *flptr;          /* Ptr to file location            */
    int i;                         /* Work variable                   */
    TCHAR *t1, *t2,                 /* M041 - Temp pointer             */
    *aptr;                    /* M041 - New arg pointer          */
    TCHAR *temp_parm;              /* @@4a */
    unsigned rc;

    DEBUG((BPGRP,OTLVL,"CALL: entered"));

    if (fname == NULL) {

        return( FAILURE );

    }
    if (!(flptr = mkstr(MAX_PATH*sizeof(TCHAR))))   /* Filespec to run   */
        return(FAILURE);

/*  Note that in reparsing the argument portion of the current statement
 *  we do not have to concern ourselves with redirection.  It was already
 *  set up when the CALL statement was dispatch()'ed.
 *  M041 - We do, however, have to "re-escape" any escape characters
 *  before reparsing or they will disappear.
 */
    aptr = fname;                      /* Initialize it           */
    if (t1 = mystrchr(fname, ESCHAR)) {
        if (!(aptr = mkstr(((mystrlen(fname) * 2) + 1) * sizeof(TCHAR))))
            return(FAILURE);
        t2 = aptr;
        t1 = fname;
        while (*t1)
            if ((*t2++ = *t1++) == ESCHAR)
                *t2++ = ESCHAR;
        *t2 = NULLC;
        if (!(aptr = resize(aptr, (mystrlen(aptr) + 1)*sizeof(TCHAR))))
            return(FAILURE);
    }

    i = DCount;                    /* Valid data ptr for parser       */

    DEBUG((BPGRP,OTLVL,"CALL: Parsing %ws",fname));

    ColonIsToken = 1;
    c=Parser(READSTRING, (INT_PTR)aptr, i);
    ColonIsToken = 0;

    if (c == (struct node *) PARSERROR) {

        DEBUG((BPGRP,OTLVL,"CALL: Parse error, returning failure"));     

        /*@@5c */

if (!(temp_parm = mkstr(((mystrlen(aptr) * 2) + 1) * sizeof(TCHAR))))
            return(FAILURE);
        /*@@5a */mystrcpy(temp_parm, aptr);
        _tcsupr(temp_parm);     
        /*@@5a */
        /*@@5a */if ( (!_tcscmp(temp_parm, TEXT(" IF" ))) ||
                      /*@@5a */         (!_tcscmp(temp_parm, TEXT(" FOR" ))) )
        /*@@5a */
        {         
            /*@@5a */
            PutStdErr( MSG_SYNERR_GENL, ONEARG, aptr );  /* @@4 */
            /*@@5a */
        }

        return(FAILURE);
    }

    if (c == (struct node *) EOF) {

        DEBUG((BPGRP,OTLVL,"CALL: Found EOF, returning success"));

        return(SUCCESS);
    }

    DEBUG((BPGRP,OTLVL,"CALL: Parsed OK, looking for batch file"));

    //
    // If extensions are enable, check for the new form of the CALL
    // statement:
    //
    //      CALL :label args...
    //
    // which is basically a form of subroutine call within command scripts.
    // If the target of the CALL begins with a COLON then do nothing
    // here and let BatProc take care of it when it is called below.
    //
    // Otherwise, execute the old code, which will search for a command
    // script file or executable.
    //
    if (fEnableExtensions && *((struct cmdnode *)c)->cmdline == COLON) {
        //
        // The new form is only valid inside of a command script, so
        // declare an error if the user entered it from the command line
        //
        if (CurrentBatchFile == NULL) {
            PutStdErr( MSG_CALL_LABEL_INVALID, NOARGS );
            return(FAILURE);
        }
    } else
        if ((mystrchr(((struct cmdnode *)c)->cmdline, STAR) ||   /* M035    */
             mystrchr(((struct cmdnode *)c)->cmdline, QMARK) ||
             (i = SearchForExecutable((struct cmdnode *)c, flptr)) != SFE_ISBAT)) {

        rc = FindFixAndRun( (struct cmdnode *)c );
        return(rc); /*@@5*/

    }

    DEBUG((BPGRP,OTLVL,"CALL: Found batch file"));

    rc = BatProc((struct cmdnode *)c, flptr, BT_CALL);

    /* @@6a If rc is zero, return LastRetCode because it might != 0 */
    return(rc ? rc : LastRetCode);
}


/***    eBreak - begin the execution of the BREAK command
 *
 *  Purpose:
 *      Does nothing as it is only here for compatibility.  If extensions are
 *      enabled and running on Windows NT, then enters a hard coded breakpoint
 *      if this process is being debugged by a debugger.
 *
 *  int eExtproc(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the copy command
 *
 *  Returns:
 *      SUCCESS;
 *
 */

int eBreak(struct cmdnode *n)
{
    UNREFERENCED_PARAMETER( n );
#if !defined( WIN95_CMD ) && DBG
    if (fEnableExtensions &&
        lpIsDebuggerPresent != NULL &&          // Only true on NT
        (*lpIsDebuggerPresent)()) {
        DebugBreak();
    }
#endif
    return(SUCCESS);
}


BOOL
ReadBufFromFile(
               HANDLE      h,
               TCHAR       *pBuf,
               int         cch,
               int         *pcch)
{
    int         cb;
    UCHAR       *pch = AnsiBuf;
    int         cchNew;
    DWORD       fPos;

    fPos = SetFilePointer(h, 0, NULL, FILE_CURRENT);
    if (ReadFile(h, AnsiBuf, cch, pcch, NULL) == 0)
        return 0;
    if (*pcch == 0)
        return 0;

    /* check for lead character at end of line */
    cb = cchNew = *pcch;
    while (cb > 0) {
        if ( (cb >=3 ) &&
             ( (*pch == '\n' && *(pch+1) == '\r') ||
               (*pch == '\r' && *(pch+1) == '\n') )  ) {
            *(pch+2) = '\000';
            cchNew = (int)(pch - AnsiBuf) + 2;
            SetFilePointer(h, fPos+cchNew, NULL, FILE_BEGIN);
            break;
        } else if (is_dbcsleadchar(*pch)) {
            if (cb == 1) {
                if (ReadFile(h, pch+1, 1, &cb, NULL) == 0 || cb == 0) {
                    *pcch = 0;
                    return 0;
                }
                cchNew++;
                break;
            }
            cb -= 2;
            pch += 2;
        } else {
            cb--;
            pch++;
        }
    }
#ifdef UNICODE
    cch = MultiByteToWideChar(CurrentCP, MB_PRECOMPOSED, AnsiBuf, cchNew, pBuf, cch);
#else
    memmove(pBuf, AnsiBuf, cchNew);
    cch = cchNew;
#endif
    *pcch = cch;
    return cch;
}

BOOL
ReadBufFromConsole(
                  HANDLE      h,
                  TCHAR*      pBuf,
                  int         cch,
                  int         *pcch)
{
    CONSOLE_READCONSOLE_CONTROL InputControl;
    BOOL ReadConsoleResult, bTouched, bPathCompletion, bHaveHScrollBar, bHaveVScrollBar;
    PTCHAR PrevBuf;
    DWORD cchPrevBuf;
    DWORD cchRead;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD InitialCursorPosition;
    HANDLE hOut;
    DWORD cchBuf;
    ULONG i, iCompletionCh, iCR;
    DWORD nLines, nCols;

    //
    // Original code just called ReadConsole with the passed parameters.
    // Now, we attempt to call the new improved ReadConsole with an extra
    // parameter to enable intermediate wakeups from the read to process
    // a file completion control character.  This new feature is only
    // enabled if all of the following are true:
    //  Command extensions are enabled
    //  User has defined a command completion control character
    //  Standard Output Handle is a console output handle
    //
    // If any of the above are not true, do it the old way.
    //

    hOut = GetStdHandle( STD_OUTPUT_HANDLE );
    if (hOut == INVALID_HANDLE_VALUE)
        hOut = CRTTONT( STDOUT );
    if (!fEnableExtensions 
        || chCompletionCtrl >= SPACE 
        || chPathCompletionCtrl >= SPACE 
        || !GetConsoleScreenBufferInfo( hOut, &csbi ) ) {
        ReadConsoleResult = ReadConsole(h, pBuf, cch, pcch, NULL);
#if defined(RICHARDW)
        Mirror( ReadConsoleResult, pBuf, *pcch );
#endif
        
        return ReadConsoleResult;
    }

    InitialCursorPosition = csbi.dwCursorPosition;
    nLines = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
    nCols = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    bHaveHScrollBar = ((SHORT)nCols != csbi.dwSize.X);
    bHaveVScrollBar = ((SHORT)nLines != csbi.dwSize.Y);

    //
    // All conditions are met, so set up the extra parameter to
    // ReadConsole to tell it what control character(s) are to
    // cause the read to return with intermediate results.
    //

    InputControl.nLength = sizeof(CONSOLE_READCONSOLE_CONTROL);
    InputControl.nInitialChars = 0;
    InputControl.dwCtrlWakeupMask = (1 << chCompletionCtrl);
    InputControl.dwCtrlWakeupMask |= (1 << chPathCompletionCtrl);
    InputControl.dwControlKeyState = 0;

    //
    // We will now loop until the user type enter, processing any
    // intermediate wakeups as file completion requests.
    //
    DoCompleteInitialize();
    PrevBuf = NULL;
    cchPrevBuf = 0;
    while (TRUE) {
        //
        // Read a line of input from the console.
        //

        ReadConsoleResult = ReadConsole(h, pBuf, cch, pcch, &InputControl);
#if defined( RICHARDW )
        Mirror( ReadConsoleResult, pBuf, *pcch );
#endif

        cchRead = *pcch;

        if (CtrlCSeen) {
            ResetCtrlC( );
            if (PrevBuf)
                HeapFree(GetProcessHeap(), 0, PrevBuf);
            PrevBuf = NULL;
        }

        //
        // If the read failed for any reason, we are done.
        //
        if (!ReadConsoleResult)
            break;

        //
        // Make sure the result buffer is null terminated.  If the buffer
        // contains a carriage return, then the use must have hit enter, so
        // break out of the loop to return the command line to the caller.
        //
        bPathCompletion = FALSE;
        iCR = iCompletionCh = 0xFFFFFFFF;
        for (i=0; i<(ULONG)*pcch; i++) {
            if (pBuf[i] == CR) {
                iCR = i;
                break;
            } else
                if (pBuf[i] == chCompletionCtrl) {
                iCompletionCh = i;
                break;
            } else
                if (pBuf[i] == chPathCompletionCtrl) {
                iCompletionCh = i;
                bPathCompletion = TRUE;
                break;
            }
        }
        if (iCR != 0xFFFFFFFF) {
            break;
        }

        //
        // Use did not hit enter, so they must have hit the file completion
        // control character.  Find where they did this and terminate the
        // result buffer at that point.  If not found, then assume they hit
        // enter and break out of the loop to return what we have.
        //
        if (iCompletionCh == 0xFFFFFFFF) {
            break;
        }

        //
        // Found the file completion control character.  Dont count it as read.
        // Null terminate the buffer and see if the buffer contents before
        // the completion character is the same as what we displayed last.
        //
        *pcch = iCompletionCh;
        pBuf[iCompletionCh] = NULLC;
        if (PrevBuf == NULL || _tcscmp(pBuf, PrevBuf))
            bTouched = TRUE;
        else
            bTouched = FALSE;

        //
        // If we know we are processing a command that only takes directory
        // names are arguments, force completion code to only match directory
        // names.
        //
        if (!bPathCompletion && iCompletionCh > 2) {
            if (!_tcsnicmp(pBuf, TEXT("cd "), 3) 
                || !_tcsnicmp(pBuf, TEXT("rd "), 3) 
                || !_tcsnicmp(pBuf, TEXT("md "), 3) 
                || !_tcsnicmp(pBuf, TEXT("chdir "), 6) 
                || !_tcsnicmp(pBuf, TEXT("rmdir "), 6) 
                || !_tcsnicmp(pBuf, TEXT("mkdir "), 6) 
                || !_tcsnicmp(pBuf, TEXT("pushd "), 6)

               ) {
                bPathCompletion = TRUE;
            }
        }

        //
        // Call the file completion code with the input buffer, current length,
        // whether the user had the shift key down or not (SHIFT means backwards)
        // and whether or not the user modified the input buffer since the last
        // time it was displayed.  If the user did not modify what was last displayed
        // then that tells the file completion code to display the next matching
        // file name from the list as opposed to recalculating the list of matching
        // files.
        //
        if ( DoComplete( pBuf,
                         iCompletionCh,
                         cch,
                         !(InputControl.dwControlKeyState & SHIFT_PRESSED),
                         bPathCompletion,
                         bTouched
                       )
           ) {
            //
            //  Recompute the position of the start of the command line, since
            //  it might have scrolled around since when we first wrote it out.
            //

            if (GetConsoleScreenBufferInfo( hOut, &csbi )) {
                //
                //  Walk backwards from the current cursor position to determine the 
                //  proper initial position for screen blanking and for the next 
                //  ReadConsole
                //
                //  The row (Y) of the next input is based on the number of lines 
                //  consumed by the prompt plus the length of what the user has input. 
                //  There is no need to round at all since any remainder is simply 
                //  how far on the screen we are.
                //

                InitialCursorPosition.Y =
                (SHORT) (csbi.dwCursorPosition.Y 
                         - (InitialCursorPosition.X + iCompletionCh) / csbi.dwSize.X);
            }

            //
            // Completion found a new file name and put it in the buffer.
            // Update the length of valid characters in the buffer, redisplay
            // the buffer at the cursor position we started, so the user can
            // see the file name found
            //
            cchBuf = _tcslen(pBuf);
            SetConsoleCursorPosition( hOut, InitialCursorPosition );

            FillConsoleOutputCharacter( hOut, 
                                        TEXT( ' ' ), 
                                        cchRead, 
                                        InitialCursorPosition, 
                                        &cchRead );

            WriteConsole(hOut, pBuf, cchBuf, &cchBuf, NULL);

            InputControl.nInitialChars = cchBuf;
        } else {
            //
            // File completion had nothing to had, so just beep and redo the read.
            //
            MessageBeep( 0xFFFFFFFF );
            InputControl.nInitialChars = _tcslen(pBuf);
        }

        //
        // Done with file completion.  Free any previous buffer copy and
        // allocate a copy of the current input buffer so we will know if the
        // user has changed it or not.
        //
        if (PrevBuf)
            HeapFree(GetProcessHeap(), 0, PrevBuf);
        cchPrevBuf = _tcslen(pBuf);
        PrevBuf = HeapAlloc(GetProcessHeap(), 0, (cchPrevBuf+1) * sizeof(TCHAR));
        if (PrevBuf == NULL) {
            return FALSE;
        }
        _tcscpy(PrevBuf, pBuf);
    }

    //
    // All done.  Free any buffer copy and return the result of the read
    // to the caller
    //
    if (PrevBuf)
        HeapFree(GetProcessHeap(), 0, PrevBuf);

    return ReadConsoleResult;
}

BOOL
ReadBufFromInput(
                HANDLE      h,
                TCHAR       *pBuf,
                int         cch,
                int         *pcch)
{
    unsigned htype;

    htype = GetFileType(h);
    htype &= ~FILE_TYPE_REMOTE;

    if (htype == FILE_TYPE_CHAR)
        return ReadBufFromConsole(h, pBuf, cch, pcch);
    else
        return ReadBufFromFile(h, pBuf, cch, pcch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cclock.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cclock.c

Abstract:

    time/date functions

--*/

#include "cmd.h"

#define MMDDYY 0
#define DDMMYY 1
#define YYMMDD 2

extern TCHAR Fmt04[], Fmt05[], Fmt06[], Fmt10[], Fmt11[];
extern TCHAR Fmt17[], Fmt15[];
extern unsigned DosErr;
extern unsigned LastRetCode;
// for keeping current console output codepage.
extern  UINT CurrentCP;

BOOL TimeAmPm=TRUE;
TCHAR TimeSeparator[8];
TCHAR DateSeparator[8];
TCHAR DecimalPlace[8];
int DateFormat;
TCHAR *DateFormatString;
TCHAR ThousandSeparator[8];


#define SHORT_NAME_LENGTH   32

TCHAR ShortMondayName[SHORT_NAME_LENGTH];
TCHAR ShortTuesdayName[SHORT_NAME_LENGTH];
TCHAR ShortWednesdayName[SHORT_NAME_LENGTH];
TCHAR ShortThursdayName[SHORT_NAME_LENGTH];
TCHAR ShortFridayName[SHORT_NAME_LENGTH];
TCHAR ShortSaturdayName[SHORT_NAME_LENGTH];
TCHAR ShortSundayName[SHORT_NAME_LENGTH];

#define AMPM_INDICATOR_LENGTH   32

TCHAR AMIndicator[AMPM_INDICATOR_LENGTH];
TCHAR PMIndicator[AMPM_INDICATOR_LENGTH];
ULONG YearWidth;

//
//  We snapshot the current LCID at startup and modify it based on the current known
//  set of scripts that Console supports.
//


LCID CmdGetUserDefaultLCID(
    void
    )
{
    LCID CmdLcid = GetUserDefaultLCID();
#ifdef LANGPACK
    if (
       (PRIMARYLANGID(CmdLcid) == LANG_ARABIC) ||
       (PRIMARYLANGID(CmdLcid) == LANG_HEBREW) ||
       (PRIMARYLANGID(CmdLcid) == LANG_THAI)   ||
       (PRIMARYLANGID(CmdLcid) == LANG_HINDI)  ||
       (PRIMARYLANGID(CmdLcid) == LANG_TAMIL)  ||
       (PRIMARYLANGID(CmdLcid) == LANG_FARSI)
       ) {
        CmdLcid = MAKELCID (MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT); // 0x409;
    }
#endif
    return CmdLcid;
}


VOID
InitLocale( VOID )
{
    TCHAR Buffer[128];

    LCID CmdLcid = CmdGetUserDefaultLCID( );
    
    // get the time separator
    if (!GetLocaleInfo(CmdLcid, LOCALE_STIME, TimeSeparator, sizeof(TimeSeparator) / sizeof( TCHAR )))
        _tcscpy(TimeSeparator, TEXT(":"));

    // determine if we're 0-12 or 0-24
    if (GetLocaleInfo(CmdLcid, LOCALE_ITIME, Buffer, 128)) {
        TimeAmPm = _tcscmp(Buffer,TEXT("1"));
    }

    _tcscpy(AMIndicator, TEXT("a"));
    _tcscpy(PMIndicator, TEXT("p"));

    //
    //  get the date ordering
    //
    DateFormat = MMDDYY;
    if (GetLocaleInfo(CmdLcid, LOCALE_IDATE, Buffer, 128)) {
        switch (Buffer[0]) {
        case TEXT('0'):
            DateFormat = MMDDYY;
            DateFormatString = TEXT( "MM/dd/yy" );
            break;
        case TEXT('1'):
            DateFormat = DDMMYY;
            DateFormatString = TEXT( "dd/MM/yy" );
            break;
        case TEXT('2'):
            DateFormat = YYMMDD;
            DateFormatString = TEXT( "yy/MM/dd" );
            break;
        default:
            break;
        }
    }

    //
    //  Get the date width
    //

    YearWidth = 2;
    if (GetLocaleInfo( CmdLcid, LOCALE_ICENTURY, Buffer, 128 )) {
        if (Buffer[0] == TEXT( '1' )) {
            YearWidth = 4;
        }
    }

    // get the date separator
    if (!GetLocaleInfo(CmdLcid, LOCALE_SDATE, DateSeparator, sizeof(DateSeparator) / sizeof( TCHAR )))
        _tcscpy(DateSeparator, TEXT("/"));

    // get the short day names
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME1, ShortMondayName, sizeof(ShortMondayName) / sizeof( TCHAR )))
        _tcscpy(ShortMondayName, TEXT("Mon"));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME2, ShortTuesdayName, sizeof(ShortTuesdayName) / sizeof( TCHAR )))
        _tcscpy(ShortTuesdayName, TEXT("Tue"));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME3, ShortWednesdayName, sizeof(ShortWednesdayName) / sizeof( TCHAR )))
        _tcscpy(ShortWednesdayName, TEXT("Wed"));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME4, ShortThursdayName, sizeof(ShortThursdayName) / sizeof( TCHAR )))
        _tcscpy(ShortThursdayName, TEXT("Thu"));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME5, ShortFridayName, sizeof(ShortFridayName) / sizeof( TCHAR )))
        _tcscpy(ShortFridayName, TEXT("Fri"));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME6, ShortSaturdayName, sizeof(ShortSaturdayName) / sizeof( TCHAR )))
        _tcscpy(ShortSaturdayName, TEXT("Sat"));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_SABBREVDAYNAME7, ShortSundayName, sizeof(ShortSundayName) / sizeof( TCHAR )))
        _tcscpy(ShortSundayName, TEXT("Sun"));

    // get decimal and thousand separator strings
    if (!GetLocaleInfo(CmdLcid, LOCALE_SDECIMAL, DecimalPlace, sizeof(DecimalPlace) / sizeof( TCHAR )))
        _tcscpy(DecimalPlace, TEXT("."));
    
    if (!GetLocaleInfo(CmdLcid, LOCALE_STHOUSAND, ThousandSeparator, sizeof(ThousandSeparator) / sizeof( TCHAR )))
        _tcscpy(ThousandSeparator, TEXT(","));

    //
    //  Set locale so that we can correctly process extended characters
    //  Note:  The string passed in is expected to be ASCII, not unicode
    //

    setlocale( LC_ALL, ".OCP" ) ;
}


/**** dayptr - return pointer to day of the week
 *
 * Purpose:
 *      To return a pointer to the string representing the current day of
 *      the week.
 *
 * Args:
 *      dow - number representing the day of the week.
 *
 */

TCHAR *dayptr( dow )
unsigned dow;
{
    switch ( dow ) {
    case 0:  return ShortSundayName;
    case 1:  return ShortMondayName;
    case 2:  return ShortTuesdayName;
    case 3:  return ShortWednesdayName;
    case 4:  return ShortThursdayName;
    case 5:  return ShortFridayName;
    default: return ShortSaturdayName;
    }
}

BOOLEAN
SetDateTime(
           IN  LPSYSTEMTIME OsDateAndTime
           )
{
    //
    //  We have to do this twice in order to get the leap year set correctly.
    //

    SetLocalTime( OsDateAndTime );
    return(SetLocalTime( OsDateAndTime ) != 0);
}

/***    eDate - begin the execution of the Date command
 *
 *  Purpose:
 *      To display and/or set the system date.
 *
 *  Args:
 *      n - the parse tree node containing the date command
 *
 *  int eDate(struct cmdnode *n)
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int eDate(n)
struct cmdnode *n ;
{
    BOOL bTerse = FALSE;
    PTCHAR pArgs = n->argptr;
    DEBUG((CLGRP, DALVL, "eDATE: argptr = `%s'", n->argptr)) ;

    //
    // If extensions are enabled, allow a /T switch
    // to disable inputing a new DATE, just display the
    // current date.
    //
    if (fEnableExtensions)
        while ( (pArgs = mystrchr( pArgs, TEXT('/') )) != NULL ) {
            TCHAR c = (TCHAR) _totlower(*(pArgs+1));
            if ( c == TEXT('t') )
                bTerse = TRUE;
            pArgs += 2; // just skip it
        }

    if ( bTerse ) {
        PrintDate(NULL, PD_PTDATE, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
        return(LastRetCode = SUCCESS);
    }

    if ((n->argptr == NULL) ||
        (*(n->argptr = EatWS(n->argptr, NULL)) == NULLC)) {
        PutStdOut(MSG_CURRENT_DATE, NOARGS) ;
        PrintDate(NULL, PD_PTDATE, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
    };

    return(LastRetCode = GetVerSetDateTime(n->argptr, EDATE)) ;
}




/***    eTime - begin the execution of the Time command
 *
 *  Purpose:
 *      To display and/or set the system date.
 *
 *  int eTime(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the time command
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int eTime(n)
struct cmdnode *n ;
{
    BOOL bTerse = FALSE;
    PTCHAR pArgs = n->argptr;
    DEBUG((CLGRP, TILVL, "eTIME: argptr = `%s'", n->argptr)) ;

    //
    // If extensions are enabled, allow a /T switch
    // to disable inputing a new TIME, just display the
    // current time.
    //
    if (fEnableExtensions)
        while ( (pArgs = mystrchr( pArgs, TEXT('/') )) != NULL ) {
            TCHAR c = (TCHAR) _totlower(*(pArgs+1));
            if ( c == TEXT('t') )
                bTerse = TRUE;
            pArgs += 2; // just skip it
        }

    if ( bTerse ) {
        PrintTime(NULL, PD_PTDATE, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
        return(LastRetCode = SUCCESS);
    }

    if ((n->argptr == NULL) ||
        (*(n->argptr = EatWS(n->argptr, NULL)) == NULLC)) {
        PutStdOut(MSG_CURRENT_TIME, NOARGS) ;
        PrintTime(NULL, PT_TIME, (TCHAR *)NULL, 0) ;
        cmd_printf(CrLf);
    };

    return(LastRetCode = GetVerSetDateTime(n->argptr, ETIME)) ;
}




/***    PrintDate - print the date
 *
 *  Purpose:
 *      To print the date either in the format used by the Date command or
 *      the format used by the Dir command.  The structure Cinfo is checked
 *      for the country date format.
 *
 *  PrintDate(int flag, TCHAR *buffer)
 *
 *  Args:
 *      flag - indicates which format to print
 *      *buffer - indicates whether or not to print date message
 *
 *  Notes:
 */

int PrintDate(crt_time,flag,buffer,cch)
struct tm *crt_time ;
int flag ;
TCHAR *buffer;
int cch;
{
    TCHAR DayOfWeek[SHORT_NAME_LENGTH];
    TCHAR datebuf [32] ;
    unsigned i, j, k, m;
    int ptr = 0;
    struct tm xcrt_time ;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    FILETIME LocalFileTime;
    int cchUsed;
    BOOL NeedDayOfWeek = TRUE;

    DEBUG((CLGRP, DALVL, "PRINTDATE: flag = %d", flag)) ;

    //
    //  PrintDate is never called with PD_DATE and buffer == NULL
    //  PrintDate is never called with PD_DIR and buffer == NULL
    //  PrintDate is never called with PD_PTDATE and buffer != NULL
    //
    //  Another way of saying this is:
    //      PD_DATE => output to buffer
    //      PD_DIR => output to buffer
    //      PD_DIR2000 => output to buffer
    //      PD_PTDATE => print out
    //
    //  PD_DIR      MM/DD/YY
    //  PD_DIR2000  MM/DD/YYYY
    //  PD_DATE     Japan: MM/DD/YYYY DayOfWeek     Rest: DayOfWeek MM/DD/YYYY
    //  PD_PTDATE   Japan: MM/DD/YYYY DayOfWeek     Rest: DayOfWeek MM/DD/YYYY
    //

    //
    //  If no time was input, then use the current system time.  Convert from the
    //  various formats to something standard.
    //

    if (!crt_time) {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime,&FileTime);
    } else {
        xcrt_time = *crt_time;
        ConverttmToFILETIME(&xcrt_time,&FileTime);
    }
    FileTimeToLocalFileTime(&FileTime,&LocalFileTime);
    FileTimeToSystemTime( &LocalFileTime, &SystemTime );

    //
    // SystemTime now contains the correct local time
    // FileTime now contains the correct local time
    //

    //
    //  If extensions are enabled, we format things in the culturally
    //  correct format (from international control panel).  if not, then
    //  we display it as best we can from NT 4.
    //

    if (fEnableExtensions) {

        TCHAR LocaleDateFormat[128];
        PTCHAR p;
        BOOL InQuotes = FALSE;

        //
        //  Map the locale to one that is acceptable to the console subsystem
        //

        if (!GetLocaleInfo( CmdGetUserDefaultLCID( ), 
                            LOCALE_SSHORTDATE, 
                            LocaleDateFormat, 
                            sizeof( LocaleDateFormat ) / sizeof( LocaleDateFormat[0] ))) {
            //
            //  Not enough room for this format, cheat and use the one we
            //  assumed from the DateFormat
            //

            _tcscpy( LocaleDateFormat, DateFormatString );
        }

        //
        //  The format string may be expanded with widely varying widths.  We
        //  adjust this string to try to make sure that they are all fixed widths.
        //
        //  The picture formats only have varying widths for:
        //      d   (no leading zero date)
        //      dddd(full date name)
        //      M   (no leading zero month)
        //      MMMM(full month name)
        //
        //      So, if we see d or M, we change it to dd or MM (leading zero)
        //      If we see dddd or MMMM we change it to ddd or MMM (three char abbrev)
        //

        p = LocaleDateFormat;
        while (*p != TEXT( '\0' )) {
            TCHAR c = *p;

            //
            //  Text inside single quotes is left alone
            //

            if (c == TEXT( '\'' )) {
                InQuotes = !InQuotes;
                p++;
            } else if (InQuotes) {
                p++;
            } else if (c == TEXT( 'd' ) || c == TEXT( 'M' )) {

                //
                //  Count the number of identical chars
                //

                int Count = 0;

                while (*p == c) {
                    Count++;
                    p++;
                }


                //
                //  Reset p and shuffle string around based on the repetition count
                //

                p -= Count;

                if (Count == 1) {
                    //
                    //  Move string right by one and copy the first char
                    //
                    memmove( (PUCHAR) &p[1], (PUCHAR) &p[0], sizeof( TCHAR ) * (_tcslen( &p[0] ) + 1));

                    //
                    //  Skip over the format string
                    //

                    p += 2;

                } else {
                    //
                    //  If the format string is specifying a day of week (d), then we do not
                    //  need to add on the DayOfWeek, below
                    //

                    if (c == TEXT( 'd' )) {
                        NeedDayOfWeek = FALSE;
                    }

                    if (Count > 3) {
                        //
                        //  Move string left from the first different char to just after the 3rd 
                        //  repetition
                        //
                        memmove( (PUCHAR) &p[3], (PUCHAR) &p[Count], sizeof( TCHAR ) * (_tcslen( &p[Count] ) + 1));

                        //
                        //  Skip over the format string
                        //

                        p += 3;

                    } else {

                        //
                        //  Skip over the 2 or 3 count
                        //

                        p += Count;
                    }
                }
            } else {
                p++;
            }
        }

        GetDateFormat( CmdGetUserDefaultLCID( ), 
                       0, 
                       &SystemTime, 
                       LocaleDateFormat, 
                       datebuf, 
                       sizeof( datebuf ) / sizeof( datebuf[0] ));
    } else {

        i = SystemTime.wMonth;
        j = SystemTime.wDay;
        k = SystemTime.wYear;

        //
        //  only print last two digits for DIR listings
        //

        if (flag == PD_DIR) {
            k = k % 100;
        }

        if (DateFormat == YYMMDD ) {
            m = k ;                         /* Swap all values         */
            k = j ;
            j = i ;
            i = m ;
        } else if (DateFormat == DDMMYY) {
            m = i ;                         /* Swap mon/day for Europe */
            i = j ;
            j = m ;
        }

        DEBUG((CLGRP, DALVL, "PRINTDATE: i = %d  j = %d  k = %d", i, j, k)) ;

        //
        //  Format the current date and current day of week
        //

        _sntprintf(datebuf, 32, Fmt10, i, DateSeparator, j, DateSeparator, k);
    }

    _tcscpy( DayOfWeek, dayptr( SystemTime.wDayOfWeek )) ;

    //
    //  If there is no input buffer, we display the day-of-week and date
    //  according to language preference.  Only in DBCS codepages (aka Japan)
    //  does the day of week FOLLOW the date
    //

    if (buffer == NULL) {
        //
        //  This can only be PD_PTDATE
        //

        //
        //  No day of week means we simply display the date
        //

        if (!NeedDayOfWeek) {
            cchUsed = cmd_printf( Fmt11, datebuf );
        } else if (IsDBCSCodePage()) {
            cchUsed = cmd_printf( Fmt15, datebuf, DayOfWeek );         //  "%s %s "
        } else {
            cchUsed = cmd_printf( Fmt15, DayOfWeek, datebuf );         //  "%s %s "
        }

    } else {
        //
        //  for PD_DATE, we need to output the date in the correct spot
        //

        if (NeedDayOfWeek && flag == PD_DATE) {

            if (IsDBCSCodePage()) {
                _tcscpy( buffer, datebuf );
                _tcscat( buffer, TEXT( " " ));
                _tcscat( buffer, DayOfWeek );
            } else {
                _tcscpy( buffer, DayOfWeek );
                _tcscat( buffer, TEXT( " " ));
                _tcscat( buffer, datebuf );
            }
        } else {
            // 
            //  PD_DIR and PD_DIR2000 only get the date
            //

            _tcscpy( buffer, datebuf );
        }
        cchUsed = _tcslen( buffer );
    }

    return cchUsed;
}




/***    PrintTime - print the time
 *
 *  Purpose:
 *      To print the time either in the format used by the Time command or
 *      the format used by the Dir command.  The structure Cinfo is checked
 *      for the country time format.
 *
 *  PrintTime(int flag)
 *
 *  Args:
 *      flag - indicates which format to print
 *
 */

int PrintTime(crt_time, flag, buffer, cch)
struct tm *crt_time ;
int flag ;
TCHAR *buffer;
int cch;
{
    TCHAR *ampm ;
    unsigned hr ;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    FILETIME LocalFileTime;
    int cchUsed;

    if (!crt_time) {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime,&FileTime);
    } else {
        ConverttmToFILETIME(crt_time,&FileTime);
    }

    FileTimeToLocalFileTime(&FileTime,&LocalFileTime);
    FileTimeToSystemTime( &LocalFileTime, &SystemTime );


    //
    //  PT_TIME implies Time Command format.  This is nothing more
    //  than 24 hour clock with tenths
    //

    if (flag == PT_TIME) {      /* Print time in Time command format    */
        if (!buffer) {
            cchUsed = cmd_printf(Fmt06,
                                 SystemTime.wHour, TimeSeparator,
                                 SystemTime.wMinute, TimeSeparator,
                                 SystemTime.wSecond, DecimalPlace,
                                 SystemTime.wMilliseconds/10
                                ) ;
        } else {
            cchUsed = _sntprintf(buffer, cch, Fmt06,
                                 SystemTime.wHour, TimeSeparator,
                                 SystemTime.wMinute, TimeSeparator,
                                 SystemTime.wSecond, DecimalPlace,
                                 SystemTime.wMilliseconds/10
                                ) ;
        }

    } else {

        TCHAR TimeBuffer[32];

        //
        //  Print time in Dir command format.  If extensions are enabled
        //  then we have the culturally correct time, otherwise we use
        //  the NT 4 format.
        //

        if (fEnableExtensions) {
            TCHAR LocaleTimeFormat[128];
            PTCHAR p;
            BOOL InQuotes = FALSE;


            if (!GetLocaleInfo( CmdGetUserDefaultLCID( ), 
                                LOCALE_STIMEFORMAT, 
                                LocaleTimeFormat, 
                                sizeof( LocaleTimeFormat ) / sizeof( LocaleTimeFormat[0] ))) {
                //
                //  Not enough room for this format, cheat and use the one we
                //  assumed from the DateFormat
                //

                _tcscpy( LocaleTimeFormat, TEXT( "HH:mm:ss t" ));
            }

            //
            //  Scan the string looking for "h", "H", or "m" and make sure there are two of them.
            //  If there is a single one, replicate it.  We do this to ensure leading zeros
            //  which we need to make this a fixed-width string
            //

            p = LocaleTimeFormat;
            while (*p != TEXT( '\0' )) {
                TCHAR c = *p;

                //
                //  Text inside single quotes is left alone
                //

                if (c == TEXT( '\'' )) {
                    InQuotes = !InQuotes;
                    p++;
                } else if (InQuotes) {
                    p++;
                } else if (c == TEXT( 'h' ) || c == TEXT( 'H' ) || c == TEXT( 'm' )) {

                    //
                    //  Count the number of identical chars
                    //

                    int Count = 0;

                    while (*p == c) {
                        Count++;
                        p++;
                    }


                    //
                    //  Reset p and shuffle string around based on the repetition count
                    //

                    p -= Count;

                    if (Count == 1) {
                        memmove( (PUCHAR) &p[1], (PUCHAR) &p[0], sizeof( TCHAR ) * (_tcslen( &p[0] ) + 1));
                        *p = c;
                    }

                    p++;

                }

                p++;
            }

            cchUsed = GetTimeFormat( CmdGetUserDefaultLCID( ),
                                     TIME_NOSECONDS,
                                     &SystemTime,
                                     LocaleTimeFormat,
                                     TimeBuffer,
                                     sizeof( TimeBuffer ) / sizeof( TimeBuffer[0] ));

            if (cchUsed == 0) {
                TimeBuffer[0] = TEXT( '\0' );
            }

        } else {
            ampm = AMIndicator ;
            hr = SystemTime.wHour;
            if ( TimeAmPm ) {  /* 12 hour am/pm format */
                if ( hr >= 12) {
                    if (hr > 12) {
                        hr -= 12 ;
                    }
                    ampm = PMIndicator ;
                } else if (hr == 0) {
                    hr = 12 ;
                }
            } else {  /* 24 hour format */
                ampm = TEXT( " " );
            }

            _sntprintf( TimeBuffer, 
                        sizeof( TimeBuffer ) / sizeof( TimeBuffer[0] ),
                        Fmt04,
                        hr,
                        TimeSeparator,
                        SystemTime.wMinute,
                        ampm );
        }

        if (!buffer) {
            cchUsed = CmdPutString( TimeBuffer );
        } else {
            _tcsncpy( buffer, TimeBuffer, cch );
            buffer[cch] = TEXT( '\0' );
            cchUsed = _tcslen( buffer );
        }

    }

    return cchUsed;
}


/***    GetVerSetDateTime - controls the changing of the date/time
 *
 *  Purpose:
 *      To prompt the user for a date or time, verify it, and set it.
 *      On entry, if *dtstr is not '\0', it already points to a date or time
 *      string.
 *
 *      If null input is given to one of the prompts, the command execution
 *      ends; neither the date or the time is changed.
 *
 *      Once valid input has been received the date/time is updated.
 *
 *  int GetVerSetDateTime(TCHAR *dtstr, int call)
 *
 *  Args:
 *      dtstr - ptr to command line date/time string and is used to hold a ptr
 *          to the tokenized date/time string
 *      call - indicates whether to prompt for date or time
 *
 */

int GetVerSetDateTime(dtstr, call)
TCHAR *dtstr ;
int call ;
{
    TCHAR dtseps[16] ;    /* Date/Time separators passed to TokStr() */
    TCHAR *scan;
    TCHAR separators[16];
    TCHAR LocalBuf[MAX_PATH];

    unsigned int dformat ;
    SYSTEMTIME OsDateAndTime;
    LONG cbRead;
    int ret;

    if (call == EDATE) {         /* Initialize date/time separator list */
        dtseps[0] = TEXT('/') ;
        dtseps[1] = TEXT('-') ;
        dtseps[2] = TEXT('.') ;
        _tcscpy(&dtseps[3], DateSeparator) ;
    } else {
        dtseps[0] = TEXT(':');
        dtseps[1] = TEXT('.');
        dtseps[2] = TimeSeparator[0] ;
        _tcscpy(&dtseps[3], DecimalPlace) ;     /* decimal separator should */
                                                /* always be last */
    }

    DEBUG((CLGRP, DALVL|TILVL, "GVSDT: dtseps = `%s'", dtseps)) ;

    for ( ; ; ) {                   /* Date/time get-verify-set loop    */
        if ((dtstr) && (*dtstr != NULLC)) {         /* If a date/time was passed copy it into input buffer */
            if (_tcslen( dtstr ) >= MAX_PATH) {
                PutStdOut(((call == EDATE) ? MSG_INVALID_DATE : MSG_REN_INVALID_TIME), NOARGS);
                return FAILURE;
            }
            
            _tcscpy(LocalBuf, dtstr) ;
            *dtstr = NULLC ;
        } else {                    /* Otherwise, prompt for new date/time  */
            switch (DateFormat) {           /* M012    */
            /*  case USA:  */
            case MMDDYY: /* @@ */
                dformat = MSG_ENTER_NEW_DATE ;
                break ;

                /*   case JAPAN:
                     case CHINA:
                     case SWEDEN:
                     case FCANADA:    @@ */
            case YYMMDD:
                dformat = MSG_ENTER_JAPAN_DATE ;
                break ;

            default:
                dformat = MSG_ENTER_DEF_DATE ;
            } ;

            if ( call == EDATE )
                PutStdOut(dformat, ONEARG, DateSeparator );
            else
                PutStdOut(MSG_ENTER_NEW_TIME, NOARGS);

            scan = LocalBuf;
            ret = ReadBufFromInput(CRTTONT(STDIN),LocalBuf,MAX_PATH,&cbRead);
            if (ret && cbRead != 0) {

                *(scan + cbRead) = NULLC ;

            } else {

                //
                // attempt to read past eof or error in pipe
                // etc.
                //
                return( FAILURE );

            }
            for (scan = LocalBuf; *scan; scan++)
                if ( (*scan == '\n') || (*scan == '\r' )) {
                    *scan = '\0';
                    break;
                }
            if (!FileIsDevice(STDIN))
                cmd_printf(Fmt17, LocalBuf) ;
            DEBUG((CLGRP, DALVL|TILVL, "GVSDT: LocalBuf = `%s'", LocalBuf)) ;
        }

        _tcscpy( separators, dtseps);
        _tcscat( separators, TEXT(";") );
        if (*(dtstr = TokStr(LocalBuf,separators, TS_SDTOKENS )) == NULLC)
            return( SUCCESS ) ;    /* If empty input, return   */

/*  - Fill date/time buffer with correct date time and overlay that
 *        of the user
 */
        GetLocalTime( &OsDateAndTime );


        if (((call == EDATE) ? VerifyDateString(&OsDateAndTime,dtstr,dtseps) :
             VerifyTimeString(&OsDateAndTime,dtstr,dtseps))) {

            if (SetDateTime( &OsDateAndTime )) {
                return( SUCCESS ) ;
            } else {
                if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD) {
                    PutStdErr(GetLastError(),NOARGS);
                    return( FAILURE );
                }
            }
        }

        DEBUG((CLGRP, DALVL|TILVL, "GVSDT: Bad date/time entered.")) ;

        PutStdOut(((call == EDATE) ? MSG_INVALID_DATE : MSG_REN_INVALID_TIME), NOARGS);
        *dtstr = NULLC ;
    }
    return( SUCCESS );
}


/***    VerifyDateString - verifies a date string
 *
 *  Purpose:
 *      To verify a date string and load it into OsDateAndTime.
 *
 *  VerifyDateString(TCHAR *dtoks, TCHAR *dseps)
 *
 *  Args:
 *      OsDateAndTime - where to store output numbers.
 *      dtoks - tokenized date string
 *      dseps - valid date separator characters
 *
 *  Returns:
 *      TRUE if the date string is valid.
 *      FALSE if the date string is invalid.
 *
 */

VerifyDateString(OsDateAndTime, dtoks, dseps)
LPSYSTEMTIME OsDateAndTime ;
TCHAR *dtoks ;
TCHAR *dseps ;
{
    int indexes[3] ;                /* Storage for date elements       */
    int i ;                         /* Work variable                   */
    int y, d, m ;                   /* Array indexes                   */

    switch (DateFormat) {   /* Set array according to date format   */
    case MMDDYY:
        m = 0 ;
        d = 1 ;
        y = 2 ;
        break ;

    case YYMMDD:
        y = 0 ;
        m = 1 ;
        d = 2 ;
        break ;

    default:
        d = 0 ;
        m = 1 ;
        y = 2 ;
    }

    DEBUG((CLGRP, DALVL, "VDATES: m = %d, d = %d, y = %d", m, d, y)) ;

/*  Loop through the tokens in dtoks, and load them into the array.  Note
 *  that the separators are also tokens in the string requiring the token
 *  pointer to be advanced twice for each element.
 */
    for (i = 0 ; i < 3 ; i++, dtoks += _tcslen(dtoks)+1) {
        TCHAR *j;
        int Length;

        DEBUG((CLGRP, DALVL, "VDATES: i = %d  dtoks = `%ws'", i, dtoks)) ;


        //
        //  The atoi() return code will not suffice to reject date field strings with
        //  non-digit characters.  It is zero, both for error and for the valid integer
        //  zero.  Also, a string like "8$" will return 8.  For that reason, each
        //  character must be tested.
        //

        j = dtoks;
        while (*j != TEXT( '\0' )) {
            if (!_istdigit( *j )) {
                return FALSE;
            }
            j++;
        }

        //
        //  Verify lengths:
        //      years can be 2 or 4 chars in length
        //      Days can be 1 or 2 chars in length
        //      Months can be 1 or 2 chars in length
        //

        indexes[i] = _tcstol(dtoks, NULL, 10) ;

        Length = (int)(j - dtoks);
        if (i == y) {
            if (Length != 2 && Length != 4) {
                return FALSE;
            } else if (Length == 4 && indexes[i] < 1600) {
                return FALSE;
            }
        } else
            if (Length != 1 && Length != 2) {
            return FALSE;
        }


        dtoks = j + 1;
        DEBUG((CLGRP, DALVL, "VDATES: *dtoks = %02x", *dtoks)) ;

        if (i < 2 && (!*dtoks || !_tcschr(dseps, *dtoks)))
            return(FALSE) ;
    }

    //
    // FIX,FIX - need to calculate OsDateAndTime->wDayOfWeek
    //

    OsDateAndTime->wDay = (WORD)indexes[d] ;
    OsDateAndTime->wMonth = (WORD)indexes[m] ;

    //
    //  Take two-digit years and convert them appropriately:
    //      80...99 => 1980...1999
    //      00...79 => 2000...2079
    //
    //  Four-digit years are taken at face value
    //

    if (indexes[y] < 0) {
        return FALSE;
    } else if (00 <= indexes[y] && indexes[y] <= 79) {
        indexes[y] += 2000;
    } else if (80 <= indexes[y] && indexes[y] <= 99) {
        indexes[y] += 1900;
    } else if (100 <= indexes[y] && indexes[y] <= 1979) {
        return FALSE;
    }

    OsDateAndTime->wYear = (WORD)indexes[y] ;
    return(TRUE) ;
}




/***    VerifyTimeString - verifies a time string
 *
 *  Purpose:
 *      To verify a date string and load it into OsDateAndTime.
 *
 *  VerifyTimeString(TCHAR *ttoks)
 *
 *  Args:             /
 *      OsDateAndTime - where to store output numbers.
 *      ttoks - Tokenized time string.  NOTE: Each time field and each
 *              separator field is an individual token in the time string.
 *              Thus the token advancing formula "str += mystrlen(str)+1",
 *              must be used twice to go from one time field to the next.
 *
 *  Returns:
 *      TRUE if the time string is valid.
 *      FALSE if the time string is invalid.
 *
 */

VerifyTimeString(OsDateAndTime, ttoks, tseps)
LPSYSTEMTIME OsDateAndTime ;
TCHAR *ttoks ;
TCHAR *tseps ;
{
    int i ;     /* Work variables    */
    int j ;
    TCHAR *p1, *p2;
    WORD *pp;
    TCHAR tsuffixes[] = TEXT("aApP");

    p2 = &tseps[ 1 ];

    pp = &OsDateAndTime->wHour;

    for (i = 0 ; i < 4 ; i++, ttoks += mystrlen(ttoks)+1) {

        DEBUG((CLGRP,TILVL, "VTIMES: ttoks = `%ws'  i = %d", ttoks, i)) ;

/* First insure that field is <= 2 bytes and they are digits.  Note this
 * also verifies that field is present.
 */

        if ((j = mystrlen(ttoks)) > 2 ||
            !_istdigit(*ttoks) ||
            (*(ttoks+1) && !_istdigit(*(ttoks+1))))
            break;

        *pp++ = (TCHAR)_tcstol(ttoks, NULL, 10) ;     /* Field OK, store int     */
        ttoks += j+1 ;                  /* Adv to separator tok    */

        DEBUG((CLGRP, TILVL, "VTIMES: separator = `%ws'", ttoks)) ;

        if (!*ttoks)                    /* No separator field?     */
            break ;                     /* If so, exit loop        */

/*  handle AM or PM
 */
        if (mystrchr(tsuffixes, *ttoks)) {
            goto HandleAMPM;
        }
/*  M000 - Fixed ability to use '.' as separator for time strings
 */
        if ( i < 2 ) {
            if ( ! (p1 = mystrchr(tseps, *ttoks) ) )
                return(FALSE) ;

        } else {
            if (*ttoks != *p2)              /* Is decimal seperator */
                return(FALSE) ;     /* valid.               */
        }
    } ;

    //
    // see if there's an a or p specified.  if there's a P, adjust
    // for PM time
    //

    if (*ttoks) {
        BOOL pm;
        if (!mystrchr(tsuffixes, *ttoks)) {
            return FALSE;
        }
        HandleAMPM:
        pm = (*ttoks == TEXT('p') ||  *ttoks == TEXT('P'));

        // if we're here, we've encountered an 'a' or 'p'.  make
        // sure that it's the last character or that the only
        // character left is an 'm'.  remember that since
        // 'a' and 'p' are separators, they get separated from the 'm'.

        ttoks += 2; // go past 'a' or 'p' plus null.
        if (*ttoks != NULLC &&
            *ttoks != TEXT('m') &&
            *ttoks != TEXT('M')) {
            return FALSE;
        }
        if (pm) {
            if (OsDateAndTime->wHour != 12) {
                OsDateAndTime->wHour += 12;
            }
        } else {
            if (OsDateAndTime->wHour == 12) {
                OsDateAndTime->wHour -= 12;
            }
        }
    }


/*  M002 - If we got at least one field, fill the rest with 00's
 */
    while (++i < 4)
        *pp++ = 0 ;

    return(TRUE) ;
}

VOID
ConverttmToFILETIME (
                    struct tm *Time,
                    LPFILETIME FileTime
                    )

/*++

Routine Description:

    This routine converts an NtTime value to its corresponding Fat time
    value.

Arguments:

    Time - Supplies the C Runtime Time value to convert from

    FileTime - Receives the equivalent File date and time

Return Value:

    BOOLEAN - TRUE if the Nt time value is within the range of Fat's
        time range, and FALSE otherwise

--*/

{
    SYSTEMTIME SystemTime;

    if (!Time) {
        GetSystemTime(&SystemTime);
    } else {

        //
        //  Pack the input time/date into a system time record
        //

        SystemTime.wYear      = (WORD)Time->tm_year;
        SystemTime.wMonth         = (WORD)(Time->tm_mon+1);     // C is [0..11]
        // NT is [1..12]
        SystemTime.wDay       = (WORD)Time->tm_mday;
        SystemTime.wHour      = (WORD)Time->tm_hour;
        SystemTime.wMinute    = (WORD)Time->tm_min;
        SystemTime.wSecond    = (WORD)Time->tm_sec;
        SystemTime.wDayOfWeek = (WORD)Time->tm_wday;
        SystemTime.wMilliseconds = 0;
    }
    SystemTimeToFileTime( &SystemTime, FileTime );

}

VOID
ConvertFILETIMETotm (
                    LPFILETIME FileTime,
                    struct tm *Time
                    )

/*++

Routine Description:

    This routine converts a file time to its corresponding C Runtime time
    value.

Arguments:

    FileTime - Supplies the File date and time to convert from

    Time - Receives the equivalent C Runtime Time value

Return Value:

--*/

{
    SYSTEMTIME SystemTime;

    // why skip printing the date if it's invalid?
    //if (FileTime->dwLowDateTime == 0 && FileTime->dwHighDateTime == 0) {
    //    return( FALSE );
    //    }

    FileTimeToSystemTime( FileTime, &SystemTime );


    //
    //  Pack the input time/date into a time field record
    //

    Time->tm_year         = SystemTime.wYear;
    Time->tm_mon          = SystemTime.wMonth-1;    // NT is [1..12]
                                                    // C is [0..11]
    Time->tm_mday         = SystemTime.wDay;
    Time->tm_hour         = SystemTime.wHour;
    Time->tm_min          = SystemTime.wMinute;
    Time->tm_sec          = SystemTime.wSecond;
    Time->tm_wday         = SystemTime.wDayOfWeek;
    Time->tm_yday         = 0;
    Time->tm_isdst        = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\wmiprovider\util.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Util.cpp
//
//  Description:
//      Implementation of utility class and functions
//
//  Maintained by:
//      Ozan Ozhan  (OzanO)     26-NOV-2002
//      Henry Wang  (HenryWa)   24-AUG-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "Cluster.h"
#include "ClusterResource.h"
#include "ClusterNode.h"
#include "ClusterGroup.h"
#include "ClusterNodeRes.h"
#include "ClusterResourceType.h"

//////////////////////////////////////////////////////////////////////////////
//  Global Data
//////////////////////////////////////////////////////////////////////////////

// CLUSTER
const WCHAR * const PVD_CLASS_CLUSTER               = L"MSCluster_Cluster";
const WCHAR * const PVD_CLASS_CLUSTERTONETWORK      = L"MSCluster_ClusterToNetwork";
const WCHAR * const PVD_CLASS_CLUSTERTONETINTERFACE = L"MSCluster_ClusterToNetworkInterface";
const WCHAR * const PVD_CLASS_CLUSTERTONODE         = L"MSCluster_ClusterToNode";
const WCHAR * const PVD_CLASS_CLUSTERTOQUORUMRES    = L"MSCluster_ClusterToQuorumResource";
const WCHAR * const PVD_CLASS_CLUSTERTORES          = L"MSCluster_ClusterToResource";
const WCHAR * const PVD_CLASS_CLUSTERTORESTYPE      = L"MSCluster_ClusterToResourceType";
const WCHAR * const PVD_CLASS_CLUSTERTOGROUP        = L"MSCluster_ClusterToResourceGroup";

const WCHAR * const PVD_PROP_CLUSTER_NAME               = L"Name";
const WCHAR * const PVD_PROP_CLUSTER_SECURITY           = L"Security";
const WCHAR * const PVD_PROP_CLUSTER_SECURITYDESCRIPTOR = L"Security_Descriptor";
const WCHAR * const PVD_PROP_CLUSTER_GROUPADMIN         = L"GroupAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_NODEADMIN          = L"NodeAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_RESADMIN           = L"ResourceAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_RESTYPEADMIN       = L"ResourceTypeAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_NETWORKADMIN       = L"NetworkAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_NETINTFACEADMIN    = L"NetworkInterfaceAdminExtensions";
const WCHAR * const PVD_PROP_CLUSTER_FILE               = L"MaintenanceFile";
const WCHAR * const PVD_PROP_CLUSTER_LOGSIZE            = L"QuorumLogFileSize";
const WCHAR * const PVD_PROP_CLUSTER_NETWORK            = L"NetworkPriorities";
const WCHAR * const PVD_PROP_CLUSTER_MAX_NODES          = L"MaxNumberOfNodes";

const WCHAR * const CLUS_CLUS_GROUPADMIN        = L"Groups\\AdminExtensions";
const WCHAR * const CLUS_CLUS_NETWORKADMIN      = L"Networks\\AdminExtensions";
const WCHAR * const CLUS_CLUS_NETINTERFACEADMIN = L"NetworkInterfaces\\AdminExtensions";
const WCHAR * const CLUS_CLUS_NODEADMIN         = L"Nodes\\AdminExtensions";
const WCHAR * const CLUS_CLUS_RESADMIN          = L"Resources\\AdminExtensions";
const WCHAR * const CLUS_CLUS_RESTYPEADMIN      = L"ResourceTypes\\AdminExtensions";

const WCHAR * const PVD_MTH_CLUSTER_RENAME              = L"Rename";
const WCHAR * const PVD_MTH_CLUSTER_SETQUORUM           = L"SetQuorumResource";
const WCHAR * const PVD_MTH_CLUSTER_GETNODECLUSTERSTATE = L"GetNodeClusterState";

const WCHAR * const PVD_MTH_CLUSTER_PARM_NEWNAME        = L"NewName";
const WCHAR * const PVD_MTH_CLUSTER_PARM_RESOURCE       = L"Resource";
const WCHAR * const PVD_MTH_CLUSTER_PARM_CLUSTERSTATE   = L"ClusterState";

// NODE
const WCHAR * const PVD_CLASS_NODE                  = L"MSCluster_Node";
const WCHAR * const PVD_CLASS_NODETOACTIVEGROUP     = L"MSCluster_NodeToActiveGroup";
const WCHAR * const PVD_CLASS_NODETONETINTERFACE    = L"MSCluster_NodeToNetworkInterface";
const WCHAR * const PVD_CLASS_NODETOACTIVERES       = L"MSCluster_NodeToActiveResource";

const WCHAR * const PVD_PROP_NODE_NAME = L"Name";

// RESOURCE
const WCHAR * const PVD_CLASS_RESOURCE          = L"MSCluster_Resource";
const WCHAR * const PVD_CLASS_RESDEPRES         = L"MSCluster_ResourceToDependentResource";
const WCHAR * const PVD_CLASS_RESTYPERESOURCE   = L"MSCluster_ResourceTypeToResource";
const WCHAR * const PVD_CLASS_RESOURCENODE      = L"MSCluster_ResourceToPossibleOwner";

const WCHAR * const PVD_PROP_RES_NAME		= L"Name";
const WCHAR * const PVD_PROP_RES_STATE		= L"State";
const WCHAR * const PVD_PROP_RES_PRIVATE	= L"PrivateProperties";
const WCHAR * const PVD_PROP_RES_CHECKPOINTS = L"RegistryCheckpoints";
const WCHAR * const PVD_PROP_RES_CRYPTO_CHECKPOINTS = L"CryptoCheckpoints";
const WCHAR * const PVD_PROP_RES_CORE_RESOURCE = L"CoreResource";

const WCHAR * const PVD_MTH_RES_ONLINE              = L"BringOnline";
const WCHAR * const PVD_MTH_RES_OFFLINE             = L"TakeOffline";
const WCHAR * const PVD_MTH_RES_ADD_DEPENDENCY      = L"AddDependency";
const WCHAR * const PVD_MTH_RES_CHANGE_GROUP        = L"MoveToNewGroup";
const WCHAR * const PVD_MTH_RES_CREATE_RESOURCE     = L"CreateResource";
const WCHAR * const PVD_MTH_RES_FAIL_RESOURCE       = L"FailResource";
const WCHAR * const PVD_MTH_RES_REMOVE_DEPENDENCY   = L"RemoveDependency";
const WCHAR * const PVD_MTH_RES_RENAME              = L"Rename";
const WCHAR * const PVD_MTH_RES_DELETE_RESOURCE    = L"DeleteResource";
const WCHAR * const PVD_MTH_RES_ADD_REG_CHECKPOINT = L"AddRegistryCheckpoint";
const WCHAR * const PVD_MTH_RES_DEL_REG_CHECKPOINT = L"RemoveRegistryCheckpoint";
const WCHAR * const PVD_MTH_RES_ADD_CRYPTO_CHECKPOINT = L"AddCryptoCheckpoint";
const WCHAR * const PVD_MTH_RES_DEL_CRYPTO_CHECKPOINT = L"RemoveCryptoCheckpoint";
const WCHAR * const PVD_MTH_PARM_RESOURCE           = L"Resource";
const WCHAR * const PVD_MTH_PARM_GROUP              = L"Group";
const WCHAR * const PVD_MTH_PARM_NEWNAME            = L"NewName";
const WCHAR * const PVD_MTH_PARM_RES_NAME           = L"ResourceName";
const WCHAR * const PVD_MTH_PARM_RES_TYPE           = L"ResourceType";
const WCHAR * const PVD_MTH_PARM_SEP_MONITOR        = L"SeparateMonitor";
const WCHAR * const PVD_MTH_PARM_RES_CHECKPOINT_NAME = L"CheckpointName";
const WCHAR * const PVD_MTH_PARM_RES_TIMEOUT        = L"TimeOut";

// Resource Type
const WCHAR * const PVD_CLASS_RESOURCETYPE  = L"MSCluster_ResourceType";
const WCHAR * const PVD_PROP_RESTYPE_NAME   = L"Name";
const WCHAR * const PVD_PROP_RESTYPE_QUORUM_CAPABLE = L"QuorumCapable";
const WCHAR * const PVD_PROP_RESTYPE_LOCALQUORUM_CAPABLE = L"LocalQuorumCapable";
const WCHAR * const PVD_PROP_RESTYPE_DELETE_REQUIRES_ALL_NODES = L"DeleteRequiresAllNodes";
const WCHAR * const PVD_MTH_RESTYPE_CREATE_RESOURCETYPE = L"CreateResourceType";
const WCHAR * const PVD_MTH_RESTYPE_DELETE_RESOURCETYPE = L"DeleteResourceType";
const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_NAME = L"Name";
const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_DISPLAYNAME = L"DisplayName";
const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_DLLNAME = L"DLLName";
const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_LOOKSALIVE = L"LooksAlivePollInterval";
const WCHAR * const PVD_MTH_RESTYPE_PARM_RESTYPE_ISALIVE = L"IsAlivePollInterval";

// GROUP
const WCHAR * const PVD_CLASS_GROUP         = L"MSCluster_ResourceGroup";
const WCHAR * const PVD_CLASS_GROUPTORES    = L"MSCluster_ResourceGroupToResource";
const WCHAR * const PVD_CLASS_GROUPNODE     = L"MSCluster_ResourceGroupToPreferredNode";

const WCHAR * const PVD_PROP_GROUP_NAME = L"Name";
const WCHAR * const PVD_PROP_GROUP_STATE = L"State";
const WCHAR * const PVD_PROP_NODELIST   = L"PreferredNodeList";

const WCHAR * const PVD_MTH_GROUP_CREATEGROUP       = L"CreateGroup";
const WCHAR * const PVD_MTH_GROUP_DELETEGROUP       = L"DeleteGroup";
const WCHAR * const PVD_MTH_GROUP_TAKEOFFLINE       = L"TakeOffLine";
const WCHAR * const PVD_MTH_GROUP_BRINGONLINE       = L"BringOnLine";
const WCHAR * const PVD_MTH_GROUP_MOVETONEWNODE     = L"MoveToNewNode";
const WCHAR * const PVD_MTH_GROUP_DELETE            = L"Delete";
const WCHAR * const PVD_MTH_GROUP_RENAME            = L"Rename";
const WCHAR * const PVD_MTH_GROUP_PARM_GROUPNAME    = L"GroupName";
const WCHAR * const PVD_MTH_GROUP_PARM_NODENAME     = L"NodeName";
const WCHAR * const PVD_MTH_GROUP_PARM_NEWNAME      = L"NewName";
const WCHAR * const PVD_MTH_GROUP_PARM_TIMEOUT      = L"TimeOut";


// NetworkInterface
const WCHAR * const PVD_CLASS_NETWORKINTERFACE = L"MSCluster_NetworkInterface";
const WCHAR * const PVD_PROP_NETINTERFACE_NAME   = L"Name";
const WCHAR * const PVD_PROP_NETINTERFACE_DEVICEID      = L"DeviceId";
const WCHAR * const PVD_PROP_NETINTERFACE_SYSTEMNAME    = L"SystemName";
const WCHAR * const PVD_PROP_NETINTERFACE_STATE         = L"State";


// networks
const WCHAR * const PVD_CLASS_NETWORK          = L"MSCluster_Network";
const WCHAR * const PVD_CLASS_NETTONETINTERFACE = L"MSCluster_NetworkToNetworkInterface";

const WCHAR * const PVD_PROP_NETWORK_STATE = L"State";

const WCHAR * const PVD_MTH_NETWORK_RENAME          = L"Rename";
const WCHAR * const PVD_MTH_NETWORK_PARM_NEWNAME    = L"NewName";

// service
const WCHAR * const PVD_CLASS_SERVICES          = L"MSCluster_Service";
const WCHAR * const PVD_CLASS_HOSTEDSERVICES    = L"MSCluster_NodeToHostedService";

const WCHAR * const PVD_PROP_SERVICE_NAME       = L"Name";
const WCHAR * const PVD_PROP_SERVICE_SYSTEMNAME = L"SystemName";

const WCHAR * const PVD_MTH_SERVICE_PAUSE   = L"Pause";
const WCHAR * const PVD_MTH_SERVICE_RESUME  = L"Resume";

// event

const WCHAR * const PVD_CLASS_EVENT             = L"MSCluster_Event";
const WCHAR * const PVD_PROP_EVENT_NAME         = L"EventObjectName";
const WCHAR * const PVD_PROP_EVENT_PATH         = L"EventObjectPath";
const WCHAR * const PVD_PROP_EVENT_TYPE         = L"EventObjectType";
const WCHAR * const PVD_PROP_EVENT_TYPEMAJOR    = L"EventTypeMajor";
const WCHAR * const PVD_PROP_EVENT_TYPEMINOR    = L"EventTypeMinor";
const WCHAR * const PVD_PROP_EVENT_NEWSTATE     = L"EventNewState";
const WCHAR * const PVD_PROP_EVENT_NODE         = L"EventNode";
const WCHAR * const PVD_PROP_EVENT_GROUP        = L"EventGroup";


const WCHAR * const PVD_CLASS_EVENT_ADD                 = L"MSCluster_EventObjectAdd";
const WCHAR * const PVD_CLASS_EVENT_REMOVE              = L"MSCluster_EventObjectRemove";
const WCHAR * const PVD_CLASS_EVENT_STATECHANGE         = L"MSCluster_EventStateChange";
const WCHAR * const PVD_CLASS_EVENT_GROUPSTATECHANGE    = L"MSCluster_EventGroupStateChange";
const WCHAR * const PVD_CLASS_EVENT_RESOURCESTATECHANGE = L"MSCluster_EventResourceStateChange";
const WCHAR * const PVD_CLASS_EVENT_PROP                = L"MSCluster_EventPropertyChange";

const WCHAR * const PVD_CLASS_PROPERTY      = L"MSCluster_Property";

const WCHAR * const PVD_PROP_NAME           = L"Name";
const WCHAR * const PVD_PROP_STATE          = L"State";
const WCHAR * const PVD_PROP_GROUPCOMPONENT = L"GroupComponent";
const WCHAR * const PVD_PROP_PARTCOMPONENT  = L"PartComponent";
const WCHAR * const PVD_PROP_CHARACTERISTIC = L"characteristics";
const WCHAR * const PVD_PROP_FLAGS          = L"Flags";

//
// wbem
//
const WCHAR * const PVD_WBEM_EXTENDEDSTATUS     = L"__ExtendedStatus";
const WCHAR * const PVD_WBEM_DESCRIPTION        = L"Description";
const WCHAR * const PVD_WBEM_STATUSCODE         = L"StatusCode";
const WCHAR * const PVD_WBEM_STATUS             = L"Status";
const WCHAR * const PVD_WBEM_CLASS              = L"__CLASS";
const WCHAR * const PVD_WBEM_RELPATH            = L"__Relpath";
const WCHAR * const PVD_WBEM_PROP_ANTECEDENT    = L"Antecedent";
const WCHAR * const PVD_WBEM_PROP_DEPENDENT     = L"Dependent";
const WCHAR * const PVD_WBEM_PROP_DEVICEID      = L"DeviceId";
const WCHAR * const PVD_WBEM_QUA_DYNAMIC        = L"Dynamic";
const WCHAR * const PVD_WBEM_QUA_CIMTYPE        = L"CIMTYPE";

const WCHAR * const PVD_WBEM_QUA_PROV_VALUE = L"MS_CLUSTER_PROVIDER";
const WCHAR * const PVD_WBEM_QUA_PROV_NAME  = L"Provider";

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CreateClass(
//      const WCHAR *           pwszClassNameIn,
//      CWbemServices *         pNamespaceIn,
//      auto_ptr< CProvBase > & rNewClassInout
//      )
//
//  Description:
//      Create the specified class
//
//  Arguments:
//      pwszClassNameIn     -- Name of the class to create.
//      pNamespaceIn        -- WMI namespace
//      rNewClassInout      -- Receives the new class.
//
//  Return Values:
//      reference to the array of property maping table
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CreateClass(
    const WCHAR *           pwszClassNameIn,
    CWbemServices *         pNamespaceIn,
    auto_ptr< CProvBase > & rNewClassInout
    )
{
    CClassCreator & rcc = g_ClassMap[ pwszClassNameIn ];
    if ( rcc.m_pfnConstructor != NULL )
    {
        auto_ptr< CProvBase > pBase(
            rcc.m_pfnConstructor(
                rcc.m_pbstrClassName,
                pNamespaceIn,
                rcc.m_dwEnumType
                )
            );
            rNewClassInout = pBase;
    }
    else
    {
        throw CProvException( static_cast< HRESULT >( WBEM_E_INVALID_PARAMETER ) );
    }

    return;

} //*** void CreateClass()

//****************************************************************************
//
//  PropMapEntryArray
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  SPropMapEntryArray::PwszLookup(
//      LPCWSTR     pwszIn
//      ) const
//
//  Description:
//      Lookup an entry in the array.
//
//  Arguments:
//      pwszIn      -- Name of entry to lookup.
//
//  Return Values:
//      Pointer to string entry in the array.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPCWSTR
SPropMapEntryArray::PwszLookup(
    LPCWSTR     pwszIn
    ) const
{
    UINT idx;

    for ( idx = 0; idx < m_dwSize; idx ++ )
    {
        if ( ClRtlStrICmp( pwszIn, m_pArray[ idx ].clstName ) == 0 )
        {
            //
            // mofName is NULL for clstname not supported
            //
            return m_pArray[ idx ].mofName;
        }
    }

    //
    // mofname is the same as clstname if not found in the table
    //
    return pwszIn;

} //*** SPropMapEntry::PwszLookup()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LPCWSTR
//  PwszSpaceReplace(
//      LPWSTR      pwszTrgInout,
//      LPCWSTR     pwszSrcIn,
//      WCHAR       wchArgIn
//      )
//
//  Description:
//      Replace spaces in a string with another character.
//      Ignores leading spaces.
//
//  Arguments:
//      pwszTrgInout    -- Target string.
//      pwszSrcIn       -- Source string.
//      wchArgIn        -- Character to replace spaces with.
//
//  Return Values:
//      Pointer to the target string.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPWSTR
PwszSpaceReplace(
    LPWSTR      pwszTrgInout,
    LPCWSTR     pwszSrcIn,
    WCHAR       wchArgIn
    )
{
    LPCWSTR pwsz = NULL;
    LPWSTR  pwszTrg = NULL;

    if ( ( pwszTrgInout == NULL ) || ( pwszSrcIn == NULL ) )
    {
        return NULL;
    }

    //
    // ignore leading space
    //
    for ( pwsz = pwszSrcIn ; *pwsz == L' '; pwsz++ )
    {
        // empty loop
    }
    pwszTrg = pwszTrgInout;
    for ( ; *pwsz != L'\0' ; pwsz++ )
    {
        if ( *pwsz == L' ' )
        {
            *pwszTrg++  = wchArgIn;
            for ( ; *pwsz == L' '; pwsz++ )
            {
                // empty loop
            }
            pwsz--;
        }
        else
        {
            *pwszTrg++  = *pwsz;
        }
    } // for: each character in the source string

    *pwszTrg = L'\0';
    return pwszTrgInout;

} //*** PwszSpaceReplace()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cdata.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cdata.c

Abstract:

    Global data

--*/

#include "cmd.h"

TCHAR CrLf[]     = TEXT("\r\n");                        // M022
TCHAR DBkSpc[] = TEXT("\b \b");         // M022
#if defined(FE_SB)
TCHAR DDBkSpc[] = TEXT("\b\b  \b\b");
#endif // defined(FE_SB)

//
// M010 - std_(e)printf format strings
//

TCHAR Fmt00[] = TEXT("   ");
TCHAR Fmt01[] = TEXT("  ");
TCHAR Fmt02[] = TEXT(" %s ");
TCHAR Fmt03[] = TEXT("%-9s%-4s");
TCHAR Fmt04[] = TEXT("%02d%s%02d%s");                //  DD/DD?
TCHAR Fmt05[] = TEXT("%2d%s%02d%s%02d");            //  DD/DD/DD
TCHAR Fmt06[] = TEXT("%2d%s%02d%s%02d%s%02d");      //  DD:DD:DD.DD
TCHAR Fmt08[] = TEXT("%10lu  ");
TCHAR Fmt09[] = TEXT("[%s]");
TCHAR Fmt10[] = TEXT("%02d%s%02d%s%02d");           //  OO/DD/DD
TCHAR Fmt11[] = TEXT("%s ");
TCHAR Fmt12[] = TEXT("%s %s%s ");
TCHAR Fmt13[] = TEXT("(%s) %s ");
TCHAR Fmt15[] = TEXT("%s %s ");
TCHAR Fmt16[] = TEXT("%s=%s\r\n");
TCHAR Fmt17[] = TEXT("%s\r\n");
TCHAR Fmt18[] = TEXT("%c%c");                       // M016 - I/O redirection echo
TCHAR Fmt19[] = TEXT("%c");
TCHAR Fmt20[] = TEXT(">");                          // M016 - Additional append symbol
TCHAR Fmt21[] = TEXT("  %03d");
TCHAR Fmt22[] = TEXT("%s%s  %03d");
TCHAR Fmt26[] = TEXT("%04X-%04X");                  // for volume serial number
TCHAR Fmt27[] = TEXT("%s>");                        // default prompt string


//
// M010 - command name strings
//


TCHAR AppendStr[]   = TEXT("DPATH");        // @@ - Added APPEND command
TCHAR CallStr[]     = TEXT("CALL");         // M005 - Added CALL command
TCHAR CdStr[]       = TEXT("CD");
TCHAR ColorStr[]    = TEXT("COLOR");
TCHAR TitleStr[]    = TEXT("TITLE");
TCHAR ChdirStr[]    = TEXT("CHDIR");
TCHAR ClsStr[]      = TEXT("CLS");
TCHAR CmdExtVerStr[]= TEXT("CMDEXTVERSION");
TCHAR DefinedStr[]  = TEXT("DEFINED");
TCHAR CopyStr[]     = TEXT("COPY");
TCHAR CPathStr[]    = TEXT("PATH");
TCHAR CPromptStr[]  = TEXT("PROMPT");

TCHAR PushDirStr[]  = TEXT("PUSHD");
TCHAR PopDirStr[]   = TEXT("POPD");
TCHAR AssocStr[]    = TEXT("ASSOC");
TCHAR FTypeStr[]    = TEXT("FTYPE");

TCHAR DatStr[]      = TEXT("DATE");
TCHAR DelStr[]      = TEXT("DEL");
TCHAR DirStr[]      = TEXT("DIR");
TCHAR DoStr[]       = TEXT("DO");

TCHAR EchoStr[]     = TEXT("ECHO");
TCHAR ElseStr[]     = TEXT("ELSE");
TCHAR EndlocalStr[] = TEXT("ENDLOCAL");     // M004 - For Endlocal command
TCHAR EraStr[]      = TEXT("ERASE");
TCHAR ErrStr[]      = TEXT("ERRORLEVEL");
TCHAR ExitStr[]     = TEXT("EXIT");
TCHAR ExsStr[]      = TEXT("EXIST");
TCHAR BreakStr[]    = TEXT("BREAK");
#if 0
TCHAR ExtprocStr[]  = TEXT("EXTPROC");      // M007 - For EXTPROC command
#endif

TCHAR ForStr[]      = TEXT("FOR");
TCHAR ForHelpStr[]  = TEXT("FOR/?");
TCHAR ForLoopStr[]  = TEXT("/L");
TCHAR ForDirTooStr[]= TEXT("/D");
TCHAR ForParseStr[] = TEXT("/F");
TCHAR ForRecurseStr[]=TEXT("/R");

TCHAR GotoStr[]     = TEXT("GOTO");
TCHAR GotoEofStr[]  = TEXT(":EOF");

TCHAR IfStr[]       = TEXT("IF");
TCHAR IfHelpStr[]   = TEXT("IF/?");
TCHAR InStr[]       = TEXT("IN");
CHAR  InternalError[] = "\nCMD Internal Error %s\n";      // M028  10,...,10

TCHAR KeysStr[]     = TEXT("KEYS");         // @@5 - Keys internal command

TCHAR MkdirStr[]    = TEXT("MKDIR");
TCHAR MdStr[]       = TEXT("MD");

TCHAR NotStr[]      = TEXT("NOT");

TCHAR PausStr[]     = TEXT("PAUSE");

TCHAR RdStr[]       = TEXT("RD");
TCHAR RemStr[]      = TEXT("REM");
TCHAR RemHelpStr[]  = TEXT("REM/?");
TCHAR MovStr[]      = TEXT("MOVE");
TCHAR RenamStr[]    = TEXT("RENAME");
TCHAR RenStr[]      = TEXT("REN");
TCHAR RmdirStr[]    = TEXT("RMDIR");

TCHAR SetStr[]      = TEXT("SET");
TCHAR SetArithStr[] = TEXT("/A");
TCHAR SetPromptStr[]= TEXT("/P");
TCHAR SetlocalStr[] = TEXT("SETLOCAL");     // M004 - For Setlocal command
TCHAR ShiftStr[]    = TEXT("SHIFT");
TCHAR StartStr[]    = TEXT("START");        // @@ - Start Command

TCHAR TimStr[]      = TEXT("TIME");
TCHAR TypStr[]      = TEXT("TYPE");

TCHAR VeriStr[]     = TEXT("VERIFY");
TCHAR VerStr[]      = TEXT("VER");
TCHAR VolStr[]      = TEXT("VOL");


//
// Strings for string compares
//

TCHAR BatExt[]      = TEXT(".BAT");         // @@ old bat file extionsion
TCHAR CmdExt[]      = TEXT(".CMD");         // @@ new bat file extionsion

TCHAR ComSpec[]     = TEXT("\\CMD.EXE");          // M017
TCHAR ComSpecStr[]  = TEXT("COMSPEC");
TCHAR ComExt[]      = TEXT(".COM");

TCHAR Delimiters[]  = TEXT("=,;");
TCHAR Delim2[]      = TEXT(":.+/[]\\ \t\"");    // 20H,09H,22H;
TCHAR Delim3[]      = TEXT("=,");               // Delimiters - no semicolon
TCHAR Delim4[]      = TEXT("=,;+/[] \t\"");     // Command delimeters - no path characters
TCHAR Delim5[]      = TEXT(":.\\");             // Possible command delimeters - path characters
TCHAR DevNul[]      = TEXT("\\DEV\\NUL");

TCHAR ExeExt[]      = TEXT(".EXE");

TCHAR PathStr[]     = TEXT("PATH");
TCHAR PathExtStr[]  = TEXT("PATHEXT");
TCHAR PathExtDefaultStr[] = TEXT(".COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS");

TCHAR PromptStr[]   = TEXT("PROMPT");

TCHAR VolSrch[]     = TEXT(" :\\*");             // Vol ID search (ctools1.c)   LNS

//
// Character Definitions
//

TCHAR BSlash    = BSLASH;         // M017 - Restored this char
TCHAR DPSwitch  = TEXT('P');
TCHAR DWSwitch  = TEXT('W');
TCHAR EqualSign = EQ;
TCHAR PathChar  = BSLASH;         // M000
TCHAR PCSwitch  = TEXT('p');
TCHAR BCSwitch  = TEXT('k');              // @@ - add /K switch to cmd.exe
TCHAR SCSwitch  = TEXT('c');
TCHAR QCSwitch  = TEXT('q');              // @@dv - add /Q switch to cmd.exe
TCHAR DCSwitch  = TEXT('b');              // add /B switch to cmd.exe
TCHAR UCSwitch  = TEXT('u');              // add /U switch to cmd.exe
TCHAR ACSwitch  = TEXT('a');              // add /A switch to cmd.exe
TCHAR XCSwitch  = TEXT('x');              // add /X switch to cmd.exe
TCHAR YCSwitch  = TEXT('y');              // add /Y switch to cmd.exe
TCHAR SwitChar  = SWITCHAR;               // M000


//
//   TmpBuf is a TMPBUFLEN byte temporary buffer which can be used by any function
//   so long as the function's use does not confict with any of the other uses
//   of the buffer.  It is HIGHLY reccommended that this buffer be used in place
//   of mallocing data or declaring new global variables whenever possible.
//
//   Once you have determined that your new use of the buffer does not conflict
//   with current uses of the buffer, add an entry in the table below.
//
//
//    TCHAR RANGE
//    USED       WHERE USED     REFERENCED BY         HOW LONG NEEDED
//   -----------+-------------+---------------------+--------------------------
//      0 - 1024| cparse.c    | All of the parser   | During parsing and lexing
//              |             | via TokBuf          |
//      0 - 128 | cinit.c     | SetUpEnvironment()  | During init
//              |             | Init()              |
//      0 - 513 | cbatch.c    | BatLoop(), SetBat() | During batch processing
//              |             | eGoTo()             | During label search
//      0 - 141 | cfile.c     | DelWork()           | Tmp buffer for path
//      0 - 141 |             | RenWork()           | Tmp buffer for path
//
//
//   *** NOTE: In some circumstances it may be beneficial to break up allocation
//   of this buffer and intermix other labels in it. In this way, you can
//   address a particular portion of the buffer without having to declare
//   another variable in your code to do so.
//
//   *** WARNING ***  If this buffer is used incorrectly bad things may happen
//   Bugs which are EXTREMELY difficult to track down could be introduce
//   if we are not VERY careful using this buffer.
//
//   *** WARNING *** When referencing TmpBuf in C files, make sure that TmpBuf
//   is declared as an array; NOT as a pointer.
//
//


TCHAR   TmpBuf[TMPBUFLEN];
CHAR    AnsiBuf[LBUFLEN];

HMODULE hKernel32 = INVALID_HANDLE_VALUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cenv.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cenv.c

Abstract:

    Environment variable support

--*/

#include "cmd.h"

struct envdata {
    LPTSTR Strings;
} ;

struct envdata CmdEnv ;    // Holds info to manipulate Cmd's environment
struct envdata * OriginalEnvironment; // original environment setup used with eStart

extern TCHAR PathStr[], PromptStr[] ;
extern TCHAR AppendStr[]; /* @@ */

extern CHAR InternalError[] ;
extern TCHAR Fmt16[], Fmt17[], EnvErr[] ;
extern TCHAR SetArithStr[] ;
extern TCHAR SetPromptStr[] ;
extern unsigned flgwd ;
extern TCHAR CdStr[] ;
extern TCHAR DatStr[] ;
extern TCHAR TimStr[] ;
extern TCHAR ErrStr[] ;
extern TCHAR CmdExtVerStr[] ;

extern unsigned LastRetCode;
extern BOOL CtrlCSeen;
extern UINT CurrentCP;
extern BOOLEAN PromptValid;

extern int  glBatType;     // to distinguish OS/2 vs DOS errorlevel behavior depending on a script file name


int SetArithWork(TCHAR *tas);


unsigned
SetLastRetCodeIfError(
                     unsigned RetCode
                     )
{
    if (RetCode != 0) {
        LastRetCode = RetCode;
    }

    return RetCode;
}

/***    ePath - Begin the execution of a Path Command
 *
 *  Purpose:
 *      If the command has no argument display the current value of the PATH
 *      environment variable.  Otherwise, change the value of the Path
 *      environment variable to the argument.
 *
 *  int ePath(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the path command
 *
 *  Returns:
 *      If changing the PATH variable, whatever SetEnvVar() returns.
 *      SUCCESS, otherwise.
 *
 */

int ePath(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE) {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(PathWork( n, 1 )));
    } else {
        return( LastRetCode = PathWork( n, 1 ) );
    }

}

/***    eAppend - Entry point for Append routine
 *
 *  Purpose:
 *      to call Append and pass it a pointer to the command line
 *      arguments
 *
 *  Args:
 *      a pointer to the command node structure
 *
 */

int eAppend(n)
struct cmdnode *n ;
{

    if (glBatType != CMD_TYPE) {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(PathWork( n, 0 )));
    } else {
        return( LastRetCode = PathWork( n, 0 ) );
    }

}

int PathWork(n, flag)
struct cmdnode *n ;
int flag;   /* 0 = AppendStr, 1 = PathStr */
{
    TCHAR *tas ;    /* Tokenized argument string    */
    TCHAR c ;

    /*  M014 - If the only argument is a single ";", then we have to set
     *  a NULL path.
     */
    if ( n->argptr ) {
        c = *(EatWS(n->argptr, NULL)) ;
    } else {
        c = NULLC;
    }

    if ((!c || c == NLN) &&         /* If args are all whitespace      */
        mystrchr(n->argptr, TEXT(';'))) {

        return(SetEnvVar(flag ? PathStr : AppendStr, TEXT(""))) ;

    } else {

        tas = TokStr(n->argptr, TEXT(";"), TS_WSPACE | TS_NWSPACE) ;

        if (*tas) {
            return(SetEnvVar(flag ? PathStr : AppendStr, tas)) ;
        }

        cmd_printf(Fmt16, flag ? PathStr : AppendStr,
                   GetEnvVar(flag ? PathStr : AppendStr)) ;
    }
    return(SUCCESS) ;
}




/***    ePrompt - begin the execution of the Prompt command
 *
 *  Purpose:
 *      To modifiy the Prompt environment variable.
 *
 *  int ePrompt(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the prompt command
 *
 *  Returns:
 *      Whatever SetEnvVar() returns.
 *
 */

int ePrompt(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE) {
        //  if set command is executed from .bat file OR entered at command prompt
        return(SetLastRetCodeIfError(SetEnvVar(PromptStr, TokStr(n->argptr, NULL, TS_WSPACE)))) ;
    } else {
        return(LastRetCode = SetEnvVar(PromptStr, TokStr(n->argptr, NULL, TS_WSPACE)) ) ;
    }
}




/***    eSet - execute a Set command
 *
 *  Purpose:
 *      To set/modify an environment or to display the current environment
 *      contents.
 *
 *  int eSet(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the set command
 *
 *  Returns:
 *      If setting and the command is syntactically correct, whatever SetEnvVar()
 *      returns.  Otherwise, FAILURE.
 *
 *      If displaying, SUCCESS is always returned.
 *
 */

int eSet(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE) {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(SetWork( n )));
    } else {
        return( LastRetCode = SetWork( n ) );
    }
}

/***    SetPromptUser - set environment variable to value entered by user.
 *
 *  Purpose:
 *      Set environment variable to value entered by user.
 *
 *  int SetPromptUser(TCHAR *tas)
 *
 *  Args:
 *      tas - pointer to null terminated string of the form:
 *
 *          VARNAME=promptString
 *
 *  Returns:
 *      If valid expression, return SUCCESS otherwise FAILURE.
 *
 */

int SetPromptUser(TCHAR *tas)
{
    TCHAR *wptr;
    TCHAR *tptr;
    ULONG    dwOutputModeOld;
    ULONG    dwOutputModeCur;
    ULONG    dwInputModeOld;
    ULONG    dwInputModeCur;
    BOOLEAN  fOutputModeSet = FALSE;
    BOOLEAN  fInputModeSet = FALSE;
    HANDLE   hndStdOut = NULL;
    HANDLE   hndStdIn = NULL;
    DWORD    cch;
    TCHAR    szValueBuffer[ 1024 ];

    //
    // Find first non-blank argument.
    //
    if (tas != NULL)
        while (*tas && *tas <= SPACE)
            tas += 1;


    // If no input, declare an error
    //
    if (!tas || !*tas) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    //
    // See if first argument is quoted.  If so, strip off
    // leading quote, spaces and trailing quote.
    //
    if (*tas == QUOTE) {
        tas += 1;
        while (*tas && *tas <= SPACE)
            tas += 1;
        tptr = _tcsrchr(tas, QUOTE);
        if (tptr)
            *tptr = NULLC;
    }

    //
    // Find the equal sign in the argument.
    //
    wptr = _tcschr(tas, EQ);

    //
    // If no equal sign, error.
    //
    if (!wptr) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    //
    // Found the equal sign, so left of equal sign is variable name
    // and right of equal sign is prompt string.  Dont allow user to set
    // a variable name that begins with an equal sign, since those
    // are reserved for drive current directories.
    //
    *wptr++ = NULLC;

    //
    // See if second argument is quoted.  If so, strip off
    // leading quote, spaces and trailing quote.
    //
    if (*wptr == QUOTE) {
        wptr += 1;
        while (*wptr && *wptr <= SPACE)
            wptr += 1;
        tptr = _tcsrchr(wptr, QUOTE);
        if (tptr)
            *tptr = NULLC;
    }

    if (*wptr == EQ) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    hndStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (GetConsoleMode( hndStdOut, &dwOutputModeOld) ) {

        // make sure CRLF is processed correctly

        dwOutputModeCur = dwOutputModeOld | ENABLE_PROCESSED_OUTPUT;
        fOutputModeSet = TRUE;
        SetConsoleMode(hndStdOut,dwOutputModeCur);
        GetLastError();
    }

    hndStdIn = GetStdHandle(STD_INPUT_HANDLE);
    if (GetConsoleMode( hndStdIn, &dwInputModeOld) ) {

        // make sure input is processed correctly

        dwInputModeCur = dwInputModeOld | ENABLE_LINE_INPUT |
                         ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT;
        fInputModeSet = TRUE;
        SetConsoleMode(hndStdIn,dwInputModeCur);
        GetLastError();
    }

    //
    // Loop till the user enters a value for the variable.
    //

    while (TRUE) {
        PutStdOut(MSG_LITERAL_TEXT, ONEARG, wptr );
        szValueBuffer[0] = NULLC;
        if (ReadBufFromInput( GetStdHandle(STD_INPUT_HANDLE),
                              szValueBuffer,
                              sizeof(szValueBuffer)/sizeof(TCHAR),
                              &cch
                            ) != 0 &&
            cch != 0
           ) {
            //
            // Strip off any trailing CRLF
            //
            while (cch > 0 && szValueBuffer[cch-1] < SPACE)
                cch -= 1;

            break;
        } else {
            cch = 0;
            break;
        }

        if (!FileIsDevice(STDIN) || !(flgwd & 1))
            cmd_printf(CrLf) ;
    }

    if (fOutputModeSet) {
        SetConsoleMode( hndStdOut, dwOutputModeOld );
    }
    if (fInputModeSet) {
        SetConsoleMode( hndStdIn, dwInputModeOld );
    }

    if (cch) {
        szValueBuffer[cch] = NULLC;
        return(SetEnvVar(tas, szValueBuffer)) ;
    } else {
        return(FAILURE);
    }
}


int SetWork(n)
struct cmdnode *n ;
{
    TCHAR *tas ;    /* Tokenized argument string    */
    TCHAR *wptr ;   /* Work pointer                 */
    int i ;                 /* Work variable                */

    //
    // If extensions are enabled, things are different
    //
    if (fEnableExtensions) {
        tas = n->argptr;
        //
        // Find first non-blank argument.
        //
        if (tas != NULL)
            while (*tas && *tas <= SPACE)
                tas += 1;

        //
        // No arguments, same as old behavior.  Display current
        // set of environment variables.
        //
        if (!tas || !*tas)
            return(DisplayEnv( GetCapturedEnvironmentStrings( &CmdEnv ))) ;

        //
        // See if /A switch given.  If so, let arithmetic
        // expression evaluator do the work.
        //
        if (!_tcsnicmp(tas, SetArithStr, 2))
            return SetArithWork(tas+2);

        //
        // See if /P switch given.  If so, prompt user for value
        //
        if (!_tcsnicmp(tas, SetPromptStr, 2))
            return SetPromptUser(tas+2);

        //
        // See if first argument is quoted.  If so, strip off
        // leading quote, spaces and trailing quote.
        //
        if (*tas == QUOTE) {
            tas += 1;
            while (*tas && *tas <= SPACE)
                tas += 1;
            wptr = _tcsrchr(tas, QUOTE);
            if (wptr)
                *wptr = NULLC;
        }

        //
        // Dont allow user to set a variable name that begins with
        // an equal sign, since those are reserved for drive current
        // directories.  This check will also detect missing variable
        // name, e.g.
        //
        //      set %LOG%=c:\tmp\log.txt
        //
        // if LOG is not defined is an invalid statement.
        //
        if (*tas == EQ) {
            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
            return(FAILURE) ;
        }

        //
        // Find the equal sign in the argument.
        //
        wptr = _tcschr(tas, EQ);

        //
        // If no equal sign, then assume argument is variable name
        // and user wants to see its value.  Display it.
        //
        if (!wptr)
            return DisplayEnvVariable(tas);

        //
        // Found the equal sign, so left of equal sign is variable name
        // and right of equal sign is value.
        //
        *wptr++ = NULLC;
        return(SetEnvVar(tas, wptr)) ;
    }

    tas = TokStr(n->argptr, ONEQSTR, TS_WSPACE|TS_SDTOKENS) ;
    if (!*tas)
        return(DisplayEnv( GetCapturedEnvironmentStrings( &CmdEnv ))) ;

    else {
        for (wptr = tas, i = 0 ; *wptr ; wptr += mystrlen(wptr)+1, i++)
            ;
        /* If too many parameters were given, the second parameter */
        /* wasn't an equal sign, or they didn't specify a string   */
        /* return an error message.                                */
        if ( i > 3 || *(wptr = tas+mystrlen(tas)+1) != EQ ||
             !mystrlen(mystrcpy(tas, StripQuotes(tas))) ) {
            /* M013 */              
            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
            return(FAILURE) ;

        } else {
            return(SetEnvVar(tas, wptr+2)) ;
        }
    }
}




/***    DisplayEnvVariable -  display a specific variable from the environment
 *
 *  Purpose:
 *      To display a specific variable from the current environment.
 *
 *  int DisplayEnvVariable( tas )
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayEnvVariable(tas)
TCHAR *tas;
{
    TCHAR *envptr ;
    TCHAR *vstr ;
    unsigned size ;
    UINT PrefixLength;
    int rc;

    //
    //  Get environment.  If there's none, we're done.
    //

    envptr = GetCapturedEnvironmentStrings( &CmdEnv );
    if (envptr == (TCHAR *)NULL) {
        fprintf ( stderr, InternalError , "Null environment" ) ;
        return( FAILURE ) ;
    }

    //
    //  Isolate the prefix to match against.
    //

    tas = EatWS(tas, NULL);
    if ((vstr = mystrrchr(tas, SPACE)) != NULL) {
        *vstr = NULLC;
    }

    PrefixLength = mystrlen(tas);

    //
    //  Walk through the environment looking for prefixes that match.
    //

    rc = FAILURE;
    while ((size = mystrlen(envptr)) > 0) {

        //
        //  Stop soon if we see ^C
        //

        if (CtrlCSeen) {
            break;
        }

        //
        //  If the prefix is long enough, then terminate the string and
        //  look for a prefix match.  If we match, restore the string
        //  and display it
        //

        if (size >= PrefixLength) {
            TCHAR SavedChar = envptr[PrefixLength];
            envptr[PrefixLength] = NULLC;
            if (!lstrcmpi( envptr, tas )) {
                envptr[PrefixLength] = SavedChar;
                cmd_printf(Fmt17, envptr );
                rc = SUCCESS;
            } else {
                envptr[PrefixLength] = SavedChar;
            }

        }

        //
        //  Advance to the next string
        //

        envptr += size+1 ;
    }

    if (rc != SUCCESS) {
        PutStdErr(MSG_ENV_VAR_NOT_FOUND, ONEARG, tas);
    }

    return(rc) ;
}


/***    MyGetEnvVar - get a pointer to the value of an environment variable
 *
 *  Purpose:
 *      Return a pointer to the value of the specified environment variable.
 *
 *      If the variable is not found, return NULL.
 *
 *  TCHAR *MyGetEnvVar(TCHAR *varname)
 *
 *  Args:
 *      varname - the name of the variable to search for
 *
 *  Returns:
 *      See above.
 *
 *  Side Effects:
 *      Returned value points to within the environment block itself, so is
 *      not valid after a set environment variable operations is perform.
 */


const TCHAR *
MyGetEnvVarPtr(TCHAR *varname)
{
    TCHAR *envptr ; /* Ptr to environment                      */
    TCHAR *vstr ;
    unsigned size ;         /* Length of current env string             */
    unsigned n ;

    if (varname == NULL) {
        return( NULL ) ;
    }

    envptr = GetCapturedEnvironmentStrings( &CmdEnv );
    if (envptr == (TCHAR *)NULL) {
        return( NULL ) ;
    }

    varname = EatWS(varname, NULL);
    if ((vstr = mystrrchr(varname, SPACE)) != NULL)
        *vstr = NULLC;

    n = mystrlen(varname);
    while ((size = mystrlen(envptr)) > 0) {                 /* M015    */
        if (CtrlCSeen) {
            break;
        }
        if (!_tcsnicmp(varname, envptr, n) && envptr[n] == TEXT( '=' )) {

            return envptr+n+1;
        }

        envptr += size+1 ;
    }

    return(NULL);
}


/***    DisplayEnv -  display the environment
 *
 *  Purpose:
 *      To display the current contents of the environment.
 *
 *  int DisplayEnv()
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayEnv(TCHAR *envptr)
{
    unsigned size ;         /* Length of current env string             */

    if (envptr == (TCHAR *)NULL) {
        fprintf ( stderr, InternalError , "Null environment" ) ;
        return( FAILURE ) ;
    }

    while ((size = mystrlen(envptr)) > 0) {                 /* M015    */
        if (CtrlCSeen) {
            return(FAILURE);
        }
#if !DBG
        // Dont show current directory variables in retail product
        if (*envptr != EQ)
#endif // DBG
            cmd_printf(Fmt17, envptr) ;   /* M005 */
        envptr += size+1 ;
    }

    return(SUCCESS) ;
}




/***    GetEnvVar - get the value of an environment variable
 *
 *  Purpose:
 *      Return a string containing the value of the specified environment
 *      variable. The string value has been placed into a static buffer
 *      that is valid until the next GetEnvVar call.
 *
 *      If the variable is not found, return NULL.
 *
 *  TCHAR *GetEnvVar(TCHAR *varname)
 *
 *  Args:
 *      varname - the name of the variable to search for
 *
 *  Returns:
 *      See above.
 *
 */


TCHAR GetEnvVarBuffer[LBUFLEN];

TCHAR *
GetEnvVar(varname)
PTCHAR varname ;
{
    GetEnvVarBuffer[0] = TEXT( '\0' );

    if (GetEnvironmentVariable(varname, GetEnvVarBuffer, sizeof(GetEnvVarBuffer) / sizeof(TCHAR))) {
        return(GetEnvVarBuffer);
    } else
        if (fEnableExtensions) {
        if (!_tcsicmp(varname, CdStr)) {
            GetDir(GetEnvVarBuffer, GD_DEFAULT) ;
            return GetEnvVarBuffer;
        } else
            if (!_tcsicmp(varname, ErrStr)) {
            _stprintf( GetEnvVarBuffer, TEXT("%d"), LastRetCode );
            return GetEnvVarBuffer;
        } else
            if (!_tcsicmp(varname, CmdExtVerStr)) {
            _stprintf( GetEnvVarBuffer, TEXT("%d"), CMDEXTVERSION );
            return GetEnvVarBuffer;
        } else
            if (!_tcsicmp(varname, TEXT("CMDCMDLINE"))) {
            return GetCommandLine();
        } else
            if (!_tcsicmp(varname, DatStr)) {
            GetEnvVarBuffer[ PrintDate(NULL, PD_DATE, GetEnvVarBuffer, LBUFLEN) ] = NULLC;
            return GetEnvVarBuffer;
        }
        if ( !_tcsicmp(varname, TimStr)) {
            GetEnvVarBuffer[ PrintTime(NULL, PT_TIME, GetEnvVarBuffer, LBUFLEN) ] = NULLC;
            return GetEnvVarBuffer;
        }
        if ( !_tcsicmp(varname, TEXT("RANDOM"))) {
            _stprintf( GetEnvVarBuffer, TEXT("%d"), rand() );
            return GetEnvVarBuffer;
        }
    }
    return(NULL);
}

/***    CaptureEnvironmentStrings - make writeable copy of environment
 *
 *  Purpose:
 *      Allocate memory and create copy of environment strings
 *
 *  Args:
 *      None
 *
 *  Returns:
 *      Allocated copy of environment strings or NULL
 */
LPTSTR CaptureEnvironmentStrings( VOID )
{
    LPTSTR EnvStrings = GetEnvironmentStrings( );
    LPTSTR Copy = NULL;
    
    if (EnvStrings != NULL) {
        ULONG Size = GetEnvCb( EnvStrings );
        
        //
        //  Allocate and copy strings
        //

        Copy = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, Size );
        if (Copy != NULL) {
            memcpy( Copy, EnvStrings, Size );
        }

        FreeEnvironmentStrings( EnvStrings );
    }

    return Copy;
}




/***    InitEnv - Set up CMD's copy of the environment
 *
 *  Purpose:
 *      Creates the copy of CMD's environment.
 *
 *  Args:
 *      None
 *
 *  Returns:
 *      None
 */
void InitEnv( void )
{
    CmdEnv.Strings = CaptureEnvironmentStrings( );
    OriginalEnvironment = CopyEnv();
}

LPWSTR GetCapturedEnvironmentStrings( struct envdata *Environment )
{
    return Environment->Strings;
}

/***    SetEnvVar - controls adding/changing an environment variable
 *
 *  Purpose:
 *      Add/replace an environment variable.  Grow it if necessary.
 *
 *  int SetEnvVar(TCHAR *varname, TCHAR *varvalue, struct envdata *env)
 *
 *  Args:
 *      varname - name of the variable being added/replaced
 *      varvalue - value of the variable being added/replaced
 *      env - environment info structure being used
 *
 *  Returns:
 *      SUCCESS if the variable could be added/replaced.
 *      FAILURE otherwise.
 *
 */

int SetEnvVar(varname, varvalue)
TCHAR *varname ;
TCHAR *varvalue ;
{
    int retvalue;
    MEMORY_BASIC_INFORMATION MemoryInfo;

    PromptValid = FALSE;        // Force it to be recalculated

    if (!_tcslen(varvalue)) {
        varvalue = NULL; // null to remove from env
    }
    
    retvalue = SetEnvironmentVariable(varname, varvalue);
    
    HeapFree( GetProcessHeap( ), 0, CmdEnv.Strings );
    CmdEnv.Strings = CaptureEnvironmentStrings();

    return !retvalue;
}

/***    MoveEnv - Move the contents of the environment (M008 - New function)
 *
 *  Purpose:
 *      Used by CopyEnv, this function moves the existing
 *      environment contents to the new location.
 *
 *  MoveEnv(unsigned thndl, unsigned shndl, unsigned cnt)
 *
 *  Args:
 *      thndl - Handle of target environment
 *      shndl - Handle of source environment
 *      cnt   - byte count to move
 *
 *  Returns:
 *      TRUE if no errors
 *      FALSE otherwise
 *
 */

BOOL MoveEnv(tenvptr, senvptr, cnt)
TCHAR *senvptr ;                /* Ptr into source env seg         */
TCHAR *tenvptr ;                /* Ptr into target env seg         */
ULONG    cnt ;
{
    if ((tenvptr == NULL) ||
        (senvptr == NULL)) {
        fprintf(stderr, InternalError, "Null environment") ;
        return(FALSE) ;
    }
    memcpy(tenvptr, senvptr, cnt) ;         /* M015    */
    return(TRUE) ;
}


/***    FreeEnv -  free an environment created by CopyEnv
 *
 *  Purpose:
 *      Free all memory associated with a copied environment
 *
 *  Returns:
 *      nothing
 *
 */

void FreeEnv( struct envdata *Environment ) 
{
    HeapFree( GetProcessHeap( ), 0, Environment->Strings );
    HeapFree( GetProcessHeap( ), 0, Environment );
}

    
    
/***    CopyEnv -  make a copy of the current environment
 *
 *  Purpose:
 *      Make a copy of CmdEnv and put the new handle into the newly
 *      created envdata structure.  This routine is only called by
 *      eSetlocal and init.
 *
 *  struct envdata *CopyEnv()
 *
 *  Returns:
 *      A pointer to the environment information structure.
 *      Returns NULL if unable to allocate enough memory
 *
 *  Notes:
 *    - M001 - This function was disabled, now reenabled.
 *    - The current environment is copied as a snapshot of how it looked
 *      before SETLOCAL was executed.
 *
 */

struct envdata *CopyEnv() {
    struct envdata *cce ;   /* New env info structure          */

    cce = (struct envdata *) HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( *cce ));
    if (cce == NULL) {
        return NULL;
    }

    cce->Strings = CaptureEnvironmentStrings( );
    if (cce->Strings == NULL) {
        HeapFree( GetProcessHeap( ), 0, cce );
        PutStdErr( MSG_OUT_OF_ENVIRON_SPACE, NOARGS );
        return NULL;
    }

    return cce;
}


/***    ResetEnv - restore the environment
 *
 *  Purpose:
 *      Restore the environment to the way it was before the execution of
 *      the SETLOCAL command.  This function only called by eEndlocal.
 *
 *  ResetEnv(struct envdata *env)
 *
 *  Args:
 *      env - structure containing handle, size and max dimensions of an
 *            environment.
 *
 *  Notes:
 *    - M001 - This function was disabled, but has been reenabled.
 *    - M001 - This function used to test for OLD/NEW style batch files
 *             and delete the copy or the original environment as
 *             appropriate.  It now always deletes the original.
 *    - M014 - Note that the modified local environment will never be
 *             shrunk, so we can assume it will hold the old one.
 *
 */

void ResetEnv( struct envdata *env)
{
    SetEnvironmentStrings( env->Strings );
    HeapFree( GetProcessHeap( ), 0, CmdEnv.Strings );
    CmdEnv.Strings = CaptureEnvironmentStrings();

#if 0
    PTCHAR EnvString;
    PTCHAR Name;
    PTCHAR Value;
   
    //
    //  Delete everything in current environment
    //
    
    EnvString = GetCapturedEnvironmentStrings( &CmdEnv );
    Name = EnvString;
    while (*Name != TEXT( '\0' )) {
        //
        //  Find equal sign
        //

        Value = Name + 1;
        while (*Value != TEXT( '\0' ) && *Value != TEXT( '=' )) {
            Value++;
        }

        if (*Value == TEXT( '\0' )) {
            //
            //  SetEnvironmentVariable will succeed in deleting this 
            //

            SetEnvironmentVariable( Name, NULL );
        } else {
            *Value = TEXT( '\0' );
            SetEnvironmentVariable( Name, NULL );
            *Value = TEXT( '=' );
        }

        Name += _tcslen( Name ) + 1;

    }
    
    //
    //  Add everything in env back into the environment
    //

    Name = env->Strings;
    while (*Name != TEXT( '\0' )) {
        //
        //  Find equal sign
        //

        Value = Name + 1;
        while (*Value != TEXT( '\0' ) && *Value != TEXT( '=' )) {
            Value++;
        }

        if (*Value == TEXT( '\0' )) {
            //
            //  I have no clue how to add this in
            //

            SetEnvironmentVariable( Name, NULL );
        } else {
            *Value = TEXT( '\0' );
            SetEnvironmentVariable( Name, Value + 1 );
            *Value = TEXT( '=' );
        }

        Name += _tcslen( Name ) + 1;

    }
    
    HeapFree( GetProcessHeap( ), 0, CmdEnv.Strings );
    CmdEnv.Strings = CaptureEnvironmentStrings();
#endif
}


ULONG
GetEnvCb( TCHAR *penv ) 
{
    TCHAR *Scan = penv;

    if (penv == NULL) {
        return(0);
    }

    //
    //  NUL string terminates environment
    //
    
    while (*Scan) {
        //
        //  Skip over string and NUL
        //
        while (*Scan++) {
        }
    }
    Scan++;

    return (Scan - penv) * sizeof( TCHAR );
}

//
//      expr -> assign [, assign]*                          ,
//
//      assign -> orlogexpr |                               
//                VAR ASSIGNOP assign                       <op>=
//
//      orlogexpr -> xorlogexpr [| xorlogexpr]*             |
//
//      xorlogexpr ->  andlogexpr [^ andlogexpr]*           ^
//
//      andlogexpr ->  shiftexpr [& shiftexpr]*             &
//
//      shiftexpr -> addexpr [SHIFTOP addexpr]*             <<, >>
//
//      addexpr -> multexpr [ADDOP multexpr]*               +, -
//
//      multexpr -> unaryexpr [MULOP unaryexpr]*            *, /, %
//
//      unaryexpr -> ( expr ) |                             ()
//                   UNARYOP unaryexpr                      +, -, !, ~
//

TCHAR szOps[] = TEXT("<>+-*/%()|^&=,");
TCHAR szUnaryOps[] = TEXT("+-~!");

typedef struct {
    PTCHAR Token;
    LONG Value;
    DWORD Error;
} PARSESTATE, *PPARSESTATE;

VOID
APerformUnaryOperation( PPARSESTATE State, TCHAR Op, LONG Value )
{
    switch (Op) {
    case TEXT( '+' ):
        State->Value = Value;
        break;
    case TEXT( '-' ):
        State->Value = -Value;
        break;
    case TEXT( '~' ):
        State->Value = ~Value;
        break;
    case TEXT( '!' ):
        State->Value = !Value;
        break;
    default:
        printf( "APerformUnaryOperation: '%c'\n", Op);
        break;
    }
}

VOID
APerformArithmeticOperation( PPARSESTATE State, TCHAR Op, LONG Left, LONG Right )
{
    switch (Op) {
    case TEXT( '<' ):
        State->Value = (Right >= 8 * sizeof( Left << Right))
                       ? 0
                       : (Left << Right);
        break;
    case TEXT( '>' ):
        State->Value = (Right >= 8 * sizeof( Left >> Right ))
                       ? (Left < 0 ? -1 : 0)
                       : (Left >> Right);
        break;
    case TEXT( '+' ):
        State->Value = Left + Right;
        break;
    case TEXT( '-' ):
        State->Value = Left - Right;
        break;
    case TEXT( '*' ):
        State->Value = Left * Right;
        break;
    case TEXT( '/' ):
        if (Right == 0) {
            State->Error = MSG_SET_A_DIVIDE_BY_ZERO;
        } else {
            State->Value = Left / Right;
        }
        break;
    case TEXT( '%' ):
        if (Right == 0) {
            State->Error = MSG_SET_A_DIVIDE_BY_ZERO;
        } else {
            State->Value = Left % Right;
        }
        break;
    case TEXT( '|' ):
        State->Value = Left | Right;
        break;
    case TEXT( '^' ):
        State->Value = Left ^ Right;
        break;
    case TEXT( '&' ):
        State->Value = Left & Right;
        break;
    case TEXT( '=' ):
        State->Value = Right;
        break;
    default:
        printf( "APerformArithmeticOperation: '%c'\n", Op);
    }
}


//
//  Return the numeric value of an environment variable (or 0)
//

LONG
AGetValue( PTCHAR Start, PTCHAR End )
{
    TCHAR c = *End;
    const TCHAR *Value;
    PTCHAR Dummy;

    *End = NULLC;

    Value = MyGetEnvVarPtr( Start );
    *End = c;

    if (Value == NULL) {
        return 0;
    }

    return _tcstol( Value, &Dummy, 0);
}

DWORD
ASetValue( PTCHAR Start, PTCHAR End, LONG Value )
{
    TCHAR Result[32];
    TCHAR c = *End;
    DWORD Return = SUCCESS;

    *End = NULLC;

    _sntprintf( Result, 32, TEXT("%d"), Value ) ;
    Result[31] = TEXT( '\0' );

    if (SetEnvVar( Start, Result) != SUCCESS) {
        Return = GetLastError();
    }

    *End = c;
    return Return;
}


//
//  Forward decls
//
PARSESTATE AParseAddExpr( PARSESTATE State );
PARSESTATE AParseAndLogExpr( PARSESTATE State );
PARSESTATE AParseAssign( PARSESTATE State );
PARSESTATE AParseExpr( PARSESTATE State );
PARSESTATE AParseMultExpr( PARSESTATE State );
PARSESTATE AParseOrLogExpr( PARSESTATE State );
PARSESTATE AParseShiftExpr( PARSESTATE State );
PARSESTATE AParseUnaryExpr( PARSESTATE State );
PARSESTATE AParseXorLogExpr( PARSESTATE State );

//
//  Skip whitespace and return next character
//

BOOL ASkipWhiteSpace( PPARSESTATE State )
{
    while (*State->Token != NULLC && *State->Token <= SPACE) {
        State->Token++;
    }

    return *State->Token != NULLC;
}

TCHAR ANextChar( PPARSESTATE State )
{
    ASkipWhiteSpace( State );
    return *State->Token;
}

BOOL AParseVariable( PPARSESTATE State, PTCHAR *FirstChar, PTCHAR *EndOfName )
{
    TCHAR c = ANextChar( State );

    //
    //  Next char is a digit or operator, can't be a variable
    //

    if (c == NULLC
        || _istdigit( c )
        || _tcschr( szOps, c ) != NULL
        || _tcschr( szUnaryOps, c ) != NULL) {

        return FALSE;

    }

    *FirstChar = State->Token;

    //
    //  find end of variable
    //

    while (*State->Token &&
           *State->Token > SPACE &&
           !_tcschr( szUnaryOps, *State->Token ) &&
           !_tcschr( szOps, *State->Token ) ) {
        State->Token += 1;
    }

    *EndOfName = State->Token;
    return TRUE;
}

//      expr -> assign [, assign]*
PARSESTATE AParseExpr( PARSESTATE State )
{
    State = AParseAssign( State );

    while (State.Error == SUCCESS) {

        if (ANextChar( &State ) != TEXT( ',' )) {
            break;
        }
        State.Token++;

        State = AParseAssign( State );

    }

    return State;
}

//      assign -> VAR ASSIGNOP assign |                               
//                orlogexpr  
PARSESTATE AParseAssign( PARSESTATE State )
{
    TCHAR c = ANextChar( &State );
    PARSESTATE SavedState;

    SavedState = State;

    if (c == NULLC) {
        State.Error = MSG_SET_A_MISSING_OPERAND;
        return State;
    }

    //
    //  See if we have VAR ASSIGNOP
    //

    do {
        PTCHAR FirstChar;
        PTCHAR EndOfName;
        TCHAR OpChar;
        LONG OldValue;

        //
        //  Parse off variable
        //

        if (!AParseVariable( &State, &FirstChar, &EndOfName )) {
            break;
        }

        //
        //  Look for <op>=
        //

        OpChar = ANextChar( &State );

        if (OpChar == NULLC) {
            break;
        }

        if (OpChar != TEXT( '=' )) {
            if (_tcschr( szOps, OpChar ) == NULL) {
                break;
            }
            State.Token++;

            if (OpChar == TEXT( '<' ) || OpChar == TEXT( '>')) {
                if (ANextChar( &State ) != OpChar) {
                    break;
                }
                State.Token++;
            }

        }

        if (ANextChar( &State ) != TEXT( '=' )) {
            break;
        }
        State.Token++;

        //
        //  OpChar is the sort of operation to apply before assignment
        //  State has been advance to, hopefully, another assign.  Parse it
        //  and see where we get
        //

        State = AParseAssign( State );
        if (State.Error != SUCCESS) {
            return State;
        }

        OldValue = AGetValue( FirstChar, EndOfName );

        //
        //  Perform the operation and the assignment 
        //

        APerformArithmeticOperation( &State, OpChar, OldValue, State.Value );
        if (State.Error != SUCCESS) {
            return State;
        }

        State.Error = ASetValue( FirstChar, EndOfName, State.Value );

        return State;
    } while ( FALSE );

    //
    //  Must be orlogexpr.  Go back and parse over
    //

    return AParseOrLogExpr( SavedState );
}

//      orlogexpr -> xorlogexpr [| xorlogexpr]*             |
PARSESTATE
AParseOrLogExpr( PARSESTATE State )
{
    State = AParseXorLogExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '|' )) {
            break;
        }
        State.Token++;

        State = AParseXorLogExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      xorlogexpr ->  andlogexpr [^ andlogexpr]*           ^
PARSESTATE
AParseXorLogExpr( PARSESTATE State )
{
    State = AParseAndLogExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '^' )) {
            break;
        }
        State.Token++;

        State = AParseAndLogExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      andlogexpr ->  shiftexpr [& shiftexpr]*             &
PARSESTATE
AParseAndLogExpr( PARSESTATE State )
{
    State = AParseShiftExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '&' )) {
            break;
        }
        State.Token++;

        State = AParseShiftExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      shiftexpr -> addexpr [SHIFTOP addexpr]*             <<, >>
PARSESTATE
AParseShiftExpr( PARSESTATE State )
{
    State = AParseAddExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '<' ) && Op != TEXT( '>' )) {
            break;
        }
        State.Token++;

        if (Op != ANextChar( &State )) {
            State.Error = MSG_SET_A_MISSING_OPERATOR;
            return State;
        }
        State.Token++;

        State = AParseAddExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      addexpr -> multexpr [ADDOP multexpr]*               +, -
PARSESTATE
AParseAddExpr( PARSESTATE State )
{
    State = AParseMultExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '+' ) && Op != TEXT( '-' )) {
            break;
        }
        State.Token++;

        State = AParseMultExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      multexpr -> unaryexpr [MULOP unaryexpr]*            *, /, %
PARSESTATE
AParseMultExpr( PARSESTATE State )
{
    State = AParseUnaryExpr( State );
    while (State.Error == SUCCESS) {
        TCHAR Op = ANextChar( &State );
        LONG Value = State.Value;

        if (Op != TEXT( '*' ) && Op != TEXT( '/' ) && Op != TEXT( '%' )) {
            break;
        }
        State.Token++;

        State = AParseUnaryExpr( State );
        APerformArithmeticOperation( &State, Op, Value, State.Value );
    }
    return State;
}

//      unaryexpr -> UNARYOP unaryexpr                      +, -, !, ~
//                   ( expr ) |                             ()
//                   NUMBER
//                   LITERAL
PARSESTATE
AParseUnaryExpr( PARSESTATE State )
{
    TCHAR c = ANextChar( &State );
    PTCHAR FirstChar;
    PTCHAR EndOfName;

    if (c == NULLC) {
        State.Error = MSG_SET_A_MISSING_OPERAND;
        return State;
    }

    //  ( expr )
    if (c == TEXT( '(' )) {
        State.Token++;
        State = AParseExpr( State );
        if (State.Error != SUCCESS) {
            return State;
        }
        c = ANextChar( &State );
        if (c != TEXT( ')' )) {
            State.Error = MSG_SET_A_MISMATCHED_PARENS;
        } else {
            State.Token++;
        }
        return State;
    }

    //  UNARYOP unaryexpr
    if (_tcschr( szUnaryOps, c ) != NULL) {
        State.Token++;
        State = AParseUnaryExpr( State );
        if (State.Error != SUCCESS) {
            return State;
        }
        APerformUnaryOperation( &State, c, State.Value );
        return State;
    }

    //  NUMBER
    if (_istdigit(c)) {
        errno = 0;
        State.Value = _tcstol( State.Token, &State.Token, 0 );
        if (State.Value == LONG_MAX && errno == ERANGE) {
            State.Error = MSG_SET_NUMBER_TOO_LARGE;
        } else if (_istdigit( *State.Token ) || _istalpha( *State.Token )) {
            State.Error = MSG_SET_A_INVALID_NUMBER;
        }
        return State;
    }

    //  Must be literal

    if (!AParseVariable( &State, &FirstChar, &EndOfName )) {
        State.Error = MSG_SET_A_MISSING_OPERAND;
        return State;
    }

    State.Value = AGetValue( FirstChar, EndOfName );
    return State;
}

/***    SetArithWork - set environment variable to value of arithmetic expression
 *
 *  Purpose:
 *      Set environment variable to value of arithmetic expression
 *
 *  int SetArithWork(TCHAR *tas)
 *
 *  Args:
 *      tas - pointer to null terminated string of the form:
 *
 *          VARNAME=expression
 *
 *  Returns:
 *      If valid expression, return SUCCESS otherwise FAILURE.
 *
 */

int SetArithWork(TCHAR *tas)
{
    PARSESTATE State;

    //
    // If no input, declare an error
    //
    if (!tas || !*tas) {
        PutStdErr(MSG_BAD_SYNTAX, NOARGS);
        return(FAILURE) ;
    }

    //
    //  Set up for parsing
    //

    State.Token = StripQuotes( tas );
    State.Value = 0;
    State.Error = SUCCESS;

    State = AParseExpr( State );
    if (State.Error == SUCCESS && ANextChar( &State ) != NULLC) {
        State.Error = MSG_SET_A_MISSING_OPERATOR;
    }

    if (State.Error != SUCCESS) {
        PutStdErr( State.Error, NOARGS );
        //printf( "%ws\n", tas );
        //printf( "%*s\n", State.Token - tas + 1, "^" );

    } else if (!CurrentBatchFile) {
        cmd_printf( TEXT("%d"), State.Value ) ;
    }

    return State.Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cfile.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cfile.c

Abstract:

    File manipulation support

--*/

#include "cmd.h"

#define Wild(spec)  ((spec)->flags & (CI_NAMEWILD))

extern int LastRetCode ;
extern jmp_buf CmdJBuf2 ;

extern TCHAR Fmt19[], Fmt17[];
extern TCHAR CurDrvDir[] ;

extern TCHAR YesChar, NoChar ;

extern TCHAR *SaveDir ;

extern TCHAR PathChar, TmpBuf[], SwitChar;

extern unsigned DosErr ;
extern unsigned flgwd ;                 /* M021 */

extern int LastRetCode ;

extern BOOL CtrlCSeen;
extern PTCHAR    pszTitleCur;
extern BOOLEAN  fTitleChanged;

//
// Internal prototypes
//
PCPYINFOSetFsSetSaveDir() ;

/***    ErrorDisplayAndJumnp - handle errors
 *
 *  Purpose:
 *      eRename and eMove error handler.  Returns to routine via longjmp
 *
 *  ErrorDisplayAndJump(unsigned int errmsg)
 *
 *
 *  Args:
 *      errmsg - the error message to print
 *
 */

void ErrorDisplayAndJump( unsigned int errmsg )
{

    PutStdErr( errmsg, NOARGS );

    RestoreSavedDirectory( );

    longjmp( CmdJBuf2, 1 ) ;
}


/*
** This routine returns the longest pathlength possible from the input path
** It assumes that the input path is a buffer that it can extend by a
** wildcard '\*' to search the file, if it is a directory.
** The input path must be fully qualified, eg: "c:\winnt\system32\kernel32.dll"
**
** Input:
**      pPath   fully qualified Pathname
**      pCch    pointer to length of pathname
** Returns:
**      TRUE    succeeded, pCch contains length
**      FALSE   error occurred
*/
BOOL
GreatestLength(
              TCHAR       *pPath,
              int         *pCch
              )
{
    WIN32_FIND_DATA     fd;
    HANDLE              hFind;
    DWORD               err;
    int                 cch;
    int                 cchThis;
    DWORD               attr;
    TCHAR               *pLast;
    BOOL        MoreFiles;

    /* assume a file, or empty directory */
    *pCch = cch = _tcslen(pPath) - 2;   /* _tcslen(TEXT("C:")) */

    if ((attr=GetFileAttributes(pPath)) == 0xffffffff) {
        PutStdErr(GetLastError(), NOARGS);
        return FALSE;
    }
    if ( !(attr & FILE_ATTRIBUTE_DIRECTORY)) {   /* if just a file... */
        return TRUE;
    }

    /* path is a directory, search it ... */

    pLast = pPath + _tcslen(pPath);
    if (*(pLast-1) == BSLASH) {
        *pLast = STAR;
        *(pLast+1) = NULLC;
    } else {
        *pLast = BSLASH;
        *(pLast+1) = STAR;
        *(pLast+2) = NULLC;
    }

    if ((hFind=FindFirstFile(pPath, &fd)) == INVALID_HANDLE_VALUE) {
        //
        // Check that failure was not due to some system error such
        // as an abort on access to floppy
        //
        err = GetLastError();
        FindClose(hFind);
        if (err != ERROR_FILE_NOT_FOUND && err != ERROR_NO_MORE_FILES) {
            PutStdErr(err, NOARGS);
            return FALSE;
        }
        return TRUE;
    }

    MoreFiles = TRUE;
    do {
        if (!_tcscmp(fd.cFileName, TEXT(".")))
            continue;
        if (!_tcscmp(fd.cFileName, TEXT("..")))
            continue;
        if (_tcslen( fd.cFileName ) == 0) {
            continue;
        }

        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            TCHAR       path[MAX_PATH];

            _tcscpy(path, pPath);
            *(path+_tcslen(path)-1) = NULLC;    /* zap asterisk */
            _tcscat(path, fd.cFileName);
            if (!GreatestLength(path, &cchThis))
                break;

            *pCch = max(*pCch, cch + cchThis);
        } else {
            *pCch = max(*pCch, (int) _tcslen(fd.cFileName));
        }

    } while ( MoreFiles = FindNextFile(hFind, &fd) );

    err = GetLastError();
    FindClose(hFind);

    if ( MoreFiles ) {
        return FALSE;
    } else if ( err != ERROR_NO_MORE_FILES ) {
        PutStdErr(err, NOARGS);
        return FALSE;
    }

    return TRUE;
}

void
RestoreSavedDirectory( void )
{
    if (SaveDir) {
        mystrcpy( CurDrvDir, SaveDir );
        SaveDir = NULL;
    }
}

BOOL
GetPromptOkay(
             const TCHAR *arg,
             BOOL *promptokay

             )
{
    BOOL Result;
    const TCHAR *p, *p1;

    Result = TRUE;
    if (arg != NULL) {
        p = arg;
        while (*p && *p <= SPACE)
            p += 1;
        p1 = p;
        while (*p1 && *p1 > SPACE)
            p1 += 1;
        if (!_tcsnicmp(p, TEXT("/Y"),(UINT)(p1-p)))
            *promptokay = FALSE;
        else
            if (!_tcsnicmp(p, TEXT("/-Y"),(UINT)(p1-p)))
            *promptokay = TRUE;
        else
            Result = FALSE;
    }

    return Result;
}

int eCopy(n)
struct cmdnode *n ;
{
    return(LastRetCode = copy(n->argptr)) ;
}


int eDelete(n)
struct cmdnode *n ;
{
    int DelWork() ;

    return(LastRetCode = DelWork(n->argptr));
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: eRename                                            */
/*                                                                     */
/* DESCRIPTIVE NAME:  Rename Internal Command                          */
/*                                                                     */
/* FUNCTION: Rename files and subdirectories.  Wildcards only applies  */
/*           to file names.                                            */
/*                                                                     */
/* NOTES:    @@5*                                                      */
/*                                                                     */
/* ENTRY POINT: eRename                                                */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - the parse tree node containing the rename command    */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       RenWork     - Worker routine for rename.                      */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int eRename(n)
struct cmdnode *n ;
{
    int RenWork();                           /* @@ */

    return(LastRetCode = RenWork( n ));      /* @@ */
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: RenWork                                            */
/*                                                                     */
/* DESCRIPTIVE NAME:  Rename Internal Command Worker                   */
/*                                                                     */
/* FUNCTION: Rename files and subdirectories.  Wildcards only applies  */
/*           to file names.                                            */
/*                                                                     */
/* NOTES:    @@5*                                                      */
/*                                                                     */
/* ENTRY POINT: RenWork                                                */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - The parse tree node containing the rename command    */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       ffirst          - Find the first matching specified file.     */
/*       fnext           - Find the next matching specified file handle*/
/*       findclose - Close the file with the specified file handle,    */
/*                       hnFirst which is given by ffirst or fnext.    */
/*       TokStr          - Tokenize argument strings.                  */
/*       wildcard_rename - Obtain name based on wildcard specification.*/
/*       SetFsSetSaveDir - Save the current directory.                 */
/*       GetDir          - Get the specified directory.                */
/*       ChangeDir       - Change to the specified directory.          */
/*       PutStdErr - Displays an error message.                        */
/*       Wild      - check if the arg contains wild card.              */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*        DOSMOVE      - Rename file and directory names.              */
/*        DOSCASEMAP   - Change lower case character to upper case.    */
/*        DOSFILEMODE  - Get attribute of specified file.              */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int RenWork(n)                                  /* @@ */
struct cmdnode *n ;
{
    TCHAR *arg1 ;                          /* Ptr to 1st arg          */
    TCHAR *arg2 ;                          /* Ptr to 2nd arg          */
    PCPYINFO a1info ;                       /* Holds arg1 fspec info   */
    PCPYINFO SetFsSetSaveDir();
    TCHAR Source[MAX_PATH];
    TCHAR bufdst[MAX_PATH];                        /* path of destination file*/
    TCHAR Replacement[MAX_PATH];
    int wlen;                              /* length of source path       */
    int rc;                                        /* return code             */
    HANDLE hnFirst ;                               /* Findfirst handle            */
    unsigned attr ;
    unsigned i;                                    /* Temp Return Code        */
    TCHAR *j ;                                     /* Temp Ptr to dir name    */
    unsigned wild_flag ;                           /* wildcard flag           */
    TCHAR pcstr[3] ;
    unsigned retval = SUCCESS;

    DEBUG((FCGRP, RELVL, "RENAME: arptr = `%ws'", n->argptr)) ;

    if (setjmp(CmdJBuf2))
        return(FAILURE) ;

    /* There should be only two arguments */
    if (!*(arg1 = TokStr(n->argptr, NULL, TS_NOFLAGS)) ||
        !*(arg2 = arg1 + mystrlen(arg1) + 1) ||
        *(arg2 + mystrlen(arg2) +1)) {             /* @@5g */

        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }

    mystrcpy( arg1, StripQuotes(arg1) );       /* 509 */
    mystrcpy( arg2, StripQuotes(arg2) );       /* 509 */

    if ((a1info = SetFsSetSaveDir(arg1)) == (PCPYINFO)FAILURE) {
        ErrorDisplayAndJump( DosErr );
    }

    mystrcpy( Source, CurDrvDir );

    mystrcpy(bufdst,CurDrvDir);                    /*  save path of dest   */

    wlen = mystrlen( Source );                       /*  get len of src path */

    if ( (a1info->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        mystrcpy(&Source[wlen],a1info->fnptr);
    } else {
        Source[--wlen] = NULLC ;
        bufdst[wlen] = NULLC ;
    }

    /* if not wild since    */
    if (!Wild(a1info)) {
        a1info->buf->dwFileAttributes =
        GetFileAttributes( StripQuotes(Source) );

        if (a1info->buf->dwFileAttributes == -1 ) {
            ErrorDisplayAndJump( GetLastError( )) ;
        }
    }


    if (*(arg2+1) == COLON ||
        mystrchr(arg2,PathChar)) {
        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }

    /**********************************************/
    /*  M009 - Always specifiy drive, filename,   */
    /*         and extension.  Note, it is        */
    /*         assumed that SaveDir always starts */
    /*         with a drive letter                */
    /**********************************************/

    Replacement[0] = CurDrvDir[0] ;      /* @@5h */
    Replacement[1] = COLON ;


    /**********************************************/
    /* Set flag whether arg1 contains             */
    /* wildcard or not.                           */
    /**********************************************/

    pcstr[0] = STAR ;
    pcstr[1] = QMARK ;
    pcstr[2] = NULLC ;
    wild_flag = ((mystrcspn(arg1,pcstr)) < mystrlen(arg1)) ;

    /**********************************************/
    /* Issue ffirst for a file name               */
    /**********************************************/
    if ( !ffirst(Source, attr = FILE_ATTRIBUTE_ARCHIVE, a1info->buf, &hnFirst )) {

        /*********************************************/
        /* Issue ffirst for a directory name         */
        /*********************************************/
        if (!ffirst(Source, attr = FILE_ATTRIBUTE_DIRECTORY, a1info->buf, &hnFirst )) {
            if (DosErr == ERROR_NO_MORE_FILES) {
                DosErr = ERROR_FILE_NOT_FOUND;
            }
            ErrorDisplayAndJump( DosErr );
        } else {

            if (wild_flag) {
                findclose( hnFirst );
                ErrorDisplayAndJump( MSG_BAD_SYNTAX );
            }
        }
    }

    Source[wlen] = NULLC;                            /* make filename = NULL */

    rc = 0 ;                                         /* @@5 */

    do {

        if (CtrlCSeen) {
            findclose(hnFirst) ;
            RestoreSavedDirectory( );

            return(FAILURE);
        }

        /**********************************************/
        /* if the file attribute of Source is         */
        /* directory then concatenate arg2 after the  */
        /* last "\" character of bufdst               */
        /**********************************************/

        if ( a1info->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {       /* @@5c*/
            j = mystrrchr(bufdst,PathChar) ;          /* @@5 */

            if ( !j ) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }

            *(++j) = NULLC;

            if ( (mystrlen(arg2) + 1 + mystrlen(bufdst)) > MAX_PATH ) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }

            mystrcpy(j,arg2);                             /* @@5 */

            bufdst[mystrlen(bufdst)] = NULLC ;            /* @@5 */
        }                                                /* @@5 */
        else {                                                /* @@5 */
            mystrcpy(&Source[wlen],a1info->buf->cFileName);

            wildcard_rename( Replacement, arg2, &Source[wlen], MAX_PATH );

            if ( (wlen + 1 + mystrlen( Replacement )) > MAX_PATH ) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }

            mystrcpy(&bufdst[wlen],&Replacement[0]); /*@@4 @J1*/
        }

        /**********************************************/
        /* Rename a file or directory                 */
        /**********************************************/
        DEBUG((FCGRP, RELVL, "RENAME: src:`%ws', dst:`%ws'", Source, bufdst)) ;
        if ( !MoveFile( Source, bufdst ) ) {
            /**********************************************/
            /* rename fails                               */
            /**********************************************/

            i = GetLastError();
            if (i == ERROR_ALREADY_EXISTS) {
                i = MSG_DUP_FILENAME_OR_NOT_FD;
            }

            rc = i ;                            /* @@5 Save the error code*/
            PutStdErr(rc,NOARGS);               /* @@5 Put our err message*/
        }

    } while (fnext(a1info->buf, attr, hnFirst ));

    /**********************************************/
    /* No more file is found                      */
    /**********************************************/
    findclose(hnFirst) ;

    RestoreSavedDirectory( );

    return( rc ? FAILURE : SUCCESS ); /* @@5 */
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: eMove                                              */
/*                                                                     */
/* DESCRIPTIVE NAME: Move Internal Command                             */
/*                                                                     */
/* FUNCTION: Parse the parameter passed and                            */
/*           moves one or more files from directory to another         */
/*           directory on the same drive.  If you prefer you can give  */
/*           the files different names.                                */
/*                                                                     */
/* NOTES:    ( New routine for Relaese 1.2 )  @@5*                     */
/*                                                                     */
/* ENTRY POINT: eMove                                                  */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - the parse tree node containing the copy command      */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to caller.                                   */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       MoveParse   - parse move command parameter                    */
/*       Move        - routine which actually call DosMove to move     */
/*                     file or directory.                              */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int eMove(n)
struct cmdnode *n ;
{
    unsigned i;
    BOOL PromptOnOverwrite;
    TCHAR arg1[MAX_PATH] ;       /* Ptr to 1st arg   */
    TCHAR arg2[MAX_PATH] ;       /* Ptr to 2nd arg   */
    PCPYINFO a1info ;     /* Holds arg1 fspec info   */
    unsigned int is_dest_dir;    /* generated by MoveParse(), used by Move() */

    DEBUG((FCGRP, RELVL, "RENAME: arptr = `%ws'", n->argptr)) ;

    if (setjmp(CmdJBuf2))
        return(LastRetCode = FAILURE) ;

    //
    // Get default prompt okay flag from COPYCMD variable.  Allow
    // user to override with /Y or /-Y switch.  Always assume /Y
    // if command executed from inside batch script or via CMD.EXE
    // command line switch (/C or /K)
    //
    if (SingleBatchInvocation || SingleCommandInvocation || CurrentBatchFile != 0)
        PromptOnOverwrite = FALSE;      // Assume /Y
    else
        PromptOnOverwrite = TRUE;       // Assume /-Y

    /* MoveParse parses the command line parameters to arg1   */
    /* and arg1. In addition, a1info holds the fspec          */
    /* information for arg1.                                  */
    /* Based on arg1 and arg2, Move moves file(s)/directory.  */
    /* Move uses a1info to determine that arg1 contains       */
    /* wildcard.                                              */

    i = MoveParse( n,
                   &PromptOnOverwrite,
                   arg1,
                   arg2,
                   &a1info,
                   &is_dest_dir,
                   MAX_PATH,
                   MAX_PATH
                 );
    if (!i) {
        i = Move( arg1, arg2, PromptOnOverwrite, a1info, is_dest_dir ) ;
    }

    return(LastRetCode = i) ;
}


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: MoveParse                                          */
/*                                                                     */
/* DESCRIPTIVE NAME: Move Parser                                       */
/*                                                                     */
/* FUNCTION: Move Internal Function Parser                             */
/*                                                                     */
/* NOTES:    This parser breaks up the command line information        */
/*           into two parameters.                                      */
/*           ( New routine for Relaese 1.2 )  @@5*                     */
/*                                                                     */
/* ENTRY POINT: MoveParse                                              */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*            n - the parse tree node containing the move command      */
/*                                                                     */
/* OUTPUT:   ptr1 - pointer to [drive:][path]filename to be moved from */
/*           ptr2 - pointer to [path]filename to be moved to           */
/*           a1info - pointer to cpyinfo which has arg1 fspec info     */
/*           is_dest_dir - flag used by Move()                         */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return SUCCESS to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*         TokStr       - Tokenize argument strings.                   */
/*         FullPath     - Figure out the full path for a file.         */
/*         SetFsSetSaveDir - Save current directory.                   */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*         DOSQFILEMODE - Get file mode of the specified file/dir.     */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/
int MoveParse(n, promptokay, source, target , a1info, is_dest_dir, sizpath1, sizpath2)
struct cmdnode *n ;
BOOL *promptokay ;
TCHAR *source ;                  /* Ptr to source file(s)/directory name  */
TCHAR *target ;                  /* Ptr to target file(s)/directory name  */
PCPYINFO* a1info ;               /* Holds arg1 fspec information          */
unsigned int *is_dest_dir;       /* to pass to move                       */
unsigned sizpath1;               /* size of source buffer                 */
unsigned sizpath2;               /* size of target buffer                 */

{       PCPYINFO SetFsSetSaveDir() ;
    TCHAR *arg1 ;                   /* Ptr to 1st arg          */
    TCHAR *arg2 ;                   /* Ptr to 2nd arg          */
    TCHAR *p1;
    TCHAR *p2;
    TCHAR arg22[MAX_PATH] ;        /* Ptr to modified 2nd arg */
    unsigned i;
    unsigned concat_flag ;
    unsigned att ; 
/*509*/unsigned arg1len, arg2len;

    //
    // Get default prompt okay flag from COPYCMD variable.  Allow
    // user to override with first token after command.
    //
    GetPromptOkay(MyGetEnvVarPtr(TEXT("COPYCMD")), promptokay);
    arg1 = TokStr(n->argptr, NULL, TS_NOFLAGS);
    if (GetPromptOkay(arg1, promptokay))
        while (*arg1++)
            ;

    /* Get arg1.  If fail to get arg1, display error message. */
    arg1len = mystrlen(arg1);

    if (arg1len == 0) {
        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    } else 
    if ( arg1len >= MAX_PATH) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    }

    /*CurDrvDir = current directory or directory which is specified in arg1*/
/*509*/mystrcpy( arg1, StripQuotes( arg1 ) );
    if (((*a1info) = SetFsSetSaveDir(arg1)) == (PCPYINFO)FAILURE) {
        ErrorDisplayAndJump( DosErr );
    }
    /*                   */
    /* Get arg2 out of arg1 */

    arg2 = arg1 + arg1len + 1;

    if ( !(*arg2) ) {

        arg22[0] = SaveDir[0];    /* get current drive */
        arg22[1] = COLON;
        arg22[2] = NULLC;
    } else if (*(arg2 + mystrlen(arg2) + 1)) {  /* @@5g */
        ErrorDisplayAndJump( MSG_BAD_SYNTAX );
    }
/*509*/
    else if ( (arg2len = mystrlen(arg2)) > MAX_PATH) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    } else {
        /* If arg2 conatins a drive name, display an error message. */

/*509*/
        mystrcpy

        ( arg2, StripQuotes( arg2 ) );

        // UNC names fix

        if (  ( *(arg2+1) != COLON )  &&  ( ! (  ( *arg2 == BSLASH ) && ( *(arg2+1) == BSLASH )  )  )  ) {
            arg22[0] = SaveDir[0];    /* get drive we're using */
            arg22[1] = COLON;
            arg22[2] = NULLC;
            if ((mystrlen(arg22) + mystrlen(arg2)+1) > MAX_PATH) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
            }
            mystrcat( arg22, arg2 ) ;

        } else

        {
            mystrcpy(arg22,arg2) ;
        }
    }


    /* source = complete path for arg1 */

    if ( i = FullPath(source, arg1,sizpath1) ) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    }

    //
    // If preserve file name portion from arg1 as FullPath will map *. to * which
    // is not what the user wants.
    //
    if (!((*a1info)->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        p1 = mystrrchr(source,PathChar) ;
        if (p1 != NULL)
            p1 += 1;
        else
            p1 = source;
        p2 = mystrrchr((*a1info)->fnptr,PathChar) ;
        if (p2 == NULL)
            p2 = (*a1info)->fnptr;
        mystrcpy(p1, p2);
    }

    /* target = complete path for arg2 */


    if ( i = FullPath(target, arg22,sizpath2) ) {
        ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
    }


    concat_flag = FALSE ;
    DosErr = NO_ERROR ;
    SetLastError(NO_ERROR);
    *is_dest_dir = 0;

    if (*lastc(target) == PathChar) {          /* test for last non DBCS character path char  @@5@J3 */
        concat_flag = TRUE ;
        target[mystrlen(target)-1] = NULLC ;
    };

    if ( (att = GetFileAttributes( target )) != -1 ) {
        if (att & FILE_ATTRIBUTE_DIRECTORY) {   /* if target is a directory, copy the file      */
            /* name from source.                            */
            *is_dest_dir = 1;
            concat_flag = TRUE ;
        };
    } else if ( (DosErr = GetLastError()) &&
                ( ( DosErr != ERROR_FILE_NOT_FOUND ) &&
                  ( DosErr !=  ERROR_PATH_NOT_FOUND )    )   ) {
        ErrorDisplayAndJump( DosErr );
    };

    if (concat_flag) {
        arg1 = mystrrchr(source,PathChar);
        if ((mystrlen(arg1) + mystrlen(target) + 1) > MAX_PATH) {
            ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME );
        }
        mystrcat( target, arg1 ) ;
    };

    return(SUCCESS) ;
}


BOOL
MyMoveFile(
          TCHAR *src,
          TCHAR *dst,
          BOOL *promptokay,
          BOOL *file_moved
          )
{
    DWORD dwFlags;

    dwFlags = MOVEFILE_COPY_ALLOWED;
    if (!*promptokay) {
        dwFlags |= MOVEFILE_REPLACE_EXISTING;
    }

    *file_moved = FALSE;
    if (!MoveFileEx(src, dst, dwFlags)) {
        if (GetLastError() == ERROR_ALREADY_EXISTS) {
            switch (PromptUser(dst, MSG_MOVE_COPY_OVERWRITE, MSG_NOYESALL_RESPONSE_DATA)) {
            case 0: // No
                return TRUE;
                break;
            case 2: // All
                *promptokay = FALSE;
            default: // Yes
                dwFlags |= MOVEFILE_REPLACE_EXISTING;
                return(*file_moved = MoveFileEx(src, dst, dwFlags));
                break;
            }
        }

        return FALSE;
    } else {
        *file_moved = TRUE;
        return TRUE;
    }
}

/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: Move                                               */
/*                                                                     */
/* DESCRIPTIVE NAME: Move Process                                      */
/*                                                                     */
/* FUNCTION: Moves one or more files from directory to another         */
/*           directory on the same drive.  If you prefer you can give  */
/*           the files different names.                                */
/*                                                                     */
/* NOTES:    ( New routine for Release 1.2 )  @@5*                     */
/*                                                                     */
/* ENTRY POINT: eMove                                                  */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:    ptr1 - pointer to [drive:][path]filename to be moved from */
/*           ptr2 - pointer to [path]filename to be moved to           */
/*           a1info - pointer to cpyinfo which has arg1 fspec info     */
/*           is_dest_dir - from MoveParse()                            */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return Success to the caller.                               */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return error code from DosMove API.                         */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       ChangeDir - Change back to the original directory.            */
/*       ffirst - Find the first file which matches the specified      */
/*                file name that may contain * or ?.                   */
/*       fnext  - Find the next file which matches the specified       */
/*                file name that may contain * or ?.                   */
/*       findclose - Close the file with the specified file handle,    */
/*                       hnFirst which is given by ffirst or fnext.    */
/*       PutStdErr - Displays an error message.                        */
/*       PutStdOut - Displays a message.                               */
/*       Wild      - check if the arg contains wild card.              */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DOSMOVE     -  move directories and files.                    */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int
Move( arg1, arg2, promptokay, a1info, is_dest_dir )
TCHAR *arg1 ;                         /* Ptr to 1st arg          */
TCHAR *arg2 ;                         /* Ptr to 2nd arg          */
BOOL promptokay ;
PCPYINFO a1info ;              /* Holds arg1 fspec info   */
unsigned int is_dest_dir;             /* flag if set--> dest. is a dir */

{
    unsigned attr ;
    unsigned i, n;
    unsigned long number_of_files_moved ;
    TCHAR Source[MAX_PATH];      /* path of source file     */
    TCHAR bufdst[MAX_PATH];      /* path of destination file*/
    HANDLE hnFirst ;                                  /* Findfirst handle    */
    TCHAR *j, *k,*l;                      /* Tmp Ptr                 */
    unsigned wild_flag ;                  /* wildcard flag           */
    BOOL file_moved;
    unsigned save_error ;                 /* Saved error code        */
    TCHAR pcstr[3] ;
    unsigned rc;
    int retc;
    int how_many_src=0;                   /* =f_RET_DIR if dir; =0 if none; = <number matching src files> else */
    char type_format_dest=0;              /* decide on how to format dest */
    char fl_move_once=0;                  /* if =1 execute move once only */



    how_many_src = f_how_many (arg1, (ULONG) (attr=FILE_ATTRIBUTE_ARCHIVE) );


    /**********************************************/
    /* Set flag whether arg1 contains             */
    /* wildcard or not.                           */
    /**********************************************/

    pcstr[0] = STAR ;
    pcstr[1] = QMARK ;
    pcstr[2] = NULLC ;
    wild_flag = ((mystrcspn(arg1,pcstr))
                 < mystrlen(arg1)) ;



    // Decide on what to do depending on: <1.multiple/single src; 2.is dest dir ?>

    if (how_many_src == f_RET_DIR) {
        if (is_dest_dir) {
            if (!MyMoveFile(arg1, arg2, &promptokay, &file_moved) ) {

                i = GetLastError();

                if (i == ERROR_ALREADY_EXISTS) {
                    i = MSG_DUP_FILENAME_OR_NOT_FD;
                }

                ErrorDisplayAndJump( i );
            } else {
                RestoreSavedDirectory( );
                
                PutStdOut(MSG_DIRS_MOVED, ONEARG, argstr1( TEXT( "%9d" ), 1 )) ;
                
                return(SUCCESS) ;
            }
        } else {
            type_format_dest = 2;
            fl_move_once = 1;
        }
    }

    else if (how_many_src > 1 ) {
        if (is_dest_dir) {
            type_format_dest = 1;
            fl_move_once = 0;
        } else {
            ErrorDisplayAndJump( MSG_MOVE_MULTIPLE_FAIL );
        }
    }

    else { // single source or source doesn't exist
        if (is_dest_dir) {
            type_format_dest = 1;
            fl_move_once = 1;
        } else {
            type_format_dest = 2;
            fl_move_once = 1;
        }
    }


    /**********************************************/
    /* Issue ffirst for a file name               */
    /**********************************************/

/*M006*/        if (!ffirst(arg1, attr = FILE_ATTRIBUTE_ARCHIVE, a1info->buf, &hnFirst )) {

        /**********************************************/
        /* Issue ffirst for a directory name          */
        /**********************************************/

        rc = ffirst(arg1, attr = FILE_ATTRIBUTE_DIRECTORY, a1info->buf, &hnFirst ) ;

        if ( !rc) {
            /**********************************************/
            /* No file or directory which arg1            */
            /* specifies found                            */
            /**********************************************/

            if (!rc && DosErr == ERROR_NO_MORE_FILES) { /* @@5e */
                rc = ERROR_FILE_NOT_FOUND;
            } else if (wild_flag) {
                rc = MSG_DUP_FILENAME_OR_NOT_FD;
            } else {
                rc = DosErr;
            }
            ErrorDisplayAndJump( rc );
        }
    }

    number_of_files_moved = 0 ;                     /* Reset the counter to zero */
    save_error = NO_ERROR ;                         /* Reset error code to zero  */
    mystrcpy(Source,arg1) ;
    j = mystrrchr(Source,PathChar) ;
    ++j;                                            /* get to filename area      */


    do {
        if (CtrlCSeen) {
            findclose(hnFirst) ;
            RestoreSavedDirectory( );

            return(FAILURE);
        }

        /**********************************************/
        /* build bufdst                               */
        /**********************************************/


        mystrcpy(j,a1info->buf->cFileName) ;

        mystrcpy(bufdst,arg2);

        if (type_format_dest == 1 ) {
            l = mystrrchr(bufdst,PathChar);
            ++l;
            mystrcpy(l,a1info->buf->cFileName) ;
            if ((mystrlen(bufdst) ) > MAX_PATH) {
                ErrorDisplayAndJump( MSG_REN_INVAL_PATH_FILENAME ) ;
            }
        }


        /**********************************************/
        /* check to see if filename is legal          */
        /**********************************************/

        {
            TCHAR TempBuffer[MAX_PATH];
            DWORD Length;
            
            Length = GetFullPathName( bufdst, MAX_PATH, TempBuffer, NULL );
            if (Length == 0 || Length >= MAX_PATH) {
                goto badness;
            }
            
            n = _tcslen( TempBuffer );
            
            Length = GetFullPathName( Source, MAX_PATH, TempBuffer, NULL );
            if (Length == 0 || Length >= MAX_PATH) {
                goto badness;
            }
            if (!GreatestLength( TempBuffer, &i))
                continue;

            i -= _tcslen( TempBuffer );
        }
        
        if (n + i > MAX_PATH) {
            i = ERROR_FILENAME_EXCED_RANGE;
            goto badness2;
        }

        /**********************************************/
        /* Move a file or directory                   */
        /**********************************************/


        if (!MyMoveFile(Source, bufdst, &promptokay, &file_moved)) {

            /**********************************************/
            /* Move fails                                 */
            /**********************************************/
            badness:
            i = GetLastError();
            badness2:

            if (i == ERROR_ALREADY_EXISTS) {
                i = MSG_DUP_FILENAME_OR_NOT_FD;
            }

            save_error = i ;         /* Save the error code      */

            PutStdErr(i, NOARGS);    /* Put out an error message */

            i = mystrlen(bufdst) ;

            if ( bufdst[--i] == DOT ) {             /* @@5a     */
                bufdst[i] = 0 ;                         /* @@5a     */
            }                                          /* @@5a     */
            /* @@5a     */
/*509*/if (!_tcsicmp(Source,bufdst)) {           /* @@5a     */
                break ;                                 /* @@5a     */
            }                                          /* @@5a     */

        } else
            if (file_moved) {
            number_of_files_moved += 1;
            if ( wild_flag ) {           /* If wild card is used */
                cmd_printf(Fmt17,Source); /* display the file name*/
            }

        }

        if (fl_move_once)
            break;

    } while (fnext(a1info->buf, attr, hnFirst ));


    /**********************************************/
    /*           No more files to be found        */
    /**********************************************/

    findclose(hnFirst) ;
    RestoreSavedDirectory( );

    /**********************************************/
    /* Display the total number of file(s) moved  */
    /**********************************************/

    if ( (a1info->buf->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        PutStdOut(MSG_FILES_MOVED, ONEARG,
                  argstr1(TEXT("%9d"), (unsigned long)number_of_files_moved)) ;
    } else {
        PutStdOut(MSG_DIRS_MOVED, ONEARG,
                  argstr1(TEXT("%9d"), (unsigned long)number_of_files_moved)) ;
    }
    
    return(save_error == NO_ERROR ? SUCCESS : FAILURE) ;
}


int
eTitle (

       IN  struct cmdnode *pcmdnode
       ) {

    LPTSTR NewTitle;
    if (!pszTitleCur) {

        pszTitleCur = HeapAlloc(GetProcessHeap(), 0, MAX_PATH*sizeof(TCHAR) + 2*sizeof(TCHAR));
        if (pszTitleCur == NULL) {

            PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
            return( FAILURE );

        }

    }

    if (mystrlen(pcmdnode->argptr) >= MAX_PATH) {

        PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
        return( FAILURE );

    }

    NewTitle = EatWS(pcmdnode->argptr, NULL);
    if (NewTitle && *NewTitle) {
        mystrcpy(pszTitleCur,NewTitle);
    }
    SetConsoleTitle(pszTitleCur);

    //
    // This insures that ResetConTitle does not undo what
    // we have just done
    //
    fTitleChanged = FALSE;
    return( SUCCESS );
}

/***    eStart - Entry point for Start routine
 *
 *  Purpose:
 *      to call Start and pass it a pointer to the command line
 *      arguments
 *
 *  Args:
 *      a pointer to the command node structure
 *
 */

int eStart( n )                     /* @@ */
struct cmdnode *n;                  /* @@ */
{                                       /* @@ */
    DBG_UNREFERENCED_PARAMETER( n );
    return( Start(n->argptr) );
}                                   /* @@ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cdebug.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cdebug.c

Abstract:

    Internal debugging support

--*/

#include "cmd.h"

#if CMD_DEBUG_ENABLE
/***	MSDOS Ver 4.0 Command Interpreter    Part 20 of 22  CDEBUG.C
 *
 *  This file contains all of the C routines in Command's debugging
 *  package.
 *
 *  The printing of debugging messages can be sectionally enabled at
 *  runtime through the first 2 arguments passed to this program.  The
 *  first one controls the groups to enable and the second one controls
 *  the level of detail in the groups to enable. (Numbers are in hex.)
 *
 *  Group   Level   Meaning
 *  ===========================================================
 *   0001	Main Command Loop Code (Main & Dispatch)
 *	 0001	    Main function
 *	 0002	    Dispatch function
 *   0002	Command Initialization
 *	 0001	    Argument checking
 *	 0002	    Environment initialization
 *	 0004	    Rest of initialization
 *   0004	Parser
 *	 0001	    Parsing
 *	 0002	    Lexing
 *	 0004	    Input routine
 *	 0008	    Dump parse tree to stdin
 *	 0010	    Byte input routine
 *   0008	Operators
 *	 0001	    Pipe level
 *	 0002	    Detach level
 *	 0004	    Other operators level
 *   0010	Path Commands
 *	 0001	    Mkdir level
 *	 0002	    Chdir level
 *	 0004	    Rmdir level
 *   0020	File Commands
 *	 0001	    Copy level
 *	 0002	    Delete level
 *	 0004	    Rename level
 *   0040	Informational Commands
 *	 0001	    Directory level
 *	 0002	    Type level
 *	 0004	    Version level
 *	 0008	    Volume level
 *	 0016	    Priv level
 *	 0032	    Console Level
 *	 0064	    Dislplay Level
 *   0080	Environment Commands
 *	 0001	    Path level
 *	 0002	    Prompt level
 *	 0004	    Set level
 *	 0008	    Other envirnment functions
 *       0010	    Environment scanning for external commands
 *   0100	Batch Processor
 *	 0001	    Batch processor
 *	 0002	    FOR processor
 *	 0004	    IF processor
 *	 0008	    Other batch commands
 *   0200	External Command Execution
 *	 0001	    External commands level
 *   0400	Other Commands
 *	 0001	    Break command
 *	 0002	    Cls command
 *	 0004	    Ctty command
 *	 0008	    Exit command
 *	 0010	    Verify command
 *   0800	Signal Handler
 *	 0001	    Main Signal handler level
 *	 0002	    Init Signal handler level
 *   1000	Memory Manager
 *	 0001	    Memory allocators
 *	 0002	    List managers
 *	 0004	    Segment manipulators
 *   2000	Common command tools
 *	 1000	    ScanFSpec level
 *	 2000	    SetFSSetAndSaveDir() level
 *       4000       TokStr() level
 *       8000       FullPath level
 *   4000	Clock manipulators
 *	 0001	    Date command level
 *	 0002	    Time command level
 *
 *
 *  None of the debugging code is included in the program if the
 *  value DBG is defined.
 *
 *
 *  Eric K. Evans, Microsoft
 */

/***	Modification History
 *
 */

extern unsigned DebGroup ;
extern unsigned DebLevel ;



/***	Deb - conditionally print debugging messages
 *
 *  Deb(MsgGroup, MsgLevel, msg, arg0, arg1, arg2, arg3, arg4)
 *
 *  Args:
 *	MsgGroup - The group of the message that wants to be printed.
 *	MsgLevel - The level of the message that wants to be printed.
 *	msg  - A printf style message string.
 *	arg0-4	 - The other args to be printed.
 *
 */
void
Deb(ULONG MsgGroup, ULONG MsgLevel, CHAR *msg, ...)
{
        CHAR  Buffer[ 512 ];
	va_list     args;
	CHAR	*pch = Buffer;
	int	cb;


	va_start( args, msg );
	cb = _vsnprintf( Buffer, 512, msg, args );
	va_end( args );
	if (cb > 512)
            fprintf(stderr, "Debug output buffer length exceeded - crash imminent\n");
        Buffer[511] = '\0'; // null-terminate the buffer in case the _vsnprintf filled the buffer

	while (*pch) {
		if (*pch == '\n' || *pch == '\r')
			*pch = '#';
		pch++;
	}

	if ((MsgGroup & DebGroup) && (MsgLevel & DebLevel)) {
		OutputDebugStringA(Buffer);
		OutputDebugStringA("\n");
	}
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cinfo.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cinfo.c

Abstract:

    Information command support

--*/

#include "cmd.h"

#define TYPEBUFSIZE     80
#define TYPEREADSIZE    512

extern UINT CurrentCP;

extern unsigned DosErr ;

extern unsigned tywild;     /* @@5@J1 type wild cards   */

extern TCHAR CurDrvDir[] ;

extern TCHAR VolSrch[] ;         /* M006 - Search string for Volume ID      */
extern TCHAR AppendStr[] ;

extern TCHAR Fmt26[], Fmt25[];

extern unsigned LastRetCode;
extern BOOL CtrlCSeen;

struct FSVol {
        unsigned long SerNum ;          /* Volume serial number            */
        TCHAR len ;                      /* Volume name len (excludes \0)   */
        TCHAR name[257] ;                /* Volume name asciz               */
        };

int ZScanA(BOOL flag, PCHAR buf, PULONG buflen, PULONG skip);

/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: eDirectory                                  */
/*                                                              */
/* DESCRIPTIVE NAME: Begin execution of the DIR command         */
/*                                                              */
/* FUNCTION: To list out the files on a disk.  eDirectory will  */
/*           be called whenever the user enters the DIR command */
/*           on the command line.  DIR will continue if it      */
/*           encounters an invalid argument.                    */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: eDirectory                                      */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: n - the parse tree node containing the DIR command    */
/*                                                              */
/* EXIT-NORMAL: return SUCCESS if no errors occur               */
/*                                                              */
/* EXIT-ERROR:  return FAILURE otherwise                        */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      Dir - lists out the files in a directory                */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

int eDirectory(n)
struct cmdnode *n ;
{
    return(LastRetCode = Dir(n->argptr)) ;
}




/***    eType - begin the execution of a Type command
 *
 *  Purpose:
 *      To type the contents of an arbitrary number of files.
 *
 *  int eType(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree note containing the type command
 *
 *  Returns:
 *      SUCCESS if all of the files were successfully typed.
 *      FAILURE otherwise.
 *
 */

int eType(n)
struct cmdnode *n ;
{

 //
 // Removed LTA_NOMATCH from flags. This caused a *.xxx to call the TyWork
 // function which would think that *.xxx is a file and try to open it.
 //
 return(LastRetCode = LoopThroughArgs(n->argptr, TyWork, LTA_EXPAND | LTA_CONT | LTA_NOMATCH)) ;
}




/***    TyWork - display a file
 *
 *  Purpose:
 *      Write the contents of the file specified in fspec to stdout.
 *      Output ends when all of fspec has been written or a ^Z is found in
 *      fspec.
 *
 *  int TyWork(TCHAR *fspec)
 *
 *  Args:
 *      fspec - the name of the file to write out
 *
 *  Returns:
 *      SUCCESS if the file was written.
 *      FAILURE otherwise, such as inability to allocate a temporary buffer
 */

int TyWork(TCHAR *fspec) {
    TCHAR       fspec_temp[MAX_PATH];
    TCHAR       TypeBufW[TYPEREADSIZE*3];
    CHAR        TypeBuf[TYPEREADSIZE+1];
    ULONG       result;
    BOOL        flag;
    const TCHAR       *bptr;
    ULONG       fDevice = 0;
    ULONG       maxbytes = 0xFFFFFFFF ; // max file size
    ULONG       bytestoctlz ;           // Number of bytes read
    ULONG       bytesread ;             // Number of bytes read
    ULONG       byteswrit ;             // Number of bytes read
    ULONG       brcopy ;                // Bytes to copy
    CRTHANDLE   fh ;                    // File handle
    int         first_read;             // first read on file for wild

    int         TypeBufSize;
    int         rc;
    LONG        bWrite;
    CHAR       *pType;
#ifdef UNICODE
    WCHAR       wc;
    BOOL        fUnicode=FALSE;
#endif // UNICODE

    TypeBufSize = TYPEREADSIZE;

    first_read = TRUE;      /* set flag to test for wilds   @@5@J1 */

    DEBUG((ICGRP, TYLVL, "TYWORK: fspec = `%ws'", fspec)) ;
    if ((fh = Copen(fspec, O_RDONLY)) == BADHANDLE) {

        bptr = MyGetEnvVarPtr(AppendStr);
        if ( bptr != NULL &&
             SearchPath( bptr,
                         (TCHAR *)fspec,
                         NULL,
                         (unsigned)MAX_PATH,
                         (TCHAR *)fspec_temp,
                         NULL ) != 0) {
           fh = Copen(fspec_temp, O_RDONLY);
        }
    }

    if ( fh == BADHANDLE )  {

        if (DosErr == ERROR_INVALID_NAME) {
            DosErr = ERROR_FILE_NOT_FOUND;
        }
        PrtErr(DosErr) ;
        rc = FAILURE;
        goto TypeExit;

    }

    /************************************************************/
    /*  M004 - Added code to get max file size if not device    */
    /************************************************************/

    bptr = (TCHAR*)TypeBuf;               /* Copy of original pointer*/
    if (!FileIsDevice(fh)) {
        maxbytes = GetFileSize(CRTTONT(fh), NULL) ; /* Get file size  */
        SetFilePointer(CRTTONT(fh), 0L, NULL, FILE_BEGIN) ;   /* Return pointer*/
        fDevice = 1 ;           /* Set no device flag      */
        DEBUG((ICGRP,TYLVL,"TYWORK: Is file, size=%d", maxbytes)) ;
    }

    do {
        if (CtrlCSeen) {
            Cclose(fh) ;
            rc = FAILURE;
            goto TypeExit;
        }
        if (!ReadFile(CRTTONT(fh), TypeBuf, TypeBufSize, (LPDWORD)&bytesread, NULL)) {
            DosErr = GetLastError();
            PutStdErr(DosErr, NOARGS);
            break;
        }
        if (bytesread == 0) {
            break;
        }

#ifdef UNICODE
        if (first_read) {
            fUnicode = *(LPWSTR)TypeBuf == BYTE_ORDER_MARK;
            if (fUnicode) {
                bytesread -= sizeof( TCHAR );
                MoveMemory( TypeBuf, TypeBuf + sizeof( TCHAR ), bytesread );
            }
        }
#endif // UNICODE

        bytestoctlz = bytesread;
#ifdef UNICODE
        if (fUnicode) {
            if (first_read) {
                DEBUG((ICGRP, TYLVL, "TYWORK: file is unicode")) ;
            }
            brcopy = bytesread / sizeof(TCHAR);
        } else
#endif // UNICODE
        if (FileIsConsole(STDOUT)
#ifdef UNICODE
              || fOutputUnicode
#endif // UNICODE
           ) {
            PCHAR   pch = TypeBuf;

            brcopy = bytesread;
            while (brcopy > 0) {
                if (is_dbcsleadchar(*pch)) {
                    pch++;
                    if (--brcopy == 0) {
                        if (!ReadFile(CRTTONT(fh), pch, 1, &brcopy, NULL)) {
                            DosErr = GetLastError();
                            PutStdErr(DosErr, NOARGS);
                            Cclose(fh) ;
                            rc = SUCCESS;
                            goto TypeExit;
                        }
                        bytesread++;
                        bytestoctlz = bytesread;
                        break;
                    }
                }
                pch++;
                brcopy--;
            }

            result = 0;
            flag = ZScanA(TRUE, (PCHAR)TypeBuf, &bytestoctlz, &result);
            DEBUG((ICGRP, TYLVL, "TYWORK: converting %d bytes to unicode", flag?bytesread:bytestoctlz)) ;

            if ( (!flag) && (bytestoctlz == 0) )
                break;

            brcopy = MultiByteToWideChar(CurrentCP, 0,
                (LPCSTR)TypeBuf, flag?bytesread:bytestoctlz,
                (LPWSTR)TypeBufW, TypeBufSize*2);
            if (brcopy == 0) {
                DEBUG((ICGRP, TYLVL, "TYWORK: Error converting to Unicode: %d", GetLastError())) ;
                brcopy = TypeBufSize*2;
            }
            bptr = TypeBufW;
        } else {
            brcopy = bytesread;
        }

        if (first_read) {
            if (tywild)
                PutStdErr(MSG_TYPE_FILENAME, ONEARG, fspec);
            first_read = FALSE;
        }

        DEBUG((ICGRP, TYLVL, "TYWORK: bytesread = %d, brcopy = %d", bytesread, brcopy)) ;

        bWrite = brcopy;
        pType  = (CHAR *)bptr;
        while ( bWrite > 0 ) {

            ULONG bToWrite = min( TYPEBUFSIZE, bWrite );

            if ( bToWrite == 0 ) {
                break;
            }

            if (CtrlCSeen) {
                Cclose(fh) ;
                rc = FAILURE;
                goto TypeExit;
            }

            if (FileIsConsole(STDOUT)) {

                DEBUG((ICGRP, TYLVL, "TYWORK: Writing to console")) ;
                flag = WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), pType, bToWrite, &byteswrit, NULL);
                if (flag == 0 || byteswrit != bToWrite) {
                    goto try_again;
                }
                bWrite -= byteswrit;
                byteswrit *= sizeof(TCHAR);
                pType  += byteswrit;

#ifdef UNICODE
            } else if (fOutputUnicode || fUnicode) {

                if ( fUnicode ) {
                    wc = *((TCHAR*)pType + bToWrite);
                    *((TCHAR*)pType + bToWrite) = UNICODE_NULL;
                }

                DEBUG((ICGRP, TYLVL, "TYWORK: Writing unicode text to file")) ;
                flag = MyWriteFile(
                  STDOUT,       /* device         */
                  pType,                 /* bytes          */
                  bToWrite * sizeof(TCHAR), /* bytes to write */
                  &byteswrit);      /* bytes actually written   */

                if ( fUnicode ) {
                    *((TCHAR*)pType + bToWrite) = wc;
                }

                bWrite -= byteswrit/sizeof(TCHAR);
                pType  += byteswrit;
#endif // UNICODE

            } else {

try_again:
                DEBUG((ICGRP, TYLVL, "TYWORK: Writing dbcs text to file")) ;
                flag = WriteFile(CRTTONT(STDOUT), pType, bToWrite, &byteswrit, NULL);
                bWrite -= byteswrit;
                pType  += byteswrit;
                byteswrit *= sizeof(TCHAR);
            }

            DEBUG((ICGRP, TYLVL, "TYWORK: flag = %d, byteswrit = %d", flag, byteswrit)) ;
            if (flag == 0 || byteswrit != bToWrite*sizeof(TCHAR)) {
                DosErr = GetLastError();
                if (!DosErr) {
                    DosErr = ERROR_DISK_FULL ;
                }
                if (FileIsDevice(STDOUT)) {
                    PutStdErr(ERROR_WRITE_FAULT, NOARGS);
                } else {
                    if (FileIsPipe(STDOUT)) {
                        PutStdErr(MSG_CMD_INVAL_PIPE, NOARGS);
                    } else {
                        PrtErr(DosErr);
                    }
                    Cclose(fh);
                    rc = FAILURE;
                    goto TypeExit;
                }
            }

        }

        if (fDevice) {  /* If not device            */
            /* Get new position ptr     */
            fDevice = SetFilePointer(CRTTONT(fh), 0, NULL, FILE_CURRENT);
        }

        /*************************************************/
        /* Added check below for current file position   */
        /*   at original EOF                             */
        /*************************************************/

    } while((bytesread == bytestoctlz) && (maxbytes > fDevice));

    Cclose(fh) ;
    rc = SUCCESS;

TypeExit:
    return(rc) ;
}




/***    eVersion - execute the Version command
 *
 *  Purpose:
 *      To print DOS version information.
 *
 *  int eVersion(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the version command. N will be NULL
 *          if eVersion was called from PrintPrompt().
 *
 *  Returns:
 *      SUCCESS always.
 *
 */

int
eVersion(
    struct cmdnode *n
    )
{
    TCHAR VersionFormat[32];

    GetVersionString( VersionFormat, sizeof( VersionFormat ) / sizeof( VersionFormat[0] ));
    
    if (n)
        cmd_printf( CrLf );

    PutStdOut( MSG_MS_DOS_VERSION,
               ONEARG,
               VersionFormat );
    if (n)
        cmd_printf( CrLf );


    return(LastRetCode = SUCCESS) ;
}


/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: eVolume                                     */
/*                                                              */
/* DESCRIPTIVE NAME: Begin execution of the VOL command         */
/*                                                              */
/* FUNCTION: eVolume will print out the volume label and serial */
/*           number for an arbitrary number of drives, and will */
/*           continue if it encounters an invalid argument.     */
/*           This routine is called when the user enters VOL    */
/*           on the command line.                               */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: eVolume                                         */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: n - a parse tree node containing the VOL command      */
/*                                                              */
/* EXIT-NORMAL: returns SUCCESS if the command was well formed, */
/*              and was executed successfully.                  */
/*                                                              */
/* EXIT-ERROR:  returns FAILURE otherwise.                      */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      LoopThroughArgs - breaks up command line, calls VolWork */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

int eVolume(n)
struct cmdnode *n ;
{

    return(LastRetCode = LoopThroughArgs(n->argptr, VolWork, LTA_CONT|LTA_NULLOK)) ;
}


/**************** START OF SPECIFICATIONS ***********************/
/*                                                              */
/* SUBROUTINE NAME: VolWork                                     */
/*                                                              */
/* DESCRIPTIVE NAME: Display the volume ID of a drive           */
/*                                                              */
/* FUNCTION: VolWork will print the volume label and serial     */
/*           number of a specific drive.                        */
/*                                                              */
/* NOTES:                                                       */
/*                                                              */
/* ENTRY POINT: VolWork                                         */
/*     LINKAGE: Near                                            */
/*                                                              */
/* INPUT: drvspec - a pointer to a character specifying the     */
/*                  drive to print the information for.  If the */
/*                  character is null, the information for the  */
/*                  current drive is displayed.                 */
/*                                                              */
/* EXIT-NORMAL: returns SUCCESS if the command was executed     */
/*              successfully                                    */
/*                                                              */
/* EXIT-ERROR:  returns FAILURE otherwise                       */
/*                                                              */
/* EFFECTS: None.                                               */
/*                                                              */
/* INTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      PutStdOut - Writes output to standard out               */
/*      PutStdErr - Writes output to standard error             */
/*                                                              */
/* EXTERNAL REFERENCES:                                         */
/*    ROUTINES:                                                 */
/*      DOSQFSINFO                                              */
/*                                                              */
/**************** END OF SPECIFICATIONS *************************/

int VolWork(drvspec)
TCHAR *drvspec ;
{
        struct FSVol vol ;
        unsigned DNum ;
        TCHAR c ;
        TCHAR VolumeRoot[] = TEXT(" :\\");
        DWORD Vsn[2];
        BOOL b;

        DEBUG((ICGRP, VOLVL, "VOLWORK: drvspec = `%ws'", drvspec)) ;

        if (*drvspec == NULLC) {
                DNum = 0 ;
                c = (TCHAR) _totupper(CurDrvDir[0]) ;
        } else if ((mystrlen(drvspec) == 2) &&
                   *(drvspec+1) == COLON &&
                   _istalpha(*drvspec)) {
                c = (TCHAR) _totupper(*drvspec) ;
                DNum = (unsigned)(c - 0x40) ;
        } else {
                cmd_printf(CrLf);
                PutStdErr(ERROR_INVALID_DRIVE, NOARGS) ;          /* M013    */
                return(FAILURE) ;
        } ;

        VolumeRoot[0] = c;
        b = GetVolumeInformation(
                VolumeRoot,
                vol.name,
                sizeof( vol.name ) / sizeof( TCHAR ),
                Vsn,
                NULL,
                NULL,
                NULL,
                0);

        if (!b) {

           DEBUG((ICGRP, VOLVL, "VOLWORK: GetVolumeInformation ret'd %d", GetLastError())) ;

           cmd_printf(CrLf);
           if (GetLastError() == ERROR_NOT_READY)
                   PutStdErr(ERROR_NOT_READY, NOARGS) ;
           else
                   PutStdErr(GetLastError(), NOARGS) ;                       /* @@5a */
           return(FAILURE) ;
        } else {
           if (b && vol.name[0]) {
/* M013 */    PutStdOut(MSG_DR_VOL_LABEL, TWOARGS,
                        argstr1( TEXT("%c"), (ULONG_PTR)c),
                        vol.name ) ;
           }
           else {
/* M013 */    PutStdOut(MSG_HAS_NO_LABEL, ONEARG,
                          argstr1( TEXT("%c"), (ULONG_PTR)c)) ;
           }
/* @@5 */  if (b) {           // FIX, FIX
              TCHAR Buffer[128];
              _sntprintf(Buffer, 128, Fmt26,
                          (Vsn[0] & 0xffff0000)>>16, (Vsn[0] & 0xffff));
              Buffer[127] = TEXT( '\0' );
              PutStdOut(MSG_DR_VOL_SERIAL, ONEARG, Buffer );
/* @@5 */  }
        } ;

        return(SUCCESS) ;
}

/****************************************************************
 *
 *  ZScanA - scan data in an arbitrary segment for ^Zs
 *
 *   Purpose:
 *      If flag is on, scan buffer for a ^Z.  If it is found, update the
 *      buffer length and return 0.  Otherwise return -1.
 *      Double byte characters are taken into account.
 *
 *   int ZScanA(int flag, long buffer, unsigned *buflenptr, int *skip_first)
 *
 *   Args:
 *      flag - nonzero if any scanning is to be done
 *      buffer - a long pointer to the buffer to use
 *      buflenptr - ptr to the length of buffer
 *      skip_first - ptr to an integer. The initial value of *skip_first
 *              must be 0 on the first call when scanning a file. There
 *              after, the caller leaves *skip_first alone. ZScan uses
 *              the variable to remember if the first byte of the next
 *              buffer is going to be the second have of a double
 *              byte character.
 *
 *   Returns:
 *      See above.
 *
 *   Notes:
 *      This routine will need to be modified once the MMU code is in the DOS.
 *      macro is defined in cmd.h.
 *
 *
 *      ZScanA
 *      if (flag) then
 *              buffer = buffer + *skip_first
 *              dbcs_flag = 0
 *              count = *buflenptr - *skip_first
 *              use rep scanb to find first ^Z in buffer
 *              if (no ^z was found)
 *                      goto FZSNoZ
 *              do {
 *                      count++;
 *                      buffer--;
 *              } until (*buffer < 0x80 || count = *buflenptr);
 *              while (--count > 0) loop
 *                      if (dbcs_flag == 0) then
 *                              if (*buffer == ^Z) then
 *                                      *buflenptr = count
 *                                      return(0)
 *                              else if (*buffer is a dbcs_lead_char) then
 *                                      dbcs_flag = 1
 *                              endif
 *                              endif
 *                      else
 *                              dbcs_flag = 0
 *                      buffer = buffer + 1
 *                      count = count - 1
 *              end loop
 *              *skip_first = dbcs_flag
 *      endif
 *FZSNoZ:
 *      return(-1)
 *----
 ****************************************************************/


int
ZScanA(BOOL flag, PCHAR buf, PULONG buflen, PULONG skip)
{
    PCHAR pbuf = buf,
          bufend;

    CHAR  c0 = '\0';

    if ( flag ) {
        pbuf += *skip;
        bufend = buf + *buflen - *skip;

        while (pbuf < bufend) {
            if (is_dbcsleadchar(c0=*pbuf))
                pbuf++;
            if (c0 == CTRLZ)
                break;
            pbuf++;
        }

        if (c0 == CTRLZ) {
            // *buflen = pbuf+1 - buf;
            *buflen = (ULONG)(pbuf - buf);
            *skip = 0;
            return(0);
        }
        else {
            *skip = (ULONG)(pbuf - bufend);
        }
    }
    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cinit.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cinit.c

Abstract:

    Initialization

--*/

#include "cmd.h"

#if CMD_DEBUG_ENABLE
unsigned DebGroup=0;
unsigned DebLevel=0;
#endif

#if defined(RICHARDW)
TCHAR Buffer27[TMPBUFLEN];
#endif


TCHAR CurDrvDir[MAX_PATH] ;     /* Current drive and directory            */
BOOL SingleBatchInvocation = FALSE ;
BOOL SingleCommandInvocation = FALSE;
BOOLEAN  fDisableUNCCheck = FALSE;
int      cmdfound = -1;         /* @@5  - command found index              */
int      cpyfirst = TRUE;       /* @@5  - flag to ctrl DOSQFILEMODE calls  */
int      cpydflag = FALSE;      /* @@5  - flag save dirflag from las DQFMDE*/
int      cpydest  = FALSE;      /* @@6  - flag to not display bad dev msg  */
int      cdevfail = FALSE;      /* @@7  - flag to not display extra emsg   */
#ifdef UNICODE
BOOLEAN  fOutputUnicode = FALSE;/* Unicode/Ansi output */
#endif // UNICODE

BOOLEAN  fEnableExtensions = FALSE;
BOOLEAN  fDefaultExtensions = TRUE;
BOOLEAN  fDelayedExpansion = FALSE;

BOOLEAN ReportDelayLoadErrors = TRUE;

unsigned tywild = 0;          /* flag to tell if wild type args    @@5 @J1 */
int array_size = 0 ;     /* original array size is zero        */
CPINFO CurrentCPInfo;
UINT CurrentCP;

WORD    wDefaultColor = 0;      // default is whatever console currently has
                                // but default can be overriden by the registry.
TCHAR chCompletionCtrl = SPACE; // Default is no completion (must be Ctrl character)
TCHAR chPathCompletionCtrl = SPACE;



VOID InitLocale( VOID );

extern TCHAR ComSpec[], ComSpecStr[] ;       /* M021 */
extern TCHAR PathStr[], PCSwitch, SCSwitch, PromptStr[] ;
extern TCHAR PathExtStr[], PathExtDefaultStr[];
extern TCHAR BCSwitch ;  /* @@ */
extern TCHAR QCSwitch ;  /* @@dv */
extern TCHAR UCSwitch;
extern TCHAR ACSwitch;
extern TCHAR XCSwitch;
extern TCHAR YCSwitch;
extern TCHAR DevNul[], VolSrch[] ;       /*  M021 - To set PathChar */

extern TCHAR SwitChar, PathChar ;        /*  M000 - Made non-settable       */
extern int Necho ;                      /*  @@dv - true if /Q for no echo  */

extern TCHAR MsgBuf[];

extern TCHAR TmpBuf[] ;                                      /* M034    */

extern TCHAR ComSpec[];

TCHAR *CmdSpec = &ComSpec[1];                                    /* M033    */

extern unsigned DosErr ;             /* D64 */

//
// TRUE if the ctrl-c thread has been run.
//
BOOL CtrlCSeen;

//
// Set TRUE when it is ok the print a control-c.
// If we are waiting for another process this will be
// FALSE
BOOLEAN fPrintCtrlC = TRUE;

//
// console mode at program startup time. Used to reset mode
// after running another process.
//
DWORD   dwCurInputConMode;
DWORD   dwCurOutputConMode;

//
// Initial Title. Used for restoration on abort etc.
// MAX_PATH was arbitrary
//
PTCHAR    pszTitleCur;
PTCHAR    pszTitleOrg;
BOOLEAN  fTitleChanged = FALSE;     // title has been changed and needs to be  reset

//
// used to gate access to ctrlcseen flag between ctrl-c thread
// and main thread
//
CRITICAL_SECTION    CtrlCSection;
LPCRITICAL_SECTION  lpcritCtrlC;

//
// Used to set and reset ctlcseen flag
//
VOID    SetCtrlC();
VOID    ResetCtrlC();

Handler(
    IN ULONG CtrlType
    )
{
    if ( (CtrlType == CTRL_C_EVENT) ||
         (CtrlType == CTRL_BREAK_EVENT) ) {

        //
        // Note that we had a ^C event
        //

        SetCtrlC();

        //
        //  Display the ^C if we are enabled and if we're not in a batch file
        //
        
        if (fPrintCtrlC && CurrentBatchFile != NULL) {

            fprintf( stderr, "^C" );
            fflush( stderr );

        }
        return TRUE;
    } else {
        return FALSE;
    }
}

/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: Init                                               */
/*                                                                     */
/* DESCRIPTIVE NAME: CMD.EXE Initialization Process                    */
/*                                                                     */
/* FUNCTION: Initialization of CMD.EXE.                                */
/*                                                                     */
/* NOTES:                                                              */
/*                                                                     */
/* ENTRY POINT: Init                                                   */
/*                                                                     */
/* INPUT: None.                                                        */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Return the pointer to command line.                         */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return NULL string.                                         */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/
/***    Init - initialize Command
 *
 *  Purpose:
 *      Save current SIGINTR response (SIGIGN or SIGDEF) and set SIGIGN.
 *      If debugging
 *          Set DebGroup & DebLevel
 *      Check for any switches.
 *      Make a version check.
 *          If version out of range
 *          Print error message.
 *          If Permanent Command
 *              Loop forever
 *          Else
 *              Exit.
 *      Save the current drive and directory.
 *      Check for other command line arguments.
 *      Set up the environment.
 *      Always print a bannner if MSDOS version of Command.
 *      Return any "comline" value found.
 *
 *  TCHAR *Init()
 *
 *  Args:
 *
 *  Returns:
 *      Comline (it's NULL if NOT in single command mode).
 *
 *  Notes:
 *      See CSIG.C for a description of the way ^Cs and INT24s are handled
 *      during initialization.
 *      M024 - Brought functionality for checking non-specific args into
 *      init from routines CheckOtherArgs and ChangeComSpec which have
 *      been eliminated.
 *
 */

BOOL Init(
    TCHAR *InitialCmds[]
    )
{
#if 0                          /* Set debug group and level words */

        int fh;
        PTCHAR nptr;

        nptr = TmpBuf;
        nptr = EatWS(nptr, NULL);
        nptr = mystrchr(nptr, TEXT(' '));
        nptr = EatWS(nptr, NULL);

        //
        // Assume a non-zero debugging group
        //
        DebGroup = hstoi(nptr) ;                        /* 1st debug arg   */
        if (DebGroup) {
            for (fh=0 ; fh < 2 ; fh++) {
                if (fh == 1)
                    DebLevel = hstoi(nptr) ;        /* 2nd debug arg   */
                while(*nptr && !_istspace(*nptr)) {       /* Index past it   */
                    ++nptr ;
                }
                nptr = EatWS(nptr, NULL) ;
            }
        }

        DEBUG((INGRP, RSLVL, "INIT: Debug GRP=%04x  LVL=%04x", DebGroup, DebLevel)) ;
        mystrcpy(TmpBuf, nptr) ;                  /* Elim from cmdline       */
#endif
        //
        // Initialize Critical Section to handle access to
        // flag for control C handling
        //
        lpcritCtrlC = &CtrlCSection;
        InitializeCriticalSection(lpcritCtrlC);
        ResetCtrlC();

        SetConsoleCtrlHandler(Handler,TRUE);

        //
        // Make sure we have the correct console modes.
        //
        ResetConsoleMode();

#ifndef UNICODE
        setbuf(stdout, NULL);           /* Don't buffer output       @@5 */
        setbuf(stderr, NULL);                                     /* @@5 */
        _setmode(1, O_BINARY);        /* Set output to text mode   @@5 */
        _setmode(2, O_BINARY);                                  /* @@5 */
#endif

        InitEnv( );

        GetRegistryValues(InitialCmds);

        if (_tcslen( GetCommandLine( )) + 1 > TMPBUFLEN) {
            PutStdErr( MSG_COMMAND_LINE_TOO_LONG, NOARGS );
            CMDexit(1) ;
        }
        
        mystrcpy(TmpBuf, GetCommandLine());
        LexCopy( TmpBuf, TmpBuf, mystrlen( TmpBuf ) );  /* convert dbcs spaces */

        GetDir(CurDrvDir, GD_DEFAULT) ;

        SetUpEnvironment() ;

        /* Check cmdline switches  */
        CheckSwitches(InitialCmds, TmpBuf);

        if (CurDrvDir[0] == BSLASH && CurDrvDir[1] == BSLASH) {
            if (!fDisableUNCCheck) {
                PutStdErr(MSG_NO_UNC_INITDIR, ONEARG, CurDrvDir);
                if( GetWindowsDirectory(CurDrvDir, sizeof( CurDrvDir )/sizeof( TCHAR )) ) {
                    ChangeDir2(CurDrvDir, TRUE);
                } else {
                    CMDexit( 1 );
                }
            }
        }

        //
        // Get current CodePage Info.  We need this to decide whether
        // or not to use half-width characters.  This is actually here
        // in the init code for safety - the Dir command calls it before
        // each dir is executed, because chcp may have been executed.
        //
        GetCPInfo((CurrentCP=GetConsoleOutputCP()), &CurrentCPInfo);

        InitLocale();

        pszTitleCur = HeapAlloc(GetProcessHeap(), 0, MAX_PATH*sizeof(TCHAR) + 2*sizeof(TCHAR));
        pszTitleOrg = HeapAlloc(GetProcessHeap(), 0, MAX_PATH*sizeof(TCHAR) + 2*sizeof(TCHAR));
        if ((pszTitleCur != NULL) && (pszTitleOrg != NULL)) {

            if (GetConsoleTitle(pszTitleOrg, MAX_PATH)) {
                mystrcpy(pszTitleCur, pszTitleOrg);
            } else {
                *pszTitleCur = 0;
                *pszTitleOrg = 0;
            }
        }

        if (!SingleCommandInvocation) {
            if (FileIsConsole(STDOUT)) {
#ifndef WIN95_CMD
                CONSOLE_SCREEN_BUFFER_INFO  csbi;

                if (!wDefaultColor) {
                    if (GetConsoleScreenBufferInfo( GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
                        wDefaultColor = csbi.wAttributes;
                    }
                }
#endif // WIN95_CMD
                if (wDefaultColor) {
                    SetColor( wDefaultColor );
                }
            }
        }

        /* Print banner if no command string on command line */
        if (!InitialCmds[2]) {
            TCHAR VersionFormat[32];

            GetVersionString( VersionFormat, sizeof( VersionFormat ) / sizeof( VersionFormat[0] ));
        
            PutStdOut( MSG_MS_DOS_VERSION,
                       ONEARG,
                       VersionFormat );
            
            cmd_printf( CrLf );
            
            PutStdOut( MSG_COPYRIGHT, NOARGS ) ;
            
            if (fDefaultExtensions) {
                //
                // DaveC says say nothing to user here.
                //
                // PutStdOut(MSG_EXT_ENABLED_BY_DEFAULT, NOARGS);
            } else
            if (fEnableExtensions) {
                PutStdOut(MSG_EXT_ENABLED, NOARGS) ;
            }
        }

        DEBUG((INGRP, RSLVL, "INIT: Returning now.")) ;

#ifndef WIN95_CMD
        {
            hKernel32 = GetModuleHandle( TEXT("KERNEL32.DLL") );
            lpCopyFileExW = (LPCOPYFILEEX_ROUTINE)
                GetProcAddress( hKernel32, "CopyFileExW" );
    
            lpIsDebuggerPresent = (LPISDEBUGGERPRESENT_ROUTINE)
                GetProcAddress( hKernel32, "IsDebuggerPresent" );
    
            lpSetConsoleInputExeName = (LPSETCONSOLEINPUTEXENAME_ROUTINE)
                GetProcAddress( hKernel32, "SetConsoleInputExeNameW" );
        }

#endif // WIN95_CMD

        return(InitialCmds[0] != NULL || InitialCmds[1] != NULL || InitialCmds[2] != NULL);
}


void GetRegistryValues(
    TCHAR *InitialCmds[]
    )
{
    long rc;
    HKEY hKey;
    ULONG ValueBuffer[ 1024 ];
    LPBYTE lpData;
    DWORD cbData;
    DWORD dwType;
    DWORD cchSrc, cchDst;
    PTCHAR s;
    int i;
    HKEY PredefinedKeys[2] = {HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER};

    if (fDefaultExtensions) {
        fEnableExtensions = TRUE;
    }

    for (i=0; i<2; i++) {
        rc = RegOpenKey(PredefinedKeys[i], TEXT("Software\\Microsoft\\Command Processor"), &hKey);
        if (rc) {
            continue;
        }

        dwType = REG_NONE;
        lpData = (LPBYTE)ValueBuffer;
        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("DisableUNCCheck"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                fDisableUNCCheck = (BOOLEAN)(*(PULONG)lpData != 0);
                }
            else
            if (dwType == REG_SZ) {
                fDisableUNCCheck = (BOOLEAN)(_wtol((PWSTR)lpData) == 1);
#if defined(RICHARDW)
            _tcscpy( Buffer27, (PWSTR)lpData );
#endif
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("EnableExtensions"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                fEnableExtensions = (BOOLEAN)(*(PULONG)lpData != 0);
                }
            else
            if (dwType == REG_SZ) {
                fEnableExtensions = (BOOLEAN)(_wtol((PWSTR)lpData) == 1);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("DelayedExpansion"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                fDelayedExpansion = (BOOLEAN)(*(PULONG)lpData != 0);
                }
            else
            if (dwType == REG_SZ) {
                fDelayedExpansion = (BOOLEAN)(_wtol((PWSTR)lpData) == 1);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("DefaultColor"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                wDefaultColor = (WORD) *(PULONG)lpData;
                }
            else
            if (dwType == REG_SZ) {
                wDefaultColor = (WORD)_tcstol((PTCHAR)lpData, NULL, 0);
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("CompletionChar"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                chCompletionCtrl = (TCHAR)*(PULONG)lpData;
                }
            else
            if (dwType == REG_SZ) {
                chCompletionCtrl = (TCHAR)_tcstol((PTCHAR)lpData, NULL, 0);
            }

            if (chCompletionCtrl == 0 || chCompletionCtrl == 0x0d || chCompletionCtrl > SPACE) {
                chCompletionCtrl = SPACE;
            }
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("PathCompletionChar"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            if (dwType == REG_DWORD) {
                chPathCompletionCtrl = (TCHAR)*(PULONG)lpData;
                }
            else
            if (dwType == REG_SZ) {
                chPathCompletionCtrl = (TCHAR)_tcstol((PTCHAR)lpData, NULL, 0);
            }

            if (chPathCompletionCtrl == 0 || chPathCompletionCtrl == 0x0d || chPathCompletionCtrl > SPACE) {
                chPathCompletionCtrl = SPACE;
            }
        }

        if (chCompletionCtrl == SPACE && chPathCompletionCtrl < SPACE) {
            chCompletionCtrl = chPathCompletionCtrl;
        } else
        if (chPathCompletionCtrl == SPACE && chCompletionCtrl < SPACE) {
            chPathCompletionCtrl = chCompletionCtrl;
        }

        cbData = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKey, TEXT("AutoRun"), NULL, &dwType, lpData, &cbData);
        if (!rc) {
            s = (TCHAR *)lpData;
            if (dwType == REG_EXPAND_SZ) {
                cchSrc = cbData / sizeof( TCHAR );
                cchDst = (sizeof( ValueBuffer ) - cbData) / sizeof( TCHAR );
                if (ExpandEnvironmentStrings( s,
                                              &s[ cchSrc+2 ],
                                              cchDst
                                            )
                   )
                    _tcscpy( s, &s[ cchSrc+2 ] );
                else
                    *s = NULLC;
                }

            if (*s)
                InitialCmds[i] = mystrcpy( mkstr( (_tcslen(s)+1) * sizeof( TCHAR ) ), s );
        }

        RegCloseKey(hKey);
    }

    //
    // Initialize for %RANDOM%
    //
    srand( (unsigned)time( NULL ) );

    return;
}

/***    CheckSwitches - process Command's switches
 *
 *  Purpose:
 *      Check to see if Command was passed any switches and take appropriate
 *      action.  The switches are:
 *              /P - Permanent Command.  Set permanent CMD flag.
 *              /C - Single command.  Build a command line out of the rest of
 *                   the args and pass it back to Init.
 *      @@      /K - Same as /C but also set BatCom flag.
 *              /Q - No echo
 *              /A - Output in ANSI
 *              /U - Output in UNICODE
 *
 *      All other switches are ignored.
 *
 *  TCHAR *CheckSwitches(TCHAR *nptr)
 *
 *  Args:
 *      nptr = Ptr to cmdline to check for switches
 *
 *  Returns:
 *      Comline (it's NULL if NOT in single command mode).
 *
 *  Notes:
 *      M034 - This function revised to use the raw cmdline
 *      from the passed environment.
 *
 */

void
CheckSwitches(
    TCHAR *InitialCmds[],
    TCHAR *nptr
    )
{
    TCHAR a,                         /* Holds switch value              */
         *comline = NULL ,           /* Ptr to command line if /c found */
          store,
         *ptr,                       /* A temporary pointers */
         *ptr_b,
         *ptr_e;

    BOOL    FoundSpace;
    BOOLEAN  fAutoGen = FALSE;       // On if "/S" in cmdline meaning cmdline was parsed by CMD.EXE previously
    BOOLEAN fOrigEnableExt;
    struct  cmdnode cmd_node;        // need for SearchForExecutable()
    TCHAR   cmdline [MAX_PATH];
    TCHAR   argptr  [MAX_PATH];

    PTCHAR  CmdBuf;
    int     retc;

    CmdBuf = mkstr( (MAXTOKLEN + 3) * sizeof( TCHAR ));
    if (CmdBuf == NULL) {
        CMDexit( 1 );
    }

    
    memset( &cmd_node, 0, sizeof( cmd_node ));
    
    fOrigEnableExt = fEnableExtensions;
    DEBUG((INGRP, ACLVL, "CHKSW: entered.")) ;

    while (nptr = mystrchr(nptr, SwitChar)) {
        a = (TCHAR) _totlower(nptr[1]) ;

        if (a == NULLC)
            break;

        if (a == QMARK) {

            BeginHelpPause();
            do {
                if (CtrlCSeen) break; PutStdOut(MSG_HELP_CMD, NOARGS);
                if (CtrlCSeen) break; PutStdOut(MSG_HELP_CMD1, NOARGS);

                if (!fOrigEnableExt && !fEnableExtensions) break;

                if (CtrlCSeen) break; PutStdOut(MSG_HELP_CMD_EXTENSIONS, NOARGS);
                if (CtrlCSeen) break; PutStdOut(MSG_HELP_CMD_EXTENSIONS1, NOARGS);
                if (CtrlCSeen) break; PutStdOut(MSG_HELP_CMD_COMPLETION1, NOARGS);
                if (CtrlCSeen) break; PutStdOut(MSG_HELP_CMD_COMPLETION2, NOARGS);

            } while ( FALSE );

            EndHelpPause();

            CMDexit(1);
        } else if (a == QCSwitch)  {   /* Quiet cmd switch        */

            Necho = TRUE ;
            mystrcpy(nptr, nptr+2) ;

        } else if ((a == SCSwitch) || (a == BCSwitch) || a == TEXT('r')) {
            DEBUG((INGRP, ACLVL, "CHKSW: Single command switch")) ;

            if ( a == BCSwitch ) {
                SingleBatchInvocation = TRUE;        // /K specified
            } else {
                SingleCommandInvocation = TRUE;          // /C or /R specified
            }

            if (!(comline = mkstr(mystrlen(nptr+2)*sizeof(TCHAR)+2*sizeof(TCHAR)))) {
                CMDexit(1) ;
            } ;

            mystrcpy(comline, nptr+2) ;       /* Make comline    */

            *nptr = NULLC ;         /* Invalidate this arg     */

            comline = SkipWhiteSpace( comline );

//---------------------------------------------------------------------------------------------------------
// CMD.EXE uses quotes by two reasons:
// 1. to embed command symbols "&", "<", ">", "|", "&&", "||" into command arguments, e.g.
//    cmd /c " dir | more "
// 2. to embed spaces into filename, e.g.
//    cmd /c " my batfile with spaces.cmd"
// Note that the caret "^" has no effect when used in between quotes in the current implementation (941221).
// Also, CMD.EXE binds the quote with the next one.
//
// I see a problem here: the commands like
//    cmd /c "findstr " | " | find "smth" "        OR
//    cmd /c "ls | " my filterbat with spaces.cmd" | more"
// WON'T WORK unless we all decide to change CMD's syntax to better handle quotes!
//
// There is more to it: when CMD.EXE parses pipes,CMD creates process with the command argument like this:
//    <full path of CMD.EXE> /S /C"  <cmdname>  "
// so we've got spaces inside the quotes.
//
// I hope I am not missing anything else...
//
// With given design restrictions, I will at least solve simple but most wide-spread problem:
// using filenames with spaces by trying this:
//      IF  ( (there is no /S switch ) AND                      // it is not the result of prev. parsing
//            (there are exactly 2 quotes) AND                  // the existing design problem with multiple quotes
//            (there is no special chars between quotes) AND    // don't break command symbols parsing
//            (there is a whitespace between quotes) AND        // otherwise it is not filename with spaces
//            (the token between quotes is a valid executable) )// otherwise we can't help anyway
//      THEN
//            Preserve quotes   // Assume it is a filename with spaces
//      ELSE
//            Exec. old logic   // Strip first and last quotes
//
// Ugly, but what options do I have? Only to patch existing logic or change syntax.
//-----------------------------------------------------------------------------------------------------------

            if (fAutoGen)                                  // seen /S switch
                goto old_way;


            if (*comline == QUOTE) {
                ptr_b = comline + 1;
                ptr_e = mystrchr (ptr_b, QUOTE);
                if (ptr_e)  {                              // at least 2 quotes
                    ptr_b = ptr_e + 1;
                    ptr_e = mystrchr (ptr_b, QUOTE);
                    if (ptr_e)  {                          // more than 2 quotes
                        goto old_way;
                    }
                }
                else {                                     // only 1 quote
                    goto old_way;
                }
                                                           // exactly 2 quotes
                store = *ptr_b;
                *ptr_b = NULLC;

                if ( (mystrchr (comline, ANDOP) ) ||
                     (mystrchr (comline, INOP)  ) ||
                     (mystrchr (comline, OUTOP) ) ||
                     (mystrchr (comline, LPOP)  ) ||
                     (mystrchr (comline, RPOP)  ) ||
                     (mystrchr (comline, SILOP) ) ||
                     (mystrchr (comline, ESCHAR)) ||
                     (mystrchr (comline, PIPOP) ) )  {

                    *ptr_b = store;                        // special chars between quotes
                    goto old_way;
                }


                FoundSpace = FALSE;
                
                {
                    PTCHAR p = comline;

                    while (*p) {
                        if (_istspace( *p )) {
                            FoundSpace = TRUE;
                            break;
                        }
                        p++;
                    }

                    if ( !FoundSpace ) {
                        *ptr_b = store;
                        goto old_way;
                    }
                }
                    

                // the last check is for valid executable

                cmd_node.type = CMDTYP ;
                cmd_node.cmdline = cmdline;
                cmd_node.argptr = argptr;
                cmd_node.rio = NULL;

                mystrcpy (cmdline, comline);                // get token between quotes
                mystrcpy (argptr, TEXT (" ") );

                *ptr_b = store;                             // restore comline

                retc = SearchForExecutable (&cmd_node, CmdBuf);
                if (retc == SFE_NOTFND)
                    goto old_way;

                if (retc ==  SFE_FAIL) {
                    PutStdErr( DosErr, NOARGS );
                    CMDexit( DosErr );
                }

                goto new_way;                               // assume filename and DO NOT strip quotes.
            }

old_way:
            if (*comline == QUOTE) {
                ++comline ;
                ptr = mystrrchr(comline, QUOTE);
                if ( ptr ) {
                    *ptr = NULLC;
                    ++ptr;
                    mystrcat(comline,ptr);
                }
            }
new_way:

            *(comline+mystrlen(comline)) = NLN ;

            DEBUG((INGRP, ACLVL, "CHKSW: Single command line = `%ws'", comline)) ;
            InitialCmds[2] = comline;
            break ;         /* Once /K or /C found, no more args exist */

        } else if (a == UCSwitch) {     /* Unicode output switch    */
#ifdef UNICODE
            fOutputUnicode = TRUE;
            mystrcpy(nptr, nptr+2) ;
#else
            PutStdErr(MSG_UNICODE_NOT_SUPPORTED, NOARGS);
#endif // UNICODE
        } else if (a == ACSwitch) {     /* Ansi output switch    */
#ifdef UNICODE
            fOutputUnicode = FALSE;
#endif // UNICODE
                mystrcpy(nptr, nptr+2) ;
        //
        // Old style of enabling extensions with /X
        //
        } else if (a == XCSwitch) {     /* Enable extensions switch */
                fEnableExtensions = TRUE;
                mystrcpy(nptr, nptr+2) ;

        //
        // Old style of disabling extensions with /Y
        //
        } else if (a == YCSwitch) {     /* Disable extensions switch */
                fEnableExtensions = FALSE;
                mystrcpy(nptr, nptr+2) ;

        //
        // Enable/Disable command extensions. /E or /E:ON to enable
        // and /E:OFF to disable.
        //
        } else if (a == TEXT('e')) {
                mystrcpy(nptr, nptr+2) ;
                if (*nptr == COLON && !_tcsnicmp(nptr+1, TEXT("OFF"), 3)) {
                    fEnableExtensions = FALSE;
                    mystrcpy(nptr, nptr+4) ;
                } else {
                    fEnableExtensions = TRUE;
                    if (!_tcsnicmp(nptr, TEXT(":ON"), 3)) {
                        mystrcpy(nptr, nptr+3) ;
                    }
                }

        //
        // Disable AutoRun from Registry if /D specified.
        //
        } else if (a == TEXT('d')) {
                mystrcpy(nptr, nptr+2) ;
                InitialCmds[0] = NULL;
                InitialCmds[1] = NULL;

        //
        // Enable/Disable file and directory name completion. /F or /F:ON to
        // enable and /F:OFF to disable.
        //
        } else if (a == TEXT('f')) {
                mystrcpy(nptr, nptr+2) ;
                if (*nptr == COLON && !_tcsnicmp(nptr+1, TEXT("OFF"), 3)) {
                    chCompletionCtrl = SPACE;
                    chPathCompletionCtrl = SPACE;
                    mystrcpy(nptr, nptr+4) ;
                } else {
                    chCompletionCtrl = 0x6;         // Ctrl-F
                    chPathCompletionCtrl = 0x4;     // Ctrl-D
                    if (!_tcsnicmp(nptr, TEXT(":ON"), 3)) {
                        mystrcpy(nptr, nptr+3) ;
                    }
                }

        //
        // Enable/Disable delayed variable expansion inside FOR loops.  /V or /V:ON to
        // enable and /V:OFF to disable.
        //
        } else if (a == TEXT('v')) {
                mystrcpy(nptr, nptr+2) ;
                if (*nptr == COLON && !_tcsnicmp(nptr+1, TEXT("OFF"), 3)) {
                    fDelayedExpansion = FALSE;
                    mystrcpy(nptr, nptr+4) ;
                } else {
                    fDelayedExpansion = TRUE;
                    if (!_tcsnicmp(nptr, TEXT(":ON"), 3)) {
                        mystrcpy(nptr, nptr+3) ;
                    }
                }

        //
        // Set the foreground/background screen coler
        // enable and /F:OFF to disable.
        //
        } else if (fEnableExtensions && a == TEXT('t')) {   /* Define start color */
            if (*(nptr+2) == __TEXT(':') && _istxdigit(*(nptr+3)) &&
                _istxdigit(*(nptr+4)) && !_istxdigit(*(nptr+5))) {
                wDefaultColor = (WORD) (_istdigit(*(nptr+3)) ? (WORD)*(nptr+3) - (WORD)TEXT('0')
                                                             : (WORD)_totlower(*(nptr+3)) - (WORD)TEXT('W')) ;
                wDefaultColor <<= 4;
                wDefaultColor |= (WORD) (_istdigit(*(nptr+4)) ? (WORD)*(nptr+4) - (WORD)TEXT('0')
                                                              : (WORD)_totlower(*(nptr+4)) - (WORD)TEXT('W')) ;
                mystrcpy(nptr+2, nptr+5 );
            }
            mystrcpy(nptr, nptr+2) ;

        } else if (a == TEXT('s') )  {  /* CMD inserts when parsing pipes */
            fAutoGen = TRUE ;
            mystrcpy(nptr, nptr+2) ;
        } else {
            mystrcpy(nptr, nptr+2) ;  /* Remove any other switches */
        } ;
    } ;

    FreeStr( CmdBuf );
    return;
}


/***    SetUpEnvironment - initialize Command's environment
 *
 *  Purpose:
 *      Initialize the PATH and COMSPEC variables as necessary.
 *
 *  SetUpEnvironment()
 *
 */

extern TCHAR KeysStr[];  /* @@5 */
extern int KeysFlag;    /* @@5 */

void SetUpEnvironment(void)
{
    TCHAR *cds ;            // Command directory string
    TCHAR *nptr ;                    // Temp cmd name ptr

    if (!(cds = mkstr(MAX_PATH*sizeof(TCHAR)))) {
        PutStdErr(ERROR_NOT_ENOUGH_MEMORY, NOARGS);
        CMDexit(1) ;
    }
    GetModuleFileName( NULL, cds, MAX_PATH );

    //
    // If the PATH variable is not set, it must be added as a NULL.  This is
    // so that DOS apps inherit the current directory path.
    //
    if (!GetEnvVar(PathStr)) {

        SetEnvVar(PathStr, TEXT("") );
    }

    //
    // If the PATHEXT variable is not set, and extensions are enabled, set it to
    // the default list of extensions that will be searched.
    //
    if (!GetEnvVar(PathExtStr)) {

        SetEnvVar(PathExtStr, PathExtDefaultStr );

    }

    //
    // If the PROMPT variable is not set, it must be added as $P$G.  This is
    // special cased, since we do not allow users to add NULLs.
    //
    if (!GetEnvVar(PromptStr)) {

        SetEnvVar(PromptStr, TEXT("$P$G") );
    }

    if (!GetEnvVar(ComSpecStr)) {

        DEBUG((INGRP, EILVL, "SETENV: No COMSPEC var")) ;

        if(!mystrchr(cds,DOT)) {          /* If no fname, use default */
            _tcsupr(CmdSpec);
            if((cds+mystrlen(cds)-1) != mystrrchr(cds,PathChar)) {
                mystrcat(cds,ComSpec) ;
            } else {
                mystrcat(cds,&ComSpec[1]) ;
            }
        }

        SetEnvVar(ComSpecStr, cds ) ;
    }

    if ( (nptr = GetEnvVar(KeysStr)) && (!_tcsicmp(nptr, TEXT("ON"))) ) {
        KeysFlag = 1;
    }

    ChangeDir(CurDrvDir);
}


VOID
ResetCtrlC() {

    EnterCriticalSection(lpcritCtrlC);
    CtrlCSeen = FALSE;
    LeaveCriticalSection(lpcritCtrlC);

}

VOID
SetCtrlC() {

    EnterCriticalSection(lpcritCtrlC);
    CtrlCSeen = TRUE;
    LeaveCriticalSection(lpcritCtrlC);

}


void
CMDexit(int rc)
{
    while (ePopDir(NULL) == SUCCESS)
        ;

    exit(rc);
}

//
//  Get the current OS version and put it into the common version format
//

VOID 
GetVersionString(
    IN OUT PTCHAR VersionString,
    IN ULONG Length
    )
{
    ULONG vrs = GetVersion();

    //
    //  Version format is [Major.Minor(2).Build(4)]
    //
    
    _sntprintf( VersionString, Length, 
                TEXT( "%d.%d.%04d" ),
                vrs & 0xFF,
                (vrs >> 8) & 0xFF,
                (vrs >> 16) & 0x3FFF
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\ckeys.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    ckeys.c

Abstract:

    Dummy support for DOS KEYS command

--*/

#include "cmd.h"

extern TCHAR KeysStr[];

/* global variables */
int KeysFlag = 0;	   /* KeysFlag indicates on / off */

/**************** START OF SPECIFICATIONS ***********************/
/*								*/
/* SUBROUTINE NAME: eKeys					*/
/*								*/
/* DESCRIPTIVE NAME: Keys internal command			*/
/*								*/
/* FUNCTION: If no argument supplied then display the state	*/
/*	     of on / off.  If argument is on / off then 	*/
/*	     change the state.	If argument is list then	*/
/*	     display the stack. 				*/
/*								*/
/* NOTES: New for OS/2 1.2.					*/
/*								*/
/* ENTRY POINT: eKeys						*/
/*    LINKAGE:							*/
/*								*/
/* INPUT:							*/
/*	n							*/
/*								*/
/* EXIT-NORMAL: 						*/
/*	returns SUCCESS 					*/
/*								*/
/* EXIT-ERROR:							*/
/*	none.							*/
/*								*/
/* EFFECTS:							*/
/*								*/
/* INTERNAL REFERENCES: 					*/
/*    ROUTINES: 						*/
/*	PutStdErr						*/
/*	PutStdOut						*/
/*	TokStr							*/
/*	strcmpi 						*/
/*	strncpy 						*/
/*								*/
/* EXTERNAL REFERENCES: 					*/
/*    ROUTINES: 						*/
/**************** END OF SPECIFICATIONS *************************/

eKeys( n )
struct cmdnode *n; /* the command node for the Keys command */
{
    TCHAR *argptr;		 /* pointer to tozenized argument */

    /* get the value of the argument pointer */
    argptr = TokStr( n->argptr, 0, TS_NOFLAGS );

    /* take action based on the argument */

    if ((*argptr == 0) && (KeysFlag)) {
        PutStdOut( MSG_KEYS_ON, NOARGS );
        }

    else if ((*argptr == 0) && (!KeysFlag)) {
        PutStdOut( MSG_KEYS_OFF, NOARGS );
        }

    else if (!(argptr[ mystrlen( argptr ) + 1 ] == 0)) {
        /* too many parameters */
        PutStdErr( MSG_BAD_SYNTAX, NOARGS );
        }

    else if (_tcsicmp( argptr, TEXT("ON") ) == 0) {
        /* set keys on */
        KeysFlag = TRUE;
        SetEnvVar(KeysStr, TEXT("ON") );
        }
    else if (_tcsicmp( argptr, TEXT("OFF") ) == 0) {
        /* set keys off */
        KeysFlag = FALSE;
        SetEnvVar(KeysStr, TEXT("OFF") );
        }

    else if (_tcsicmp( argptr, TEXT("LIST") ) == 0) {
        }

    else {
        /* invalid parameter */
        PutStdErr( MSG_BAD_PARM1, NOARGS );
        }

    return SUCCESS;

} /* eKeys */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\cext.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    cext.c

Abstract:

    External command support

--*/

#include "cmd.h"

#define DBENV   0x0080
#define DBENVSCAN       0x0010

unsigned start_type ;                                          /* D64 */

extern UINT CurrentCP;
extern TCHAR Fmt16[] ; /* @@5h */

extern unsigned DosErr ;
extern BOOL CtrlCSeen;

extern TCHAR CurDrvDir[] ;

extern TCHAR CmdExt[], BatExt[], PathStr[] ;
extern TCHAR PathExtStr[], PathExtDefaultStr[];
extern TCHAR ComSpec[] ;        /* M033 - Use ComSpec for SM memory        */
extern TCHAR ComSpecStr[] ;     /* M033 - Use ComSpec for SM memory        */
extern void tokshrink(TCHAR*);

extern TCHAR PathChar ;
extern TCHAR SwitChar ;

extern PTCHAR    pszTitleCur;
extern BOOLEAN  fTitleChanged;

extern int LastRetCode ;
extern HANDLE PipePid ;       /* M024 - Store PID from piped cmd   */

extern struct envdata CmdEnv ;    // Holds info to manipulate Cmd's environment

extern int  glBatType;     // to distinguish OS/2 vs DOS errorlevel behavior depending on a script file name

TCHAR  szNameEqExitCodeEnvVar[]       = TEXT ("=ExitCode");
TCHAR  szNameEqExitCodeAsciiEnvVar[]  = TEXT ("=ExitCodeAscii");
TCHAR  ShellOpenCommandString[] = TEXT( "\\Shell\\Open\\Command" );


WORD
GetProcessSubsystemType(
    HANDLE hProcess
    );


/***    ExtCom - controls the execution of external programs
 *
 *  Purpose:
 *      Synchronously execute an external command.  Call ECWork with the
 *      appropriate values to have this done.
 *
 *  ExtCom(struct cmdnode *n)
 *
 *  Args:
 *      Parse tree node containing the command to be executed.
 *
 *  Returns:
 *      Whatever ECWork returns.
 *
 *  Notes:
 *      During batch processing, labels are ignored.  Empty commands are
 *      also ignored.
 *
 */

int ExtCom(n)
struct cmdnode *n ;
{
        if (CurrentBatchFile && *n->cmdline == COLON)
                return(SUCCESS) ;

        if (n && n->cmdline && mystrlen(n->cmdline)) {
                return(ECWork(n, AI_SYNC, CW_W_YES)) ;          /* M024    */
        } ;

        return(SUCCESS) ;
}





/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: ECWork                                             */
/*                                                                     */
/* DESCRIPTIVE NAME: Execute External Commands Worker                  */
/*                                                                     */
/* FUNCTION: Execute External Commands                                 */
/*           This routine calls SearchForExecutable routine to search  */
/*           for the executable command.  If the command ( .EXE, .COM, */
/*           or .CMD file ) is found, the command is executed.         */
/*                                                                     */
/* ENTRY POINT: ECWork                                                 */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT: n - the parse tree node containing the command to be executed*/
/*                                                                     */
/*        ai - the asynchronous indicator                              */
/*           - 0 = Exec synchronous with parent                        */
/*           - 1 = Exec asynchronous and discard child return code     */
/*           - 2 = Exec asynchronous and save child return code        */
/*                                                                     */
/*        wf - the wait flag                                           */
/*           - 0 = Wait for process completion                         */
/*           - 1 = Return immediately (Pipes)                          */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         If synchronous execution, the return code of the command is */
/*         returned.                                                   */
/*                                                                     */
/*         If asynchronous execution, the return code of the exec call */
/*         is returned.                                                */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/
/***    ECWork - begins the execution of external commands
 *
 *  Purpose:
 *      To search for and execute an external command.  Update LastRetCode
 *      if an external program was executed.
 *
 *  int ECWork(struct cmdnode *n, unsigned ai, unsigned wf)
 *
 *  Args:
 *      n - the parse tree node containing the command to be executed
 *      ai - the asynchronous indicator
 *         - 0 = Exec synchronous with parent
 *         - 1 = Exec asynchronous and discard child return code
 *         - 2 = Exec asynchronous and save child return code
 *      wf - the wait flag
 *         - 0 = Wait for process completion
 *         - 1 = Return immediately (Pipes)
 *
 *  Returns:
 *      If syncronous execution, the return code of the command is returned.
 *      If asyncronous execution, the return code of the exec call is returned.
 *
 *  Notes:
 *      The pid of a program that will be waited on is placed in the global
 *      variable Retcds.ptcod so that WaitProc can use it and so SigHand()
 *      can kill it if necessary (only during SYNC exec's).
 *      M024 - Added wait flag parm so pipes can get immediate return while
 *             still doing an AI_KEEP async exec.
 *           - Considerable revisions to structure.
 */

int ECWork(n, ai, wf)
struct cmdnode *n ;
unsigned ai ;
unsigned wf ;
{
        TCHAR *fnptr,                           /* Ptr to filename         */
             *argptr,                           /* Command Line String     */
             *tptr;                             /* M034 - Temps            */
        int i ;                                 /* Work variable           */
        TCHAR *  onb ;                           /* M035 - Obj name buffer  */
        ULONG   rc;


        if (!(fnptr = mkstr(MAX_PATH*sizeof(TCHAR)+sizeof(TCHAR))))    /* Loc/nam of file to exec */
            return(FAILURE) ;

        argptr = GetTitle( n );
        tptr = argptr;
        if (argptr == NULL) {

            return( FAILURE );

        }

        i = SearchForExecutable(n, fnptr) ;
        if (i == SFE_ISEXECOM) {                /* Found .com or .exe file */

                if (!(onb = (TCHAR *)mkstr(MAX_PATH*sizeof(TCHAR)+sizeof(TCHAR))))  /* M035    */
                   {
                        return(FAILURE) ;

                   }

            SetConTitle( tptr );
            rc = ExecPgm( n, onb, ai, wf, argptr, fnptr, tptr);
            ResetConTitle( pszTitleCur );

            return( rc  );

        } ;

        if (i == SFE_ISBAT) {            /* Found .cmd file, call BatProc  */

                SetConTitle(tptr);
                rc = BatProc(n, fnptr, BT_CHN) ;
                ResetConTitle( pszTitleCur );
                return(rc) ;
        } ;

        if (i == SFE_ISDIR) {
                return ChangeDir2(fnptr, TRUE);
        }

        LastRetCode = DosErr;
        if (i == SFE_FAIL) {            /* Out of Memory Error             */
                return(FAILURE) ;
        } ;

        if (DosErr == MSG_DIR_BAD_COMMAND_OR_FILE) {
            PutStdErr(DosErr, ONEARG, n->cmdline);
            }
        else {
            PutStdErr(DosErr, NOARGS);
            }
        return(FAILURE) ;
}


#ifndef WIN95_CMD
VOID
RestoreCurrentDirectories( VOID )

/* this routine sets the current process's current directories to
   those of the child if the child was the VDM to fix DOS batch files.
*/

{
    ULONG cchCurDirs;
    UINT PreviousErrorMode;
    PTCHAR pCurDirs,pCurCurDir;
    BOOL CurDrive=TRUE;
#ifdef UNICODE
    PCHAR pT;
#endif

    cchCurDirs = GetVDMCurrentDirectories( 0,
                                           NULL
                                         );
    if (cchCurDirs == 0)
        return;

    pCurDirs = gmkstr(cchCurDirs*sizeof(TCHAR));
#ifdef UNICODE
    pT = gmkstr(cchCurDirs);
#endif

    GetVDMCurrentDirectories( cchCurDirs,
#ifdef UNICODE
                               pT
#else
                               pCurDirs
#endif
                            );
#ifdef UNICODE
    MultiByteToWideChar(CurrentCP, MB_PRECOMPOSED, pT, -1, pCurDirs, cchCurDirs);
#endif

    // set error mode so we don't get popup if trying to set curdir
    // on empty floppy drive

    PreviousErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    for (pCurCurDir=pCurDirs;*pCurCurDir!=NULLC;pCurCurDir+=(_tcslen(pCurCurDir)+1)) {
        ChangeDir2(pCurCurDir,CurDrive);
        CurDrive=FALSE;
    }
    SetErrorMode(PreviousErrorMode);
    //free(pCurDirs);
#ifdef UNICODE
    FreeStr((PTCHAR)pT);
#endif
}
#endif // WIN95_CMD


/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: ExecPgm                                            */
/*                                                                     */
/* DESCRIPTIVE NAME: Call DosExecPgm to execute External Command       */
/*                                                                     */
/* FUNCTION: Execute External Commands with DosExecPgm                 */
/*           This routine calls DosExecPgm to execute the command.     */
/*                                                                     */
/*                                                                     */
/* NOTES: This is a new routine added for OS/2 1.1 release.            */
/*                                                                     */
/*                                                                     */
/* ENTRY POINT: ExecPgm                                                */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT: n - the parse tree node containing the command to be executed*/
/*                                                                     */
/*        ai - the asynchronous indicator                              */
/*           - 0 = Exec synchronous with parent                        */
/*           - 1 = Exec asynchronous and discard child return code     */
/*           - 2 = Exec asynchronous and save child return code        */
/*                                                                     */
/*        wf - the wait flag                                           */
/*           - 0 = Wait for process completion                         */
/*           - 1 = Return immediately (Pipes)                          */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         If synchronous execution, the return code of the command is */
/*         returned.                                                   */
/*                                                                     */
/*         If asynchronous execution, the return code of the exec call */
/*         is returned.                                                */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE to the caller.                               */
/*                                                                     */
/* EFFECTS:                                                            */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       ExecError - Handles execution error                           */
/*       PutStdErr - Print an error message                            */
/*       WaitProc - wait for the termination of the specified process, */
/*                  its child process, and  related pipelined          */
/*                  processes.                                         */
/*                                                                     */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DOSEXECPGM      - Execute the specified program               */
/*       DOSSMSETTITLE   - Set title for the presentation manager      */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

int
ExecPgm(
    IN struct cmdnode *n,
    IN TCHAR *onb,
    IN unsigned int ai,
    IN unsigned int  wf,
    IN TCHAR * argptr,
    IN TCHAR * fnptr,
    IN TCHAR * tptr
    )
{
    int i ;                                 /* Work variable           */
    BOOL b;
    BOOL VdmProcess = FALSE;
    BOOL WowProcess = FALSE;
    LPTSTR CopyCmdValue;
    HANDLE hChildProcess;

    HDESK   hdesk;
    LPTSTR  lpDesktop;
    DWORD   cbDesktop = 0;
    HWINSTA hwinsta;
    DWORD   cbWinsta = 0;

    TCHAR   szValEqExitCodeEnvVar [20];
    TCHAR   szValEqExitCodeAsciiEnvVar [12];


    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ChildProcessInfo;

    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    StartupInfo.lpTitle = tptr;
    StartupInfo.dwX = 0;
    StartupInfo.dwY = 1;
    StartupInfo.dwXSize = 100;
    StartupInfo.dwYSize = 100;
    StartupInfo.dwFlags = 0;//STARTF_SHELLOVERRIDE;
    StartupInfo.wShowWindow = SW_SHOWNORMAL;

    // Pass current Desktop to a new process.

    hwinsta = GetProcessWindowStation();
    GetUserObjectInformation( hwinsta, UOI_NAME, NULL, 0, &cbWinsta );

    hdesk = GetThreadDesktop ( GetCurrentThreadId() );
    GetUserObjectInformation (hdesk, UOI_NAME, NULL, 0, &cbDesktop);

    if ((lpDesktop = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cbDesktop + cbWinsta + 32) ) != NULL ) {
        LPTSTR  p = lpDesktop;
        if ( GetUserObjectInformation (hwinsta, UOI_NAME, p, cbWinsta, &cbWinsta) ) {
            if (cbWinsta > 0) {
                p += ((cbWinsta/sizeof(TCHAR))-1);
                *p++ = L'\\';
            }
            if ( GetUserObjectInformation (hdesk, UOI_NAME, p, cbDesktop, &cbDesktop) ) {
                StartupInfo.lpDesktop = lpDesktop;
            }
        }
    }

    //
    //  Incredibly ugly hack for Win95 compatibility.
    //
    //  XCOPY in Win95 reaches up into it's parent process to see if it was
    //  invoked in a batch file.  If so, then XCOPY pretends COPYCMD=/Y
    //
    //  There is no way we can do this for NT.  The best that can be done is
    //  to detect if we're in a batch file starting XCOPY and then temporarily
    //  change COPYCMD=/Y.
    //

    {
        const TCHAR *p = MyGetEnvVarPtr( TEXT( "COPYCMD" ));

        if (p == NULL) {
            p = TEXT( "" );
        }

        CopyCmdValue = malloc( (mystrlen( p ) + 1) * sizeof( TCHAR ));
        if (CopyCmdValue == NULL) {
            PutStdErr( MSG_NO_MEMORY, NOARGS );
            return FAILURE;
        }
        mystrcpy( CopyCmdValue, p );

        if ((SingleBatchInvocation
             || SingleCommandInvocation
             || CurrentBatchFile )
            && (p = mystrrchr( fnptr, TEXT( '\\' ))) != NULL
            && !lstrcmp( p, TEXT( "\\XCOPY.EXE" ))
           ) {

            SetEnvVar( TEXT( "COPYCMD" ), TEXT( "/Y" ) );

        }
    }

    //
    // If the restricted token exists then create the process with the 
    // restricted token. 
    // Else create the process without any restrictions.
    //

    if ((CurrentBatchFile != NULL) && (CurrentBatchFile->hRestrictedToken != NULL)) {

        b = CreateProcessAsUser( CurrentBatchFile->hRestrictedToken,
                                 fnptr,
                                 argptr,
                                 (LPSECURITY_ATTRIBUTES) NULL,
                                 (LPSECURITY_ATTRIBUTES) NULL,
                                 TRUE,
                                 0,
                                 NULL,
                                 CurDrvDir,
                                 &StartupInfo,
                                 &ChildProcessInfo
                                 );


    } else {
        b = CreateProcess( fnptr,
                           argptr,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           (LPSECURITY_ATTRIBUTES) NULL,
                           TRUE,
                           0,
                           NULL,
                           CurDrvDir,
                           &StartupInfo,
                           &ChildProcessInfo
                         );
    }

    if (!b) {
        DosErr = i = GetLastError();
    } else {
        hChildProcess = ChildProcessInfo.hProcess;
        CloseHandle(ChildProcessInfo.hThread);
    }

    //
    //  Undo ugly hack
    //

    SetEnvVar( TEXT( "COPYCMD" ), CopyCmdValue );
    free( CopyCmdValue );

    HeapFree (GetProcessHeap(), 0, lpDesktop);
    if (!b) {

        if (fEnableExtensions && DosErr == ERROR_BAD_EXE_FORMAT) {
            SHELLEXECUTEINFO sei;

            memset(&sei, 0, sizeof(sei));

            //
            // Use the DDEWAIT flag so apps can finish their DDE conversation
            // before ShellExecuteEx returns.  Otherwise, apps like Word will
            // complain when they try to exit, confusing the user.
            //

            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_HASTITLE |
                        SEE_MASK_NO_CONSOLE |
                        SEE_MASK_FLAG_DDEWAIT |
                        SEE_MASK_NOCLOSEPROCESS;
            sei.lpFile = fnptr;
            sei.lpParameters = n->argptr;
            sei.lpDirectory = CurDrvDir;
            sei.nShow = StartupInfo.wShowWindow;

            try {
                b = ShellExecuteEx( &sei );

                if (b) {
                    hChildProcess = sei.hProcess;
                    leave;
                }

                if (sei.hInstApp == NULL) {
                    DosErr = ERROR_NOT_ENOUGH_MEMORY;
                } else if ((DWORD_PTR)sei.hInstApp == HINSTANCE_ERROR) {
                    DosErr = ERROR_FILE_NOT_FOUND;
                } else {
                    DosErr = HandleToUlong(sei.hInstApp);
                }

            } except( DosErr = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER ) {
                b = FALSE;
            }

        }

        if (!b) {
            mystrcpy( onb, fnptr );
            ExecError( onb ) ;

            return (FAILURE) ;
        }
    }

#ifndef WIN95_CMD
    VdmProcess = ((UINT_PTR)(hChildProcess) & 1) ? TRUE : FALSE;
    WowProcess = ((UINT_PTR)(hChildProcess) & 2) ? TRUE : FALSE;
#endif // WIN95_CMD
    if (hChildProcess == NULL
        || (fEnableExtensions 
            && CurrentBatchFile == 0 
            && !SingleBatchInvocation 
            && !SingleCommandInvocation 
            && ai == AI_SYNC 
            && (WowProcess 
                || GetProcessSubsystemType(hChildProcess) == IMAGE_SUBSYSTEM_WINDOWS_GUI
                )
            )
       ) {
        //
        // If extensions enabled and doing a synchronous exec of a GUI
        // application, then change it into an asynchronous exec, with the
        // return code discarded, ala Win 3.x and Win 95 COMMAND.COM
        //
        ai = AI_DSCD;
    }

    i = SUCCESS;
    start_type = EXECPGM;

    
    //
    //  Now that the process has been started, process the various
    //  termination conditions
    //
    
    if (ai == AI_SYNC) {
        //
        //  Synchronous exec: we wait for the child, establish status code
        //  environment variable, and update current directories if we're
        //  running a DOS app
        //

        LastRetCode = WaitProc( hChildProcess );
        hChildProcess = NULL;
        i = LastRetCode ;

        //
        //  Set up exit code environment variable both numeric and
        //  ascii displayable
        //

        _stprintf (szValEqExitCodeEnvVar, TEXT("%08X"), i);
        SetEnvVar(szNameEqExitCodeEnvVar, szValEqExitCodeEnvVar );

        if ( (i >= 0x20) &&  (i <= 0x7e) ) {
            _stprintf (szValEqExitCodeAsciiEnvVar, TEXT("%01C"), i);
            SetEnvVar(szNameEqExitCodeAsciiEnvVar, szValEqExitCodeAsciiEnvVar );
        } else
            SetEnvVar(szNameEqExitCodeAsciiEnvVar, TEXT("\0") );

        //
        //  Update current directories if the process was handled by NTVDM.  This
        //  is done since DOS .BAT scripts allow inheritance of current directory
        //  from child apps
        //

#ifndef WIN95_CMD
        if (VdmProcess) {
            RestoreCurrentDirectories();
        }
#endif // WIN95_CMD
    } else if (ai == AI_DSCD) {

        //
        //  Disconnected exec; we simply close the process handle and
        //  let it run to completion.
        //

        if (hChildProcess != NULL) {
            CloseHandle( hChildProcess );
            hChildProcess = NULL;
        }
    
    } else if (ai == AI_KEEP) {

        //
        //  Keep-the-handle-open exec: this is called only within the 
        //  piping process. We've started the process, now we set a global
        //  so that the piping code can pick it up.
        //

        PipePid = hChildProcess;
    } else {
#if !defined( WIN95_CMD ) && DBG
        DbgBreakPoint( );
#endif
    }


    return (i) ;             /* i == return from DOSEXECPGM     */
}

/********************* START OF SPECIFICATION **************************/
/*                                                                     */
/* SUBROUTINE NAME: SearchForExecutable                                */
/*                                                                     */
/* DESCRIPTIVE NAME:  Search for Executable File                       */
/*                                                                     */
/* FUNCTION: This routine searches the specified executable file.      */
/*           If the file extension is specified,                       */
/*           CMD.EXE searches for the file with the file extension     */
/*           to execute.  If the specified file with the extension     */
/*           is not found, CMD.EXE will display an error message to    */
/*           indicate that the file is not found.                      */
/*           If the file extension is not specified,                   */
/*           CMD.EXE searches for the file with the order of these     */
/*           file extensions, .COM, .EXE, .CMD, and .BAT.              */
/*           The file which is found first will be executed.           */
/*                                                                     */
/* NOTES:    1) If a path is given, only the specified directory is    */
/*              searched.                                              */
/*           2) If no path is given, the current directory of the      */
/*              drive specified is searched followed by the            */
/*              directories in the PATH environment variable.          */
/*           3) If no executable file is found, an error message is    */
/*              printed.                                               */
/*                                                                     */
/* ENTRY POINT: SearchForExecutable                                    */
/*    LINKAGE: NEAR                                                    */
/*                                                                     */
/* INPUT:                                                              */
/*    n - parse tree node containing the command to be searched for    */
/*    loc - the string in which the location of the command is to be   */
/*          placed                                                     */
/*                                                                     */
/* OUTPUT: None.                                                       */
/*                                                                     */
/* EXIT-NORMAL:                                                        */
/*         Returns:                                                    */
/*             SFE_EXECOM, if a .EXE or .COM file is found.            */
/*             SFE_ISBAT, if a .CMD file is found.                     */
/*             SFE_ISDIR, if a directory is found.                     */
/*             SFE_NOTFND, if no executable file is found.             */
/*                                                                     */
/* EXIT-ERROR:                                                         */
/*         Return FAILURE or                                           */
/*             SFE_FAIL, if out of memory.                             */
/*                                                                     */
/* EFFECTS: None.                                                      */
/*                                                                     */
/* INTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       DoFind    - Find the specified file.                          */
/*       GetEnvVar - Get full path.                                    */
/*       FullPath  - build a full path name.                           */
/*       TokStr    - tokenize argument strings.                        */
/*       mkstr     -  allocate space for a string.                     */
/*                                                                     */
/* EXTERNAL REFERENCES:                                                */
/*      ROUTINES:                                                      */
/*       None                                                          */
/*                                                                     */
/********************** END  OF SPECIFICATION **************************/

SearchForExecutable(n, loc)
struct cmdnode *n ;
TCHAR *loc ;
{
    TCHAR *tokpath ;
    TCHAR *extPath ;
    TCHAR *extPathWrk ;
    TCHAR *fname;
    TCHAR *p1;
    TCHAR *tmps01;
    TCHAR *tmps02 = NULL;
    TCHAR pcstr[3];
    LONG BinaryType;

    size_t cName;   // number of characters in file name.

    int tplen;              // Length of the current tokpath token
    int dotloc;             // loc offset where extension is appended
    int pcloc;              // M014 - Flag. True=user had partial path
    int addpchar;   // True - append PathChar to string   @@5g
    TCHAR *j ;

    TCHAR wrkcmdline[MAX_PATH] ;
    unsigned tokpathlen;
    BOOL DoDot;

    //
    //      Test for name too long first.  If it is, we avoid wasting time
    //
    p1 = StripQuotes( n->cmdline );
    if ((cName = mystrlen(p1)) >= MAX_PATH) {
        DosErr = MSG_LINES_TOO_LONG;
        return(SFE_NOTFND) ;
    }

    //
    // If cmd extensions enable, then treat CMD without an extension
    // or path as a reference to COMSPEC variable.  Guarantees we dont
    // get a random copy of CMD.EXE
    //

    if (fEnableExtensions && (p1 == NULL || !_tcsnicmp( p1, TEXT( "cmd " ), 4))) {
        p1 = GetEnvVar( ComSpecStr );
        if (p1 == NULL) {
            DosErr = MSG_INVALID_COMSPEC;
            return SFE_NOTFND;
        }
    }

    mytcsnset(wrkcmdline, NULLC, MAX_PATH);
    mystrcpy(wrkcmdline, p1);
    FixPChar( wrkcmdline, SwitChar );

    //
    // Create the path character string, this will be search string
    //
    pcstr[0] = PathChar;
    pcstr[1] = COLON;
    pcstr[2] = NULLC;

    //
    // The variable pcloc is used as a flag to indicate whether the user
    // did or didn't specify a drive or a partial path in his original
    // input.  It will be NZ if drive or path was specified.
    //

    pcloc = ((mystrcspn(wrkcmdline,pcstr)) < cName) ;
    pcstr[1] = NULLC ;      // Fixup pathchar string

    //
    // handle the case of the user typing in a file name of
    // ".", "..", or ending in "\"
    // pcloc true say string has to have either a pathchar or colon
    //
    if ( pcloc ) {
        if (!(p1 = mystrrchr( wrkcmdline, PathChar ))) {
            p1 = mystrchr( wrkcmdline, COLON );
        }
        p1++; // move to terminator if hanging ":" or "\"
    } else {
        p1 = wrkcmdline;
    }

    //
    // p1 is guaranteed to be non-zero
    //
    if ( !(*p1) || !_tcscmp( p1, TEXT(".") ) || !_tcscmp( p1, TEXT("..") ) ) {
        //
        // If CMD.EXE extensions enable, see if name matches
        // subdirectory name.
        //
        if (fEnableExtensions) {
            DWORD dwFileAttributes;

            dwFileAttributes = GetFileAttributes( loc );
            if (dwFileAttributes != 0xFFFFFFFF &&
                (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
               ) {
                return(SFE_ISDIR);
            }

            if (dwFileAttributes == 0xFFFFFFFF 
                && GetLastError() == ERROR_NOT_READY) {
                DosErr = ERROR_NOT_READY;
                return SFE_FAIL;
            }
        }

        DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
        return(SFE_NOTFND) ;
    }

    if (!(tmps01 = mkstr(2*sizeof(TCHAR)*MAX_PATH))) {
        DosErr = ERROR_NOT_ENOUGH_MEMORY;
        return(SFE_FAIL) ;
    }

    //
    // Handle the case of file..ext on a fat drive
    //
    mystrcpy( loc, wrkcmdline );
    loc[ &p1[0] - &wrkcmdline[0] ] = 0;
    mystrcat( loc, TEXT(".") );

    //
    // Check for a malformed name
    //
    if (FullPath(tmps01, loc,MAX_PATH*2)) {
        //
        // If CMD.EXE extensions enable, see if name matches
        // subdirectory name.
        //
        if (fEnableExtensions) {
            DWORD dwFileAttributes;

            dwFileAttributes = GetFileAttributes( loc );
            if (dwFileAttributes != 0xFFFFFFFF &&
                (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
               ) {
                return(SFE_ISDIR);
            }
        }
        DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
        return(SFE_NOTFND);
    }

    if ( *lastc(tmps01) != PathChar ) {
        mystrcat( tmps01, TEXT("\\") );
    }

    //
    // tmps01 contains full path + file name
    //
    mystrcat( tmps01, p1 );

    tmps01 = resize(tmps01, (mystrlen(tmps01)+1)*sizeof(TCHAR)) ;
    if (tmps01 == NULL) {
        DosErr = ERROR_NOT_ENOUGH_MEMORY;
        return( SFE_FAIL ) ;
    }

    //
    // fname will point to last '\'
    // tmps01 is to be path and fname is to be name
    //
    fname = mystrrchr(tmps01,PathChar) ;
    *fname++ = NULLC ;

    DEBUG((DBENV, DBENVSCAN, "SearchForExecutable: Command:%ws",fname));

    //
    // If only fname type in get path string
    //
    if (!pcloc) {
        tmps02 = GetEnvVar(PathStr) ;
    }

    DEBUG((DBENV, DBENVSCAN, "SearchForExecutable: PATH:%ws",tmps02));

    DoDot = NeedCurrentDirectoryForExePath(loc);

    //
    // tmps02 is PATH environment variable
    // compute enough for PATH environment plus file default path
    //
    tokpath = mkstr( ((DoDot ? 2 + mystrlen(tmps01) : 0) + mystrlen(tmps02) + 2)*sizeof(TCHAR)) ;
    if ( ! tokpath ) {
        DosErr = ERROR_NOT_ENOUGH_MEMORY;
        return( SFE_FAIL ) ;
    }

    if (DoDot) {
        //
        // Copy default path
        //
        mystrcat(tokpath,TEXT("\""));
        mystrcat(tokpath,tmps01) ;
        mystrcat(tokpath,TEXT("\""));
    }
    
    //
    // If only name type in get also delim and path string
    //
    if (!pcloc) {
        if (DoDot) {
            mystrcat(tokpath, TEXT(";")) ;
        }
        mystrcat(tokpath,tmps02) ;
    }

    //
    // Shift left string at ';;'
    //
    tokshrink(tokpath);
    tokpath = TokStr(tokpath, TEXT(";"), TS_WSPACE) ;
    cName = mystrlen(fname) + 1 ; // file spec. length

    //
    // Build up the list of extensions we are going to search
    // for.  If extensions are enabled, get the list from the PATHEXT
    // variable, otherwise use the hard coded default.
    //
    extPath = NULL;
    if (fEnableExtensions)
        extPath = GetEnvVar(PathExtStr);

    if (extPath == NULL)
        extPath = PathExtDefaultStr;

    tokshrink(extPath);
    extPath = TokStr(extPath, TEXT(";"), TS_WSPACE) ;

    //
    // Everything is now set up.    Var tokpath contains a sequential series
    // of asciz strings terminated by an extra null. If the user specified
    // a drive or partial path, it contains only that one converted to full
    // root-based form.     If the user typed only a filename (pcloc = 0) it
    // begins with the current directory and contains each directory that
    // was contained in the PATH variable.  This loop will search each of
    // the tokpath elements once for each possible executable extention.
    // Note that 'i' is used as a constant to test for excessive string
    // length prior to performing the string copies.
    //
    for ( ; ; ) {

        //
        // Length of current path
        //
        tplen = mystrlen(tokpath) ;
        mystrcpy( tokpath, StripQuotes( tokpath ) );
        tokpathlen = mystrlen(tokpath);

        if (*lastc(tokpath) != PathChar) {
            addpchar = TRUE;
            tplen++;
            tokpathlen++;
        } else {
            addpchar = FALSE;
        }
        /* path + name too long */
        //
        // Check if path + name is too long
        //
        if (*tokpath && (tokpathlen + cName) > MAX_PATH) {
            tokpath += addpchar ? tplen : tplen+1; // get next path
            continue;
        }

        //
        // If no more paths to search return descriptive error
        //
        if (*(tokpath) == NULLC) {
            if (pcloc) {
                if (DosErr == 0 || DosErr == ERROR_FILE_NOT_FOUND)
                    DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
            } else {                   /* return generic message */
                DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
            }
            return(SFE_NOTFND) ;
        }

        //
        // Install this path and setup for next one
        //
        mystrcpy(loc, tokpath) ;
        tokpath += addpchar ? tplen : tplen+1;


        if (addpchar) {
            mystrcat(loc, pcstr) ;
        }

        mystrcat(loc, fname) ;
        mystrcpy(loc, StripQuotes(loc) );
        dotloc = mystrlen(loc) ;

        DEBUG((DBENV, DBENVSCAN, "SearchForExecutable: PATH:%ws",loc));

        //
        // Check drive in each path to insure it is valid before searching
        //
        if (*(loc+1) == COLON) {
            if (!IsValidDrv(*loc))
                continue ;
        };

        //
        // If fname has ext & ext > "." look for given filename
        // this says that all executable files must have an extension
        //
        j = mystrrchr( fname, DOT );
        if ( j && j[1] ) {
            //
            // If access was denied and the user included a path,
            // then say we found it.  This handles the case where
            // we don't have permission to do the findfirst and so we
            // can't see the binary, but it actually exists -- if we
            // have execute permission, CreateProcess will work
            // just fine.
            //
            if (exists_ex(loc,TRUE) || (pcloc && (DosErr == ERROR_ACCESS_DENIED))) {
                //
                // Recompute j as exists_ex trims trailing spaces
                //
                j = mystrrchr( loc, DOT );
                if (j != NULL) {
                    if ( !_tcsicmp(j,CmdExt) ) {
                        return(SFE_ISBAT) ;
                    } else if ( !_tcsicmp(j,BatExt) ) {
                        return(SFE_ISBAT) ;
                    } else {
                        return(SFE_ISEXECOM) ;
                    }
                }
            }

            if ((DosErr != ERROR_FILE_NOT_FOUND) && DosErr)
                continue;  // Try next path
        }
        if (mystrchr( fname, STAR ) || mystrchr( fname, QMARK ) ) {
            DosErr = MSG_DIR_BAD_COMMAND_OR_FILE;
            return(SFE_NOTFND);
        }

        //
        // Search for each type of extension
        //

        extPathWrk = extPath;
        if (DoFind(loc, dotloc, TEXT(".*"), FALSE))         // Found anything?
            while (*extPathWrk) {
                //
                // if name + path + ext is less then max path length
                //
                if ( (cName + tokpathlen + mystrlen(extPathWrk)) <= MAX_PATH) {
                    //
                    // See if this extension is a match.
                    //

                    if (DoFind(loc, dotloc, extPathWrk, TRUE)) {
                        if (!_tcsicmp(extPathWrk, BatExt) || !_tcsicmp(extPathWrk, CmdExt))
                            return(SFE_ISBAT) ;     // found .bat or .cmd
                        else
                            return(SFE_ISEXECOM) ;  // found executable

                    } else {
                        //
                        // Any kind of error other than file not found, bail from
                        // search and try next element in path
                        //
                        if ((DosErr != ERROR_FILE_NOT_FOUND) && DosErr)
                            break;
                    }
                }

                //
                // Not this extension, try next.

                while (*extPathWrk++)
                    ;
            }

        //
        // If we get here, then no match with list of extensions.
        // If no wierd errors, deal with NUll extension case.
        //

        if (DosErr == NO_ERROR || DosErr == ERROR_FILE_NOT_FOUND) {
            if (DoFind(loc, dotloc, TEXT("\0"), TRUE)) {
                if (GetBinaryType(loc,&BinaryType) &&
                    BinaryType == SCS_POSIX_BINARY) {          // Found .
                    return(SFE_ISEXECOM) ;
                }
            }
        }
    } // end for

    return(SFE_NOTFND);
}




/***    DoFind - does indiviual findfirsts during searching
 *
 *  Purpose:
 *      Add the extension to loc and do the find first for
 *      SearchForExecutable().
 *
 *  DoFind(TCHAR *loc, int dotloc, TCHAR *ext)
 *
 *  Args:
 *      loc - the string in which the location of the command is to be placed
 *      dotloc - the location loc at which the extension is to be appended
 *      ext - the extension to append to loc
 *
 *  Returns:
 *      1 if the file is found.
 *      0 if the file isn't found.
 *
 */

int DoFind(loc, dotloc, ext, metas)
TCHAR *loc ;
int dotloc ;
TCHAR *ext ;
BOOL metas;
{
        *(loc+dotloc) = NULLC ;
        mystrcat(loc, ext) ;

        DEBUG((DBENV, DBENVSCAN, "DoFind: exists_ex(%ws)",loc));

        return(exists_ex(loc,metas)) ;                  /*@@4*/
}




/***    ExecError - handles exec errors
 *
 *  Purpose:
 *      Print the exec error message corresponding to the error number in the
 *      global variable DosErr.
 *  @@ lots of error codes added.
 *  ExecError()
 *
 */

void ExecError( onb )
TCHAR *onb;
{
        unsigned int errmsg;
        unsigned int count;

        count = ONEARG;

        switch (DosErr) {

           case ERROR_BAD_DEVICE:
                   errmsg = MSG_DIR_BAD_COMMAND_OR_FILE;
                   count = NOARGS;
                   break;

           case ERROR_LOCK_VIOLATION:
                   errmsg = ERROR_SHARING_VIOLATION;
                   break ;

           case ERROR_NO_PROC_SLOTS:
                   errmsg =  ERROR_NO_PROC_SLOTS;
                   count = NOARGS;
                   break ;

           case ERROR_NOT_DOS_DISK:
                   errmsg = ERROR_NOT_DOS_DISK;
                   break ;

           case ERROR_NOT_ENOUGH_MEMORY:
                   errmsg =  ERROR_NOT_ENOUGH_MEMORY;
                   count = NOARGS;
                   break ;

           case ERROR_PATH_NOT_FOUND:
                   errmsg =  MSG_CMD_FILE_NOT_FOUND;
                   break ;

           case ERROR_FILE_NOT_FOUND:
                   errmsg =  MSG_CMD_FILE_NOT_FOUND;
                   break ;

           case ERROR_ACCESS_DENIED:
                   errmsg =  ERROR_ACCESS_DENIED;
                   break ;

           case ERROR_EXE_MACHINE_TYPE_MISMATCH:
                   errmsg =  ERROR_EXE_MACHINE_TYPE_MISMATCH;
                   break;

           case ERROR_DRIVE_LOCKED:
                   errmsg =  ERROR_DRIVE_LOCKED;
                   break ;

           case ERROR_INVALID_STARTING_CODESEG:
                   errmsg =  ERROR_INVALID_STARTING_CODESEG;
                   break ;

           case ERROR_INVALID_STACKSEG:
                   errmsg = ERROR_INVALID_STACKSEG;
                   break ;

           case ERROR_INVALID_MODULETYPE:
                   errmsg =  ERROR_INVALID_MODULETYPE;
                   break ;

           case ERROR_INVALID_EXE_SIGNATURE:
                   errmsg =  ERROR_INVALID_EXE_SIGNATURE;
                   break ;

           case ERROR_EXE_MARKED_INVALID:
                   errmsg =  ERROR_EXE_MARKED_INVALID;
                   break ;

           case ERROR_BAD_EXE_FORMAT:
                   errmsg =  ERROR_BAD_EXE_FORMAT;
                   break ;

           case ERROR_INVALID_MINALLOCSIZE:
                   errmsg =  ERROR_INVALID_MINALLOCSIZE;
                   break ;

           case ERROR_SHARING_VIOLATION:
                   errmsg =  ERROR_SHARING_VIOLATION;
                   break ;

           case ERROR_BAD_ENVIRONMENT:
                   errmsg =  ERROR_INFLOOP_IN_RELOC_CHAIN;
                   count = NOARGS;
                   break ;

           case ERROR_INVALID_ORDINAL:
                   errmsg =  ERROR_INVALID_ORDINAL;
                   break ;

           case ERROR_CHILD_NOT_COMPLETE:
                   errmsg =  ERROR_CHILD_NOT_COMPLETE;
                   break ;

           case ERROR_DIRECTORY:
                   errmsg = MSG_BAD_CURDIR;
                   count = NOARGS;
                   break;

           case ERROR_NOT_ENOUGH_QUOTA:
                   errmsg = ERROR_NOT_ENOUGH_QUOTA;
                   count = NOARGS;
                   break;


           case MSG_REAL_MODE_ONLY:
                   errmsg =  MSG_REAL_MODE_ONLY;
                   count = NOARGS;
                   break ;

           default:
//                 printf( "Exec failed code %x\n", DosErr );    
                   count = NOARGS;
                   errmsg = MSG_EXEC_FAILURE ;             /* M031    */

        }


        LastRetCode = errmsg;
        PutStdErr(errmsg, count, onb );
}

/*
 * tokshrink @@4
 *
 * remove duplicate ';' in a path
 */

void tokshrink( tokpath )
TCHAR *tokpath;
{
   int i, j;

   i = 0;
   do {
      if ( tokpath[i] == QUOTE ) {
         do {
            i++;
         } while ( tokpath[i] && tokpath[i] != QUOTE );
      }
      if ( tokpath[i] && tokpath[i] != TEXT(';') ) {
         i++;
      }
      if ( tokpath[i] == TEXT(';') ) {
         j = i;
         while ( tokpath[j+1] == TEXT(';') ) {
            j++;
         }
         if ( j > i ) {
            mystrcpy( &tokpath[i], &tokpath[j] );
         }
         i++;
      }
   } while ( tokpath[i] );
}



/***    eAssoc - execute an Assoc command
 *
 *  Purpose:
 *      To set/modify the file associations stored in the registry under the
 *      HKEY_LOCAL_MACHINE\Software\Classes key
 *
 *  int eAssoc(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the set command
 *
 *  Returns:
 *      If setting and the command is syntactically correct, whatever SetAssoc()
 *      returns.  Otherwise, FAILURE.
 *
 *      If displaying, SUCCESS is always returned.
 *
 */

int eAssoc(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(AssocWork( n )));
    }
    else {
        return( LastRetCode = AssocWork( n ) );
    }
}

int AssocWork(n)
struct cmdnode *n ;
{
        HKEY hKeyClasses;
        TCHAR *tas ;    /* Tokenized argument string    */
        TCHAR *wptr ;   /* Work pointer                 */
        int i ;                 /* Work variable                */
        int rc ;


        rc = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Classes"), &hKeyClasses);
        if (rc) {
            return rc;
        }

        tas = TokStr(n->argptr, ONEQSTR, TS_WSPACE|TS_SDTOKENS) ;
        if (!*tas)
                rc = DisplayAssoc(hKeyClasses, NULL) ;

        else {
                for (wptr = tas, i = 0 ; *wptr ; wptr += mystrlen(wptr)+1, i++)
                        ;
                /* If too many parameters were given, the second parameter */
                /* wasn't an equal sign, or they didn't specify a string   */
                /* return an error message.                                */
                if ( i > 3 || *(wptr = tas+mystrlen(tas)+1) != EQ ||
                    !mystrlen(mystrcpy(tas, StripQuotes(tas))) ) {
                        if (i==1) {
                            rc =DisplayAssoc(hKeyClasses, tas);
                        } else {
                            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
                            rc = FAILURE ;
                        }
                } else {
                        rc = SetAssoc(hKeyClasses, tas, wptr+2) ;
                }
        } ;

        RegCloseKey(hKeyClasses) ;

        return rc;
}




/***    DisplayAssoc - display a specific file association or all
 *
 *  Purpose:
 *      To display a specific file association or all
 *
 *  int DisplayAssoc( hKeyClasses, tas )
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayAssoc(hKeyClasses, tas)
HKEY hKeyClasses;
TCHAR *tas;
{
        int i;
        int rc = SUCCESS;
        TCHAR NameBuffer[MAX_PATH];
        TCHAR ValueBuffer[MAX_PATH];
        TCHAR *vstr ;
        DWORD cb;

        if (tas == NULL) {
            for (i=0 ; rc == SUCCESS ; i++) {
                rc = RegEnumKey( hKeyClasses, i, NameBuffer, sizeof( NameBuffer ) / sizeof( TCHAR ));
                if (rc != SUCCESS) {
                    if (rc==ERROR_NO_MORE_ITEMS)
                        rc = SUCCESS;
                    break;
                } else
                if (NameBuffer[0] == DOT) {
                    cb = sizeof(ValueBuffer);
                    rc = RegQueryValue(hKeyClasses, NameBuffer, ValueBuffer, &cb);
                    if (rc != 0) {
                        break;
                    }

#if !DBG
                    if (_tcslen( ValueBuffer ) != 0)
#endif
                        rc = cmd_printf(Fmt16, NameBuffer, ValueBuffer);
                }

                if (CtrlCSeen) {
                    return(FAILURE);
                }
            }
        }
        else {
            tas = EatWS(tas, NULL);
            if ((vstr = mystrrchr(tas, ' ')) != NULL)
                *vstr = NULLC;

            cb = sizeof(ValueBuffer);
            rc = RegQueryValue(hKeyClasses, tas, ValueBuffer, &cb);
            if (rc == 0)
                rc = cmd_printf(Fmt16, tas, ValueBuffer);
            else
                PutStdErr(MSG_ASSOC_NOT_FOUND, ONEARG, tas);
        }

        return(rc);
}



/***    SetAssoc - controls adding/changing a file association
 *
 *  Purpose:
 *      Add/replace a file association
 *
 *  int SetAssoc(HKEY hKeyClasses, TCHAR *fileext, TCHAR *filetype)
 *
 *  Args:
 *      hKeyClasses - handle to HKEY_LOCAL_MACHINE\Software\Classes key
 *      fileext - file extension string to associate
 *      filetype - file type associate
 *
 *  Returns:
 *      SUCCESS if the association could be added/replaced.
 *      FAILURE otherwise.
 *
 */

int SetAssoc(hKeyClasses, fileext, filetype)
HKEY hKeyClasses;
TCHAR *fileext ;
TCHAR *filetype ;
{
    int rc;
    int i;
    DWORD cb;

    //
    //  Nothing was specified.  We are to delete the key
    //
    
    if (filetype==NULL || *filetype==NULLC) {
        rc = RegDeleteKey(hKeyClasses, fileext);
        
        //
        //  The key may have subkeys.  We only delete the default
        //  value, by opening the key and deleting the value
        //  with a zero-length name
        //
        
        if (rc != 0) {
            HKEY hKeyValue;

            rc = RegOpenKey( hKeyClasses, fileext, &hKeyValue );
            if (rc != 0) {
                //
                //  If there was no key to begin with, suppress the
                //  error
                //

                if (rc != ERROR_FILE_NOT_FOUND) {
                    PutStdErr( rc, NOARGS );
                }
            
            } else {
                rc = RegDeleteValue( hKeyValue, TEXT( "" ) );
                if (rc != 0) {
                    PutStdErr( rc, NOARGS );
                }
                RegCloseKey( hKeyValue );
            }
        }
    }
    else {
        
        //
        //  Set the value for the key
        //
        
        rc = RegSetValue(hKeyClasses, fileext, REG_SZ, filetype, _tcslen(filetype));
        if (rc == 0) {
            cmd_printf( Fmt16, fileext, filetype );
        }
        else
            PutStdErr(MSG_ERR_PROC_ARG, ONEARG, fileext);
    }
    
    //
    //  If the value was changed/deleted successfully, notify all
    //  apps about this
    //
    
    if (rc == 0) {
        try {
            SHChangeNotify( SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL );
        } except (DosErr = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return rc;
}


/***    eFType - execute an FType command
 *
 *  Purpose:
 *      To set/modify the file types stored in the registry under the
 *      HKEY_LOCAL_MACHINE\Software\Classes key
 *
 *  int eFType(struct cmdnode *n)
 *
 *  Args:
 *      n - the parse tree node containing the set command
 *
 *  Returns:
 *      If setting and the command is syntactically correct, whatever SetFType()
 *      returns.  Otherwise, FAILURE.
 *
 *      If displaying, SUCCESS is always returned.
 *
 */

int eFType(n)
struct cmdnode *n ;
{
    if (glBatType != CMD_TYPE)  {
        //  if set command is executed from .bat file OR entered at command prompt
        return( SetLastRetCodeIfError(FTypeWork( n )));
    }
    else {
        return( LastRetCode = FTypeWork( n ) );
    }
}

int FTypeWork(n)
struct cmdnode *n ;
{
        HKEY hKeyClasses;
        TCHAR *tas ;    /* Tokenized argument string    */
        TCHAR *wptr ;   /* Work pointer                 */
        int i ;                 /* Work variable                */
        int rc ;


        rc = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Classes"), &hKeyClasses);
        if (rc) {
            return rc;
        }

        tas = TokStr(n->argptr, ONEQSTR, TS_WSPACE|TS_SDTOKENS) ;
        if (!*tas)
                rc = DisplayFType(hKeyClasses, NULL) ;

        else {
                for (wptr = tas, i = 0 ; *wptr ; wptr += mystrlen(wptr)+1, i++)
                        ;
                /* If too many parameters were given, the second parameter */
                /* wasn't an equal sign, or they didn't specify a string   */
                /* return an error message.                                */
                if ( i > 3 || *(wptr = tas+mystrlen(tas)+1) != EQ ||
                    !mystrlen(mystrcpy(tas, StripQuotes(tas))) ) {
                        if (i==1) {
                            rc =DisplayFType(hKeyClasses, tas);
                        } else {
                            PutStdErr(MSG_BAD_SYNTAX, NOARGS);
                            rc = FAILURE ;
                        }
                } else {
                        rc = SetFType(hKeyClasses, tas, wptr+2) ;
                }
        } ;

        RegCloseKey(hKeyClasses) ;

        return rc;
}




/***    DisplayFType - display a specific file type or all
 *
 *  Purpose:
 *      To display a specific file type or all
 *
 *  int DisplayFType( hKeyClasses, tas )
 *
 *  Returns:
 *      SUCCESS if all goes well
 *      FAILURE if it runs out of memory or cannot lock the env. segment
 */

int DisplayFType(hKeyClasses, tas)
HKEY hKeyClasses;
TCHAR *tas;
{
    int i;
    int rc;
    HKEY hKeyOpenCmd;
    TCHAR NameBuffer[MAX_PATH];
    TCHAR ValueBuffer[MAX_PATH];
    TCHAR *vstr ;
    DWORD cb, j, Type;

    if (tas == NULL) {
        for (i = 0;;i++) {
            rc = RegEnumKey( hKeyClasses, i, NameBuffer, sizeof( NameBuffer ) / sizeof( TCHAR ));
            if (rc != 0) {
                if (rc==ERROR_NO_MORE_ITEMS)
                    rc = SUCCESS;
                break;
            } else if (NameBuffer[0] != DOT) {
                j = _tcslen( NameBuffer );
                if (j + _tcslen( ShellOpenCommandString ) + 1 <= MAX_PATH) {
                    _tcscat(NameBuffer, ShellOpenCommandString );
                    _tcscpy(ValueBuffer,TEXT("*** no open command defined ***"));
                    rc = RegOpenKey(hKeyClasses, NameBuffer, &hKeyOpenCmd);
                    if (!rc) {
                        NameBuffer[j] = TEXT('\0');
                        cb = sizeof(ValueBuffer);
                        rc = RegQueryValueEx(hKeyOpenCmd, TEXT(""), NULL, &Type, (LPBYTE)ValueBuffer, &cb);
                        RegCloseKey(hKeyOpenCmd);
                    }

                    if (!rc) {
                        cmd_printf(Fmt16, NameBuffer, ValueBuffer);
                    }
                }
            }
            if (CtrlCSeen) {
                return(FAILURE);
            }
        }
    } else {
        if (*tas == DOT) {
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, tas);
            return ERROR_INVALID_NAME;
        }

        tas = EatWS(tas, NULL);
        if ((vstr = mystrrchr(tas, ' ')) != NULL)
            *vstr = NULLC;

        if (_tcslen( tas ) + _tcslen( ShellOpenCommandString ) + 1 > MAX_PATH) {
            PutStdErr(MSG_FTYPE_TOO_LONG, ONEARG, tas);
            return ERROR_INVALID_NAME;
        }
        
        _tcscpy( NameBuffer, tas );
        _tcscat( NameBuffer, ShellOpenCommandString );
        
        rc = RegOpenKey(hKeyClasses, NameBuffer, &hKeyOpenCmd);
        if (rc) {
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, tas);
            return rc;
        }

        cb = sizeof(ValueBuffer);
        rc = RegQueryValueEx(hKeyOpenCmd, TEXT(""), NULL, &Type, (LPBYTE)ValueBuffer, &cb);
        if (rc == 0) {
            ValueBuffer[ (cb / sizeof( TCHAR )) - 1 ];
            cmd_printf(Fmt16, tas, ValueBuffer);
        } else
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, tas);
        RegCloseKey( hKeyOpenCmd );
    }

    return(rc);
}



/***    SetFType - controls adding/changing the open command associated with a file type
 *
 *  Purpose:
 *      Add/replace an open command string associated with a file type
 *
 *  int SetFType(HKEY hKeyOpenCmd, TCHAR *filetype TCHAR *opencmd)
 *
 *  Args:
 *      hKeyClasses - handle to HKEY_LOCAL_MACHINE\Software\Classes
 *      filetype - file type name
 *      opencmd - open command string
 *
 *  Returns:
 *      SUCCESS if the file type could be added/replaced.
 *      FAILURE otherwise.
 *
 */

int SetFType(hKeyClasses, filetype, opencmd)
HKEY hKeyClasses;
TCHAR *filetype ;
TCHAR *opencmd ;
{
    HKEY hKeyOpenCmd;
    TCHAR NameBuffer[MAX_PATH];
    TCHAR c, *s;
    DWORD Disposition;
    int rc;
    int i;
    DWORD cb;

    if (_tcslen( filetype ) + _tcslen( ShellOpenCommandString ) + 1 > MAX_PATH) {
        PutStdErr( MSG_FTYPE_TOO_LONG, NOARGS );
        return FAILURE;
    }
    
    _tcscpy( NameBuffer, filetype );
    _tcscat( NameBuffer, ShellOpenCommandString );

    rc = RegOpenKey(hKeyClasses, NameBuffer, &hKeyOpenCmd);
    if (rc) {
        if (opencmd==NULL || *opencmd==NULLC) {
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, filetype);
            return rc;
        }

        s = NameBuffer;
        while (TRUE) {
            while (*s && *s != TEXT('\\')) {
                s += 1;
            }
            c = *s;
            *s = TEXT('\0');
            rc = RegCreateKeyEx(hKeyClasses,
                                NameBuffer,
                                0,
                                NULL,
                                0,
                                (REGSAM)MAXIMUM_ALLOWED,
                                NULL,
                                &hKeyOpenCmd,
                                &Disposition
                               );
            if (rc) {
                PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, filetype);
                return rc;
            }

            if (c == TEXT('\0')) {
                break;
            }

            *s++ = c;
            RegCloseKey(hKeyOpenCmd);
        }
    }

    if (opencmd==NULL || *opencmd==NULLC) {
        rc = RegDeleteKey(hKeyOpenCmd, NULL);
        if (rc != 0)
            PutStdErr(MSG_FTYPE_NOT_FOUND, ONEARG, filetype);
    }
    else {
        rc = RegSetValueEx(hKeyOpenCmd, TEXT(""), 0, REG_EXPAND_SZ, (LPBYTE)opencmd, (_tcslen(opencmd)+1)*sizeof(TCHAR));
        if (rc == 0)
            cmd_printf(Fmt16, filetype, opencmd);
        else
            PutStdErr(MSG_ERR_PROC_ARG, ONEARG, filetype);
    }

    RegCloseKey(hKeyOpenCmd);
    return rc;
}


typedef
NTSTATUS
(NTAPI *PNTQUERYINFORMATIONPROCESS)(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

HMODULE hNtDllModule;
PNTQUERYINFORMATIONPROCESS lpNtQueryInformationProcess;

WORD
GetProcessSubsystemType(
    HANDLE hProcess
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    PPEB PebAddress;
    PEB Peb;
    SIZE_T SizeOfPeb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    BOOL b;
    PVOID ImageBaseAddress;
    LONG e_lfanew;
    WORD Subsystem;

    Subsystem = IMAGE_SUBSYSTEM_UNKNOWN;
    if (hNtDllModule == NULL) {
        hNtDllModule = LoadLibrary( TEXT("NTDLL.DLL") );
        if (hNtDllModule != NULL) {
            lpNtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)
                                          GetProcAddress( hNtDllModule,
                                                          "NtQueryInformationProcess"
                                                        );
            }
        else {
            hNtDllModule = INVALID_HANDLE_VALUE;
            }
        }

    if (lpNtQueryInformationProcess != NULL) {
        //
        // Get the Peb address
        //

        Status = (*lpNtQueryInformationProcess)( hProcess,
                                                 ProcessBasicInformation,
                                                 &ProcessInfo,
                                                 sizeof( ProcessInfo ),
                                                 NULL
                                               );
        if (NT_SUCCESS( Status )) {
            PebAddress = ProcessInfo.PebBaseAddress;

            //
            // Read the subsystem type from the Peb
            //

            if (ReadProcessMemory( hProcess,
                                   PebAddress,
                                   &Peb,
                                   sizeof( Peb ),
                                   &SizeOfPeb
                                 )
               ) {
                //
                // See if we are running on a system that has the image subsystem
                // type captured in the PEB.  If so use it.  Otherwise go the slow
                // way and try to get it from the image header.
                //
                if (SizeOfPeb >= FIELD_OFFSET( PEB, ImageSubsystem ) &&
                    ((UINT_PTR)Peb.ProcessHeaps - (UINT_PTR)PebAddress) > FIELD_OFFSET( PEB, ImageSubsystem )
                   ) {
                    Subsystem = (WORD)Peb.ImageSubsystem;
                    }
                else {
                    //
                    // read e_lfanew from imageheader
                    //

                    if (ReadProcessMemory( hProcess,
                                           &((PIMAGE_DOS_HEADER)Peb.ImageBaseAddress)->e_lfanew,
                                           &e_lfanew,
                                           sizeof( e_lfanew ),
                                           NULL
                                         )
                       ) {
                        //
                        // Read subsystem version info
                        //

                        NtHeader = (PIMAGE_NT_HEADERS)((PUCHAR)Peb.ImageBaseAddress + e_lfanew);
                        if (ReadProcessMemory( hProcess,
                                               &NtHeader->OptionalHeader.Subsystem,
                                               &Subsystem,
                                               sizeof( Subsystem ),
                                               NULL
                                             )
                           ) {
                            }
                        }
                    }
                }
            }
        }

    return Subsystem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cmd\clex.c ===
/*++

Copyright (c) 1988-1999  Microsoft Corporation

Module Name:

    clex.c

Abstract:

    Lexical processing support

--*/

#include "cmd.h"

extern unsigned int DosErr;
extern jmp_buf CmdJBuf2; /* Used for error handling  */

extern TCHAR DTNums[];
extern TCHAR MsgBuf[];
extern unsigned msglen;                    /*    @@@@@@@@   */
int Necho = 0;                             /* No echo option */
extern BOOLEAN fDumpTokens;
extern int KeysFlag; /* @@5 */

unsigned DataFlag;      /* Tells FillBuf where to get its input    */
UINT_PTR DataPtr;       /* File handle/string ptr FillBuf...       */

int Ctrlc = 0;  /* flag - if set print a ctrl/c before next prompt */
int ExtCtrlc = 0; /* @@4 flag, if set print msg */
int AtIsToken;    /* @@4 flag, true if @ is a token */

/***
 * The lex buffer is called LexBuf. It holds characters as they are
 * retrieved one by one by GetByte. With the advent of double byte
 * characters, UnGetByte may be sometimes called upon to put back
 * up to two characters. To facilitate this, LexBuf is really an
 * alias for &LexBuffer[1]. This gives an extra byte in front of the
 * buffer for character push back. Every time fillbuf is called, it
 * copies the last character of the previous buffer into the byte
 * preceeding the normal buffer. Thus, when UnGetByte does a
 * LexBufPtr-- the pointer will correctly point at the preceeding character.
 */
TCHAR LexBuffer[LBUFLEN+3];      /* @@4 */
                                /* ...reads from Lexer input buffer   *M011*/
                                /* LBUFLEN characters + newline + null +   */
                                /* an extra byte for UnGetByte             */
#define LexBuf (&LexBuffer[1])
TCHAR *LexBufPtr;        /* Ptr to next byte in Lex's input buffer  */

TCHAR *PrevLexPtr;       /* M013 - New previous token pointer       */

TCHAR FrsBuf[LBUFLEN+1];

extern CHAR  AnsiBuf[];

extern TCHAR Fmt27[];

extern int NulNode;
extern TCHAR Fmt19[];
extern TCHAR DBkSpc[];
#if defined(FE_SB) // DDBkSpc[]
extern TCHAR DDBkSpc[];
#endif // defined(FE_SB)
extern unsigned global_dfvalue;            /* @@4 */

extern int EchoFlag;
extern TCHAR PromptStr[], CurDrvDir[], Delimiters[];
extern unsigned flgwd;
extern BOOL CtrlCSeen;

VOID    SetCtrlC();
VOID    ResetCtrlC();

//
// Prompt string special characters and associated print character/flag.
//
// These are the flags which may be placed in the flag field of the
// prompt_table structure to control PrintPrompt
//

#define PNULLFLAG   0
#define PTIMFLAG    1
#define PDATFLAG    2
#define PPATFLAG    3
#define PVERFLAG    4
#define PBAKFLAG    5   // destructive backspace flag
#define PNLNFLAG    6   // newline prompt flag
#define PDRVFLAG    7
#define PLITFLAG    8   // Print character in SpecialChar field
#define PDPTFLAG    9   // Print depth of pushd stack
#define PNETFLAG   10   // Print \\server\share or local for current drive

//
// Esc character used to mark a special prompt char. in prompt string
//
#define PROMPTESC DOLLAR

//
// Table of prompts for user.
//
typedef struct {
    TCHAR Char;         // Used to match esc. char. in user prompt
    TCHAR  Format;       // Used to print some string that has to be computed
    TCHAR Literal;      // When Format == PLITFLAG this is printed in prompt
    } PROMPT_ENTRY;

PROMPT_ENTRY PromptTable[] = {

       { TEXT('P'),PPATFLAG, NULLC },
       { TEXT('E'),PLITFLAG,'\033' },
       { TEXT('D'),PDATFLAG, NULLC },
       { TEXT('T'),PTIMFLAG, NULLC },
       { TEXT('B'),PLITFLAG, PIPOP   },
       { TEXT('G'),PLITFLAG, OUTOP   },
       { TEXT('H'),PBAKFLAG, NULLC },
       { TEXT('L'),PLITFLAG, INOP   },
       { TEXT('N'),PDRVFLAG, NULLC },
       { TEXT('S'),PLITFLAG, SPACE   },
       { TEXT('Q'),PLITFLAG, EQ   },
       { TEXT('V'),PVERFLAG, NULLC },
       { TEXT('_'),PNLNFLAG, NULLC },
       { DOLLAR,   PLITFLAG, DOLLAR   },
       { TEXT('A'),PLITFLAG, ANDOP   },
       { TEXT('C'),PLITFLAG, LPOP   },
       { TEXT('F'),PLITFLAG, RPOP   },
       { TEXT('+'),PDPTFLAG, NULLC },
       { TEXT('M'),PNETFLAG, NULLC },
       { NULLC,PNULLFLAG, NULLC}};

/***    InitLex - initialize the lexer's global variables
 *
 *  Purpose:
 *      Initialize DataFlag, DataPtr, LexBuf, and LexBufPtr.
 *
 *  InitLex(unsigned dfvalue, INT_PTR dpvalue)
 *
 *  Args:
 *      dfvalue - the value to be assigned to DataFlag
 *      dpvalue - the value to be assigned to DataPtr
 *
 */

void InitLex(dfvalue, dpvalue)
unsigned dfvalue;
INT_PTR dpvalue;
{
        DataFlag = dfvalue;
        DataPtr = dpvalue;
        *LexBuf = NULLC;
        PrevLexPtr = LexBufPtr = LexBuf;       /* M013 - Init new ptr     */


        DEBUG((PAGRP, LXLVL, "INITLEX: Dataflag = %04x  DataPtr = %04x", DataFlag, DataPtr));
}




/***    Lex - controls data input and token lexing
 *
 *  Purpose:
 *      Read in the next token or argstring and put it in tokbuf.
 *
 *  unsigned Lex(TCHAR *tokbuf, unsigned lflag)
 *
 *  Args:
 *      tokbuf - buffer used by lex to store the next token or
 *             - M013 if zero, indicates unget last token.
 *      lflag - bit 0 on if lex is to return an argument string, ie white space
 *          other than NLN is not considered a token delimiter
 *
 *  Returns:
 *      If the token is an operator, EOS, or NLN ret the 1st byte of the token.
 *      If the token is a command, REM arg or argstring, return TEXTOKEN.
 *      If the token is longer than MAXTOKLEN or the token is illegal, LEXERROR
 *      is returned.
 *
 *  Notes:
 *      The parser depends on the fact that the only values returned by
 *      Lex that are greater than 0xff are TEXTOKEN and LEXERROR.
 *
 */

unsigned Lex(tokbuf, lflag)
TCHAR *tokbuf;
unsigned lflag;
{
        int i;        /* Length of text token                    */
        TCHAR c,                 /* Current character                       */
                *tbcpy;         /* Copy of tokbuf                          */

        if(setjmp(CmdJBuf2)) {          /* M026 - Now msg printed prior    */
            return((unsigned)LEXERROR);  /* ...to arrival here              */
        }

/*  M013 - This code detects request to unget last token and if so, performs
           that function.  If not, it sets the previous token pointer to
           to equal the current token pointer.
*/
        if (tokbuf == LX_UNGET) {               /* Unget last token?       */

                DEBUG((PAGRP, LXLVL, "LEX: Ungetting last token."));

                if (fDumpTokens)
                    cmd_printf( TEXT("Ungetting: '%s'\n"), PrevLexPtr);
                LexBufPtr = PrevLexPtr;        /* If so, reset ptr...     */
                return(LX_UNGET);              /* ...and return           */
        } else {                                /* If not, set previous... */
                PrevLexPtr = LexBufPtr;        /* ...ptr to current...    */

                DEBUG((PAGRP, LXLVL, "LEX: lflag = %d", lflag));

        }                                     /* ...ptr and continue     */
/*  M013 ends   */

        tbcpy = tokbuf;


/*  M005 - Altered conditional below to also fail if the LX_REM bit
 *         is set making it "If !(arg | rem), eat whtspc & delims".
 */
        if (!(lflag & (LX_ARG|LX_REM))) {

                DEBUG((PAGRP, LXLVL, "LEX: Trashing white space."));

                while (TRUE) {
                    c = GetByte();
                    if (((_istspace(c) && c != NLN)
                        || (mystrchr(((lflag & LX_EQOK) ? &Delimiters[1] : Delimiters), c) && c)))
                       ;
                    else
                        break;
                }
                UnGetByte();
        }

/*  As of M016, operators of more than 2 characters can be lexed.  For now,
 *  these are assumed to be specific-handle redirection operators of the form
 *  'n>>' or 'n<<' and always begin with a digit.  TextCheck will not return
 *  a digit as an operator unless it is preceeded by whitespace and followed
 *  by '>' or '<'.  To simplify matters, handle substitution (ie., '...&n')
 *  is now lexed as part of a special five character operator, instead of
 *  looking at the '&n' as an argument.  ASCII filename arguments, however,
 *  are still lexed as separate tokens via another call to Lex.
 */
        if (TextCheck(&c, &lflag) == LX_DELOP) {
                *tokbuf++ = c;         /* The token is an operator        */

                if (_istdigit(c)) {               /* Next is '<' or '>'...   */
                        DEBUG((PAGRP, LXLVL, "LEX: Found digit operator."));
                        c = GetByte();         /* ...by definition or ... */
                        *tokbuf++ = c;         /* ...we wouldn't be here  */
                }

                if (c == PIPOP || c == ANDOP || c == OUTOP || c == INOP) {
                        if ((c = GetByte()) == *(tokbuf-1)) {
                                *tokbuf++ = c;
                                c = GetByte();
                        }

                        if (*(tokbuf-1) == OUTOP || *(tokbuf-1) == INOP) {
                                DEBUG((PAGRP,LXLVL, "LEX: Found redir."));
                                if (c == CSOP) {
                                        DEBUG((PAGRP,LXLVL, "LEX: Found >&"));
                                        *tokbuf++ = c;
                                        do {
                                                c = GetByte();
                                        } while (_istspace(c) ||
                                               mystrchr(Delimiters,c));

                                        if (_istdigit(c)) {
                                                *tokbuf++ = c;
                                                c = GetByte();
                                        }
                                }
/*  M016 ends   */
                        }
                        UnGetByte();
                }

                *tokbuf = NULLC;

                DEBUG((PAGRP, LXLVL, "LEX: Returning op = `%ws'", tbcpy));

                return(*tbcpy);
        }

        DEBUG((PAGRP, LXLVL, "LEX: Found text token %04x, Getting more.", c));

        *tokbuf++ = c;         /* Found text token, read the rest         */
        lflag |= LX_DBLOK;
        AtIsToken = 0;          /* @@4, treat @ as text now */
        for (i = (int)(tokbuf-tbcpy); TextCheck(&c, &lflag) != LX_DELOP && i < MAXTOKLEN; i++)
            *tokbuf++ = c;

        lflag &= ~LX_DBLOK;
        *tokbuf = NULLC;
        if (i < MAXTOKLEN)
                UnGetByte();

        if (i >= MAXTOKLEN && c != (TCHAR) -1) { /* Token too long, complain */

/* M025 */      PutStdErr(MSG_TOKEN_TOO_LONG, ONEARG, tbcpy );
                return((unsigned)LEXERROR);
        }

        DEBUG((PAGRP, LXLVL, "LEX: Return text = `%ws'  type = %04x", tbcpy, TEXTOKEN));

        return(TEXTOKEN);
}




/***    TextCheck - get the next character and determine its type
 *
 *  Purpose:
 *      Store the next character in LexBuf in *c.  If that character is a
 *      valid text token character, return it.  Otherwise return LX_DELOP.
 *
 *  int TextCheck(TCHAR *c, unsigned &lflag)
 *
 *  Args:
 *      c - the next character in the lexer input buffer is stored here.
 *      lflag - Bit 0 = On if lex is to return an argument string, ie.,
 *                      white space other than NLN is not a token delimiter.
 *              Bit 1 = On if a quoted string is being read, ie., only NLN
 *                      or a closing quote are delimiters.
 *              Bit 2 = On if equalsigns are NOT to be considered delimiters.
 *              Bit 3 = On if left parens are to be considered operators.
 *              Bit 4 = On if right parens are to be considered operators.
 *              Bit 5 = On if only NLN is to be a delimiter.
 *              Bit 6 = On iff the caller is willing to accept the second
 *                      half of a double byte character
 *
 *  Returns:
 *      Next character or LX_DELOP if a delimeter/operator character is found.
 *
 */

int TextCheck(c, lflag)
TCHAR *c;
unsigned *lflag;
{
        TCHAR i;                        /* M016 - Temp byte holder         */
        static int saw_dbcs_lead = 0;   /* remember if we're in the middle
                                           of a double byte character */
        *c = GetByte();

        if (saw_dbcs_lead) {
                saw_dbcs_lead = 0;
                if (*lflag & LX_DBLOK)  /* If second half of double byte is */
                        return(*c);     /* ok, return it, otherwise. . . */
                else
                        *c = GetByte(); /* go on to next character */
        }

        DEBUG((PAGRP, BYLVL, "TXTCHK: c = %04x  lflag = %04x", *c, *lflag));

        switch (*c) {
                case SILOP:             /* M017 - New unary operator       */
                                        /* ...binds like left paren        */

                        if ((*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                break;

                        if( !AtIsToken )   /* If @ is not to be treated */
                          {                /* as token, then indicate  */
                            return( *c );  /* such  @@4    */
                          }

                case LPOP:              /* M002 - Moved these two cases    */

                        if ((*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                break;

                        if(!(*lflag & GT_LPOP)) /* ...up and break if      */
                                break;         /* ...they are not to      */

                case RPOP:                      /* ...be treated as ops    */

                        if ((*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                break;

                        if((!(*lflag & GT_RPOP)) && *c == RPOP)
                                break; /* M002 ends                       */

                case NLN:       /* M005 - NLN turns off QUOTE/REM flags    */
                case EOS:       /* @@5a - treat like NLN                   */

                        *lflag &= (~LX_QUOTE & ~LX_REM);       /* M005    */

                case CSOP:
                case INOP:      /* M005 - Note below that LX_DELOP...      */
                case PIPOP:     /* ...QUOTE mode or REM mode is in...      */
                case OUTOP:     /* ...in effect at the time                */

                        if (!(*lflag & (LX_QUOTE|LX_REM)))      /* M005    */
                                return(LX_DELOP);
        }

/*  M003 - If the character is '^', and the QUOTE mode flag is off,
 *         discard the current character, get the next one and return
 *         it as text.
 *  M005 - Extended this conditional to insure that both QUOTE and
 *         REM flags must be off for "escape" to occur.
 */
        if (*c == ESCHAR && !(*lflag & (LX_QUOTE|LX_REM))) {
            *c = GetByte();
            if (*c == NLN) {
                *c = GetByte( );

                //
                //  If we are at the end of the string, meaning that the
                //  command ended with ^ and there is an empty next command
                //  (most likely from a batch file), then we just treat
                //  this as a standard delimeter.
                //

                if (*c == EOS) {
                    return(LX_DELOP);
                }
            }

            return(*c);
        }

/*  M003/M005 end       */

        if (*c == QUOTE)                /* Flip quote mode flag bit        */
                *lflag ^= LX_QUOTE;

/*  M005 - Altered conditional below to also insure that REM flag was
 *         off before checking for any delimiters
 */
        if (!(*lflag & (LX_ARG|LX_QUOTE|LX_REM)) &&
            (_istspace(*c) ||
             mystrchr(((*lflag & LX_EQOK) ? &Delimiters[1] : Delimiters), *c)))
                return(LX_DELOP);

/*  As of M016, before accepting this character as text, it is now tested
 *  for being a digit followed by one of the redirection operators and;
 *  1) is the first character on a line, 2) is preceeded by whitespace or
 *  3) is preceeded by a delimiter (including Command's operators).  If it
 *  meets these conditions, it is a special, specific-handle redirection
 *  operator and TextCheck must return LX_DELOP so that Lex can build the
 *  remainder.  NOTE: LexBufPtr is advanced during GetByte, so that the
 *  current byte is *(LexBufPtr-1).
 */
        if (_istdigit(*c)) {
                DEBUG((PAGRP,BYLVL,"TXTCHK: Found digit character."));
                if ((LexBufPtr-LexBuf) < 2 ||
                    _istspace(i = *(LexBufPtr-2)) ||
                    mystrchr(TEXT("()|&=,;\""), i)) {

                        DEBUG((PAGRP,BYLVL,"TXTCHK: Digit follows delim."));

                        if (*LexBufPtr == INOP || *LexBufPtr == OUTOP) {
                            DEBUG((PAGRP,BYLVL,"TXTCHK: Found hdl redir"));

                            if (!(*lflag & (LX_QUOTE|LX_REM)))  /* M005 */
                                return(LX_DELOP);
                        }
                }
        }
/*  M016 ends   */

        return(*c);
}




/***    GetByte - return the next byte in the buffer
 *
 *  Purpose:
 *      Get the next byte from the lexer's input buffer.  If the buffer is
 *      empty, fill it first.  Update the buffer pointer.
 *
 *  TCHAR GetByte()
 *
 *  Return:
 *      The next character in the buffer or EOF.
 *
 *  Notes:
 *      All three types of input STDIN, FILE and STRING are treated
 *      the same now when it comes to dealing with CR/LF combinations.
 *      Keyboard input is massaged to look like file input.
 *      Invalid double byte characters are thrown away and not returned
 *      to the caller.
 *
 */

TCHAR GetByte()
{
        static int saw_dbcs_lead = 0;   /* remember if we're in the middle
                                           of a double byte character */
        TCHAR lead;                     /* variables for remember parts of
                                           double byte characters */

        if (!*LexBufPtr)
                FillBuf();

        DEBUG((PAGRP, BYLVL, "GTTCHAR: byte = %04x", *LexBufPtr));

        if (*LexBufPtr == CR && !saw_dbcs_lead) {
                                        /* M000 - removed file-only test   */
                LexBufPtr++;
                return(GetByte());
        }

        /* if this is a double byte character, look ahead to the next character
           and check for legality */
        if (saw_dbcs_lead) {
                saw_dbcs_lead = 0;
                return(*LexBufPtr++);
        }
        else {
                lead = *LexBufPtr++;
                return(lead);
        }
}




/***    UnGetByte - rewind the lexer buffer pointer 1 byte
 *
 *  Purpose:
 *      Back up the lexer's buffer pointer.  If the pointer already points
 *      to the beginning of the buffer, do nothing.
 *
 *  UnGetByte()
 *
 *  Return:
 *      Nothing.
 *
 */

void UnGetByte()
{
        if (!(LexBufPtr == LexBuffer))
                LexBufPtr--;
}


int
EditLine(
    CRTHANDLE CrtHandle,
    TCHAR *Buffer,	   /* the buffer to be filled */
    int MaxLength,	   /* the Maximum length of the buffer, */
	            	   /* including <CR> */
    int *ReturnLength  /* the number of characters in the buffer, not */
	            	   /* including the <CR> */
    )
{
    BOOL flag;

    flag = ReadBufFromInput( CRTTONT(CrtHandle), (TCHAR*)Buffer, MaxLength, ReturnLength);

    if (flag == 0 || *ReturnLength == 0) {
        return(GetLastError());
    } else {
        return(0);
    }
}



/***    FillBuf - read data to fill the lexer's buffer
 *
 *  Purpose:
 *      To fill the lexer's buffer with data from whatever source is indicated
 *      by the global variables DataFlag and DataPtr.  If reading from
 *      stdin, prompt for data.
 *
 *  FillBuf()
 *
 *  Notes:
 *    - Algorithm after M021 is as follows:
 *      copy last char of current buffer into LexBuffer[0] (which preceeds
 *              LexBuf by one byte) so the UnGetByte can unget two bytes
 *      If READSTDIN or READFILE
 *              If input is STDIN
 *                      Print correct prompt
 *              Use DOSREAD to fill primary buffer
 *              Copy to Lexer buffer so that primary buffer is usable by F3 key.
 *              Null terminate total input.
 *              Scan buffer for NLN || ^Z
 *              If none found
 *                      Error out
 *              Else
 *                      Terminate statement at NLN or ^Z (exclude ^Z iteself)
 *              If read was from file
 *                      Rewind to end of first statement
 *                      If file handle is STDIN
 *                              Echo statement to STDOUT
 *      Else
 *              Read first statement from string and reset pointer
 *      Reset Lexer Buffer Pointer to start of buffer
 *      Substitute for batch and environment variables (M026)
 *      Reset Previous Lexer Buffer Pointer to start of buffer
 *
 */

BOOL ReadFromStdInOkay = FALSE;

void FillBuf()
{

        long l;                        /* M004 - Data count in buffer     */

        TCHAR *sptr;           /* Copy of DataPtr                 */
        size_t i;                      /* Work variable                   */

        DWORD cnt;              /* Count of input bytes    */
        BOOL flag;

        //
        // clear this flag in case it was hit from previous command
        // if it is true we would not execute the next command
        //
        ResetCtrlC();
        LexBuffer[0] = *(LexBufPtr - 1);
        switch (DataFlag & FIRSTIME) {
                case READFILE:
                case READSTDIN:
                        if ((DataFlag & FIRSTIME) == READSTDIN ||
                            DataPtr == STDIN) {
                                if (DataFlag & NOTFIRSTIME) {
/* M025 */                              PutStdOut(MSG_MS_MORE, NOARGS);
                                } else {
                                        PrintPrompt();
                                        DataFlag |= NOTFIRSTIME;

                                        DEBUG((PAGRP, LFLVL, "FLBF: Reading stdin"));
                                }
                        }

                        //
                        // clear in case ^c seen while printing prompt
                        //
                        ResetCtrlC();
                        DEBUG((PAGRP, LFLVL, "FLBF: Reading handle %d", DataPtr));
                        //
                        // If input is STDIN and piped or input is from a
                        // device but not console input (flgwd == 1)
                        //
                        if ( ( DataPtr == STDIN ) && ( FileIsPipe( STDIN ) ||
                           ( FileIsDevice( STDIN ) && (!(flgwd & 1)) ) ) ) {

                          cnt = 0;
                          while (
                          ( cnt < LBUFLEN) &&   /* ##1 */
                          ( (ReadBufFromFile(CRTTONT((CRTHANDLE)DataPtr),
                                  &FrsBuf[cnt], 1, (LPDWORD)&i)) != 0 ||
                            GetLastError() == ERROR_MORE_DATA) &&
                          ( i != 0 )
                          ) {
                               cnt++;
                               if ( FrsBuf[cnt-1] == NLN ){
                                  break;
                               } /* endif */
                            }
                        } else if ( ( DataPtr == STDIN ) &&
                                      FileIsDevice( STDIN ) &&
                                      (flgwd & 1) ) {

                            //
                            // Are reading from stdin and it is a device
                            // (not a file) and it is console input
                            //
                            if ( KeysFlag ) {
                                i = EditLine( (CRTHANDLE)DataPtr, FrsBuf, LBUFLEN, &cnt );
                            }
                            else {
                                ResetCtrlC();
                                if (ReadBufFromConsole(
                                             CRTTONT((CRTHANDLE)DataPtr),
                                             FrsBuf,
                                             LBUFLEN,
                                             &cnt) ) {

                                    //
                                    // Check that ^c's on the current line.
                                    // Could be the case where ^c thread
                                    // came in from a previous line
                                    //
                                    //
                                    // also if cnt is 0 then outpt crlf to
                                    // prevent two prompts on command line
                                    //

                                    if (cnt == 0) {

                                        if (GetLastError() == ERROR_OPERATION_ABORTED) {
                                            cmd_printf(CrLf);
                                            longjmp(CmdJBuf2, -1);
                                        }
                                        cmd_printf(CrLf);
                                    }
                                    i = 0;
                                    DEBUG((PAGRP, LFLVL, "FLBF: ReadFile %d bytes", cnt));
                                } else {
                                    cnt = 0;
                                    i = GetLastError();
                                    DEBUG((PAGRP, LFLVL, "FLBF: ReadFile %d bytes and error %d", cnt, i));
                                }
                            }
                        }
                        else {
                          flag = ReadBufFromFile(
                                        CRTTONT((CRTHANDLE)DataPtr),
                                        FrsBuf, LBUFLEN, (LPDWORD)&cnt);
                          DEBUG((PAGRP, LFLVL, "FLBF: Read %d bytes", cnt));
                          if (CtrlCSeen) {
                              ResetCtrlC();
                              longjmp(CmdJBuf2, -1);
                              //  Abort();
                          }

                          if (flag == 0 || (int)cnt <= 0) {
                            cnt = 0;
                            i = GetLastError();
                          }
                          else {
                            i = 0;
                          }
                        }
                        DEBUG((PAGRP, LFLVL, "FLBF: I made it here alive"));
                        if (!cnt && DataPtr == STDIN) {

                                DEBUG((PAGRP,LFLVL,"FLBF: ^Z from STDIN!"));
                                DEBUG((PAGRP,LFLVL,"      READFILE retd %d",i));

                                if (FileIsDevice(STDIN) && ReadFromStdInOkay) {

                                        DEBUG((PAGRP,LFLVL,"FLBF: Is device, fixing up buffer"));
                                        FrsBuf[0] = NLN;
                                        ++cnt;
                                } else {

                                        DEBUG((PAGRP,LFLVL,"FLBF: Is file, aborting!!!"));
                                        ExitAbort(EXIT_EOF);
                                }
                        } else if (!ReadFromStdInOkay && cnt && DataPtr == STDIN) {
                            ReadFromStdInOkay = TRUE;
                        }

                        cnt = LexCopy(LexBuf, FrsBuf, cnt);

                        DEBUG((PAGRP, LFLVL, "FLBF: Received %d characters.", cnt));

                        *(LexBuf+cnt) = NULLC;         /* Term with NULL  */

/* Have total bytes read.  Now scan for NLN or ^Z.  Either means end of
 * input statement, neither in 128 bytes means buffer overflow error.
 */
                        if((i = mystrcspn(LexBuf, TEXT("\n\032"))) < mystrlen(LexBuf)
                                || cnt == 0) {  /*M029*/

                DEBUG((PAGRP, LFLVL, "FLBF: Scan found %04x", *(LexBuf+i)));
                DEBUG((PAGRP, LFLVL, "FLBF: At position %d", i));

                                sptr = LexBuf+i;       /* Set pointer     */

                                if(*sptr == CTRLZ) {
                                    *sptr = NLN;
                                }

                                if(*sptr == NLN) {      /* If \n, inc...   */
                                        ++sptr;        /* ...ptr & sub    */
                                        l = cnt - ++i; /* ....whats used  */
/*  M014 ends   */                      i = FILE_CURRENT;
                                } else {                /* If ^Z, go EOF   */
                                        l = 0;
                                        i = FILE_END;
                                }

                DEBUG((PAGRP,LFLVL,"FLBF: Changing %04x to NULLC",*(sptr-1)));

                                *sptr = NULLC;         /* Term valid input */
                                if (!FileIsDevice((CRTHANDLE)DataPtr)) {
                                        SetFilePointer(CRTTONT((CRTHANDLE)DataPtr), -l, NULL, i);

                                DEBUG((PAGRP, LFLVL, "FLBF: Rewound %ld", l));

                                        if ((DataPtr == STDIN) && (!Necho)) {
                                            CmdPutString( LexBuf );
                                        }
                                }

                        } else if(i >= LBUFLEN) {       /*M029*/

/* @@4 */                      if ( global_dfvalue == READFILE )
/* @@4 */                         {
/* @@4 */                         if ( EchoFlag == E_ON )
/* @@4 */                            {
/* @@4 */                                DEBUG((PAGRP, LXLVL,
/* @@4 */                                "BLOOP: Displaying Statement."));
/* @@4 */
/* @@4 */                                PrintPrompt();
/* @@4 */                                cmd_printf(&LexBuffer[1]);
/* @@4 */                                cmd_printf(CrLf);
/* @@4 */                            }
/* @@4 */                             PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
/* @@4 */                             Abort();
/* @@4 */                         }

                                PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
/* M028 */                      if(DataPtr == STDIN && FileIsDevice((CRTHANDLE)DataPtr))
                                        FlushKB();
                                longjmp(CmdJBuf2,-1);
                        }
                        break;

                case READSTRING:

                        DEBUG((PAGRP, LFLVL, "FLBF: Reading string."));

                        *(LexBuf+LBUFLEN) = NULLC;     /* Term max string */
                        _tcsncpy(LexBuf, (TCHAR *) DataPtr, LBUFLEN);
                        DataPtr += mystrlen(LexBuf)*sizeof(TCHAR);   /* Update DataPtr  */

                        DEBUG((PAGRP, LFLVL, "FLBF: New DataPtr = %ws", DataPtr));
                        break;
        }

        LexBufPtr = LexBuf;            /* M004 - Reset pointer            */

        SubVar();                      /* Sub env & batch vars (M026)     */

        DEBUG((PAGRP, LFLVL, "FLBF: Buffer contents: `%ws'", LexBufPtr));

/*  Insure that when buffer is refilled, the previous token pointer is
 *  reset to the start of the lexer buffer
 */
        PrevLexPtr = LexBufPtr;
}


/***   LexCopy - copy the lex buffer
 *
 *  Purpose:
 *      To copy the contents read into the dos buffer into LexBuf,
 *      translating double byte spaces into regular spaces in the
 *      process.
 *  Input:
 *      A to and from pointer and a byte count.
 *  Returned:
 *      A new byte count which might be smaller than that passed in.
 */
int LexCopy(to, from, count)
TCHAR *to, *from;
int count;
{

    _tcsncpy( to, from, count );
    return count;

}

BOOLEAN PromptValid;
TCHAR PromptVariableBuffer[ 512 ];
TCHAR PromptBuffer[ 1024 ];

void
PrintPrompt()

/*++

Routine Description:

    To print Command's main input prompt and to interpret the special
    characters in it (see MSDOS manual for list of special prompt
    characters).

    An array of PROMPT_ENTRY structures called PromptTable is searched for
    the special characters.  If a match is found , then either print out
    the special character if the format field is PLITFLAG or do some
    sort of special processing to print out the prompt string such as
    get time of day etc.

Arguments:


Return Value:


--*/

{
        TCHAR *pszPrompt;
        TCHAR *s;
        int nLeft, nUsed;
        ULONG idx;
#if defined(FE_SB)
        // This local variable is used for determine the last
        // character is full width character (=DBCS) or not.
        TCHAR chLast = NULLC;
#endif
        if (CtrlCSeen) {
                PutStdOut(MSG_C, NOARGS);
                ResetCtrlC();
                // Abort();
        }

//
// The newline which must preceed the prompt is tied to prompt rather than to
// command completion in Dispatch.
//
// Also return without newline or prompt if echo status is "echo off".
//
    if (EchoFlag == E_OFF) {
        return;
    }

    if (!NulNode) {
        cmd_printf(CrLf);
    }

    if ( PromptValid ) {
        pszPrompt = PromptVariableBuffer;
        }
    else {
        //
        // Fetch user prompt string from environment (should be PROMPT)
        //
        pszPrompt = GetEnvVar(PromptStr);
        if ( pszPrompt ) {
            mystrcpy( PromptVariableBuffer, pszPrompt);
            pszPrompt = PromptVariableBuffer;
            PromptValid = TRUE;
            }
        }
    //
    // refetch the current directory,  since we may have lost the
    // drive letter due to net disconnect
    //
    GetDir(CurDrvDir, GD_DEFAULT);
    DEBUG((PAGRP, LFLVL, "PRINTPROMPT: pszPrompt = `%ws'", pszPrompt));

    s = PromptBuffer;
    *s = NULLC;
    nLeft = sizeof(PromptBuffer) / sizeof(TCHAR);

    //
    // Check if there was a prompt string.
    // If there is not prompt string then just print current drive
    //
    if (!pszPrompt || !*pszPrompt) {
        nUsed = _sntprintf( s, nLeft, Fmt27, CurDrvDir);
        s += nUsed;
        nLeft -= nUsed;

    } else {

        //
        // Loop through interpreting prompt string
        //
        for (; *pszPrompt; pszPrompt++) {

            //
            // Look for the escape character in prompt for special
            // processing
            //
            if (*pszPrompt != PROMPTESC) {

                nUsed = _sntprintf( s, nLeft, Fmt19, *pszPrompt);
                s += nUsed;
                nLeft -= nUsed;

#if defined(FE_SB)
                // If character is full width character, mark it.
                if (IsDBCSCodePage() &&
                    IsFullWidth(*pszPrompt))
                    chLast = *pszPrompt;
                 else
                    chLast = NULLC;
#endif

            } else {

                //
                // There is an escape character in prompt string.
                // Try to find a match for next character after escape
                // character from prompt table.
                //
                pszPrompt++;
                for (idx = 0; PromptTable[idx].Char != NULLC; idx++)
                    if (_totupper(*pszPrompt) == PromptTable[idx].Char) {

                        break;
                    }

                if (PromptTable[idx].Char == NULLC) {

                    //
                    // Could find no match for escape. Exit loop to print
                    // what we have so far
                    //
                    break;

                } else {

                    if (PromptTable[idx].Format == PLITFLAG) {

                        nUsed = _sntprintf( s, nLeft, Fmt19, PromptTable[idx].Literal);
                        s += nUsed;
                        nLeft -= nUsed;

                    } else {

                        switch (PromptTable[idx].Format) {

                        case PTIMFLAG:

                            nUsed = PrintTime(NULL, PT_TIME, s, nLeft);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PDATFLAG:

                            nUsed = PrintDate(NULL, PD_DATE, s, nLeft);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PPATFLAG:

                            nUsed = _sntprintf( s, nLeft, TEXT( "%s" ), CurDrvDir);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PVERFLAG:
                            {
                                TCHAR VersionFormat[32];
                                PTCHAR Message;
                                GetVersionString( 
                                    VersionFormat, 
                                    sizeof( VersionFormat ) / sizeof( VersionFormat[0] ));
                                Message = GetMsg( MSG_MS_DOS_VERSION, VersionFormat );
                                nUsed = _sntprintf( s, nLeft, TEXT( "%s" ), Message );
                                s += nUsed;
                                nLeft -= nUsed;
                                LocalFree( Message );
                            }

                            break;

                        case PBAKFLAG:

#if defined(FE_SB) // PrintPrompt()
                            // if the last character is full width character.
                            // we should delete 2 bytes.
                            if (chLast != NULLC)
                                nUsed = _sntprintf( s, nLeft, DDBkSpc);
                             else
                                nUsed = _sntprintf( s, nLeft, DBkSpc);
#else
                            nUsed = _sntprintf( s, nLeft, DBkSpc);
#endif
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PNLNFLAG:

                            nUsed = _sntprintf( s, nLeft, CrLf);
                            s += nUsed;
                            nLeft -= nUsed;
                            break;

                        case PDPTFLAG:
                            //
                            //  $+ generates from zero to N plus characters, depending upon
                            //     the depth of the PUSHD directory stack.
                            //
                            if (fEnableExtensions) {
                                int Depth = GetDirStackDepth( );

                                while (nLeft && Depth--) {
                                    *s++ = TEXT( '+' );
                                    nLeft--;
                                }
                            }
                                
                            break;

                        case PNETFLAG:
                            //
                            //  $m generates the empty string if the current drive is not a
                            //     network drive.  If it is, then $m generates the \\server\share
                            //     name with a trailing space.
                            //
                            if (!fEnableExtensions) {
                                break;
                            }

                            {
                                TCHAR CurDrive[4];
                                TCHAR NetPath[MAX_PATH];
                                DWORD n, Err;


                                _tcsncpy( CurDrive, CurDrvDir, 2 );
                                CurDrive[2] = BSLASH;
                                CurDrive[3] = NULLC;
                                if (GetDriveType( CurDrive ) != DRIVE_REMOTE) {
                                    break;
                                }
                                
                                CurDrive[2] = NULLC;
                                n = MAX_PATH;
                                
                                try {
                                    Err = WNetGetConnection( CurDrive, NetPath, &n );
                                } except( Err = GetExceptionCode( ), EXCEPTION_EXECUTE_HANDLER) {
                                }
                                
                                switch (Err) {
                                case NO_ERROR:
                                    nUsed = _sntprintf( s, nLeft, TEXT("%s "), NetPath);
                                    s += nUsed;
                                    nLeft -= nUsed;
                                    break;

                                case ERROR_NOT_CONNECTED:
                                    break;

                                default:
                                    nUsed = _sntprintf( s, nLeft, TEXT("Unknown"));
                                    s += nUsed;
                                    nLeft -= nUsed;
                                    break;
                                }
                            }
                            break;

                        default:
                            nUsed = _sntprintf( s, nLeft, Fmt19, CurDrvDir[0]);
                            s += nUsed;
                            nLeft -= nUsed;
                        }
                    }
                }
            }
        } // for
    } // else

    *s = NULLC;
    CmdPutString( PromptBuffer );

    //
    // If ^c seen while printing prompt blow it away
    //
    if (CtrlCSeen) {
        ResetCtrlC();
    }

}




/***    IsData - check the input buffer
 *
 *  Purpose:
 *      Check the lexer's input buffer to see if there is data in it.
 *
 *  int IsData()
 *
 *  Returns:
 *      TRUE if the buffer has data in it.
 *      FALSE if the buffer is empty.
 *
 */

int IsData()
{
        DEBUG((PAGRP, LXLVL, "ISDATA: *LexBufPtr = %04x", *LexBufPtr));

        if (*LexBufPtr)
                return(TRUE);

        return(FALSE);
}




/***    SubVar - Substitute for environment variables. (M004)
 *
 *  Purpose:
 *      This function scans the lexer input buffer looking for percent
 *      signs and substituting batch variables and environment variables
 *      as they are found.
 *
 *  void SubVar()
 *
 *  NOTES:
 *    - This function does not return if expansion causes length to exceed
 *      maximum line length (LBUFLEN).
 *    - M026 caused complete rewrite to perform batch variable substitution
 *      at the lexer stage rather than in batch processing.  Note that the
 *      printing of error messages can now be either line too long or token
 *      too long, so error printing occurs before the longjmp() call.
 */

void SubVar()
{
    PTCHAR lxtmp;
    int dlen;             /* Temps & counters                */
    int j, slen;
    TCHAR *srcp;
    TCHAR *substr = NULL;           /* Possible Env Var pointer        */
    TCHAR c;               /* Temp byte holder                */

    srcp = lxtmp = mkstr( (LBUFLEN + 1) * sizeof( TCHAR ));
    if (lxtmp == NULL) {
        memset( LexBuffer, 0, sizeof( LexBuffer ));
        LexBufPtr = LexBuf;
        longjmp( CmdJBuf2, -1 );
    }
    
    mystrcpy(srcp,LexBufPtr);      /* Make a copy of the input        */

    DEBUG((PAGRP, LXLVL, "SBENV: Copy = %ws", srcp));

    dlen = j = slen = 0;   /* Zero the counters               */

    while ((c = *srcp++) && dlen <= LBUFLEN + 1) {
        if (c != PERCENT) {
            *LexBufPtr++ = c;
            ++dlen;
            if (c == NLN)    /* Stop subst. if statement end    */
                break;
            continue;
        }

        DEBUG((PAGRP,LXLVL,"SBVAR: Found `%%' in input"));
        DEBUG((PAGRP,LXLVL,"SBVAR: Current pair is `%c%c'",c,*srcp));

        if (CurrentBatchFile && *srcp == PERCENT) {

            DEBUG((PAGRP,LXLVL,"SBVAR: Found `%%%%' in batch file"));

            *LexBufPtr++ = *srcp++;
            ++dlen;
            continue;
        }

        //
        // If inside a command script and extensions are enabled,
        // expand %* into all the arguments (%1 through %n).
        //
        if (CurrentBatchFile && fEnableExtensions && *srcp == STAR) {
            ++srcp;                /* Kick past star          */

            slen = mystrlen(CurrentBatchFile->orgargs);
            substr = CurrentBatchFile->orgargs;
            DEBUG((PAGRP,LXLVL,"SBVAR: Found batch var %*"));
            DEBUG((PAGRP,LXLVL,"SBVAR:   - len = %d", slen));
            DEBUG((PAGRP,LXLVL,"SBVAR:   - var = %ws", substr));

            if (slen > 0) {
                if (dlen+slen > MAXTOKLEN) {

                    DEBUG((PAGRP,LXLVL,"SBVAR: Too Long!"));

                    _tcsncpy(LexBufPtr,substr,MAXTOKLEN - dlen);
                    LexBuf[MAXTOKLEN] = NULLC;
                    PutStdErr(MSG_TOKEN_TOO_LONG, ONEARG,LexBuf);
                    FreeStr( lxtmp );
                    longjmp(CmdJBuf2,-1);
                }

                mystrcpy(LexBufPtr, substr);
                dlen += slen;
                LexBufPtr += slen;

                DEBUG((PAGRP,LXLVL,"SBVAR: Subst complete; dest = `%ws'", LexBuf));
            } else {

                DEBUG((PAGRP,LXLVL,"SBVAR: Var %* undefined"));
            }

            continue;
        }

        //
        // If inside a command script attempt to expand variable references
        // of the form %n where n is a digit from 0 to 9
        //
        // If not in a command script or not a variable reference see if
        // this is an environment variable expansion request.
        //
        if ((CurrentBatchFile != NULL
             && (substr = MSCmdVar( &CmdJBuf2, srcp, &j, TEXT("0123456789"), CurrentBatchFile->aptrs ))) 
            || (substr = MSEnvVar( &CmdJBuf2, srcp, &j, PERCENT )) != NULL ) {

            DEBUG((PAGRP,LXLVL,"SBVAR: Found var %ws", substr));

            //
            // Either variable reference or environment variable reference.
            // Copy the result to the input buffer
            //
            slen = mystrlen( substr );
            dlen += slen;
            if (dlen  > LBUFLEN + 1) {
                PutStdErr( MSG_LINES_TOO_LONG, NOARGS );
                FreeStr( lxtmp );
                longjmp( CmdJBuf2, -1 );
            }
            mystrcpy( LexBufPtr, substr );
            LexBufPtr += slen;
            srcp += j;
        } else {

            DEBUG((PAGRP,LXLVL,"SBVAR: No var found"));

            //
            // Variable not found.  If inside of command script, toss
            // the variable reference in the bit bucket.  If not in a
            // command script pass the characters that make up the reference
            // into the input buffer.  User will see their mistake shortly.
            //
            if (CurrentBatchFile) {
                srcp += j;
            } else {
                *LexBufPtr++ = c;
                dlen++;
            }
        }
    }

    *LexBufPtr = NULLC;            /* Terminate Statement             */
    LexBufPtr = LexBuf;            /* Reset Pointer to start          */

    if (dlen > LBUFLEN+1) {          /* Statement too long??            */
        *LexBufPtr = NULLC;    /* If so, kill line, print err     */
        PutStdErr(MSG_LINES_TOO_LONG, NOARGS);
        FreeStr( lxtmp );
        longjmp(CmdJBuf2,-1);
    }
    FreeStr( lxtmp );
}




/***    MSEnvVar - Does environment variable substitution
 *
 *  Purpose:
 *      When percent signs are found in the newly filled lexer buffer,
 *      this function is called to determine if there is an environment
 *      variable substitution possible.
 *
 *  TCHAR *MSEnvVar(TCHAR *str, int *supdate, TCHAR delim)
 *
 *  Args:
 *      errjmp  - optional pointer to jmp_buf for errors
 *      str     - pointer to a possible environment variable name
 *      supdate - location to place env variable name length in
 *      delim   - delimiter character to look for (e.g. PERCENT)
 *
 *  Returns:
 *      If there is no ending delim,
 *              set supdate to 0
 *              return NULL
 *      else
 *              set supdate to the enclosed string length
 *              if the string is not an environment variable
 *                      return NULL
 *              else
 *                      return a pointer to the replacement string
 *
 *  Notes:
 *    - M026 changed the way this function works so that supdate will
 *      contain the string length if any string was found.  This allows
 *      the string to be deleted if within a batch file.
 *
 */

TCHAR *MSEnvVar(errjmp, str, supdate, delim)
jmp_buf *errjmp;
TCHAR *str;
int *supdate;
const TCHAR delim;
{
    PTCHAR TempBuf;
    TCHAR *w0;                     /* Points to ending delim          */
    TCHAR *w1;                     /* Will hold ptr to env var value  */
    TCHAR *w2;
    TCHAR *SearchString;
    TCHAR *SearchStringEnd;
    int SearchLength;
    TCHAR *ReplaceString;
    TCHAR *ReplaceStringEnd;
    int ReplaceLength;
    TCHAR TerminatingChar;
    int noff, nlen;
    BOOL PrefixMatch;

    //
    //  Allocate temp buffer space
    //
    
    TempBuf = mkstr( LBUFLEN * sizeof( TCHAR ));
    if (TempBuf == NULL) {
        if (errjmp != NULL) {
            longjmp( *errjmp, -1 );
        }

        *supdate = 0;
        return NULL;
    }
    
    //
    //  Search for character that terminates the environment variable.
    //  This can be either the passed-in delimiter or a COLON
    //  (when extensions are enabled) as long as the colon isn't
    //  immediately followed by the delimiter.  In this case, we
    //  treat the colon as part of the environment variable name.
    //

    w0 = str;
    while (
           //   Stop at end of string
           *w0 != NULLC &&

           //   Stop at delimiter
           *w0 != delim &&

           //   Stop if extensions and colon not followed by delimiter
           (!fEnableExtensions || w0[0] != COLON || w0[1] == delim)) {

        w0++;
    }

    DEBUG((PAGRP, LFLVL, "MSENVVAR: *w0 = %04x", *w0));

    //
    //  If there is no further text or if there are two delimiters
    //  in a row then the env var is not well formed and we terminate
    //

    if ( *w0 == NULLC || w0 == str) {
        *supdate = 0;
        FreeStr( TempBuf );
        return NULL;
    }

    //
    //  We have pointers to the start and end of the environment variable name.
    //  Terminate the name, look it up in the environment and restore the
    //  original name
    //

    TerminatingChar = *w0;
    *w0 = NULLC;

    DEBUG((PAGRP, LFLVL, "MSENVVAR: Possible env var = `%ws'", str));

    w1 = GetEnvVar(str);

    //
    //  w1 points to the environment variable value in a buffer that we 
    //  can use.  This static buffer is good until the next GetEnvVar call.
    //

    *w0++ = TerminatingChar;

    //
    //  If Command Extensions are enabled, then we support munging the
    //  output of environment variable expansion.  Here is the supported
    //  syntax, all keyed off a trailing COLON character at the end of
    //  the environment variable name.  Note, that %FOO:% is treated
    //  as it was before.
    //
    //  Environment variable substitution has been enhanced as follows:
    //
    //      %PATH:str1=str2%
    //
    //  would expand the PATH environment variable, substituting each
    //  occurrence of "str1" in the expanded result with "str2".  "str2" can
    //  be the empty string to effectively delete all occurrences of "str1"
    //  from the expanded output.  Additionally:
    //
    //      %PATH:~10,5%
    //
    //  would expand the PATH environment variable, and then use only the 5
    //  characters that begin at the 11th character of the expanded result.
    //  If the ,5 is left off, it will take the entire remainder of the
    //  expanded result.
    //

    //
    //  If we aren't doing extensions or we have a simple replacement
    //  or the named environment variable has no value then we're done.
    //
    //  Note that we must do this for non-existent environment variables
    //  since the following will generate big problems:
    //      for %i in (c:foo) do ...
    //  The % will introduce an environment variable and the : will indicate
    //  a substitution.  If we were to delete the above text, things break.
    //

    if (!fEnableExtensions 
        || TerminatingChar != COLON 
        || w1 == NULL) {
        *supdate = (int)(w0 - str);
        FreeStr( TempBuf );
        return w1;
    }

    if (*w0 == EQI) {

        //
        //  We are extracting a substring   %PATH:~10,5%
        //

        w0 += 1;

        //
        //  Parse the offset within the environment string.  A
        //  negative number indicates an offset from the right end of
        //  the string.
        //

        noff = _tcstol( w0, &w0, 0 );
        if (noff < 0) {
            noff += _tcslen( w1 );
        }

        noff = max( 0, min( noff, (int)_tcslen( w1 )));

        //
        //  If a comma is present, what follows is the maximum length
        //  to be copied.  Parse off this number, negative turns into
        //  an offset from the right of the string
        //

        if (*w0 == COMMA) {
            //
            //  The length is specified; extract it and bound it by the
            //  length of the entire string
            //
            w0 += 1;
            nlen = _tcstol( w0, &w0, 0 );

            if (nlen < 0) {
                nlen += _tcslen( w1 + noff );
            }

            nlen = max( 0, nlen );
            nlen = min( nlen, (int)_tcslen( w1 + noff ));
        } else {
            nlen = _tcslen( w1 + noff );
        }

        //
        //  Copy from the string up to the requested length or the
        //  terminating NUL
        //

        _tcsncpy( w1, w1+noff, nlen );
        
        //
        //  Terminate the string.  We need to be extra careful here since the string
        //  may be the null string above which is in READ/ONLY memory.
        //
        
        if (w1[nlen] != NULLC) {
            w1[nlen] = NULLC;
        }

        //
        //  We must have a terminating delimiter to make this a valid
        //  substitution.
        //

        if (*w0++ != delim) {
            *supdate = 0;
            FreeStr( TempBuf );
            return NULL;
        }

        *supdate = (int)(w0 - str);

    } else {

        //
        // Not extracting a string, so must be search and replacing
        //
        //  %PATH:str1=str2%
        //
        //  Test for asterisk and skip forward looking for = sign or
        //  end of string
        //

        if (*w0 == STAR) {
            w0++;
            PrefixMatch = TRUE;
        } else {
            PrefixMatch = FALSE;
        }

        SearchString = w0;
        while (*w0 != NULLC && *w0 != EQ) {
            w0 += 1;
        }

        //
        //  No equal sign is no substitution
        //

        if (*w0 == NULLC) {
            *supdate = 0;
            FreeStr( TempBuf );
            return NULL;
        }

        SearchStringEnd = w0;
        SearchLength = (int)(SearchStringEnd - SearchString);

        //
        //  An empty search string is a syntax error
        //

        if (SearchLength == 0) {
            if (errjmp != NULL) {
                PutStdErr( MSG_SYNERR_GENL, ONEARG, SearchStringEnd );
                FreeStr( TempBuf );
                longjmp( *errjmp, -1 );
            }

            *supdate = 0;
            FreeStr( TempBuf );
            return NULL;
        }

        //
        //  Find end of replacement string
        //

        w0++;
        ReplaceString = w0;
        while (*w0 && *w0 != delim) {
            w0 += 1;
        }

        //
        //  No terminating delimiter is no substitution
        //

        if (*w0 == NULLC) {
            *supdate = 0;
            FreeStr( TempBuf );
            return NULL;
        }

        ReplaceStringEnd = w0++;
        ReplaceLength = (int)(ReplaceStringEnd - ReplaceString);

        //
        //  Everything is well-formed now.  Set the correct number
        //  of source chars to be skipped.
        //

        *supdate = (int)(w0 - str);

        //
        //  If there's actually a string to replace
        //
        
        if (*w1 != TEXT( '\0' )) {
            
            //
            //  Copy env var into temp buffer so that we can
            //  perform a replacement copy back to original buffer
            //

            _tcscpy( TempBuf, w1 );
            w2 = TempBuf;
            w0 = w1;

            //
            //  Walk forward through w2 trying to find instances of
            //  the search string and replacing them into w2
            //

            while (TRUE) {
                if (!_tcsnicmp( w2, SearchString, SearchLength )) {

                    //
                    //  A prefix match means replacing everything from the
                    //  beginning of the string through the end of the search
                    //  match with the replacement string and then bailing
                    //

                    if (PrefixMatch) {
                        _tcsncpy( w1, ReplaceString, ReplaceLength );
                        _tcscpy( w1 + ReplaceLength, w2 + SearchLength );
                        break;
                    }

                    //
                    //  Otherwise, we copy in the replacement string and
                    //  skip over the search string
                    //

                    _tcsncpy( w0, ReplaceString, ReplaceLength );
                    w0 += ReplaceLength;
                    w2 += SearchLength;

                } else {

                    //
                    //  Not a match, copy this one character
                    //

                    *w0++ = *w2++;
                    if (w0[-1] == NULLC) {
                        break;
                    }
                }
            }
        }
    }

    FreeStr( TempBuf );
    return w1;
}


struct {
    ULONG dwAttributeFlag;
    TCHAR chAttributeChar;
} rgAttrToCharMap[] = {
    {FILE_ATTRIBUTE_DIRECTORY ,     TEXT('d')},
    {FILE_ATTRIBUTE_READONLY  ,     TEXT('r')},
    {FILE_ATTRIBUTE_ARCHIVE   ,     TEXT('a')},
    {FILE_ATTRIBUTE_HIDDEN    ,     TEXT('h')},
    {FILE_ATTRIBUTE_SYSTEM    ,     TEXT('s')},
    {FILE_ATTRIBUTE_COMPRESSED,     TEXT('c')},
    {FILE_ATTRIBUTE_OFFLINE   ,     TEXT('o')},
    {FILE_ATTRIBUTE_TEMPORARY ,     TEXT('t')},
    {FILE_ATTRIBUTE_REPARSE_POINT,  TEXT('l')},
    {0, NULLC}
};

/***    MSCmdVar - Does command variable substitution
 *
 *  Purpose:
 *      When percent signs are found in the newly filled lexer buffer,
 *      this function is called to determine if there is a command processor
 *      variable substitution possible.
 *
 *  TCHAR *MSCmdVar(TCHAR *srcp, int *supdate, TCHAR *vars, TCHAR *subs[])
 *
 *  Args:
 *      errjmp  - optional pointer to jmp_buf for errors
 *      srcp    - pointer to a possible variable name
 *      supdate - location to place variable name length in
 *      vars    - array of character variable names to look for
 *      subs    - array of substitution strings for each variable name.
 *
 *  Returns:
 *      If there is no ending delimiter
 *              set supdate to 0
 *              return NULL
 *      else
 *              set supdate to the enclosed string length
 *              if the string is not a variable
 *                      return NULL
 *              else
 *                      return a pointer to the replacement string
 */

TCHAR *MSCmdVar(errjmp, srcp, supdate, vars, subs)
jmp_buf *errjmp;
TCHAR *srcp;
int *supdate;
TCHAR *vars;
TCHAR *subs[];
{
    static TCHAR ValidModifiers[] = TEXT( "fdpnxsatz" );
    TCHAR *substr;
    TCHAR *s1;

    substr = NULL;
    *supdate = 0;
    //
    // If extensions are enabled, we support the following syntax for expanding
    // variable values:
    //     %~fi         - expands %i to a fully qualified path name
    //     %~di         - expands %i to a drive letter only
    //     %~pi         - expands %i to a path only
    //     %~ni         - expands %i to a file name only
    //     %~xi         - expands %i to a file extension only
    //     %~si         - changes the meaning of n and x options to
    //                     reference the short name instead
    //     %~$PATH:i    - searches the directories listed in the PATH
    //                     environment variable and expands %i to the
    //                     fully qualified name of the first one found.
    //                     If the environment variable name is not
    //                     defined or the file is not found by the
    //                     search, then this modifier expands to the
    //                     empty string
    //
    // The modifiers can be combined to get compound results:
    //
    //     %~dpi       - expands %i to a drive letter and path only
    //     %~nxi       - expands %i to a file name and extension only
    //     %~dp$PATH:i - searches the directories listed in the PATH
    //                    environment variable for %i and expands to the
    //                    drive letter and path of the first one found.
    //

    //
    // See if new syntax is being specified
    //
    if (fEnableExtensions && *srcp == EQI) {

#define PATHMODIFIER    0x8000
#define ATTRMODIFIER    0x4000

#define WANTFULLPATH    (0x0001)
#define WANTDRIVE       (0x0002)
#define WANTPATH        (0x0004)
#define WANTNAME        (0x0008)
#define WANTEXTENSION   (0x0010)
#define WANTSHORTNAME   (0x0020)
#define PATHBITS        (0x00FF)

#define WANTATTRIB      (0x0100)
#define WANTTIMESTAMP   (0x0200)
#define WANTSIZE        (0x0400)
#define ATTRBITS        (0x0F00)
        
        ULONG Modifiers = 0;
        ULONG LastModifierValue = 0;
        TCHAR *LastVariablePosition;

        TCHAR FullPath[ 2 * MAX_PATH], NullExt;
        TCHAR *FilePart, *Extension, *StartPath, *VarName, *StartBuf;
        const TCHAR *SearchVar;
        DWORD FullPathLength;

        FullPathLength = 0;
        SearchVar = NULL;
        StartBuf = srcp-1;
        s1 = NULL;
        
        
        srcp++;
        
        LastVariablePosition = srcp;
        
        //
        //  Walk forward through the string, remembering where we see variables
        //  and saving the position and status of the modifiers at the most
        //  recent variable.  We stop when we encounter a char that cannot be a
        //  modifier.  If that char is a variable, we use it.  Otherwise, we
        //  reset the pointer to the most recently found variable.
        //

        while (*srcp != TEXT( '\0' ) && 
               *srcp != TEXT( '$' ) && 
               _tcsrchr( ValidModifiers, _totlower( *srcp )) != NULL) {
            //
            //  The cha