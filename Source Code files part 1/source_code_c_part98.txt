
    CL_NETWORK_ID NetworkId;
    ULONG SeqNumber;
    ULONG AckNumber;
} INTERFACE_HEARTBEAT_INFO, *PINTERFACE_HEARTBEAT_INFO;

#define InterfaceHBInfoInitialLength            16
#define InterfaceHBInfoLengthIncrement          4

PINTERFACE_HEARTBEAT_INFO InterfaceHeartBeatInfo = NULL;
ULONG InterfaceHBInfoCount;         // running count while sending HBs
ULONG InterfaceHBInfoCurrentLength; // current length of HB info array

LARGE_INTEGER HBTime;       // HB time in relative sys time
#define MAX_DPC_SKEW    ( -HBTime.QuadPart / 2 )

//
// Outerscreen mask. This is set by clussvc's membership manager in user
// mode. As it changes, MM drops down the set outerscreen Ioctl to update
// clusnet's notion of this mask. Clusnet uses this mask to determine the
// validity of a received heart beat. If the sending node is not part
// of the mask, then it is sent a poison packet and the received event
// is not passed on to other consumers. If it is a legetimate PP, then
// we generate the proper event.
//
// Note: MM type definitions and macros have been moved to cnpdef.h for
//       general usage.
//
typedef CX_CLUSTERSCREEN CX_OUTERSCREEN;

CX_OUTERSCREEN MMOuterscreen;


// Multicast Heartbeat Data
//
typedef struct _NETWORK_MCAST_HEARTBEAT_INFO {
    CL_NETWORK_ID        NetworkId;
    PCNP_MULTICAST_GROUP McastGroup;
    CX_HB_NODE_INFO      NodeInfo[ClusterDefaultMaxNodes+ClusterMinNodeId];
    CX_CLUSTERSCREEN     McastTarget;
} NETWORK_MCAST_HEARTBEAT_INFO, *PNETWORK_MCAST_HEARTBEAT_INFO;

#define NetworkHBInfoInitialLength            4
#define NetworkHBInfoLengthIncrement          4

PNETWORK_MCAST_HEARTBEAT_INFO NetworkHeartBeatInfo = NULL;
ULONG NetworkHBInfoCount;         // running count while sending HBs
ULONG NetworkHBInfoCurrentLength; // current length of HB info array

CL_NETWORK_ID     MulticastBestNetwork = ClusterAnyNetworkId;

ULONG CxMulticastEpoch = 0;

//
// Declarations for Clussvc to Clusnet Heartbeating.
//
ULONG             ClussvcClusnetHbTimeoutTicks = 0;
ClussvcHangAction ClussvcClusnetHbTimeoutAction = ClussvcHangActionDisable;
ULONG             ClussvcClusnetHbTickCount = 0;
BOOLEAN           ClussvcTerminateStopHbs = FALSE;
PIO_WORKITEM      ClussvcTerminateWorkItem = NULL;
// Parameters for the Clussvc to Clusnet Heartbeating bugcheck. These are
// for informational purposes only and should not otherwise be used. For
// instance, the process object is dereferenced immediately after the 
// pointer is determined.
PEPROCESS         ClussvcProcessObject = NULL;
ULONG             ClussvcClusnetHbTimeoutSeconds = 0;

/* Forward */

NTSTATUS
CxInitializeHeartBeat(
    void
    );

VOID
CxUnloadHeartBeat(
    VOID
    );

VOID
CnpHeartBeatDpc(
    PKDPC DpcObject,
    PVOID DeferredContext,
    PVOID Arg1,
    PVOID Arg2
    );

BOOLEAN
CnpWalkNodesToSendHeartBeats(
    IN  PCNP_NODE   UpdateNode,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    );

BOOLEAN
CnpWalkNodesToCheckForHeartBeats(
    IN  PCNP_NODE   UpdateNode,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    );

VOID
CnpSendHBs(
    IN  PCNP_INTERFACE   UpdateInterface
    );

NTSTATUS
CxSetOuterscreen(
    IN  ULONG Outerscreen
    );

VOID
CnpReceivePoisonPacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber
    );

VOID
CnpUpdateMulticastEpoch(
    ULONG NewEpoch
    );

VOID
CnpCheckClussvcHang(
    VOID
    );

VOID
CnpLogClussvcHangAndTerminate(    
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

VOID
CnpLogClussvcHang(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

/* End Forward */


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CxInitializeHeartBeat)
#pragma alloc_text(PAGE, CxUnloadHeartBeat)

#endif // ALLOC_PRAGMA



NTSTATUS
CxInitializeHeartBeat(
    void
    )

/*++

Routine Description:

    Init the mechanisms used to send and monitor heart beats

Arguments:

    None

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if allocation fails.
    STATUS_SUCCESS otherwise.

--*/

{
    // allocate the interface info array
    InterfaceHBInfoCount = 0;
    InterfaceHBInfoCurrentLength = InterfaceHBInfoInitialLength;
    
    if (InterfaceHBInfoCurrentLength > 0) {
        InterfaceHeartBeatInfo = CnAllocatePool(
                                     InterfaceHBInfoCurrentLength 
                                     * sizeof(INTERFACE_HEARTBEAT_INFO)
                                     );
        if (InterfaceHeartBeatInfo == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    // allocate the network info array
    NetworkHBInfoCount = 0;
    NetworkHBInfoCurrentLength = NetworkHBInfoInitialLength;

    if (NetworkHBInfoCurrentLength > 0) {
        NetworkHeartBeatInfo = CnAllocatePool(
                                   NetworkHBInfoCurrentLength
                                   * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                                   );
        if (NetworkHeartBeatInfo == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        RtlZeroMemory(
            NetworkHeartBeatInfo, 
            NetworkHBInfoCurrentLength * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
            );
    }

    KeInitializeTimer( &HeartBeatTimer );
    KeInitializeDpc( &HeartBeatDpc, CnpHeartBeatDpc, NULL );
    KeInitializeEvent( &HeartBeatDpcFinished, SynchronizationEvent, FALSE );
    CnInitializeLock( &HeartBeatLock, CNP_HBEAT_LOCK );

    MEMLOG( MemLogInitHB, 0, 0 );

    return(STATUS_SUCCESS);

} // CxInitializeHeartBeat


VOID
CxUnloadHeartBeat(
    VOID
    )
/*++

Routine Description:

    Called during clusnet driver unload. Free any data structures
    allocated to send and monitor heartbeats.

Arguments:

    None

Return Value:

    None

--*/
{
    PAGED_CODE();

    if (InterfaceHeartBeatInfo != NULL) {
        CnFreePool(InterfaceHeartBeatInfo);
        InterfaceHeartBeatInfo = NULL;
    }

    if (NetworkHeartBeatInfo != NULL) {
        CnFreePool(NetworkHeartBeatInfo);
        NetworkHeartBeatInfo = NULL;
    }

    return;

} // CxUnloadHeartBeat


NTSTATUS
CnpStartHeartBeats(
    VOID
    )

/*++

Routine Description:

    Start heart beating with the nodes that are marked alive and have
    an interface marked either OnlinePending or Online.

Arguments:

    None

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if the workitem allocation fails

--*/

{
    BOOLEAN TimerInserted;
    CN_IRQL OldIrql;
    ULONG period = HEART_BEAT_PERIOD;

    //
    // Pre-allocate a workitem in case we need an emergency
    // termination of the cluster service due to a user-mode
    // hang.
    // No need to take the lock before the allocation and
    // assignment, since below is the first place the lock 
    // is acquired as the service starts.
    CnAssert(ClussvcTerminateWorkItem == NULL);
    ClussvcTerminateWorkItem = IoAllocateWorkItem(CnDeviceObject);
    if (ClussvcTerminateWorkItem == NULL) {
        CnTrace(HBEAT_EVENT, HbTraceTerminateWorkItemAlloc,
            "[HB] Failed to pre-allocate clussvc termination "
            "workitem.\n"
            );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CnAcquireLock( &HeartBeatLock, &OldIrql );

    HBTime.QuadPart = Int32x32To64( HEART_BEAT_PERIOD, -10000 );

    TimerInserted = KeSetTimerEx(&HeartBeatTimer,
                                 HBTime,
                                 HEART_BEAT_PERIOD,
                                 &HeartBeatDpc);

    HeartBeatEnabled = TRUE;
    ClussvcTerminateStopHbs = FALSE;

    CnTrace(HBEAT_EVENT, HbTraceTimerStarted,
        "[HB] Heartbeat timer started. Period = %u ms.",
        period // LOGULONG
        );            
    
    MEMLOG( MemLogHBStarted, HEART_BEAT_PERIOD, 0 );

    CnReleaseLock( &HeartBeatLock, OldIrql );

    return(STATUS_SUCCESS);

} // CnpStartHeartBeats

VOID
CnpStopHeartBeats(
    VOID
    )

/*++

Routine Description:

    Stop heart beating with other nodes in the cluster.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN      TimerCanceled;
    CN_IRQL      OldIrql;
    PIO_WORKITEM FreeWorkItem = NULL;

    CnAcquireLock( &HeartBeatLock, &OldIrql );

    if (HeartBeatEnabled) {
        HeartBeatEnabled = FALSE;

        //
        // Cancel the periodic timer. Contrary to what the DDK implies,
        // this does not cancel the DPC if it is still queued from the
        // last timer expiration. It only stops the timer from firing
        // again. This is true as of 8/99. See KiTimerListExpire() in
        // ntos\ke\dpcsup.c.
        //
        TimerCanceled = KeCancelTimer( &HeartBeatTimer );

        CnTrace(HBEAT_DETAIL, HbTraceTimerCancelled,
            "[HB] Heartbeat timer cancelled: %!bool!",
            TimerCanceled // LOGBOOLEAN
            );

        MEMLOG( MemLogHBStopped, 0, 0 );

        //
        // Remove the DPC associated with the timer from the system DPC
        // queue, if it is there. This actually does nothing, because a
        // timer DPC is only inserted into the system DPC  queue if it is
        // bound to a specific processor. Unbound DPCs are executed inline
        // on the current processor in the kernel's timer expiration code.
        // Note that the object for a periodic timer is reinserted into the
        // timer queue before the DPC is excuted. So, it is possible for the
        // timer and the associated DPC to be queued simultaneously. This is
        // true as of 8/99. See KiTimerListExpire() in ntos\ke\dpcsup.c.
        //
        // The bottom line is that there is no safe way to synchronize with
        // the execution of a timer DPC during driver unload. All we can
        // do is ensure that the DPC handler code recognizes that it should
        // abort execution immediately and hope that it does so before the
        // driver code is unloaded. We do this by setting the HeartBeatEnabled
        // flag to False above. If our DPC code happens to be executing at
        // this point in time on another processor, as denoted by
        // HeartBeatDpcRunning, we wait for it to finish.
        //
        if ( !KeRemoveQueueDpc( &HeartBeatDpc )) {

            CnTrace(HBEAT_DETAIL, HbTraceDpcRunning,
                "[HB] DPC not removed. HeartBeatDpcRunning = %!bool!",
                HeartBeatDpcRunning // LOGBOOLEAN
                );
        
            MEMLOG( MemLogHBDpcRunning, HeartBeatDpcRunning, 0 );

            if ( HeartBeatDpcRunning ) {

                CnReleaseLock( &HeartBeatLock, OldIrql );

                CnTrace(HBEAT_DETAIL, HbWaitForDpcToFinish,
                    "can't remove DPC; waiting on DPCFinished event"
                    );

                MEMLOG( MemLogWaitForDpcFinish, 0, 0 );

                KeWaitForSingleObject(&HeartBeatDpcFinished,
                                      Executive,
                                      KernelMode,
                                      FALSE,              // not alertable
                                      NULL);              // no timeout

                KeClearEvent( &HeartBeatDpcFinished );

                CnAcquireLock( &HeartBeatLock, &OldIrql);
            }
        }

        CnTrace(HBEAT_EVENT, HbTraceTimerStopped,
            "[HB] Heartbeat timer stopped."
            );

    }

    //
    // If the pre-allocated workitem was not used, we need to 
    // free it to remove the reference on the clusnet device object.
    //
    FreeWorkItem = ClussvcTerminateWorkItem;
    ClussvcTerminateWorkItem = NULL;

    CnReleaseLock( &HeartBeatLock, OldIrql );

    if (FreeWorkItem != NULL) {
        IoFreeWorkItem(FreeWorkItem);
    }

    return;

} // CnpStopHeartBeats

VOID
CnpSendMcastHBCompletion(
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     Buffer
)
/*++

Routine Description:
    
    Called when a mcast heartbeat send request completes 
    successfully or unsuccessfully. Dereferences the
    McastGroup data structure.
    
Arguments:

    Status - status of request
    
    BytesSent - not used
    
    Context - points to multicast group data structure
    
    Buffer - not used
    
Return value:

    None.
    
--*/
{
    PCNP_MULTICAST_GROUP mcastGroup = (PCNP_MULTICAST_GROUP) Context;

    CnAssert(mcastGroup != NULL);

    CnpDereferenceMulticastGroup(mcastGroup);

    return;

} // CnpSendMcastHBCompletion

NTSTATUS
CnpSendMcastHB(
    IN  PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Writes multicast heartbeat data into the NetworkHeartBeatInfo
    array for target Interface.
    
Notes:

    Called from DPC with Network and Node locks held.
    Returns with Network and Node locks held.

--*/
{
    ULONG      i;
    BOOLEAN    networkConnected;

    // find the network info structure for this network
    for (i = 0; i < NetworkHBInfoCount; i++) {
        if (NetworkHeartBeatInfo[i].NetworkId 
            == Interface->Network->Id) {
            break;
        }
    }

    // start a new network info structure, if necessary
    if (i == NetworkHBInfoCount) {

        // before claiming an entry in the network info array,
        // make sure the array is large enough
        if (NetworkHBInfoCount >= NetworkHBInfoCurrentLength) {

            // need to allocate a new network info array

            PNETWORK_MCAST_HEARTBEAT_INFO tempInfo = NULL;
            PNETWORK_MCAST_HEARTBEAT_INFO freeInfo = NULL;
            ULONG                         tempLength;

            tempLength = NetworkHBInfoCurrentLength
                + NetworkHBInfoLengthIncrement;
            tempInfo = CnAllocatePool(
                           tempLength 
                           * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                           );
            if (tempInfo == NULL) {

                CnTrace(
                    HBEAT_DETAIL, HbNetInfoArrayAllocFailed,
                    "[HB] Failed to allocate network heartbeat info "
                    "array of length %u. Cannot schedule heartbeat "
                    "for node %u on network %u.",
                    tempLength, 
                    Interface->Node->Id,
                    Interface->Network->Id
                    );

                // cannot continue. the failure to send this
                // heartbeat will not be fatal if we recover
                // quickly. if we do not recover, this node
                // will be poisoned, which is probably best
                // since it is dangerously low on nonpaged pool.

                return(STATUS_INSUFFICIENT_RESOURCES);

            } else {

                // the allocation was successful. establish
                // the new array as the heartbeat info
                // array.

                RtlZeroMemory(
                    tempInfo,
                    tempLength * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                    );

                freeInfo = NetworkHeartBeatInfo;
                NetworkHeartBeatInfo = tempInfo;
                NetworkHBInfoCurrentLength = tempLength;

                if (freeInfo != NULL) {

                    if (NetworkHBInfoCount > 0) {
                        RtlCopyMemory(
                            NetworkHeartBeatInfo,
                            freeInfo,
                            NetworkHBInfoCount 
                            * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                            );
                    }

                    CnFreePool(freeInfo);
                }

                CnTrace(
                    HBEAT_DETAIL, HbNetInfoArrayLengthIncreased,
                    "[HB] Increased network heartbeat info array "
                    "to size %u.",
                    NetworkHBInfoCurrentLength
                    );
            }
        }

        // increment the current counter
        NetworkHBInfoCount++;

        // initialize the information for this structure
        RtlZeroMemory(
            &NetworkHeartBeatInfo[i].McastTarget,
            sizeof(NetworkHeartBeatInfo[i].McastTarget)
            );
        NetworkHeartBeatInfo[i].NetworkId = Interface->Network->Id;
        NetworkHeartBeatInfo[i].McastGroup = 
            Interface->Network->CurrentMcastGroup;
        CnpReferenceMulticastGroup(NetworkHeartBeatInfo[i].McastGroup);
    }

    networkConnected = (BOOLEAN)(!CnpIsNetworkLocalDisconn(Interface->Network));

    CnTrace(HBEAT_DETAIL, HbTraceScheduleMcastHBForInterface,
        "[HB] Scheduling multicast HB for node %u on network %u "
        "(I/F state = %!ifstate!) "
        "(interface media connected = %!bool!).",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State, // LOGIfState
        networkConnected
        );

    // fill in the network info for this node/interface
    NetworkHeartBeatInfo[i].NodeInfo[Interface->Node->Id].SeqNumber = 
        Interface->SequenceToSend;
    NetworkHeartBeatInfo[i].NodeInfo[Interface->Node->Id].AckNumber =
        Interface->LastSequenceReceived;
    CnpClusterScreenInsert(
        NetworkHeartBeatInfo[i].McastTarget.ClusterScreen,
        INT_NODE(Interface->Node->Id)
        );

    return(STATUS_SUCCESS);

} // CnpSendMcastHB

NTSTATUS
CnpSendUcastHB(
    IN  PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Writes unicast heartbeat data into the InterfaceHeartBeatInfo
    array for target Interface.
    
Notes:

    Called from DPC with Network and Node locks held.
    Returns with Network and Node locks held.

--*/
{
    BOOLEAN    networkConnected;
    
    // before filling an entry in the heartbeat info array,
    // make sure the array is large enough.
    if (InterfaceHBInfoCount >= InterfaceHBInfoCurrentLength) {

        // need to allocate a new heartbeat info array

        PINTERFACE_HEARTBEAT_INFO tempInfo = NULL;
        PINTERFACE_HEARTBEAT_INFO freeInfo = NULL;
        ULONG                     tempLength;

        tempLength = InterfaceHBInfoCurrentLength 
            + InterfaceHBInfoLengthIncrement;
        tempInfo = CnAllocatePool(
                       tempLength * sizeof(INTERFACE_HEARTBEAT_INFO)
                       );
        if (tempInfo == NULL) {

            CnTrace(
                HBEAT_DETAIL, HbInfoArrayAllocFailed,
                "[HB] Failed to allocate heartbeat info "
                "array of length %u. Cannot schedule heartbeat "
                "for node %u on network %u.",
                tempLength, 
                Interface->Node->Id,
                Interface->Network->Id
                );

            // cannot continue. the failure to send this
            // heartbeat will not be fatal if we recover
            // quickly. if we do not recover, this node
            // will be poisoned, which is probably best
            // since it is dangerously low on nonpaged pool.

            return(STATUS_INSUFFICIENT_RESOURCES);

        } else {

            // the allocation was successful. establish
            // the new array as the heartbeat info
            // array.

            freeInfo = InterfaceHeartBeatInfo;
            InterfaceHeartBeatInfo = tempInfo;
            InterfaceHBInfoCurrentLength = tempLength;

            if (freeInfo != NULL) {

                if (InterfaceHBInfoCount > 0) {
                    RtlCopyMemory(
                        InterfaceHeartBeatInfo,
                        freeInfo,
                        InterfaceHBInfoCount * sizeof(INTERFACE_HEARTBEAT_INFO)
                        );
                }

                CnFreePool(freeInfo);
            }

            CnTrace(
                HBEAT_DETAIL, HbInfoArrayLengthIncreased,
                "[HB] Increased heartbeat info array to size %u.",
                InterfaceHBInfoCurrentLength
                );
        }
    }

    networkConnected = (BOOLEAN)(!CnpIsNetworkLocalDisconn(Interface->Network));

    CnTrace(HBEAT_DETAIL, HbTraceScheduleHBForInterface,
        "[HB] Scheduling HB for node %u on network %u (I/F state = %!ifstate!) "
        "(interface media connected = %!bool!).",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State, // LOGIfState
        networkConnected
        );

    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].NodeId = Interface->Node->Id;
    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].SeqNumber =
        Interface->SequenceToSend;
    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].AckNumber =
        Interface->LastSequenceReceived;
    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].NetworkId = Interface->Network->Id;

    ++InterfaceHBInfoCount;

    return(STATUS_SUCCESS);

} // CnpSendUcastHB


VOID
CnpSendHBs(
    IN  PCNP_INTERFACE   Interface
    )

/*++

Routine Description:

    If Interface is in the correct state then stuff an entry in
    the heartbeat info array. Expand the heartbeat info
    array if necessary.

Arguments:

    Interface - target interface for heartbeat message

Return Value:

    None

--*/

{
    BOOLEAN mcastOnly = FALSE;

    if ( Interface->State >= ClusnetInterfaceStateUnreachable ) {

        // increment the sequence number
        (Interface->SequenceToSend)++;

        // check if we should include this interface in a 
        // multicast heartbeat. first we verify that the
        // network is multicast capable. then, we include it
        // if either of the following conditions are true:
        // - we have received a multicast heartbeat from the
        //   target interface
        // - the discovery count (the number of discovery mcasts
        //   left to send to the target interface) is greater 
        //   than zero
        if (CnpIsNetworkMulticastCapable(Interface->Network)) {
            
            if (CnpInterfaceQueryReceivedMulticast(Interface)) {

                // write the mcast heartbeat data. if not
                // successful, attempt a unicast heartbeat.
                if (CnpSendMcastHB(Interface) == STATUS_SUCCESS) {
                    mcastOnly = TRUE;
                }

            } else if (Interface->McastDiscoverCount > 0) {

                // write the mcast heartbeat data for a
                // discovery. if successful, decrement the
                // discovery count.
                if (CnpSendMcastHB(Interface) == STATUS_SUCCESS) {
                    --Interface->McastDiscoverCount;

                    // if the discovery count has reached zero,
                    // set the rediscovery countdown. this is
                    // the number of heartbeat periods until we
                    // try discovery again.
                    if (Interface->McastDiscoverCount == 0) {
                        Interface->McastRediscoveryCountdown = 
                            CNP_INTERFACE_MCAST_REDISCOVERY;
                    }
                }
            } else if (Interface->McastRediscoveryCountdown > 0) {

                // decrement the rediscovery countdown. if we
                // reach zero, we will start multicast discovery
                // on the next heartbeat to this interface.
                if (--Interface->McastRediscoveryCountdown == 0) {
                    Interface->McastDiscoverCount = 
                        CNP_INTERFACE_MCAST_DISCOVERY;
                }
            }
        }

        // write unicast heartbeat data
        if (!mcastOnly) {
            CnpSendUcastHB(Interface);
        }
    }

    CnReleaseLock(&Interface->Network->Lock, Interface->Network->Irql);

    return;

} // CnpSendHBs

VOID
CnpCheckForHBs(
    IN  PCNP_INTERFACE   Interface
    )

/*++

Routine Description:

    Check if heart beats have been received for this interface

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG   MissedHBCount;
    BOOLEAN NetworkLockReleased = FALSE;

    if ( Interface->State >= ClusnetInterfaceStateUnreachable
         && !CnpIsNetworkLocalDisconn(Interface->Network) ) {

        MissedHBCount = InterlockedIncrement( &Interface->MissedHBs );

        if ( MissedHBCount == 1 ) {

            //
            // a HB was received in time for this node. Clear the status
            // info associated with this interface, but also mark the node
            // as having an interface that is ok. Note that we do not
            // use HBs on restricted nets to determine node health.
            //

            if (!CnpIsNetworkRestricted(Interface->Network)) {
                Interface->Node->HBWasMissed = FALSE;
            }
            
            CnTrace(HBEAT_DETAIL, HbTraceHBReceivedForInterface,
                "[HB] A HB was received from node %u on net %u in this "
                "period.",
                Interface->Node->Id, // LOGULONG
                Interface->Network->Id // LOGULONG
                );

        } else {
            CnTrace(HBEAT_EVENT, HbTraceMissedIfHB,
                "[HB] HB MISSED for node %u on net %u, missed count %u.",
                Interface->Node->Id, // LOGULONG
                Interface->Network->Id, // LOGULONG
                MissedHBCount // LOGULONG
                );

            MEMLOG4(
                MemLogMissedIfHB,
                (ULONG_PTR)Interface, MissedHBCount,
                Interface->Node->Id,
                Interface->Network->Id
                );

            if ( MissedHBCount >= HBInterfaceLostHBTicks &&
                 Interface->State >= ClusnetInterfaceStateOnlinePending ) {

                //
                // interface is either online pending or online, so move it
                // to unreachable. CnpFailInterface will also mark the node
                // unreachable if all of the node's interfaces are unreachable.
                // CnpFailInterface releases the network object lock as part
                // of its duties.
                //

                CnTrace(HBEAT_DETAIL, HbTraceFailInterface,
                    "[HB] Moving I/F for node %u on net %u to failed state, "
                    "previous I/F state = %!ifstate!.",
                    Interface->Node->Id, // LOGULONG
                    Interface->Network->Id, // LOGULONG
                    Interface->State // LOGIfState
                    );
                
                //
                // continuation log entries go before the main entry since
                // we scan the log backwards, i.e., we'll hit FailingIf
                // before we hit FailingIf1.
                //
                MEMLOG4(
                    MemLogFailingIf,
                    (ULONG_PTR)Interface,
                    Interface->State,
                    Interface->Node->Id,
                    Interface->Network->Id
                    );

                CnpFailInterface( Interface );
                NetworkLockReleased = TRUE;

                //
                // issue a net interface unreachable event to let consumers
                // know what is happening
                //
                CnTrace(HBEAT_EVENT, HbTraceInterfaceUnreachableEvent,
                    "[HB] Issuing InterfaceUnreachable event for node %u "
                    "on net %u, previous I/F state = %!ifstate!.",
                    Interface->Node->Id, // LOGULONG
                    Interface->Network->Id, // LOGULONG
                    Interface->State // LOGIfState
                    );
                
                CnIssueEvent(ClusnetEventNetInterfaceUnreachable,
                             Interface->Node->Id,
                             Interface->Network->Id);
            }
        }
    }

    if ( !NetworkLockReleased ) {

        CnReleaseLock(&Interface->Network->Lock,
                      Interface->Network->Irql);
    }

    return;

} // CnpCheckForHBs

BOOLEAN
CnpWalkNodesToSendHeartBeats(
    IN  PCNP_NODE   Node,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    )

/*++

Routine Description:

    Support routine called for each node in the node table. If node is
    alive, then we walk its interfaces, performing the appropriate
    action.

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // If this node is alive and not the local node, then walk its
    // interfaces, supplying the appropriate routine to use at this time
    //

    if ( Node->MMState == ClusnetNodeStateAlive &&
         Node != CnpLocalNode ) {

        CnTrace(HBEAT_DETAIL, HbTraceScheduleHBForNode,
            "[HB] Scheduling HBs for node %u (state = %!mmstate!).",
            Node->Id, // LOGULONG
            Node->MMState // LOGMmState
            );
                
        MEMLOG( MemLogSendHBWalkNode, Node->Id, Node->MMState );
        CnpWalkInterfacesOnNode( Node, (PVOID)CnpSendHBs );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    return TRUE;       // the node table lock is still held

} // CnpWalkNodesToSendHeartBeats

BOOLEAN
CnpWalkNodesToCheckForHeartBeats(
    IN  PCNP_NODE   Node,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    )

/*++

Routine Description:

    heart beat checking routine called for each node  in the node table
    (except for the local node). If node is alive, then we walk its
    interfaces, performing the appropriate action.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN NodeWasReachable;
    ULONG MissedHBCount;

    if ( Node->MMState == ClusnetNodeStateAlive &&
         Node != CnpLocalNode ) {

        //
        // this node is alive, so walk its interfaces. Assume the
        // worst by setting the HB Missed flag to true and
        // have the interfaces prove that this is wrong. Also make
        // note of the current unreachable flag setting. If it changes
        // this time
        //

        NodeWasReachable = !CnpIsNodeUnreachable( Node );
        Node->HBWasMissed = TRUE;

        CnTrace(HBEAT_DETAIL, HbTraceCheckNodeForHeartbeats,
            "[HB] Checking for HBs from node %u. WasReachable = %!bool!, "
            "state = %!mmstate!.",
            Node->Id, // LOGULONG
            NodeWasReachable, // LOGBOOLEAN
            Node->MMState // LOGMmState
            );

        MEMLOG( MemLogCheckHBNodeReachable, Node->Id, NodeWasReachable );
        MEMLOG( MemLogCheckHBWalkNode, Node->Id, Node->MMState );

        CnpWalkInterfacesOnNode( Node, (PVOID)CnpCheckForHBs );

        if ( Node->HBWasMissed ) {

            //
            // no HBs received on any of this node's IFs. if membership
            // still thinks this node is alive and the node has been
            // unreachable, then note that this node is toast in HB
            // info array. This will cause a node down event to be
            // generated for this node.
            //

            MissedHBCount = InterlockedIncrement( &Node->MissedHBs );

            CnTrace(HBEAT_EVENT, HbTraceNodeMissedHB,
                "[HB] Node %u has missed %u HBs on all interfaces, "
                "current state = %!mmstate!.",
                Node->Id, // LOGULONG
                MissedHBCount, // LOGULONG
                Node->MMState // LOGMmState
                );

            MEMLOG( MemLogCheckHBMissedHB, MissedHBCount, Node->MMState );

            //
            // if the this node is a either a member or in the process of
            // joining AND it's missed too many HBs AND we haven't issued a
            // node down, then issue a node down.
            //
            if ( ( Node->MMState == ClusnetNodeStateAlive
                   ||
                   Node->MMState == ClusnetNodeStateJoining
                 )
                 && MissedHBCount >= HBNodeLostHBTicks
                 && !Node->NodeDownIssued
               )
            {
                Node->NodeDownIssued = TRUE;
                CnIssueEvent( ClusnetEventNodeDown, Node->Id, 0 );

                CnTrace(HBEAT_EVENT, HbTraceNodeDownEvent,
                    "[HB] Issuing NodeDown event for node %u.",
                    Node->Id // LOGULONG
                    );
                        
                MEMLOG( MemLogNodeDownIssued, Node->Id, TRUE );
            }
        }
    } else {
        MEMLOG( MemLogCheckHBWalkNode, Node->Id, Node->MMState );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    return TRUE;       // the node table lock is still held

} // CnpWalkNodesToCheckForHeartBeats

VOID
CnpHeartBeatDpc(
    PKDPC DpcObject,
    PVOID DeferredContext,
    PVOID Arg1,
    PVOID Arg2
    )

/*++

Routine Description:

    Start heart beating with the nodes that are marked alive and have
    an interface marked either OnlinePending or Online.

Arguments:

    None

Return Value:

    None

--*/

{
    PINTERFACE_HEARTBEAT_INFO     pNodeHBInfo;
    PNETWORK_MCAST_HEARTBEAT_INFO pMcastHBInfo;
    CN_IRQL                       OldIrql;
    BOOLEAN                       StopSendRecvHbs;

#ifdef MEMLOGGING
    static LARGE_INTEGER LastSysTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeDelta;

    //
    // try to determine the skew between when we asked to be run and
    // the time we actually did run
    //

    KeQuerySystemTime( &CurrentTime );

    if ( LastSysTime.QuadPart != 0 ) {

        //
        // add in HBTime which is negative due to relative sys time
        //

        TimeDelta.QuadPart = ( CurrentTime.QuadPart - LastSysTime.QuadPart ) +
            HBTime.QuadPart;

        if ( TimeDelta.QuadPart > MAX_DPC_SKEW ||
             TimeDelta.QuadPart < -MAX_DPC_SKEW 
           ) 
        {
            LONG skew = (LONG)(TimeDelta.QuadPart/10000);  // convert to ms

            MEMLOG( MemLogDpcTimeSkew, TimeDelta.LowPart, 0 );
            

            CnTrace(HBEAT_EVENT, HbTraceLateDpc,
                "[HB] Timer fired %d ms late.", 
                skew // LOGSLONG
                );

        }
    }

    LastSysTime.QuadPart = CurrentTime.QuadPart;

#endif // MEMLOGGING

    CnAcquireLock( &HeartBeatLock, &OldIrql );

    if ( !HeartBeatEnabled ) {
        CnTrace(HBEAT_DETAIL, HbTraceSetDpcEvent,
            "DPC: setting HeartBeatDpcFinished event"
            );
        
        MEMLOG( MemLogSetDpcEvent, 0, 0 );

        KeSetEvent( &HeartBeatDpcFinished, 0, FALSE );
        
        CnReleaseLock( &HeartBeatLock, OldIrql );
        
        return;
    }

    HeartBeatDpcRunning = TRUE;

    //
    // Check if we need to stop sending heartbeats. This
    // occurs when clusnet detects that clussvc is not
    // operating correctly. In case system work queues
    // are blocked up (but not DPCs), we stop sending
    // heartbeats so that other nodes initiate failover.
    //
    StopSendRecvHbs = ClussvcTerminateStopHbs;

    CnReleaseLock( &HeartBeatLock, OldIrql );

    if (!StopSendRecvHbs) {

        if ( HeartBeatClockTicks == 0 ||
             HeartBeatClockTicks == HeartBeatSendTicks) {

            //
            // time to send HBs. Clear the count of target interfaces 
            // and walk the node table finding the nodes that are
            // marked alive.
            //

            NetworkHBInfoCount = 0;
            InterfaceHBInfoCount = 0;
            CnpWalkNodeTable( CnpWalkNodesToSendHeartBeats, NULL );

            //
            // run down the list of networks and send out any multicast
            // heartbeats.
            //

            pMcastHBInfo = NetworkHeartBeatInfo;
            while ( NetworkHBInfoCount-- ) {

                CnTrace(
                    HBEAT_EVENT, HbTraceSendMcastHB,
                    "[HB] Sending multicast HB on net %u.\n",
                    pMcastHBInfo->NetworkId
                    );

                CxSendMcastHeartBeatMessage(
                    pMcastHBInfo->NetworkId,
                    pMcastHBInfo->McastGroup,
                    pMcastHBInfo->McastTarget,
                    CxMulticastEpoch,
                    pMcastHBInfo->NodeInfo,
                    CnpSendMcastHBCompletion,
                    pMcastHBInfo->McastGroup
                    );

                ++pMcastHBInfo;
            }

            //
            // now run down the list of interfaces that we compiled and
            // send any unicast packets
            //

            pNodeHBInfo = InterfaceHeartBeatInfo;
            while ( InterfaceHBInfoCount-- ) {

                CnTrace(HBEAT_EVENT, HbTraceSendHB,
                    "[HB] Sending HB to node %u on net %u, seqno %u, ackno %u.",
                    pNodeHBInfo->NodeId, // LOGULONG
                    pNodeHBInfo->NetworkId, // LOGULONG
                    pNodeHBInfo->SeqNumber, // LOGULONG
                    pNodeHBInfo->AckNumber // LOGULONG
                );

                CxSendHeartBeatMessage(pNodeHBInfo->NodeId,
                                       pNodeHBInfo->SeqNumber,
                                       pNodeHBInfo->AckNumber,
                                       pNodeHBInfo->NetworkId);

                MEMLOG(
                    MemLogSendingHB, 
                    pNodeHBInfo->NodeId, 
                    pNodeHBInfo->NetworkId
                    );

                ++pNodeHBInfo;
            }

            //
            // finally, up the tick count, progressing to the next potential
            // work item
            //

            HeartBeatClockTicks++;

        } else if ( HeartBeatClockTicks >= ( HeartBeatSendTicks - 1 )) {

            //
            // walk the node table looking for lack of heart beats on
            // a node's set of interfaces.
            //
            CnpWalkNodeTable( CnpWalkNodesToCheckForHeartBeats, NULL );
            HeartBeatClockTicks = 0;

        } else {

            HeartBeatClockTicks++;
        }
    }

    // Check for clussvc hangs.
    CnpCheckClussvcHang();
    
    //
    // indicate that we're no longer running and if we're shutting down
    // then set the event that the shutdown thread is waiting on
    //

    CnAcquireLock( &HeartBeatLock, &OldIrql );
    HeartBeatDpcRunning = FALSE;

    if ( !HeartBeatEnabled ) {
        KeSetEvent( &HeartBeatDpcFinished, 0, FALSE );

        CnTrace(HBEAT_DETAIL, HbTraceSetDpcEvent2,
            "DPC: setting HeartBeatDpcFinished event (2)"
            );
                 
        MEMLOG( MemLogSetDpcEvent, 0, 0 );
    }

    CnReleaseLock( &HeartBeatLock, OldIrql );

} // CnpHeartBeatDpc

PCNP_INTERFACE
CnpFindInterfaceLocked(
    IN  PCNP_NODE Node,
    IN  PCNP_NETWORK Network
    )

/*++

Routine Description:

    Given node and network structure pointers, find the interface
    structure. Similar to CnpFindInterface except that we're passing
    in pointers instead of IDs.

Arguments:

    Node - pointer to node struct that sent the packet
    Network - pointer to Network struct on which packet was received

Return Value:

    Pointer to Interface on which packet was recv'd, otherwise NULL

--*/

{
    PLIST_ENTRY IfEntry;
    PCNP_INTERFACE Interface;

    CnVerifyCpuLockMask(CNP_NODE_OBJECT_LOCK,         // Required
                        0,                            // Forbidden
                        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
                        );

    for (IfEntry = Node->InterfaceList.Flink;
         IfEntry != &(Node->InterfaceList);
         IfEntry = IfEntry->Flink
         )
        {
            Interface = CONTAINING_RECORD(IfEntry,
                                          CNP_INTERFACE,
                                          NodeLinkage);

            if ( Interface->Network == Network ) {
                break;
            }
        }


    if ( IfEntry == &Node->InterfaceList ) {

        return NULL;
    } else {

        return Interface;
    }
} // CnpFindInterfaceLocked

VOID
CnpReceiveHeartBeatMessage(
    IN  PCNP_NETWORK Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber,
    IN  ULONG AckNumber,
    IN  BOOLEAN Multicast,
    IN  ULONG MulticastEpoch
    )

/*++

Routine Description:

    We received a heartbeat from a node on a network. Reset
    the missed HB count on that network's interface.


Arguments:

    Network - pointer to network block on which the packet was received

    SourceNodeId - node number that issued the packet

    SeqNumber - sending nodes' sequence num

    AckNumber - last seq number sent by us that was seen at the sending node
    
    Multicast - indicates whether this heartbeat was received in a multicast

    MulticastEpoch - indicates multicast epoch number from heartbeat packet

Return Value:

    None

--*/

{
    PCNP_NODE Node;
    PCNP_INTERFACE Interface;
    CX_OUTERSCREEN CurrentOuterscreen;


    //
    // Take a snapshot of the current outerscreen so that our
    // information doesn't change between decisions.
    //
    CurrentOuterscreen.UlongScreen = MMOuterscreen.UlongScreen;

    //
    // we ignore all packets until we're part of the cluster
    //
    if ( !CnpClusterScreenMember(
              CurrentOuterscreen.ClusterScreen,
              INT_NODE( CnLocalNodeId )
              )
       )
    {
        return;
    }

    //
    // We ignore multicast packets whose epoch is earlier than ours.
    // This prevents replay attacks, because the multicast key may
    // not have been regenerated since the last time a node joined (and
    // heartbeat sequence numbers were reset to one).
    //
    if (Multicast && MulticastEpoch < CxMulticastEpoch) {
        CnTrace(HBEAT_ERROR, HbTraceHBFromExpiredEpoch,
            "[HB] Discarding HB from old epoch. Source Node %u, "
            "Pkt Epoch %u, Current Epoch %u.",
            SourceNodeId, // LOGULONG
            MulticastEpoch, // LOGULONG
            CxMulticastEpoch // LOGULONG
            );
        return;
    }

    //
    // convert the Node ID into a pointer and find the interface
    // on which the packet was received.
    //
    Node = CnpFindNode( SourceNodeId );
    CnAssert( Node != NULL );

    Interface = CnpFindInterfaceLocked( Node, Network );

    if ( Interface == NULL ) {

        //
        // somehow this network object went away while we were
        // receiving some data on it. Just ignore this msg
        //

        CnTrace(HBEAT_ERROR, HbTraceHBFromUnknownNetwork,
            "[HB] Discarding HB from node %u on an unknown network.",
            Node->Id // LOGULONG
            );

        MEMLOG( MemLogNoNetID, Node->Id, (ULONG_PTR)Network );
        goto error_exit;
    }

    //
    // determine if this is guy is legit. If not in the outerscreen,
    // then send a poison packet and we're done
    //

    if ( !CnpClusterScreenMember(
              CurrentOuterscreen.ClusterScreen,
              INT_NODE( SourceNodeId )
              )
       )
    {
        //
        // Don't bother sending poison packets on restricted networks. They
        // will be ignored.
        //
        if (CnpIsNetworkRestricted(Interface->Network)) {
            goto error_exit;
        }

        CnTrace(HBEAT_ERROR, HbTraceHBFromBanishedNode,
            "[HB] Discarding HB from banished node %u on net %u "
            "due to outerscreen %04X. Sending poison packet back.",
            Node->Id, // LOGULONG
            Interface->Network->Id, // LOGULONG
            CurrentOuterscreen.UlongScreen // LOGULONG
            );

        CcmpSendPoisonPacket( Node, NULL, 0, Network, NULL);
        //
        // The node lock was released.
        //
        return;
    }

    //
    // Check that the incoming seq num is something we expect to
    // guard against replay attacks.
    //
    if ( SeqNumber <= Interface->LastSequenceReceived) {

        CnTrace( 
            HBEAT_ERROR, HbTraceHBOutOfSequence,
            "[HB] Discarding HB from node %u on net %u with stale seqno %u. "
            "Last seqno %u. Multicast: %!bool!.",
            Node->Id, // LOGULONG
            Interface->Network->Id, // LOGULONG
            SeqNumber, // LOGULONG
            Interface->LastSequenceReceived, // LOGULONG
            Multicast
            );

        MEMLOG( MemLogOutOfSequence, SourceNodeId, SeqNumber );

        goto error_exit;
    }

    // Update the interface's last received seq number
    // which will be sent back as the ack number.
    Interface->LastSequenceReceived = SeqNumber;

    //
    // Compare our seq number to the ack number in the packet.
    // If more than two off then the source node is not recv'ing
    // our heartbeats, but we're receiving theirs. This network is
    // not usable. We ignore this msg to guarantee that we will
    // declare the network down if the condition persists.
    //
    // In addition, if we are sending multicast heartbeats to this
    // interface, revert to unicasts in case there is a multicast
    // problem.
    //
    if (( Interface->SequenceToSend - AckNumber ) > 2 ) {

        CnTrace(HBEAT_ERROR, HbTraceHBWithStaleAck,
            "[HB] Discarding HB from node %u with stale ackno %u. "
            "My seqno %u. Multicast: %!bool!.",
            Node->Id, // LOGULONG
            AckNumber, // LOGULONG
            Interface->SequenceToSend, // LOGULONG
            Multicast
            );

        MEMLOG( MemLogSeqAckMismatch, (ULONG_PTR)Interface, Interface->State );

        if (CnpInterfaceQueryReceivedMulticast(Interface)) {
            CnpInterfaceClearReceivedMulticast(Interface);
            Interface->McastDiscoverCount = CNP_INTERFACE_MCAST_DISCOVERY;
            CnpMulticastChangeNodeReachability(
                Network,
                Node,
                FALSE,   // not reachable
                TRUE,    // raise event
                NULL     // OUT new mask
                );
        }

        goto error_exit;
    }

    MEMLOG4( MemLogReceivedPacket,
             SeqNumber, AckNumber,
             SourceNodeId, Interface->Network->Id );

    CnTrace(HBEAT_EVENT, HbTraceReceivedHBpacket,
        "[HB] Received HB from node %u on net %u, seqno %u, ackno %u, "
        "multicast: %!bool!.",
        SourceNodeId, // LOGULONG
        Interface->Network->Id, // LOGULONG
        SeqNumber, // LOGULONG
        AckNumber, // LOGULONG
        Multicast
        );

    // Reset the interface's and node's Missed HB count
    // to indicate that things are somewhat normal.
    //
    InterlockedExchange(&Interface->MissedHBs, 0);

    //
    // Don't reset node miss count on restricted nets.
    //
    if (!CnpIsNetworkRestricted(Interface->Network)) {
        InterlockedExchange(&Node->MissedHBs, 0);
    }

    //
    // if local interface was previously disconnected (e.g. received
    // a WMI NDIS status media disconnect event), reconnect it now.
    //
    if (CnpIsNetworkLocalDisconn(Interface->Network)) {
        CxReconnectLocalInterface(Interface->Network->Id);
    }

    //
    // move interface to online if necessary
    //
    if ( Interface->State == ClusnetInterfaceStateOnlinePending ||
         Interface->State == ClusnetInterfaceStateUnreachable ) {

        CnAcquireLockAtDpc( &Interface->Network->Lock );
        Interface->Network->Irql = DISPATCH_LEVEL;

        CnTrace(HBEAT_DETAIL, HbTraceInterfaceOnline,
            "[HB] Moving interface for node %u on network %u to online "
            "state.",
            Node->Id, // LOGULONG
            Interface->Network->Id // LOGULONG
            );

        //
        // Initiate multicast discovery.
        //
        Interface->McastDiscoverCount = CNP_INTERFACE_MCAST_DISCOVERY;
        Interface->McastRediscoveryCountdown = 0;

        MEMLOG( MemLogOnlineIf, Node->Id, Interface->State );

        CnpOnlineInterface( Interface );
    
        CnTrace(HBEAT_EVENT, HbTraceInterfaceUpEvent,
            "[HB] Issuing InterfaceUp event for node %u on network %u.",
            Node->Id, // LOGULONG
            Interface->Network->Id // LOGULONG
            );                

        CnIssueEvent(ClusnetEventNetInterfaceUp,
                     Node->Id,
                     Interface->Network->Id);
    }

    //
    // Indicate that a multicast has been received from this interface.
    // This allows us to include this interface in our multicasts.
    //
    if (Multicast) {
        IF_CNDBG(CN_DEBUG_HBEATS) {
            CNPRINT(("[HB] Received multicast heartbeat on "
                     "network %d from source node %d, seq %d, "
                     "ack %d.\n",
                     Network->Id, SourceNodeId,
                     SeqNumber, AckNumber
                     ));
        }

        if (!CnpInterfaceQueryReceivedMulticast(Interface)) {
            
            CnpInterfaceSetReceivedMulticast(Interface);
            
            CnpMulticastChangeNodeReachability(
                Network,
                Node,
                TRUE,    // reachable
                TRUE,    // raise event
                NULL     // OUT new mask
                );
        }

        // There is no point in sending discovery packets to this
        // interface.
        Interface->McastDiscoverCount = 0;
        Interface->McastRediscoveryCountdown = 0;

        // If the source node's multicast epoch is greater than
        // ours, update. We can make the initial comparison without
        // acquiring the lock.
        if (MulticastEpoch > CxMulticastEpoch) {
            CnpUpdateMulticastEpoch(MulticastEpoch);
        }
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    //
    // when the first HB is recv'ed, a node may be in either the
    // join or alive state (the sponser, for instance, moves from
    // dead to alive). We need to clear the Node down issued flag
    // for either case. If the MM State is joining, then a node up
    // event must be issued as well. Note that we ignore HBs for
    // node health purposes on restricted nets.
    //

    if ( ( (Node->MMState == ClusnetNodeStateJoining)
           ||
           (Node->MMState == ClusnetNodeStateAlive)
         )
         &&
         Node->NodeDownIssued
         &&
         !CnpIsNetworkRestricted(Interface->Network)
       )
    {

        Node->NodeDownIssued = FALSE;
        MEMLOG( MemLogNodeDownIssued, Node->Id, FALSE );

        if ( Node->MMState == ClusnetNodeStateJoining ) {

            CnTrace(HBEAT_EVENT, HbTraceNodeUpEvent,
                "[HB] Issuing NodeUp event for node %u.",
                Node->Id // LOGULONG
                );   
            
            MEMLOG( MemLogNodeUp, Node->Id, 0 );

            CnIssueEvent( ClusnetEventNodeUp, Node->Id, 0 );
        }
    }

    return;

error_exit:

    CnReleaseLock( &Node->Lock, Node->Irql );
    return;

} // CnpReceiveHeartBeatMessage

NTSTATUS
CxSetOuterscreen(
    IN  ULONG Outerscreen
    )
{
    //
    // based on the number of valid nodes, make sure any extranious
    // bits are not set
    //

    CnAssert( ClusterDefaultMaxNodes <= 32 );
    CnAssert(
        ( Outerscreen & ( 0xFFFFFFFE << ( 32 - ClusterDefaultMaxNodes - 1 )))
        == 0);

    IF_CNDBG( CN_DEBUG_HBEATS )
        CNPRINT(("[CCMP] Setting outerscreen to %04X\n",
                 ((Outerscreen & 0xFF)<< 8) | ((Outerscreen >> 8) & 0xFF)));

    MMOuterscreen.UlongScreen = Outerscreen;

    CnTrace(HBEAT_EVENT, HbTraceSetOuterscreen,
        "[HB] Setting outerscreen to %04X",
        Outerscreen // LOGULONG
        );

    MEMLOG( MemLogOuterscreen, Outerscreen, 0 );

    return STATUS_SUCCESS;
} // CxSetOuterscreen

VOID
CnpTerminateClusterService(
    IN PVOID Parameter
    )
{
    PWORK_QUEUE_ITEM workQueueItem = Parameter;
    ULONG sourceNodeId = *((PULONG)(workQueueItem + 1));
    WCHAR sourceNodeStringId[ 16 ];

    swprintf(sourceNodeStringId, L"%u", sourceNodeId );

    //
    // only way we can get here right now is if a poison packet was received.
    //
    CnWriteErrorLogEntry(CLNET_NODE_POISONED,
                         STATUS_SUCCESS,
                         NULL,
                         0,
                         1,
                         sourceNodeStringId );

    if ( ClussvcProcessHandle ) {

        //
        // there is still a race condition between the cluster service shutting
        // down and closing this handle and it being used here. This really
        // isn't a problem since the user mode portion is going away anyway.
        // Besides, there isn't alot we can do if this call doesn't work anyway.
        //

        ZwTerminateProcess( ClussvcProcessHandle, STATUS_CLUSTER_POISONED );
    }

    CnFreePool( Parameter );
} // CnpTerminateClusterService

VOID
CnpReceivePoisonPacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber
    )
{
    PCNP_NODE Node;
    PCNP_INTERFACE Interface;
    PWORK_QUEUE_ITEM WorkItem;

    
    //
    // give the node and the network pointers, find the interface on which
    // this packet was received
    //

    Node = CnpFindNode( SourceNodeId );
    
    if ( Node == NULL ) {
        CnTrace(HBEAT_ERROR, HbTraceNoPoisonFromUnknownNode,
            "[HB] Discarding poison packet from unknown node %u.",
            SourceNodeId // LOGULONG
        );
        return;
    }

    Interface = CnpFindInterfaceLocked( Node, Network );

    if ( Interface == NULL ) {

        //
        // somehow this network object went away while we were
        // receiving some data on it. Just ignore this msg
        //
        CnTrace(HBEAT_ERROR, HbTracePoisonFromUnknownNetwork,
            "[HB] Discarding poison packet from node %u on unknown network.",
            Node->Id // LOGULONG
            );

        MEMLOG( MemLogNoNetID, Node->Id, (ULONG_PTR)Network );

        CnReleaseLock( &Node->Lock, Node->Irql );
        return;
    }

    //
    // Check that the incoming seq num is something we expect to
    // guard against replay attacks.
    //

    if ( SeqNumber <= Interface->LastSequenceReceived) {

        CnTrace(HBEAT_ERROR , HbTracePoisonOutOfSeq,
            "[HB] Discarding poison packet from node %u with stale seqno %u. "
            "Current seqno %u.",
            SourceNodeId, // LOGULONG
            SeqNumber, // LOGULONG
            Interface->LastSequenceReceived // LOGULONG
            );

        MEMLOG( MemLogOutOfSequence, SourceNodeId, SeqNumber );

        CnReleaseLock( &Node->Lock, Node->Irql );
        return;
    }

    //
    // Ignore poison packets from restricted networks
    //
    if (CnpIsNetworkRestricted(Network)) {

        CnTrace(HBEAT_ERROR , HbTracePoisonFromRestrictedNet,
            "[HB] Discarding poison packet from node %u on restricted "
            "network %u.",
            SourceNodeId, // LOGULONG
            Network->Id // LOGULONG
            );

        CnReleaseLock( &Node->Lock, Node->Irql );
        return;
    }

    //
    // We always honor a recv'ed poison packet.
    //

    CnReleaseLock( &Node->Lock, Node->Irql );

    CnTrace(HBEAT_EVENT, HbTracePoisonPktReceived,
        "[HB] Received poison packet from node %u. Halting this node.",
        SourceNodeId // LOGULONG
        );            

    MEMLOG( MemLogPoisonPktReceived, SourceNodeId, 0 );

    CnIssueEvent( ClusnetEventPoisonPacketReceived, SourceNodeId, 0 );

    //
    // Shutdown all cluster network processing.
    //
    CnHaltOperation(NULL);

    //
    // allocate a work queue item so we can whack the cluster service
    // process. allocate extra space at the end and stuff the source node ID
    // out there. Yes, I know it is groady...
    //

    WorkItem = CnAllocatePool( sizeof( WORK_QUEUE_ITEM ) + sizeof( CL_NODE_ID ));
    if ( WorkItem != NULL ) {

        *((PULONG)(WorkItem + 1)) = SourceNodeId;
        ExInitializeWorkItem( WorkItem, CnpTerminateClusterService, WorkItem );
        ExQueueWorkItem( WorkItem, CriticalWorkQueue );
    }
    
    return;

} // CnpReceivePoisonPacket

VOID
CnpLogClussvcHangAndTerminate(    
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++

Routine Description:

    This routine logs an entry into system event log about clussvc hang, and terminates the
    clussvc process.

Arguments:

    None

Return Value:

    None

--*/
    
{
    WCHAR myStr[40];

    swprintf(myStr, L"%u", ((ClussvcClusnetHbTimeoutTicks * HEART_BEAT_PERIOD)/1000));

    CnWriteErrorLogEntry(
        CLNET_CLUSSVC_HUNG_TERMINATE,
        STATUS_SUCCESS,
        NULL,
        0,
        1,
        myStr
        );

    if (ClussvcProcessHandle) {
        ZwTerminateProcess(ClussvcProcessHandle, STATUS_CLUSTER_NODE_DOWN); 
    }
    IoFreeWorkItem((PIO_WORKITEM)Context);
}//CnpLogClussvcHangAndTerminate

VOID
CnpLogClussvcHang(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++

Routine Description:

    This routine logs an entry into system event log about clussvc hang.

Arguments:

    None

Return Value:

    None

--*/
    
{
    WCHAR myStr[40];

    swprintf(myStr, L"%u", ((ClussvcClusnetHbTimeoutTicks * HEART_BEAT_PERIOD)/1000));

    CnWriteErrorLogEntry(
        CLNET_CLUSSVC_HUNG,
        STATUS_SUCCESS,
        NULL,
        0,
        1,
        myStr
        );

    IoFreeWorkItem((PIO_WORKITEM)Context);
}//CnpLogClussvcHang
    
VOID
CnpCheckClussvcHang(
    VOID
    )
/*++

Routine Description:

    Check for HB ticks from Clussvc, if not disabled, and Tick count has reached max
    then take appropriate action depending on the configured value.

Arguments:

    None

Return Value:

    None

--*/
    
{

    ULONG newValue;
    
    // Check if heartbeating is disabled, then return.
    if((ClussvcClusnetHbTickCount == 0) || 
        (ClussvcClusnetHbTimeoutAction == ClussvcHangActionDisable)) {
        return;
    }

    // Decrement the counter by 1.
    newValue = InterlockedDecrement(&ClussvcClusnetHbTickCount);

    // If this is 1->0 transition we need to do something.
    if(newValue != 0)
        return;

    CnTrace(HBEAT_ERROR , HbTraceClussvcHang,
            "[HB] Clussvc to Clusnet HB Timeout, Timeout=%u DPC ticks, Action=%u.",
            ClussvcClusnetHbTimeoutTicks,
            ClussvcClusnetHbTimeoutAction
            );

    IF_CNDBG( CN_DEBUG_HBEATS ) {
        CNPRINT((
            "[HB] Clussvc to Clusnet HB Timeout, Timeout=%u DPC ticks, Action=%u\n",
            ClussvcClusnetHbTimeoutTicks,
            (ULONG)ClussvcClusnetHbTimeoutAction
            ));
    }

    CnAssert(ClussvcClusnetHbTimeoutAction< ClussvcHangActionMax);
    
    switch(ClussvcClusnetHbTimeoutAction) {

        case ClussvcHangActionLog:
            // Just log a message and reset ClussvcClusnetHbTickCount to ClussvcClusnetHbTimeoutTicks
            // Use DelayedWorkQueue
            {
                PIO_WORKITEM WorkItem;    

                WorkItem = IoAllocateWorkItem(CnDeviceObject);
                if ( WorkItem != NULL ) {
                    IoQueueWorkItem(
                        WorkItem,
                        CnpLogClussvcHang,
                        DelayedWorkQueue,
                        (PVOID)WorkItem
                        );
                }
                InterlockedExchange(&ClussvcClusnetHbTickCount, ClussvcClusnetHbTimeoutTicks);
            }
            break;

        case ClussvcHangActionBugCheckMachine:
            // Bugcheck the machine.
            {
                KeBugCheckEx(
                    USER_MODE_HEALTH_MONITOR,
                    (ULONG_PTR)((ClussvcProcessHandle != NULL) ? ClussvcProcessObject : NULL),
                    (ULONG_PTR)(ClussvcClusnetHbTimeoutSeconds),
                    0,
                    0
                    );
            }
            break;

        case ClussvcHangActionTerminateService:
        default:    
            // Terminate Cluster Service. Handling is similar to the case as if clusnet has
            // received a poison packet. Using Critical work queue.
            {
                KIRQL        irql;

                // If we have already run through this terminate path,
                // then we do not do it again. The workitem will already
                // be on the critical work queue (even if it has not yet
                // executed).
                CnAcquireLock(&HeartBeatLock, &irql);

                if (ClussvcTerminateWorkItem != NULL) {

                    PIO_WORKITEM WorkItem;

                    // Swap out the workitem.
                    WorkItem = ClussvcTerminateWorkItem;
                    ClussvcTerminateWorkItem = NULL;

                    // Stop outgoing heartbeats.
                    ClussvcTerminateStopHbs = TRUE;
                    
                    CnReleaseLock(&HeartBeatLock, irql);

                    // Issue halt event so clusdisk stops reservations.
                    CnIssueEvent(ClusnetEventHalt, 0, 0);

                    // Stop normal clusnet activity.
                    CnHaltOperation(NULL);

                    // Queue the critical workitem to terminate the
                    // service process.
                    IoQueueWorkItem(
                        WorkItem,
                        CnpLogClussvcHangAndTerminate,
                        CriticalWorkQueue,
                        (PVOID)WorkItem
                        );

                 } else {
                    CnReleaseLock(&HeartBeatLock, irql);
                }
            }
            break;
    }    
}//CnpCheckClussvcHang

VOID
CnpWalkInterfacesAfterRegroup(
    IN  PCNP_INTERFACE   Interface
    )

/*++

Routine Description:

    Reset counters for each interface after a regroup

Arguments:

    None

Return Value:

    None

--*/

{
    InterlockedExchange(&Interface->MissedHBs, 0);
    CnReleaseLock(&Interface->Network->Lock, Interface->Network->Irql);

} // CnpWalkInterfacesAfterRegroup

BOOLEAN
CnpWalkNodesAfterRegroup(
    IN  PCNP_NODE   Node,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    )

/*++

Routine Description:

    Called for each node in the node table. Regroup has finished
    so we clear the node's missed Heart beat count and its node down
    issued flag. No node should be unreachable at this point. If we
    find one, kick off another regroup.

Arguments:

    standard...

Return Value:

    None

--*/

{
    //
    // check for inconsistent settings of Comm and MM state
    //
    if ( ( Node->MMState == ClusnetNodeStateAlive
           ||
           Node->MMState == ClusnetNodeStateJoining
         )
         &&
         Node->CommState == ClusnetNodeCommStateUnreachable
       )
    {

        CnTrace(HBEAT_EVENT, HbTraceNodeDownEvent2,
            "[HB] Issuing NodeDown event for node %u.",
            Node->Id // LOGULONG
            );
    
        MEMLOG( MemLogInconsistentStates, Node->Id, Node->MMState );
        CnIssueEvent( ClusnetEventNodeDown, Node->Id, 0 );
    }

    CnpWalkInterfacesOnNode( Node, (PVOID)CnpWalkInterfacesAfterRegroup );

    InterlockedExchange(&Node->MissedHBs, 0);

    //
    // clear this only for nodes in the alive state. Once a node is marked
    // dead, the flag is re-init'ed to true (this is used during a join to
    // issue only one node up event).
    //

    if ( Node->MMState == ClusnetNodeStateAlive ) {

        Node->NodeDownIssued = FALSE;
        MEMLOG( MemLogNodeDownIssued, Node->Id, FALSE );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    return TRUE;       // the node table lock is still held

} // CnpWalkNodesAfterRegroup


VOID
CxRegroupFinished(
    ULONG NewEventEpoch,
    ULONG NewRegroupEpoch
    )

/*++

Routine Description:

    called when regroup has finished. Walk the node list and
    perform the cleanup in the walk routine.

Arguments:

    None

Return Value:

    None

--*/

{
    MEMLOG( MemLogRegroupFinished, NewEventEpoch, 0 );

    CnTrace(HBEAT_EVENT, HbTraceRegroupFinished,
        "[HB] Regroup finished, new event epoch = %u, "
        "new regroup epoch = %u.",
        NewEventEpoch, // LOGULONG
        NewRegroupEpoch // LOGULONG
        );

    CnAssert( NewEventEpoch >= EventEpoch );
    EventEpoch = NewEventEpoch;

    if (NewRegroupEpoch > CxMulticastEpoch) {
        CnpUpdateMulticastEpoch(NewRegroupEpoch);
    }

    CnpWalkNodeTable( CnpWalkNodesAfterRegroup, NULL );
} // CxRegroupFinished


VOID
CnpUpdateMulticastEpoch(
    ULONG NewEpoch
    )
/*++

Routine Description:

    The Multicast Epoch must be monotonically increasing
    and agreed upon by all nodes. It is based on the
    regroup epoch (not to be confused with the ClusNet
    event epoch, which is local to each node).
    
    It is conceivable for a stale regroup epoch update
    to occur; thus, only update if the new value is 
    greater than the current value.

Arguments:

    NewEpoch - new epoch number

Return value:

    None

--*/
{
    KIRQL irql;

    CnAcquireLock(&HeartBeatLock, &irql);

    if (NewEpoch > CxMulticastEpoch) {

        CnTrace(HBEAT_EVENT, HbTraceUpdateMulticastEpoch,
            "[HB] Updating multicast epoch from %u to %u.",
            CxMulticastEpoch, NewEpoch
            );

        CxMulticastEpoch = NewEpoch;
    }

    CnReleaseLock(&HeartBeatLock, irql);
    
} // CnpUpdateMulticastEpoch

/* end chbeat.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cdprecv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdpsend.c

Abstract:

    TDI Receive datagram routines.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cdprecv.tmh"

#include <sspi.h>

#ifdef ALLOC_PRAGMA


#endif // ALLOC_PRAGMA

//
// Local types
//
typedef struct {
    CL_NODE_ID   SourceNodeId;
    USHORT       SourcePort;
    ULONG        TdiReceiveDatagramFlags;
    ULONG        TsduSize;
    PCX_ADDROBJ  AddrObj;
    PCNP_NETWORK Network;
} CDP_RECEIVE_CONTEXT, *PCDP_RECEIVE_CONTEXT;


//
// Local Data
//
PCN_RESOURCE_POOL  CdpReceiveRequestPool = NULL;

#define CDP_RECEIVE_REQUEST_POOL_DEPTH 2

//
// Local utility routines
//
VOID
CdpIndicateReceivePacket(
    IN  PCX_ADDROBJ  AddrObj,
    IN  CL_NODE_ID   SourceNodeId,
    IN  USHORT       SourcePort,
    IN  ULONG        TdiReceiveDatagramFlags,
    IN  ULONG        TsduSize,
    IN  PVOID        Tsdu,
    IN  BOOLEAN      DataVerified
    )
/*++

Notes:

    Called with address object lock held.
    Returns with address object lock released.

--*/
{
    NTSTATUS                   status;
    PTDI_IND_RECEIVE_DATAGRAM  handler = AddrObj->ReceiveDatagramHandler;
    PVOID                      context = AddrObj->ReceiveDatagramContext;
    TA_CLUSTER_ADDRESS         sourceTransportAddress;
    PIRP                       irp = NULL;
    ULONG                      bytesTaken = 0;


    CnVerifyCpuLockMask(
        CX_ADDROBJ_LOCK,      // Required
        0,                    // Forbidden
        CX_ADDROBJ_LOCK_MAX   // Maximum
        );

    CnAssert(handler != NULL);

    CnReleaseLock(&(AddrObj->Lock), AddrObj->Irql);

    //
    // Build the source address buffer
    //
    CxBuildTdiAddress(
        &sourceTransportAddress,
        SourceNodeId,
        SourcePort,
        DataVerified
        );

    CnTrace(CDP_RECV_DETAIL, CdpTraceIndicateReceive,
        "[CDP] Indicating dgram, src: node %u port %u, dst: port %u, "
        "data len %u",
        SourceNodeId, // LOGULONG
        SourcePort, // LOGUSHORT
        AddrObj->LocalPort, // LOGUSHORT
        TsduSize // LOGULONG
        );

    //
    // Call the upper layer indication handler.
    //
    status = (*handler)(
                 context,
                 sizeof(TA_CLUSTER_ADDRESS),
                 &sourceTransportAddress,
                 0, // no options
                 NULL,
                 TdiReceiveDatagramFlags,
                 TsduSize,
                 TsduSize,
                 &bytesTaken,
                 Tsdu,
                 &irp
                 );

    CnAssert(status != STATUS_MORE_PROCESSING_REQUIRED);
    CnAssert(bytesTaken == TsduSize);
    CnAssert(irp == NULL);

    if (irp != NULL) {
        irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
    }

    //
    // Dereference the address object
    //
    CnDereferenceFsContext(&(AddrObj->FsContext));

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return;

}  // CdpIndicateReceivePacket


NTSTATUS
CdpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    NTSTATUS              status;
    PCNP_RECEIVE_REQUEST  request = Context;
    PCDP_RECEIVE_CONTEXT  context = request->UpperProtocolContext;
    PCX_ADDROBJ           addrObj = context->AddrObj;
    ULONG                 consumed;
    PVOID                 data;
    ULONG                 dataLength;
    BOOLEAN               fscontextDereferenced = FALSE;


    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        CnAssert(Irp->IoStatus.Information == context->TsduSize);

        data = request->DataBuffer;
        dataLength = (ULONG)Irp->IoStatus.Information;

        CnAcquireLock(&(addrObj->Lock), &(addrObj->Irql));

        if (addrObj->ReceiveDatagramHandler != NULL) {
            CdpIndicateReceivePacket(
                addrObj,
                context->SourceNodeId,
                context->SourcePort,
                context->TdiReceiveDatagramFlags,
                dataLength,
                data,
                FALSE   // not verified
                );
            fscontextDereferenced = TRUE;
        }
        else {
            CnReleaseLock(&(addrObj->Lock), addrObj->Irql);
        }
    }
    else {
        CnTrace(CDP_RECV_ERROR, CdpTraceCompleteReceiveFailed,
            "[CDP] Failed to fetch dgram data, src: node %u port %u, "
            "dst: port %u, status %!status!",
            context->SourceNodeId, // LOGULONG
            context->SourcePort, // LOGUSHORT
            addrObj->LocalPort, // LOGUSHORT
            Irp->IoStatus.Status // LOGSTATUS
            );
    }

    //
    // Drop the active reference on the network.
    //
    if (context->Network != NULL) {
        CnAcquireLock(&(context->Network->Lock), &(context->Network->Irql));
        CnpActiveDereferenceNetwork(context->Network);
        context->Network = NULL;
    }

    //
    // Dereference the addr object fscontext (only necessary
    // after error condition).
    //
    if (!fscontextDereferenced) {
        CnDereferenceFsContext(&(addrObj->FsContext));
    }

    CnpFreeReceiveRequest(request);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // CdpCompleteReceivePacket


//
// Routines exported within the Cluster Transport
//
NTSTATUS
CdpInitializeReceive(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Initializing receive...\n"));
    }

    CdpReceiveRequestPool = CnpCreateReceiveRequestPool(
                                sizeof(CDP_RECEIVE_CONTEXT),
                                CDP_RECEIVE_REQUEST_POOL_DEPTH
                                );

    if (CdpReceiveRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Receive initialized.\n"));
    }

    return(STATUS_SUCCESS);

}  // CdpInitializeReceive


VOID
CdpCleanupReceive(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Cleaning up receive...\n"));
    }

    if (CdpReceiveRequestPool != NULL) {
        CnpDeleteReceiveRequestPool(CdpReceiveRequestPool);
        CdpReceiveRequestPool = NULL;
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Receive cleanup complete.\n"));
    }

    return;

}  // CdpCleanupReceive


NTSTATUS
CdpReceivePacketHandler(
    IN  PVOID          Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
{
    NTSTATUS                   status;
    CDP_HEADER UNALIGNED *     header = Tsdu;
    PCX_ADDROBJ                addrObj;
    ULONG                      bytesTaken = 0;
    PCNP_RECEIVE_REQUEST       request;
    USHORT                     srcPort = 0;
    USHORT                     destPort = 0;
    ULONG                      consumed = 0;


    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (BytesIndicated >= sizeof(CDP_HEADER))
    {
        destPort = header->DestinationPort;
        srcPort =  header->SourcePort;

        //
        // Consume the CDP header
        //
        consumed = sizeof(CDP_HEADER);

        //
        // Verify that the remaining packet is consistent.
        //
        if (header->PayloadLength != (BytesAvailable - consumed)) {
            goto error_exit;
        }

        BytesIndicated -= consumed;
        BytesAvailable -= consumed;
        *BytesTaken += consumed;
        Tsdu = (PUCHAR)Tsdu + consumed;

        CnAcquireLockAtDpc(&CxAddrObjTableLock);

        addrObj = CxFindAddressObject(destPort);

        if (addrObj != NULL) {

            CnReleaseLockFromDpc(&CxAddrObjTableLock);

            if ( ( !(addrObj->Flags & CX_AO_FLAG_CHECKSTATE)
                   ||
                   (CnpReceiveFlags & CNP_RECV_FLAG_NODE_STATE_CHECK_PASSED)
                 )
                 &&
                 (addrObj->ReceiveDatagramHandler != NULL)
               )
            {
                //
                // Reference the address object so it can't go away during
                // the indication.
                //
                CnReferenceFsContext(&(addrObj->FsContext));

                if (BytesAvailable == BytesIndicated) {

                    CdpIndicateReceivePacket(
                        addrObj,
                        SourceNodeId,
                        srcPort,
                        TdiReceiveDatagramFlags,
                        BytesAvailable,
                        ((BytesAvailable > 0) ? Tsdu : NULL),
                        (BOOLEAN)(
                            CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED
                        )
                        );

                    //
                    // The addrObj lock was released.
                    //

                    *BytesTaken += BytesAvailable;
                    *Irp = NULL;

                    CnVerifyCpuLockMask(
                        0,                // Required
                        0xFFFFFFFF,       // Forbidden
                        0                 // Maximum
                        );

                    return(STATUS_SUCCESS);
                }

                CnReleaseLockFromDpc(&(addrObj->Lock));

                //
                // This message cannot be a CNP multicast, and it
                // cannot have been verified, because the CNP layer
                // could not have verified an incomplete message.
                //
                CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST));
                CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED));

                //
                // We need to fetch the rest of the packet before we
                // can indicate it to the upper layer.
                //
                request = CnpAllocateReceiveRequest(
                              CdpReceiveRequestPool,
                              Network,
                              BytesAvailable,
                              CdpCompleteReceivePacket
                              );

                if (request != NULL) {

                    PCDP_RECEIVE_CONTEXT  context;
                    PCNP_NETWORK          network = (PCNP_NETWORK)Network;
                    ULONG                 refCount;

                    context = request->UpperProtocolContext;

                    context->SourceNodeId = SourceNodeId;
                    context->SourcePort = header->SourcePort;
                    context->TdiReceiveDatagramFlags = TdiReceiveDatagramFlags;
                    context->TsduSize = BytesAvailable;
                    context->AddrObj = addrObj;
                    context->Network = Network;

                    //
                    // Take a reference on the network so that it
                    // doesn't disappear before the IRP completes.
                    //
                    CnAcquireLock(&(network->Lock), &(network->Irql));
                    refCount = CnpActiveReferenceNetwork(Network);
                    CnReleaseLock(&(network->Lock), network->Irql);

                    if (refCount == 0) {
                        // This Network is being closed down. We
                        // cannot retrieve or deliver the data. Drop
                        // the packet.
                        CnpFreeReceiveRequest(request);
                        goto error_exit;
                    }

                    *Irp = request->Irp;

                    CnTrace(CDP_RECV_DETAIL, CdpTraceCompleteReceive,
                        "[CDP] Fetching dgram data, src: node %u port %u, "
                        "dst: port %u, BI %u, BA %u, CNP Flags %x.",
                        SourceNodeId, // LOGULONG
                        srcPort, // LOGUSHORT
                        destPort, // LOGUSHORT
                        BytesIndicated, // LOGULONG
                        BytesAvailable, // LOGULONG
                        CnpReceiveFlags // LOGXLONG
                        );

                    CnVerifyCpuLockMask(
                        0,                // Required
                        0xFFFFFFFF,       // Forbidden
                        0                 // Maximum
                        );

                    return(STATUS_MORE_PROCESSING_REQUIRED);

                }

                CnTrace(
                    CDP_RECV_ERROR, CdpTraceDropReceiveNoIrp,
                    "[CDP] Dropping dgram: failed to allocate "
                    "receive request."
                    );

                //
                // Out of resources. Drop the packet.
                //
            }
            else {
                //
                // No receive handler or node state check failed.
                //
                CnReleaseLockFromDpc(&(addrObj->Lock));

                CnTrace(
                    CDP_RECV_ERROR, CdpTraceDropReceiveState,
                    "[CDP] Dropping dgram: addr obj flags %x, "
                    "CNP flags %x, dgram recv handler %p.",
                    addrObj->Flags,
                    CnpReceiveFlags,
                    addrObj->ReceiveDatagramHandler
                    );
            }
        }
        else {
            CnReleaseLockFromDpc(&CxAddrObjTableLock);

            CnTrace(
                CDP_RECV_ERROR, CdpTraceDropReceiveNoAO,
                "[CDP] Dropping dgram: no clusnet addr obj found "
                "for dest port %u.",
                destPort
                );
        }
    }

error_exit:

    //
    // Something went wrong. Drop the packet by
    // indicating that we consumed it.
    //
    *BytesTaken += BytesAvailable;
    *Irp = NULL;

    CnTrace(CDP_RECV_ERROR, CdpTraceDropReceive,
        "[CDP] Dropped dgram, src: node %u port %u, dst: port %u, "
        "BI %u, BA %u, CNP flags %x.",
        SourceNodeId, // LOGULONG
        srcPort, // LOGUSHORT
        destPort, // LOGUSHORT
        BytesIndicated, // LOGULONG
        BytesAvailable, // LOGULONG
        CnpReceiveFlags // LOGXLONG
        );

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CdpReceivePacketHandler


//
// Routines exported within the Cluster Network driver
//
NTSTATUS
CxReceiveDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;


    CNPRINT(("[Clusnet] CxReceiveDatagram called!\n"));

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);

}  // CxReceiveDatagram
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnpmisc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnpmisc.c

Abstract:

    Miscellaneous routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpmisc.tmh"

#include <tdiinfo.h>
#include <tcpinfo.h>
#include <fipsapi.h>
#include <sspi.h>


//
// Salt generation
//
ULONGLONG                CnpSaltBase = 0;
#define                  CNP_SALTBASE_MULTIPLIER 31

//
// Local function prototypes
//
NTSTATUS
CnpRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );


#ifdef ALLOC_PRAGMA

//
// All of this code is pageable.
//
#pragma alloc_text(PAGE, CnpTdiSetEventHandler)
#pragma alloc_text(PAGE, CnpIssueDeviceControl)
#pragma alloc_text(PAGE, CnpOpenDevice)
#pragma alloc_text(PAGE, CnpZwDeviceControl)
#pragma alloc_text(PAGE, CnpSetTcpInfoEx)
#pragma alloc_text(PAGE, CnpInitializeSaltGenerator)

#endif // ALLOC_PRAGMA


 
NTSTATUS
CnpRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PBOOLEAN reuseIrp = (PBOOLEAN) Context;

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    //
    // Mark the IRP pending, if necessary.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // If we are reusing a client IRP, tell the I/O manager not to 
    // halt I/O completion processing immediately.
    //
    if (*reuseIrp) {
        if (Irp->UserIosb != NULL) {
            *(Irp->UserIosb) = Irp->IoStatus;
        }
        if (Irp->UserEvent != NULL) {
            KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);
        }
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        return STATUS_SUCCESS;
    }

} // CnpRestartDeviceControl




NTSTATUS
CnpIssueDeviceControl (
    IN PFILE_OBJECT     FileObject,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            IrpParameters,
    IN ULONG            IrpParametersLength,
    IN PVOID            MdlBuffer,
    IN ULONG            MdlBufferLength,
    IN UCHAR            MinorFunction,
    IN PIRP             ClientIrp            OPTIONAL
    )

/*++

Routine Description:

    Issues a device control request to a TDI provider and waits for the
    request to complete.

Arguments:

    FileObject - a pointer to the file object corresponding to a TDI
        handle

    DeviceObject - a pointer to the device object corresponding to the
        FileObject.

    IrpParameters - information to write to the parameters section of the
        stack location of the IRP.

    IrpParametersLength - length of the parameter information.  Cannot be
        greater than 16.

    MdlBuffer - if non-NULL, a buffer of nonpaged pool to be mapped
        into an MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - the size of the buffer pointed to by MdlBuffer.

    MinorFunction - the minor function code for the request.
    
    ClientIrp - client IRP that may be reusable for this ioctl

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    PIRP                 irp;
    PIO_STACK_LOCATION   irpSp;
    KEVENT               event;
    IO_STATUS_BLOCK      ioStatusBlock;
    PDEVICE_OBJECT       deviceObject;
    PMDL                 mdl;
    KPROCESSOR_MODE      clientRequestorMode;
    PKEVENT              clientUserEvent;
    PIO_STATUS_BLOCK     clientIosb;
    PMDL                 clientMdl;
    BOOLEAN              reuseIrp = FALSE;


    PAGED_CODE( );

    //
    // Initialize the kernel event that will signal I/O completion.
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // If there is a ClientIrp available, check if it has sufficient
    // stack locations.
    //
    if (ClientIrp != NULL 
        && CnpIsIrpStackSufficient(ClientIrp, DeviceObject)) {

        //
        // Reuse the client IRP rather than allocating a new one.
        //
        reuseIrp = TRUE;
        irp = ClientIrp;

        //
        // Save state from client IRP
        //
        clientRequestorMode = irp->RequestorMode;
        clientUserEvent = irp->UserEvent;
        clientIosb = irp->UserIosb;
        clientMdl = irp->MdlAddress;

    } else {

        //
        // Reference the passed in file object. This is necessary because
        // the IO completion routine dereferences it.
        //
        ObReferenceObject( FileObject );

        //
        // Set the file object event to a non-signaled state.
        //
        (VOID) KeResetEvent( &FileObject->Event );

        //
        // Attempt to allocate and initialize the I/O Request Packet (IRP)
        // for this operation.
        //
        irp = IoAllocateIrp( (DeviceObject)->StackSize, TRUE );

        if ( irp == NULL ) {
            ObDereferenceObject( FileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
        irp->PendingReturned = FALSE;

        irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->UserBuffer = NULL;

        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = FileObject;
        irp->Tail.Overlay.AuxiliaryBuffer = NULL;

        //
        // Queue the IRP to the thread.
        //
        IoEnqueueIrp( irp );
    }

    //
    // If an MDL buffer was specified, get an MDL, map the buffer,
    // and place the MDL pointer in the IRP.
    //

    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            if (!reuseIrp) {
                IoFreeIrp( irp );
                ObDereferenceObject( FileObject );
            } else {
                irp->MdlAddress = clientMdl;
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        irp->MdlAddress = NULL;
    }

    irp->RequestorMode = KernelMode;
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = &event;

    //
    // Put the file object pointer in the stack location.
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = DeviceObject;

    //
    // Fill in the service-dependent parameters for the request.
    //
    CnAssert( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    //
    // Set up a completion routine which we'll use to free the MDL
    // allocated previously.
    //
    IoSetCompletionRoutine(
        irp,
        CnpRestartDeviceControl,
        (PVOID) &reuseIrp,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver( DeviceObject, irp );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            (PVOID)&event,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    //
    // Before returning, restore the client IRP
    //
    if (reuseIrp) {
        irp->RequestorMode = clientRequestorMode;
        irp->UserIosb = clientIosb;
        irp->UserEvent = clientUserEvent;
        irp->MdlAddress = clientMdl;
    }

    return status;

} // CnpIssueDeviceControl



NTSTATUS
CnpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext,
    IN PIRP            ClientIrp     OPTIONAL
    )
/*++

Routine Description:

    Sets up a TDI indication handler on a connection or address object
    (depending on the file handle).  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    DeviceObject - a pointer to the device object associated with the
        file object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.
    
    ClientIrp - client IRP that may be passed to CnpIssueDeviceControl
        for reuse    

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT  parameters;
    NTSTATUS                      status;


    PAGED_CODE( );

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;

    status = CnpIssueDeviceControl(
                 FileObject,
                 DeviceObject,
                 &parameters,
                 sizeof(parameters),
                 NULL,
                 0,
                 TDI_SET_EVENT_HANDLER,
                 ClientIrp
                 );

    return(status);

}  // CnpTdiSetEventHandler



NTSTATUS
CnpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    )
{

    return(STATUS_SUCCESS);

}  // CnpTdiErrorHandler



VOID
CnpAttachSystemProcess(
    VOID
    )
/*++

Routine Description:

    Attach to the system process, as determined during DriverEntry
    and stored in CnSystemProcess.
    
Arguments:

    None.
    
Return value:

    None.
    
Notes:

    Must be followed by a call to CnpDetachSystemProcess.
    
    Implemented in this module due to header conflicts with
    ntddk.h.
    
--*/
{
    KeAttachProcess(CnSystemProcess);

    return;

}  // CnpAttachSystemProcess



VOID
CnpDetachSystemProcess(
    VOID
    )
/*++

Routine Description:

    Detach from the system process.
    
Arguments:

    None.
    
Return value:

    None.
    
Notes:

    Must be preceded by a call to CnpDetachSystemProcess.
    
    Implemented in this module due to header conflicts with
    ntddk.h.
    
--*/
{
    KeDetachProcess();

    return;

}  // CnpDetachSystemProcess


NTSTATUS
CnpOpenDevice(
    IN      LPWSTR          DeviceName,
    OUT     HANDLE          *Handle
    )
/*++

Routine Description:

    Opens a handle to DeviceName. Since no EaBuffer is specified,
    CnpOpenDevice opens a control channel for TDI transports.
    
Arguments:

    DeviceName - device to open
    
    Handle - resulting handle, NULL on failure

Return Value:

    Status of ZwCreateFile
    
Notes:

    Specifies OBJ_KERNEL_HANDLE, meaning that the resulting 
        handle is only valid in kernel-mode. This routine
        cannot be called to obtain a handle that will be 
        exported to user-mode.

--*/
{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;

    PAGED_CODE();

    *Handle = (HANDLE) NULL;

    RtlInitUnicodeString(&nameString, DeviceName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateFile(
                 Handle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &iosb,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_OPEN) {
            CNPRINT(("[Clusnet] Failed to open device %S, status %lx\n", 
                     DeviceName, status));
        }
        *Handle = NULL;
    }

    return(status);

}   // CnpOpenDevice


NTSTATUS
CnpZwDeviceControl(
    IN HANDLE   Handle,
    IN ULONG    IoControlCode,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN ULONG    OutputBufferLength
    )
{
    NTSTATUS             status = STATUS_SUCCESS;
    IO_STATUS_BLOCK      iosb;
    HANDLE               event;

    PAGED_CODE();

    status = ZwCreateEvent( &event,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if (NT_SUCCESS(status)) {

        status = ZwDeviceIoControlFile(
                     Handle,
                     event,
                     NULL,
                     NULL,
                     &iosb,
                     IoControlCode,
                     InputBuffer,
                     InputBufferLength,
                     OutputBuffer,
                     OutputBufferLength
                     );

        if (status == STATUS_PENDING) {
            status = ZwWaitForSingleObject( event, FALSE, NULL );
            CnAssert( status == STATUS_SUCCESS );
            status = iosb.Status;
        }

        ZwClose( event );
    }

    return(status);

} // CnpZwDeviceControl


#define TCP_SET_INFO_EX_BUFFER_PREALLOCSIZE 16
#define TCP_SET_INFO_EX_PREALLOCSIZE                      \
    (FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) \
     + TCP_SET_INFO_EX_BUFFER_PREALLOCSIZE                \
     )

NTSTATUS
CnpSetTcpInfoEx(
    IN HANDLE   Handle,
    IN ULONG    Entity,
    IN ULONG    Class,
    IN ULONG    Type,
    IN ULONG    Id,
    IN PVOID    Value,
    IN ULONG    ValueLength
    )
{
    NTSTATUS                        status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    UCHAR                           infoBuf[TCP_SET_INFO_EX_PREALLOCSIZE]={0};

    PAGED_CODE();

    //
    // Check if we need to dynamically allocate.
    //
    if (ValueLength > TCP_SET_INFO_EX_BUFFER_PREALLOCSIZE) {

        setInfoEx = CnAllocatePool(
                        FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer)
                        + ValueLength
                        );
        if (setInfoEx == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(
            setInfoEx,
            FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) + ValueLength
            );

    } else {

        setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)&infoBuf[0];
    }

    setInfoEx->ID.toi_entity.tei_entity = Entity;
    setInfoEx->ID.toi_entity.tei_instance = 0;
    setInfoEx->ID.toi_class = Class;
    setInfoEx->ID.toi_type = Type;
    setInfoEx->ID.toi_id = Id;
    setInfoEx->BufferSize = ValueLength;
    RtlCopyMemory(setInfoEx->Buffer, Value, ValueLength);
    
    status = CnpZwDeviceControl(
                 Handle,
                 IOCTL_TCP_SET_INFORMATION_EX,
                 setInfoEx,
                 FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer)
                 + ValueLength,
                 NULL,
                 0
                 );

    //
    // Free the buffer, if dynamically allocated
    //
    if (setInfoEx != (PTCP_REQUEST_SET_INFORMATION_EX)&infoBuf[0]) {
        CnFreePool(setInfoEx);
    }

    return(status);

}   // CnpSetTcpInfoEx


NTSTATUS
CnpInitializeSaltGenerator(
    VOID
    )
/*++

Routine Description:

    Initialize the FIPS-based random number generator.

--*/
{
    BOOL     success;
    ULONG    retries = 5;

    do {
        success = CxFipsFunctionTable.FIPSGenRandom(
                      (PUCHAR) &CnpSaltBase,
                      sizeof(CnpSaltBase)
                      );
    } while (!success && retries--);
    
    return ((success) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
    
} // CnpInitializeSaltGenerator


VOID
CnpGenerateSalt(
    IN PVOID       SaltBuffer,
    IN ULONG       SaltBufferLength
    )
/*++

Routine Description:

    Produce a salt.

    Assumptions: The salt produced in this routine does not 
    need to be unpredictable. It just needs to be different. 
    It will not be used as a key. It is intended to introduce
    greater variation into signed messages, because data 
    typically signed by this algorithm differs by only a few 
    bits (e.g. heartbeat sequence numbers, RGP flooded packets).

    Ideally, the FIPS random number generator would be used
    to produce as-random-as-possible numbers, but it cannot
    be called at DISPATCH_LEVEL. Therefore, we use the 
    following algorithm:

    - Seed the 64-bit salt base with the FIPS RNG
    - Each time this routine is called, multiply the salt base
      by a prime number. This multiplication is not synchronized 
      (e.g. with InterlockedXXX or a spinlock) because we don't 
      really care if it is.
    - Add the current interrupt time to introduce a modicum of
      unpredictability.
      
Arguments:

    SaltBuffer - allocated buffer for salt, possibly unaligned

    SaltBufferLength - length in bytes of SaltBuffer

Return value:

    None.

--*/
{
    ULONG bufIndex;
    ULONG remaining;

    for (bufIndex = 0, remaining = SaltBufferLength - bufIndex; 
         remaining > 0; 
         bufIndex += sizeof(ULONGLONG), remaining -= sizeof(ULONGLONG)) {

        ULONGLONG salt;

        salt = (CnpSaltBase *= (ULONG)CNP_SALTBASE_MULTIPLIER);
        salt += KeQueryInterruptTime() + 1;

        RtlCopyMemory(
            (PUCHAR)SaltBuffer + bufIndex,
            (PUCHAR)&salt,
            (remaining <= sizeof(salt)) ? remaining : sizeof(salt)
            );
    }

    return;
    
} // CnpGenerateSalt


NTSTATUS
CnpMakeSignature(
    IN             PSecBufferDesc         Data,
    IN             PVOID                  Key,
    IN             ULONG                  KeyLength,
    IN  OPTIONAL   PVOID                  SigBuffer,
    IN  OPTIONAL   ULONG                  SigBufferLength,
    OUT OPTIONAL   PSecBuffer           * SigSecBuffer,
    OUT OPTIONAL   ULONG                * SigLen
    )
/*++

Routine Description:

    Builds a signature for Data.
    
Arguments:

    Data - data to be signed, packaged in a SecBufferDesc. All
           SecBuffers in Data should be of type SECBUFFER_DATA
           except exactly one which has type SECBUFFER_TOKEN.
           Other buffers will be ignored.
           
    Key - authentication key
    
    KeyLength - length of Key in bytes
           
    SigBuffer - Buffer in which to place completed signature. If NULL,
                signature is written into signature secbuffer (has
                type SECBUFFER_TOKEN in Data).
                
    SigBufferLength - length of buffer at SigBuffer, if provided
    
    SigSecBuffer - If non-NULL, returns pointer to signature secbuffer
                   from Data.
    
    SigLen - on success, contains length of signature written
             on SEC_E_BUFFER_TOO_SMALL, contains required signature length
             undefined otherwise
    
Return value:

    SEC_E_OK if successful.
    SEC_E_SECPKG_NOT_FOUND if the security buffer version is wrong.
    SEC_E_BUFFER_TOO_SMALL if SigBufferLength is too small.
    SEC_E_INVALID_TOKEN if Data is a misformed SecBuffer.
    
--*/
{
    A_SHA_CTX            shaCtxt;
    PUCHAR               hashBuffer;
    ULONG                bufIndex;
    PSecBuffer           sigSecBuffer = NULL;
    PSecBuffer           curBuffer;
    ULONG                status;

    //
    // Verify the version.
    //
    if (Data->ulVersion != SECBUFFER_VERSION) {
        status = SEC_E_SECPKG_NOT_FOUND;
        goto error_exit;
    }

    //
    // Verify that the provided sig buffer is big enough.
    //
    if (SigBuffer != NULL && SigBufferLength < CX_SIGNATURE_LENGTH) {
        status = SEC_E_BUFFER_TOO_SMALL;
        goto error_exit;
    }

    //
    // Initialize the SHA context.
    //
    CxFipsFunctionTable.FipsHmacSHAInit(&shaCtxt, (PUCHAR) Key, KeyLength);

    //
    // Hash the data.
    //
    for (bufIndex = 0, curBuffer = &(Data->pBuffers[bufIndex]); 
         bufIndex < Data->cBuffers; 
         bufIndex++, curBuffer++) {

        //
        // Process this buffer according to its type.
        //
        if (curBuffer->BufferType == SECBUFFER_DATA) {

            //
            // Hash this buffer.
            //
            CxFipsFunctionTable.FipsHmacSHAUpdate(
                                    &shaCtxt, 
                                    (PUCHAR) curBuffer->pvBuffer, 
                                    curBuffer->cbBuffer
                                    );

        } else if (curBuffer->BufferType == SECBUFFER_TOKEN) {

            if (sigSecBuffer != NULL) {
                // 
                // There can only be one signature buffer per message.
                // 
                status = SEC_E_INVALID_TOKEN;
                goto error_exit;
            } else {
                sigSecBuffer = curBuffer;
                
                //
                // Verify that the signature buffer is big enough.
                //
                if (sigSecBuffer->cbBuffer < CX_SIGNATURE_LENGTH) {
                    *SigLen = CX_SIGNATURE_LENGTH;
                    status = SEC_E_BUFFER_TOO_SMALL;
                    goto error_exit;
                }

                //
                // Set the output buffer.
                //
                if (SigBuffer == NULL) {
                    hashBuffer = sigSecBuffer->pvBuffer;
                } else {
                    hashBuffer = SigBuffer;
                }
            }
        }
    }

    //
    // Verify that we found a buffer for the signature.
    //
    if (sigSecBuffer == NULL) {
        status = SEC_E_INVALID_TOKEN;
        goto error_exit;
    }

    //
    // Complete the hash.
    //
    CxFipsFunctionTable.FipsHmacSHAFinal(
                            &shaCtxt, 
                            (PUCHAR) Key,
                            KeyLength,
                            hashBuffer
                            );

    //
    // Return the signature buffer and length.
    //
    if (SigSecBuffer != NULL) {
        *SigSecBuffer = sigSecBuffer;
    }
    if (SigLen != NULL) {
        *SigLen = CX_SIGNATURE_LENGTH;
    }

    status = SEC_E_OK;

error_exit:

    return(status);

} // CnpMakeSignature

NTSTATUS
CnpVerifySignature(
    IN     PSecBufferDesc         Data,
    IN     PVOID                  Key,
    IN     ULONG                  KeyLength
    )
/*++

Routine Description:

    Verifies a signature for data.

Arguments:

    Data - data to be verified, packaged in a SecBufferDesc. All
           SecBuffers in Data should be of type SECBUFFER_DATA
           except exactly one which has type SECBUFFER_TOKEN.
           Other buffers will be ignored.
           
    Key - authentication key
    
    KeyLength - length of Key in bytes
           
Return value:

    SEC_E_OK if the signature is correct.
    SEC_E_SECPKG_NOT_FOUND if the security buffer version is wrong.
    SEC_E_INVALID_TOKEN if Data is a misformed SecBuffer.
    SEC_E_MESSAGE_ALTERED if signature is incorrect (including if it
        is the wrong length).
        
--*/
{
    UCHAR                hashBuffer[CX_SIGNATURE_LENGTH];
    PSecBuffer           sigBuffer = NULL;
    ULONG                status;

    status = CnpMakeSignature(
                 Data,
                 Key,
                 KeyLength,
                 hashBuffer,
                 sizeof(hashBuffer),
                 &sigBuffer,
                 NULL
                 );
    if (status == SEC_E_OK) {
    
        //
        // Compare the generated signature to the provided signature.
        //
        if (RtlCompareMemory(
                hashBuffer,
                sigBuffer->pvBuffer, 
                CX_SIGNATURE_LENGTH
                ) != sigBuffer->cbBuffer) {
            status = SEC_E_MESSAGE_ALTERED;
        } else {
            status = SEC_E_OK;
        }
    }

    return(status);

} // CnpVerifySignature

#define CNP_SIGN_SIGSECBUFS      3
#define CNP_VRFY_SIGSECBUFS      2

NTSTATUS
CnpSignMulticastMessage(
    IN              PCNP_SEND_REQUEST               SendRequest,
    IN              PMDL                            DataMdl,
    IN OUT          CL_NETWORK_ID                 * NetworkId,
    OUT    OPTIONAL ULONG                         * SigDataLen
    )
/*++

Routine Description:

    Sign a message.
    
    If NetworkId is not ClusterAnyNetworkId, the mcast group
    field must be set (and already referenced) in the SendRequest.
    This is the group that will be used to send the packet.

    The signature will be calculated in the order in which
    we provide SecBuffers. We need to make sure that order
    is the same on the sending side as it is on the receiving
    side. In order to make the signing and verifying more
    efficient, we prefer to sign and verify contiguous data
    in one chunk. Thus, we prepend the Salt (generated here)
    to the upper protocol header, allowing us to sign and verify
    the salt with that header. Thus, the layout of the message
    is as follows:

        MAC / IP / UDP Headers               --
                                               |
        CNP Header                             |
                                                - not signed
        - CNP Signature Data                   |
                                               |
        - Signature                            |
                                             ==
        - Salt                                 |
                                               |
        Upper Protocol Header (CDP or CCMP)     - signed
                                               |
        Data                                 --

    Note: Signing and verifying the Salt in the same chunk
          as the upper protocol header requires that they be
          contiguous. There can be no extra padding between
          the salt buffer and the start of the header.
    
Arguments:

    SendRequest - send request, used to locate the upper protocol
                  header to sign, as well as the signature buffer.
    
    DataMdl - data to sign
    
    NetworkId - IN: network on which to send the message, or 
                    ClusterAnyNetworkId if it should be chosen
                OUT: network id chosen to send packet
    
    SigDataLen - OUT (OPTIONAL): number of bytes occupied in
                 message by signature data and signature
    
--*/
{
    NTSTATUS                        status;
    PCNP_NETWORK                    network;
    PCNP_MULTICAST_GROUP            mcastGroup;
    BOOLEAN                         mcastGroupReferenced = FALSE;
    CNP_HEADER UNALIGNED          * cnpHeader;
    CNP_SIGNATURE UNALIGNED       * cnpSig;
    SecBufferDesc                   sigDescriptor;
    SecBuffer                       sigSecBufferPrealloc[CNP_SIGN_SIGSECBUFS];
    PSecBuffer                      sigSecBuffer = NULL;
    ULONG                           secBufferCount;
    ULONG                           sigLen;
    PMDL                            mdl;
    PSecBuffer                      curBuffer;

    CnAssert(SendRequest != NULL);
    CnAssert(SendRequest->UpperProtocolHeader == NULL ||
             SendRequest->UpperProtocolHeaderLength > 0);    
    CnAssert(((CNP_HEADER UNALIGNED *)SendRequest->CnpHeader)->Version ==
             CNP_VERSION_MULTICAST);

    //
    // Determine which network to use.
    //
    if (*NetworkId != ClusterAnyNetworkId) {
        
        mcastGroup = SendRequest->McastGroup;
        CnAssert(mcastGroup != NULL);
    
    } else {
        
        network = CnpGetBestMulticastNetwork();

        if (network == NULL) {
            CnTrace(CNP_SEND_ERROR, CnpMcastGetBestNetwork,
                "[CNP] Failed to find best multicast network."
                );
            status = STATUS_NETWORK_UNREACHABLE;
            goto error_exit;
        } 
        
        //
        // Get the network id and mcast group before releasing
        // the network lock.
        //
        *NetworkId = network->Id;

        mcastGroup = network->CurrentMcastGroup;
        if (mcastGroup == NULL) {
            CnTrace(CNP_SEND_ERROR, CnpMcastGroupNull,
                "[CNP] Best multicast network %u has null "
                "multicast group.",
                network->Id
                );
            CnReleaseLock(&(network->Lock), network->Irql);
            status = STATUS_NETWORK_UNREACHABLE;
            goto error_exit;
        }
        CnpReferenceMulticastGroup(mcastGroup);
        mcastGroupReferenced = TRUE;

        CnReleaseLock(&(network->Lock), network->Irql);
    }

    CnAssert(mcastGroup->SignatureLength == CX_SIGNATURE_LENGTH);

    //
    // Initialize the signature header.
    //
    cnpHeader = (CNP_HEADER UNALIGNED *)(SendRequest->CnpHeader);
    cnpSig = (CNP_SIGNATURE UNALIGNED *)(cnpHeader + 1);
    cnpSig->Version = CNP_SIG_VERSION_1;
    cnpSig->SigLength = CX_SIGNATURE_LENGTH;
    cnpSig->NetworkId = *NetworkId;
    cnpSig->ClusterNetworkBrand = mcastGroup->McastNetworkBrand;
    cnpSig->SaltLength = CX_SIGNATURE_SALT_LENGTH;

    //
    // Generate the salt. Write it into the SigDataBuffer field 
    // of the header immediately after the signature.
    //
    CnpGenerateSalt(
        ((PUCHAR) &cnpSig->SigDataBuffer[CX_SIGNATURE_LENGTH]),
        CX_SIGNATURE_SALT_LENGTH
        );
        
    //
    // Determine how many sig sec buffers we will need.
    // The common case is three: one for a header and salt, 
    // one for the data, and one for the signature. 
    // We prealloc sig buffers on the stack
    // for the common case, but we dynamically allocate 
    // if needed (e.g. if the data is a chain of MDLs).
    //
    secBufferCount = CNP_SIGN_SIGSECBUFS - 1;
    for (mdl = DataMdl; mdl != NULL; mdl = mdl->Next) {
        secBufferCount++;
    }

    //
    // Allocate the sig sec buffers.
    //
    if (secBufferCount <= CNP_SIGN_SIGSECBUFS) {
        sigSecBuffer = &sigSecBufferPrealloc[0];
    } else {

        sigSecBuffer = CnAllocatePool(
                           secBufferCount * sizeof(SecBuffer)
                           );
        if (sigSecBuffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        }
    }

    //
    // Prepare the descriptor for the message and signature.
    //
    sigDescriptor.cBuffers = secBufferCount;
    sigDescriptor.pBuffers = sigSecBuffer;
    sigDescriptor.ulVersion = SECBUFFER_VERSION;
    curBuffer = sigSecBuffer;

    //
    // Header and salt.
    //
    curBuffer->BufferType = SECBUFFER_DATA;
    curBuffer->pvBuffer = (PVOID) &cnpSig->SigDataBuffer[CX_SIGNATURE_LENGTH];
    curBuffer->cbBuffer = CX_SIGNATURE_SALT_LENGTH + 
                          SendRequest->UpperProtocolHeaderLength;
    curBuffer++;

    //
    // The payload provided by our client.
    //
    for (mdl = DataMdl; mdl != NULL; mdl = mdl->Next) {

        curBuffer->BufferType = SECBUFFER_DATA;
        curBuffer->cbBuffer = MmGetMdlByteCount(mdl);
        curBuffer->pvBuffer = MmGetMdlVirtualAddress(mdl);
        curBuffer++;
    }

    //
    // The Signature.
    //
    curBuffer->BufferType = SECBUFFER_TOKEN;
    curBuffer->pvBuffer = cnpSig->SigDataBuffer;
    curBuffer->cbBuffer = CX_SIGNATURE_LENGTH;

    status = CnpMakeSignature(
                 &sigDescriptor,
                 mcastGroup->Key,
                 mcastGroup->KeyLength,
                 NULL,
                 0,
                 NULL,
                 &sigLen
                 );

    if (status != STATUS_SUCCESS || sigLen != CX_SIGNATURE_LENGTH) {

        IF_CNDBG(CN_DEBUG_CNPSEND) {
            CNPRINT(("[CNP] MakeSignature failed or returned "
                     "an unexpected length, status %x, "
                     "expected length %d, returned length %d.\n",
                     status, CX_SIGNATURE_LENGTH, sigLen));
        }

        CnTrace(CNP_SEND_ERROR, CnpMcastMakeSigFailed,
            "[CNP] MakeSignature failed or returned "
            "an unexpected length, status %!status!, "
            "expected length %d, returned length %d.",
            status, CX_SIGNATURE_LENGTH, sigLen
            );

        status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
    }

    if (SigDataLen != NULL) {
        *SigDataLen = CNP_SIG_LENGTH(CX_SIGNATURE_DATA_LENGTH);
    }

    SendRequest->McastGroup = mcastGroup;

error_exit:

    if (sigSecBuffer != NULL && 
        sigSecBuffer != &sigSecBufferPrealloc[0]) {

        CnFreePool(sigSecBuffer);
        sigSecBuffer = NULL;
    }

    if (status != STATUS_SUCCESS && mcastGroupReferenced) {
        CnAssert(mcastGroup != NULL);
        CnpDereferenceMulticastGroup(mcastGroup);
        mcastGroupReferenced = FALSE;
    }

    return(status);

} // CnpSignMulticastMessage


NTSTATUS
CnpVerifyMulticastMessage(
    IN     PCNP_NETWORK                    Network,
    IN     PVOID                           Tsdu,
    IN     ULONG                           TsduLength,
    IN     ULONG                           ExpectedPayload,
       OUT ULONG                         * BytesTaken,
       OUT BOOLEAN                       * CurrentGroup
    )
/*++

Routine Description:

    Verify a message.

    This routine assumes that the Salt in the CNP Signature
    header is contiguous with the payload (most likely 
    consisting of a CDP or CCMP header followed by the
    upper protocol payload). See the Routine Description
    for CnpSignMulticastMessage for the expected layout of
    the message data.

    If, in a future release, it becomes necessary to extend
    the space between the CNP Signature Header and the
    payload (e.g. for alignment or whatever), the SigLength
    can be increased. This routine will only compare 
    CX_SIGNATURE_LENGTH bytes of the signature buffer.
    
Arguments:

    Network - network on which message arrived
    
    Tsdu - points to protocol header
           
    TsduLength - length of TSDU, including signature data
    
    ExpectedPayload - expected payload after signature data
                     
    BytesTaken - OUT: quantity of data consumed by signature data
                     
    CurrentGroup - OUT: whether signature matched current
                        multicast group. 

Return value:

    SEC_E_OK or error status.
    
--*/
{
    NTSTATUS                        status;
    CNP_SIGNATURE UNALIGNED       * cnpSig = Tsdu;
    ULONG                           totalSigBytes = 0;
    PVOID                           saltAndPayload;
    ULONG                           saltAndPayloadLength;
    PCNP_MULTICAST_GROUP            currMcastGroup = NULL;
    PCNP_MULTICAST_GROUP            prevMcastGroup = NULL;

    SecBufferDesc                   sigDescriptor;
    SecBuffer                       sigSecBufferPrealloc[CNP_VRFY_SIGSECBUFS];
    PSecBuffer                      sigSecBuffer = NULL;
    PSecBuffer                      curBuffer;


    //
    // Verify that the signature is present. Do not 
    // dereference any signature data until we know 
    // it's there.
    //
    if (
        
        // Verify that signature header data is present.
        (TsduLength < (ULONG)CNP_SIGHDR_LENGTH) ||

        // Verify that signature length and salt lengths are
        // separately reasonable. 
        // This check prevents an overflow attack in which the 
        // sum of the lengths looks okay but individually they
        // are invalid.
        (TsduLength < cnpSig->SigLength) ||
        (TsduLength < cnpSig->SaltLength) ||

        // Verify that aggregate signature buffer is present
        (TsduLength < 
         (totalSigBytes = CNP_SIG_LENGTH(cnpSig->SigLength + cnpSig->SaltLength))
         ) ||

        // Verify that the expected payload is present
        (TsduLength - totalSigBytes != ExpectedPayload)
        
        ) {

        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Cannot verify mcast packet with "
                     "mis-sized payload: TsduLength %u, required "
                     "sig hdr %u, sig data length %u, "
                     "expected payload %u.\n",
                     TsduLength,
                     CNP_SIGHDR_LENGTH,
                     totalSigBytes,
                     ExpectedPayload
                     ));
        }

        CnTrace(CNP_RECV_ERROR, CnpTraceReceiveTooSmall,
            "[CNP] Cannot verify mcast packet with "
            "undersized payload: TsduLength %u, required "
            "sig hdr %u, sig buffer %u, "
            "expected payload %u.\n",
            TsduLength,
            CNP_SIGHDR_LENGTH,
            totalSigBytes,
            ExpectedPayload
            );

        //
        // Drop it.
        //
        status = SEC_E_INCOMPLETE_MESSAGE;
        goto error_exit;            
    }

    //
    // Verify that the signature protocol is understood.
    //
    if (cnpSig->Version != CNP_SIG_VERSION_1) {
        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Cannot verify mcast packet with "
                     "unknown signature version: %u.\n",
                     cnpSig->Version
                     ));
        }

        CnTrace(
            CNP_RECV_ERROR, CnpTraceRecvUnknownSigVersion,
            "[CNP] Cannot verify mcast packet with "
            "unknown signature version: %u.",
            cnpSig->Version
            );

        //
        // Drop it.
        //
        status = SEC_E_BAD_PKGID;
        goto error_exit;
    }

    //
    // Lock the network object and reference the 
    // multicast groups.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    currMcastGroup = Network->CurrentMcastGroup;
    if (currMcastGroup != NULL) {
        CnpReferenceMulticastGroup(currMcastGroup);
    }
    prevMcastGroup = Network->PreviousMcastGroup;
    if (prevMcastGroup != NULL) {
        CnpReferenceMulticastGroup(prevMcastGroup);
    }

    CnReleaseLock(&(Network->Lock), Network->Irql);

    //
    // Verify that the packet network id matches the 
    // local network object.
    //
    if (cnpSig->NetworkId != Network->Id) {
        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Mcast packet has bad network "
                     "id: found %d, expected %d.\n",
                     cnpSig->NetworkId,
                     Network->Id
                     ));
        }

        CnTrace(
            CNP_RECV_ERROR, CnpTraceReceiveBadNetworkId,
            "[CNP] Mcast packet has bad network id: "
            "found %d, expected %d.",
            cnpSig->NetworkId,
            Network->Id
            );

        //
        // Drop it.
        //
        status = SEC_E_TARGET_UNKNOWN;
        goto error_exit;
    }

    //
    // Verify that the brand matches either the current or
    // previous multicast group.
    //
    if (currMcastGroup != NULL &&
        cnpSig->ClusterNetworkBrand != currMcastGroup->McastNetworkBrand) {

        // can't use currMcastGroup
        CnpDereferenceMulticastGroup(currMcastGroup);
        currMcastGroup = NULL;
    }

    if (prevMcastGroup != NULL &&
        cnpSig->ClusterNetworkBrand != prevMcastGroup->McastNetworkBrand) {

        // can't use prevMcastGroup
        CnpDereferenceMulticastGroup(prevMcastGroup);
        prevMcastGroup = NULL;
    }

    if (currMcastGroup == NULL && prevMcastGroup == NULL) {

        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Recv'd mcast packet with brand %x, "
                     "but no matching multicast groups.\n",
                     cnpSig->ClusterNetworkBrand
                     ));
        }

        CnTrace(
            CNP_RECV_ERROR, CnpTraceReceiveBadBrand,
            "[CNP] Recv'd mcast packet with brand %x, "
            "but no matching multicast groups.",
            cnpSig->ClusterNetworkBrand
            );

        //
        // Drop it.
        //
        status = SEC_E_TARGET_UNKNOWN;
        goto error_exit;
    }

    //
    // Locate the salt and payload following the signature data.
    // The salt and payload are contiguous, and this is where we
    // start with signature verification.
    //
    saltAndPayload = (PVOID)(&cnpSig->SigDataBuffer[cnpSig->SigLength]);
    saltAndPayloadLength = 
        TsduLength - (PtrToUlong(saltAndPayload) - PtrToUlong(Tsdu));

    //
    // Build the signature descriptor for verification. The bytes
    // that were signed (and hence need to be verified) include
    // the salt (placed between the signature and the payload data) 
    // and the payload data.
    //
    sigSecBuffer = &sigSecBufferPrealloc[0];
    curBuffer = sigSecBuffer;

    sigDescriptor.cBuffers = CNP_VRFY_SIGSECBUFS - 1;
    sigDescriptor.pBuffers = sigSecBuffer;
    sigDescriptor.ulVersion = SECBUFFER_VERSION;

    //
    // Place the signature first in the sigDescriptor array. The
    // order doesn't matter for correctness, but this way the
    // signature token buffer will be validated before any
    // computationally expensive hashing is performed.
    //
    curBuffer->BufferType = SECBUFFER_TOKEN;
    curBuffer->cbBuffer = cnpSig->SigLength;
    curBuffer->pvBuffer = (PVOID)&(cnpSig->SigDataBuffer[0]);
    curBuffer++;

    //
    // Data.
    //
    if (saltAndPayloadLength > 0) {
        sigDescriptor.cBuffers = CNP_VRFY_SIGSECBUFS;
        curBuffer->BufferType = SECBUFFER_DATA;
        curBuffer->cbBuffer = saltAndPayloadLength;
        curBuffer->pvBuffer = saltAndPayload;
        curBuffer++;
    } 

    /*CNPRINT(("[CNP] Verifying message of length %d with "
             "sig of length %d.\n",
             HeaderLength + payloadLength,
             cnpSig->SigBufferLen));*/

    //
    // Try the current multicast group, and if necessary,
    // the previous multicast group.
    //
    status = SEC_E_INVALID_TOKEN;

    if (currMcastGroup != NULL) {

        status = CnpVerifySignature(
                     &sigDescriptor,
                     currMcastGroup->Key,
                     currMcastGroup->KeyLength
                     );

        if (status == SEC_E_OK && CurrentGroup != NULL) {
            *CurrentGroup = TRUE;
        }
    }

    if (status != SEC_E_OK && prevMcastGroup != NULL) {

        status = CnpVerifySignature(
                     &sigDescriptor,
                     prevMcastGroup->Key,
                     prevMcastGroup->KeyLength
                     );

        if (status == SEC_E_OK && CurrentGroup != NULL) {
            *CurrentGroup = FALSE;
        }
    }

    if (status == SEC_E_OK) {
        *BytesTaken = totalSigBytes;
    }

error_exit:

    if (currMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(currMcastGroup);
    }

    if (prevMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(prevMcastGroup);
    }

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(status);

} // CnpVerifyMulticastMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnprecv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnprecv.c

Abstract:

    Cluster Network Protocol receive processing code.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnprecv.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CnpCreateSendRequestPool)

#endif // ALLOC_PRAGMA

//
// Local types
//
typedef struct {
    ULONG        TdiReceiveDatagramFlags;
    ULONG        TsduSize;
    PCNP_NETWORK Network;
    ULONG        CnpReceiveFlags;
} CNP_RECEIVE_CONTEXT, *PCNP_RECEIVE_CONTEXT;


//
// Local Data
//
PCN_RESOURCE_POOL  CnpReceiveRequestPool = NULL;

#define CNP_RECEIVE_REQUEST_POOL_DEPTH 2

//
// Routines exported within the Cluster Transport
//
NTSTATUS
CnpLoad(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Loading...\n"));
    }

    CnpReceiveRequestPool = CnpCreateReceiveRequestPool(
                                sizeof(CNP_RECEIVE_CONTEXT),
                                CNP_RECEIVE_REQUEST_POOL_DEPTH
                                );

    if (CnpReceiveRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Loading complete.\n"));
    }

    return(STATUS_SUCCESS);

}  // CnpInitializeReceive

VOID
CnpUnload(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Unloading...\n"));
    }

    if (CnpReceiveRequestPool != NULL) {
        CnpDeleteReceiveRequestPool(CnpReceiveRequestPool);
        CnpReceiveRequestPool = NULL;
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Unloading complete.\n"));
    }

    return;

}  // CnpCleanupReceive

//
// Private Utility Fumctions
//
PCN_RESOURCE
CnpCreateReceiveRequest(
    IN PVOID   Context
    )
{
    PCNP_RECEIVE_REQUEST_POOL_CONTEXT   context = Context;
    PCNP_RECEIVE_REQUEST                request;
    PIRP                                irp;


    //
    // Allocate a new receive request. Include space for the upper protocol
    // context.
    //
    request = CnAllocatePool(
                  sizeof(CNP_RECEIVE_REQUEST) +
                      context->UpperProtocolContextSize
                  );

    if (request != NULL) {
        request->UpperProtocolContext = request + 1;
        return(&(request->CnResource));
    }

    return(NULL);

}  // CnpCreateReceiveRequest


VOID
CnpDeleteReceiveRequest(
    PCN_RESOURCE  Resource
    )
{
    PCNP_RECEIVE_REQUEST  request = CONTAINING_RECORD(
                                        Resource,
                                        CNP_RECEIVE_REQUEST,
                                        CnResource
                                        );

    CnFreePool(request);

    return;

} // CnpDeleteReceiveRequest


//
// Routines Exported within the Cluster Transport
//
PCN_RESOURCE_POOL
CnpCreateReceiveRequestPool(
    IN ULONG  UpperProtocolContextSize,
    IN USHORT PoolDepth
    )
{
    PCN_RESOURCE_POOL                   pool;
    PCNP_RECEIVE_REQUEST_POOL_CONTEXT   context;


    PAGED_CODE();

    pool = CnAllocatePool(
               sizeof(CN_RESOURCE_POOL) +
                   sizeof(CNP_RECEIVE_REQUEST_POOL_CONTEXT)
               );

    if (pool != NULL) {
        context = (PCNP_RECEIVE_REQUEST_POOL_CONTEXT) (pool + 1);

        context->UpperProtocolContextSize = UpperProtocolContextSize;

        CnInitializeResourcePool(
                   pool,
                   PoolDepth,
                   CnpCreateReceiveRequest,
                   context,
                   CnpDeleteReceiveRequest
                   );
    }

    return(pool);

}  // CnpCreateReceiveRequestPool


PCNP_RECEIVE_REQUEST
CnpAllocateReceiveRequest(
    IN PCN_RESOURCE_POOL  RequestPool,
    IN PVOID              Network,
    IN ULONG              BytesToReceive,
    IN PVOID              CompletionRoutine
    )
{
    PCNP_NETWORK          network = Network;
    PCNP_RECEIVE_REQUEST  request = (PCNP_RECEIVE_REQUEST)
                                    CnAllocateResource(RequestPool);

    if (request != NULL) {

        //
        // Allocate a buffer to hold the data.
        //
        request->DataBuffer = CnAllocatePool(BytesToReceive);

        if (request->DataBuffer != NULL) {
            request->Irp = IoAllocateIrp(
                               network->DatagramDeviceObject->StackSize,
                               FALSE
                               );

            if (request->Irp != NULL) {
                PMDL  mdl = IoAllocateMdl(
                                request->DataBuffer,
                                BytesToReceive,
                                FALSE,
                                FALSE,
                                NULL
                                );

                if (mdl != NULL) {
                    PIRP  irp = request->Irp;

                    MmBuildMdlForNonPagedPool(mdl);

                    //
                    // Build the irp.
                    //
                    irp->Flags = 0;
                    irp->RequestorMode = KernelMode;
                    irp->PendingReturned = FALSE;
                    irp->UserIosb = NULL;
                    irp->UserEvent = NULL;
                    irp->Overlay.AsynchronousParameters.UserApcRoutine =
                        NULL;
                    irp->AssociatedIrp.SystemBuffer = NULL;
                    irp->UserBuffer = NULL;
                    irp->Tail.Overlay.Thread = 0;
                    irp->Tail.Overlay.OriginalFileObject =
                        network->DatagramFileObject;
                    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

                    TdiBuildReceiveDatagram(
                        irp,
                        network->DatagramDeviceObject,
                        network->DatagramFileObject,
                        CompletionRoutine,
                        request,
                        mdl,
                        BytesToReceive,
                        NULL,
                        NULL,
                        0
                        );

                    //
                    // Make the next stack location current.
                    // Normally IoCallDriver would do this, but
                    // since we're bypassing that, we do it directly.
                    //
                    IoSetNextIrpStackLocation( irp );

                    return(request);
                }

                IoFreeIrp(request->Irp);
                request->Irp = NULL;
            }

            CnFreePool(request->DataBuffer);
            request->DataBuffer = NULL;
        }

        CnFreeResource((PCN_RESOURCE) request);
    }

    return(NULL);

}  // CnpAllocateReceiveRequest


VOID
CnpFreeReceiveRequest(
    PCNP_RECEIVE_REQUEST  Request
    )
{
    IoFreeMdl(Request->Irp->MdlAddress);
    Request->Irp->MdlAddress = NULL;

    IoFreeIrp(Request->Irp);
    Request->Irp = NULL;

    CnFreePool(Request->DataBuffer);
    Request->DataBuffer = NULL;

    CnFreeResource((PCN_RESOURCE) Request);

    return;

}  // CnpFreeReceiveRequest


NTSTATUS
CnpIndicateData(
    IN  PCNP_NETWORK   Network,
    IN  UCHAR          NextHeader,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
/*++

Routine Description:

    Indicate data to the next highest protocol.

--*/
{
    NTSTATUS status;

    if (NextHeader == PROTOCOL_CDP) {

        CnTrace(CNP_RECV_DETAIL, CnpTraceIndicateDataPacket,
            "[CNP] Indicating data packet from node %u net %u, "
            "BI %u, BA %u, CNP Flags %x.",
            SourceNodeId, // LOGULONG
            Network->Id, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );

        status = CdpReceivePacketHandler(
                     Network,
                     SourceNodeId,
                     CnpReceiveFlags,
                     TdiReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     Irp
                     );
    }
    else if (NextHeader == PROTOCOL_CCMP) {

        CnTrace(CNP_RECV_DETAIL, CnpTraceIndicateControlPacket,
            "[CNP] Indicating control packet from node %u net %u, "
            "BI %u, BA %u, CNP Flags %x.",
            SourceNodeId, // LOGULONG
            Network->Id, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );

        status = CcmpReceivePacketHandler(
                     Network,
                     SourceNodeId,
                     CnpReceiveFlags,
                     TdiReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     Irp
                     );
    }
    else {
        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT((
                "[CNP] Received packet for unknown protocol %u\n",
                NextHeader
                ));
        }
        CnTrace(CNP_RECV_DETAIL, CnpTraceRecvUnknownProtocol,
            "[CNP] Received packet for unknown protocol (%u) "
            " from node %u net %u, BI %u, BA %u, CNP Flags %x.",
            NextHeader,
            SourceNodeId, // LOGULONG
            Network->Id, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );

        status = STATUS_SUCCESS;
    }

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(status);

} // CnpIndicateData


NTSTATUS
CnpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    NTSTATUS               status;
    PCNP_RECEIVE_REQUEST   request = Context;
    PCNP_RECEIVE_CONTEXT   context = request->UpperProtocolContext;
    CNP_HEADER UNALIGNED * cnpHeader = request->DataBuffer;
    ULONG                  consumed;
    ULONG                  dataLength;
    PIRP                   irp = NULL;
    ULONG                  bytesTaken = 0;
    BOOLEAN                currentMcastGroup = FALSE;


    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        CnAssert(Irp->IoStatus.Information == context->TsduSize);

        CnAssert(context->CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST);
        CnAssert(
            !(context->CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED)
            );
        CnAssert(
            !(context->CnpReceiveFlags & CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP)
            );

        dataLength = (ULONG)Irp->IoStatus.Information;

        //
        // This routine is only called for multicast packets,
        // so we need to verify the signature.
        //
        status = CnpVerifyMulticastMessage(
                     context->Network,
                     cnpHeader + 1,
                     dataLength - sizeof(CNP_HEADER),
                     cnpHeader->PayloadLength,
                     &consumed,
                     &currentMcastGroup
                     );
        if (status != SEC_E_OK) {
            CnTrace(CNP_RECV_ERROR, CnpTraceRecvBadSig,
                "[CNP] Failed to verify multicast "
                "packet, status %x, src node %u, net %u, "
                "data length %u, CNP flags %x.",
                status,
                cnpHeader->SourceAddress, // LOGULONG
                context->Network->Id,
                dataLength,
                context->CnpReceiveFlags
                );
            goto error_exit;
        }

        context->CnpReceiveFlags |= CNP_RECV_FLAG_SIGNATURE_VERIFIED;

        if (currentMcastGroup) {
            context->CnpReceiveFlags |= CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP;
        }

        consumed += sizeof(CNP_HEADER);

        //
        // Indicate the data to the next highest protocol.
        //
        status = CnpIndicateData(
                     context->Network,
                     cnpHeader->NextHeader,
                     cnpHeader->SourceAddress,
                     context->CnpReceiveFlags,
                     context->TdiReceiveDatagramFlags,
                     dataLength - consumed,
                     dataLength - consumed,
                     &bytesTaken,
                     (PUCHAR)cnpHeader + consumed,
                     &irp
                     );

        CnAssert(status != STATUS_MORE_PROCESSING_REQUIRED);
        CnAssert(bytesTaken == dataLength - consumed);
        CnAssert(irp == NULL);

        if (irp != NULL) {
            CnTrace(CNP_RECV_ERROR, CnpTraceCompleteReceiveIrp,
                "[CNP] Upper layer protocol requires more"
                "processing. Failing request."
                );
            irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
        }
    }
    else {
        CnTrace(CNP_RECV_ERROR, CnpTraceCompleteReceiveFailed,
            "[CNP] Failed to fetch packet, src node %u, "
            "status %!status!",
            cnpHeader->SourceAddress, // LOGULONG
            Irp->IoStatus.Status // LOGSTATUS
            );
    }

error_exit:

    //
    // Drop the active reference on the network.
    //
    if (context->Network != NULL) {
        CnAcquireLock(&(context->Network->Lock), &(context->Network->Irql));
        CnpActiveDereferenceNetwork(context->Network);
        context->Network = NULL;
    }

    CnpFreeReceiveRequest(request);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // CdpCompleteReceivePacket


NTSTATUS
CnpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   Irp
    )
{
    NTSTATUS                        status;
    CNP_HEADER UNALIGNED *          cnpHeader = Tsdu;
    PCNP_NETWORK                    network = TdiEventContext;
    PCNP_NODE                       srcNode;
    ULONG                           cnpRecvFlags = 0;
    BOOLEAN                         cnpSigDataIndicated = FALSE;
    ULONG                           consumed;
    PCNP_RECEIVE_REQUEST            request;


    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);
    CnAssert(network->State > ClusnetNetworkStateOffline);
    CnAssert(CnLocalNodeId != ClusterInvalidNodeId);
    CnAssert(CnpLocalNode != NULL);

    //
    // Validate the CNP header.
    //
    // First make sure it exists.
    //
    if (BytesIndicated < sizeof(CNP_HEADER)) {
        goto error_exit;
    }

    if ((cnpHeader->SourceAddress < CnMinValidNodeId) ||
        (cnpHeader->SourceAddress > CnMaxValidNodeId)) {
        goto error_exit;
    }

    if (cnpHeader->Version == CNP_VERSION_UNICAST) {
        //
        // Unicast checks.
        //
        if ((cnpHeader->PayloadLength +
             sizeof(CNP_HEADER) != BytesAvailable) ||
            (cnpHeader->DestinationAddress != CnLocalNodeId)) {
            goto error_exit;
        }
    } else if (cnpHeader->Version == CNP_VERSION_MULTICAST) {
        //
        // Multicast checks.
        //
        // Defer payload length check until the signature
        // length is known.
        //
        if (cnpHeader->DestinationAddress != ClusterAnyNodeId) {
            goto error_exit;
        }

        cnpRecvFlags |= CNP_RECV_FLAG_MULTICAST;
    }

    //
    // Validate the source and destination nodes.
    //
    CnAcquireLockAtDpc(&CnpNodeTableLock);

    srcNode = CnpNodeTable[cnpHeader->SourceAddress];

    if (srcNode == NULL) {
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        goto error_exit;
    }

    if ( (srcNode->CommState == ClusnetNodeCommStateOnline) &&
         (CnpLocalNode->CommState == ClusnetNodeCommStateOnline)
       )
    {
        cnpRecvFlags |= CNP_RECV_FLAG_NODE_STATE_CHECK_PASSED;
    }

    CnReleaseLockFromDpc(&CnpNodeTableLock);

    if ((cnpRecvFlags & CNP_RECV_FLAG_MULTICAST) != 0) {

        //
        // Multicast packets need to be verified. Verification
        // cannot proceed unless the entire packet is present.
        //
        if (BytesIndicated == BytesAvailable) {

            BOOLEAN     currentMcastGroup = FALSE;

            //
            // The entire message is indicated. We can
            // verify it now.
            //
            status = CnpVerifyMulticastMessage(
                         network,
                         cnpHeader + 1,
                         BytesIndicated - sizeof(CNP_HEADER),
                         cnpHeader->PayloadLength,
                         &consumed,
                         &currentMcastGroup
                         );
            if (status != SEC_E_OK) {
                CnTrace(CNP_RECV_DETAIL, CdpTraceRecvBadSig,
                    "[CNP] Failed to verify multicast "
                    "packet, status %x, "
                    "src node %u, BI %u, BA %u",
                    status,
                    cnpHeader->SourceAddress, // LOGULONG
                    BytesIndicated, // LOGULONG
                    BytesAvailable // LOGULONG
                    );
                goto error_exit;
            }

            cnpRecvFlags |= CNP_RECV_FLAG_SIGNATURE_VERIFIED;

            if (currentMcastGroup) {
                cnpRecvFlags |= CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP;
            }
            consumed += sizeof(CNP_HEADER);

        } else {

            //
            // The entire message is not indicated. We need
            // to submit a request and wait for the rest of
            // the data.
            //
            request = CnpAllocateReceiveRequest(
                          CnpReceiveRequestPool,
                          network,
                          BytesAvailable,
                          CnpCompleteReceivePacket
                          );
            if (request != NULL) {

                PCNP_RECEIVE_CONTEXT  context;
                ULONG                 refCount;

                context = request->UpperProtocolContext;

                context->TdiReceiveDatagramFlags = ReceiveDatagramFlags;
                context->TsduSize = BytesAvailable;
                context->Network = network;
                context->CnpReceiveFlags = cnpRecvFlags;

                //
                // Take a reference on the network so that it
                // doesn't disappear before the IRP completes.
                //
                CnAcquireLock(&(network->Lock), &(network->Irql));
                refCount = CnpActiveReferenceNetwork(network);
                CnReleaseLock(&(network->Lock), network->Irql);

                if (refCount == 0) {
                    // This Network is being closed down. We
                    // cannot retrieve or deliver the data. Drop
                    // the packet.
                    CnpFreeReceiveRequest(request);
                    goto error_exit;
                }

                *Irp = request->Irp;

                CnTrace(CNP_RECV_DETAIL, CnpTraceCompleteReceive,
                    "[CNP] Fetching CNP multicast data, src "
                    "node %u, BI %u, BA %u, CNP flags %x.",
                    cnpHeader->SourceAddress, // LOGULONG
                    BytesIndicated, // LOGULONG
                    BytesAvailable, // LOGULONG
                    context->CnpReceiveFlags // LOGXLONG
                    );

                CnVerifyCpuLockMask(
                    0,                // Required
                    0xFFFFFFFF,       // Forbidden
                    0                 // Maximum
                    );

                return(STATUS_MORE_PROCESSING_REQUIRED);

            }

            CnTrace(CNP_RECV_ERROR, CnpTraceDropReceiveNoIrp,
                "[CNP] Dropping packet: failed to allocate "
                "receive request."
                );

            //
            // Out of resources. Drop the packet.
            //
            goto error_exit;
        }

    } else {

        //
        // Unicast packets do not need to verified.
        //
        consumed = sizeof(CNP_HEADER);
    }

    //
    // Deliver the packet to the appropriate upper layer protocol.
    //
    *BytesTaken = consumed;
    BytesIndicated -= consumed;
    BytesAvailable -= consumed;

    return (CnpIndicateData(
                network,
                cnpHeader->NextHeader,
                cnpHeader->SourceAddress,
                cnpRecvFlags,
                ReceiveDatagramFlags,
                BytesIndicated,
                BytesAvailable,
                BytesTaken,
                (PUCHAR)Tsdu + consumed,
                Irp
                )
            );

error_exit:

    //
    // Something went wrong. Drop the packet by
    // indicating that we consumed it.
    //

    *BytesTaken = BytesAvailable;
    *Irp = NULL;

    CnTrace(CNP_RECV_ERROR, CnpTraceDropReceive,
        "[CNP] Dropped packet from net %u, BI %u, BA %u, CNP flags %x.",
        network->Id, // LOGULONG
        BytesIndicated, // LOGULONG
        BytesAvailable, // LOGULONG
        cnpRecvFlags // LOGXLONG
        );

    IF_CNDBG(CN_DEBUG_CNPRECV) {
        CNPRINT(("[CNP] Dropped packet from net %u, BI %u, BA %u.\n",
                 network->Id, BytesIndicated, BytesAvailable));
    }

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CnpTdiReceiveDatagramHandler
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnpif.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnpif.c

Abstract:

    Interface management routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           January 6, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-06-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpif.tmh"

#include <ntddndis.h>


//
// Routines exported within CNP
//
BOOLEAN
CnpIsBetterInterface(
    PCNP_INTERFACE            Interface1,
    PCNP_INTERFACE            Interface2
    )
{
    if ( (Interface2 == NULL)
         ||
         (Interface1->State > Interface2->State)
         ||
         ( (Interface1->State == Interface2->State)
           &&
           CnpIsHigherPriority(Interface1->Priority, Interface2->Priority)
         )
       )
    {
        return(TRUE);
    }

    return(FALSE);
}

VOID
CnpWalkInterfacesOnNode(
    PCNP_NODE                      Node,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    )
/*++

Routine Description:

    Walks the interface list of a node and performs a specified
    operation on each interface.

Arguments:

    Node    - The node on which to operate.

    UpdateRoutine - The operation to perform on each interface.

Return Value:

    None.

Notes:

    Called with node object lock held.

    Valid Update Routines:

        CnpOnlinePendingInterfaceWrapper
        CnpOfflineInterfaceWrapper

--*/
{
    PLIST_ENTRY      entry, nextEntry;
    PCNP_INTERFACE   interface;



    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,      // Required
        0,                         // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX   // Maximum
        );

    entry = Node->InterfaceList.Flink;

    while (entry != &(Node->InterfaceList)) {
        //
        // Save a pointer to the next entry now in case we delete the
        // current entry.
        //
        nextEntry = entry->Flink;

        interface = CONTAINING_RECORD(
                        entry,
                        CNP_INTERFACE,
                        NodeLinkage
                        );

        CnAcquireLockAtDpc(&(interface->Network->Lock));
        interface->Network->Irql = DISPATCH_LEVEL;

        (*UpdateRoutine)(interface);

        //
        // The network object lock was released.
        //

        entry = nextEntry;
    }

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,      // Required
        0,                         // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX   // Maximum
        );

    return;

} // CnpWalkInterfacesOnNode



VOID
CnpWalkInterfacesOnNetwork(
    PCNP_NETWORK                   Network,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    )
/*++

Routine Description:

    Walks the node table and the interface list of each node looking
    for interfaces on a specified network. Performs a specified operation
    on each matching interface.

Arguments:

    Network    - The target network.

    UpdateRoutine - The operation to perform on each matching interface.

Return Value:

    None.

Notes:

    Called with no locks held.

    Valid Update Routines:

        CnpOnlinePendingInterfaceWrapper
        CnpOfflineInterfaceWrapper
        CnpDeleteInterface
        CnpRecalculateInterfacePriority

--*/
{
    ULONG            i;
    CN_IRQL          tableIrql;
    PCNP_NODE        node;
    PLIST_ENTRY      entry;
    PCNP_INTERFACE   interface;


    CnVerifyCpuLockMask(
        0,                         // Required
        CNP_LOCK_RANGE,            // Forbidden
        CNP_PRECEEDING_LOCK_RANGE  // Maximum
        );

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);

    for (i=CnMinValidNodeId; i <= CnMaxValidNodeId; i++) {
        node = CnpNodeTable[i];

        if (node != NULL) {

            CnAcquireLockAtDpc(&(node->Lock));
            CnReleaseLockFromDpc(&CnpNodeTableLock);
            node->Irql = tableIrql;

            for (entry = node->InterfaceList.Flink;
                 entry != &(node->InterfaceList);
                 entry = entry->Flink
                )
            {
                interface = CONTAINING_RECORD(
                                entry,
                                CNP_INTERFACE,
                                NodeLinkage
                                );

                if (interface->Network == Network) {

                    CnAcquireLockAtDpc(&(Network->Lock));
                    Network->Irql = DISPATCH_LEVEL;

                    (*UpdateRoutine)(interface);

                    //
                    // The network object lock was released.
                    // The node object lock is still held.
                    //

                    break;
                }
            }

            CnReleaseLock(&(node->Lock), node->Irql);
            CnAcquireLock(&CnpNodeTableLock, &tableIrql);
        }
    }

    CnReleaseLock(&CnpNodeTableLock, tableIrql);

    CnVerifyCpuLockMask(
        0,                         // Required
        CNP_LOCK_RANGE,            // Forbidden
        CNP_PRECEEDING_LOCK_RANGE  // Maximum
        );

    return;

} // CnpWalkInterfacesOnNetwork



NTSTATUS
CnpOnlinePendingInterface(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Changes an Offline interface to the OnlinePending state.
    This will enable heartbeats over this interface. When a heartbeat
    is established, the interface will move to the Online state.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    An NT status value.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    NTSTATUS                 status = STATUS_SUCCESS;
    PCNP_NODE                node = Interface->Node;
    PCNP_NETWORK             network = Interface->Network;
    BOOLEAN                  networkLocked = TRUE;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if ( (Interface->State == ClusnetInterfaceStateOffline) &&
         (network->State == ClusnetNetworkStateOnline) &&

         // Place an active reference on the associated network,
         // and verify that it is not going away.
         (CnpActiveReferenceNetwork(network))
       )
    {
        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to OnlinePending state.\n",
                node->Id,
                network->Id
                ));

        Interface->State = ClusnetInterfaceStateOnlinePending;
        Interface->MissedHBs = 0;

        //
        // Update the node's CurrentInterface if appropriate.
        //
        if ( !CnpIsNetworkRestricted(network) &&
             !CnpIsNetworkLocalDisconn(network) &&
             CnpIsBetterInterface(Interface, node->CurrentInterface)
           )
        {
            node->CurrentInterface = Interface;

            IF_CNDBG( CN_DEBUG_IFOBJ )
                CNPRINT((
                    "[CNP] Network %u is now the best route to node %u\n",
                    network->Id,
                    node->Id
                    ));

            if (CnpIsNodeUnreachable(node)) {
                CnTrace(
                    CNP_IF_DETAIL,
                    CnpTraceOnlinePendingIfReach,
                    "[CNP] Declaring node %u reachable after "
                    "setting interface on network %u to online pending.\n",
                    node->Id, network->Id
                    );
                CnpDeclareNodeReachable(node);
            }
        }

        //
        // Clear multicast-received flag and start multicast discovery
        // packets.
        //
        // This call releases the network lock.
        //
        if (CnpIsNetworkMulticastCapable(network)) {
            CnpStartInterfaceMcastTransition(Interface);
            networkLocked = FALSE;
        }
    }
    else {
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    if (networkLocked) {
        CnReleaseLockFromDpc(&(network->Lock));
        networkLocked = FALSE;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpOnlinePendingInterface



VOID
CnpOnlinePendingInterfaceWrapper(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Wrapper for CnpOnlinePendingInterface that conforms to the calling
    convention for PCNP_INTERFACE_UPDATE_ROUTINE.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    (VOID) CnpOnlinePendingInterface(Interface);

    return;

} // CnpOnlinePendingInterfaceWrapper


NTSTATUS
CnpOfflineInterface(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Called to change an interface to the Offline state
    when the associated network goes offline or the interface
    is being deleted.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    An NT status value.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    NTSTATUS             status = STATUS_SUCCESS;
    PCNP_NODE            node = Interface->Node;
    PCNP_NETWORK         network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if (Interface->State != ClusnetInterfaceStateOffline) {

        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to Offline state.\n",
                node->Id,
                network->Id
                ));

        Interface->State = ClusnetInterfaceStateOffline;

        //
        // Release the network lock.
        //
        CnReleaseLock(&(network->Lock), network->Irql);

        //
        // Update the node's CurrentInterface value if appropriate.
        //
        if (node->CurrentInterface == Interface) {
            CnpUpdateNodeCurrentInterface(node);

            if ( !CnpIsNodeUnreachable(node)
                 &&
                 ( (node->CurrentInterface == NULL) ||
                   ( node->CurrentInterface->State <
                     ClusnetInterfaceStateOnlinePending
                   )
                 )
               )
            {
                //
                // This node is now unreachable.
                //
                CnTrace(
                    CNP_IF_DETAIL,
                    CnpTraceOfflineIfUnreach,
                    "[CNP] Declaring node %u unreachable after "
                    "taking interface on network %u offline.\n",
                    node->Id, network->Id
                    );

                CnpDeclareNodeUnreachable(node);
            }
        }

        //
        // Change the node's reachability status via this network.
        //
        CnpMulticastChangeNodeReachability(
            network,
            node,
            FALSE,    // not reachable
            TRUE,     // raise event
            NULL      // OUT new mask
            );

        //
        // Remove the active reference on the associated network.
        // This releases the network lock.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
        CnpActiveDereferenceNetwork(network);
    }
    else {
        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpOfflineInterface



VOID
CnpOfflineInterfaceWrapper(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Wrapper for CnpOfflineInterface that conforms to the calling
    convention for PCNP_INTERFACE_UPDATE_ROUTINE.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    (VOID) CnpOfflineInterface(Interface);

    return;

} // CnpOfflineInterfaceWrapper



NTSTATUS
CnpOnlineInterface(
    PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Called to change an OnlinePending interface to the Online state
    after a heartbeat has been (re)established.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    NTSTATUS             status = STATUS_SUCCESS;
    PCNP_NODE            node = Interface->Node;
    PCNP_NETWORK         network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if ( (network->State == ClusnetNetworkStateOnline) &&
         ( (Interface->State == ClusnetInterfaceStateOnlinePending) ||
           (Interface->State == ClusnetInterfaceStateUnreachable)
         )
       )
    {
        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to Online state.\n",
                node->Id,
                network->Id
                ));

        //
        // Move the interface to the online state.
        //
        Interface->State = ClusnetInterfaceStateOnline;

        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));

        //
        // Update the node's CurrentInterface if appropriate.
        //
        if (!CnpIsNetworkRestricted(network) &&
            !CnpIsNetworkLocalDisconn(network) ) {

            if (CnpIsBetterInterface(Interface, node->CurrentInterface)) {
                node->CurrentInterface = Interface;

                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                        "[CNP] Network %u is now the best route to node %u\n",
                        network->Id,
                        node->Id
                        ));
            }

            if (CnpIsNodeUnreachable(node)) {
                CnTrace(
                    CNP_IF_DETAIL,
                    CnpTraceOnlineIfReach,
                    "[CNP] Declaring node %u reachable after "
                    "bring interface on network %u online.\n",
                    node->Id, network->Id
                    );
                CnpDeclareNodeReachable(node);
            }
        }
    }
    else {
        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpOnlineInterface



NTSTATUS
CnpFailInterface(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Called to change an Online or OnlinePending interface to the Failed
    state after the heartbeat has been lost for some time.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    NTSTATUS             status = STATUS_SUCCESS;
    PCNP_NODE            node = Interface->Node;
    PCNP_NETWORK         network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if ( (network->State == ClusnetNetworkStateOnline) &&
         (Interface->State >= ClusnetInterfaceStateOnlinePending)
       )
    {
        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to Failed state.\n",
                node->Id,
                network->Id
                ));

        Interface->State = ClusnetInterfaceStateUnreachable;

        //
        // Clear the multicast received flag so that we "rediscover"
        // multicast if ever this interface comes back up.
        //
        if (Interface->Node != CnpLocalNode) {
            CnpInterfaceClearReceivedMulticast(Interface);
        }

        CnAssert(network->Irql == DISPATCH_LEVEL);

        //
        // Reference the network so that it can't be deleted
        // while we release the lock.
        //
        CnpReferenceNetwork(network);

        CnReleaseLockFromDpc(&(network->Lock));

        //
        // Update the node's CurrentInterface value if appropriate.
        //
        if (node->CurrentInterface == Interface) {
            CnpUpdateNodeCurrentInterface(node);

            if ( (node->CurrentInterface == NULL)
                 ||
                 ( node->CurrentInterface->State <
                   ClusnetInterfaceStateOnlinePending
                 )
               )
            {
                //
                // This node is now unreachable.
                //
                CnTrace(
                    CNP_IF_DETAIL,
                    CnpTraceFailIfUnreach,
                    "[CNP] Declaring node %u unreachable after "
                    "marking interface on network %u failed.\n",
                    node->Id, network->Id
                    );

                CnpDeclareNodeUnreachable(node);
            }
        }

        //
        // Change the node's reachability status via this network.
        //
        CnpMulticastChangeNodeReachability(
            network,
            node,
            FALSE,      // not reachable
            TRUE,       // raise event
            NULL        // OUT new mask
            );

        //
        // Drop the network reference. This releases the network
        // lock.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
        CnpDereferenceNetwork(network);
    }
    else {
        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpFailInterface



VOID
CnpDeleteInterface(
    IN PCNP_INTERFACE Interface
    )
/*++

/*++

Routine Description:

    Called to delete an interface.

Arguments:

    Interface - A pointer to the interface to delete.

Return Value:

    None.

Notes:

    Called with node and network object locks held.
    Returns with the network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    CL_NODE_ID      nodeId = Interface->Node->Id;
    CL_NETWORK_ID   networkId = Interface->Network->Id;
    PCNP_NODE       node = Interface->Node;
    PCNP_NETWORK    network = Interface->Network;
    BOOLEAN         isLocal = FALSE;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    IF_CNDBG( CN_DEBUG_IFOBJ )
        CNPRINT((
            "[CNP] Deleting interface (%u, %u)\n",
            nodeId,
            networkId
            ));

    if (Interface->State >= ClusnetInterfaceStateUnreachable) {
        (VOID) CnpOfflineInterface(Interface);

        //
        // The call released the network lock.
        // Reacquire it.
        //
        CnAcquireLockAtDpc(&(network->Lock));
        network->Irql = DISPATCH_LEVEL;
    }

    //
    // Remove the interface from the node's interface list.
    //
#if DBG
    {
        PLIST_ENTRY      entry;
        PCNP_INTERFACE   oldInterface = NULL;


        for (entry = node->InterfaceList.Flink;
             entry != &(node->InterfaceList);
             entry = entry->Flink
            )
        {
            oldInterface = CONTAINING_RECORD(
                            entry,
                            CNP_INTERFACE,
                            NodeLinkage
                            );

            if (oldInterface == Interface) {
                break;
            }
        }

        CnAssert(oldInterface == Interface);
    }
#endif // DBG

    RemoveEntryList(&(Interface->NodeLinkage));

    //
    // Remove the base reference that this node had on the network.
    // This releases the network lock.
    //
    CnpDereferenceNetwork(network);

    //
    //  Update the node's CurrentInterface if appropriate.
    //
    if (node->CurrentInterface == Interface) {
        if (IsListEmpty(&(node->InterfaceList))) {
            node->CurrentInterface = NULL;
        }
        else {
            CnpUpdateNodeCurrentInterface(node);
        }
    }

    CnFreePool(Interface);

    IF_CNDBG( CN_DEBUG_IFOBJ )
        CNPRINT((
            "[CNP] Deleted interface (%u, %u)\n",
            nodeId,
            networkId
            ));

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpDeleteInterface



VOID
CnpReevaluateInterfaceRole(
    IN PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Reevaluates the role of an interface after the corresponding network's
    restriction state has been changed.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE      node = Interface->Node;
    PCNP_NETWORK   network = Interface->Network;
    BOOLEAN        restricted = CnpIsNetworkRestricted(network);


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    //
    // We don't really need the network lock.  It's just part of
    // the calling convention.
    //
    CnReleaseLockFromDpc(&(network->Lock));

    if (restricted) {
        if (node->CurrentInterface == Interface) {
            CnpUpdateNodeCurrentInterface(node);
        }
    }
    else if (node->CurrentInterface != Interface) {
        CnpUpdateNodeCurrentInterface(node);
    }

    if (node->CurrentInterface == NULL && !CnpIsNodeUnreachable(node)) {

        //
        // This node is now unreachable.
        //
        CnTrace(
            CNP_IF_DETAIL,
            CnpTraceEvalRoleUnreach,
            "[CNP] Declaring node %u unreachable after "
            "evaluating role of interface on network %u.\n",
            node->Id, network->Id
            );

        CnpDeclareNodeUnreachable(node);

    } else if (node->CurrentInterface != NULL && CnpIsNodeUnreachable(node)) {

        //
        // This node may now be reachable.
        //
        CnTrace(
            CNP_IF_DETAIL,
            CnpTraceEvalRoleReach,
            "[CNP] Declaring node %u reachable after "
            "evaluating role of interface on network %u.\n",
            node->Id, network->Id
            );
        CnpDeclareNodeReachable(node);
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpReevaluateInterfaceRole



VOID
CnpRecalculateInterfacePriority(
    IN PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Recalculates the priority of interfaces which get their
    priority from their associated network. Called after the network's
    priority changes.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE      node = Interface->Node;
    PCNP_NETWORK   network = Interface->Network;
    ULONG          networkPriority = network->Priority;
    ULONG          oldPriority = Interface->Priority;
    BOOLEAN        restricted = CnpIsNetworkRestricted(network);
    BOOLEAN        localDisconn = CnpIsNetworkLocalDisconn(network);


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    //
    // We don't really need the network lock.  It's just part of
    // the calling convention.
    //
    CnReleaseLockFromDpc(&(network->Lock));

    if (CnpIsInterfaceUsingNetworkPriority(Interface)) {
        Interface->Priority = networkPriority;

        if (!restricted) {
            if (Interface == node->CurrentInterface) {
                if (CnpIsLowerPriority(Interface->Priority, oldPriority)) {
                    //
                    // Our priority got worse. Recalculate the best route.
                    //
                    CnpUpdateNodeCurrentInterface(node);
                }
                //
                // Else, priority same or better. Nothing to do.
                //
            }
            else if ( !localDisconn &&
                      CnpIsBetterInterface(
                          Interface,
                          node->CurrentInterface
                          )
                    )
            {
                //
                // Our priority got better.
                //
                IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ ))
                    CNPRINT((
                        "[CNP] Network %u is now the best route to node %u\n",
                        network->Id,
                        node->Id
                        ));

                node->CurrentInterface = Interface;
            }
        }
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpRecalculateInterfacePriority



VOID
CnpUpdateNodeCurrentInterface(
    IN PCNP_NODE  Node
    )
/*++

Routine Description:

    Called to determine the best available interface for a node
    after one of its interfaces changes state or priority.

Arguments:

    Node  - A pointer to the node on which to operate.

Return Value:

    None.

Notes:

    Called with node object lock held.

--*/
{
    PLIST_ENTRY      entry;
    PCNP_INTERFACE   interface;
    PCNP_INTERFACE   bestInterface = NULL;


    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,     // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    CnAssert(!IsListEmpty(&(Node->InterfaceList)));
    // CnAssert(Node->CurrentInterface != NULL);

    for (entry = Node->InterfaceList.Flink;
         entry != &(Node->InterfaceList);
         entry = entry->Flink
        )
    {
        interface = CONTAINING_RECORD(entry, CNP_INTERFACE, NodeLinkage);

        if ( !CnpIsNetworkRestricted(interface->Network) &&
             !CnpIsNetworkLocalDisconn(interface->Network) &&
             CnpIsBetterInterface(interface, bestInterface)
           )
        {
            bestInterface = interface;
        }
    }

    Node->CurrentInterface = bestInterface;

    IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ )) {
        if (bestInterface == NULL) {
            CNPRINT((
                "[CNP] No route for node %u!!!!\n",
                Node->Id
                ));
        }
        else {
            CNPRINT((
                "[CNP] Best route for node %u is now network %u.\n",
                Node->Id,
                bestInterface->Network->Id
                ));
        }
    }

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,     // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpUpdateNodeCurrentInterface



VOID
CnpResetAndOnlinePendingInterface(
    IN PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Resets the sequence numbers used to authenticate packets
    sent by a node over a particular network. Also takes the
    node's interface online.

    This operation is performed when a node is joining a cluster.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE          node = Interface->Node;
    PCNP_NETWORK       network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ ))
        CNPRINT((
            "[CNP] Reseting sequence numbers for node %u on network %u\n",
            node->Id,
            network->Id
            ));

    Interface->SequenceToSend = 0;
    Interface->LastSequenceReceived = 0;

    //
    // Take the interface online.
    //
    (VOID) CnpOnlinePendingInterface(Interface);

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpRecalculateInterfacePriority



NTSTATUS
CnpFindInterface(
    IN  CL_NODE_ID         NodeId,
    IN  CL_NETWORK_ID      NetworkId,
    OUT PCNP_INTERFACE *   Interface
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    PLIST_ENTRY        entry;


    CnVerifyCpuLockMask(
        0,                          // Required
        0,                          // Forbidden
        CNP_PRECEEDING_LOCK_RANGE   // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status ==  STATUS_SUCCESS) {

        network = CnpFindNetwork(NetworkId);

        if (network != NULL) {

            for (entry = node->InterfaceList.Flink;
                 entry != &(node->InterfaceList);
                 entry = entry->Flink
                )
            {
                interface = CONTAINING_RECORD(
                                entry,
                                CNP_INTERFACE,
                                NodeLinkage
                                );

                if (interface->Network == network) {
                    *Interface = interface;

                    CnVerifyCpuLockMask(
                        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),
                        0,                            // Forbidden
                        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
                        );

                    return(STATUS_SUCCESS);
                }
            }

            CnReleaseLock(&(network->Lock), network->Irql);
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0,                          // Forbidden
        CNP_PRECEEDING_LOCK_RANGE   // Maximum
        );

    return(STATUS_CLUSTER_NETINTERFACE_NOT_FOUND);

}  // CnpFindInterface



//
// Cluster Transport Public Routines
//
NTSTATUS
CxRegisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    PUWSTR              AdapterId,
    ULONG               AdapterIdLength,
    ULONG               TdiAddressLength,
    PTRANSPORT_ADDRESS  TdiAddress,
    PULONG              MediaStatus
    )
{
    NTSTATUS           status;
    PLIST_ENTRY        entry;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    ULONG              allocSize;
    PWCHAR             adapterDevNameBuffer = NULL;
    HANDLE             adapterDevHandle = NULL;
    BOOLEAN            localAdapter = FALSE;

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    //
    // Allocate and initialize an interface object.
    //
    allocSize = FIELD_OFFSET(CNP_INTERFACE, TdiAddress) + TdiAddressLength;

    interface = CnAllocatePool(allocSize);

    if (interface == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(interface, allocSize);

    CN_INIT_SIGNATURE(interface, CNP_INTERFACE_SIG);
    interface->State = ClusnetInterfaceStateOffline;

    RtlMoveMemory(&(interface->TdiAddress), TdiAddress, TdiAddressLength);
    interface->TdiAddressLength = TdiAddressLength;

    //
    // Register the new interface object
    //
    status = CnpValidateAndFindNode(NodeId, &node);

    if (NT_SUCCESS(status)) {

        //
        // If this adapter is on the local node, use the adapter ID
        // to find the corresponding WMI Provider ID.
        //
        localAdapter = (BOOLEAN)(node == CnpLocalNode);
        if (localAdapter) {

            PWCHAR             adapterDevNamep, brace;
            PFILE_OBJECT       adapterFileObject;
            PDEVICE_OBJECT     adapterDeviceObject;

            // first drop the node lock
            CnReleaseLock(&(node->Lock), node->Irql);

            // allocate a buffer for the adapter device name
            allocSize = wcslen(L"\\Device\\") * sizeof(WCHAR)
                        + AdapterIdLength
                        + sizeof(UNICODE_NULL);
            brace = L"{";
            if (*((PWCHAR)AdapterId) != *brace) {
                allocSize += 2 * sizeof(WCHAR);
            }
            adapterDevNameBuffer = CnAllocatePool(allocSize);
            if (adapterDevNameBuffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto error_exit;
            }

            // build the adapter device name from the adapter ID
            RtlZeroMemory(adapterDevNameBuffer, allocSize);

            adapterDevNamep = adapterDevNameBuffer;

            RtlCopyMemory(
                adapterDevNamep,
                L"\\Device\\",
                wcslen(L"\\Device\\") * sizeof(WCHAR)
                );

            adapterDevNamep += wcslen(L"\\Device\\");

            if (*((PWCHAR)AdapterId) != *brace) {
                *adapterDevNamep = *brace;
                adapterDevNamep++;
            }

            RtlCopyMemory(adapterDevNamep, AdapterId, AdapterIdLength);

            if (*((PWCHAR)AdapterId) != *brace) {
                brace = L"}";
                adapterDevNamep =
                    (PWCHAR)((PUCHAR)adapterDevNamep + AdapterIdLength);
                *adapterDevNamep = *brace;
            }

            // open the adapter device
            status = CnpOpenDevice(
                         adapterDevNameBuffer,
                         &adapterDevHandle
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                             "[CNP] Failed to open adapter "
                             "device %S while registering "
                             "interface (%u, %u), status %lx.\n",
                             adapterDevNameBuffer,
                             NodeId,
                             NetworkId,
                             status
                             ));
                goto error_exit;
            }

            status = ObReferenceObjectByHandle(
                         adapterDevHandle,
                         0L,  // DesiredAccess
                         NULL,
                         KernelMode,
                         &adapterFileObject,
                         NULL
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                             "[CNP] Failed to reference handle "
                             "for adapter device %S while "
                             "registering interface (%u, %u), "
                             "status %lx.\n",
                             adapterDevNameBuffer,
                             NodeId,
                             NetworkId,
                             status
                             ));
                ZwClose(adapterDevHandle);
                adapterDevHandle = NULL;
                goto error_exit;
            }

            adapterDeviceObject = IoGetRelatedDeviceObject(
                                      adapterFileObject
                                      );

            // convert the adapter device object into the
            // WMI provider ID
            interface->AdapterWMIProviderId =
                IoWMIDeviceObjectToProviderId(adapterDeviceObject);

            IF_CNDBG( CN_DEBUG_IFOBJ )
                CNPRINT((
                         "[CNP] Found WMI Provider ID %lx for adapter "
                         "device %S while "
                         "registering interface (%u, %u).\n",
                         interface->AdapterWMIProviderId,
                         adapterDevNameBuffer,
                         NodeId,
                         NetworkId
                         ));

            // we no longer need the file object or device name
            // buffer, but we hold onto the adapter device handle
            // in order to query the current media status.
            ObDereferenceObject(adapterFileObject);
            CnFreePool(adapterDevNameBuffer);
            adapterDevNameBuffer = NULL;

            // reacquire the local node lock
            status = CnpValidateAndFindNode(NodeId, &node);

            if (!NT_SUCCESS(status)) {
                status = STATUS_CLUSTER_NODE_NOT_FOUND;
                goto error_exit;
            }
        }

        network = CnpFindNetwork(NetworkId);

        if (network != NULL) {
            //
            // Check if the specified interface already exists.
            //
            status = STATUS_SUCCESS;

            for (entry = node->InterfaceList.Flink;
                 entry != &(node->InterfaceList);
                 entry = entry->Flink
                )
            {
                PCNP_INTERFACE  oldInterface = CONTAINING_RECORD(
                                                   entry,
                                                   CNP_INTERFACE,
                                                   NodeLinkage
                                                   );

                if (oldInterface->Network == network) {
                    status = STATUS_CLUSTER_NETINTERFACE_EXISTS;
                    break;
                }
            }

            if (NT_SUCCESS(status)) {

                interface->Node = node;
                interface->Network = network;

                if (Priority != 0) {
                    interface->Priority = Priority;
                }
                else {
                    interface->Priority = network->Priority;
                    interface->Flags |= CNP_IF_FLAG_USE_NETWORK_PRIORITY;
                }

                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                             "[CNP] Registering interface (%u, %u) pri %u...\n",
                             NodeId,
                             NetworkId,
                             interface->Priority
                             ));

                //
                // Place a reference on the network for this interface.
                //
                CnpReferenceNetwork(network);

                //
                // Insert the interface into the node's interface list.
                //
                InsertTailList(
                    &(node->InterfaceList),
                    &(interface->NodeLinkage)
                    );

                //
                // Update the node's CurrentInterface if appropriate.
                //
                if ( !CnpIsNetworkRestricted(network) &&
                     !CnpIsNetworkLocalDisconn(network) &&
                     CnpIsBetterInterface(interface, node->CurrentInterface)
                   )
                {
                    IF_CNDBG( CN_DEBUG_IFOBJ )
                        CNPRINT((
                            "[CNP] Network %u is now the best route to node %u.\n",
                            network->Id,
                            node->Id
                            ));

                    node->CurrentInterface = interface;

                    if (CnpIsNodeUnreachable(node)) {
                        CnTrace(
                            CNP_IF_DETAIL,
                            CnpTraceOnlinePendingIfReach,
                            "[CNP] Declaring node %u reachable after "
                            "registering interface on network %u.\n",
                            node->Id, network->Id
                            );
                        CnpDeclareNodeReachable(node);
                    }
                }

                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                        "[CNP] Registered interface (%u, %u).\n",
                        NodeId,
                        NetworkId
                        ));

                if (network->State == ClusnetNetworkStateOnline) {
                    (VOID) CnpOnlinePendingInterface(interface);

                    //
                    // The network lock was released.
                    //
                }
                else {
                    CnReleaseLockFromDpc(&(network->Lock));
                }

                CnReleaseLock(&(node->Lock), node->Irql);

                //
                // Determine the initial media status state of this
                // interface if it is local.
                //
                if (localAdapter) {
                    CxQueryMediaStatus(
                        adapterDevHandle,
                        NetworkId,
                        MediaStatus
                        );
                } else {
                    //
                    // Assume remote interfaces are connected
                    //
                    *MediaStatus = NdisMediaStateConnected;
                }

                if (adapterDevHandle != NULL) {
                    ZwClose(adapterDevHandle);
                    adapterDevHandle = NULL;
                }

                return(STATUS_SUCCESS);
            }

            CnReleaseLockFromDpc(&(network->Lock));
        }
        else {
            status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }
    else {
        status = STATUS_CLUSTER_NODE_NOT_FOUND;
    }

error_exit:

    if (!NT_SUCCESS(status)) {
        CnFreePool(interface);
    }

    if (adapterDevHandle != NULL) {
        ZwClose(adapterDevHandle);
        adapterDevHandle = NULL;
    }

    if (adapterDevNameBuffer != NULL) {
        CnFreePool(adapterDevNameBuffer);
        adapterDevNameBuffer = NULL;
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

} // CxRegisterInterface



NTSTATUS
CxDeregisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    ULONG              i;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    CN_IRQL            tableIrql;


    if ((NodeId == ClusterAnyNodeId) && (NetworkId == ClusterAnyNetworkId)) {
        //
        // Destroy all interfaces on all networks.
        //
        IF_CNDBG(( CN_DEBUG_IFOBJ | CN_DEBUG_CLEANUP ))
            CNPRINT(("[CNP] Destroying all interfaces on all networks\n"));

        CnAcquireLock(&CnpNodeTableLock, &tableIrql);

        CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
        CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);

        for (i=CnMinValidNodeId; i <= CnMaxValidNodeId; i++) {
            node = CnpNodeTable[i];

            if (node != NULL) {
                CnAcquireLockAtDpc(&(node->Lock));
                CnReleaseLockFromDpc(&CnpNodeTableLock);
                node->Irql = tableIrql;

                CnpWalkInterfacesOnNode(node, CnpDeleteInterface);

                CnReleaseLock(&(node->Lock), node->Irql);
                CnAcquireLock(&CnpNodeTableLock, &tableIrql);
            }
        }

        CnReleaseLock(&CnpNodeTableLock, tableIrql);

        status = STATUS_SUCCESS;
    }
    else if (NodeId == ClusterAnyNodeId) {
        //
        // Destroy all interfaces on a specific network.
        //
        IF_CNDBG(( CN_DEBUG_IFOBJ | CN_DEBUG_NETOBJ | CN_DEBUG_CLEANUP ))
            CNPRINT((
                     "[CNP] Destroying all interfaces on network %u\n",
                     NetworkId
                     ));

        network = CnpFindNetwork(NetworkId);

        if (network != NULL) {
            CnpReferenceNetwork(network);
            CnReleaseLock(&(network->Lock), network->Irql);

            CnpWalkInterfacesOnNetwork(network, CnpDeleteInterface);

            CnAcquireLock(&(network->Lock), &(network->Irql));
            CnpDereferenceNetwork(network);

            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
        }
    }
    else if (NetworkId == ClusterAnyNetworkId) {
        //
        // Destroy all interfaces on a specified node.
        //
        IF_CNDBG(( CN_DEBUG_IFOBJ | CN_DEBUG_NODEOBJ | CN_DEBUG_CLEANUP ))
            CNPRINT((
                     "[CNP] Destroying all interfaces on node %u\n",
                     NodeId
                     ));

        status = CnpValidateAndFindNode(NodeId, &node);

        if (status == STATUS_SUCCESS) {
            CnpWalkInterfacesOnNode(node, CnpDeleteInterface);
            CnReleaseLock(&(node->Lock), node->Irql);
        }
    }
    else {
        //
        // Delete a specific interface
        //
        status = CnpFindInterface(NodeId, NetworkId, &interface);

        if (NT_SUCCESS(status)) {
            node = interface->Node;

            CnpDeleteInterface(interface);
            //
            // The network lock was released.
            //

            CnReleaseLock(&(node->Lock), node->Irql);
        }
    }

    return(status);

}  // CxDeregisterNetwork



NTSTATUS
CxSetInterfacePriority(
    IN CL_NODE_ID          NodeId,
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               Priority
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    ULONG              oldPriority;
    BOOLEAN            restricted;
    BOOLEAN            localDisconn;



    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        oldPriority = interface->Priority;
        restricted = CnpIsNetworkRestricted(network);
        localDisconn = CnpIsNetworkLocalDisconn(network);

        if (Priority != 0) {
            interface->Priority = Priority;
            interface->Flags &= ~(CNP_IF_FLAG_USE_NETWORK_PRIORITY);
        }
        else {
            interface->Priority = network->Priority;
            interface->Flags |= CNP_IF_FLAG_USE_NETWORK_PRIORITY;
        }

        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Set interface (%u, %u) to priority %u\n",
                NodeId,
                NetworkId,
                interface->Priority
                ));

        CnReleaseLockFromDpc(&(network->Lock));

        if (!restricted) {
            if (interface == node->CurrentInterface) {
                if (interface->Priority > oldPriority) {
                    //
                    // Our priority got worse. Recalculate the best route.
                    //
                    CnpUpdateNodeCurrentInterface(node);
                }
                //
                // Else interface priority is same or better. Nothing to do.
                //
            }
            else if ( !localDisconn &&
                      CnpIsBetterInterface(
                          interface,
                          node->CurrentInterface
                          )
                    )
            {
                //
                // Our priority got better.
                //
                IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ ))
                    CNPRINT((
                        "[CNP] Network %u is now the best route to node %u\n",
                        network->Id,
                        node->Id
                        ));

                node->CurrentInterface = interface;
            }
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxSetInterfacePriority



NTSTATUS
CxGetInterfacePriority(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        *NetworkPriority = network->Priority;

        if (CnpIsInterfaceUsingNetworkPriority(interface)) {
            *InterfacePriority = 0;
        }
        else {
            *InterfacePriority = interface->Priority;
        }

        CnReleaseLockFromDpc(&(network->Lock));

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxGetInterfacePriority



NTSTATUS
CxGetInterfaceState(
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    )
{
    NTSTATUS       status;
    PCNP_INTERFACE interface;
    PCNP_NODE      node;
    PCNP_NETWORK   network;

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status == STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        *State = interface->State;

        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxGetInterfaceState



//
// Test APIs
//
#if DBG


NTSTATUS
CxOnlinePendingInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        status = CnpOnlinePendingInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOnlinePendingInterface



NTSTATUS
CxOnlineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;

        status = CnpOnlineInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOnlineInterface



NTSTATUS
CxOfflineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;

        status = CnpOfflineInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOfflineInterface


NTSTATUS
CxFailInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;

        status = CnpFailInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOfflineInterface



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnpdef.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cnpdef.h

Abstract:

    Main private header file for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#ifndef _CNPDEF_INCLUDED_
#define _CNPDEF_INCLUDED_

#include <fipsapi.h>
#include <sspi.h>

//
// Forward declarations
//
typedef struct _CNP_INTERFACE *PCNP_INTERFACE;

//
// Priority definitions
//
#define CnpIsHigherPriority(_p1, _p2)      ((_p1) < (_p2))
#define CnpIsLowerPriority(_p1, _p2)       ((_p1) > (_p2))
#define CnpIsEqualPriority(_p1, _p2)       ((_p1) == (_p2))


//
// Multicast Group Object
//
// This structure contains the data needed to implement a multicast
// endpoint on a network.
//
typedef struct _CNP_MULTICAST_GROUP {
    ULONG                   McastNetworkBrand;
    PTRANSPORT_ADDRESS      McastTdiAddress;
    ULONG                   McastTdiAddressLength;
    PVOID                   Key;
    ULONG                   KeyLength;
    ULONG                   SignatureLength;
    ULONG                   RefCount;
} CNP_MULTICAST_GROUP, *PCNP_MULTICAST_GROUP;

//
// Network Object
//
// This structure represents a communication link between the nodes of a
// cluster. It references a particular transport protocol and interface
// configured on the local system. It also links together all of the
// interface objects for the nodes attached to the network.
//
// Networks are identified by a small integer assigned by the Cluster
// Service. Network objects are stored in a global array indexed by
// the network ID.
//
typedef struct {
    LIST_ENTRY              Linkage;
    CN_SIGNATURE_FIELD
    CL_NETWORK_ID           Id;
    CN_LOCK                 Lock;
    CN_IRQL                 Irql;
    ULONG                   RefCount;
    ULONG                   ActiveRefCount;
    CLUSNET_NETWORK_STATE   State;
    ULONG                   Flags;
    ULONG                   Priority;
    HANDLE                  DatagramHandle;
    PFILE_OBJECT            DatagramFileObject;
    PDEVICE_OBJECT          DatagramDeviceObject;
    TDI_PROVIDER_INFO       ProviderInfo;
    PIRP                    PendingDeleteIrp;
    PIRP                    PendingOfflineIrp;
    WORK_QUEUE_ITEM         ExWorkItem;
    PCNP_MULTICAST_GROUP    CurrentMcastGroup;
    PCNP_MULTICAST_GROUP    PreviousMcastGroup;
    CX_CLUSTERSCREEN        McastReachableNodes;
    ULONG                   McastReachableCount;
} CNP_NETWORK, *PCNP_NETWORK;

#define CNP_NETWORK_SIG    'kwtn'

extern LIST_ENTRY      CnpNetworkList;
extern CN_LOCK         CnpNetworkListLock;

#define CNP_NET_FLAG_DELETING       0x00000001
#define CNP_NET_FLAG_PARTITIONED    0x00000002
#define CNP_NET_FLAG_RESTRICTED     0x00000004
#define CNP_NET_FLAG_LOCALDISCONN   0x00000008
#define CNP_NET_FLAG_MULTICAST      0x00000010
#define CNP_NET_FLAG_MCASTSORTED    0x00000020

#define CnpIsNetworkDeleting(_network) \
            (((_network)->Flags & CNP_NET_FLAG_DELETING) != 0)

#define CnpIsValidNetworkId(_id)   ( ((_id) != ClusterAnyNetworkId ) && \
                                     ((_id) != ClusterInvalidNetworkId))

#define CnpIsNetworkRestricted(_network) \
            (((_network)->Flags & CNP_NET_FLAG_RESTRICTED) != 0)

#define CnpIsNetworkLocalDisconn(_network) \
            (((_network)->Flags & CNP_NET_FLAG_LOCALDISCONN) != 0)

#define CnpIsNetworkMulticastCapable(_network) \
            (((_network)->Flags & CNP_NET_FLAG_MULTICAST) != 0)

#define CnpIsNetworkMulticastSorted(_network) \
            (((_network)->Flags & CNP_NET_FLAG_MCASTSORTED) != 0)

#define CnpNetworkResetMcastReachableNodes(_network)     \
            (RtlZeroMemory(                              \
                 &((_network)->McastReachableNodes),     \
                 sizeof((_network)->McastReachableNodes) \
                 ))
/*
            (BYTE((_network)->McastReachableNodes, INT_NODE(CnLocalNodeId)) \
            = (1 << (BYTEL-1-BIT(INT_NODE(CnLocalNodeId)))))
            */

//
// Node Object
//
// This structure represents a cluster node. One exists for each
// defined member of a cluster.
//
// Nodes are identified by a small integer assigned by the Cluster Service.
// Node objects are stored in a global array indexed by node ID.
//
// Note that the order of the CLUSTER_NODE_COMM_STATE enumeration *is* important.
//
typedef struct {
    LIST_ENTRY              Linkage;
    CN_SIGNATURE_FIELD
    CL_NODE_ID              Id;
    CN_LOCK                 Lock;
    CN_IRQL                 Irql;
    ULONG                   RefCount;
    CLUSNET_NODE_COMM_STATE CommState;
    CLUSNET_NODE_STATE      MMState;
    ULONG                   Flags;
    LIST_ENTRY              InterfaceList;
    PCNP_INTERFACE          CurrentInterface;
    PIRP                    PendingDeleteIrp;
    BOOLEAN                 HBWasMissed;
    BOOLEAN                 NodeDownIssued;
    ULONG                   MissedHBs;
} CNP_NODE, *PCNP_NODE;

#define CNP_NODE_SIG  'edon'

extern PCNP_NODE *        CnpNodeTable;
extern CN_LOCK            CnpNodeTableLock;
extern PCNP_NODE          CnpLocalNode;

#define CNP_NODE_FLAG_DELETING       0x00000001
#define CNP_NODE_FLAG_UNREACHABLE    0x00000002
#define CNP_NODE_FLAG_LOCAL          0x00000010

#define CnpIsNodeDeleting(_node) \
            ((_node)->Flags & CNP_NODE_FLAG_DELETING)

#define CnpIsNodeLocal(_node) \
            ((_node)->Flags & CNP_NODE_FLAG_LOCAL)

#define CnpIsNodeUnreachable(_node) \
            ((_node)->Flags & CNP_NODE_FLAG_UNREACHABLE)

//++
//
// Routine Description:
//
//     Callback routine for CnpWalkNodeTable. Performs an operation on
//     the specified node.
//
// Arguments:
//
//     UpdateNode    - A pointer to the node on which to operate.
//
//     UpdateContext - Operation-specific context
//
//     NodeTableIrql - The IRQL at which the CnpNodeTableLock was acquired.
//
// Return Value:
//
//     Returns TRUE if the CnpNodeTable lock is still held.
//     Returns FALSE if the CnpNodeTable lock is released.
//
// Notes:
//
//     Called with both the CnpNodeTable and node object locks held.
//     The node object lock is released upon return.
//
//--
typedef
BOOLEAN
(*PCNP_NODE_UPDATE_ROUTINE)(
    IN  PCNP_NODE   UpdateNode,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    );

//
// Interface Object
//
// This structure represents a node's transport interface to a network.
// It contains a transport address which may be used to communicate
// with the specified node using the specified network.
//
// Interface objects are linked onto lists in the associated node objects.
// They are identified by a {node, network} tuple.
//
// The interfaces on a node are ranked based on their state and priority.
// Numerically higher state values are ranked ahead of lower values.
// For interfaces with the same state, Numerically lower priority values
// are ranked ahead of lower values. Priority values fall in the range
// 0x1-0xFFFFFFFF. State values are defined by CLUSNET_INTERFACE_STATE
// enumeration. By default, interfaces inherit their priority from the
// associated network. In this case, the Priority field will contain the
// network's priority value, and the CNP_IF_FLAG_USE_NETWORK_PRIORITY flag
// will be set in the Flags field.
//
// Note that the order of the CLUSNET_INTERFACE_STATE enumeration
// *is* important.
//

typedef struct _CNP_INTERFACE {
    LIST_ENTRY                     NodeLinkage;
    CN_SIGNATURE_FIELD
    PCNP_NODE                      Node;
    PCNP_NETWORK                   Network;
    CLUSNET_INTERFACE_STATE        State;
    ULONG                          Priority;
    ULONG                          Flags;
    ULONG                          MissedHBs;
    ULONG                          SequenceToSend;
    ULONG                          LastSequenceReceived;
    ULONG                          McastDiscoverCount;
    ULONG                          McastRediscoveryCountdown;
    ULONG                          AdapterWMIProviderId;
    ULONG                          TdiAddressLength;
    TRANSPORT_ADDRESS              TdiAddress;
} CNP_INTERFACE;

#define CNP_INTERFACE_SIG    '  fi'

#define CNP_INTERFACE_MCAST_DISCOVERY        0x5
#define CNP_INTERFACE_MCAST_REDISCOVERY      3000 // 1 hr at 1.2 hbs/sec

#define CNP_IF_FLAG_USE_NETWORK_PRIORITY     0x00000001
#define CNP_IF_FLAG_RECVD_MULTICAST          0x00000002

#define CnpIsInterfaceUsingNetworkPriority(_if) \
            ( (_if)->Flags & CNP_IF_FLAG_USE_NETWORK_PRIORITY )

#define CnpInterfaceQueryReceivedMulticast(_if) \
            ( (_if)->Flags & CNP_IF_FLAG_RECVD_MULTICAST )

#define CnpInterfaceSetReceivedMulticast(_if) \
            ( (_if)->Flags |= CNP_IF_FLAG_RECVD_MULTICAST )

#define CnpInterfaceClearReceivedMulticast(_if) \
            ( (_if)->Flags &= ~CNP_IF_FLAG_RECVD_MULTICAST )


//++
//
// Routine Description:
//
//     Callback routine for CnpWalkInterfacesOnNetwork and
//     CnpWalkInterfacesOnNode routines. Performs a specified
//     operation on all interfaces.
//
// Arguments:
//
//     UpdateInterface - A pointer to the interface on which to operate.
//
// Return Value:
//
//     None.
//
// Notes:
//
//     Called with the associated node and network object locks held.
//     Mut return with the network object lock released.
//     May not release node object lock at any time.
//
//--
typedef
VOID
(*PCNP_INTERFACE_UPDATE_ROUTINE)(
    IN  PCNP_INTERFACE   UpdateInterface
    );


//
// Send Request Pool
//
typedef struct {
    USHORT                 UpperProtocolHeaderLength;
    ULONG                  UpperProtocolContextSize;
    UCHAR                  UpperProtocolNumber;
    UCHAR                  CnpVersionNumber;
    UCHAR                  Pad[2];
} CNP_SEND_REQUEST_POOL_CONTEXT, *PCNP_SEND_REQUEST_POOL_CONTEXT;

//
// Forward Declaration
//
typedef struct _CNP_SEND_REQUEST *PCNP_SEND_REQUEST;

typedef
VOID
(*PCNP_SEND_COMPLETE_ROUTINE)(
    IN     NTSTATUS            Status,
    IN OUT PULONG              BytesSent,
    IN     PCNP_SEND_REQUEST   SendRequest,
    IN     PMDL                DataMdl
    );

//
// Send Request Structure
//
typedef struct _CNP_SEND_REQUEST {
    CN_RESOURCE                  CnResource;
    PMDL                         HeaderMdl;
    PVOID                        CnpHeader;
    PIRP                         UpperProtocolIrp;
    PVOID                        UpperProtocolHeader;
    USHORT                       UpperProtocolHeaderLength;
    KPROCESSOR_MODE              UpperProtocolIrpMode;
    UCHAR                        Pad;
    PMDL                         UpperProtocolMdl;
    PVOID                        UpperProtocolContext;
    PCNP_SEND_COMPLETE_ROUTINE   CompletionRoutine;
    PCNP_NETWORK                 Network;
    PCNP_MULTICAST_GROUP         McastGroup;
    TDI_CONNECTION_INFORMATION   TdiSendDatagramInfo;
} CNP_SEND_REQUEST;


//
// Internal Init/Cleanup routines
//

//
// Internal Node Routines
//
VOID
CnpWalkNodeTable(
    PCNP_NODE_UPDATE_ROUTINE  UpdateRoutine,
    PVOID                     UpdateContext
    );

NTSTATUS
CnpValidateAndFindNode(
    IN  CL_NODE_ID    NodeId,
    OUT PCNP_NODE *   Node
    );

PCNP_NODE
CnpLockedFindNode(
    IN  CL_NODE_ID    NodeId,
    IN  CN_IRQL       NodeTableIrql
    );

PCNP_NODE
CnpFindNode(
    IN  CL_NODE_ID    NodeId
    );

VOID
CnpOfflineNode(
    PCNP_NODE    Node
    );

VOID
CnpDeclareNodeUnreachable(
    PCNP_NODE  Node
    );

VOID
CnpDeclareNodeReachable(
    PCNP_NODE  Node
    );

VOID
CnpReferenceNode(
    PCNP_NODE  Node
    );

VOID
CnpDereferenceNode(
    PCNP_NODE  Node
    );


//
// Internal Network Routines
//
VOID
CnpReferenceNetwork(
    PCNP_NETWORK  Network
    );

VOID
CnpDereferenceNetwork(
    PCNP_NETWORK  Network
    );

ULONG
CnpActiveReferenceNetwork(
    PCNP_NETWORK  Network
    );

VOID
CnpActiveDereferenceNetwork(
    PCNP_NETWORK   Network
    );

PCNP_NETWORK
CnpFindNetwork(
    IN CL_NETWORK_ID  NetworkId
    );

VOID
CnpDeleteNetwork(
    PCNP_NETWORK  Network,
    CN_IRQL       NetworkListIrql
    );

VOID
CnpFreeMulticastGroup(
    IN PCNP_MULTICAST_GROUP Group
    );

#define CnpReferenceMulticastGroup(_group) \
    (InterlockedIncrement(&((_group)->RefCount)))

#define CnpDereferenceMulticastGroup(_group)                 \
    if (InterlockedDecrement(&((_group)->RefCount)) == 0) {  \
        CnpFreeMulticastGroup(_group);                       \
    }

BOOLEAN
CnpSortMulticastNetwork(
    IN  PCNP_NETWORK        Network,
    IN  BOOLEAN             RaiseEvent,
    OUT CX_CLUSTERSCREEN  * McastReachableNodes      OPTIONAL
    );

BOOLEAN
CnpMulticastChangeNodeReachability(
    IN  PCNP_NETWORK       Network,
    IN  PCNP_NODE          Node,
    IN  BOOLEAN            Reachable,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * NewMcastReachableNodes    OPTIONAL
    );

PCNP_NETWORK
CnpGetBestMulticastNetwork(
    VOID
    );

VOID
CnpStartInterfaceMcastTransition(
    PCNP_INTERFACE  Interface
    );

//
// Internal Interface Routines
//

VOID
CnpWalkInterfacesOnNode(
    PCNP_NODE                      Node,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    );

VOID
CnpWalkInterfacesOnNetwork(
    PCNP_NETWORK                   Network,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    );

NTSTATUS
CnpOnlinePendingInterface(
    PCNP_INTERFACE   Interface
    );

VOID
CnpOnlinePendingInterfaceWrapper(
    PCNP_INTERFACE   Interface
    );

NTSTATUS
CnpOfflineInterface(
    PCNP_INTERFACE   Interface
    );

VOID
CnpOfflineInterfaceWrapper(
    PCNP_INTERFACE   Interface
    );

NTSTATUS
CnpOnlineInterface(
    PCNP_INTERFACE   Interface
    );

NTSTATUS
CnpFailInterface(
    PCNP_INTERFACE   Interface
    );

VOID
CnpDeleteInterface(
    IN PCNP_INTERFACE Interface
    );

VOID
CnpReevaluateInterfaceRole(
    IN PCNP_INTERFACE  Interface
    );

VOID
CnpRecalculateInterfacePriority(
    IN PCNP_INTERFACE  Interface
    );

VOID
CnpUpdateNodeCurrentInterface(
    PCNP_NODE  Node
    );

VOID
CnpResetAndOnlinePendingInterface(
    IN PCNP_INTERFACE  Interface
    );

NTSTATUS
CnpFindInterface(
    IN  CL_NODE_ID         NodeId,
    IN  CL_NETWORK_ID      NetworkId,
    OUT PCNP_INTERFACE *   Interface
    );


//
// Send Routines.
//
PCN_RESOURCE_POOL
CnpCreateSendRequestPool(
    IN UCHAR  CnpVersionNumber,
    IN UCHAR  UpperProtocolNumber,
    IN USHORT UpperProtocolHeaderSize,
    IN USHORT UpperProtocolContextSize,
    IN USHORT PoolDepth
    );

#define CnpDeleteSendRequestPool(_pool) \
        { \
            CnDrainResourcePool(_pool);  \
            CnFreePool(_pool);           \
        }

NTSTATUS
CnpSendPacket(
    IN PCNP_SEND_REQUEST    SendRequest,
    IN CL_NODE_ID           DestNodeId,
    IN PMDL                 DataMdl,
    IN USHORT               DataLength,
    IN BOOLEAN              CheckDestState,
    IN CL_NETWORK_ID        NetworkId OPTIONAL
    );

VOID
CcmpSendPoisonPacket(
    IN PCNP_NODE                   Node,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN PVOID                       CompletionContext,  OPTIONAL
    IN PCNP_NETWORK                Network,            OPTIONAL
    IN PIRP                        Irp                 OPTIONAL
    );

//
// Receive Routines
//
NTSTATUS
CcmpReceivePacketHandler(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    );

VOID
CnpReceiveHeartBeatMessage(
    IN  PCNP_NETWORK Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber,
    IN  ULONG AckNumber,
    IN  BOOLEAN Multicast,
    IN  ULONG MulticastEpoch
    );

VOID
CnpReceivePoisonPacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber
    );

//
// TDI routines
//
NTSTATUS
CnpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   IoRequestPacket
    );

NTSTATUS
CnpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    );

NTSTATUS
CnpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext,
    IN PIRP            ClientIrp     OPTIONAL
    );

NTSTATUS
CnpIssueDeviceControl (
    IN PFILE_OBJECT     FileObject,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            IrpParameters,
    IN ULONG            IrpParametersLength,
    IN PVOID            MdlBuffer,
    IN ULONG            MdlBufferLength,
    IN UCHAR            MinorFunction,
    IN PIRP             ClientIrp            OPTIONAL
    );

VOID
CnpAttachSystemProcess(
    VOID
    );

VOID
CnpDetachSystemProcess(
    VOID
    );

NTSTATUS
CnpOpenDevice(
    IN  LPWSTR          DeviceName,
    OUT HANDLE          *Handle
    );

NTSTATUS
CnpZwDeviceControl(
    IN HANDLE   Handle,
    IN ULONG    IoControlCode,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN ULONG    OutputBufferLength
    );

NTSTATUS
CnpSetTcpInfoEx(
    IN HANDLE   Handle,
    IN ULONG    Entity,
    IN ULONG    Class,
    IN ULONG    Type,
    IN ULONG    Id,
    IN PVOID    Value,
    IN ULONG    ValueLength
    );

#define CnpIsIrpStackSufficient(_irp, _targetdevice) \
            ((_irp)->CurrentLocation - (_targetdevice)->StackSize >= 1)

#define CnpIsIPv4McastTransportAddress(_ta)                             \
            (  (((PTA_IP_ADDRESS)(_ta))->Address[0].AddressType         \
               == TDI_ADDRESS_TYPE_IP                                   \
               )                                                        \
            && ((((PTA_IP_ADDRESS)(_ta))->Address[0].Address[0].in_addr \
                 & 0xf0)                                                \
               == 0xe0                                                  \
               )                                                        \
            )

#define CnpIsIPv4McastSameGroup(_ta1, _ta2)                              \
            ( ((PTA_IP_ADDRESS)(_ta1))->Address[0].Address[0].in_addr == \
              ((PTA_IP_ADDRESS)(_ta2))->Address[0].Address[0].in_addr    \
            )

//
// Signature mechanisms.
//

extern FIPS_FUNCTION_TABLE CxFipsFunctionTable;

 // The signature length is the SHA digest length.
#define CX_SIGNATURE_LENGTH                A_SHA_DIGEST_LEN

// The salt length is eight bytes.
#define CX_SIGNATURE_SALT_LENGTH           sizeof(ULONGLONG)

// Combined signature and salt
#define CX_SIGNATURE_DATA_LENGTH           \
    (CX_SIGNATURE_LENGTH + CX_SIGNATURE_SALT_LENGTH)

NTSTATUS
CnpSignMulticastMessage(
    IN     PCNP_SEND_REQUEST               SendRequest,
    IN     PMDL                            DataMdl,
    IN OUT CL_NETWORK_ID                 * NetworkId,
    OUT    ULONG                         * SigLen           OPTIONAL
    );

NTSTATUS
CnpVerifyMulticastMessage(
    IN     PCNP_NETWORK                    Network,
    IN     PVOID                           Tsdu,
    IN     ULONG                           TsduLength,
    IN     ULONG                           ExpectedPayload,
       OUT ULONG                         * BytesTaken,
       OUT BOOLEAN                       * CurrentGroup
    );

NTSTATUS
CnpInitializeSaltGenerator(
    VOID
    );

 #endif // ifndef _CNPDEF_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnpnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cnpnet.c

Abstract:

    Network management routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpnet.tmh"

#include <tdiinfo.h>
#include <tcpinfo.h>
#include <align.h>
#include <sspi.h>

//
// Global Data
//
LIST_ENTRY          CnpNetworkList = {NULL, NULL};
LIST_ENTRY          CnpDeletingNetworkList = {NULL, NULL};
#if DBG
CN_LOCK             CnpNetworkListLock = {0,0};
#else  // DBG
CN_LOCK             CnpNetworkListLock = 0;
#endif // DBG
BOOLEAN             CnpIsNetworkShutdownPending = FALSE;
PKEVENT             CnpNetworkShutdownEvent = NULL;
USHORT              CnpReservedClusnetPort = 0;



#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CnpLoadNetworks)
#pragma alloc_text(PAGE, CnpInitializeNetworks)

#endif // ALLOC_PRAGMA


//
// Private utiltity routines
//
#define CnpIpAddrPrintArgs(_ip) \
    ((_ip >> 0 ) & 0xff),       \
    ((_ip >> 8 ) & 0xff),       \
    ((_ip >> 16) & 0xff),       \
    ((_ip >> 24) & 0xff)


#define CnpIsInternalMulticastNetwork(_network)                  \
            (((_network)->State == ClusnetNetworkStateOnline) && \
             (!CnpIsNetworkRestricted((_network))) &&            \
             (CnpIsNetworkMulticastCapable((_network))))


VOID
CnpMulticastGetReachableNodesLocked(
    OUT CX_CLUSTERSCREEN * McastReachableNodes,
    OUT ULONG            * McastReachableCount
    )
{
    PLIST_ENTRY      entry;
    PCNP_NETWORK     network = NULL;

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    if (!IsListEmpty(&CnpNetworkList)) {

        entry = CnpNetworkList.Flink;
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        //
        // The old screen and count are only valid if
        // this is a valid internal network.
        //
        if (CnpIsInternalMulticastNetwork(network)) {
            *McastReachableNodes = network->McastReachableNodes;
            *McastReachableCount = network->McastReachableCount;
        } else {
            network = NULL;
        }
    }
    if (network == NULL) {
        RtlZeroMemory(McastReachableNodes, sizeof(*McastReachableNodes));
        *McastReachableCount = 0;
    }

    return;

} // CnpMulticastGetReachableNodesLocked


BOOLEAN
CnpRemoveNetworkListEntryLocked(
    IN  PCNP_NETWORK       Network,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * McastReachableNodes   OPTIONAL
    )
/*++

Routine Description:

    Remove Network from the network list and return the new
    multicast reachable mask.

Return value:

    TRUE if the reachable set changed

Notes:

    Called and returns with network list lock held.

--*/
{
    ULONG                count;
    BOOLEAN              setChanged;
    CX_CLUSTERSCREEN     oldScreen;
    CX_CLUSTERSCREEN     newScreen;

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

    RemoveEntryList(&(Network->Linkage));
    Network->Flags &= ~CNP_NET_FLAG_MCASTSORTED;

    CnpMulticastGetReachableNodesLocked(&newScreen, &count);

    setChanged = (BOOLEAN)
        (oldScreen.UlongScreen != newScreen.UlongScreen);

    if (RaiseEvent && setChanged) {

        CnTrace(CNP_NET_DETAIL, CnpTraceMulticastReachEventRemove,
            "[CNP] Issuing event for new multicast "
            "reachable set (%lx) after removing "
            "network %u.",
            newScreen.UlongScreen,
            Network->Id
            );

        CnIssueEvent(
            ClusnetEventMulticastSet,
            newScreen.UlongScreen,
            0
            );
    }

    if (McastReachableNodes != NULL) {
        *McastReachableNodes = newScreen;
    }

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,    // required
        0,                        // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpRemoveNetworkListEntryLocked


BOOLEAN
CnpIsBetterMulticastNetwork(
    IN PCNP_NETWORK        Network1,
    IN PCNP_NETWORK        Network2
    )
/*++

Routine Description:

    Compares two networks according to multicast reachability
    criteria:
    1. online/registered AND
       not restricted (e.g. enabled for intracluster comm) AND
       not disconnected AND
       multicast-enabled
    2. priority
    3. number of multicast reachable nodes

Return value:

    TRUE if Network1 is better than Network2

--*/
{
    if (!CnpIsInternalMulticastNetwork(Network1)) {
        return(FALSE);
    }

    if (!CnpIsInternalMulticastNetwork(Network2)) {
        return(TRUE);
    }

    //
    // Both networks are equal with respect to basic
    // multicast requirements.
    //
    // Now compare the priority.
    //
    if (CnpIsEqualPriority(Network1->Priority, Network2->Priority)) {

        //
        // The priority is the same. Although this is unexpected,
        // we now compare the number of nodes reachable by
        // multicast.
        //
        return(Network1->McastReachableCount > Network2->McastReachableCount);

    } else {

        return(CnpIsHigherPriority(Network1->Priority, Network2->Priority));
    }

} // CnpIsBetterMulticastNetwork


BOOLEAN
CnpSortMulticastNetworkLocked(
    IN  PCNP_NETWORK        Network,
    IN  BOOLEAN             RaiseEvent,
    OUT CX_CLUSTERSCREEN  * NewMcastReachableNodes      OPTIONAL
    )
/*++

Routine Description:

    Positions Network in network list according to multicast
    reachability. Network must already be inserted in the
    network list.

    The network list is always sorted, but it is possible
    for one network in the list to be "perturbed". In this
    case, that entry must be repositioned correctly. This
    routine handles repositioning.

    Returns new screen through NewMcastReachableNodes.

Return value:

    TRUE if number of reachable nodes changes.

Notes:

    Called and returns with network list locked.

--*/
{
    ULONG            count;
    CX_CLUSTERSCREEN oldScreen;
    CX_CLUSTERSCREEN newScreen;
    BOOLEAN          newScreenValid = FALSE;
    PLIST_ENTRY      entry;
    PCNP_NETWORK     network = NULL;
    KIRQL            irql;
    BOOLEAN          move = FALSE;
    BOOLEAN          setChanged = FALSE;


    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    //
    // If the network has already been removed from the
    // sorted list, there is no sense in resorting it.
    //
    if (CnpIsNetworkMulticastSorted(Network)) {

        //
        // Remember the current screen and count to detect
        // changes.
        //
        CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

        //
        // Check if it needs to be moved up.
        //
        for (entry = Network->Linkage.Blink;
             entry != &CnpNetworkList;
             entry = entry->Blink) {

            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            if (CnpIsBetterMulticastNetwork(Network, network)) {
                move = TRUE;
            } else {
                break;
            }
        }

        if (move) {
            RemoveEntryList(&(Network->Linkage));
            InsertHeadList(entry, &(Network->Linkage));
        } else {

            //
            // Check if it needs to be moved down.
            //
            for (entry = Network->Linkage.Flink;
                 entry != &CnpNetworkList;
                 entry = entry->Flink) {

                network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

                if (CnpIsBetterMulticastNetwork(network, Network)) {
                    move = TRUE;
                } else {
                    break;
                }
            }

            if (move) {
                RemoveEntryList(&(Network->Linkage));
                InsertTailList(entry, &(Network->Linkage));
            }
        }

        //
        // Determine if the set of reachable nodes has changed.
        //
        CnpMulticastGetReachableNodesLocked(&newScreen, &count);
        newScreenValid = TRUE;

        setChanged = (BOOLEAN)
            (oldScreen.UlongScreen != newScreen.UlongScreen);
    }

    if (RaiseEvent && setChanged) {

        if (!newScreenValid) {
            CnpMulticastGetReachableNodesLocked(&newScreen, &count);
            newScreenValid = TRUE;
        }

        CnTrace(CNP_NET_DETAIL, CnpTraceMulticastReachEventSort,
            "[CNP] Issuing event for new multicast "
            "reachable set (%lx) after sorting "
            "network %u.",
            newScreen.UlongScreen,
            Network->Id
            );

        CnIssueEvent(
            ClusnetEventMulticastSet,
            newScreen.UlongScreen,
            0
            );
    }

    if (NewMcastReachableNodes != NULL) {
        if (!newScreenValid) {
            CnpMulticastGetReachableNodesLocked(&newScreen, &count);
            newScreenValid = TRUE;
        }
        *NewMcastReachableNodes = newScreen;
    }

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpSortMulticastNetworkLocked


BOOLEAN
CnpMulticastChangeNodeReachabilityLocked(
    IN  PCNP_NETWORK       Network,
    IN  PCNP_NODE          Node,
    IN  BOOLEAN            Reachable,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * NewMcastReachableNodes    OPTIONAL
    )
/*++

Routine Description:

    Changes the multicast reachability state of Node
    on Network.

    If the set of reachable nodes changes, returns
    the new screen through NewMcastReachableNodes.

Return value:

    TRUE if set of reachable nodes changes.

Notes:

    Called and returns with node lock held.
    Called and returns with network list lock held.

--*/
{
    KIRQL            irql;
    BOOLEAN          netSetChanged = FALSE;
    BOOLEAN          setChanged = FALSE;
    CX_CLUSTERSCREEN oldScreen;
    CX_CLUSTERSCREEN newScreen;
    BOOLEAN          newScreenValid = FALSE;
    ULONG            count;

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK | CNP_NETWORK_LIST_LOCK, // required
        0,                                            // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                   // max
        );

    if (Reachable) {
        if (Node != CnpLocalNode) {
            if (!CnpClusterScreenMember(
                     Network->McastReachableNodes.ClusterScreen,
                     INT_NODE(Node->Id)
                     )) {

                //
                // Remember the current screen and count to detect
                // changes.
                //
                CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

                CnpClusterScreenInsert(
                    Network->McastReachableNodes.ClusterScreen,
                    INT_NODE(Node->Id)
                    );
                Network->McastReachableCount++;
                netSetChanged = TRUE;
            }
        }
    } else {
        if (Node == CnpLocalNode) {

            //
            // Remember the current screen and count to detect
            // changes.
            //
            CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

            //
            // The local interface on this network
            // no longer speaks multicast. Declare all
            // other nodes unreachable.
            //
            CnpNetworkResetMcastReachableNodes(Network);
            if (Network->McastReachableCount != 0) {
                netSetChanged = TRUE;
            }
            Network->McastReachableCount = 0;
        } else {
            if (CnpClusterScreenMember(
                    Network->McastReachableNodes.ClusterScreen,
                    INT_NODE(Node->Id)
                    )) {

                //
                // Remember the current screen and count to detect
                // changes.
                //
                CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

                CnpClusterScreenDelete(
                    Network->McastReachableNodes.ClusterScreen,
                    INT_NODE(Node->Id)
                    );
                Network->McastReachableCount--;
                netSetChanged = TRUE;
            }
        }
    }

    if (netSetChanged) {

        CnpSortMulticastNetworkLocked(Network, FALSE, &newScreen);
        newScreenValid = TRUE;

        setChanged = (BOOLEAN)(oldScreen.UlongScreen != newScreen.UlongScreen);
    }

    if (RaiseEvent && setChanged) {

        if (!newScreenValid) {
            CnpMulticastGetReachableNodesLocked(&newScreen, &count);
            newScreenValid = TRUE;
        }

        CnTrace(CNP_NET_DETAIL, CnpTraceMulticastReachEventReach,
            "[CNP] Issuing event for new multicast "
            "reachable set (%lx) after setting "
            "reachability for network %u to %!bool!.",
            newScreen.UlongScreen,
            Network->Id, Reachable
            );

        CnIssueEvent(
            ClusnetEventMulticastSet,
            newScreen.UlongScreen,
            0
            );
    }

    if (NewMcastReachableNodes != NULL) {
        if (!newScreenValid) {
            CnpMulticastGetReachableNodesLocked(&newScreen, &count);
            newScreenValid = TRUE;
        }
        *NewMcastReachableNodes = newScreen;
    }

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK | CNP_NETWORK_LIST_LOCK, // required
        0,                                            // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                   // max
        );

    return(setChanged);

} // CnpMulticastChangeNodeReachabilityLocked


PCNP_NETWORK
CnpLockedFindNetwork(
    IN CL_NETWORK_ID  NetworkId,
    IN CN_IRQL        ListIrql
    )
/*++

Routine Description:

    Searches the network list for a specified network object.

Arguments:

    NetworkId   - The ID of the network object to locate.

    ListIrql    - The IRQL level at which the network list lock was
                  acquired before calling this routine.

Return Value:

    A pointer to the requested network object, if it exists.
    NULL otherwise.

Notes:

    Called with CnpNetworkListLock held.
    Returns with CnpNetworkListLock released.
    If return value is non-NULL, returns with network object lock held.

--*/
{
    PLIST_ENTRY        entry;
    CN_IRQL            networkIrql;
    PCNP_NETWORK       network = NULL;


    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,           // Required
        0,                               // Forbidden
        CNP_NETWORK_LIST_LOCK_MAX        // Maximum
        );

    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        CnAcquireLock(&(network->Lock), &networkIrql);

        if (NetworkId == network->Id) {
            CnReleaseLock(&CnpNetworkListLock, networkIrql);
            network->Irql = ListIrql;

            CnVerifyCpuLockMask(
                CNP_NETWORK_OBJECT_LOCK,          // Required
                CNP_NETWORK_LIST_LOCK,            // Forbidden
                CNP_NETWORK_OBJECT_LOCK_MAX       // Maximum
                );

            return(network);
        }

        CnReleaseLock(&(network->Lock), networkIrql);
    }

    CnReleaseLock(&CnpNetworkListLock, ListIrql);

    CnVerifyCpuLockMask(
        0,                                                    // Required
        (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK),    // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                              // Maximum
        );

    return(NULL);

}  // CnpLockedFindNetwork




VOID
CnpOfflineNetwork(
    PCNP_NETWORK    Network
    )
/*++

Notes:

    Called with network object lock held.
    Returns with network object lock released.
    May not be called while holding any higher-ranked locks.

--*/
{
    NTSTATUS        status;
    PFILE_OBJECT    fileObject = NULL;
    PDEVICE_OBJECT  deviceObject = NULL;

    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,               // Required
        (ULONG) ~(CNP_NETWORK_OBJECT_LOCK),    // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX            // Maximum
        );

    CnAssert(Network->State >= ClusnetNetworkStateOnlinePending);

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Offline of network %u pending....\n",
            Network->Id
            ));
    }

    Network->State = ClusnetNetworkStateOfflinePending;

    //
    // Get the UDP file and device objects associated
    // with this network to clear the receive event
    // handler. Referencing the file object will keep
    // both the file and device objects from going away,
    // since the I/O mgr maintains a ref on the device
    // object for the file object.
    //
    fileObject = Network->DatagramFileObject;
    if (fileObject != NULL) {
        ObReferenceObject(fileObject);
    }
    deviceObject = Network->DatagramDeviceObject;

    CnReleaseLock(&(Network->Lock), Network->Irql);

    CnTrace(
        CNP_NET_DETAIL, CnpTraceNetworkOfflinePending,
        "[CNP] Offline of network %u pending.",
        Network->Id
        );

    //
    // If the network is still on the sorted network list,
    // re-sort.
    //
    CnpSortMulticastNetwork(Network, TRUE, NULL);

    //
    // Take all of the interfaces on this network offline.
    //
    // Note that the network cannot go away while we do this
    // because we still hold an active reference on it.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Taking all interfaces on network %u offline...\n",
            Network->Id
            ));
    }

    CnpWalkInterfacesOnNetwork(Network, CnpOfflineInterfaceWrapper);

    //
    // Stop the incoming data flow by clearing the receive
    // datagram TDI event handler.
    //
    if (fileObject != NULL && deviceObject != NULL) {
        status = CnpTdiSetEventHandler(
                     fileObject,
                     deviceObject,
                     TDI_EVENT_RECEIVE_DATAGRAM,
                     NULL, // handler
                     NULL, // context
                     NULL  // IRP for re-use
                     );
        if (!NT_SUCCESS(status)) {
            CnTrace(CNP_NET_DETAIL, CnpTraceNetworkClearRecv,
                "[CNP] Failed to clear receive datagram handler "
                "for network ID %u, status %!status!",
                Network->Id, // LOGULONG
                status // LOGSTATUS
                );
            // Non-fatal error. All will be cleaned up when we
            // close the file object.
        }
    }

    //
    // Drop the reference we took on the file object.
    //
    if (fileObject != NULL) {
        ObDereferenceObject(fileObject);
    }

    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    //
    // Remove the initial active reference. When the active
    // reference count goes to zero, the network will be taken
    // offline and the irp completed.
    //
    // The network object lock will be released by
    // the dereference.
    //
    CnpActiveDereferenceNetwork(Network);

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    return;

}  // CnpOfflineNetwork



VOID
CnpOfflineNetworkWorkRoutine(
    IN PVOID  Parameter
    )
/*++

Routine Description:

    Performs the actual work involved in taking a network offline.
    This routine runs in the context of an ExWorkerThread.

Arguments:

    Parameter - A pointer to the network object on which to operate.

Return Value:

    None.

--*/

{
    NTSTATUS             status;
    HANDLE               handle = NULL;
    PFILE_OBJECT         fileObject = NULL;
    PIRP                 offlineIrp;
    PCNP_NETWORK         network = Parameter;


    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);
    CnAssert(network->State == ClusnetNetworkStateOfflinePending);
    CnAssert(CnSystemProcess == (PKPROCESS) IoGetCurrentProcess());

    CnAcquireLock(&(network->Lock), &(network->Irql));

    handle = network->DatagramHandle;
    network->DatagramHandle = NULL;

    fileObject = network->DatagramFileObject;
    network->DatagramFileObject = NULL;

    network->DatagramDeviceObject = NULL;

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Taking network %u offline...\n", network->Id));
    }

    CnReleaseLock(&(network->Lock), network->Irql);

    CnTrace(CNP_NET_DETAIL, CnpTraceNetworkTakingOffline,
        "[CNP] Taking network %u offline, dgram handle %p, "
        "dgram fileobj %p.",
        network->Id, // LOGULONG
        handle, // LOGHANDLE
        fileObject // LOGPTR
        );

    if (fileObject != NULL) {
        ObDereferenceObject(fileObject);
    }

    if (handle != NULL) {

        status = ZwClose(handle);
        IF_CNDBG(CN_DEBUG_CONFIG) {
            if (!NT_SUCCESS(status)) {
                CNPRINT(("[CNP] Failed to close handle for network %u, "
                         "status %lx.\n",
                         network->Id, status));
            }
        }
        CnAssert(NT_SUCCESS(status));

        CnTrace(CNP_NET_DETAIL, CnpTraceNetworkClosed,
            "[CNP] Closed handle %p for network ID %u, status %!status!",
            handle, // LOGHANDLE
            network->Id, // LOGULONG
            status // LOGSTATUS
            );
    }

    CnAcquireLock(&(network->Lock), &(network->Irql));

    CnAssert(network->State == ClusnetNetworkStateOfflinePending);

    network->State = ClusnetNetworkStateOffline;

    offlineIrp = network->PendingOfflineIrp;
    network->PendingOfflineIrp = NULL;

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Network %u is now offline.\n", network->Id));
    }

    //
    // Remove the active reference from the base refcount.
    // This releases the network object lock.
    //
    CnpDereferenceNetwork(network);

    if (offlineIrp != NULL) {
        CN_IRQL              cancelIrql;

        CnAcquireCancelSpinLock(&cancelIrql);
        offlineIrp->CancelIrql = cancelIrql;

        CnCompletePendingRequest(offlineIrp, STATUS_SUCCESS, 0);
    }

    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);

    return;

} // CnpOfflineNetworkWorkRoutine


VOID
CnpDeleteNetwork(
    PCNP_NETWORK  Network,
    CN_IRQL       NetworkListIrql
    )
/*++

Notes:

    Called with the CnpNetworkListLock and network object lock held.
    Returns with both locks released.

--*/

{
    NTSTATUS           status;
    ULONG              i;
    PCNP_INTERFACE     interface;
    CL_NETWORK_ID      networkId = Network->Id;


    CnVerifyCpuLockMask(
        (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK),  // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Deleting network %u\n", Network->Id));
    }

    //
    // Move the network to the deleting list. Once we do this,
    // no new threads can reference the network object.
    //
    CnpRemoveNetworkListEntryLocked(Network, TRUE, NULL);
    InsertTailList(&CnpDeletingNetworkList, &(Network->Linkage));

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Moved network %u to deleting list\n",
            Network->Id
            ));
    }

    CnReleaseLockFromDpc(&CnpNetworkListLock);
    Network->Irql = NetworkListIrql;

    Network->Flags |= CNP_NET_FLAG_DELETING;

    if (Network->State >= ClusnetNetworkStateOnlinePending) {
        //
        // Take the network offline. This will force all of the
        // associated interfaces offline as well.
        //
        // This will release the network object lock.
        //
        CnpOfflineNetwork(Network);
    }
    else {
        CnReleaseLock(&(Network->Lock), Network->Irql);
    }

    //
    // Delete all the interfaces on this network.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Deleting all interfaces on network %u...\n",
            Network->Id
            ));
    }

    CnpWalkInterfacesOnNetwork(Network, CnpDeleteInterface);

    //
    // Remove the initial reference on the object. The object will be
    // destroyed when the reference count goes to zero. The delete irp
    // will be completed at that time.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    CnpDereferenceNetwork(Network);

    CnVerifyCpuLockMask(
        0,                                                    // Required
        (CNP_NETWORK_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),  // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                              // Maximum
        );

    return;

} // CnpDeleteNework


VOID
CnpDestroyNetworkWorkRoutine(
    IN PVOID  Parameter
    )
/*++

Routine Description:

    Performs the actual work involved in destroying a network.
    This routine runs in the context of an ExWorkerThread.

Arguments:

    Parameter - A pointer to the network object on which to operate.

Return Value:

    None.

--*/
{
    PLIST_ENTRY    entry;
    CN_IRQL        listIrql;
    BOOLEAN        setCleanupEvent = FALSE;
    PCNP_NETWORK   network = Parameter;


    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);
    CnAssert(network->State == ClusnetNetworkStateOffline);
    CnAssert(CnSystemProcess == (PKPROCESS) IoGetCurrentProcess());

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Destroying network %u\n", network->Id));
    }

    CnAcquireLock(&CnpNetworkListLock, &listIrql);

#if DBG
    {
        PCNP_NETWORK   oldNetwork = NULL;

        //
        // Verify that the network object is on the deleting list.
        //
        for (entry = CnpDeletingNetworkList.Flink;
             entry != &CnpDeletingNetworkList;
             entry = entry->Flink
            )
        {
            oldNetwork = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            if (oldNetwork == network) {
                break;
            }
        }

        CnAssert(oldNetwork == network);
    }
#endif // DBG

    RemoveEntryList(&(network->Linkage));

    if (CnpIsNetworkShutdownPending) {
        if (IsListEmpty(&CnpDeletingNetworkList)) {
            setCleanupEvent = TRUE;
        }
    }

    CnReleaseLock(&CnpNetworkListLock, listIrql);

    if (network->PendingDeleteIrp != NULL) {
        CnAcquireCancelSpinLock(&(network->PendingDeleteIrp->CancelIrql));

        CnCompletePendingRequest(
            network->PendingDeleteIrp,
            STATUS_SUCCESS,
            0
            );

        //
        // The IoCancelSpinLock was released by CnCompletePendingRequest()
        //
    }

    if (network->CurrentMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(network->CurrentMcastGroup);
        network->CurrentMcastGroup = NULL;
    }

    if (network->PreviousMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(network->PreviousMcastGroup);
        network->PreviousMcastGroup = NULL;
    }

    CnFreePool(network);

    if (setCleanupEvent) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Setting network cleanup event.\n"));
        }

        KeSetEvent(CnpNetworkShutdownEvent, 0, FALSE);
    }

    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);

    return;

}  // CnpDestroyNetworkWorkRoutine



//
// Routines exported within CNP
//
PCNP_NETWORK
CnpFindNetwork(
    IN CL_NETWORK_ID  NetworkId
    )
/*++

Notes:

--*/
{
    CN_IRQL   listIrql;


    CnAcquireLock(&CnpNetworkListLock, &listIrql);

    return(CnpLockedFindNetwork(NetworkId, listIrql));

}  // CnpFindNetwork



VOID
CnpReferenceNetwork(
    PCNP_NETWORK  Network
    )
/*++

Notes:

    Called with network object lock held.

--*/
{
    CnAssert(Network->RefCount != 0xFFFFFFFF);

    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    Network->RefCount++;

    IF_CNDBG(CN_DEBUG_CNPREF) {
        CNPRINT((
            "[CNP] Referencing network %u, new refcount %u\n",
            Network->Id,
            Network->RefCount
            ));
    }

    return;

}  // CnpReferenceNetwork



VOID
CnpDereferenceNetwork(
    PCNP_NETWORK  Network
    )
/*++

Notes:

    Called with network object lock held.
    Returns with network object lock released.

    Sometimes called with a node object lock held as well.

--*/
{
    PLIST_ENTRY    entry;
    CN_IRQL        listIrql;
    BOOLEAN        setCleanupEvent = FALSE;
    ULONG          newRefCount;
    PCNP_NETWORK   network;


    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    CnAssert(Network->RefCount != 0);

    newRefCount = --(Network->RefCount);

    IF_CNDBG(CN_DEBUG_CNPREF) {
        CNPRINT((
            "[CNP] Dereferencing network %u, new refcount %u\n",
            Network->Id,
            Network->RefCount
            ));
    }

    CnReleaseLock(&(Network->Lock), Network->Irql);

    if (newRefCount > 0) {

        CnVerifyCpuLockMask(
            0,                            // Required
            CNP_NETWORK_OBJECT_LOCK,      // Forbidden
            CNP_NETWORK_LIST_LOCK_MAX     // Maximum
            );

        return;
    }

    CnAssert(Network->ActiveRefCount == 0);
    CnAssert(Network->State == ClusnetNetworkStateOffline);
    CnAssert(Network->DatagramHandle == NULL);

    //
    // Schedule an ExWorkerThread to destroy the network.
    // We do this because we don't know if a higher-level lock,
    // such as a node object lock, is held when this routine is
    // called. We may need to acquire the IoCancelSpinLock,
    // which must be acquired before a node lock, in
    // order to complete a deregister Irp.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Posting destroy work item for network %u.\n",
            Network->Id
            ));
    }

    ExInitializeWorkItem(
        &(Network->ExWorkItem),
        CnpDestroyNetworkWorkRoutine,
        Network
        );

    ExQueueWorkItem(&(Network->ExWorkItem), DelayedWorkQueue);

    CnVerifyCpuLockMask(
        0,                            // Required
        CNP_NETWORK_OBJECT_LOCK,      // Forbidden
        CNP_NETWORK_LIST_LOCK_MAX     // Maximum
        );

    return;

}  // CnpDereferenceNetwork



ULONG
CnpActiveReferenceNetwork(
    PCNP_NETWORK  Network
    )
/*++

Return value:

    New ref count.

Notes:

    Called with network object lock held.

    Will not allow reference if current refcount is zero.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    CnAssert(Network->ActiveRefCount != 0xFFFFFFFF);
    CnAssert(Network->RefCount != 0);

    if (Network->ActiveRefCount == 0) {
        CnTrace(CNP_NET_DETAIL, CnpActiveRefNetFailed,
            "[CNP] Cannot take active reference on "
            "network %u because the active refcount "
            "is already zero.",
             Network->Id
            );
        return(Network->ActiveRefCount);
    }

    return (++Network->ActiveRefCount);

}  // CnpActiveReferenceNetwork



VOID
CnpActiveDereferenceNetwork(
    PCNP_NETWORK   Network
    )
/*++

Notes:

    Called with network object lock held.
    Returns with network object lock released.

--*/
{
    ULONG                newRefCount;


    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    CnAssert(Network->ActiveRefCount != 0);
    CnAssert(Network->State != ClusnetNetworkStateOffline);

    newRefCount = --(Network->ActiveRefCount);

    CnReleaseLock(&(Network->Lock), Network->Irql);

    if (newRefCount > 0) {

        CnVerifyCpuLockMask(
            0,                            // Required
            CNP_NETWORK_OBJECT_LOCK,      // Forbidden
            CNP_NETWORK_LIST_LOCK_MAX     // Maximum
            );

        return;
    }

    //
    // The network's active reference count has gone to zero.
    //
    CnAssert(Network->State == ClusnetNetworkStateOfflinePending);

    //
    // Schedule an ExWorkerThread to take the network offline.
    // We do this because we don't know if a higher-level lock,
    // such as a node object lock, is held when this routine is
    // called. The base transport file handle must be closed at
    // PASSIVE_LEVEL. We may also need to acquire the IoCancelSpinLock
    // in order to complete an Offline Irp.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Posting offline work item for network %u.\n",
            Network->Id
            ));
    }

    CnTrace(
        CNP_NET_DETAIL, CnpTraceNetworkSchedulingOffline,
        "[CNP] Scheduling offline of network %u.",
        Network->Id
        );

    ExInitializeWorkItem(
        &(Network->ExWorkItem),
        CnpOfflineNetworkWorkRoutine,
        Network
        );

    ExQueueWorkItem(&(Network->ExWorkItem), DelayedWorkQueue);

    CnVerifyCpuLockMask(
        0,                            // Required
        CNP_NETWORK_OBJECT_LOCK,      // Forbidden
        CNP_NETWORK_LIST_LOCK_MAX     // Maximum
        );

    return;

}  // CnpActiveDereferenceNetwork


NTSTATUS
CnpAllocateMulticastGroup(
    IN  ULONG                     Brand,
    IN  PTRANSPORT_ADDRESS        TdiMulticastAddress,
    IN  ULONG                     TdiMulticastAddressLength,
    IN  PVOID                     Key,
    IN  ULONG                     KeyLength,
    OUT PCNP_MULTICAST_GROUP    * Group
    )
/*++

Routine Description:

    Allocates and initializes a network multicast group
    structure.

--*/
{
    PCNP_MULTICAST_GROUP group;
    ULONG                groupSize;
    UCHAR                keyBuffer[DES_BLOCKLEN];
    PUCHAR               key;

    //
    // Allocate the data structure.
    //
    groupSize = sizeof(CNP_MULTICAST_GROUP);

    if (TdiMulticastAddressLength != 0) {
        groupSize = ROUND_UP_COUNT(groupSize,
                                   TYPE_ALIGNMENT(TRANSPORT_ADDRESS)) +
                    TdiMulticastAddressLength;
    }

    if (KeyLength != 0) {
        groupSize = ROUND_UP_COUNT(groupSize, TYPE_ALIGNMENT(PVOID)) +
                    KeyLength;
    }

    group = CnAllocatePool(groupSize);
    if (group == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Fill in parameter fields.
    //
    group->McastNetworkBrand = Brand;

    group->McastTdiAddress = (PTRANSPORT_ADDRESS)
        ROUND_UP_POINTER((PUCHAR)group + sizeof(CNP_MULTICAST_GROUP),
                         TYPE_ALIGNMENT(TRANSPORT_ADDRESS));
    group->McastTdiAddressLength = TdiMulticastAddressLength;
    RtlCopyMemory(
        group->McastTdiAddress,
        TdiMulticastAddress,
        TdiMulticastAddressLength
        );

    group->Key = (PVOID)
        ROUND_UP_POINTER((PUCHAR)group->McastTdiAddress
                         + TdiMulticastAddressLength,
                         TYPE_ALIGNMENT(PVOID));
    group->KeyLength = KeyLength;
    RtlCopyMemory(
        group->Key,
        Key,
        KeyLength
        );

    group->SignatureLength = CX_SIGNATURE_LENGTH;

    //
    // Set the initial refcount to 1.
    //
    group->RefCount = 1;

    *Group = group;

    return(STATUS_SUCCESS);

} // CnpAllocateMulticastGroup


VOID
CnpFreeMulticastGroup(
    IN PCNP_MULTICAST_GROUP Group
    )
{
    if (Group != NULL) {
        CnFreePool(Group);
    }

    return;

} // CnpFreeMulticastGroup


NTSTATUS
CnpConfigureBasicMulticastSettings(
    IN  HANDLE             Handle,
    IN  PFILE_OBJECT       FileObject,
    IN  PDEVICE_OBJECT     DeviceObject,
    IN  PTDI_ADDRESS_INFO  TdiBindAddressInfo,
    IN  ULONG              McastTtl,
    IN  UCHAR              McastLoop,
    IN  PIRP               Irp
    )
/*++

Routine Description:

    Set basic multicast parameters on the address object
    represented by Handle, FileObject, and DeviceObject
    using the interface represented by TdiBindAddressInfo.

Notes:

    This routine attaches to the system process when using
    handles, so it should not be called pre-attached.

--*/
{
    UDPMCastIFReq     mcastIfReq;
    ULONG             ifBindIp;
    BOOLEAN           attached = FALSE;

    NTSTATUS          status;

    //
    // Set this interface for outgoing multicast traffic.
    //
    ifBindIp = *((ULONG UNALIGNED *)
                 (&(((PTA_IP_ADDRESS)&(TdiBindAddressInfo->Address))
                   ->Address[0].Address[0].in_addr)
                  )
                 );

    mcastIfReq.umi_addr = ifBindIp;

    KeAttachProcess(CnSystemProcess);
    attached = TRUE;

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 AO_OPTION_MCASTIF,
                 &mcastIfReq,
                 sizeof(mcastIfReq)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Set mcast interface for "
                 "AO handle %p, IF %d.%d.%d.%d, status %x.\n",
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 status
                 ));
    }

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 AO_OPTION_MCASTTTL,
                 &McastTtl,
                 sizeof(McastTtl)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Set mcast TTL to %d on "
                 "AO handle %p, IF %d.%d.%d.%d, "
                 "status %x.\n",
                 McastTtl,
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 status
                 ));
    }

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 AO_OPTION_MCASTLOOP,
                 &McastLoop,
                 sizeof(McastLoop)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Set mcast loopback flag to %d on "
                 "AO handle %p, IF %d.%d.%d.%d, status %x.\n",
                 McastLoop,
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 status
                 ));
    }

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

error_exit:

    if (attached) {
        KeDetachProcess();
        attached = FALSE;
    }

    return(status);

}  // CnpConfigureBasicMulticastSettings


NTSTATUS
CnpAddRemoveMulticastAddress(
    IN  HANDLE             Handle,
    IN  PFILE_OBJECT       FileObject,
    IN  PDEVICE_OBJECT     DeviceObject,
    IN  PTDI_ADDRESS_INFO  TdiBindAddressInfo,
    IN  PTRANSPORT_ADDRESS TdiMcastBindAddress,
    IN  ULONG              OpId,
    IN  PIRP               Irp
    )
/*++

Routine Description:

    Add or remove the multicast address specified by
    TdiMcastBindAddress from the interface specified
    by TdiBindAddressInfo.

Arguments:

    OpId - either AO_OPTION_ADD_MCAST or AO_OPTION_DEL_MCAST

Notes:

    This routine attaches to the system process when using
    handles, so it should not be called pre-attached.

--*/
{
    UDPMCastReq    mcastAddDelReq;
    ULONG          mcastBindIp;
    ULONG          ifBindIp;
    BOOLEAN        attached = FALSE;

    NTSTATUS       status;

    mcastBindIp = *((ULONG UNALIGNED *)
                    (&(((PTA_IP_ADDRESS)TdiMcastBindAddress)
                       ->Address[0].Address[0].in_addr)
                     )
                    );
    ifBindIp = *((ULONG UNALIGNED *)
                 (&(((PTA_IP_ADDRESS)&(TdiBindAddressInfo->Address))
                    ->Address[0].Address[0].in_addr)
                  )
                 );

    mcastAddDelReq.umr_addr = mcastBindIp;
    mcastAddDelReq.umr_if = ifBindIp;

    KeAttachProcess(CnSystemProcess);
    attached = TRUE;

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 OpId,
                 &mcastAddDelReq,
                 sizeof(mcastAddDelReq)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Adjusted mcast binding on "
                 "interface for AO handle %p, "
                 "IF %d.%d.%d.%d, mcast addr %d.%d.%d.%d, "
                 "OpId %d, status %x.\n",
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 CnpIpAddrPrintArgs(mcastBindIp),
                 OpId,
                 status
                 ));
    }

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

error_exit:

    if (attached) {
        KeDetachProcess();
        attached = FALSE;
    }

    return(status);

} // CnpAddRemoveMulticastAddress


VOID
CnpStartInterfaceMcastTransition(
    PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Called during a multicast group transition. Clears
    the multicast received flag and enables discovery.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Conforms to the calling convention for
    PCNP_INTERFACE_UPDATE_ROUTINE.

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    if (Interface->Node != CnpLocalNode) {
        CnpInterfaceClearReceivedMulticast(Interface);
        Interface->McastDiscoverCount = CNP_INTERFACE_MCAST_DISCOVERY;
    }

    CnReleaseLock(&(Interface->Network->Lock), Interface->Network->Irql);

    return;

} // CnpStartInterfaceMcastTransition



//
// Cluster Transport Public Routines
//
NTSTATUS
CnpLoadNetworks(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is loading. Initializes
    static network-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    InitializeListHead(&CnpNetworkList);
    InitializeListHead(&CnpDeletingNetworkList);
    CnInitializeLock(&CnpNetworkListLock, CNP_NETWORK_LIST_LOCK);

    return(STATUS_SUCCESS);

} // CnpLoadNetworks


NTSTATUS
CnpInitializeNetworks(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is being (re)initialized.
    Initializes dynamic network-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();


    CnAssert(CnpNetworkShutdownEvent == NULL);
    CnAssert(IsListEmpty(&CnpNetworkList));
    CnAssert(IsListEmpty(&CnpDeletingNetworkList));

    CnpNetworkShutdownEvent = CnAllocatePool(sizeof(KEVENT));

    if (CnpNetworkShutdownEvent == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    KeInitializeEvent(CnpNetworkShutdownEvent, NotificationEvent, FALSE);
    CnpIsNetworkShutdownPending = FALSE;

    return(STATUS_SUCCESS);

} // CnpInitializeNetworks



VOID
CnpShutdownNetworks(
    VOID
    )
/*++

Routine Description:

    Called when a shutdown request is issued to the Cluster Network
    Driver. Deletes all network objects.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY   entry;
    CN_IRQL       listIrql;
    CN_IRQL       networkIrql;
    PCNP_NETWORK  network;
    NTSTATUS      status;
    BOOLEAN       waitEvent = FALSE;


    if (CnpNetworkShutdownEvent != NULL) {

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Cleaning up networks...\n"));
        }

        CnAcquireLock(&CnpNetworkListLock, &listIrql);

        while (!IsListEmpty(&CnpNetworkList)) {

            entry = CnpNetworkList.Flink;

            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));
            network->Irql = DISPATCH_LEVEL;

            CnpDeleteNetwork(network, listIrql);

            //
            // Both locks were released.
            //

            CnAcquireLock(&CnpNetworkListLock, &listIrql);
        }

        if (!IsListEmpty(&CnpDeletingNetworkList)) {
            CnpIsNetworkShutdownPending = TRUE;
            waitEvent = TRUE;
            KeResetEvent(CnpNetworkShutdownEvent);
        }

        CnReleaseLock(&CnpNetworkListLock, listIrql);

        if (waitEvent) {
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[CNP] Network deletes are pending...\n"));
            }

            status = KeWaitForSingleObject(
                         CnpNetworkShutdownEvent,
                         Executive,
                         KernelMode,
                         FALSE,        // not alertable
                         NULL          // no timeout
                         );

            CnAssert(status == STATUS_SUCCESS);
        }

        CnAssert(IsListEmpty(&CnpNetworkList));
        CnAssert(IsListEmpty(&CnpDeletingNetworkList));

        CnFreePool(CnpNetworkShutdownEvent); CnpNetworkShutdownEvent = NULL;

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Networks cleaned up.\n"));
        }

    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;
}



NTSTATUS
CxRegisterNetwork(
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    BOOLEAN             Restricted
    )
{
    NTSTATUS           status = STATUS_SUCCESS;
    PLIST_ENTRY        entry;
    CN_IRQL            listIrql;
    PCNP_NETWORK       network = NULL;


    if (!CnpIsValidNetworkId(NetworkId)) {
        return(STATUS_CLUSTER_INVALID_NETWORK);
    }

    //
    // Allocate and initialize a network object.
    //
    network = CnAllocatePool(sizeof(CNP_NETWORK));

    if (network == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(network, sizeof(CNP_NETWORK));

    CN_INIT_SIGNATURE(network, CNP_NETWORK_SIG);
    network->RefCount = 1;
    network->Id = NetworkId;
    network->State = ClusnetNetworkStateOffline;
    network->Priority = Priority;

    if (Restricted) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT(("[CNP] Registering network %u as restricted\n", NetworkId));
        }
        network->Flags |= CNP_NET_FLAG_RESTRICTED;
    }
    else {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT(("[CNP] Registering network %u as unrestricted\n", NetworkId));
        }
    }

    CnpNetworkResetMcastReachableNodes(network);

    CnInitializeLock(&(network->Lock), CNP_NETWORK_OBJECT_LOCK);

    CnAcquireLock(&CnpNetworkListLock, &listIrql);

    //
    // Check if the specified network already exists.
    //
    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList;
         entry = entry->Flink
        )
    {
        PCNP_NETWORK  oldNetwork = CONTAINING_RECORD(
                                       entry,
                                       CNP_NETWORK,
                                       Linkage
                                       );

        CnAcquireLock(&(oldNetwork->Lock), &(oldNetwork->Irql));

        if (NetworkId == oldNetwork->Id) {
            CnReleaseLock(&(oldNetwork->Lock), oldNetwork->Irql);
            CnReleaseLock(&CnpNetworkListLock, listIrql);

            status = STATUS_CLUSTER_NETWORK_EXISTS;

            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT(("[CNP] Network %u already exists\n", NetworkId));
            }

            goto error_exit;
        }

        CnReleaseLock(&(oldNetwork->Lock), oldNetwork->Irql);
    }

    InsertTailList(&CnpNetworkList, &(network->Linkage));
    network->Flags |= CNP_NET_FLAG_MCASTSORTED;

    CnReleaseLock(&CnpNetworkListLock, listIrql);

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Registered network %u\n", NetworkId));
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(STATUS_SUCCESS);


error_exit:

    if (network != NULL) {
        CnFreePool(network);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

} // CxRegisterNetwork



VOID
CxCancelDeregisterNetwork(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
/*++

Routine Description:

    Cancellation handler for DeregisterNetwork requests.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PFILE_OBJECT   fileObject;
    CN_IRQL        cancelIrql = Irp->CancelIrql;
    PLIST_ENTRY    entry;
    PCNP_NETWORK   network;


    CnMarkIoCancelLockAcquired();

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Attempting to cancel DeregisterNetwork irp %p\n",
            Irp
            ));
    }

    CnAssert(DeviceObject == CnDeviceObject);

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc(&CnpNetworkListLock);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // We can only complete the irp if we can find it stashed in a
    // deleting network object. The deleting network object could have
    // been destroyed and the IRP completed before we acquired the
    // CnpNetworkListLock.
    //
    for (entry = CnpDeletingNetworkList.Flink;
         entry != &CnpDeletingNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        if (network->PendingDeleteIrp == Irp) {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Found dereg irp on network %u\n",
                    network->Id
                    ));
            }

            //
            // Found the Irp. Now take it away and complete it.
            //
            network->PendingDeleteIrp = NULL;

            CnReleaseLock(&CnpNetworkListLock, cancelIrql);

            CnAcquireCancelSpinLock(&(Irp->CancelIrql));

            CnEndCancelRoutine(fileObject);

            CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);

            //
            // IoCancelSpinLock was released by CnCompletePendingRequest().
            //

            CnVerifyCpuLockMask(
                0,                  // Required
                0xFFFFFFFF,         // Forbidden
                0                   // Maximum
                );

            return;
        }
    }

    CnReleaseLock(&CnpNetworkListLock, cancelIrql);

    CnAcquireCancelSpinLock(&cancelIrql);

    CnEndCancelRoutine(fileObject);

    CnReleaseCancelSpinLock(cancelIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpCancelApiDeregisterNetwork



NTSTATUS
CxDeregisterNetwork(
    IN CL_NETWORK_ID       NetworkId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
{
    NTSTATUS           status;
    PLIST_ENTRY        entry;
    CN_IRQL            irql;
    PCNP_NETWORK       network = NULL;


    CnAcquireCancelSpinLock(&irql);
    CnAcquireLockAtDpc(&CnpNetworkListLock);

    status = CnMarkRequestPending(Irp, IrpSp, CxCancelDeregisterNetwork);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    if (status != STATUS_CANCELLED) {
        CnAssert(status == STATUS_SUCCESS);

        for (entry = CnpNetworkList.Flink;
             entry != &CnpNetworkList;
             entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));

            if (NetworkId == network->Id) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CNP] Deregistering network %u.\n",
                        NetworkId
                        ));
                }

                //
                // Save a pointer to pending irp. Note this is protected
                // by the list lock, not the object lock.
                //
                network->PendingDeleteIrp = Irp;

                CnpDeleteNetwork(network, irql);

                //
                // Both locks were released.
                // Irp will be completed when the network is destroyed
                // or the irp is cancelled.
                //

                CnVerifyCpuLockMask(
                    0,                  // Required
                    0xFFFFFFFF,         // Forbidden
                    0                   // Maximum
                    );

                return(STATUS_PENDING);
            }

            CnReleaseLockFromDpc(&(network->Lock));
        }

        CnReleaseLock(&CnpNetworkListLock, irql);

        CnAcquireCancelSpinLock(&(Irp->CancelIrql));

        CnCompletePendingRequest(Irp, STATUS_CLUSTER_NETWORK_NOT_FOUND, 0);

        CnVerifyCpuLockMask(
            0,                  // Required
            0xFFFFFFFF,         // Forbidden
            0                   // Maximum
            );

        return(STATUS_PENDING);
    }

    CnAssert(status == STATUS_CANCELLED);

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxDeregisterNetwork



NTSTATUS
CxOnlineNetwork(
    IN  CL_NETWORK_ID       NetworkId,
    IN  PWCHAR              TdiProviderName,
    IN  ULONG               TdiProviderNameLength,
    IN  PTRANSPORT_ADDRESS  TdiBindAddress,
    IN  ULONG               TdiBindAddressLength,
    IN  PWCHAR              AdapterName,
    IN  ULONG               AdapterNameLength,
    OUT PTDI_ADDRESS_INFO   TdiBindAddressInfo,
    IN  ULONG               TdiBindAddressInfoLength,
    IN  PIRP                Irp                       OPTIONAL
)
/*++

Notes:

    Each associated interface will be brought online when a heartbeat
    is established for the target of the interface.

--*/
{

    NTSTATUS                               status;
    PCNP_NETWORK                           network;
    OBJECT_ATTRIBUTES                      objectAttributes;
    IO_STATUS_BLOCK                        iosb;
    PFILE_FULL_EA_INFORMATION              ea = NULL;
    ULONG                                  eaBufferLength;
    HANDLE                                 addressHandle = NULL;
    PFILE_OBJECT                           addressFileObject = NULL;
    PDEVICE_OBJECT                         addressDeviceObject = NULL;
    BOOLEAN                                attached = FALSE;
    UNICODE_STRING                         unicodeString;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO                      addressInfo;


    //
    // Allocate memory to hold the EA buffer we'll use to specify the
    // transport address to NtCreateFile.
    //
    eaBufferLength = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                     TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                     TdiBindAddressLength;

    ea = CnAllocatePool(eaBufferLength);

    if (ea == NULL) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] memory allocation of %u bytes failed.\n",
                eaBufferLength
                ));
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the EA using the network's transport information.
    //
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = (USHORT) TdiBindAddressLength;

    RtlMoveMemory(
        ea->EaName,
        TdiTransportAddress,
        ea->EaNameLength + 1
        );

    RtlMoveMemory(
        &(ea->EaName[ea->EaNameLength + 1]),
        TdiBindAddress,
        TdiBindAddressLength
        );

    RtlInitUnicodeString(&unicodeString, TdiProviderName);

    network = CnpFindNetwork(NetworkId);

    if (network == NULL) {
        CnFreePool(ea);
        return(STATUS_CLUSTER_NETWORK_NOT_FOUND);
    }

    if (network->State != ClusnetNetworkStateOffline) {
        CnReleaseLock(&(network->Lock), network->Irql);
        CnFreePool(ea);
        return(STATUS_CLUSTER_NETWORK_ALREADY_ONLINE);
    }

    CnAssert(network->DatagramHandle == NULL);
    CnAssert(network->DatagramFileObject == NULL);
    CnAssert(network->DatagramDeviceObject == NULL);
    CnAssert(network->ActiveRefCount == 0);

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Bringing network %u online...\n", NetworkId));
    }

    //
    // Set the initial active refcount to 2. One reference will be removed
    // when the network is successfully brought online. The other will be
    // removed when the network is to be taken offline. Also increment the
    // base refcount to account for the active refcount. Change to
    // the online pending state.
    //
    network->ActiveRefCount = 2;
    CnpReferenceNetwork(network);
    network->State = ClusnetNetworkStateOnlinePending;

    CnReleaseLock(&(network->Lock), network->Irql);

    //
    // Prepare for opening the address object.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,         // attributes
        NULL,
        NULL
        );

    //
    // Attach to the system process so the handle we open will remain valid
    // after the calling process goes away.
    //
    KeAttachProcess(CnSystemProcess);
    attached = TRUE;

    //
    // Perform the actual open of the address object.
    //
    status = ZwCreateFile(
                 &addressHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 0,                              // not shareable
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 ea,
                 eaBufferLength
                 );

    CnFreePool(ea); ea = NULL;

    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to open address for network %u, status %lx.\n",
                NetworkId,
                status
                ));
        }

        goto error_exit;
    }

    //
    // Get a pointer to the file object of the address.
    //
    status = ObReferenceObjectByHandle(
                 addressHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 &addressFileObject,
                 NULL
                 );

    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to reference address handle, status %lx.\n",
                status
                ));
        }

        goto error_exit;
    }

    //
    // Remember the device object to which we need to give requests for
    // this address object.  We can't just use the fileObject->DeviceObject
    // pointer because there may be a device attached to the transport
    // protocol.
    //
    addressDeviceObject = IoGetRelatedDeviceObject(
                              addressFileObject
                              );

    //
    // Adjust the StackSize of CdpDeviceObject so that we can pass CDP
    // IRPs through for this network.
    //
    CnAdjustDeviceObjectStackSize(CdpDeviceObject, addressDeviceObject);

    //
    // Get the transport provider info
    //
    queryInfo.QueryType = TDI_QUERY_PROVIDER_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = CnpIssueDeviceControl(
                 addressFileObject,
                 addressDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 &(network->ProviderInfo),
                 sizeof(network->ProviderInfo),
                 TDI_QUERY_INFORMATION,
                 Irp
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to get provider info, status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    if (! ( network->ProviderInfo.ServiceFlags &
            TDI_SERVICE_CONNECTIONLESS_MODE)
       )
    {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Provider doesn't support datagrams!\n"
                ));
        }
        status = STATUS_CLUSTER_INVALID_NETWORK_PROVIDER;
        goto error_exit;
    }

    //
    // Get the address to which we were bound.
    //
    queryInfo.QueryType = TDI_QUERY_ADDRESS_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = CnpIssueDeviceControl(
                 addressFileObject,
                 addressDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 TdiBindAddressInfo,
                 TdiBindAddressInfoLength,
                 TDI_QUERY_INFORMATION,
                 Irp
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to get address info, status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // Set up indication handlers on the address object. We are eligible
    // to receive indications as soon as we do this.
    //
    status = CnpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_ERROR,
                 CnpTdiErrorHandler,
                 network,
                 Irp
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Setting TDI_EVENT_ERROR failed: %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    status = CnpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 CnpTdiReceiveDatagramHandler,
                 network,
                 Irp
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Setting TDI_EVENT_RECEIVE_DATAGRAM failed: %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // We're done working with handles, so detach from the system process.
    //
    KeDetachProcess();

    //
    // Finish transition to online state. Note that an offline request
    // could have been issued in the meantime.
    //
    CnAcquireLock(&(network->Lock), &(network->Irql));

    network->DatagramHandle = addressHandle;
    addressHandle = NULL;
    network->DatagramFileObject = addressFileObject;
    addressFileObject = NULL;
    network->DatagramDeviceObject = addressDeviceObject;
    addressDeviceObject = NULL;

    //
    // If an offline wasn't issued, change to the online state.
    //
    if (network->State == ClusnetNetworkStateOnlinePending) {

        CnAssert(network->ActiveRefCount == 2);
        network->State = ClusnetNetworkStateOnline;

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT(("[CNP] Network %u is now online.\n", NetworkId));
        }

        CnReleaseLock(&(network->Lock), network->Irql);

        //
        // Bring all of the interfaces on this network online.
        //
        // The network can't be taken offline because we still hold
        // the 2nd active reference.
        //
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Bringing all interfaces on network %u online...\n",
                network->Id
                ));
        }

        CnpWalkInterfacesOnNetwork(network, CnpOnlinePendingInterfaceWrapper);

        //
        // Position the network in the network list according to
        // multicast reachability.
        //
        CnpSortMulticastNetwork(network, TRUE, NULL);

        //
        // Reacquire the lock to drop the active reference.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
    }
    else {
        //
        // An offline was issued. It will take effect when we
        // remove our 2nd active reference. The offline operation removed
        // the first one. No send threads could have accessed this network
        // yet because we never brought the associated interfaces online.
        //
        CnAssert(network->State == ClusnetNetworkStateOfflinePending);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] An offline request was issued on network %u during online pending.\n",
                NetworkId
                ));
        }
    }

    CnpActiveDereferenceNetwork(network);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(STATUS_SUCCESS);


error_exit:

    if (addressFileObject != NULL) {
        ObDereferenceObject(addressFileObject);
    }

    if (addressHandle != NULL) {
        ZwClose(addressHandle);
    }

    KeDetachProcess();

    CnAcquireLock(&(network->Lock), &(network->Irql));

    if (network->State == ClusnetNetworkStateOnlinePending) {
        //
        // Remove our 2nd active reference and call the offline code.
        // The offline function will release the network object lock.
        //
        CnAssert(network->ActiveRefCount == 2);

        --(network->ActiveRefCount);

        CnpOfflineNetwork(network);
    }
    else {
        CnAssert(network->State == ClusnetNetworkStateOfflinePending);
        //
        // An offline was issued. It will take effect when we
        // remove our 2nd active reference. The offline operation removed
        // the first one. The dereference will release the network object
        // lock.
        //
        CnAssert(network->State == ClusnetNetworkStateOfflinePending);
        CnAssert(network->ActiveRefCount == 1);

        CnpActiveDereferenceNetwork(network);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOnlineNetwork



VOID
CxCancelOfflineNetwork(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
/*++

Routine Description:

    Cancellation handler for OfflineNetwork requests.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PFILE_OBJECT   fileObject;
    CN_IRQL        cancelIrql = Irp->CancelIrql;
    PLIST_ENTRY    entry;
    PCNP_NETWORK   network;
    PCNP_NETWORK   offlineNetwork = NULL;


    CnMarkIoCancelLockAcquired();

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Attempting to cancel OfflineNetwork irp %p\n",
            Irp
            ));
    }

    CnAssert(DeviceObject == CnDeviceObject);

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc(&CnpNetworkListLock);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // We can only complete the irp if we can find it stashed in a
    // network object. The network object could have been destroyed
    // and the IRP completed before we acquired the CnpNetworkListLock.
    //
    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        CnAcquireLockAtDpc(&(network->Lock));

        if (network->PendingOfflineIrp == Irp) {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Found offline irp on network %u\n",
                    network->Id
                    ));
            }

            network->PendingOfflineIrp = NULL;
            offlineNetwork = network;

            CnReleaseLockFromDpc(&(network->Lock));

            break;
        }

        CnReleaseLockFromDpc(&(network->Lock));
    }

    if (offlineNetwork == NULL) {
        for (entry = CnpDeletingNetworkList.Flink;
             entry != &CnpDeletingNetworkList;
             entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));

            if (network->PendingOfflineIrp == Irp) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CNP] Found offline irp on network %u\n",
                        network->Id
                        ));
                }

                network->PendingOfflineIrp = NULL;
                offlineNetwork = network;

                CnReleaseLockFromDpc(&(network->Lock));

                break;
            }

            CnReleaseLockFromDpc(&(network->Lock));
        }
    }

    CnReleaseLock(&CnpNetworkListLock, cancelIrql);

    CnAcquireCancelSpinLock(&cancelIrql);

    CnEndCancelRoutine(fileObject);

    if (offlineNetwork != NULL) {
        //
        // Found the Irp. Now take it away and complete it.
        // This releases the cancel spinlock
        //
        Irp->CancelIrql = cancelIrql;
        CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);
    }
    else {
        CnReleaseCancelSpinLock(cancelIrql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpCancelApiOfflineNetwork



NTSTATUS
CxOfflineNetwork(
    IN CL_NETWORK_ID       NetworkId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Notes:


--*/
{
    PCNP_NETWORK   network;
    CN_IRQL        irql;
    NTSTATUS       status;


    CnAcquireCancelSpinLock(&irql);
    CnAcquireLockAtDpc(&CnpNetworkListLock);

    status = CnMarkRequestPending(Irp, IrpSp, CxCancelOfflineNetwork);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    if (status != STATUS_CANCELLED) {
        CnAssert(status == STATUS_SUCCESS);

        network = CnpLockedFindNetwork(NetworkId, irql);

        //
        // CnpNetworkListLock was released.
        //

        if (network != NULL) {
            if (network->State >= ClusnetNetworkStateOnlinePending) {

                network->PendingOfflineIrp = Irp;

                CnpOfflineNetwork(network);

                return(STATUS_PENDING);
            }

            CnReleaseLock(&(network->Lock), network->Irql);

            status = STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE;
        }
        else {
            status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
        }

        CnAcquireCancelSpinLock(&irql);
        Irp->CancelIrql = irql;

        CnCompletePendingRequest(Irp, status, 0);

        CnVerifyCpuLockMask(
            0,                  // Required
            0xFFFFFFFF,         // Forbidden
            0                   // Maximum
            );

        return(STATUS_PENDING);
    }

    CnAssert(status == STATUS_CANCELLED);

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOfflineNetwork



NTSTATUS
CxSetNetworkRestriction(
    IN CL_NETWORK_ID  NetworkId,
    IN BOOLEAN        Restricted,
    IN ULONG          NewPriority
    )
{
    NTSTATUS           status;
    PCNP_NETWORK       network;


    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        if (Restricted) {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Restricting network %u.\n",
                    network->Id
                    ));
            }

            network->Flags |= CNP_NET_FLAG_RESTRICTED;
        }
        else {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Unrestricting network %u.\n",
                    network->Id
                    ));
            }

            network->Flags &= ~CNP_NET_FLAG_RESTRICTED;

            if (NewPriority != 0) {
                network->Priority = NewPriority;
            }
        }

        //
        // Reference the network so it can't go away while we
        // reprioritize the associated interfaces.
        //
        CnpReferenceNetwork(network);

        CnReleaseLock(&(network->Lock), network->Irql);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Recalculating priority for all interfaces on network %u ...\n",
                network->Id
                ));
        }

        if (!Restricted) {
            CnpWalkInterfacesOnNetwork(
                network,
                CnpRecalculateInterfacePriority
                );
        }

        CnpWalkInterfacesOnNetwork(network, CnpReevaluateInterfaceRole);

        //
        // Reposition the network according to multicast reachability.
        //
        CnpSortMulticastNetwork(network, TRUE, NULL);

        CnAcquireLock(&(network->Lock), &(network->Irql));

        CnpDereferenceNetwork(network);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxSetNetworkRestriction



NTSTATUS
CxSetNetworkPriority(
    IN CL_NETWORK_ID  NetworkId,
    IN ULONG          Priority
    )
{
    NTSTATUS           status;
    PCNP_NETWORK       network;


    if (Priority == 0) {
        return(STATUS_INVALID_PARAMETER);
    }

    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Network %u old priority %u, new priority %u.\n",
                network->Id,
                network->Priority,
                Priority
                ));
        }

        network->Priority = Priority;

        //
        // Reference the network so it can't go away while we
        // reprioritize the associated interfaces.
        //
        CnpReferenceNetwork(network);

        CnReleaseLock(&(network->Lock), network->Irql);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Recalculating priority for all interfaces on network %u ...\n",
                network->Id
                ));
        }

        CnpWalkInterfacesOnNetwork(network, CnpRecalculateInterfacePriority);

        //
        // Reposition the network according to multicast reachability.
        //
        CnpSortMulticastNetwork(network, TRUE, NULL);

        CnAcquireLock(&(network->Lock), &(network->Irql));

        CnpDereferenceNetwork(network);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxSetNetworkPriority



NTSTATUS
CxGetNetworkPriority(
    IN  CL_NETWORK_ID   NetworkId,
    OUT PULONG          Priority
    )
{
    NTSTATUS       status;
    PCNP_NETWORK   network;


    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        *Priority = network->Priority;

        CnReleaseLock(&(network->Lock), network->Irql);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNetworkPriority



NTSTATUS
CxGetNetworkState(
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    )
{
    NTSTATUS       status;
    PCNP_NETWORK   network;


    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        *State = network->State;

        CnReleaseLock(&(network->Lock), network->Irql);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNetworkState


NTSTATUS
CxUnreserveClusnetEndpoint(
    VOID
    )
/*++

Routine Description:

    Unreserves port number previously reserved with
    CxUnreserveClusnetEndpoint.

    CnResource should already be held when this routine
    is called. Alternately, this routine is called without
    CnResource held during unload of the clusnet driver.

Arguments:

    None.

Return Value:

    Status of TCP/IP ioctl.

--*/
{
    HANDLE tcpHandle = (HANDLE) NULL;
    TCP_RESERVE_PORT_RANGE portRange;
    NTSTATUS status = STATUS_SUCCESS;

    // Check if we have a port reserved
    if (CnpReservedClusnetPort != 0) {

        status = CnpOpenDevice(
                     DD_TCP_DEVICE_NAME,
                     &tcpHandle
                     );
        if (NT_SUCCESS(status)) {

            // TCP/IP interprets port ranges in host order
            portRange.LowerRange = CnpReservedClusnetPort;
            portRange.UpperRange = CnpReservedClusnetPort;

            status = CnpZwDeviceControl(
                         tcpHandle,
                         IOCTL_TCP_UNRESERVE_PORT_RANGE,
                         &portRange,
                         sizeof(portRange),
                         NULL,
                         0
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Failed to unreserve "
                             "port %d: %lx\n",
                             CnpReservedClusnetPort, status));
                }
            } else {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Unreserved "
                             "port %d.\n",
                             CnpReservedClusnetPort));
                }
            }

            ZwClose(tcpHandle);

        } else {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT(("[Clusnet] Failed to open device %S, "
                         "status %lx\n",
                         DD_TCP_DEVICE_NAME, status));
            }
        }

        CnpReservedClusnetPort = 0;
    }

    return status;
}


NTSTATUS
CxReserveClusnetEndpoint(
    IN USHORT Port
    )
/*++

Routine Description:

    Reserves assigned clusnet endpoint port number so that
    the TCP/IP driver will not hand it out to applications
    requesting a wildcard port.

Arguments:

    Port - port number to reserve, in host byte-order format

Return Value:

    Status of TCP/IP ioctl.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE tcpHandle = (HANDLE) NULL;
    TCP_RESERVE_PORT_RANGE portRange;

    // Check for invalid port number 0
    if (Port == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    // Check if we already have a port reserved.
    if (CnpReservedClusnetPort != 0
        && CnpReservedClusnetPort != Port) {

        status = CxUnreserveClusnetEndpoint();
    }

    if (CnpReservedClusnetPort == 0) {

        // Reserve Port with the TCP/IP driver.
        status = CnpOpenDevice(
                     DD_TCP_DEVICE_NAME,
                     &tcpHandle
                     );
        if (NT_SUCCESS(status)) {

            // TCP/IP interprets port ranges in host order
            portRange.LowerRange = Port;
            portRange.UpperRange = Port;

            status = CnpZwDeviceControl(
                         tcpHandle,
                         IOCTL_TCP_RESERVE_PORT_RANGE,
                         &portRange,
                         sizeof(portRange),
                         NULL,
                         0
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Failed to reserve "
                             "port %d: %lx\n",
                             Port, status));
                }
            } else {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Reserved "
                             "port %d.\n",
                             Port));
                }
                CnpReservedClusnetPort = Port;
            }

            ZwClose(tcpHandle);

        } else {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT(("[Clusnet] Failed to open device %S, "
                         "status %lx\n",
                         DD_TCP_DEVICE_NAME, status));
            }
        }
    }

    return status;

} // CxReserveClusnetEndpoint

NTSTATUS
CxConfigureMulticast(
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               MulticastNetworkBrand,
    IN PTRANSPORT_ADDRESS  TdiMcastBindAddress,
    IN ULONG               TdiMcastBindAddressLength,
    IN PVOID               Key,
    IN ULONG               KeyLength,
    IN PIRP                Irp
    )
/*++

Routine Description:

    Configures a network for multicast.

Notes:

    The network multicast flag is turned off at the
    beginning of this routine to prevent multicasts
    during the transition. If the routine does not
    complete successfully, the multicast flag is
    purposely left cleared.

--*/
{
    NTSTATUS                               status;
    KIRQL                                  irql;
    PLIST_ENTRY                            entry;
    PCNP_NETWORK                           network = NULL;
    BOOLEAN                                networkLocked = FALSE;
    BOOLEAN                                mcastEnabled = FALSE;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO                      addressInfo;
    HANDLE                                 networkHandle;
    PFILE_OBJECT                           networkFileObject;
    PDEVICE_OBJECT                         networkDeviceObject;

    PCNP_MULTICAST_GROUP                   group = NULL;
    PCNP_MULTICAST_GROUP                   delGroup = NULL;
    PCNP_MULTICAST_GROUP                   currGroup = NULL;
    PCNP_MULTICAST_GROUP                   prevGroup = NULL;
    BOOLEAN                                prevGroupMatch = FALSE;

    UCHAR addressInfoBuffer[FIELD_OFFSET(TDI_ADDRESS_INFO, Address) +
                            sizeof(TA_IP_ADDRESS)] = {0};

    //
    // Validate multicast bind address parameter. Even if this
    // request only leaves a group, the multicast address data
    // structure must be provided.
    //
    if (TdiMcastBindAddressLength != sizeof(TA_IP_ADDRESS)) {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Acquire the lock on the local node, but go through the
    // node table to be extra paranoid.
    //
    CnAcquireLock(&CnpNodeTableLock, &irql);

    if (CnpLocalNode != NULL) {

        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = irql;

        //
        // Find the network object in the network object table.
        //
        CnAcquireLockAtDpc(&CnpNetworkListLock);

        for (entry = CnpNetworkList.Flink;
             entry != &CnpNetworkList;
             entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));

            if (NetworkId == network->Id) {

                //
                // We now hold locks on the node, the network list,
                // and the network.

                //
                // Verify the network state. Then take an active
                // reference so that it doesn't disappear while
                // we're working with it.
                //
                if ((network->State < ClusnetNetworkStateOnline) ||
                    (!CnpActiveReferenceNetwork(network))
                    ) {
                    CnReleaseLockFromDpc(&(network->Lock));
                    CnReleaseLockFromDpc(&CnpNetworkListLock);
                    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
                    return(STATUS_CLUSTER_INVALID_NETWORK);
                }

                //
                // Clear the reachable set for this network.
                //
                CnpMulticastChangeNodeReachabilityLocked(
                    network,
                    CnpLocalNode,
                    FALSE,
                    TRUE,
                    NULL
                    );

                //
                // Remember whether the network was multicast-capable. Then
                // clear the multicast capable flag so that we don't try to
                // send multicasts during the transition period.
                //
                mcastEnabled = (BOOLEAN) CnpIsNetworkMulticastCapable(network);
                network->Flags &= ~CNP_NET_FLAG_MULTICAST;

                networkHandle = network->DatagramHandle;
                networkFileObject = network->DatagramFileObject;
                networkDeviceObject = network->DatagramDeviceObject;

                currGroup = network->CurrentMcastGroup;
                if (currGroup != NULL) {
                    CnpReferenceMulticastGroup(currGroup);
                }
                prevGroup = network->PreviousMcastGroup;
                if (prevGroup != NULL) {
                    CnpReferenceMulticastGroup(prevGroup);
                }

                //
                // Release the network lock.
                //
                CnReleaseLockFromDpc(&(network->Lock));
                networkLocked = FALSE;

                //
                // Break out of the network search.
                //
                break;

            } else {
                CnReleaseLockFromDpc(&(network->Lock));
                network = NULL;
            }
        }

        //
        // Release the network list lock.
        //
        CnReleaseLockFromDpc(&CnpNetworkListLock);

        //
        // Release the local node lock.
        //
        CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);

    } else {
        CnReleaseLock(&CnpNodeTableLock, irql);

        CnTrace(CNP_NET_DETAIL, CnpTraceMcastPreConfigNoHost,
            "[CNP] Cannot configure multicast for network %u "
            "because local host not found.",
            NetworkId
            );

        return(STATUS_HOST_UNREACHABLE);
    }

    //
    // Verify that we found the network.
    //
    if (network == NULL) {
        return (STATUS_CLUSTER_NETWORK_NOT_FOUND);
    }

    //
    // Allocate a multicast group data structure with the
    // new configuration parameters.
    //
    status = CnpAllocateMulticastGroup(
                 MulticastNetworkBrand,
                 TdiMcastBindAddress,
                 TdiMcastBindAddressLength,
                 Key,
                 KeyLength,
                 &group
                 );
    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_NETOBJ) {
            CNPRINT((
                "[CNP] Failed to allocate mcast group, "
                "status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // Get the local interface address.
    //
    addressInfo = (PTDI_ADDRESS_INFO) &addressInfoBuffer[0];
    queryInfo.QueryType = TDI_QUERY_ADDRESS_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = CnpIssueDeviceControl(
                 networkFileObject,
                 networkDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 addressInfo,
                 sizeof(addressInfoBuffer),
                 TDI_QUERY_INFORMATION,
                 Irp
                 );
    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_NETOBJ) {
            CNPRINT((
                "[CNP] Failed to get address info, status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // Determine if the multicast bind address is valid. If not,
    // we are disabling.
    //
    if (CnpIsIPv4McastTransportAddress(TdiMcastBindAddress)) {

        // temp vars for logging
        ULONG         mcastBindIp;
        ULONG         ifBindIp;

        mcastBindIp = *((ULONG UNALIGNED *)
                        (&(((PTA_IP_ADDRESS)TdiMcastBindAddress)
                           ->Address[0].Address[0].in_addr)
                         )
                        );
        ifBindIp = *((ULONG UNALIGNED *)
                     (&(((PTA_IP_ADDRESS)&(addressInfo->Address))
                        ->Address[0].Address[0].in_addr)
                      )
                     );

        //
        // We are trying to join a new multicast group. Fail
        // immediately if there is no key.
        //
        if (KeyLength == 0) {
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT((
                    "[CNP] Cannot configure new multicast group "
                    "without key.\n"
                    ));
            }
            status = STATUS_INVALID_PARAMETER;
            goto error_exit;
        }

        //
        // Configure basic multicast settings if not done
        // previously (though this call is idempotent).
        //
        if (!mcastEnabled) {

            status = CnpConfigureBasicMulticastSettings(
                         networkHandle,
                         networkFileObject,
                         networkDeviceObject,
                         addressInfo,
                         1, // ttl
                         0, // disable loopback
                         Irp
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_NETOBJ) {
                    CNPRINT((
                        "[CNP] Failed to configure basic "
                        "multicast settings, status %lx\n",
                        status
                        ));
                }
                goto error_exit;
            }
        }

        //
        // Add the group address if we are not already in
        // this multicast group (e.g. the multicast bind
        // address is the same as the current group or
        // previous group).
        //
        if (prevGroup != NULL &&
            CnpIsIPv4McastSameGroup(
                prevGroup->McastTdiAddress,
                TdiMcastBindAddress
                )
            ) {
            prevGroupMatch = TRUE;
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT(("[CNP] New mcast address matches "
                         "previous mcast address.\n"));
            }
            CnTrace(CNP_NET_DETAIL, CnpTraceMcastNewPrevGroupMatch,
                "[CNP] New multicast group %!ipaddr! "
                "for interface %!ipaddr!, network id %d, "
                "matches previous group.",
                mcastBindIp,
                ifBindIp,
                NetworkId
                );
        }
        else if (currGroup != NULL &&
                 CnpIsIPv4McastSameGroup(
                     currGroup->McastTdiAddress,
                     TdiMcastBindAddress
                     )
                 ) {
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT(("[CNP] New mcast address matches "
                         "current mcast address.\n"));
            }
            CnTrace(CNP_NET_DETAIL, CnpTraceMcastNewCurrGroupMatch,
                "[CNP] New multicast group %!ipaddr! "
                "for interface %!ipaddr!, network id %d, "
                "matches current group.",
                mcastBindIp,
                ifBindIp,
                NetworkId
                );
        } else {

            status = CnpAddRemoveMulticastAddress(
                         networkHandle,
                         networkFileObject,
                         networkDeviceObject,
                         addressInfo,
                         TdiMcastBindAddress,
                         AO_OPTION_ADD_MCAST,
                         Irp
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_NETOBJ) {
                    CNPRINT((
                        "[CNP] Failed to add mcast address, "
                        "status %lx\n",
                        status
                        ));
                }
                CnTrace(CNP_NET_DETAIL, CnpTraceMcastAddGroupFailed,
                    "[CNP] Failed to add multicast group %!ipaddr! to "
                    "interface %!ipaddr! network id %d, "
                    "status %!status!.",
                    mcastBindIp,
                    ifBindIp,
                    NetworkId,
                    status
                    );
                goto error_exit;
            } else {
                CnTrace(CNP_NET_DETAIL, CnpTraceMcastAddGroup,
                    "[CNP] Added multicast group %!ipaddr! to "
                    "interface %!ipaddr!, network id %d.",
                    mcastBindIp,
                    ifBindIp,
                    NetworkId
                    );
            }
        }
    }

    //
    // Leave membership for previous group if
    // - the previous group does not match the new group, AND
    // - the previous group does not match the current group
    //
    if (!prevGroupMatch &&
        prevGroup != NULL &&
        CnpIsIPv4McastTransportAddress(prevGroup->McastTdiAddress)) {

        // temp vars for logging
        ULONG         mcastBindIp;
        ULONG         ifBindIp;

        mcastBindIp = *((ULONG UNALIGNED *)
                        (&(((PTA_IP_ADDRESS)prevGroup->McastTdiAddress)
                           ->Address[0].Address[0].in_addr)
                         )
                        );
        ifBindIp = *((ULONG UNALIGNED *)
                     (&(((PTA_IP_ADDRESS)&(addressInfo->Address))
                        ->Address[0].Address[0].in_addr)
                      )
                     );

        if (!CnpIsIPv4McastSameGroup(
                 prevGroup->McastTdiAddress,
                 currGroup->McastTdiAddress
                 )) {

            status = CnpAddRemoveMulticastAddress(
                         networkHandle,
                         networkFileObject,
                         networkDeviceObject,
                         addressInfo,
                         prevGroup->McastTdiAddress,
                         AO_OPTION_DEL_MCAST,
                         Irp
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_NETOBJ) {
                    CNPRINT((
                        "[CNP] Failed to leave mcast group, "
                        "IF %d.%d.%d.%d, mcast addr %d.%d.%d.%d, "
                        "status %lx.\n",
                        CnpIpAddrPrintArgs(ifBindIp),
                        CnpIpAddrPrintArgs(mcastBindIp),
                        status
                        ));
                }
                CnTrace(CNP_NET_DETAIL, CnpTraceMcastLeaveGroupFailed,
                    "[CNP] Failed to leave multicast group %!ipaddr! on "
                    "interface %!ipaddr!, network id %d, "
                    "status %!status!. Continuing anyway.",
                    mcastBindIp,
                    ifBindIp,
                    NetworkId,
                    status
                    );
                // not considered a fatal error
                status = STATUS_SUCCESS;
            } else {
                CnTrace(CNP_NET_DETAIL, CnpTraceMcastLeaveGroup,
                    "[CNP] Left multicast group %!ipaddr! on "
                    "interface %!ipaddr!, network id %d.",
                    mcastBindIp,
                    ifBindIp,
                    NetworkId
                    );
            }
        } else {
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT(("[CNP] Prev mcast address matches "
                         "current mcast address.\n"));
            }
            CnTrace(CNP_NET_DETAIL, CnpTraceMcastCurrPrevGroupMatch,
                "[CNP] Previous multicast group %!ipaddr! "
                "on interface %!ipaddr!, network id %d, "
                "matches current group. Not leaving.",
                mcastBindIp,
                ifBindIp,
                NetworkId
                );
        }
    }

    //
    // Reacquire the network lock to make changes
    // to the network object data structure, including
    // shifting the multicast group data structures and
    // turning on the multicast flag. The multicast flag
    // was turned off earlier in this routine before
    // starting the transition. It is only re-enabled if
    // the new multicast bind address is a valid multicast
    // address.
    //
    CnAcquireLock(&(network->Lock), &(network->Irql));
    networkLocked = TRUE;

    delGroup = network->PreviousMcastGroup;
    network->PreviousMcastGroup = network->CurrentMcastGroup;
    network->CurrentMcastGroup = group;
    group = NULL;

    if (CnpIsIPv4McastTransportAddress(TdiMcastBindAddress)) {
        network->Flags |= CNP_NET_FLAG_MULTICAST;
    }

    CnReleaseLock(&(network->Lock), network->Irql);
    networkLocked = FALSE;

    //
    // Transition into new multicast group, if appropriate.
    //
    if (CnpIsIPv4McastTransportAddress(TdiMcastBindAddress)) {

        //
        // Switch all outgoing heartbeats on this node to
        // unicast with discovery.
        //
        CnpWalkInterfacesOnNetwork(
            network,
            CnpStartInterfaceMcastTransition
            );
    }

error_exit:

    if (networkLocked) {
        CnReleaseLock(&(network->Lock), network->Irql);
        networkLocked = FALSE;
    }

    //
    // Reposition the network according to multicast reachability.
    //
    CnpSortMulticastNetwork(network, TRUE, NULL);

    CnAcquireLock(&(network->Lock), &(network->Irql));

    CnpActiveDereferenceNetwork(network);

    if (group != NULL) {
        CnpDereferenceMulticastGroup(group);
    }

    if (currGroup != NULL) {
        CnpDereferenceMulticastGroup(currGroup);
    }

    if (prevGroup != NULL) {
        CnpDereferenceMulticastGroup(prevGroup);
    }

    if (delGroup != NULL) {
        CnpDereferenceMulticastGroup(delGroup);
    }

    return(status);

} // CxConfigureMulticast


BOOLEAN
CnpSortMulticastNetwork(
    IN  PCNP_NETWORK        Network,
    IN  BOOLEAN             RaiseEvent,
    OUT CX_CLUSTERSCREEN  * McastReachableNodes      OPTIONAL
    )
/*++

Routine Description:

    Wrapper for CnpSortMulticastNetworkLocked.

Return value:

    TRUE if reachable node set changed

Notes:

    Acquires and releases CnpNetworkListLock.

--*/
{
    KIRQL    irql;
    BOOLEAN  setChanged = FALSE;

    CnVerifyCpuLockMask(
        0,                       // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    CnAcquireLock(&CnpNetworkListLock, &irql);

    setChanged = CnpSortMulticastNetworkLocked(
                     Network,
                     RaiseEvent,
                     McastReachableNodes
                     );

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        0,                       // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpSortMulticastNetwork


BOOLEAN
CnpMulticastChangeNodeReachability(
    IN  PCNP_NETWORK       Network,
    IN  PCNP_NODE          Node,
    IN  BOOLEAN            Reachable,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * NewMcastReachableNodes
    )
/*++

Routine Description:

    Changes the multicast reachability state of Node
    on Network.

    If the set of reachable nodes changes, returns
    the new screen through NewMcastReachableNodes.

Return value:

    TRUE if set of reachable nodes changes.

Notes:

    Called and returns with node lock held.

--*/
{
    KIRQL            irql;
    BOOLEAN          setChanged = FALSE;

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,    // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    CnAcquireLock(&CnpNetworkListLock, &irql);

    setChanged = CnpMulticastChangeNodeReachabilityLocked(
                     Network,
                     Node,
                     Reachable,
                     RaiseEvent,
                     NewMcastReachableNodes
                     );

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,    // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpMulticastChangeNodeReachability


PCNP_NETWORK
CnpGetBestMulticastNetwork(
    VOID
    )
/*++

Routine Description:

    Returns network object that currently has best
    node reachability.

Return value:

    Best network object, or NULL if there are no
    internal multicast networks.

Notes:

    Must not be called with network list lock held.
    Returns with network locked (if found).

--*/
{
    PCNP_NETWORK   network = NULL;
    KIRQL          listIrql;
    KIRQL          networkIrql;

    CnVerifyCpuLockMask(
        0,                                                 // required
        (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK), // forbidden
        CNP_NODE_OBJECT_LOCK_MAX                           // max
        );

    CnAcquireLock(&CnpNetworkListLock, &listIrql);

    if (!IsListEmpty(&CnpNetworkList)) {

        network = CONTAINING_RECORD(
                      CnpNetworkList.Flink,
                      CNP_NETWORK,
                      Linkage
                      );

        CnAcquireLock(&(network->Lock), &networkIrql);

        if (CnpIsInternalMulticastNetwork(network)) {

            CnReleaseLock(&CnpNetworkListLock, networkIrql);
            network->Irql = listIrql;

            CnVerifyCpuLockMask(
                CNP_NETWORK_OBJECT_LOCK,          // required
                CNP_NETWORK_LIST_LOCK,            // forbidden
                CNP_NETWORK_OBJECT_LOCK_MAX       // max
                );

        } else {

            CnReleaseLock(&(network->Lock), networkIrql);
            network = NULL;
        }
    }

    if (network == NULL) {

        CnReleaseLock(&CnpNetworkListLock, listIrql);

        CnVerifyCpuLockMask(
            0,                                                 // required
            (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK), // forbidden
            CNP_NODE_OBJECT_LOCK_MAX                           // max
            );
    }

    return(network);

} // CnpGetBestMulticastNetwork

NTSTATUS
CxGetMulticastReachableSet(
    IN  CL_NETWORK_ID      NetworkId,
    OUT ULONG            * NodeScreen
    )
/*++

Routine Description:

    Queries multicast reachable set for specified network.
    The multicast reachable set is protected by the network
    list lock.

--*/
{
    KIRQL               irql;
    PLIST_ENTRY         entry;
    PCNP_NETWORK        network;
    CX_CLUSTERSCREEN    nodeScreen;
    BOOLEAN             found = FALSE;

    CnVerifyCpuLockMask(
        0,                       // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    CnAcquireLock(&CnpNetworkListLock, &irql);

    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList && !found;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        CnAcquireLockAtDpc(&(network->Lock));

        if (NetworkId == network->Id) {
            nodeScreen = network->McastReachableNodes;
            found = TRUE;
        }

        CnReleaseLockFromDpc(&(network->Lock));
    }

    CnReleaseLock(&CnpNetworkListLock, irql);

    if (!found) {
        return(STATUS_CLUSTER_NETWORK_NOT_FOUND);
    } else {
        *NodeScreen = nodeScreen.UlongScreen;
        return(STATUS_SUCCESS);
    }

} // CxGetMulticastReachableSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cxaddr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxaddr.c

Abstract:

    TDI Address Object management code.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cxaddr.tmh"


#define CX_WILDCARD_PORT   0           // 0 means assign a port.

#define CX_MIN_USER_PORT   1025        // Minimum value for a wildcard port
#define CX_MAX_USER_PORT   5000        // Maximim value for a user port.
#define CX_NUM_USER_PORTS  (CX_MAX_USER_PORT - CX_MIN_USER_PORT + 1)

//
// Address Object Data
//
USHORT              CxNextUserPort = CX_MIN_USER_PORT;
LIST_ENTRY          CxAddrObjTable[CX_ADDROBJ_TABLE_SIZE];
#if DBG
CN_LOCK             CxAddrObjTableLock = {0,0};
#else  // DBG
CN_LOCK             CxAddrObjTableLock = 0;
#endif // DBG



NTSTATUS
CxParseTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *AddrList,
    IN  ULONG                        AddressListLength,
    OUT CL_NODE_ID *                 Node,
    OUT PUSHORT                      Port
    )
{
    LONG                             i;
    PTA_ADDRESS                      currentAddr;
    TDI_ADDRESS_CLUSTER UNALIGNED *  validAddr;

    if (AddressListLength >= sizeof(TA_CLUSTER_ADDRESS)) {
        //
        // Find an address we can use.
        //
        currentAddr = (PTA_ADDRESS) AddrList->Address;

        for (i = 0; i < AddrList->TAAddressCount; i++) {
            if ( (currentAddr->AddressType == TDI_ADDRESS_TYPE_CLUSTER) &&
                 (currentAddr->AddressLength >= TDI_ADDRESS_LENGTH_CLUSTER)
               )
            {
                validAddr = (TDI_ADDRESS_CLUSTER UNALIGNED *)
                            currentAddr->Address;

                *Node = validAddr->Node;
                *Port = validAddr->Port;

                return(STATUS_SUCCESS);
            }
            else {
                if ( AddressListLength >=
                     (currentAddr->AddressLength + sizeof(TA_CLUSTER_ADDRESS))
                   )
                {
                    AddressListLength -= currentAddr->AddressLength;

                    currentAddr = (PTA_ADDRESS)
                                  ( currentAddr->Address +
                                    currentAddr->AddressLength
                                  );
                }
                else {
                    break;
                }
            }
        }
    }

    return(STATUS_INVALID_ADDRESS_COMPONENT);

} // CxParseTransportAddress


PCX_ADDROBJ
CxFindAddressObject(
    IN USHORT  Port
    )
/*++

Notes:

    Called with AO Table lock held.
    Returns with address object lock held.

--*/
{
    PLIST_ENTRY          entry;
    ULONG                hashBucket = CX_ADDROBJ_TABLE_HASH(Port);
    PCX_ADDROBJ          addrObj;


    for ( entry = CxAddrObjTable[hashBucket].Flink;
          entry != &(CxAddrObjTable[hashBucket]);
          entry = entry->Flink
        )
    {
        addrObj = CONTAINING_RECORD(
                      entry,
                      CX_ADDROBJ,
                      AOTableLinkage
                      );

        if (addrObj->LocalPort == Port) {
            CnAcquireLockAtDpc(&(addrObj->Lock));
            addrObj->Irql = DISPATCH_LEVEL;

            return(addrObj);
        }
    }

    return(NULL);

}  // CxFindAddressObject


NTSTATUS
CxOpenAddress(
    OUT PCN_FSCONTEXT *                CnFsContext,
    IN  TRANSPORT_ADDRESS UNALIGNED *  TransportAddress,
    IN  ULONG                          TransportAddressLength
    )
{
    PCX_ADDROBJ          addrObj, oldAddrObj;
    NTSTATUS             status;
    CL_NODE_ID           nodeId;
    USHORT               port;
    CN_IRQL              tableIrql;
    ULONG                i;
    ULONG                hashBucket;


    status = CxParseTransportAddress(
                 TransportAddress,
                 TransportAddressLength,
                 &nodeId,
                 &port
                 );

    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_ADDROBJ) {
            CNPRINT((
                "[Clusnet] Open address - failed to parse address, status %lx\n",
                status
                ));
        }
        return(status);
    }

    addrObj = CnAllocatePool(sizeof(CX_ADDROBJ));

    if (addrObj == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(addrObj, sizeof(CX_ADDROBJ));
    CN_INIT_SIGNATURE(&(addrObj->FsContext), CX_ADDROBJ_SIG);
    CnInitializeLock(&(addrObj->Lock), CX_ADDROBJ_LOCK);
    addrObj->Flags |= CX_AO_FLAG_CHECKSTATE;

    CnAcquireLock(&CxAddrObjTableLock, &tableIrql);

    // If no port is specified we have to assign one. If there is a
    // port specified, we need to make sure that the port isn't
    // already open. If the input address is a wildcard, we need to
    // assign one ourselves.

    if (port == CX_WILDCARD_PORT) {
        port = CxNextUserPort;

        for (i = 0; i < CX_NUM_USER_PORTS; i++, port++) {
            if (port > CX_MAX_USER_PORT) {
                port = CX_MIN_USER_PORT;
            }

            oldAddrObj = CxFindAddressObject(port);

            if (oldAddrObj == NULL) {
                IF_CNDBG(CN_DEBUG_ADDROBJ) {
                    CNPRINT(("[Clusnet] Assigning port %u\n", port));
                }
                break;              // Found an unused port.
            }

            CnReleaseLockFromDpc(&(oldAddrObj->Lock));
        }

        if (i == CX_NUM_USER_PORTS) {  // Couldn't find a free port.
            IF_CNDBG(CN_DEBUG_ADDROBJ) {
                CNPRINT((
                    "[Clusnet] No free wildcard ports.\n"
                    ));
            }

            CnReleaseLock(&CxAddrObjTableLock, tableIrql);
            CnFreePool(addrObj);
            return (STATUS_TOO_MANY_ADDRESSES);
        }

        CxNextUserPort = port + 1;

    } else {                        // Address was specificed
        oldAddrObj = CxFindAddressObject(port);

        if (oldAddrObj != NULL) {
            IF_CNDBG(CN_DEBUG_ADDROBJ) {
                CNPRINT((
                    "[Clusnet] Port %u is already in use.\n",
                    port
                    ));
            }

            CnReleaseLockFromDpc(&(oldAddrObj->Lock));
            CnReleaseLock(&CxAddrObjTableLock, tableIrql);
            CnFreePool(addrObj);
            return (STATUS_ADDRESS_ALREADY_EXISTS);
        }
    }

    addrObj->LocalPort = port;

    hashBucket = CX_ADDROBJ_TABLE_HASH(port);

    InsertHeadList(
        &(CxAddrObjTable[hashBucket]),
        &(addrObj->AOTableLinkage)
        );

    *CnFsContext = (PCN_FSCONTEXT) addrObj;

    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT((
            "[Clusnet] Opened address object %p for port %u\n",
            addrObj,
            port
            ));
    }

    CnTrace(
        CDP_ADDR_DETAIL, CdpTraceOpenAO,
        "[Clusnet] Opened address object %p for port %u.",
        addrObj,
        port
        );

    CnReleaseLock(&CxAddrObjTableLock, tableIrql);

    return(STATUS_SUCCESS);

}  // CxOpenAddress


NTSTATUS
CxCloseAddress(
    IN PCN_FSCONTEXT CnFsContext
    )
{
    PCX_ADDROBJ   addrObj = (PCX_ADDROBJ) CnFsContext;
    CN_IRQL       tableIrql;


    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT((
            "[Clusnet] Closed address object %p for port %u\n",
            addrObj,
            addrObj->LocalPort
            ));
    }

    CnTrace(
        CDP_ADDR_DETAIL, CdpTraceCloseAO,
        "[Clusnet] Closed address object %p for port %u.",
        addrObj,
        addrObj->LocalPort
        );

    CnAcquireLock(&CxAddrObjTableLock, &tableIrql);
    CnAcquireLockAtDpc(&(addrObj->Lock));

    RemoveEntryList(&(addrObj->AOTableLinkage));

    CnReleaseLockFromDpc(&(addrObj->Lock));
    CnReleaseLock(&CxAddrObjTableLock, tableIrql);

    //
    // The address object memory will be freed by the common code.
    //

    return(STATUS_SUCCESS);

} // CxCloseAddress


NTSTATUS
CxSetEventHandler(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PTDI_REQUEST_KERNEL_SET_EVENT request;
    PCX_ADDROBJ addrObj;
    CN_IRQL irql;


    //
    // Since this ioctl registers a callback function pointer, ensure
    // that it was issued by a kernel-mode component.
    //
    if (Irp->RequestorMode != KernelMode) {
        return(STATUS_ACCESS_DENIED);
    }

    addrObj = (PCX_ADDROBJ) IrpSp->FileObject->FsContext;
    request = (PTDI_REQUEST_KERNEL_SET_EVENT) &(IrpSp->Parameters);

    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT((
            "[Clusnet] TdiSetEvent type %u handler %p context %p\n",
            request->EventType,
            request->EventHandler,
            request->EventContext
            ));
    }

    CnAcquireLock(&(addrObj->Lock), &irql);

    switch (request->EventType) {

        case TDI_EVENT_ERROR:
            addrObj->ErrorHandler = request->EventHandler;
            addrObj->ErrorContext = request->EventContext;
            break;
        case TDI_EVENT_RECEIVE_DATAGRAM:
            addrObj->ReceiveDatagramHandler = request->EventHandler;
            addrObj->ReceiveDatagramContext = request->EventContext;
            break;
        case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            addrObj->ChainedReceiveDatagramHandler = request->EventHandler;
            addrObj->ChainedReceiveDatagramContext = request->EventContext;
            break;
        default:
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    CnReleaseLock(&(addrObj->Lock), irql);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);

}  // CxSetEventHandler


VOID
CxBuildTdiAddress(
    PVOID        Buffer,
    CL_NODE_ID   Node,
    USHORT       Port,
    BOOLEAN      Verified
    )
/*++

Routine Description:

    Called when we need to build a TDI address structure. We fill in
    the specifed buffer with the correct information in the correct
    format.

Arguments:

    Buffer      - Buffer to be filled in as TDI address structure.
    Node        - Node ID to fill in.
    Port        - Port to be filled in.
    Verified    - During a receive, whether clusnet verified the
                  signature and data

Return Value:

    Nothing

--*/
{
    PTRANSPORT_ADDRESS      xportAddr;
    PTA_ADDRESS             taAddr;

    xportAddr = (PTRANSPORT_ADDRESS) Buffer;
    xportAddr->TAAddressCount = 1;
    taAddr = xportAddr->Address;
    taAddr->AddressType = TDI_ADDRESS_TYPE_CLUSTER;
    taAddr->AddressLength = sizeof(TDI_ADDRESS_CLUSTER);
    ((PTDI_ADDRESS_CLUSTER) taAddr->Address)->Port = Port;
    ((PTDI_ADDRESS_CLUSTER) taAddr->Address)->Node = Node;
    ((PTDI_ADDRESS_CLUSTER) taAddr->Address)->ReservedMBZ = 
        ((Verified) ? 1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnpnode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cnpnode.c

Abstract:

    Node management routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpnode.tmh"


//
// Global Node Data
//
PCNP_NODE *        CnpNodeTable = NULL;
LIST_ENTRY         CnpDeletingNodeList = {NULL, NULL};
#if DBG
CN_LOCK            CnpNodeTableLock = {0, 0};
#else  // DBG
CN_LOCK            CnpNodeTableLock = 0;
#endif // DBG
PCNP_NODE          CnpLocalNode = NULL;
BOOLEAN            CnpIsNodeShutdownPending = FALSE;
PKEVENT            CnpNodeShutdownEvent = NULL;

//
// static data
//

//
// Membership state table. This table is used to determine the validity
// of membership state transitions. Row is current state; col is the state
// to which a transition is made. Dead to Unconfigured is currently illegal,
// but someday, if we support dynamically shrinking the size of the
// cluster, we'd need to allow this transition.
//

typedef enum _MM_ACTION {
    MMActionIllegal = 0,
    MMActionWarning,
    MMActionNodeAlive,
    MMActionNodeDead,
    MMActionConfigured,
    MMActionUnconfigured
} MM_ACTION;

MM_ACTION MembershipStateTable[ClusnetNodeStateLastEntry][ClusnetNodeStateLastEntry] = {
              // Alive              Joining            Dead                NC'ed
/* Alive */    { MMActionWarning,   MMActionIllegal,   MMActionNodeDead,   MMActionIllegal },
/* Join  */    { MMActionNodeAlive, MMActionIllegal,   MMActionNodeDead,   MMActionIllegal },
/* Dead  */    { MMActionNodeAlive, MMActionNodeAlive, MMActionWarning,    MMActionIllegal },
/* NC'ed */    { MMActionIllegal,   MMActionIllegal,   MMActionConfigured, MMActionIllegal }
};

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CnpLoadNodes)
#pragma alloc_text(PAGE, CnpInitializeNodes)

#endif // ALLOC_PRAGMA


//
// Private utility routines
//

VOID
CnpDestroyNode(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with no locks held. There should be no outstanding references
    to the target node.

    Synchronization with CnpCancelDeregisterNode() is achieved via
    CnpNodeTableLock.

--*/
{
    PLIST_ENTRY    entry;
    CN_IRQL        tableIrql;
    BOOLEAN        setCleanupEvent = FALSE;


    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT(("[CNP] Destroying node %u\n", Node->Id));

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    //
    // Remove the node from the deleting list.
    //
#if DBG
    {
        PCNP_NODE      node = NULL;

        //
        // Verify that the node object is on the deleting list.
        //
        for (entry = CnpDeletingNodeList.Flink;
             entry != &CnpDeletingNodeList;
             entry = entry->Flink
            )
        {
            node = CONTAINING_RECORD(entry, CNP_NODE, Linkage);

            if (node == Node) {
                break;
            }
        }

        CnAssert(node == Node);
    }

#endif // DBG

    RemoveEntryList(&(Node->Linkage));

    if (CnpIsNodeShutdownPending) {
        if (IsListEmpty(&CnpDeletingNodeList)) {
            setCleanupEvent = TRUE;
        }
    }

    CnReleaseLock(&CnpNodeTableLock, tableIrql);

    if (Node->PendingDeleteIrp != NULL) {
        CnAcquireCancelSpinLock(&(Node->PendingDeleteIrp->CancelIrql));

        CnCompletePendingRequest(Node->PendingDeleteIrp, STATUS_SUCCESS, 0);

        //
        // The IoCancelSpinLock was released by CnCompletePendingRequest()
        //
    }

    CnFreePool(Node);

    if (setCleanupEvent) {
        IF_CNDBG(CN_DEBUG_CLEANUP) {
            CNPRINT(("[CNP] Setting node cleanup event.\n"));
        }

        KeSetEvent(CnpNodeShutdownEvent, 0, FALSE);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpDestroyNode



BOOLEAN
CnpDeleteNode(
    IN  PCNP_NODE    Node,
    IN  PVOID        Unused,
    IN  CN_IRQL      NodeTableIrql
    )
/*++

Routine Description:

    Deletes a node object.

Arguments:

    Node   - A pointer to the node object to be deleted.

    Unused - An umused parameter.

    NodeTableIrql  - The IRQL value at which the CnpNodeTable lock was
                     acquired,

Return Value:

    Returns TRUE if the CnpNodeTable lock is still held.
    Returns FALSE if the CnpNodeTable lock is released.

Notes:

    Called with CnpNodeTable and node object locks held.
    Releases both locks.

    Conforms to the calling convention for PCNP_NODE_UPDATE_ROUTINE

--*/
{
    PLIST_ENTRY      entry;
    PCNP_INTERFACE   interface;
    PCNP_NETWORK     network;
    CL_NODE_ID       nodeId = Node->Id;


    CnVerifyCpuLockMask(
        (CNP_NODE_TABLE_LOCK | CNP_NODE_OBJECT_LOCK),  // Required
        0,                                             // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                       // Maximum
        );

    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT(("[CNP] Deleting node %u\n", nodeId));

    if (CnpLocalNode == Node) {
        CnAssert(CnLocalNodeId == Node->Id);
        CnpLocalNode = NULL;
    }

    //
    // Move the node to the deleting list.
    //
    CnpNodeTable[nodeId] = NULL;
    InsertTailList(&CnpDeletingNodeList, &(Node->Linkage));

    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT((
            "[CNP] Moved node %u to deleting list\n",
            nodeId
            ));

    CnReleaseLockFromDpc(&CnpNodeTableLock);
    Node->Irql = NodeTableIrql;

    //
    // From this point on, the cancel routine may run and
    // complete the irp.
    //

    Node->Flags |= CNP_NODE_FLAG_DELETING;

    CnTrace(
        CNP_NODE_DETAIL,
        CnpTraceDeleteNodeOfflineComm,
        "[CNP] Moving node %u comm state to offline.\n",
        Node->Id
        );

    Node->CommState = ClusnetNodeCommStateOffline;

    //
    // Delete all the node's interfaces.
    //
    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT((
            "[CNP] Deleting all interfaces on node %u\n",
            Node->Id
            ));

    while (!IsListEmpty(&(Node->InterfaceList))) {

        interface = CONTAINING_RECORD(
                        Node->InterfaceList.Flink,
                        CNP_INTERFACE,
                        NodeLinkage
                        );

        network = interface->Network;

        CnAcquireLockAtDpc(&(network->Lock));
        network->Irql = DISPATCH_LEVEL;

        CnpDeleteInterface(interface);

        //
        // The network object lock was released.
        //
    }

    //
    // Remove initial reference on node object. When the reference
    // count goes to zero, the node will be deleted. This releases
    // the node lock.
    //
    CnpDereferenceNode(Node);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(FALSE);
}



//
// CNP Internal Routines
//
VOID
CnpWalkNodeTable(
    PCNP_NODE_UPDATE_ROUTINE  UpdateRoutine,
    PVOID                     UpdateContext
    )
{
    ULONG         i;
    CN_IRQL       tableIrql;
    PCNP_NODE     node;
    BOOLEAN       isNodeTableLockHeld;


    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);

    for (i=CnMinValidNodeId; i <= CnMaxValidNodeId; i++) {

        if (CnpNodeTable == NULL) {
            //
            // The node table has been freed since we
            // last held the node table lock.
            //
            break;
        }

        node = CnpNodeTable[i];

        if (node != NULL) {

            CnAcquireLockAtDpc(&(node->Lock));
            node->Irql = DISPATCH_LEVEL;

            isNodeTableLockHeld = (*UpdateRoutine)(
                                      node,
                                      UpdateContext,
                                      tableIrql
                                      );

            //
            // The node object lock was released.
            // The node table lock may also have been released.
            //
            if (!isNodeTableLockHeld) {
                CnAcquireLock(&CnpNodeTableLock, &tableIrql);
            }
        }
    }

    CnReleaseLock(&CnpNodeTableLock, tableIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

} // CnpWalkNodeTable



NTSTATUS
CnpValidateAndFindNode(
    IN  CL_NODE_ID    NodeId,
    OUT PCNP_NODE *   Node
    )
{
    NTSTATUS           status;
    CN_IRQL            tableIrql;
    PCNP_NODE          node = NULL;


    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    if (CnIsValidNodeId(NodeId)) {
        CnAcquireLock(&CnpNodeTableLock, &tableIrql);

        if (CnpNodeTable != NULL &&
            CnpNodeTable[NodeId] != NULL) {
        
            node = CnpNodeTable[NodeId];

            CnAcquireLockAtDpc(&(node->Lock));
            CnReleaseLockFromDpc(&CnpNodeTableLock);
            node->Irql = tableIrql;

            *Node = node;

            CnVerifyCpuLockMask(
                CNP_NODE_OBJECT_LOCK,        // Required
                CNP_NODE_TABLE_LOCK,         // Forbidden
                CNP_NODE_OBJECT_LOCK_MAX     // Maximum
                );

            return(STATUS_SUCCESS);
        }
        else {
            status = STATUS_CLUSTER_NODE_NOT_FOUND;
        }

        CnReleaseLock(&CnpNodeTableLock, tableIrql);
    }
    else {
        status = STATUS_CLUSTER_INVALID_NODE;
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);

}  // CnpValidateAndFindNode


PCNP_NODE
CnpLockedFindNode(
    IN  CL_NODE_ID    NodeId,
    IN  CN_IRQL       NodeTableIrql
    )
/*++

Routine Description:

    Searches the node table for a specified node object.

Arguments:

    NodeId      - The ID of the node object to locate.

    NodeTableIrql  - The IRQL level at which the node table lock was
                     acquired before calling this routine.

Return Value:

    A pointer to the requested node object, if it exists.
    NULL otherwise.

Notes:

    Called with CnpNodeTableLock held.
    Returns with CnpNodeTableLock released.
    If return value is non-NULL, returns with node object lock held.

--*/
{
    NTSTATUS           status;
    CN_IRQL            tableIrql;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        CNP_NODE_TABLE_LOCK,             // Required
        0,                               // Forbidden
        CNP_NODE_TABLE_LOCK_MAX          // Maximum
        );

    node = CnpNodeTable[NodeId];

    if (node != NULL) {
        CnAcquireLockAtDpc(&(node->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        node->Irql = NodeTableIrql;

        CnVerifyCpuLockMask(
            CNP_NODE_OBJECT_LOCK,          // Required
            CNP_NODE_TABLE_LOCK,           // Forbidden
            CNP_NODE_OBJECT_LOCK_MAX       // Maximum
            );

        return(node);
    }

    CnReleaseLock(&CnpNodeTableLock, NodeTableIrql);

    CnVerifyCpuLockMask(
        0,                                                    // Required
        (CNP_NODE_TABLE_LOCK | CNP_NODE_OBJECT_LOCK),         // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                              // Maximum
        );

    return(NULL);

}  // CnpLockedFindNode



PCNP_NODE
CnpFindNode(
    IN  CL_NODE_ID    NodeId
    )
{
    CN_IRQL            tableIrql;


    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    if (CnpNodeTable == NULL) {
        CnReleaseLock(&CnpNodeTableLock, tableIrql);
        return(NULL);
    }

    return(CnpLockedFindNode(NodeId, tableIrql));

}  // CnpFindNode



VOID
CnpDeclareNodeUnreachable(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
        );

    if ( (Node->CommState == ClusnetNodeCommStateOnline) &&
         !CnpIsNodeUnreachable(Node)
       )
    {
        IF_CNDBG( CN_DEBUG_NODEOBJ )
            CNPRINT(("[CNP] Declaring node %u unreachable\n", Node->Id));

        Node->Flags |= CNP_NODE_FLAG_UNREACHABLE;
    }

    return;

}  // CnpDeclareNodeUnreachable



VOID
CnpDeclareNodeReachable(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,           // Required
        0,                              // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX     // Maximum
        );

    if ( (Node->CommState == ClusnetNodeCommStateOnline) &&
         CnpIsNodeUnreachable(Node)
       )
    {
        IF_CNDBG( CN_DEBUG_NODEOBJ )
            CNPRINT(("[CNP] Declaring node %u reachable again\n", Node->Id));

        Node->Flags &= ~(CNP_NODE_FLAG_UNREACHABLE);
    }

    return;

}  // CnpDeclareNodeUnreachable



VOID
CnpReferenceNode(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
        );

    CnAssert(Node->RefCount != 0xFFFFFFFF);

    Node->RefCount++;

    IF_CNDBG( CN_DEBUG_CNPREF )
        CNPRINT((
            "[CNP] Referencing node %u, new refcount %u\n",
            Node->Id,
            Node->RefCount
            ));

    return;

}  // CnpReferenceNode



VOID
CnpDereferenceNode(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.
    Returns with node object lock released.

--*/
{
    BOOLEAN   isDeleting = FALSE;
    ULONG     newRefCount;


    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
    );

    CnAssert(Node->RefCount != 0);

    newRefCount = --(Node->RefCount);

    IF_CNDBG( CN_DEBUG_CNPREF )
        CNPRINT((
            "[CNP] Dereferencing node %u, new refcount %u\n",
            Node->Id,
            newRefCount
            ));

    CnReleaseLock(&(Node->Lock), Node->Irql);

    if (newRefCount > 0) {
        CnVerifyCpuLockMask(
            0,                           // Required
            CNP_NODE_OBJECT_LOCK,        // Forbidden
            CNP_NODE_TABLE_LOCK_MAX      // Maximum
            );

        return;
    }

    CnpDestroyNode(Node);

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_NODE_OBJECT_LOCK,        // Forbidden
        CNP_NODE_TABLE_LOCK_MAX      // Maximum
        );

    return;

}  // CnpDereferenceNode



//
// Cluster Transport Public Routines
//
NTSTATUS
CnpLoadNodes(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is loading. Initializes
    static node-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS  status;
    ULONG     i;


    CnInitializeLock(&CnpNodeTableLock, CNP_NODE_TABLE_LOCK);
    InitializeListHead(&CnpDeletingNodeList);

    return(STATUS_SUCCESS);

}  // CnpLoadNodes


NTSTATUS
CnpInitializeNodes(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is being (re)initialized.
    Initializes dynamic node-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS  status;
    ULONG     i;


    PAGED_CODE();

    CnAssert(CnLocalNodeId != ClusterInvalidNodeId);
    CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnpNodeTable == NULL);
    CnAssert(CnpNodeShutdownEvent == NULL);
    CnAssert(IsListEmpty(&CnpDeletingNodeList));

    CnpNodeShutdownEvent = CnAllocatePool(sizeof(KEVENT));

    if (CnpNodeShutdownEvent == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    KeInitializeEvent(CnpNodeShutdownEvent, NotificationEvent, FALSE);
    CnpIsNodeShutdownPending = FALSE;

    CnpNodeTable = CnAllocatePool(
                       (sizeof(PCNP_NODE) * (CnMaxValidNodeId + 1))
                       );

    if (CnpNodeTable == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(CnpNodeTable, (sizeof(PCNP_NODE) * (CnMaxValidNodeId + 1)) );

    //
    // Register the local node.
    //
    status = CxRegisterNode(CnLocalNodeId);

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    return(STATUS_SUCCESS);

}  // CnpInitializeNodes



VOID
CnpShutdownNodes(
    VOID
    )
/*++

Routine Description:

    Called when a shutdown request is issued to the Cluster Network
    Driver. Deletes all node objects.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG         i;
    CN_IRQL       tableIrql;
    PCNP_NODE     node;
    PCNP_NODE *   table;
    BOOLEAN       waitEvent = FALSE;
    NTSTATUS      status;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    if (CnpNodeShutdownEvent != NULL) {
        CnAssert(CnpIsNodeShutdownPending == FALSE);

        IF_CNDBG(CN_DEBUG_CLEANUP) {
            CNPRINT(("[CNP] Cleaning up nodes...\n"));
        }

        if (CnpNodeTable != NULL) {

            CnpWalkNodeTable(CnpDeleteNode, NULL);

            CnAcquireLock(&CnpNodeTableLock, &tableIrql);

            if (!IsListEmpty(&CnpDeletingNodeList)) {
                CnpIsNodeShutdownPending = TRUE;
                waitEvent = TRUE;
            }

            CnReleaseLock(&CnpNodeTableLock, tableIrql);

            if (waitEvent) {
                IF_CNDBG(CN_DEBUG_CLEANUP) {
                    CNPRINT(("[CNP] Node deletes are pending...\n"));
                }

                status = KeWaitForSingleObject(
                             CnpNodeShutdownEvent,
                             Executive,
                             KernelMode,
                             FALSE,        // not alertable
                             NULL          // no timeout
                             );
                CnAssert(status == STATUS_SUCCESS);
            }

            CnAssert(IsListEmpty(&CnpDeletingNodeList));

            IF_CNDBG(CN_DEBUG_CLEANUP) {
                CNPRINT(("[CNP] All nodes deleted.\n"));
            }

            CnAcquireLock(&CnpNodeTableLock, &tableIrql);

            if (CnpNodeTable != NULL) {
                CnFreePool(CnpNodeTable);
                CnpNodeTable = NULL;
            }
            
            CnReleaseLock(&CnpNodeTableLock, tableIrql);
        }

        CnFreePool(CnpNodeShutdownEvent); CnpNodeShutdownEvent = NULL;

        IF_CNDBG(CN_DEBUG_CLEANUP) {
            CNPRINT(("[CNP] Nodes cleaned up.\n"));
        }
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    return;

}  // CnpShutdownNodes



NTSTATUS
CxRegisterNode(
    CL_NODE_ID    NodeId
    )
{
    NTSTATUS           status = STATUS_SUCCESS;
    CN_IRQL            tableIrql;
    PCNP_NODE          node = NULL;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    if (CnIsValidNodeId(NodeId)) {
        //
        // Allocate and initialize a node object.
        //
        node = CnAllocatePool(sizeof(CNP_NODE));

        if (node == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(node, sizeof(CNP_NODE));

        CN_INIT_SIGNATURE(node, CNP_NODE_SIG);
        node->Id = NodeId;
        node->CommState = ClusnetNodeCommStateOffline;
        node->MMState = ClusnetNodeStateDead;
        node->RefCount = 1;

        //
        // NodeDownIssued is init'ed to true so that the first recv'd
        // heart beat msg will cause a node up event to be triggered
        //

        node->NodeDownIssued = TRUE;
        InitializeListHead(&(node->InterfaceList));
        CnInitializeLock(&(node->Lock), CNP_NODE_OBJECT_LOCK);

        CnAcquireLock(&CnpNodeTableLock, &tableIrql);

        //
        // Make sure the node table is present. If the node table 
        // were not present (e.g. because of clusnet shutdown) the 
        // clusnet state check should have failed in the dispatch 
        // code, but this check is inexpensive and extra-thorough.
        //
        if (CnpNodeTable != NULL) {

            //
            // Make sure this isn't a duplicate registration
            //
            if (CnpNodeTable[NodeId] == NULL) {
                if (NodeId == CnLocalNodeId) {
                    node->Flags |= CNP_NODE_FLAG_LOCAL;
                    CnpLocalNode = node;
                }

                CnpNodeTable[NodeId] = node;

                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_CLUSTER_NODE_EXISTS;
            }
        }
        else {
            status = STATUS_CLUSTER_NODE_NOT_FOUND;
        }

        CnReleaseLock(&CnpNodeTableLock, tableIrql);

        if (!NT_SUCCESS(status)) {
            CnFreePool(node);
        }
        else {
            IF_CNDBG( CN_DEBUG_NODEOBJ )
                CNPRINT(("[CNP] Registered node %u\n", NodeId));
            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceRegisteredNode,
                "[CNP] Registered node %u.\n",
                NodeId
                );
        }
    }
    else {
        status = STATUS_CLUSTER_INVALID_NODE;
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    return(status);

} // CxRegisterNode



VOID
CxCancelDeregisterNode(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
/*++

Routine Description:

    Cancellation handler for DeregisterNode requests.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PFILE_OBJECT   fileObject;
    CN_IRQL        cancelIrql = Irp->CancelIrql;
    PLIST_ENTRY    entry;
    PCNP_NODE      node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    CnMarkIoCancelLockAcquired();

    IF_CNDBG( CN_DEBUG_IRP )
        CNPRINT((
            "[CNP] Attempting to cancel DeregisterNode irp %p\n",
            Irp
            ));

    CnAssert(DeviceObject == CnDeviceObject);

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc(&CnpNodeTableLock);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // We can only complete the irp if we can find it stashed in a
    // deleting node object. The deleting node object could have
    // been destroyed and the IRP completed before we acquired the
    // CnpNetworkListLock.
    //
    for (entry = CnpDeletingNodeList.Flink;
         entry != &CnpDeletingNodeList;
         entry = entry->Flink
        )
    {
        node = CONTAINING_RECORD(entry, CNP_NODE, Linkage);

        if (node->PendingDeleteIrp == Irp) {
            IF_CNDBG( CN_DEBUG_IRP )
                CNPRINT((
                    "[CNP] Found dereg irp on node %u\n",
                    node->Id
                    ));

            //
            // Found the Irp. Now take it away and complete it.
            //
            node->PendingDeleteIrp = NULL;

            CnReleaseLock(&CnpNodeTableLock, cancelIrql);

            CnAcquireCancelSpinLock(&(Irp->CancelIrql));

            CnEndCancelRoutine(fileObject);

            CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);

            //
            // IoCancelSpinLock was released by CnCompletePendingRequest().
            //

            CnVerifyCpuLockMask(
                0,                  // Required
                0xFFFFFFFF,         // Forbidden
                0                   // Maximum
                );

            return;
        }
    }

    CnReleaseLock(&CnpNodeTableLock, cancelIrql);

    CnAcquireCancelSpinLock(&cancelIrql);

    CnEndCancelRoutine(fileObject);

    CnReleaseCancelSpinLock(cancelIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpCancelApiDeregisterNode



NTSTATUS
CxDeregisterNode(
    CL_NODE_ID           NodeId,
    PIRP                 Irp,
    PIO_STACK_LOCATION   IrpSp
    )
{
    NTSTATUS           status;
    CN_IRQL            cancelIrql;
    PCNP_NODE          node = NULL;
    BOOLEAN            isNodeTableLockHeld;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    if (CnIsValidNodeId(NodeId)) {
        if (NodeId != CnLocalNodeId) {
            CnAcquireCancelSpinLock(&cancelIrql);
            CnAcquireLockAtDpc(&CnpNodeTableLock);

            if (CnpNodeTable != NULL &&
                CnpNodeTable[NodeId] != NULL) {

                node = CnpNodeTable[NodeId];

                status = CnMarkRequestPending(
                             Irp,
                             IrpSp,
                             CxCancelDeregisterNode
                             );

                if (status != STATUS_CANCELLED) {

                    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

                    CnAssert(status == STATUS_SUCCESS);

                    CnAcquireLockAtDpc(&(node->Lock));

                    IF_CNDBG( CN_DEBUG_NODEOBJ )
                        CNPRINT(("[CNP] Deregistering node %u\n", NodeId));

                    //
                    // Save a pointer to pending irp. Note this is protected
                    // by the table lock, not the object lock.
                    //
                    node->PendingDeleteIrp = Irp;

                    isNodeTableLockHeld = CnpDeleteNode(
                                              node, 
                                              NULL,
                                              cancelIrql
                                              );

                    if (isNodeTableLockHeld) {
                        CnReleaseLock(&CnpNodeTableLock, cancelIrql);
                    }

                    CnVerifyCpuLockMask(
                        0,                           // Required
                        0xFFFFFFFF,                  // Forbidden
                        0                            // Maximum
                        );

                    return(STATUS_PENDING);
                }
            }
            else {
                status = STATUS_CLUSTER_NODE_NOT_FOUND;
            }

            CnReleaseLockFromDpc(&CnpNodeTableLock);
            CnReleaseCancelSpinLock(cancelIrql);
        }
        else {
            status = STATUS_CLUSTER_INVALID_REQUEST;
        }
    }
    else {
        status = STATUS_CLUSTER_INVALID_NODE;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxDeregisterNode



NTSTATUS
CxOnlineNodeComm(
    CL_NODE_ID     NodeId
    )
{
    NTSTATUS           status;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {

        if (node->CommState == ClusnetNodeCommStateOffline) {
            IF_CNDBG( CN_DEBUG_NODEOBJ )
                CNPRINT((
                    "[CNP] Moving node %u comm state to online.\n",
                    NodeId
                    ));

            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceOnlineNodeComm,
                "[CNP] Moving node %u comm state to online.\n",
                NodeId
                );

            node->CommState = ClusnetNodeCommStateOnline;

            CnpWalkInterfacesOnNode(node, CnpResetAndOnlinePendingInterface);

        }
        else {
            status = STATUS_CLUSTER_NODE_ALREADY_UP;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOnlineNodeComm



NTSTATUS
CxOfflineNodeComm(
    IN CL_NODE_ID          NodeId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Notes:


--*/
{
    PCNP_NODE   node;
    NTSTATUS    status;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {
        if (node->CommState == ClusnetNodeCommStateOnline) {
            IF_CNDBG( CN_DEBUG_NODEOBJ )
                CNPRINT((
                    "[CNP] Moving node %u comm state to offline.\n",
                    NodeId
                    ));

            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceOfflineNodeComm,
                "[CNP] Moving node %u comm state to offline.\n",
                NodeId
                );
            
            node->CommState = ClusnetNodeCommStateOffline;

            CnpWalkInterfacesOnNode(node, CnpOfflineInterfaceWrapper);

        }
        else {
            status = STATUS_CLUSTER_NODE_ALREADY_DOWN;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }
    else {
        status = STATUS_CLUSTER_NODE_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOfflineNodeComm



NTSTATUS
CxGetNodeCommState(
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  CommState
    )
{
    NTSTATUS       status;
    PCNP_NODE      node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {
        if (CnpIsNodeUnreachable(node)) {
            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceGetNodeCommStateUnreach,
                "[CNP] Returning node %u comm state offline "
                "because node is unreachable.",
                NodeId
                );
            *CommState = ClusnetNodeCommStateUnreachable;
        }
        else {
            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceGetNodeCommState,
                "[CNP] Returning node %u comm state %u.",
                NodeId, node->CommState
                );
            *CommState = node->CommState;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNodeCommState


NTSTATUS
CxGetNodeMembershipState(
    IN  CL_NODE_ID              NodeId,
    OUT PCLUSNET_NODE_STATE   State
    )
{
    NTSTATUS       status;
    PCNP_NODE      node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {

        *State = node->MMState;

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNodeMembershipState


NTSTATUS
CxSetNodeMembershipState(
    IN  CL_NODE_ID              NodeId,
    IN  CLUSNET_NODE_STATE    State
    )
{
    NTSTATUS status;
    PCNP_NODE node;
    MM_ACTION MMAction;
    BOOLEAN   nodeLockAcquired = FALSE;

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {
        nodeLockAcquired = TRUE;

        IF_CNDBG( CN_DEBUG_MMSTATE ) {
            CNPRINT(("[Clusnet] Changing Node %u (%08X) MMState from %u to %u\n",
                     node->Id, node, node->MMState, State));
        }

        //
        // look up the routine to call (if any) based on the old and new
        // state
        //
        switch ( MembershipStateTable[ node->MMState ][ State ] ) {

        case MMActionIllegal:
            status = STATUS_CLUSTER_INVALID_REQUEST;
            break;

        case MMActionWarning:

            //
            // warning about null transitions
            //

            if ( node->MMState == ClusnetNodeStateAlive &&
                 State == ClusnetNodeStateAlive ) {

                status = STATUS_CLUSTER_NODE_ALREADY_UP;
            } else if ( node->MMState == ClusnetNodeStateDead &&
                        State == ClusnetNodeStateDead ) {

                status = STATUS_CLUSTER_NODE_ALREADY_DOWN;
            }
            break;

        case MMActionNodeAlive:
            node->MMState = State;
            //
            // if we're transitioning our own node from Dead to
            // Joining or Alive then start heartbeat code
            //

            if (( node->MMState != ClusnetNodeStateJoining ||
                  State != ClusnetNodeStateAlive )
                &&
                CnpIsNodeLocal( node )) {

                node->MissedHBs = 0;
                node->HBWasMissed = FALSE;

                //
                // Release the node lock before starting heartbeats. Note
                // that we are holding the global resource here, which will
                // synchronize this code with shutdown.
                //
                CnReleaseLock(&(node->Lock), node->Irql);
                nodeLockAcquired = FALSE;

                status = CnpStartHeartBeats();
            }

            break;

        case MMActionNodeDead:

            //
            // reset this flag so when node is being brought
            // online again, we'll issue a Node Up event on
            // first HB received from this node.
            //

            node->NodeDownIssued = TRUE;
            node->MMState = State;

            if ( CnpIsNodeLocal( node )) {
                //
                // Release the node lock before stopping heartbeats. Note
                // that we are holding the global resource here, which will
                // synchronize this code with shutdown.
                //
                CnReleaseLock(&(node->Lock), node->Irql);
                nodeLockAcquired = FALSE;

                CnpStopHeartBeats();
            }

            break;

        case MMActionConfigured:
            node->MMState = State;
            break;
        }

        if ( NT_ERROR( status )) {

            CN_DBGCHECK;
        }

        if (nodeLockAcquired) {
            CnReleaseLock(&(node->Lock), node->Irql);
        }
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxSetNodeMembershipState
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cnpsend.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnpsend.c

Abstract:

    Cluster Network Protocol send processing code.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpsend.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CnpCreateSendRequestPool)

#endif // ALLOC_PRAGMA


//
// Private Utility Functions
//
PCN_RESOURCE
CnpCreateSendRequest(
    IN PVOID   Context
    )
{
    PCNP_SEND_REQUEST_POOL_CONTEXT   context = Context;
    PCNP_SEND_REQUEST                request;
    PCNP_HEADER                      cnpHeader;
    ULONG                            cnpHeaderSize;

    //
    // The CNP header size includes signature data for version 2.
    //
    cnpHeaderSize = sizeof(CNP_HEADER);
    if (context->CnpVersionNumber == 2) {
        cnpHeaderSize += CNP_SIG_LENGTH(CX_SIGNATURE_DATA_LENGTH);
    }

    //
    // Allocate a new send request. Include space for the upper protocol
    // and CNP headers.
    //
    request = CnAllocatePool(
                  sizeof(CNP_SEND_REQUEST) + cnpHeaderSize +
                  ((ULONG) context->UpperProtocolHeaderLength) +
                  context->UpperProtocolContextSize
                  );

    if (request != NULL) {
        //
        // Allocate an MDL to describe the CNP and upper transport headers.
        //

        // On I64 Context has to be 64 bit aligned,
        // let's put it before CnpHeader
        if (context->UpperProtocolContextSize > 0) {
            request->UpperProtocolContext = request + 1;
            request->CnpHeader = ( ((PCHAR) request->UpperProtocolContext) +
                                     context->UpperProtocolContextSize );
        } else {
            request->UpperProtocolContext = NULL;
            request->CnpHeader = request + 1;
        }

        request->HeaderMdl = IoAllocateMdl(
                                 request->CnpHeader,
                                 (ULONG) (context->UpperProtocolHeaderLength +
                                          cnpHeaderSize),
                                 FALSE,
                                 FALSE,
                                 NULL
                                 );

        if (request->HeaderMdl != NULL) {
            MmBuildMdlForNonPagedPool(request->HeaderMdl);

            //
            // Finish initializing the request.
            //
            request->UpperProtocolHeader = ( ((PCHAR) request->CnpHeader) +
                                             cnpHeaderSize );

            request->UpperProtocolHeaderLength =
                context->UpperProtocolHeaderLength;

            RtlZeroMemory(
                &(request->TdiSendDatagramInfo),
                sizeof(request->TdiSendDatagramInfo)
                );

            request->McastGroup = NULL;

            //
            // Fill in the constant CNP header values.
            //
            cnpHeader = request->CnpHeader;
            cnpHeader->Version = context->CnpVersionNumber;
            cnpHeader->NextHeader = context->UpperProtocolNumber;

            return((PCN_RESOURCE) request);
        }

        CnFreePool(request);
    }

    return(NULL);

}  // CnpCreateSendRequest


VOID
CnpDeleteSendRequest(
    PCN_RESOURCE  Resource
    )
{
    PCNP_SEND_REQUEST  request = (PCNP_SEND_REQUEST) Resource;

    IoFreeMdl(request->HeaderMdl);
    CnFreePool(request);

    return;

} // CnpDeleteSendRequest


//
// Routines Exported within the Cluster Transport
//
PCN_RESOURCE_POOL
CnpCreateSendRequestPool(
    IN UCHAR  CnpVersionNumber,
    IN UCHAR  UpperProtocolNumber,
    IN USHORT UpperProtocolHeaderSize,
    IN USHORT UpperProtocolContextSize,
    IN USHORT PoolDepth
    )
{
    PCN_RESOURCE_POOL                pool;
    PCNP_SEND_REQUEST_POOL_CONTEXT   context;


    PAGED_CODE();

    CnAssert((0xFFFF - sizeof(CNP_HEADER)) >= UpperProtocolHeaderSize);

    pool = CnAllocatePool(
               sizeof(CN_RESOURCE_POOL) +
                   sizeof(CNP_SEND_REQUEST_POOL_CONTEXT)
               );

    if (pool != NULL) {
        context = (PCNP_SEND_REQUEST_POOL_CONTEXT) (pool + 1);

        context->UpperProtocolNumber = UpperProtocolNumber;
        context->UpperProtocolHeaderLength = UpperProtocolHeaderSize;
        context->UpperProtocolContextSize = UpperProtocolContextSize;
        context->CnpVersionNumber = CnpVersionNumber;

        CnInitializeResourcePool(
                   pool,
                   PoolDepth,
                   CnpCreateSendRequest,
                   context,
                   CnpDeleteSendRequest
                   );
    }

    return(pool);

}  // CnpCreateSendRequestPool



VOID
CnpCompleteSendPacketCommon(
    IN PIRP              Irp,
    IN PCNP_SEND_REQUEST Request,
    IN PMDL              DataMdl
    )
{
    PCNP_NETWORK       network = Request->Network;
    ULONG              bytesSent = (ULONG)Irp->IoStatus.Information;
    NTSTATUS           status = Irp->IoStatus.Status;
    PCNP_HEADER        cnpHeader = Request->CnpHeader;


    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    if (NT_SUCCESS(status)) {
        //
        // Subtract the CNP header from the count of bytes sent.
        //
        if (bytesSent >= sizeof(CNP_HEADER)) {
            bytesSent -= sizeof(CNP_HEADER);
        }
        else {
            CnAssert(FALSE);
            bytesSent = 0;
        }

        //
        // If CNP signed the message, subtract the signature
        // data from the count of bytes sent.
        //
        if (cnpHeader->Version == CNP_VERSION_MULTICAST) {
            CNP_SIGNATURE UNALIGNED * cnpSig;
            ULONG                     cnpSigDataLength;

            cnpSig = (CNP_SIGNATURE UNALIGNED *)(cnpHeader + 1);
            cnpSigDataLength = CNP_SIG_LENGTH(
                                   cnpSig->SigLength + cnpSig->SaltLength
                                   );

            if (bytesSent >= cnpSigDataLength) {
                bytesSent -= cnpSigDataLength;
            } else {
                CnAssert(FALSE);
                bytesSent = 0;
            }
        }

        CnTrace(CNP_SEND_DETAIL, CnpTraceSendComplete,
            "[CNP] Send of packet to node %u on net %u complete, "
            "bytes sent %u.",
            cnpHeader->DestinationAddress, // LOGULONG
            network->Id, // LOGULONG
            bytesSent // LOGULONG
            );
    }
    else {
        //
        // It is possible to reach this path with
        // status = c0000240 (STATUS_REQUEST_ABORTED) and
        // bytesSent > 0.
        //
        bytesSent = 0;

        CnTrace(CNP_SEND_ERROR, CnpTraceSendFailedBelow,
            "[CNP] Tcpip failed to send packet to node %u on net %u, "
            "data len %u, status %!status!",
            cnpHeader->DestinationAddress, // LOGULONG
            network->Id, // LOGULONG
            cnpHeader->PayloadLength, // LOGUSHORT
            status // LOGSTATUS
            );
    }

    //
    // Remove the active reference we put on the network.
    //
    CnAcquireLock(&(network->Lock), &(network->Irql));
    CnpActiveDereferenceNetwork(network);

    //
    // Free the TDI address buffer
    //
    CnFreePool(Request->TdiSendDatagramInfo.RemoteAddress);

    //
    // Call the upper protocol's completion routine
    //
    if (Request->CompletionRoutine) {
        (*(Request->CompletionRoutine))(
            status,
            &bytesSent,
            Request,
            DataMdl
            );
    }

    //
    // Update the Information field of the completed IRP to
    // reflect the actual bytes sent (adjusted for the CNP
    // and upper protocol headers).
    //
    Irp->IoStatus.Information = bytesSent;

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return;

}  // CnpCompleteSendPacketCommon



NTSTATUS
CnpCompleteSendPacketNewIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PCNP_SEND_REQUEST  request = Context;
    PIRP               upperIrp = request->UpperProtocolIrp;
    PMDL               dataMdl;

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    //
    // Unlink the data MDL chain from the header MDL.
    //
    CnAssert(Irp->MdlAddress == request->HeaderMdl);
    dataMdl = request->HeaderMdl->Next;
    request->HeaderMdl->Next = NULL;
    Irp->MdlAddress = NULL;

    CnpCompleteSendPacketCommon(Irp, request, dataMdl);

    //
    // Complete the upper-level IRP, if there is one
    //
    if (upperIrp != NULL) {

        IF_CNDBG( CN_DEBUG_CNPSEND )
            CNPRINT(("[CNP] CnpCompleteSendPacketNewIrp calling "
                     "CnCompleteRequest for IRP %p with status "
                     "%08x\n",
                     upperIrp, Irp->IoStatus.Status));

        CnAcquireCancelSpinLock(&(upperIrp->CancelIrql));
        CnCompletePendingRequest(
            upperIrp,
            Irp->IoStatus.Status,            // status
            (ULONG)Irp->IoStatus.Information // bytes returned
            );

        //
        // The IoCancelSpinLock was released by the completion routine.
        //
    }

    //
    // Free the new IRP
    //
    IoFreeIrp(Irp);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

}  // CnpCompleteSendPacketNewIrp



NTSTATUS
CnpCompleteSendPacketReuseIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PCNP_SEND_REQUEST  request = Context;
    PMDL               dataMdl;

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    //
    // Unlink the data MDL chain from the header MDL.
    //
    CnAssert(Irp->MdlAddress == request->HeaderMdl);
    dataMdl = request->HeaderMdl->Next;
    request->HeaderMdl->Next = NULL;

    //
    // Restore the requestor mode of the upper protocol IRP.
    //
    Irp->RequestorMode = request->UpperProtocolIrpMode;

    //
    // Restore the MDL of the upper protocol IRP.
    //
    Irp->MdlAddress = request->UpperProtocolMdl;

    CnpCompleteSendPacketCommon(Irp, request, dataMdl);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    IF_CNDBG( CN_DEBUG_CNPSEND )
        CNPRINT(("[CNP] CnpCompleteSendPacketReuseIrp returning "
                 "IRP %p to I/O Manager\n",
                 Irp));

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CnpCompleteSendPacketReuseIrp



NTSTATUS
CnpSendPacket(
    IN PCNP_SEND_REQUEST    SendRequest,
    IN CL_NODE_ID           DestNodeId,
    IN PMDL                 DataMdl,
    IN USHORT               DataLength,
    IN BOOLEAN              CheckDestState,
    IN CL_NETWORK_ID        NetworkId        OPTIONAL
    )
/*++

Routine Description:

    Main send routine for CNP. Handles unicast and multicast
    sends.

--*/
{
    NTSTATUS               status = STATUS_SUCCESS;
    PCNP_HEADER            cnpHeader = SendRequest->CnpHeader;
    PIRP                   upperIrp = SendRequest->UpperProtocolIrp;
    CN_IRQL                tableIrql;
    BOOLEAN                multicast = FALSE;
    CL_NETWORK_ID          networkId = NetworkId;
    CN_IRQL                cancelIrql;
    BOOLEAN                cnComplete = FALSE;
    BOOLEAN                destNodeLocked = FALSE;
    PCNP_NODE              destNode;
    ULONG                  sigDataLen;
    PCNP_INTERFACE         interface;
    PCNP_NETWORK           network;
    BOOLEAN                networkReferenced = FALSE;
    PIRP                   irp;
    PVOID                  addressBuffer = NULL;
    PIO_COMPLETION_ROUTINE compRoutine;
    PDEVICE_OBJECT         targetDeviceObject;
    PFILE_OBJECT           targetFileObject;
    BOOLEAN                mcastGroupReferenced = FALSE;


    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    IF_CNDBG( CN_DEBUG_CNPSEND )
        CNPRINT(("[CNP] CnpSendPacket called with upper IRP %p\n",
                 upperIrp));

    //
    // Make all the tests to see if we can send the packet.
    //

    //
    // Acquire the node table lock to match the destination node id
    // to a node object.
    //
    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    if (CnpNodeTable == NULL) {
        CnReleaseLock(&CnpNodeTableLock, tableIrql);
        status = STATUS_NETWORK_UNREACHABLE;
        goto error_exit;
    }

    //
    // Fill in the local node ID while we still hold the node table lock.
    //
    CnAssert(CnLocalNodeId != ClusterInvalidNodeId);
    cnpHeader->SourceAddress = CnLocalNodeId;

    //
    // Check first if the destination node id indicates that this is
    // a multicast.
    //
    if (DestNodeId == ClusterAnyNodeId) {

        //
        // This is a multicast. For multicasts, we use the local
        // node in place of the dest node to validate the network
        // and interface.
        //
        multicast = TRUE;
        destNode = CnpLockedFindNode(CnLocalNodeId, tableIrql);
    }

    //
    // Not a multicast. The destination node id must be valid.
    //
    else if (!CnIsValidNodeId(DestNodeId)) {
        CnReleaseLock(&CnpNodeTableLock, tableIrql);
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        goto error_exit;
    }

    //
    // Find the destination node object in the node table.
    //
    else {
        destNode = CnpLockedFindNode(DestNodeId, tableIrql);
    }

    //
    // The NodeTableLock was released. Verify that we know about
    // the destination node.
    //
    if (destNode == NULL) {
        status = STATUS_HOST_UNREACHABLE;
        goto error_exit;
    }

    destNodeLocked = TRUE;

    //
    // CNP multicast messages must be signed.
    //
    if (multicast) {

        CnAssert(((CNP_HEADER UNALIGNED *)(SendRequest->CnpHeader))
                 ->Version = CNP_VERSION_MULTICAST);

        //
        // Sign the data, starting with the upper protocol header
        // and finishing with the data payload.
        //
        // If we are requesting the current best multicast network,
        // we need to make sure that the mcast group data structure
        // is dereferenced.
        //
        mcastGroupReferenced = (BOOLEAN)(networkId == ClusterAnyNetworkId);

        status = CnpSignMulticastMessage(
                     SendRequest,
                     DataMdl,
                     &networkId,
                     &sigDataLen
                     );
        if (status != STATUS_SUCCESS) {
            mcastGroupReferenced = FALSE;
            goto error_exit;
        }


    } else {
        sigDataLen = 0;
    }

    //
    // Choose the destination interface.
    //
    if (networkId != ClusterAnyNetworkId) {

        //
        // we really want to send this packet over the indicated
        // network. walk the node's interface list matching the
        // supplied network id to the interface's network ID and
        // send the packet on that interface
        //

        PLIST_ENTRY      entry;

        for (entry = destNode->InterfaceList.Flink;
             entry != &(destNode->InterfaceList);
             entry = entry->Flink
             )
            {
                interface = CONTAINING_RECORD(
                                entry,
                                CNP_INTERFACE,
                                NodeLinkage
                                );

                if ( interface->Network->Id == networkId ) {
                    break;
                }
            }

        if ( entry == &destNode->InterfaceList ) {
            //
            // no network object with the specified ID. if
            // this is the network the sender designated,
            // fail the send.
            //
            status = STATUS_NETWORK_UNREACHABLE;
            goto error_exit;
        }
    } else {
        interface = destNode->CurrentInterface;
    }

    //
    // Verify that we know about the destination interface.
    //
    if (interface == NULL) {
        // No interface for node. Must be down. Note that the
        // HOST_DOWN error code should cause the caller to give
        // up immediately.
        status = STATUS_HOST_DOWN;
        // status = STATUS_HOST_UNREACHABLE;

        goto error_exit;
    }

    //
    // Verify that everything is online. If all looks okay,
    // take an active reference on the network.
    //
    // For unicasts, verify the state of destination interface,
    // node, and intervening network.
    //
    // For multicasts, verify the state of the network and
    // its multicast capability.
    //
    network = interface->Network;

    if ( (!multicast)
         &&
         ( (interface->State > ClusnetInterfaceStateOfflinePending)
           &&
           (destNode->CommState == ClusnetNodeCommStateOnline)
         )
       )
    {
        //
        // Everything checks out. Reference the network so
        // it can't go offline while we are using it.
        //
        CnAcquireLockAtDpc(&(network->Lock));
        CnAssert(network->State >= ClusnetNetworkStateOfflinePending);
        if (!CnpActiveReferenceNetwork(network)) {
            // This Network is being closed down. We
            // cannot send the data.
            CnReleaseLockFromDpc(&(network->Lock));
            status = STATUS_HOST_UNREACHABLE;
            goto error_exit;
        }
        CnReleaseLockFromDpc(&(network->Lock));

        networkReferenced = TRUE;

    } else {
        //
        // Either the node is not online or this is a
        // multicast (in which case we don't bother checking
        // the status of all the nodes). Figure out what to do.
        //
        if (!multicast && CheckDestState) {
            //
            // Caller doesn't want to send to a down node.
            // Bail out. Note that the HOST_DOWN error code
            // should cause the caller to give up immediately.
            //
            status = STATUS_HOST_DOWN;
            // status = STATUS_HOST_UNREACHABLE;

            goto error_exit;
        }

        CnAcquireLockAtDpc(&(network->Lock));

        if (network->State <= ClusnetNetworkStateOfflinePending) {
            //
            // The chosen network is not online.
            // Bail out.
            //
            CnReleaseLockFromDpc(&(network->Lock));
            status = STATUS_HOST_UNREACHABLE;
            goto error_exit;
        }

        //
        // Verify that the chosen network has been
        // enabled for multicast.
        //
        if (multicast && !CnpIsNetworkMulticastCapable(network)) {
            CnReleaseLockFromDpc(&(network->Lock));
            status = STATUS_HOST_UNREACHABLE;
            goto error_exit;
        }

        //
        // Reference the network so it can't go offline
        // while we are using it.
        //
        if (!CnpActiveReferenceNetwork(network)) {
            // This Network is being closed down. We
            // cannot send the data.
            CnReleaseLockFromDpc(&(network->Lock));
            status = STATUS_HOST_UNREACHABLE;
            goto error_exit;
        }

        //
        // The network is online, even if the host isn't.
        // The caller doesn't care. Go for it.
        //
        CnReleaseLockFromDpc(&(network->Lock));
        networkReferenced = TRUE;
    }

    //
    // Allocate a buffer for the destination address.
    //
    addressBuffer = CnAllocatePool(interface->TdiAddressLength);

    if (addressBuffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    //
    // Fill in the address buffer, and save it in the send
    // request data structure.
    //
    if (multicast) {

        PCNP_MULTICAST_GROUP   mcastGroup = SendRequest->McastGroup;

        CnAssert(mcastGroup != NULL);

        CnAssert(
            CnpIsIPv4McastTransportAddress(mcastGroup->McastTdiAddress)
            );
        CnAssert(
            mcastGroup->McastTdiAddressLength == interface->TdiAddressLength
            );

        RtlMoveMemory(
            addressBuffer,
            mcastGroup->McastTdiAddress,
            mcastGroup->McastTdiAddressLength
            );

        SendRequest->TdiSendDatagramInfo.RemoteAddressLength =
            mcastGroup->McastTdiAddressLength;

        if (mcastGroupReferenced) {
            CnpDereferenceMulticastGroup(mcastGroup);
            mcastGroupReferenced = FALSE;
            SendRequest->McastGroup = NULL;
        }

        targetFileObject = network->DatagramFileObject;
        targetDeviceObject = network->DatagramDeviceObject;

    } else {

        CnAssert(mcastGroupReferenced == FALSE);

        RtlMoveMemory(
            addressBuffer,
            &(interface->TdiAddress),
            interface->TdiAddressLength
            );

        SendRequest->TdiSendDatagramInfo.RemoteAddressLength =
            interface->TdiAddressLength;

        targetFileObject = network->DatagramFileObject;
        targetDeviceObject = network->DatagramDeviceObject;
    }

    SendRequest->TdiSendDatagramInfo.RemoteAddress =
        addressBuffer;

    //
    // Release the node lock.
    //
    CnReleaseLock(&(destNode->Lock), destNode->Irql);
    destNodeLocked = FALSE;

    //
    // If there is an upper protocol IRP, see
    // if it has enough stack locations.
    //
    if ( (upperIrp != NULL)
         &&
         (CnpIsIrpStackSufficient(upperIrp, targetDeviceObject))
       ) {

        //
        // We can use the upper protocol IRP.
        //
        irp = upperIrp;
        compRoutine = CnpCompleteSendPacketReuseIrp;

        //
        // Ensure that IRP is marked as a kernel request,
        // but first save the current requestor mode so
        // that it can be restored later.
        //
        SendRequest->UpperProtocolIrpMode = irp->RequestorMode;
        irp->RequestorMode = KernelMode;

        //
        // Save the upper protocol IRP MDL to restore
        // later. This is probably the same as DataMdl,
        // but we don't want to make any assumptions.
        //
        SendRequest->UpperProtocolMdl = irp->MdlAddress;

    } else {

        //
        // We cannot use the upper protocol IRP.
        //
        // If there is an upper protocol IRP, it needs
        // to be marked pending.
        //
        if (upperIrp != NULL) {

            CnAcquireCancelSpinLock(&cancelIrql);

            status = CnMarkRequestPending(
                         upperIrp,
                         IoGetCurrentIrpStackLocation(upperIrp),
                         NULL
                         );

            CnReleaseCancelSpinLock(cancelIrql);

            if (status == STATUS_CANCELLED) {
                //
                // Bail out
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto error_exit;

            } else {
                //
                // If IoAllocateIrp fails, we need
                // to call CnCompletePendingRequest
                // now that we've called
                // CnMarkRequestPending.
                //
                cnComplete = TRUE;
            }
        }

        //
        // Allocate a new IRP
        //
        irp = IoAllocateIrp(
                  targetDeviceObject->StackSize,
                  FALSE
                  );
        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        }

        //
        // Use the completion routine for having
        // allocated a new IRP
        //
        compRoutine = CnpCompleteSendPacketNewIrp;

        //
        // Fill in IRP fields that are not specific
        // to any one stack location.
        //
        irp->Flags = 0;
        irp->RequestorMode = KernelMode;
        irp->PendingReturned = FALSE;

        irp->UserIosb = NULL;
        irp->UserEvent = NULL;

        irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->UserBuffer = NULL;

        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    }

    //
    // Ok, we can finally send the packet.
    //
    SendRequest->Network = network;

    //
    // Link the data MDL chain after the header MDL.
    //
    SendRequest->HeaderMdl->Next = DataMdl;

    //
    // Finish building the CNP header.
    //
    cnpHeader->DestinationAddress = DestNodeId;
    cnpHeader->PayloadLength =
        SendRequest->UpperProtocolHeaderLength + DataLength;

    //
    // Build the next irp stack location.
    //
    TdiBuildSendDatagram(
        irp,
        targetDeviceObject,
        targetFileObject,
        compRoutine,
        SendRequest,
        SendRequest->HeaderMdl,
        cnpHeader->PayloadLength + sizeof(CNP_HEADER) + sigDataLen,
        &(SendRequest->TdiSendDatagramInfo)
        );

    CnTrace(CNP_SEND_DETAIL, CnpTraceSend,
        "[CNP] Sending packet to node %u on net %u, "
        "data len %u",
        cnpHeader->DestinationAddress, // LOGULONG
        network->Id, // LOGULONG
        cnpHeader->PayloadLength // LOGUSHORT
        );

    //
    // Now send the packet.
    //
    status = IoCallDriver(
                 targetDeviceObject,
                 irp
                 );

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);


    //
    // The following code is only executed in an error condition,
    // No send IRP has been submitted to a lower-level driver.
    //

error_exit:

    CnTrace(CNP_SEND_ERROR, CnpTraceSendFailedInternal,
        "[CNP] Failed to send packet to node %u on net %u, "
        "data len %u, status %!status!",
        cnpHeader->DestinationAddress, // LOGULONG
        NetworkId, // LOGULONG
        cnpHeader->PayloadLength, // LOGUSHORT
        status // LOGSTATUS
        );

    if (destNodeLocked) {
        CnReleaseLock(&(destNode->Lock), destNode->Irql);
        destNodeLocked = FALSE;
    }

    if (networkReferenced) {
        //
        // Remove the active reference we put on the network.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
        CnpActiveDereferenceNetwork(network);
        networkReferenced = FALSE;
    }

    if (mcastGroupReferenced) {
        CnAssert(SendRequest->McastGroup != NULL);
        CnpDereferenceMulticastGroup(SendRequest->McastGroup);
        SendRequest->McastGroup = NULL;
        mcastGroupReferenced = FALSE;
    }

    if (addressBuffer != NULL) {
        CnFreePool(addressBuffer);
    }

    //
    // Call the upper protocol completion routine
    //
    if (SendRequest->CompletionRoutine) {

        ULONG bytesSent = 0;

        (*SendRequest->CompletionRoutine)(
            status,
            &bytesSent,
            SendRequest,
            DataMdl
            );
    }

    //
    // Complete the upper protocol IRP, if there is one
    //
    if (upperIrp) {

        if (cnComplete) {

            //
            // CnMarkRequestPending was called for upperIrp.
            //
            IF_CNDBG( CN_DEBUG_CNPSEND )
                CNPRINT(("[CNP] Calling CnCompletePendingRequest "
                         "for IRP %p with status %08x\n",
                         upperIrp, status));

            CnCompletePendingRequest(upperIrp, status, 0);

        } else {

            IF_CNDBG( CN_DEBUG_CNPSEND )
                CNPRINT(("[CNP] Completing IRP %p with status %08x\n",
                         upperIrp, status));

            upperIrp->IoStatus.Status = status;
            upperIrp->IoStatus.Information = 0;
            IoCompleteRequest(upperIrp, IO_NO_INCREMENT);
        }
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);

} // CnpSendPacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cxinfo.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxinfo.c

Abstract:

    TDI Set/Query Information routines.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cxinfo.tmh"


#ifdef ALLOC_PRAGMA


#endif // ALLOC_PRAGMA


#if 0

#define CDP_SERVICE_FLAGS    (TDI_SERVICE_CONNECTIONLESS_MODE | \
                             TDI_SERVICE_BROADCAST_SUPPORTED)
#else // 0

//
// TDI_SERVICE_FORCE_ACCESS_CHECK tells AFD to provide security 
// information (via IoCreateFile options) when creating CDP sockets.
//
#define CDP_SERVICE_FLAGS    (TDI_SERVICE_CONNECTIONLESS_MODE | \
                              TDI_SERVICE_FORCE_ACCESS_CHECK)

#endif // 0


NTSTATUS
CxQueryInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS                                status = STATUS_SUCCESS;
    PCN_FSCONTEXT                           fsContext;
    PCX_ADDROBJ                             addrObj;
    CN_IRQL                                 irql;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInformation;
    ULONG                                   fileType;
    ULONG                                   infoSize;
    PVOID                                   infoBuffer;
    union {
        TDI_PROVIDER_INFO  ProviderInfo;
        TDI_ADDRESS_INFO   AddressInfo;
        struct {
            TDI_ADDRESS_INFO     AddressInfo;
            TDI_ADDRESS_CLUSTER  ClusterAddress;
        } DummyAddressInfo;
    } info;


    fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    fileType = PtrToUlong(IrpSp->FileObject->FsContext2);
    queryInformation = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)
                           &(IrpSp->Parameters);

    IF_CNDBG(CN_DEBUG_INFO) {
        CNPRINT((
            "[Clusnet] TDI query info type %u\n",
            queryInformation->QueryType
            ));
    }

    switch(queryInformation->QueryType) {

    case TDI_QUERY_BROADCAST_ADDRESS:
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case TDI_QUERY_PROVIDER_INFO:
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);

        infoSize = sizeof(info.ProviderInfo);
        infoBuffer = &(info.ProviderInfo);
        info.ProviderInfo.Version = 0x0100;
        info.ProviderInfo.MaxSendSize = 0;
        info.ProviderInfo.MaxConnectionUserData = 0;
        info.ProviderInfo.MaxDatagramSize = 
            CDP_MAX_SEND_SIZE(CX_SIGNATURE_LENGTH);
        info.ProviderInfo.ServiceFlags = CDP_SERVICE_FLAGS;
        info.ProviderInfo.MinimumLookaheadData = 1;
        info.ProviderInfo.MaximumLookaheadData = 0xFFFFF;
        info.ProviderInfo.NumberOfResources = 0;
        info.ProviderInfo.StartTime.QuadPart = 0;

        break;

    case TDI_QUERY_PROVIDER_STATISTICS:
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
            infoSize = FIELD_OFFSET(TDI_ADDRESS_INFO, Address) +
                       sizeof(TA_CLUSTER_ADDRESS);
            infoBuffer = &(info.AddressInfo);
            addrObj = (PCX_ADDROBJ) fsContext;

            //
            // Since no one knows what the activity count means, we'll just set
            // it to 1.
            //
            info.AddressInfo.ActivityCount = 1;

            CnAcquireLock(&(addrObj->Lock), &irql);

            CxBuildTdiAddress(
                &(info.AddressInfo.Address),
                CnLocalNodeId,
                addrObj->LocalPort,
                FALSE
                );

            CnReleaseLock(&(addrObj->Lock), irql);
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (status == STATUS_SUCCESS) {

        PULONG pnBytes = &((ULONG)(Irp->IoStatus.Information));

        status = TdiCopyBufferToMdl(
                     infoBuffer,
                     0,
                     infoSize,
                     Irp->MdlAddress,
                     0,
                     pnBytes
                     );
    }

    IF_CNDBG(CN_DEBUG_INFO) {
        CNPRINT((
            "[Clusnet] TDI query info returning status %lx, %u bytes\n",
            status,
            (ULONG)(Irp->IoStatus.Information)
            ));
    }

    return(status);

}  // CxQueryInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cxdisp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cxdisp.c

Abstract:

    Dispatch routines for the Cluster Transport.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cxdisp.tmh"

#include <align.h>
#include <strsafe.h>

//
// Local Prototypes
//
NTSTATUS
CxDispatchRegisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchDeregisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchRegisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchDeregisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchRegisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchDeregisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOnlineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOfflineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOnlineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOfflineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetNetworkRestriction(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNetworkState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetInterfaceState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchIgnoreNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSendPoisonPacket(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetOuterscreen(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchRegroupFinished(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchImportSecurityContext(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchReserveClusnetEndpoint(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchConfigureMulticast(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetMulticastReachableSet(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


#if DBG

NTSTATUS
CxDispatchOnlinePendingInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOnlineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOfflineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchFailInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSendMmMsg(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


#endif // DBG


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CxDispatchDeviceControl)
#pragma alloc_text(PAGE, CxDispatchRegisterNode)
#pragma alloc_text(PAGE, CxDispatchDeregisterNode)
#pragma alloc_text(PAGE, CxDispatchRegisterNetwork)
#pragma alloc_text(PAGE, CxDispatchDeregisterNetwork)
#pragma alloc_text(PAGE, CxDispatchRegisterInterface)
#pragma alloc_text(PAGE, CxDispatchDeregisterInterface)
#pragma alloc_text(PAGE, CxDispatchOnlineNodeComm)
#pragma alloc_text(PAGE, CxDispatchOfflineNodeComm)
#pragma alloc_text(PAGE, CxDispatchOnlineNetwork)
#pragma alloc_text(PAGE, CxDispatchOfflineNetwork)
#pragma alloc_text(PAGE, CxDispatchSetNetworkRestriction)
#pragma alloc_text(PAGE, CxDispatchGetNetworkPriority)
#pragma alloc_text(PAGE, CxDispatchSetNetworkPriority)
#pragma alloc_text(PAGE, CxDispatchGetInterfacePriority)
#pragma alloc_text(PAGE, CxDispatchSetInterfacePriority)
#pragma alloc_text(PAGE, CxDispatchGetNodeState)
#pragma alloc_text(PAGE, CxDispatchGetNetworkState)
#pragma alloc_text(PAGE, CxDispatchGetInterfaceState)
#pragma alloc_text(PAGE, CxDispatchGetNodeMembershipState)
#pragma alloc_text(PAGE, CxDispatchSetNodeMembershipState)
#pragma alloc_text(PAGE, CxDispatchSendPoisonPacket)
#pragma alloc_text(PAGE, CxDispatchSetOuterscreen)
#pragma alloc_text(PAGE, CxDispatchRegroupFinished)
#pragma alloc_text(PAGE, CxDispatchImportSecurityContext)
#pragma alloc_text(PAGE, CxDispatchReserveClusnetEndpoint)
#pragma alloc_text(PAGE, CxDispatchConfigureMulticast)
#pragma alloc_text(PAGE, CxDispatchGetMulticastReachableSet)


#if DBG

#pragma alloc_text(PAGE, CxDispatchOnlinePendingInterface)
#pragma alloc_text(PAGE, CxDispatchOnlineInterface)
#pragma alloc_text(PAGE, CxDispatchOfflineInterface)
#pragma alloc_text(PAGE, CxDispatchFailInterface)
#ifdef MM_IN_CLUSNET
#pragma alloc_text(PAGE, CxDispatchSendMmMsg)
#endif // MM_IN_CLUSNET

#endif // DBG

#endif // ALLOC_PRAGMA




NTSTATUS
CxDispatchDeviceControl(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Dispatch routine for device control ioctls.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Notes:

    Any IRP for which the return value is not STATUS_PENDING will be
    completed by the calling routine.

--*/

{
    NTSTATUS              status;


    PAGED_CODE();

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CX_REGISTER_NODE:
            status = CxDispatchRegisterNode(Irp, IrpSp);
            break;

        case IOCTL_CX_DEREGISTER_NODE:
            status = CxDispatchDeregisterNode(Irp, IrpSp);
            break;

        case IOCTL_CX_REGISTER_NETWORK:
            status = CxDispatchRegisterNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_DEREGISTER_NETWORK:
            status = CxDispatchDeregisterNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_REGISTER_INTERFACE:
            status = CxDispatchRegisterInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_DEREGISTER_INTERFACE:
            status = CxDispatchDeregisterInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_ONLINE_NODE_COMM:
            status = CxDispatchOnlineNodeComm(Irp, IrpSp);
            break;

        case IOCTL_CX_OFFLINE_NODE_COMM:
            status = CxDispatchOfflineNodeComm(Irp, IrpSp);
            break;

        case IOCTL_CX_ONLINE_NETWORK:
            status = CxDispatchOnlineNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_OFFLINE_NETWORK:
            status = CxDispatchOfflineNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_NETWORK_RESTRICTION:
            status = CxDispatchSetNetworkRestriction(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NETWORK_PRIORITY:
            status = CxDispatchGetNetworkPriority(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_NETWORK_PRIORITY:
            status = CxDispatchSetNetworkPriority(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_INTERFACE_PRIORITY:
            status = CxDispatchGetInterfacePriority(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_INTERFACE_PRIORITY:
            status = CxDispatchSetInterfacePriority(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NODE_STATE:
            status = CxDispatchGetNodeState(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NETWORK_STATE:
            status = CxDispatchGetNetworkState(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_INTERFACE_STATE:
            status = CxDispatchGetInterfaceState(Irp, IrpSp);
            break;

        case IOCTL_CX_IGNORE_NODE_STATE:
            status = CxDispatchIgnoreNodeState(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NODE_MMSTATE:
            status = CxDispatchGetNodeMembershipState(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_NODE_MMSTATE:
            status = CxDispatchSetNodeMembershipState(Irp, IrpSp);
            break;

        case IOCTL_CX_SEND_POISON_PACKET:
            status = CxDispatchSendPoisonPacket(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_OUTERSCREEN:
            status = CxDispatchSetOuterscreen(Irp, IrpSp);
            break;

        case IOCTL_CX_REGROUP_FINISHED:
            status = CxDispatchRegroupFinished(Irp, IrpSp);
            break;

        case IOCTL_CX_IMPORT_SECURITY_CONTEXTS:
            status = CxDispatchImportSecurityContext(Irp, IrpSp);
            break;

        case IOCTL_CX_RESERVE_ENDPOINT:
            status = CxDispatchReserveClusnetEndpoint(Irp, IrpSp);
            break;

        case IOCTL_CX_CONFIGURE_MULTICAST:
            status = CxDispatchConfigureMulticast(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_MULTICAST_REACHABLE_SET:
            status = CxDispatchGetMulticastReachableSet(Irp, IrpSp);
            break;

#if DBG

        case IOCTL_CX_ONLINE_PENDING_INTERFACE:
            status = CxDispatchOnlinePendingInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_ONLINE_INTERFACE:
            status = CxDispatchOnlineInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_OFFLINE_INTERFACE:
            status = CxDispatchOfflineInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_FAIL_INTERFACE:
            status = CxDispatchFailInterface(Irp, IrpSp);
            break;

#ifdef MM_IN_CLUSNET
        case IOCTL_CX_SEND_MM_MSG:
            status = CxDispatchSendMmMsg(Irp, IrpSp);
            break;
#endif // MM_IN_CLUSNET

#endif // DBG

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return(status);

} // CxDispatchDeviceControl


NTSTATUS
CxDispatchRegisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS               status;
    PCX_NODE_REG_REQUEST   request;
    ULONG                  requestSize;


    PAGED_CODE();

    request = (PCX_NODE_REG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NODE_REG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxRegisterNode(
                 request->Id
                 );

    return(status);

}   // CxDispatchRegisterNode


NTSTATUS
CxDispatchDeregisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                 status;
    PCX_NODE_DEREG_REQUEST   request;
    ULONG                    requestSize;


    PAGED_CODE();

    request = (PCX_NODE_DEREG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NODE_DEREG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxDeregisterNode(request->Id, Irp, IrpSp);

    return(status);

}   // CxDispatchDeregisterNode


NTSTATUS
CxDispatchRegisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                    status;
    PCX_NETWORK_REG_REQUEST     request;
    ULONG                       requestSize;


    PAGED_CODE();

    request = (PCX_NETWORK_REG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NETWORK_REG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxRegisterNetwork(
                 request->Id,
                 request->Priority,
                 request->Restricted
                 );

    return(status);

}   // CxDispatchRegisterNetwork


NTSTATUS
CxDispatchDeregisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                    status;
    PCX_NETWORK_DEREG_REQUEST   request;
    ULONG                       requestSize;


    PAGED_CODE();

    request = (PCX_NETWORK_DEREG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NETWORK_DEREG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxDeregisterNetwork(request->Id, Irp, IrpSp);

    return(status);

}   // CxDispatchDeregisterNetwork


NTSTATUS
CxDispatchRegisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                   status;
    PCX_INTERFACE_REG_REQUEST  request;
    ULONG                      requestSize, resid;
    PCX_INTERFACE_REG_RESPONSE response;
    ULONG                      responseSize;

    PWCHAR                     adapterId;

    PAGED_CODE();

    // Verify that the request buffer has sufficient size, given the 
    // offsets and lengths.

    request = (PCX_INTERFACE_REG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_INTERFACE_REG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    response = (PCX_INTERFACE_REG_RESPONSE) Irp->AssociatedIrp.SystemBuffer;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (responseSize < sizeof(CX_INTERFACE_REG_RESPONSE)) {
        return(STATUS_INVALID_PARAMETER);
    }

    resid = requestSize 
        - FIELD_OFFSET(CX_INTERFACE_REG_REQUEST, TdiAddress[0]);

    if (resid < request->TdiAddressLength) {
        return(STATUS_INVALID_PARAMETER);
    }

    resid -= request->TdiAddressLength;

    if (request->AdapterIdOffset
        < FIELD_OFFSET(CX_INTERFACE_REG_REQUEST, TdiAddress[0])
        + request->TdiAddressLength
        || request->AdapterIdOffset > requestSize) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (resid < request->AdapterIdLength) {
        return(STATUS_INVALID_PARAMETER);
    }

    // Verify that the string offset is properly aligned
    adapterId = (PWCHAR)((PUCHAR)request + request->AdapterIdOffset);

    if (!POINTER_IS_ALIGNED(adapterId, TYPE_ALIGNMENT(WCHAR))) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxRegisterInterface(
                 request->NodeId,
                 request->NetworkId,
                 request->Priority,
                 (PUWSTR)((PUCHAR)request + request->AdapterIdOffset),
                 request->AdapterIdLength,
                 request->TdiAddressLength,
                 (PTRANSPORT_ADDRESS) &(request->TdiAddress[0]),
                 &response->MediaStatus
                 );

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CX_INTERFACE_REG_RESPONSE);
    }

    return(status);

}   // CxDispatchRegisterInterface


NTSTATUS
CxDispatchDeregisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                      status;
    PCX_INTERFACE_DEREG_REQUEST   request;
    ULONG                         requestSize;


    PAGED_CODE();

    request = (PCX_INTERFACE_DEREG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_INTERFACE_DEREG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxDeregisterInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchDeregisterInterface


NTSTATUS
CxDispatchOnlineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                  status;
    PCX_ONLINE_NODE_COMM_REQUEST   request;
    ULONG                     requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_NODE_COMM_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_NODE_COMM_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlineNodeComm(request->Id);

    return(status);

}  // CxDispatchOnlineNodeComm


NTSTATUS
CxDispatchOfflineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                      status;
    PCX_OFFLINE_NODE_COMM_REQUEST      request;
    ULONG                         requestSize;


    PAGED_CODE();

    request = (PCX_OFFLINE_NODE_COMM_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_OFFLINE_NODE_COMM_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOfflineNodeComm(request->Id, Irp, IrpSp);

    return(status);

}  // CxDispatchOfflineNodeComm


NTSTATUS
CxDispatchOnlineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                    status;
    PCX_ONLINE_NETWORK_REQUEST  request;
    ULONG                       requestSize;
    PTDI_ADDRESS_INFO           response;
    ULONG                       responseSize;
    ULONG                       requiredSize = sizeof(
                                                   CX_ONLINE_NETWORK_REQUEST
                                                   );
    PWCHAR                      tdiProviderName;
    PTRANSPORT_ADDRESS          tdiBindAddress;
    PWCHAR                      adapterName;


    PAGED_CODE();

    //
    // Validate the request buffer
    //

    // First validate that the request buffer size matches the offsets
    // and lengths.
    request = (PCX_ONLINE_NETWORK_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < requiredSize) {
        return(STATUS_INVALID_PARAMETER);
    }

    // Validate that all offset length pairs are within the request
    // buffer.
    if ( ( request->TdiProviderNameOffset + request->TdiProviderNameLength
           < request->TdiProviderNameOffset
         ) ||
         ( request->TdiProviderNameOffset + request->TdiProviderNameLength
           > requestSize
         ) ||
         ( request->TdiBindAddressOffset + request->TdiBindAddressLength
           < request->TdiBindAddressOffset
         ) ||
         ( request->TdiBindAddressOffset + request->TdiBindAddressLength
           > requestSize
         ) ||
         ( request->AdapterNameOffset + request->AdapterNameLength
           < request->AdapterNameOffset
         ) ||
         ( request->AdapterNameOffset + request->AdapterNameLength
           > requestSize
         )
       ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Construct pointers to the parameters.
    tdiBindAddress = (PTRANSPORT_ADDRESS)
                     ( ((PUCHAR) request) + request->TdiBindAddressOffset );

    tdiProviderName = (PWCHAR)
                      ( ((PUCHAR) request) + request->TdiProviderNameOffset );

    adapterName = (PWCHAR)
                  ( ((PUCHAR) request) + request->AdapterNameOffset );

    // Validate that the resulting pointers are properly aligned and
    // within the request buffer.
    if ( ( ((PUCHAR) tdiBindAddress) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) tdiBindAddress) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(tdiBindAddress, 
                               TYPE_ALIGNMENT(TRANSPORT_ADDRESS)) ) ||
         ( ((PUCHAR) tdiProviderName) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) tdiProviderName) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(tdiProviderName, TYPE_ALIGNMENT(WCHAR)) ) ||
         ( ((PUCHAR) adapterName) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) adapterName) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(adapterName, TYPE_ALIGNMENT(WCHAR)) )
        )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Validate that name strings are null-terminated. The length
    // fields in the request structure are byte counts, but 
    // StringCchLengthW takes a character count.
    if (
         (StringCchLengthW(
              tdiProviderName, 
              request->TdiProviderNameLength / sizeof(WCHAR),
              NULL
              ) != S_OK) ||

         (StringCchLengthW(
              adapterName,
              request->AdapterNameLength / sizeof(WCHAR),
              NULL
              ) != S_OK)
        )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Validate the response buffer
    //
    response = (PTDI_ADDRESS_INFO) Irp->AssociatedIrp.SystemBuffer;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    requiredSize = FIELD_OFFSET(TDI_ADDRESS_INFO, Address) +
                   request->TdiBindAddressLength;

    if (responseSize < requiredSize) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlineNetwork(
                 request->Id,
                 tdiProviderName,
                 request->TdiProviderNameLength,
                 tdiBindAddress,
                 request->TdiBindAddressLength,
                 adapterName,
                 request->AdapterNameLength,
                 response,
                 responseSize,
                 Irp
                 );

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = responseSize;
    }

    return(status);

}  // CxDispatchOnlineNetwork


NTSTATUS
CxDispatchOfflineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                      status;
    PCX_OFFLINE_NETWORK_REQUEST   request;
    ULONG                         requestSize;


    PAGED_CODE();

    request = (PCX_OFFLINE_NETWORK_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_OFFLINE_NETWORK_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOfflineNetwork(request->Id, Irp, IrpSp);

    return(status);

}  // CxDispatchOfflineNetwork


NTSTATUS
CxDispatchSetNetworkRestriction(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    ULONG                                requestSize;
    PCX_SET_NETWORK_RESTRICTION_REQUEST  request;


    PAGED_CODE();

    request = (PCX_SET_NETWORK_RESTRICTION_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SET_NETWORK_RESTRICTION_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetNetworkRestriction(
                 request->Id,
                 request->Restricted,
                 request->NewPriority
                 );

    return(status);

}   // CxDispatchSetNetworkRestriction


NTSTATUS
CxDispatchGetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_NETWORK_PRIORITY_REQUEST     request;
    PCX_GET_NETWORK_PRIORITY_RESPONSE    response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_NETWORK_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NETWORK_PRIORITY_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NETWORK_PRIORITY_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNetworkPriority(
                 request->Id,
                 &(response->Priority)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNetworkPriority


NTSTATUS
CxDispatchSetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS        status;
    ULONG           requestSize;
    PCX_SET_NETWORK_PRIORITY_REQUEST  request;


    PAGED_CODE();

    request = (PCX_SET_NETWORK_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SET_NETWORK_PRIORITY_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetNetworkPriority(
                 request->Id,
                 request->Priority
                 );

    return(status);

}   // CxDispatchSetNetworkPriority


NTSTATUS
CxDispatchGetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_INTERFACE_PRIORITY_REQUEST   request;
    PCX_GET_INTERFACE_PRIORITY_RESPONSE  response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_INTERFACE_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_INTERFACE_PRIORITY_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_INTERFACE_PRIORITY_REQUEST)) ||
         (responseSize < sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetInterfacePriority(
                 request->NodeId,
                 request->NetworkId,
                 &(response->InterfacePriority),
                 &(response->NetworkPriority)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE);
    }

    return(status);

}   // CxDispatchGetInterfacePriority


NTSTATUS
CxDispatchSetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS        status;
    ULONG           requestSize;
    PCX_SET_INTERFACE_PRIORITY_REQUEST  request;


    PAGED_CODE();

    request = (PCX_SET_INTERFACE_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SET_INTERFACE_PRIORITY_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetInterfacePriority(
                 request->NodeId,
                 request->NetworkId,
                 request->Priority
                 );

    return(status);

}   // CxDispatchSetInterfacePriority


NTSTATUS
CxDispatchGetNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_NODE_STATE_REQUEST           request;
    PCX_GET_NODE_STATE_RESPONSE          response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_NODE_STATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NODE_STATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NODE_STATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NODE_STATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNodeCommState(
                 request->Id,
                 &(response->State)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NODE_STATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNodeState


NTSTATUS
CxDispatchGetNetworkState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_NETWORK_STATE_REQUEST        request;
    PCX_GET_NETWORK_STATE_RESPONSE       response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_NETWORK_STATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NETWORK_STATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NETWORK_STATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NETWORK_STATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNetworkState(
                 request->Id,
                 &(response->State)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NETWORK_STATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNetworkState


NTSTATUS
CxDispatchGetInterfaceState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_INTERFACE_STATE_REQUEST      request;
    PCX_GET_INTERFACE_STATE_RESPONSE     response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_INTERFACE_STATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_INTERFACE_STATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_INTERFACE_STATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_INTERFACE_STATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetInterfaceState(
                 request->NodeId,
                 request->NetworkId,
                 &(response->State)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_INTERFACE_STATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetInterfaceState

NTSTATUS
CxDispatchIgnoreNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PCX_ADDROBJ   addrObj = (PCX_ADDROBJ) (IrpSp->FileObject->FsContext);
    CN_IRQL       irql;


    CnAcquireLock(&(addrObj->Lock), &irql);

    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT(("[CDP] Turning off checkstate flag on AO %p\n", addrObj));
    }

    addrObj->Flags &= ~(CX_AO_FLAG_CHECKSTATE);

    CnReleaseLock(&(addrObj->Lock), irql);

    return(STATUS_SUCCESS);

}   // CxDispatchIgnoreNodeState

NTSTATUS
CxDispatchGetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_GET_NODE_MMSTATE_REQUEST request;
    PCX_GET_NODE_MMSTATE_RESPONSE response;
    ULONG requestSize;
    ULONG responseSize;


    PAGED_CODE();

    request = (PCX_GET_NODE_MMSTATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NODE_MMSTATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NODE_MMSTATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NODE_MMSTATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNodeMembershipState( request->Id, &(response->State));

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NODE_MMSTATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNodeMembershipState

NTSTATUS
CxDispatchSetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_SET_NODE_MMSTATE_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;


    PAGED_CODE();

    request = (PCX_SET_NODE_MMSTATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof( CX_SET_NODE_MMSTATE_REQUEST ) ||
        request->State >= ClusnetNodeStateLastEntry) {

        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetNodeMembershipState( request->NodeId, request->State );

    Irp->IoStatus.Information = 0;

    return(status);

}   // CxDispatchSetNodeMembershipState

VOID
CxCompleteSendPoisonPacket(
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     MessageData
    )
{
    PIRP  irp = Context;

    CnAssert(Status != STATUS_PENDING);

    IF_CNDBG(( CN_DEBUG_IRP | CN_DEBUG_POISON ))
        CNPRINT(("[Clusnet] Completing SendPoisonPacket request for "
                 "irp %p, status %08X\n",
                 irp,
                 Status));

    //
    // The irp is completed in the CNP send completion routine.
    //

    return;

} // CxCompleteSendPoisonPacket


NTSTATUS
CxDispatchSendPoisonPacket(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                     status;
    PCX_SEND_POISON_PKT_REQUEST  request;
    ULONG                        requestSize;

    PAGED_CODE();

    request = (PCX_SEND_POISON_PKT_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    //
    // request size should exactly equal the size of the request struct plus
    // the data passed in
    //

    if ( requestSize != sizeof(CX_SEND_POISON_PKT_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // We will always return pending, so mark the IRP pending.
    // The IRP will be completed by CxCompleteSendPoisonPacket
    //
    IoMarkIrpPending(Irp);
    
    IF_CNDBG(( CN_DEBUG_IRP | CN_DEBUG_POISON ))
        CNPRINT(("[Clusnet] Posting SendPoisonPacket irp %p\n", Irp));

    CxSendPoisonPacket(
        request->Id,
        CxCompleteSendPoisonPacket,
        Irp,
        Irp
        );

    return(STATUS_PENDING);

} // CxDispatchSendPoisonPacket

NTSTATUS
CxDispatchSetOuterscreen(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_SET_OUTERSCREEN_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;


    PAGED_CODE();

    request = (PCX_SET_OUTERSCREEN_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize < sizeof( CX_SET_OUTERSCREEN_REQUEST )) {

        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetOuterscreen( request->Outerscreen );

    Irp->IoStatus.Information = 0;

    return(status);

}   // CxDispatchSetOuterscreen

NTSTATUS
CxDispatchRegroupFinished(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_REGROUP_FINISHED_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;

    PAGED_CODE();

    request = (PCX_REGROUP_FINISHED_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize < sizeof( CX_REGROUP_FINISHED_REQUEST )) {

        return(STATUS_INVALID_PARAMETER);
    }

    CxRegroupFinished( request->EventEpoch, request->RegroupEpoch );

    Irp->IoStatus.Information = 0;

    return( STATUS_SUCCESS );

}   // CxDispatchRegroupFinished

NTSTATUS
CxDispatchImportSecurityContext(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_IMPORT_SECURITY_CONTEXT_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;

    PAGED_CODE();

    request = (PCX_IMPORT_SECURITY_CONTEXT_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize < sizeof( CX_IMPORT_SECURITY_CONTEXT_REQUEST )) {

        return(STATUS_INVALID_PARAMETER);
    }

    status = CxImportSecurityContext(request->JoiningNodeId,
                                     request->PackageName,
                                     request->PackageNameSize,
                                     request->SignatureSize,
                                     request->ServerContext,
                                     request->ClientContext);

    Irp->IoStatus.Information = 0;

    return( status );

}   // CxDispatchImportSecurityContext

NTSTATUS
CxDispatchReserveClusnetEndpoint(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    USHORT   port;
    ULONG    requestSize;

    PAGED_CODE();

    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(USHORT)) {

        status = STATUS_INVALID_PARAMETER;
    }
    else {
        port = *((PUSHORT) Irp->AssociatedIrp.SystemBuffer);
        status = CxReserveClusnetEndpoint(port);
    }
    
    Irp->IoStatus.Information = 0;

    return (status);
}

NTSTATUS
CxDispatchConfigureMulticast(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                         status;
    PCX_CONFIGURE_MULTICAST_REQUEST  request;
    ULONG                            requestSize;
    ULONG                            requiredSize;

    PTRANSPORT_ADDRESS               tdiMcastAddress;
    PVOID                            key;
    
    PAGED_CODE();

    //
    // Validate the request buffer
    //

    // First validate that the request buffer size matches the offsets
    // and lengths.
    request = (PCX_CONFIGURE_MULTICAST_REQUEST)Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    //
    // The required size is based on the size and required alignment
    // of each field of data following the structure. If there is no
    // data following the structure, only the structure is required.
    //
    requiredSize = sizeof(CX_CONFIGURE_MULTICAST_REQUEST);

    //
    // Verify that the required size is present.
    //
    if (requestSize < requiredSize)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that all offset length pairs are within the request size.
    //
    if ( ( request->MulticastAddress + request->MulticastAddressLength
           < request->MulticastAddress
         ) ||
         ( request->MulticastAddress + request->MulticastAddressLength
           > requestSize
         ) ||
         ( request->Key + request->KeyLength < request->Key
         ) ||
         ( request->Key + request->KeyLength > requestSize
         ) 
       ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Construct pointers using the offsets.
    //
    tdiMcastAddress = (PTRANSPORT_ADDRESS)
                      ( ((PUCHAR) request) + request->MulticastAddress );

    key = (PVOID)( ((PUCHAR) request) + request->Key );

    //
    // Validate that the resulting pointers are properly aligned and
    // within the request data structure.
    //
    if ( ( ((PUCHAR) tdiMcastAddress) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) tdiMcastAddress) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(tdiMcastAddress, 
                               TYPE_ALIGNMENT(TRANSPORT_ADDRESS))) ||
         ( ((PUCHAR) key) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) key) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(key, TYPE_ALIGNMENT(PVOID))) 
       ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxConfigureMulticast(
                 request->NetworkId,
                 request->MulticastNetworkBrand,
                 tdiMcastAddress,
                 request->MulticastAddressLength,
                 key,
                 request->KeyLength,
                 Irp
                 );

    // No return data.
    Irp->IoStatus.Information = 0;

    return(status);

} // CxDispatchConfigureMulticast

NTSTATUS
CxDispatchGetMulticastReachableSet(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                                  status;
    PCX_GET_MULTICAST_REACHABLE_SET_REQUEST   request;
    PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE  response;
    ULONG                                     requestSize;
    ULONG                                     responseSize;

    PAGED_CODE();

    request = (PCX_GET_MULTICAST_REACHABLE_SET_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(PCX_GET_MULTICAST_REACHABLE_SET_REQUEST)) ||
         (responseSize < sizeof(PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetMulticastReachableSet(
                 request->Id,
                 &(response->NodeScreen)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = 
            sizeof(CX_GET_MULTICAST_REACHABLE_SET_RESPONSE);
    }

    return(status);

} // CxDispatchGetMulticastReachableSet

//
// Test IOCTLs.
//
#if DBG

NTSTATUS
CxDispatchOnlinePendingInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlinePendingInterface(request->NodeId, request->NetworkId);

    return(status);
}   // CxDispatchOnlinePendingInterface


NTSTATUS
CxDispatchOnlineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlineInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchOnlineInterface


NTSTATUS
CxDispatchOfflineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOfflineInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchOfflineInterface


NTSTATUS
CxDispatchFailInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxFailInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchFailInterface


VOID
CxCompleteSendMmMsg(
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     MessageData
    )
{
    PIRP  irp = Context;

    CnAssert(Status != STATUS_PENDING);

    CNPRINT((
        "[Clusnet] Completing SendMmMsg irp %p, status %lx, bytes sent %u\n",
        irp,
        Status,
        BytesSent
        ));

    //
    // Complete the irp.
    //
    irp->IoStatus.Status = Status;
    irp->IoStatus.Information = 0;

    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

    return;

} // CxCompleteSendMmMsg

#ifdef MM_IN_CLUSNET

NTSTATUS
CxDispatchSendMmMsg(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                     status;
    PCX_SEND_MM_MSG_REQUEST      request;
    ULONG                        requestSize;


    PAGED_CODE();

    request = (PCX_SEND_MM_MSG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SEND_MM_MSG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    IoMarkIrpPending(Irp);

    CNPRINT(("[Clusnet] Posting SendMmMsg irp %p\n", Irp));

    status = CxSendMembershipMessage(
                 request->DestNodeId,
                 &(request->MessageData[0]),
                 CX_MM_MSG_DATA_LEN,
                 CxCompleteSendMmMsg,
                 Irp
                 );

    return(status);


} // CxDispatchSendMmMsg
#endif // MM_IN_CLUSNET

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\precomp.h ===
#include "cxp.h"
#include "cnpdef.h"
#include "cdp.h"
#include "winerror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\autostart.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    autostart.c

Abstract:

    Autostart wmi loggers.
    Takes arguments from tracing registry
    (This code may end up in wpp framework, hence Wpp prefix)

Author:

    Gor Nishanov (gorn) 29-Oct-2000

Revision History:

--*/

#include "clusrtlp.h"
#include <wmistr.h>
#include <evntrace.h>

#define WppDebug(x,y) 

#define WPPINIT_STATIC

#define WPP_REG_TRACE_REGKEY            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing"

#define WPP_TEXTGUID_LEN 37

static TRACEHANDLE WppQueryLogger(PCWSTR LoggerName)
{
    ULONG status;
    EVENT_TRACE_PROPERTIES LoggerInfo;

    ZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
    LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
    LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

    status = QueryTraceW(0, LoggerName, &LoggerInfo);
    WppDebug(4, ("QueryLogger(%ws) => %x:%x %d\n", 
        LoggerName, LoggerInfo.Wnode.HistoricalContext, status) );   
    if (status == ERROR_SUCCESS || status == ERROR_MORE_DATA) {
        return (TRACEHANDLE) LoggerInfo.Wnode.HistoricalContext;
    }
    return 0;
}

WPPINIT_STATIC
__inline UINT WppHexVal(int ch) { 
    return isdigit(ch) ? ch - '0' : ch - 'a' + 10; 
}

WPPINIT_STATIC
UINT WppHex(LPCWSTR s, int n)
{
    UINT res = 0;
    while(n--) { res = res * 16 + WppHexVal(*s++); }
    return res;
}

WPPINIT_STATIC
VOID
WppGuidFromStr(
    IN LPCWSTR str,
    OUT LPGUID guid)
{
    guid->Data1 =            WppHex(str +  0, 8);
    guid->Data2 =    (USHORT)WppHex(str +  9, 4);
    guid->Data3 =    (USHORT)WppHex(str + 14, 4);
    guid->Data4[0] = (UCHAR) WppHex(str + 19, 2);
    guid->Data4[1] = (UCHAR) WppHex(str + 21, 2);
    guid->Data4[2] = (UCHAR) WppHex(str + 24, 2);
    guid->Data4[3] = (UCHAR) WppHex(str + 26, 2);
    guid->Data4[4] = (UCHAR) WppHex(str + 28, 2);
    guid->Data4[5] = (UCHAR) WppHex(str + 30, 2);
    guid->Data4[6] = (UCHAR) WppHex(str + 32, 2);
    guid->Data4[7] = (UCHAR) WppHex(str + 34, 2);
}

#define WPP_BUF_SIZE(hmem) ((hmem) ? (ULONG)LocalSize(hmem) : 0)

// Make sure that the buffer is at least of size dwSize
WPPINIT_STATIC 
DWORD WppGrowBuf(PVOID *Buf, DWORD dwSize)
{
    DWORD status = ERROR_SUCCESS;
    WppDebug(4, ("WppGrowBuf(%x, %d (%d)) => ", *Buf, dwSize, WPP_BUF_SIZE(*Buf)) );
    if (*Buf == 0) {
        *Buf = LocalAlloc(LMEM_FIXED, dwSize);
        if (*Buf == 0) {
            status = GetLastError();
        }
    } else if (LocalSize(*Buf) < dwSize) {
        PVOID newBuf = LocalReAlloc(*Buf, dwSize, LMEM_MOVEABLE);
        if (newBuf) {
            *Buf = newBuf;
        } else {
            status = GetLastError();
        }
    }
    WppDebug(4, ("(%x (%d), %d)\n", *Buf, WPP_BUF_SIZE(*Buf), status) );
    return status; 
}

WPPINIT_STATIC 
DWORD WppRegQueryGuid(
    IN HKEY       hKey,
    IN LPCWSTR    ValueName,
    OUT LPGUID    pGuid
    )
{
    WCHAR GuidTxt[WPP_TEXTGUID_LEN];
    DWORD status;
    DWORD dwLen = sizeof(GuidTxt);
    DWORD Type;

    status = RegQueryValueExW(
        hKey,         // handle to key
        ValueName,    // value name
        0,            // reserved
        &Type,        // type buffer
        (LPBYTE)GuidTxt,  // data buffer // 
        &dwLen    // size of data buffer
        );

    if (status != ERROR_SUCCESS || Type != REG_SZ || dwLen < 35) {
        return status;
    }

    WppGuidFromStr(GuidTxt, pGuid);

    return status;        
}

WPPINIT_STATIC 
DWORD WppRegQueryDword(
    IN HKEY       hKey,
    IN LPCWSTR     ValueName,
    IN DWORD Default,
    IN DWORD MinVal,
    IN DWORD MaxVal
    )
{
    DWORD Result = Default;
    DWORD dwLen = sizeof(DWORD);

    RegQueryValueExW(hKey, ValueName, 
        0, NULL,  // lpReserved, lpType, 
        (LPBYTE)&Result, &dwLen);

    if (Result < MinVal || Result > MaxVal) {
        Result = Default;
    }

    return Result;        
}

WPPINIT_STATIC 
DWORD WppRegQueryString(
    IN HKEY       hKey,
    IN LPCWSTR     ValueName,
    IN OUT PWCHAR *Buf,
    IN DWORD ExtraPadding // Add this amount whenever we need to alloc more memory
    )
{
    DWORD ExpandSize;
    DWORD BufSize;
    DWORD ValueSize = WPP_BUF_SIZE(*Buf);
    DWORD status;
    DWORD Type = 0;

    status = RegQueryValueExW(
        hKey,         // handle to key
        ValueName,    // value name
        0,            // reserved
        &Type,        // type buffer
        (LPBYTE)(ValueSize?*Buf:ValueName), // data buffer // 
        &ValueSize    // size of data buffer
        );
    if (status == ERROR_MORE_DATA) {
        if (Type == REG_EXPAND_SZ) {
            ExtraPadding += ValueSize + 100; // Room for ExpandEnvStrings
        }
        status = WppGrowBuf(Buf, ValueSize + ExtraPadding);
        if (status != ERROR_SUCCESS) {
            return status;
        }
        status = RegQueryValueExW(
            hKey,       // handle to key
            ValueName,  // value name
            0,          // reserved
            &Type,      // type buffer
            (LPBYTE)*Buf,       // data buffer
            &ValueSize  // size of data buffer
            );
    }
    if (status != ERROR_SUCCESS) {
        return status;
    }
    if (Type == REG_SZ) {
        return ERROR_SUCCESS;
    }
    if (Type != REG_EXPAND_SZ) {
        return ERROR_DATATYPE_MISMATCH;
    }
    if (wcschr(*Buf, '%') == 0) {
        // nothing to expand
        return ERROR_SUCCESS;
    }
    BufSize = (ULONG)LocalSize(*Buf);
    ExpandSize = sizeof(WCHAR) * ExpandEnvironmentStringsW(
        *Buf, (LPWSTR)((LPBYTE)*Buf + ValueSize), (BufSize - ValueSize) / sizeof(WCHAR) ) ;
    if (ExpandSize + ValueSize > BufSize) {
        status = WppGrowBuf(Buf, ExpandSize + max(ExpandSize, ValueSize) + ExtraPadding );
        if (status != ERROR_SUCCESS) {
            return status;
        }
        ExpandSize = ExpandEnvironmentStringsW(*Buf, (LPWSTR)((LPBYTE)*Buf + ValueSize), ExpandSize / sizeof(WCHAR));
    }
    if (ExpandSize == 0) {
        return GetLastError();
    }
    // Copy expanded string on top of the original one
    MoveMemory(*Buf, (LPBYTE)*Buf + ValueSize, ExpandSize); 
    return ERROR_SUCCESS;
}

WPPINIT_STATIC 
void
WppSetExt(LPWSTR buf, int i)
{
    buf[0] = '.';
    buf[4] = 0;
    buf[3] = (WCHAR)('0' + i % 10); i = i / 10;
    buf[2] = (WCHAR)('0' + i % 10); i = i / 10;
    buf[1] = (WCHAR)('0' + i % 10); 
}

#if !defined(WPP_DEFAULT_LOGGER_FLAGS)
#  define WPP_DEFAULT_LOGGER_FLAGS (EVENT_TRACE_FILE_MODE_CIRCULAR | EVENT_TRACE_USE_GLOBAL_SEQUENCE)
#endif

// A set of buffers used by an autostart
// Buffers are reused between iterations and recursive invocations
// to minimize number of allocations

typedef struct _WPP_AUTO_START_BUFFERS {
    PWCHAR LogSessionName;
    PWCHAR Buf;
} WPP_AUTO_START_BUFFERS, *PWPP_AUTO_START_BUFFERS;

WPPINIT_STATIC 
DWORD
WppReadLoggerInfo(
    IN HKEY          LoggerKey, 
    IN OUT PWPP_AUTO_START_BUFFERS x, 
    OUT TRACEHANDLE* Logger)
{
    DWORD status;
    PEVENT_TRACE_PROPERTIES Trace;
    DWORD len, sessionNameLen;

    DWORD MaxBackups = 0;
    DWORD ExtraPadding; // add this amount when we need to allocate

    status = WppRegQueryString(LoggerKey, L"LogSessionName", &x->LogSessionName, 0);
            
    if (status != ERROR_SUCCESS) {
        // this registry node doesn't contain a logger
        return status;
    }

    sessionNameLen = wcslen(x->LogSessionName);
    *Logger = WppQueryLogger(x->LogSessionName);

    if (*Logger) {
        WppDebug(1,("[WppInit] Logger %ls is already running\n", x->LogSessionName) );
        return ERROR_SUCCESS;
    }

    // The TraceProperties property buffer that we need to give to StartTrace
    // should be of size EVENT_TRACE_PROPERTIES + len(sessionName) + len(logFileName)
    // However, we don't know the length of logFileName at the moment. To eliminate
    // extra allocations we will add ExtraPadding to an any allocation, so that the final
    // buffer will be of required size

    ExtraPadding = sizeof(EVENT_TRACE_PROPERTIES) + (sessionNameLen + 1) * sizeof(WCHAR);

    status = WppRegQueryString(LoggerKey, L"LogFileName", &x->Buf, ExtraPadding);
    if (status != ERROR_SUCCESS) {
        WppDebug(1,("[WppInit] Read %ls\\LogFileName failed, %d\n", x->LogSessionName, status) );
        return status;
    }
    len = wcslen(x->Buf);

    MaxBackups = WppRegQueryDword(LoggerKey, L"MaxBackups", 0, 0, 999);

    if (MaxBackups) {
        int i, success;
        LPWSTR FromExt, ToExt, From, To;
        // Copy current.evm => current.evm.001, 001 => 002, etc

        // MakeSure, Buffer is big enought for two file names + .000 extensions
        status = WppGrowBuf(&x->Buf, (len + 5) * 2 * sizeof(WCHAR) + ExtraPadding); // .xxx\0 (5)
        if (status != ERROR_SUCCESS) {
            return status;
        }

        From = x->Buf;                // MyFileName.evm      MyFileName.evm.001
        FromExt = From + len ;      // ^             ^     ^             ^
        To = FromExt + 5; // .xxx0  // From          Ext1  To            Ext2
        ToExt = To + len;

        memcpy(To, From, (len + 1) * sizeof(WCHAR) );
        
        for (i = MaxBackups; i >= 1; --i) {
            WppSetExt(ToExt, i); 
            if (i == 1) {
                *FromExt = 0; // remove extension
            } else {
                WppSetExt(FromExt, i-1);
            }
            success = MoveFileExW(From, To, MOVEFILE_REPLACE_EXISTING);
            if (!success) {
                status = GetLastError();
            } else {
                status = ERROR_SUCCESS;
            }
            WppDebug(3, ("[WppInit] Rename %ls => %ls, status %d\n", 
                From, To, status) );
        }
    }

    status = WppGrowBuf(&x->Buf, ExtraPadding + (len + 1) * sizeof(WCHAR) );
    if (status != ERROR_SUCCESS) {
        return status;
    }
    MoveMemory((LPBYTE)x->Buf + sizeof(EVENT_TRACE_PROPERTIES), x->Buf, (len + 1) * sizeof(WCHAR) ); // Free room for the header

    Trace = (PEVENT_TRACE_PROPERTIES)x->Buf;
    ZeroMemory(Trace, sizeof(EVENT_TRACE_PROPERTIES) );

    Trace->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES) + (len + sessionNameLen + 2) * sizeof(WCHAR);
    Trace->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

    Trace->BufferSize      = WppRegQueryDword(LoggerKey, L"BufferSize",      0, 0, ~0u);
    Trace->MinimumBuffers  = WppRegQueryDword(LoggerKey, L"MinimumBuffers",  0, 0, ~0u);
    Trace->MaximumBuffers  = WppRegQueryDword(LoggerKey, L"MaximumBuffers",  0, 0, ~0u);
    Trace->MaximumFileSize = WppRegQueryDword(LoggerKey, L"MaximumFileSize", 0, 0, ~0u);
    Trace->LogFileMode     = WppRegQueryDword(LoggerKey, L"LogFileMode", WPP_DEFAULT_LOGGER_FLAGS, 0, ~0u);
    Trace->FlushTimer      = WppRegQueryDword(LoggerKey, L"FlushTimer",  0, 0, ~0u);
    Trace->EnableFlags     = WppRegQueryDword(LoggerKey, L"EnableFlags", 0, 0, ~0u);
    Trace->AgeLimit        = WppRegQueryDword(LoggerKey, L"AgeLimit",    0, 0, ~0u);

    Trace->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    Trace->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (len + 1) * sizeof(WCHAR);

    wcscpy((LPWSTR)((LPBYTE)x->Buf + Trace->LoggerNameOffset), x->LogSessionName);

    status = StartTraceW(Logger, x->LogSessionName, Trace);
    WppDebug(1, ("[WppInit] Logger %ls started %x:%x %d\n", x->LogSessionName, *Logger, status) );
        
    return status;
}

typedef struct _WPP_INHERITED_DATA {
    TRACEHANDLE Logger;
    ULONG ControlFlags;
    ULONG ControlLevel;
} WPP_INHERITED_DATA, *PWPP_INHERITED_DATA;

WPPINIT_STATIC
ULONG
WppAutoStartInternal(
    IN HKEY Dir OPTIONAL, // if 0, use TracingKey ...
    IN LPCWSTR ProductName, 
    IN PWPP_INHERITED_DATA InheritedData OPTIONAL,
    IN OUT PWPP_AUTO_START_BUFFERS x // to minimize data allocations, the buffers are reused
    )
{
    ULONG status;
    WPP_INHERITED_DATA data;
    HKEY CloseMe = 0;
    HKEY hk      = 0;
    DWORD dwSizeOfModuleName;
    DWORD dwIndex;
    GUID  Guid;

    WppDebug(2, ("[WppInit] Init %ls\n", ProductName) );

    if (InheritedData) {
        data = *InheritedData;
    } else {
        ZeroMemory(&data, sizeof(data));
    }

    if (!Dir) {
        status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, WPP_REG_TRACE_REGKEY, 0, KEY_READ, &Dir);
        if (status != ERROR_SUCCESS) {
            WppDebug(1, ("[WppInit] Failed to open Trace Key, %d\n", status) );
            goto exit_gracefully;
        }
        CloseMe = Dir;
        if (WppRegQueryDword(Dir, L"NoAutoStart", 0, 0, 1) == 1) {
            WppDebug(1, ("[WppInit] Auto-start vetoed\n") );
            goto exit_gracefully;
        }
    }

    status = RegOpenKeyExW(Dir, ProductName, 0, KEY_READ, &hk);
    if (status != ERROR_SUCCESS) {
        WppDebug(1, ("[WppInit] Failed to open %ls subkey, %d\n", ProductName, status) );
        goto exit_gracefully;
    }

    if (WppRegQueryDword(Dir, L"Active", 1, 0, 1) == 0) {
        WppDebug(1, ("[WppInit] Tracing is not active for %ls\n", ProductName) );
    	goto exit_gracefully;
    }

    WppReadLoggerInfo(hk, x, &data.Logger);

    data.ControlLevel = WppRegQueryDword(hk, L"ControlLevel", data.ControlLevel, 0, ~0u);
    data.ControlFlags = WppRegQueryDword(hk, L"ControlFlags", data.ControlFlags, 0, ~0u);

    if (WppRegQueryGuid(hk, L"Guid", &Guid) == ERROR_SUCCESS) {

        // We can try to start tracing //
        if (data.Logger) {
            status = EnableTrace(1, data.ControlFlags, data.ControlLevel,
                                 &Guid, data.Logger);
            WppDebug(1, ("[WppInit] Enable %ls, status %d\n", ProductName, status) );
        }
    }

    dwSizeOfModuleName = WPP_BUF_SIZE(x->Buf);
    dwIndex = 0;
    while (ERROR_SUCCESS == (status = RegEnumKeyExW(hk, dwIndex, 
                                                   x->Buf, &dwSizeOfModuleName,
                                                   NULL, NULL, NULL, NULL)))
    {
        status = WppAutoStartInternal(hk, x->Buf, &data, x);

        dwSizeOfModuleName = WPP_BUF_SIZE(x->Buf);
        ++dwIndex;
    }

    if (ERROR_NO_MORE_ITEMS == status) {
        status = ERROR_SUCCESS;
    }

exit_gracefully:
    if (CloseMe) {
        RegCloseKey(CloseMe);
    }
    if (hk) {
        RegCloseKey(hk);
    }
    return status;
}

ULONG
WppAutoStart(
    IN LPCWSTR ProductName
    )
{
    WPP_AUTO_START_BUFFERS x;
    ULONG status;
    x.LogSessionName = 0;
    x.Buf = 0;

    if (ProductName == NULL) {
        return ERROR_SUCCESS;
    }

    if( WppGrowBuf(&x.Buf, 1024) == ERROR_SUCCESS && 
        WppGrowBuf(&x.LogSessionName, 64) == ERROR_SUCCESS ) 
    {

        WppDebug(1, ("[WppInit] Initialize %ls\n", ProductName) );
        status = WppAutoStartInternal(0, ProductName, 0, &x);

    } else {
        WppDebug(1, ("[WppInit] Allocation failure\n") );
        status = ERROR_OUTOFMEMORY;
    }

    LocalFree(x.Buf);
    LocalFree(x.LogSessionName);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cxpnp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxpnp.c

Abstract:

    PnP handling code for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           March 21, 1998

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     03-22-98    created

Notes:

--*/

#include "precomp.h"

#include <ntddk.h>
#include <wmistr.h>
#include <ndisguid.h>
#include <ntddndis.h>
#include <ntpnpapi.h>
#include <zwapi.h>

#pragma hdrstop
#include "cxpnp.tmh"

//
// Local data structures
//
typedef struct _CNP_WMI_RECONNECT_WORKER_CONTEXT {
    PIO_WORKITEM  WorkItem;
    CL_NETWORK_ID NetworkId;
} CNP_WMI_RECONNECT_WORKER_CONTEXT, *PCNP_WMI_RECONNECT_WORKER_CONTEXT;

//
// WMI Data
//
PERESOURCE CnpWmiNdisMediaStatusResource = NULL;
PVOID      CnpWmiNdisMediaStatusConnectObject = NULL;
PVOID      CnpWmiNdisMediaStatusDisconnectObject = NULL;
HANDLE     CnpIpMediaSenseFileHandle = NULL;
PIRP       CnpIpDisableMediaSenseIrp = NULL;
PKEVENT    CnpIpDisableMediaSenseEvent = NULL;


//
// Local prototypes
//
NTSTATUS
CnpWmiPnpDisableMediaSenseCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

VOID
CnpWmiNdisMediaStatusConnectCallback(
    IN PVOID             Wnode,
    IN PVOID             Context
    );

VOID
CnpWmiNdisMediaStatusDisconnectCallback(
    IN PVOID             Wnode,
    IN PVOID             Context
    );

VOID
CnpReconnectLocalInterfaceWrapper(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

VOID
CnpDisconnectLocalInterface(
    PCNP_INTERFACE Interface,
    PCNP_NETWORK   Network
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CxWmiPnpLoad)
#pragma alloc_text(PAGE, CxWmiPnpUnload)
#pragma alloc_text(PAGE, CxWmiPnpInitialize)
#pragma alloc_text(PAGE, CxWmiPnpShutdown)

#endif // ALLOC_PRAGMA


//
// Exported Routines
//
VOID
CxTdiAddAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    )
{
    if (TaAddress->AddressType == TDI_ADDRESS_TYPE_IP) {
        NTSTATUS          status;
        PTDI_ADDRESS_IP   tdiAddressIp = (PTDI_ADDRESS_IP)
                                         &(TaAddress->Address[0]);


        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CX] Processing PnP add event for IP address %lx\n",
                tdiAddressIp->in_addr
                ));
        }

        //
        // Ensure that this is a valid address, and that it is not one
        // that we brought online for a cluster ip address resource.
        //
        if (tdiAddressIp->in_addr != 0) {
            if (!IpaIsAddressRegistered(tdiAddressIp->in_addr)) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CX] Issuing address add event to cluster svc for IP address %lx\n",
                        tdiAddressIp->in_addr
                        ));
                }
                CnIssueEvent(
                    ClusnetEventAddAddress,
                    0,
                    (CL_NETWORK_ID) tdiAddressIp->in_addr
                    );
            }
            else {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CX] PnP add event is for an IP address resource, skip.\n"
                        ));
                }
            }
        }
    }

    return;

} // CxTdiAddAddressHandler


VOID
CxTdiDelAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    )
{


    if (TaAddress->AddressType == TDI_ADDRESS_TYPE_IP) {
        NTSTATUS           status;
        PCNP_INTERFACE     interface;
        PCNP_NETWORK       network;
        PLIST_ENTRY        entry;
        PTA_IP_ADDRESS     taIpAddress;
        CN_IRQL            nodeTableIrql;
        CL_NODE_ID         i;
        PTDI_ADDRESS_IP    tdiAddressIp = (PTDI_ADDRESS_IP)
                                          &(TaAddress->Address[0]);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CX] Processing PnP delete event for IP address %lx.\n",
                tdiAddressIp->in_addr
                ));
        }

        if (tdiAddressIp->in_addr != 0) {
            //
            // Figure out if this is the address for one of this node's
            // registered interfaces.
            //
            CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

            if (CnpLocalNode != NULL) {
                CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
                CnReleaseLockFromDpc(&CnpNodeTableLock);
                CnpLocalNode->Irql = nodeTableIrql;

                network = NULL;

                for (entry = CnpLocalNode->InterfaceList.Flink;
                     entry != &(CnpLocalNode->InterfaceList);
                     entry = entry->Flink
                    )
                {
                    interface = CONTAINING_RECORD(
                                    entry,
                                    CNP_INTERFACE,
                                    NodeLinkage
                                    );

                    taIpAddress = (PTA_IP_ADDRESS) &(interface->TdiAddress);

                    if (taIpAddress->Address[0].Address[0].in_addr ==
                        tdiAddressIp->in_addr
                       )
                    {
                        //
                        // Found the local interface corresponding to this
                        // address. Be proactive - destroy the corresponding
                        // network now.
                        //
                        network = interface->Network;

                        CnAcquireLockAtDpc(&CnpNetworkListLock);
                        CnAcquireLockAtDpc(&(network->Lock));
                        CnReleaseLockFromDpc(&(CnpLocalNode->Lock));
                        network->Irql = DISPATCH_LEVEL;

                        IF_CNDBG(CN_DEBUG_CONFIG) {
                            CNPRINT((
                                "[CX] Deleting network ID %u after PnP "
                                "delete event for IP address %lx.\n",
                                network->Id, tdiAddressIp->in_addr
                                ));
                        }

                        CnpDeleteNetwork(network, nodeTableIrql);

                        //
                        // Both locks were released.
                        //
                        break;
                    }
                }

                if (network == NULL) {
                    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
                }

                //
                // Post an event to the service.
                //
                CnIssueEvent(
                    ClusnetEventDelAddress,
                    0,
                    (CL_NETWORK_ID) tdiAddressIp->in_addr
                    );
            }
            else {
                CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
            }
        }
    }

    return;

} // CxTdiDelAddressHandler

NTSTATUS
CxWmiPnpLoad(
    VOID
    )
/*++

Notes:

    Called when clusnet driver is loaded.
    
--*/    
{
    PDEVICE_OBJECT     ipDeviceObject = NULL;
    PFILE_OBJECT       ipFileObject = NULL;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS           status;

    //
    // Allocate a synchronization resource.
    //
    CnpWmiNdisMediaStatusResource = CnAllocatePool(sizeof(ERESOURCE));

    if (CnpWmiNdisMediaStatusResource == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = ExInitializeResourceLite(CnpWmiNdisMediaStatusResource);

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    //
    // Get a handle to the IP device object to disable media sense
    //
    status = CnpOpenDevice(
                 DD_IP_DEVICE_NAME,
                 &CnpIpMediaSenseFileHandle
                 );
    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CX] Failed to open IP device to "
                     "disable media sense, status %lx\n", 
                     status));
        }
        return(status);
    }

    //
    // Disable IP media sense. This works by submitting an
    // IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST IRP. The IRP
    // will pend until we cancel it (re-enabling media sense).
    //
    CnpIpDisableMediaSenseEvent = CnAllocatePool(sizeof(KEVENT));

    if (CnpIpDisableMediaSenseEvent != NULL) {

        KeInitializeEvent(
            CnpIpDisableMediaSenseEvent,
            SynchronizationEvent,
            FALSE
            );

        //
        // Reference the IP file object and get the device object
        //
        status = ObReferenceObjectByHandle(
                     CnpIpMediaSenseFileHandle,
                     0,
                     NULL,
                     KernelMode,
                     &ipFileObject,
                     NULL
                     );

        if (NT_SUCCESS(status)) {

            ipDeviceObject = IoGetRelatedDeviceObject(ipFileObject);

            //
            // File object reference is no longer needed
            // because the handle is still open.
            //
            ObDereferenceObject(ipFileObject);

            CnpIpDisableMediaSenseIrp = IoAllocateIrp(
                                            ipDeviceObject->StackSize,
                                            FALSE
                                            );

            if (CnpIpDisableMediaSenseIrp != NULL) {

                irpSp = IoGetNextIrpStackLocation(CnpIpDisableMediaSenseIrp);

                irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                irpSp->Parameters.DeviceIoControl.IoControlCode
                    = IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST;
                irpSp->DeviceObject = ipDeviceObject;
                irpSp->FileObject = ipFileObject;

                IoSetCompletionRoutine(
                    CnpIpDisableMediaSenseIrp,
                    CnpWmiPnpDisableMediaSenseCompletion,
                    NULL,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                status = IoCallDriver(
                             ipDeviceObject, 
                             CnpIpDisableMediaSenseIrp
                             );

                if (status != STATUS_PENDING) {
                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT(("[CX] Failed to disable IP media "
                                 "sense, status %lx\n", status));
                    }
                    KeWaitForSingleObject(
                        CnpIpDisableMediaSenseEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
                    CnFreePool(CnpIpDisableMediaSenseEvent);
                    CnpIpDisableMediaSenseEvent = NULL;
                    IoFreeIrp(CnpIpDisableMediaSenseIrp);
                    CnpIpDisableMediaSenseIrp = NULL;

                    //
                    // Cannot risk simply returning status
                    // because we need the driver load to
                    // fail.
                    //
                    if (NT_SUCCESS(status)) {
                        status = STATUS_UNSUCCESSFUL;
                    }

                } else {

                    //
                    // Need to return STATUS_SUCCESS so that
                    // the driver load will not fail.
                    //
                    status = STATUS_SUCCESS;

                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT(("[CX] IP media sense disabled.\n"));
                    }

                    CnTrace(
                        CXPNP, CxWmiPnpIPMediaSenseDisabled,
                        "[CXPNP] IP media sense disabled.\n"
                        );
                }

            } else {

                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT(("[CX] Failed to allocate IP media sense "
                             "disable IRP.\n"));
                }
                CnFreePool(CnpIpDisableMediaSenseEvent);
                CnpIpDisableMediaSenseEvent = NULL;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[CX] Failed to reference IP device "
                         "file handle, status %lx\n", status));
            }
            CnFreePool(CnpIpDisableMediaSenseEvent);
            CnpIpDisableMediaSenseEvent = NULL;
        }

    } else {

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CX] Failed to allocate IP media sense "
                     "disable event.\n"));
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);

}  // CxWmiPnpLoad


VOID
CxWmiPnpUnload(
    VOID
    )
/*++

Notes:

    Called when clusnet driver is unloaded.
    
--*/    
{
    CnAssert(CnpWmiNdisMediaStatusConnectObject == NULL);
    CnAssert(CnpWmiNdisMediaStatusDisconnectObject == NULL);

    //
    // Re-enable IP media sense. This works by cancelling our
    // IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST IRP, which should
    // still be pending.
    //
    if (CnpIpDisableMediaSenseIrp != NULL) {
        
        if (!IoCancelIrp(CnpIpDisableMediaSenseIrp)) {

            //
            // Our disable media sense IRP could not be cancelled. This
            // probably means that it was completed because somebody
            // else submitted a media sense enable request. 
            //
            CnTrace(
                CXPNP, CnpWmiPnpDisableMediaSenseCompletionUnexpected,
                "[CXPNP] IP media sense re-enabled unexpectedly.\n"
                );

        } else {

            //
            // Irp was cancelled, and media sense is disabled as
            // expected.
            //
            CnTrace(
                CXPNP, CnpWmiPnpDisableMediaSenseCompletion,
                "[CXPNP] IP media sense re-enabled.\n"
                );
        }

        //
        // Regardless of who re-enabled media sense, we need to free
        // the media sense IRP and event. First we wait on the event,
        // which is signalled in our completion routine.
        //
        KeWaitForSingleObject(
            CnpIpDisableMediaSenseEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        CnFreePool(CnpIpDisableMediaSenseEvent);
        CnpIpDisableMediaSenseEvent = NULL;

        IoFreeIrp(CnpIpDisableMediaSenseIrp);
        CnpIpDisableMediaSenseIrp = NULL;
    } 

    CnAssert(CnpIpDisableMediaSenseIrp == NULL);

    if (CnpIpMediaSenseFileHandle != NULL) {
        ZwClose(CnpIpMediaSenseFileHandle);
        CnpIpMediaSenseFileHandle = NULL;
    }

    if (CnpWmiNdisMediaStatusResource != NULL) {
        ExDeleteResourceLite(CnpWmiNdisMediaStatusResource);
        CnFreePool(CnpWmiNdisMediaStatusResource); 
        CnpWmiNdisMediaStatusResource = NULL;
    }

}  // CxWmiPnpUnload


NTSTATUS
CxWmiPnpInitialize(
    VOID
    )
/*++

Notes:

    Called in response to initialize ioctl.
    
--*/
{
    NTSTATUS           status = STATUS_SUCCESS;
    BOOLEAN            acquired = FALSE;
    GUID               wmiGuid;

    PAGED_CODE();

    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    //
    // Register WMI callbacks for NDIS media status events
    //

    if (CnpWmiNdisMediaStatusConnectObject == NULL) {

        wmiGuid = GUID_NDIS_STATUS_MEDIA_CONNECT;
        status = IoWMIOpenBlock(
                     &wmiGuid,
                     WMIGUID_NOTIFICATION,
                     &CnpWmiNdisMediaStatusConnectObject
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to open WMI NDIS status media connect "
                "datablock, status %lx\n",
                status
                ));
            CnpWmiNdisMediaStatusConnectObject = NULL;
            goto error_exit;
        }

        status = IoWMISetNotificationCallback(
                     CnpWmiNdisMediaStatusConnectObject,
                     CnpWmiNdisMediaStatusConnectCallback,
                     NULL
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to register WMI NDIS status media connect "
                "callback, status %lx\n",
                status
                ));
            goto error_exit;
        }

    }

    if (CnpWmiNdisMediaStatusDisconnectObject == NULL) {

        wmiGuid = GUID_NDIS_STATUS_MEDIA_DISCONNECT;
        status = IoWMIOpenBlock(
                     &wmiGuid,
                     WMIGUID_NOTIFICATION,
                     &CnpWmiNdisMediaStatusDisconnectObject
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to open WMI NDIS status media disconnect "
                "datablock, status %lx\n",
                status
                ));
            CnpWmiNdisMediaStatusDisconnectObject = NULL;
            goto error_exit;
        }

        status = IoWMISetNotificationCallback(
                     CnpWmiNdisMediaStatusDisconnectObject,
                     CnpWmiNdisMediaStatusDisconnectCallback,
                     NULL
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to register WMI NDIS status media disconnect "
                "callback, status %lx\n",
                status
                ));
            goto error_exit;
        }
    }

    goto release_exit;

error_exit:
    
    if (CnpWmiNdisMediaStatusConnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusConnectObject);
        CnpWmiNdisMediaStatusConnectObject = NULL;
    }

    if (CnpWmiNdisMediaStatusDisconnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusDisconnectObject);
        CnpWmiNdisMediaStatusDisconnectObject = NULL;
    }

release_exit:
    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }

    return(status);
    
}  // CxWmiPnpInitialize


VOID
CxWmiPnpShutdown(
    VOID
    )
/*++

Notes:

    Called in response to clusnet shutdown.
    
--*/
{
    BOOLEAN  acquired = FALSE;

    PAGED_CODE();

    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    if (CnpWmiNdisMediaStatusConnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusConnectObject);
        CnpWmiNdisMediaStatusConnectObject = NULL;
    }

    if (CnpWmiNdisMediaStatusDisconnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusDisconnectObject);
        CnpWmiNdisMediaStatusDisconnectObject = NULL;
    }

    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    return;

}  // CxWmiPnpShutdown


VOID
CxReconnectLocalInterface(
    IN CL_NETWORK_ID NetworkId
    )
/**

Routine Description:

    Queues a worker thread to set the local interface
    associated with NetworkId to connected. Called when
    a heartbeat is received over a network that is marked
    locally disconnected.
    
Arguments:

    NetworkId - network ID of network to be reconnected
    
Return value:

    None
    
Notes:

    Can fail without reporting an error if either
    allocation fails.

--*/
{
    PCNP_WMI_RECONNECT_WORKER_CONTEXT context;
    
    context = CnAllocatePool(sizeof(CNP_WMI_RECONNECT_WORKER_CONTEXT));

    if (context != NULL) {
        
        context->WorkItem = IoAllocateWorkItem(CnDeviceObject);

        if (context->WorkItem != NULL) {

            context->NetworkId = NetworkId;

            CnTrace(
                CXPNP, CxReconnectLocalInterface,
                "[CXPNP] Queueing worker thread to reconnect local "
                "interface for network ID %u.\n",
                NetworkId // LOGULONG
                );

            IoQueueWorkItem(
                context->WorkItem, 
                CnpReconnectLocalInterfaceWrapper, 
                DelayedWorkQueue,
                context
                );
        
        } else {

            CnFreePool(context);
        }
    }

    return;
}


VOID
CxQueryMediaStatus(
    IN  HANDLE            AdapterDeviceHandle,
    IN  CL_NETWORK_ID     NetworkId,
    OUT PULONG            MediaStatus
    )
/**

Routine Description:

    Queries the status of the adapter device. Used to 
    determine whether a local interface is initially
    connected or disconnected.

Arguments:

    AdapterHandle - adapter device object handle
    NetworkId - network ID of adapter to be queried
    
Return value:

    None
    
Notes:

    NDIS query formation modeled after ndis\lib\ndisapi.c

--*/
{
    BOOLEAN                      acquired = FALSE;
    NTSTATUS                     status;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    //
    // Set default
    //
    *MediaStatus = NdisMediaStateDisconnected;

    //
    // Acquire resource
    //
    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    if (AdapterDeviceHandle != NULL) {
        
        //
        // Construct NDIS statistics query
        //
        
        NDIS_OID statsOidList[] =
        {
            OID_GEN_MEDIA_CONNECT_STATUS // | NDIS_OID_PRIVATE
        };
        UCHAR                  statsBuf[
                                   FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data)
                                   + sizeof(LARGE_INTEGER)
                                   ];
        PNDIS_STATISTICS_VALUE pStatsBuf;
        LARGE_INTEGER          value;

        IF_CNDBG( CN_DEBUG_CONFIG ) {
            CNPRINT((
                "[CXPNP] Querying NDIS for local adapter "
                "on network %u (handle %p).\n",
                NetworkId,
                AdapterDeviceHandle
                ));
        }

        pStatsBuf = (PNDIS_STATISTICS_VALUE) &statsBuf[0];
        status = CnpZwDeviceControl(
                     AdapterDeviceHandle,
                     IOCTL_NDIS_QUERY_SELECTED_STATS,
                     statsOidList,
                     sizeof(statsOidList),
                     pStatsBuf,
                     sizeof(statsBuf)
                     );
        
        IF_CNDBG( CN_DEBUG_CONFIG ) {
            CNPRINT((
                "[CXPNP] NDIS query for local adapter "
                "on network %u returned status %lx.\n",
                NetworkId,
                status
                ));
        }

        if (pStatsBuf->DataLength == sizeof(LARGE_INTEGER)) {
            value.QuadPart = *(PULONGLONG)(&pStatsBuf->Data[0]);
        } else {
            value.LowPart = *(PULONG)(&pStatsBuf->Data[0]);
        }
        
        *MediaStatus = value.LowPart; // NdisMediaState{Disc|C}onnected
    
        IF_CNDBG( CN_DEBUG_CONFIG ) {
            CNPRINT((
                "[CXPNP] NDIS query for local adapter "
                "on network %u returned media status %lx.\n",
                NetworkId,
                *MediaStatus
                ));
        }

        CnTrace(
            CXPNP, CxQueryMediaStatus,
            "[CXPNP] Found media status %u for local network ID %u.\n",
            *MediaStatus, // LOGULONG
            NetworkId // LOGULONG
            );
    }

    //
    // If the media status is disconnected, we must disconnect the
    // local interface and network.
    //
    if (*MediaStatus == NdisMediaStateDisconnected) {

        PCNP_NETWORK                      network = NULL;
        PCNP_INTERFACE                    interface = NULL;
        CN_IRQL                           nodeTableIrql;
        PLIST_ENTRY                       entry;

        CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

        if (CnpLocalNode != NULL) {
            CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
            CnReleaseLockFromDpc(&CnpNodeTableLock);
            CnpLocalNode->Irql = nodeTableIrql;

            network = CnpFindNetwork(NetworkId);

            if (network != NULL) {

                //
                // Only go through the disconnect if the network
                // is currently marked as locally connected.
                // It is possible that we have already received
                // and processed a WMI disconnect event.
                //
                if (!CnpIsNetworkLocalDisconn(network)) {

                    for (entry = CnpLocalNode->InterfaceList.Flink;
                         entry != &(CnpLocalNode->InterfaceList);
                         entry = entry->Flink
                        )
                    {
                        interface = CONTAINING_RECORD(
                                        entry,
                                        CNP_INTERFACE,
                                        NodeLinkage
                                        );

                        if (interface->Network == network) {

                            CnpDisconnectLocalInterface(
                                interface,
                                network
                                );

                            //
                            // Both node and network locks
                            // were released.
                            //

                            break;

                        } else {
                            interface = NULL;
                        }
                    }

                } else {

                    CnTrace(
                        CXPNP, CxQueryMediaStatusDisconnectRedundant,
                        "[CXPNP] Network ID %u is already disconnected; "
                        "aborting disconnect.\n",
                        network->Id // LOGULONG
                        );
                }

                if (interface == NULL) {
                    CnReleaseLock(&(network->Lock), network->Irql);
                }
            }

            if (interface == NULL) {
                CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
            }
        } else {
            CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
        }
    }
    
    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CxQueryMediaStatus


//
// Local Routines
//
NTSTATUS
CnpWmiPnpDisableMediaSenseCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    //
    // Irp is always freed by our disable routine to prevent a race
    // condition where we don't know if we have called IoCancelIrp
    // yet or not.
    //
    KeSetEvent(CnpIpDisableMediaSenseEvent, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}  // CnpWmiPnpDisableMediaSenseCompletion


VOID
CnpWmiPnpUpdateCurrentInterface(
    IN  PCNP_INTERFACE   UpdateInterface
    )
/*++

Routine Description:

    Updates the CurrentInterface for interfaces after the local
    interface is connected or disconnected. Called in response 
    to WMI NDIS media status events.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE node = UpdateInterface->Node;

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    //
    // We don't really need the network lock.  It's just part of
    // the calling convention.
    //
    CnReleaseLockFromDpc(&(UpdateInterface->Network->Lock));

    CnpUpdateNodeCurrentInterface(node);

    if ( (node->CurrentInterface == NULL)
         ||
         ( node->CurrentInterface->State <
           ClusnetInterfaceStateOnlinePending
         )
       )
    {
        //
        // This node is now unreachable.
        //
        CnTrace(
            CXPNP, CxWmiPnpNodeUnreach,
            "[CXPNP] Declaring node %u unreachable after "
            "handling media sense event.\n",
            node->Id
            );
        
        CnpDeclareNodeUnreachable(node);
    
    } else {

        //
        // This node may now be reachable.
        //
        if (CnpIsNodeUnreachable(node)) {
            CnTrace(
                CXPNP,
                CxWmiPnpNodeReach,
                "[CNP] Declaring node %u reachable after "
                "handling media sense event.\n",
                node->Id
                );
            CnpDeclareNodeReachable(node);
        }
    }
    
    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpWmiPnpUpdateCurrentInterface


VOID
CnpReconnectLocalInterface(
    PCNP_INTERFACE Interface,
    PCNP_NETWORK   Network
    )
/*++

Routine Description:

    Changes a local interface from being disconnected to
    connected. Called in response to a WMI NDIS media status
    connect event or a heartbeat received on a disconnected
    interface.
   
Arguments:

    Interface - local interface that is reconnected
    
    Network - network associated with Interface
    
Return value:

    None
    
Notes:

    Called with CnpWmiNdisMediaStatusResource, local node lock,
    and Network lock held.
    
    Returns with CnpWmiNdisMediaStatusResource held but neither
    lock held.
    
--*/    
{
    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    CnTrace(
        CXPNP, CnpReconnectLocalInterface,
        "[CXPNP] Reconnecting local interface for "
        "network ID %u.\n",
        Network->Id // LOGULONG
        );

    //
    // Clear the local disconnect flag in the network
    // object
    //
    Network->Flags &= ~CNP_NET_FLAG_LOCALDISCONN;

    //
    // Reference the network so it can't go away while we
    // reprioritize the associated interfaces.
    //
    CnpReferenceNetwork(Network);

    //
    // Bring the interface online. This call releases the
    // network lock.
    //
    CnpOnlineInterface(Interface);

    //
    // Release the node lock before walking the interfaces
    // on the network.
    //
    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);

    //
    // Update the CurrentInterface for the other
    // nodes in the cluster to reflect the connected
    // status of the local interface.
    //
    CnpWalkInterfacesOnNetwork(
        Network, 
        CnpWmiPnpUpdateCurrentInterface
        );

    //
    // Issue InterfaceUp event to the cluster
    // service.
    //
    CnTrace(
        CXPNP, CxWmiNdisReconnectIssueEvent,
        "[CXPNP] Issuing InterfaceUp event "
        "for node %u on net %u, previous I/F state = %!ifstate!.",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State // LOGIfState
        );

    CnIssueEvent(
        ClusnetEventNetInterfaceUp,
        Interface->Node->Id,
        Interface->Network->Id
        );

    //
    // Release the reference on the network object.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    CnpDereferenceNetwork(Network);

    return;

}  // CnpReconnectLocalInterface

VOID
CnpReconnectLocalInterfaceWrapper(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
{
    PCNP_WMI_RECONNECT_WORKER_CONTEXT context = Context;
    PCNP_NETWORK                      network = NULL;
    PCNP_INTERFACE                    interface = NULL;
    CN_IRQL                           nodeTableIrql;
    BOOLEAN                           acquired = FALSE;
    PLIST_ENTRY                       entry;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

    if (CnpLocalNode != NULL) {
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = nodeTableIrql;

        network = CnpFindNetwork(context->NetworkId);
    
        if (network != NULL) {

            //
            // Only go through the reconnect if the network
            // is currently marked as locally disconnected.
            // It is possible that we have already received
            // and processed a WMI connect event.
            //
            if (CnpIsNetworkLocalDisconn(network)) {

                for (entry = CnpLocalNode->InterfaceList.Flink;
                     entry != &(CnpLocalNode->InterfaceList);
                     entry = entry->Flink
                    )
                {
                    interface = CONTAINING_RECORD(
                                    entry,
                                    CNP_INTERFACE,
                                    NodeLinkage
                                    );

                    if (interface->Network == network) {

                        CnpReconnectLocalInterface(
                            interface,
                            network
                            );

                        //
                        // Both node and network locks
                        // were released.
                        //

                        break;

                    } else {
                        interface = NULL;
                    }
                }
            
            } else {

                CnTrace(
                    CXPNP, CnpReconnectLocalInterfaceWrapperRedundant,
                    "[CXPNP] Network ID %u is already connected; "
                    "aborting reconnect in wrapper.\n",
                    network->Id // LOGULONG
                    );
            }

            if (interface == NULL) {
                CnReleaseLock(&(network->Lock), network->Irql);
            }
        }

        if (interface == NULL) {
            CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
        }
    } else {
        CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
    }
    
    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    //
    // Free the workitem and context
    //
    IoFreeWorkItem(context->WorkItem);
    CnFreePool(context);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpReconnectLocalInterfaceWrapper


VOID
CnpDisconnectLocalInterface(
    PCNP_INTERFACE Interface,
    PCNP_NETWORK   Network
    )
/*++

Routine Description:

    Changes a local interface from being connected to
    disconnected. Called in response to a WMI NDIS media status
    disconnect event or an NDIS query that returns media 
    disconnected.
   
Arguments:

    Interface - local interface that is reconnected
    
    Network - network associated with Interface
    
Return value:

    None
    
Notes:

    Called with CnpWmiNdisMediaStatusResource, local node lock,
    and Network lock held.
    
    Returns with CnpWmiNdisMediaStatusResource held but neither
    lock held.
    
--*/    
{
    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    CnTrace(
        CXPNP, CnpDisconnectLocalInterface,
        "[CXPNP] Interface for network ID %u "
        "disconnected.\n",
        Network->Id // LOGULONG
        );

    //
    // Set the local disconnect flag in the network
    // object
    //
    Network->Flags |= CNP_NET_FLAG_LOCALDISCONN;

    //
    // Reference the network so it can't go away while we
    // reprioritize the associated interfaces.
    //
    CnpReferenceNetwork(Network);

    //
    // Fail the interface. This call releases the
    // network lock.
    //
    CnpFailInterface(Interface);

    //
    // Release the node lock before walking the interfaces
    // on the network.
    //
    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);

    //
    // Update the CurrentInterface for the other
    // nodes in the cluster to reflect the disconnected
    // status of the local interface.
    //
    CnpWalkInterfacesOnNetwork(
        Network, 
        CnpWmiPnpUpdateCurrentInterface
        );

    //
    // Issue InterfaceFailed event to the cluster
    // service.
    //
    CnTrace(
        CXPNP, CnpLocalDisconnectIssueEvent,
        "[CXPNP] Issuing InterfaceFailed event "
        "for node %u on net %u, previous I/F state = %!ifstate!.",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State // LOGIfState
        );

    CnIssueEvent(
        ClusnetEventNetInterfaceFailed,
        Interface->Node->Id,
        Interface->Network->Id
        );

    //
    // Release the reference on the network object.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    CnpDereferenceNetwork(Network);

    return;

}  // CnpDisconnectLocalInterface


VOID
CnpWmiNdisMediaStatusConnectCallback(
    IN PVOID Wnode,
    IN PVOID Context
    )
{
    PWNODE_SINGLE_INSTANCE wnode = (PWNODE_SINGLE_INSTANCE) Wnode;
    PCNP_INTERFACE         interface;
    PCNP_NETWORK           network;
    PLIST_ENTRY            entry;
    CN_IRQL                nodeTableIrql;
    BOOLEAN                acquired = FALSE;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CX] Received WMI NDIS status media connect event.\n"
            ));
    }

    //
    // Serialize events as much as possible, since clusnet spinlocks
    // may be acquired and released repeatedly. 
    //
    // Note that there may not be any guarantees that WMI event
    // ordering is guaranteed. The fallback mechanism for clusnet
    // is heartbeats -- if a heartbeat is received on an interface,
    // we know the interface is connected.
    //
    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );

    CnAssert(acquired == TRUE);

    //
    // Figure out if this callback is for one of this node's
    // registered interfaces by comparing the WMI provider ID
    // in the WNODE header to the WMI provider IDs of this
    // node's adapters.
    //
    CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

    if (CnpLocalNode != NULL) {
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = nodeTableIrql;

        network = NULL;

        for (entry = CnpLocalNode->InterfaceList.Flink;
             entry != &(CnpLocalNode->InterfaceList);
             entry = entry->Flink
            )
        {
            interface = CONTAINING_RECORD(
                            entry,
                            CNP_INTERFACE,
                            NodeLinkage
                            );

            if (wnode->WnodeHeader.ProviderId
                == interface->AdapterWMIProviderId) {
                
                //
                // Found the local interface corresponding to this
                // address.
                //
                network = interface->Network;

                //
                // Start by checking if we believe the network is
                // currently disconnected.
                //
                CnAcquireLockAtDpc(&(network->Lock));
                network->Irql = DISPATCH_LEVEL;

                if (CnpIsNetworkLocalDisconn(network)) {

                    CnTrace(
                        CXPNP, CxWmiNdisConnectNet,
                        "[CXPNP] Interface for network ID %u "
                        "connected.\n",
                        network->Id // LOGULONG
                        );

                    CnpReconnectLocalInterface(interface, network);
                    
                    //
                    // Node and network locks were released
                    //

                } else {

                    CnTrace(
                        CXPNP, CxWmiNdisConnectNetRedundant,
                        "[CXPNP] Ignoring redundant WMI NDIS connect "
                        "event for interface for network ID %u.\n",
                        network->Id // LOGULONG
                        );
                    
                    CnReleaseLockFromDpc(&(network->Lock));
                    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
                }
                
                break;
            }
        }

        if (network == NULL) {
            CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
        }
    }
    else {
        CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
    }

    IF_CNDBG(CN_DEBUG_CONFIG) {
        if (network != NULL) {
            CNPRINT((
                "[CX] Interface for network ID %u connected.\n",
                network->Id
                ));
        } else {
            CNPRINT((
                "[CX] Unknown interface connected, provider id %lx\n",
                wnode->WnodeHeader.ProviderId
                ));
        }
    }

    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

} // CnpWmiNdisMediaStatusConnectCallback


VOID
CnpWmiNdisMediaStatusDisconnectCallback(
    IN PVOID Wnode,
    IN PVOID Context
    )
{
    PWNODE_SINGLE_INSTANCE wnode = (PWNODE_SINGLE_INSTANCE) Wnode;
    PCNP_INTERFACE         interface;
    PCNP_NETWORK           network;
    PLIST_ENTRY            entry;
    CN_IRQL                nodeTableIrql;
    BOOLEAN                acquired = FALSE;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CX] Received WMI NDIS status media disconnect event.\n"
            ));
    }

    CnTrace(CXPNP, CxWmiNdisDisconnect,
        "[CXPNP] Received WMI NDIS status media disconnect event.\n"
        );

    //
    // Serialize events as much as possible, since clusnet spinlocks
    // may be acquired and released repeatedly. 
    //
    // Note that there may not be any guarantees that WMI event
    // ordering is guaranteed. The fallback mechanism for clusnet
    // is heartbeats -- if a heartbeat is received on an interface,
    // we know the interface is connected.
    //
    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );

    CnAssert(acquired == TRUE);

    //
    // Figure out if this callback is for one of this node's
    // registered interfaces by comparing the WMI provider ID
    // in the WNODE header to the WMI provider IDs of this
    // node's adapters.
    //
    CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

    if (CnpLocalNode != NULL) {
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = nodeTableIrql;

        network = NULL;

        for (entry = CnpLocalNode->InterfaceList.Flink;
             entry != &(CnpLocalNode->InterfaceList);
             entry = entry->Flink
            )
        {
            interface = CONTAINING_RECORD(
                            entry,
                            CNP_INTERFACE,
                            NodeLinkage
                            );

            if (wnode->WnodeHeader.ProviderId
                == interface->AdapterWMIProviderId) {
                
                //
                // Found the local interface object corresponding
                // to this adapter.
                //
                network = interface->Network;

                CnAcquireLockAtDpc(&(network->Lock));
                network->Irql = DISPATCH_LEVEL;

                CnpDisconnectLocalInterface(interface, network);

                break;
            }
        }

        if (network == NULL) {
            CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
        }
    }
    else {
        CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
    }

    IF_CNDBG(CN_DEBUG_CONFIG) {
        if (network != NULL) {
            CNPRINT((
                "[CX] Interface for network ID %u disconnected.\n",
                network->Id
                ));
        } else {
            CNPRINT((
                "[CX] Unknown interface disconnected, provider id %lx\n",
                wnode->WnodeHeader.ProviderId
                ));
        }
    }

    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

} // CnpWmiNdisMediaStatusDisconnectCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cxinit.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxinit.c

Abstract:

    Initialization code for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#include "precomp.h"

#pragma hdrstop
#include "cxinit.tmh"

//
// Tdi Data
//
HANDLE  CxTdiRegistrationHandle = NULL;
HANDLE  CxTdiPnpBindingHandle = NULL;


//
// FIPS function table
//
HANDLE              CxFipsDriverHandle = NULL;
FIPS_FUNCTION_TABLE CxFipsFunctionTable;


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CxLoad)
#pragma alloc_text(PAGE, CxUnload)
#pragma alloc_text(PAGE, CxInitialize)
#pragma alloc_text(PAGE, CxShutdown)

#endif // ALLOC_PRAGMA


//
// Routines
//
NTSTATUS
CxLoad(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Driver load routine for the cluster transport. Initializes all
    transport data structures.

Arguments:

    RegistryPath   - The driver's registry key.

Return Value:

    An NT status code.

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              deviceName;
    TDI_CLIENT_INTERFACE_INFO   info;



    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Loading...\n"));
    }

    TdiInitialize();

    //
    // Register our device object with TDI.
    //
    RtlInitUnicodeString(&deviceName, DD_CDP_DEVICE_NAME);

    status = TdiRegisterDeviceObject(&deviceName, &CxTdiRegistrationHandle);

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[CX] Unable to register device %ws with TDI, status %lx\n",
            deviceName.Buffer,
            status
            ));
        return(status);
    }

    //
    // Register for PnP events.
    //
    RtlZeroMemory(&info, sizeof(info));

    info.MajorTdiVersion = 2;
    info.MinorTdiVersion = 0;
    info.ClientName = &deviceName;
    info.AddAddressHandlerV2 = CxTdiAddAddressHandler;
    info.DelAddressHandlerV2 = CxTdiDelAddressHandler;

    status = TdiRegisterPnPHandlers(
                 &info,
                 sizeof(info),
                 &CxTdiPnpBindingHandle
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[CX] Unable to register for TDI PnP events, status %lx\n",
            status
            ));
        return(status);
    }

    //
    // Register for WMI NDIS media status events.
    //
    status = CxWmiPnpLoad();
    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[CX] Failed to initialize WMI PnP event handlers, "
            "status %lx\n",
            status
            ));
    }

    //
    // Get the FIPS function table. Hold onto the FIPS driver
    // handle so that the FIPS driver cannot unload.
    //
    status = CnpOpenDevice(FIPS_DEVICE_NAME, &CxFipsDriverHandle);
    if (NT_SUCCESS(status)) {

        status = CnpZwDeviceControl(
                     CxFipsDriverHandle,
                     IOCTL_FIPS_GET_FUNCTION_TABLE,
                     NULL,
                     0,
                     &CxFipsFunctionTable,
                     sizeof(CxFipsFunctionTable)
                     );
        if (!NT_SUCCESS(status)) {
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[CNP] Failed to fill FIPS function "
                         "table, status %x.\n", status));
            }
        }

    } else {
        CxFipsDriverHandle = NULL;
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Failed to open FIPS device, "
                     "status %x.\n", status));
        }
    }
    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CnpLoadNodes();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CnpLoadNetworks();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CnpLoad();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CcmpLoad();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CxInitializeHeartBeat();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CdpLoad();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Loaded.\n"));
    }

    return(STATUS_SUCCESS);

} // CxLoad


VOID
CxUnload(
    VOID
    )

/*++

Routine Description:

    Called when the Cluster Network driver is unloading. Frees all resources
    allocated by the Cluster Transport.

    The Transport is guaranteed not to receive any more user-mode requests,
    membership send requests, or membership events at the time
    this routine is called.

    A shutdown of the Cluster Network driver has already occured when this
    routine is called.

Arguments:

    None.

Return Value:

    None

Notes:

    This routine MUST be callable even if CxLoad() has not yet been
    called.

--*/

{
    PAGED_CODE();


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Unloading...\n"));
    }

    CxUnreserveClusnetEndpoint();

    CdpUnload();

    CxUnloadHeartBeat();

    CcmpUnload();

    CnpUnload();

    CxWmiPnpUnload();

    if (CxFipsDriverHandle != NULL) {
        ZwClose(CxFipsDriverHandle);
        CxFipsDriverHandle = NULL;
    }

    if (CxTdiPnpBindingHandle != NULL) {
        TdiDeregisterPnPHandlers(CxTdiPnpBindingHandle);
        CxTdiPnpBindingHandle = NULL;
    }

    if (CxTdiRegistrationHandle != NULL) {
        TdiDeregisterDeviceObject(CxTdiRegistrationHandle);
        CxTdiRegistrationHandle = NULL;
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Unloaded.\n"));
    }

    return;

} // CxUnload



NTSTATUS
CxInitialize(
    VOID
    )
/*++

Routine Description:

    Initialization routine for the Cluster Transport.
    Called when the Membership Manager is starting up.
    Enables operation of the transport.

Arguments:

    None.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS   status;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Initializing...\n"));
    }

    EventEpoch = 0;
    CxMulticastEpoch = 0;

    //
    // Initialize our FIPS-seeded salt generator.
    //
    status = CnpInitializeSaltGenerator();
    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Failed to initialize FIPS-seeded "
                     "random number generator, status %x.\n", 
                     status));
        }
        return(status);
    }    

    status = CnpInitializeNodes();

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    status = CnpInitializeNetworks();

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    status = CxWmiPnpInitialize();

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Initialized...\n"));
    }

    return(STATUS_SUCCESS);

} // CxInitialize


VOID
CxShutdown(
    VOID
    )
/*++

Routine Description:

    Terminates operation of the Cluster Transport.
    Called when the Membership Manager is shutting down.

Arguments:

    None.

Return Value:

    None.

--*/
{

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Shutting down...\n"));
    }

    CnpStopHeartBeats();

    CxWmiPnpShutdown();

    CnpShutdownNetworks();

    CnpShutdownNodes();

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Shutdown complete...\n"));
    }

    return;

} // CxShutdown
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusnet\xport\cxp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cxp.h

Abstract:

    Common definitions for the Cluster Transport.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#ifndef _CXP_INCLUDED_
#define _CXP_INCLUDED_


#include <clusnet.h>
#include <ntddtcp.h>
#include <ntddndis.h>


//
// Tdi Definitions
//
//
// TDI Address Object
//
// This structure represents a cluster transport address opened by a
// TDI client. It is also used as an endpoint for datagram communication.
// One such structure exists for each port address opened on the local node.
//
// Address objects are stored in a bucket hash table. The table is
// hashed by port number.
//
typedef struct {
    CN_FSCONTEXT                        FsContext;
    LIST_ENTRY                          AOTableLinkage;
    CN_LOCK                             Lock;
    CN_IRQL                             Irql;
    ULONG                               Flags;
    USHORT                              LocalPort;
    LIST_ENTRY                          ReceiveQueue;
    PTDI_IND_ERROR                      ErrorHandler;
    PVOID                               ErrorContext;
    PTDI_IND_RECEIVE_DATAGRAM           ReceiveDatagramHandler;
    PVOID                               ReceiveDatagramContext;
    PTDI_IND_CHAINED_RECEIVE_DATAGRAM   ChainedReceiveDatagramHandler;
    PVOID                               ChainedReceiveDatagramContext;
} CX_ADDROBJ, *PCX_ADDROBJ;

#define CX_ADDROBJ_SIG    'rdda'

#define CX_ADDROBJ_TABLE_SIZE  7

#define CX_ADDROBJ_TABLE_HASH(_port)  \
            ((ULONG) ((_port) % CX_ADDROBJ_TABLE_SIZE))


#define CX_AO_FLAG_DELETING      0x00000001
#define CX_AO_FLAG_CHECKSTATE    0x00000002


extern LIST_ENTRY           CxAddrObjTable[CX_ADDROBJ_TABLE_SIZE];
extern CN_LOCK              CxAddrObjTableLock;

extern HANDLE               CxTdiRegistrationHandle;


//
// Packet header structures need to be packed.
//
#include <packon.h>

//
// CNP Header
//
typedef struct {
    UCHAR      Version;
    UCHAR      NextHeader;
    USHORT     PayloadLength;
    ULONG      SourceAddress;
    ULONG      DestinationAddress;
} CNP_HEADER, *PCNP_HEADER;

//
// CDP Header
//
typedef struct {
    USHORT   SourcePort;
    USHORT   DestinationPort;
    USHORT   PayloadLength;
    USHORT   Checksum;
} CDP_HEADER, *PCDP_HEADER;

//
// Node info structure for heartbeats.
//
typedef struct _CX_HB_NODE_INFO {
    ULONG    SeqNumber;
    ULONG    AckNumber;
} CX_HB_NODE_INFO, *PCX_HB_NODE_INFO;

//
// Multicast signature data.
//
typedef struct {
    UCHAR            Version;
    UCHAR            Reserved;
    USHORT           SigLength;
    CL_NETWORK_ID    NetworkId;
    ULONG            ClusterNetworkBrand;
    USHORT           SaltLength;
    UCHAR            SigDataBuffer[1]; // Dynamic: SigLength + SaltLength
} CNP_SIGNATURE, *PCNP_SIGNATURE;


#include <packoff.h>

//
// Protocol constants
//
#define CNP_VERSION_1     0x1     // original CNP
#define CNP_VERSION_2     0x2     // original CNP + multicast

#define CNP_VERSION_UNICAST       CNP_VERSION_1
#define CNP_VERSION_MULTICAST     CNP_VERSION_2

#define PROTOCOL_CCMP     1
#define PROTOCOL_CDP      2

#define CNP_SIG_VERSION_1 0x1

//
// Size of CNP multicast signature data.
//
#define CNP_SIGHDR_LENGTH                                    \
    (FIELD_OFFSET(CNP_SIGNATURE, SigDataBuffer[0]))
    
#define CNP_SIG_LENGTH(_SignatureDataSize)                   \
    (CNP_SIGHDR_LENGTH + (_SignatureDataSize)) 
    
#define MAX_UDP_SEND_SIZE  ( 0xFFFF - 68 )

#define CDP_MAX_SEND_SIZE(_SignatureDataSize) \
    (MAX_UDP_SEND_SIZE                        \
     - sizeof(CNP_HEADER)                     \
     - CNP_SIG_LENGTH(_SignatureDataSize))    \
     - sizeof(CDP_HEADER)

//
// CNP Receive Flags
//
#define CNP_RECV_FLAG_NODE_STATE_CHECK_PASSED     0x00000001
#define CNP_RECV_FLAG_MULTICAST                   0x00000002
#define CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP     0x00000004
#define CNP_RECV_FLAG_SIGNATURE_VERIFIED          0x00000008

//
// Multicast epoch
//
extern ULONG CxMulticastEpoch;


//
// put here for kdcn
//

typedef enum {
    CcmpInvalidMsgType = 0,
    CcmpHeartbeatMsgType = 1,
    CcmpPoisonMsgType = 2,
    CcmpMembershipMsgType = 3,
    CcmpMcastHeartbeatMsgType = 4
} CCMP_MSG_TYPE;

//
// From MM in clussvc:
//
// The data type "cluster_t" is a bit array of size equal to the maximum
// number of nodes in the cluster. The bit array is implemented as an
// array of uint8s.
//
// Given a node#, its bit position in the bit array is computed by first
// locating the byte in the array (node# / BYTEL) and then the bit in
// the byte. Bits in the byte are numbered 0..7 (from left to right).
// Thus, node 0 is placed in byte 0, bit 0, which is the left-most bit
// in the bit array.
//
//
// The cluster type sizing defines and manipulation routines are copied
// from MM so there is some notion of how the mask is managed.
//

#define MAX_CLUSTER_SIZE    ClusterDefaultMaxNodes

#define BYTEL 8 // number of bits in a uint8
#define BYTES_IN_CLUSTER ((MAX_CLUSTER_SIZE + BYTEL - 1) / BYTEL)

#define BYTE(cluster, node) ( (cluster)[(node) / BYTEL] ) // byte# in array
#define BIT(node)           ( (node) % BYTEL )            // bit# in byte

typedef UCHAR cluster_t [BYTES_IN_CLUSTER];
typedef SHORT node_t;

typedef union _CX_CLUSTERSCREEN {
    ULONG     UlongScreen;
    cluster_t ClusterScreen;
} CX_CLUSTERSCREEN;

//
// converts external node number to internal
//
#define LOWEST_NODENUM     ((node_t)ClusterMinNodeId)  // starting node number
#define INT_NODE(ext_node) ((node_t)(ext_node - LOWEST_NODENUM))

#define CnpClusterScreenMember(c, i) \
    ((BOOLEAN)((BYTE(c,i) >> (BYTEL-1-BIT(i))) & 1))

#define CnpClusterScreenInsert(c, i) \
    (BYTE(c, i) |= (1 << (BYTEL-1-BIT(i))))

#define CnpClusterScreenDelete(c, i) \
    (BYTE(c, i) &= ~(1 << (BYTEL-1-BIT(i))))


//
// CNP Receive Request structures and routines
//

//
// Receive Request Pool
//
typedef struct {
    ULONG   UpperProtocolContextSize;
} CNP_RECEIVE_REQUEST_POOL_CONTEXT, *PCNP_RECEIVE_REQUEST_POOL_CONTEXT;

//
// Receive Request Structure
//
typedef struct {
    CN_RESOURCE      CnResource;
    PIRP             Irp;
    PVOID            DataBuffer;
    PVOID            UpperProtocolContext;
} CNP_RECEIVE_REQUEST, *PCNP_RECEIVE_REQUEST;


PCN_RESOURCE_POOL
CnpCreateReceiveRequestPool(
    IN ULONG  UpperProtocolContextSize,
    IN USHORT PoolDepth
    );

#define CnpDeleteReceiveRequestPool(_pool) \
        { \
            CnDrainResourcePool(_pool);  \
            CnFreePool(_pool);           \
        }

PCNP_RECEIVE_REQUEST
CnpAllocateReceiveRequest(
    IN PCN_RESOURCE_POOL  RequestPool,
    IN PVOID              Network,
    IN ULONG              BytesToReceive,
    IN PVOID              CompletionRoutine
    );

VOID
CnpFreeReceiveRequest(
    PCNP_RECEIVE_REQUEST  Request
    );

//
//
// Function Prototypes
//
//

VOID
CxTdiAddAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    );

VOID
CxTdiDelAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    );

NTSTATUS
CxWmiPnpLoad(
    VOID
    );

VOID
CxWmiPnpUnload(
    VOID
    );

NTSTATUS
CxWmiPnpInitialize(
    VOID
    );

VOID
CxWmiPnpShutdown(
    VOID
    );

VOID
CxReconnectLocalInterface(
    IN CL_NETWORK_ID NetworkId
    );

VOID
CxQueryMediaStatus(
    IN  HANDLE            AdapterDeviceHandle,
    IN  CL_NETWORK_ID     NetworkId,
    OUT PULONG            MediaStatus
    );

VOID
CxBuildTdiAddress(
    PVOID        Buffer,
    CL_NODE_ID   Node,
    USHORT       Port,
    BOOLEAN      Verified
    );

NTSTATUS
CxParseTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *AddrList,
    IN  ULONG                        AddressListLength,
    OUT CL_NODE_ID *                 Node,
    OUT PUSHORT                      Port
    );

PCX_ADDROBJ
CxFindAddressObject(
    IN USHORT  Port
    );

NTSTATUS
CnpLoadNodes(
    VOID
    );

NTSTATUS
CnpInitializeNodes(
    VOID
    );

VOID
CnpShutdownNodes(
    VOID
    );

NTSTATUS
CnpLoadNetworks(
    VOID
    );

NTSTATUS
CnpInitializeNetworks(
    VOID
    );

VOID
CnpShutdownNetworks(
    VOID
    );

NTSTATUS
CnpLoad(
    VOID
    );

VOID
CnpUnload(
    VOID
    );

NTSTATUS
CcmpLoad(
    VOID
    );

VOID
CcmpUnload(
    VOID
    );

NTSTATUS
CdpLoad(
    VOID
    );

VOID
CdpUnload(
    VOID
    );

NTSTATUS
CdpReceivePacketHandler(
    IN  PVOID          Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    );

NTSTATUS
CxInitializeHeartBeat(
    VOID
    );

VOID
CxUnloadHeartBeat(
    VOID
    );

NTSTATUS
CnpStartHeartBeats(
    VOID
    );

VOID
CnpStopHeartBeats(
    VOID
    );

NTSTATUS
CxReserveClusnetEndpoint(
    IN USHORT Port
    );

NTSTATUS
CxUnreserveClusnetEndpoint(
    VOID
    );

NTSTATUS
CxSendMcastHeartBeatMessage(
    IN     CL_NETWORK_ID               NetworkId,
    IN     PVOID                       McastGroup,
    IN     CX_CLUSTERSCREEN            McastTargetNodes,
    IN     ULONG                       McastEpoch,
    IN     CX_HB_NODE_INFO             NodeInfo[],
    IN     PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN     PVOID                       CompletionContext   OPTIONAL
    );

NTSTATUS
CxConfigureMulticast(
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               MulticastNetworkBrand,
    IN PTRANSPORT_ADDRESS  TdiMcastBindAddress,
    IN ULONG               TdiMcastBindAddressLength,
    IN PVOID               Key,
    IN ULONG               KeyLength,
    IN PIRP                Irp
    );

NTSTATUS
CxGetMulticastReachableSet(
    IN  CL_NETWORK_ID      NetworkId,
    OUT ULONG            * NodeScreen
    );

#endif // ifndef _CXP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\bufpool.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   bufpool.c

Abstract:

    Generic Buffer Pool Manager.

Author:

    Mike Massa (mikemas)           April 5, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-05-96    created

Notes:

    Buffer Pools provide a mechanism for managing caches of fixed size
    structures which are frequently allocated/deallocated.

--*/

#include "clusrtlp.h"


//
// Pool of generic buffers
//
typedef struct _CLRTL_BUFFER_POOL {
    DWORD                        PoolSignature;
    DWORD                        BufferSize;
    SINGLE_LIST_ENTRY            FreeList;
    DWORD                        MaximumCached;
    DWORD                        CurrentCached;
    DWORD                        MaximumAllocated;
    DWORD                        ReferenceCount;
    CLRTL_BUFFER_CONSTRUCTOR     Constructor;
    CLRTL_BUFFER_DESTRUCTOR      Destructor;
    CRITICAL_SECTION             Lock;
} CLRTL_BUFFER_POOL;


//
// Header for each allocated buffer
//
typedef struct {
    SINGLE_LIST_ENTRY    Linkage;
    PCLRTL_BUFFER_POOL   Pool;
} BUFFER_HEADER, *PBUFFER_HEADER;


#define BP_SIG   'loop'

#define ASSERT_BP_SIG(pool)  CL_ASSERT((pool)->PoolSignature == BP_SIG)


//
// Macros
//
//
#define BpAllocateMemory(size)    LocalAlloc(LMEM_FIXED, (size))
#define BpFreeMemory(buf)         LocalFree(buf)
#define BpAcquirePoolLock(Pool)   EnterCriticalSection(&((Pool)->Lock))
#define BpReleasePoolLock(Pool)   LeaveCriticalSection(&((Pool)->Lock))


//
// Public Functions
//
PCLRTL_BUFFER_POOL
ClRtlCreateBufferPool(
    IN DWORD                      BufferSize,
    IN DWORD                      MaximumCached,
    IN DWORD                      MaximumAllocated,
    IN CLRTL_BUFFER_CONSTRUCTOR   Constructor,         OPTIONAL
    IN CLRTL_BUFFER_DESTRUCTOR    Destructor           OPTIONAL
    )
/*++

Routine Description:

    Creates a pool from which fixed-size buffers may be allocated.

Arguments:

    BufferSize        - Size of the buffers managed by the pool.

    MaximumCached     - The maximum number of buffers to cache in the pool.
                        Must be less than or equal to MaximumAllocated.

    MaximumAllocated  - The maximum number of buffers to allocate from
                        system memory. Must be less than or equal to
                        CLRTL_MAX_POOL_BUFFERS.

    Constructor       - An optional routine to be called when a new buffer
                        is allocated from system memory. May be NULL

    Destructor        - An optional routine to be called when a buffer
                        is returned to system memory. May be NULL.

Return Value:

    A pointer to the created buffer pool or NULL on error.
    Extended error information is available from GetLastError().

--*/

{
    PCLRTL_BUFFER_POOL  pool;


    if ( (MaximumAllocated > CLRTL_MAX_POOL_BUFFERS) ||
         (MaximumCached > MaximumAllocated)
       )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    pool = BpAllocateMemory(sizeof(CLRTL_BUFFER_POOL));

    if (pool != NULL) {

        InitializeCriticalSection(&(pool->Lock));

        pool->PoolSignature = BP_SIG;
        pool->BufferSize = sizeof(BUFFER_HEADER) + BufferSize;
        pool->FreeList.Next = NULL;
        pool->MaximumCached = MaximumCached;
        pool->CurrentCached = 0;
        pool->MaximumAllocated = MaximumAllocated + 1;
        pool->ReferenceCount = 1;
        pool->Constructor = Constructor;
        pool->Destructor = Destructor;
    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pool);
}


VOID
ClRtlDestroyBufferPool(
    IN PCLRTL_BUFFER_POOL  Pool
    )
/*++

Routine Description:

    Destroys a previously created buffer pool.

Arguments:

    Pool  - A pointer to the pool to destroy.

Return Value:

    None.

Notes:

    The pool will not actually be destroyed until all outstanding
    buffers have been returned. Each outstanding buffer is effectively
    a reference on the pool.

--*/

{
    SINGLE_LIST_ENTRY          deleteList;
    CLRTL_BUFFER_DESTRUCTOR    destructor;
    PSINGLE_LIST_ENTRY         item;
    PBUFFER_HEADER             header;
    BOOLEAN                    freePool;


    deleteList.Next = NULL;

    ASSERT_BP_SIG(Pool);

    BpAcquirePoolLock(Pool);

    CL_ASSERT(Pool->ReferenceCount != 0);
    Pool->ReferenceCount--;          // Remove initial reference.
    destructor = Pool->Destructor;

    //
    // Free all cached buffers
    //
    item = PopEntryList(&(Pool->FreeList));

    while (item != NULL) {
        CL_ASSERT(Pool->ReferenceCount != 0);
        PushEntryList(&deleteList, item);
        Pool->ReferenceCount--;

        item = PopEntryList(&(Pool->FreeList));
    }

    if (Pool->ReferenceCount == 0) {
        BpReleasePoolLock(Pool);

        DeleteCriticalSection(&(Pool->Lock));
        BpFreeMemory(Pool);
    }
    else {
        //
        // Pool destruction is deferred until all buffers have been freed.
        //
        Pool->CurrentCached = 0;
        Pool->MaximumCached = 0;

        BpReleasePoolLock(Pool);
    }

    item = PopEntryList(&deleteList);

    while (item != NULL) {
        header = CONTAINING_RECORD(
                     item,
                     BUFFER_HEADER,
                     Linkage
                     );

        if (destructor != NULL) {
            (*destructor)(header+1);
        }

        BpFreeMemory(header);

        item = PopEntryList(&deleteList);
    }

    return;
}


PVOID
ClRtlAllocateBuffer(
    IN PCLRTL_BUFFER_POOL Pool
    )
/*++

Routine Description:

    Allocates a buffer from a previously created buffer pool.

Arguments:

    Pool - A pointer to the pool from which to allocate the buffer.

Return Value:

    A pointer to the allocated buffer if the routine was successfull.
    NULL if the routine failed. Extended error information is available
    by calling GetLastError().

--*/

{

//
// turn this fancy stuff off until it works.
//
#if 0
    PSINGLE_LIST_ENTRY    item;
    PBUFFER_HEADER        header;
    PVOID                 buffer;
    DWORD                 status;


    ASSERT_BP_SIG(Pool);

    BpAcquirePoolLock(Pool);

    //
    // First, check the cache.
    //
    item = PopEntryList(&(Pool->FreeList));

    if (item != NULL) {
        CL_ASSERT(Pool->CurrentCached != 0);
        Pool->CurrentCached--;

        BpReleasePoolLock(Pool);

        header = CONTAINING_RECORD(
                     item,
                     BUFFER_HEADER,
                     Linkage
                     );

        return(header+1);
    }

    //
    // Need to allocate a fresh buffer from system memory.
    //
    if (Pool->ReferenceCount < Pool->MaximumAllocated) {
        //
        // This is equivalent to a reference on the Pool.
        //
        Pool->ReferenceCount++;

        BpReleasePoolLock(Pool);

        header = BpAllocateMemory(Pool->BufferSize);

        if (header != NULL) {
            header->Pool = Pool;
            buffer = header+1;

            if (Pool->Constructor == NULL) {
                return(buffer);
            }

            status = (*(Pool->Constructor))(buffer);

            if (status == ERROR_SUCCESS) {
                return(buffer);
            }

            SetLastError(status);

            //
            // The constructor failed.
            //
            BpFreeMemory(header);
        }
        else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Failed - undo the reference.
        //
        BpAcquirePoolLock(Pool);

        Pool->ReferenceCount--;
    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    BpReleasePoolLock(Pool);

    return(NULL);
#else
    return(LocalAlloc(LMEM_FIXED, Pool->BufferSize));
#endif
}


VOID
ClRtlFreeBuffer(
    PVOID Buffer
    )
/*++

Routine Description:

    Frees a buffer back to its owning pool.

Arguments:

    Buffer   - The buffer to free.

Return Value:

    None.

--*/
{
//
//  turn this fancy stuff off until it works.
//
#if 0

    PBUFFER_HEADER              header;
    PCLRTL_BUFFER_POOL          pool;
    CLRTL_BUFFER_DESTRUCTOR     destructor;


    header = ((PBUFFER_HEADER) Buffer) - 1;

    pool = header->Pool;

    ASSERT_BP_SIG(pool);

    BpAcquirePoolLock(pool);

    if (pool->CurrentCached < pool->MaximumCached) {
        //
        // Return to free list
        //
        PushEntryList(
            &(pool->FreeList),
            (PSINGLE_LIST_ENTRY) &(header->Linkage)
            );

        pool->CurrentCached++;

        BpReleasePoolLock(pool);

        return;
    }

    destructor = pool->Destructor;

    CL_ASSERT(pool->ReferenceCount != 0);

    if (--(pool->ReferenceCount) != 0) {
        BpReleasePoolLock(pool);

        if (destructor) {
            (*destructor)(Buffer);
        }

        BpFreeMemory(header);

        return;

    }

    CL_ASSERT(pool->CurrentCached == 0);
    BpReleasePoolLock(pool);
    DeleteCriticalSection(&(pool->Lock));
    BpFreeMemory(pool);

    if (destructor) {
        (*destructor)(Buffer);
    }

    BpFreeMemory(header);

    return;
#else
    LocalFree(Buffer);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\clusrtlp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    clusrtlp.h

Abstract:

    Private header file for the NT Cluster RTL library

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

extern HANDLE LocalEventLog;
#define LOG_CURRENT_MODULE LOG_MODULE_CLRTL

// Adding watchdog struct definitions.....
typedef struct _WATCHDOGPAR{
    HANDLE wTimer;
    LPWSTR par;
    DWORD threadId;
} WATCHDOGPAR, *PWATCHDOGPAR;

VOID
ClRtlpFlushLogBuffers(
    VOID
    );

ULONG
WppAutoStart(
    IN LPCWSTR ProductName
    );
    
VOID
ClRtlPrintf(
    PCHAR FormatString,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\clusrtl.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clusrtl.c

Abstract:

    Provides run-time library support common to any module
    of the NT Cluster.

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:

--*/
#include "clusrtlp.h"
#include "stdarg.h"
#include "stdlib.h"
#include "clusverp.h"
#include "windns.h"
#include "security.h"
#include "secext.h"
#include "sddl.h"

#define WMI_TRACING 1
#define RPC_WMI_TRACING 1

#if defined(WMI_TRACING)

// 789aa2d3-e298-4d8b-a3a3-a8a0ec9c7702 -- Rpc
// b1599392-1a0f-11d3-ba86-00c04f8eed00 -- ClusSvc

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(ClusRtl,(b1599392,1a0f,11d3,ba86,00c04f8eed00), \
      WPP_DEFINE_BIT(Error)      \
      WPP_DEFINE_BIT(Unusual)    \
      WPP_DEFINE_BIT(Noise)      \
      WPP_DEFINE_BIT(Watchdog)      \
   )        \
   WPP_DEFINE_CONTROL_GUID(ClusRpc,(789aa2d3,e298,4d8b,a3a3,a8a0ec9c7702), \
      WPP_DEFINE_BIT(RpcTrace)   \
   )

//#define WppDebug(x,y) ClRtlPrintf y
#include "clusrtl.tmh"

#define REG_TRACE_CLUSTERING        L"Clustering Service"


#endif // defined(WMI_TRACING)

//
// Local Macros
//

//
// SC Manager failure action parameters. set STARTUP_FAILURE_RESTART to one
// before shipping to get the normal backoff behavior.
//

#if STARTUP_FAILURE_RESTART
#define CLUSTER_FAILURE_RETRY_COUNT             -1  // forever
#else
#define CLUSTER_FAILURE_RETRY_COUNT             0
#endif

#define CLUSTER_FAILURE_MAX_STARTUP_RETRIES             30
#define CLUSTER_FAILURE_INITIAL_RETRY_INTERVAL          60 * 1000           // 60 secs
#define CLUSTER_FAILURE_FINAL_RETRY_INTERVAL            ( 60 * 1000 * 16)   // 16 mins

#define ClRtlAcquirePrintLock() \
        WaitForSingleObject( ClRtlPrintFileMutex, INFINITE );

#define ClRtlReleasePrintLock() \
        ReleaseMutex( ClRtlPrintFileMutex );

#define LOGFILE_NAME L"Cluster.log"

//
// DON'T CHANGE THIS CONSTANT UNLESS YOU REALLY KNOW WHAT YOU'RE
// DOING. ASSUMPTIONS HAVE BEEN MADE ABOUT IT'S SIZE AND THINGS WILL BREAK IF
// YOU MAKE IT TOO SMALL. - charlwi 4/1/02 (and, no, this is not an April
// Fool's joke).
//
#define LOGENTRY_BUFFER_SIZE 512


//
// Private Data
//
BOOL                ClRtlpDbgOutputToConsole = FALSE;
BOOL                ClRtlpInitialized = FALSE;
BOOL                ClRtlPrintToFile = FALSE;
HANDLE              ClRtlPrintFile = NULL;
HANDLE              ClRtlPrintFileMutex = NULL;
DWORD               ClRtlProcessId;
PDWORD              ClRtlDbgLogLevel;
HANDLE				ClRtlWatchdogTimerQueue = NULL;

#define MAX_NUMBER_LENGTH 20

// Specify maximum file size ( DWORD / 1MB )

#define MAX_FILE_SIZE ( 0xFFFFF000 / ( 1024 * 1024 ) )

DWORD               ClRtlPrintFileLimit = ( 8 * 1024 * 1024 ); // 8 MB default
DWORD               ClRtlPrintFileLoWater = 0;

//
// Public Routines
//

// !!!!NOTE!!!!
//
// This initialization routine is call from DllMain(), do not add anyting out
// here that requires synchronization. Do not add any win32 api calls here.
//

DWORD
ClRtlInitialize(
    IN  BOOL    DbgOutputToConsole,
    IN  PDWORD  DbgLogLevel
    )
{
    WCHAR   logFileBuffer[MAX_PATH];
    LPWSTR  logFileName = NULL;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   defaultLogSize = 8;
    HKEY    ClusterKey;
    WCHAR   modulePath[MAX_PATH];
    DWORD   envLength;
    WCHAR   logFileSize[MAX_NUMBER_LENGTH];
    DWORD   logSize;
    LPWSTR  lpszBakFileName = NULL;
    DWORD   fileSizeHigh = 0;
    DWORD   fileSizeLow;

    UNICODE_STRING  logFileString;

    SECURITY_ATTRIBUTES logFileSecurityAttr;

    PSECURITY_DESCRIPTOR    logFileSecurityDesc;

    //
    // init event stuff so we have a means for logging other failures
    //
    ClRtlEventLogInit();

    if (!ClRtlpInitialized) {
        ClRtlpDbgOutputToConsole = DbgOutputToConsole;
        ClRtlpInitialized = TRUE;
        ClRtlDbgLogLevel = DbgLogLevel;

        //
        // GetEnvironmentVariable returns the count minus the null if the
        // buffer is large enough. Otherwise, the return length includes space
        // for the trailing null.
        //
        // the code that deals with the clusterlog and clusterlogsize
        // env. variables is dup'ed in OmpOpenObjectLog
        // (service\om\omlog.c). Any changes made here should be prop'ed to
        // that area if appropriate.
        //
        envLength = GetEnvironmentVariable(L"ClusterLog",
                                            logFileBuffer,
                                            RTL_NUMBER_OF( logFileBuffer ));

        if ( envLength > RTL_NUMBER_OF( logFileBuffer )) {

            logFileName = LocalAlloc( LMEM_FIXED,
                                      envLength * sizeof( WCHAR ) );
            if ( logFileName == NULL ) {
                return GetLastError();
            }

            envLength = GetEnvironmentVariable(L"ClusterLog",
                                                logFileName,
                                                envLength);
            if ( envLength == 0 ) {
                LocalFree( logFileName );
                logFileName = NULL;
            }
        } else if ( envLength != 0 ) {
            logFileName = logFileBuffer;
        }

        //
        // remove any trailing white space. go to the end of the string and
        // scan backwards; stop when we find the first non-white space char or
        // we hit the beginning of the buffer.
        //
        if ( logFileName != NULL ) {
            PWCHAR  p = logFileName + envLength - 1;

            while ( iswspace( *p )) {
                *p = UNICODE_NULL;

                if ( p == logFileName ) {
                    break;
                }

                --p;
            }

            //
            // make sure something useful is left
            //
            if ( wcslen( logFileName ) == 0 ) {
                if ( logFileName != logFileBuffer ) {
                    LocalFree( logFileName );
                }

                logFileName = NULL;
            }
        }

#if CLUSTER_BETA

        //
        // always turn on logging when in beta mode
        //
        if ( ( logFileName != NULL ) && ( *logFileName == UNICODE_NULL ) ) {
            WCHAR *p;

            if ( GetModuleFileName(NULL,
                                   modulePath,
                                   MAX_PATH - sizeof(LOGFILE_NAME)/sizeof(WCHAR) ) ) {
                p = wcsrchr( modulePath, '\\' );
                if ( p != UNICODE_NULL ) {
                    p++;
                    *p = UNICODE_NULL;
                    wcscat( modulePath, LOGFILE_NAME );
                    logFileName = modulePath;
                }
            }
        }
#endif

        if ( logFileName != NULL ) {
            //
            // Try to get a limit on the log file size.
            // This number is the number of MB.
            //
            envLength = GetEnvironmentVariable(L"ClusterLogSize",
                                                logFileSize,
                                                RTL_NUMBER_OF( logFileSize ));
            if ( (envLength != 0) &&
                 (envLength < MAX_NUMBER_LENGTH) ) {
                RtlInitUnicodeString( &logFileString, logFileSize );
                Status = RtlUnicodeStringToInteger( &logFileString,
                                                    10,
                                                    &logSize );
                if ( NT_SUCCESS( Status ) ) {
                    ClRtlPrintFileLimit = logSize;
                }
            } else {
                ClRtlPrintFileLimit = defaultLogSize;
            }

            Status = ERROR_SUCCESS;

            if ( ClRtlPrintFileLimit == 0 ) {
                goto exit;
            }

            if ( ClRtlPrintFileLimit > MAX_FILE_SIZE ) {
                ClRtlPrintFileLimit = MAX_FILE_SIZE;
            }
            ClRtlPrintFileLimit = ClRtlPrintFileLimit * ( 1024 * 1024 );

            ClRtlPrintFileMutex = CreateMutex( NULL,
                                               FALSE,
                                               L"ClusterRtlPrintFileMutex" );
            if ( ClRtlPrintFileMutex != NULL ) {
                BOOL createdDirectory = FALSE;
                //
                //  Chittur Subbaraman (chitturs) - 11/11/98
                //
                //  Check whether the ClusterLogOverwrite environment var is
                //  defined.
                //
                envLength = GetEnvironmentVariable( L"ClusterLogOverwrite",
                                                    NULL,
                                                    0 );
                if ( envLength != 0 )
                {
                    HANDLE  hLogFile = INVALID_HANDLE_VALUE;
                    WCHAR   bakExtension[] = L".bak";

                    //
                    //  Check whether someone else has an open handle to
                    //  the log file.  If so, don't attempt anything.
                    //
                    hLogFile = CreateFile( logFileName,
                                           GENERIC_READ | GENERIC_WRITE,
                                           0, // Exclusive file share mode
                                           NULL,
                                           OPEN_EXISTING,
                                           0,
                                           NULL );
                    if ( hLogFile != INVALID_HANDLE_VALUE )
                    {
                        CloseHandle( hLogFile );

                        lpszBakFileName = LocalAlloc( LMEM_FIXED,
                                                      ( RTL_NUMBER_OF( bakExtension ) + lstrlenW( logFileName ) ) *
                                                      sizeof( WCHAR ) );
                        if ( lpszBakFileName == NULL )
                        {
                            Status = GetLastError();
                            ClRtlDbgPrint(LOG_CRITICAL,
                                          "[ClRtl] Mem alloc for .bak file name failed. Error %1!u!\n",
                                          Status);
                            goto exit;
                        }

                        //
                        //  Append ".bak" to the log file name
                        //
                        lstrcpyW( lpszBakFileName, logFileName );
                        lstrcatW( lpszBakFileName, bakExtension );

                        //
                        //  Move the log file (if it exists) to a bak
                        //  file. Moving preserves the ACL on the file.
                        //
                        if ( !MoveFileExW( logFileName, lpszBakFileName, MOVEFILE_REPLACE_EXISTING )) {
                            //
                            //  There is no reason for this to happen since the
                            //  log file should be deletable.
                            //
                            Status = GetLastError();
                            ClRtlDbgPrint(LOG_CRITICAL,
                                          "[ClRtl] Error %1!u! in renaming cluster log file.\n",
                                          Status);
                            goto exit;
                        }
                    }
                }

                //
                // create a SD giving only local admins and localsystem
                // access.
                //
                if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                          L"D:(A;;FA;;;BA)(A;;FA;;;SY)",
                          SDDL_REVISION_1,
                          &logFileSecurityDesc,
                          NULL
                          )
                   )
                {
                    logFileSecurityDesc = NULL;
                }

                logFileSecurityAttr.nLength = sizeof( logFileSecurityAttr );
                logFileSecurityAttr.lpSecurityDescriptor = logFileSecurityDesc;
                logFileSecurityAttr.bInheritHandle = FALSE;

openFileRetry:
                ClRtlPrintFile = CreateFile(logFileName,
                                            GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            &logFileSecurityAttr,
                                            OPEN_ALWAYS,
                                            0,
                                            NULL );

                if ( ClRtlPrintFile == INVALID_HANDLE_VALUE ) {
                    Status = GetLastError();

                    if ( !createdDirectory && Status == ERROR_PATH_NOT_FOUND ) {
                        PWCHAR lastSlash = wcsrchr( logFileName, '\\' );
                        WCHAR  slashChar;

                        if ( lastSlash == NULL ) {
                            lastSlash = wcsrchr( logFileName, '/' );
                        }

                        if ( lastSlash != NULL ) {
                            slashChar = *lastSlash;
                            *lastSlash = UNICODE_NULL;
                            Status = ClRtlCreateDirectory( logFileName );

                            if ( Status == ERROR_SUCCESS ) {
                                createdDirectory = TRUE;
                                *lastSlash = slashChar;
                                goto openFileRetry;
                            }
                        }
                    }

                    ClRtlDbgPrint(LOG_CRITICAL,
                                  "[ClRtl] Open of log file failed. Error %1!u!\n",
                                  Status);
                    goto exit;
                } else {
                    ClRtlPrintToFile = TRUE;
                    ClRtlProcessId = GetCurrentProcessId();

                    //
                    // determine the initial low water mark. We have 3 cases
                    // we need to handle:
                    // 1) log size is less than 1/2 limit
                    // 2) log size is within limit but more than 1/2 limit
                    // 3) log size is greater than limit
                    //
                    // case 1 requires nothing special; the low water mark
                    // will be updated on the next log write.
                    //
                    // for case 2, we need to find the beginning of a line
                    // near 1/2 the current limit. for case 3, the place to
                    // start looking is current log size - 1/2 limit. In this
                    // case, the log will be truncated before the first write
                    // occurs, so we need to take the last 1/2 limit bytes and
                    // copy them down to the front.
                    //
                    //

                    ClRtlAcquirePrintLock();
                    fileSizeLow = GetFileSize( ClRtlPrintFile, &fileSizeHigh );
                    if ( fileSizeLow < ( ClRtlPrintFileLimit / 2 )) {
                        //
                        // case 1: leave low water at zero; it will be updated
                        // with next log write
                        //
                        ;
                    } else {
#define LOGBUF_SIZE 1024
                        CHAR    buffer[LOGBUF_SIZE];
                        LONG    currentPosition;
                        DWORD   bytesRead;

                        if ( fileSizeLow < ClRtlPrintFileLimit ) {
                            //
                            // case 2; start looking at the 1/2 the current
                            // limit to find the starting position
                            //
                            currentPosition = ClRtlPrintFileLimit / 2;
                        } else {
                            //
                            // case 3: start at current size minus 1/2 limit
                            // to find our starting position.
                            //
                            currentPosition  = fileSizeLow - ( ClRtlPrintFileLimit / 2 );
                        }

                        //
                        // read in a block (backwards) from the initial file
                        // position and look for a newline char. When we find
                        // one, the next char is the first char on a new log
                        // line. use that as the initial starting position
                        // when we finally truncate the file.
                        //
                        ClRtlPrintFileLoWater = 0;
                        currentPosition -= LOGBUF_SIZE;

                        SetFilePointer(ClRtlPrintFile,
                                       currentPosition,
                                       &fileSizeHigh,
                                       FILE_BEGIN);
                        if ( ReadFile(ClRtlPrintFile,
                                      buffer,
                                      LOGBUF_SIZE,
                                      &bytesRead,
                                      NULL ) )
                        {
                            PCHAR p = &buffer[ bytesRead - 1 ];

                            while ( *p != '\n' && bytesRead-- != 0 ) {
                                --p;
                            }
                            if ( *p == '\n' ) {
                                ClRtlPrintFileLoWater = (DWORD)(currentPosition + ( p - buffer + 1 ));
                            }
                        }

                        if ( ClRtlPrintFileLoWater == 0 ) {
                            //
                            // couldn't find any reasonable data. just set it to
                            // initial current position.
                            //
                            ClRtlPrintFileLoWater = currentPosition + LOGBUF_SIZE;
                        }
                    }
                    ClRtlReleasePrintLock();
                }

                LocalFree( logFileSecurityDesc );

            } else {
                Status = GetLastError();
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "[ClRtl] Unable to create print file mutex. Error %1!u!.\n",
                              Status);
                Status = ERROR_SUCCESS;
                //goto exit;
            }
        }
    }

exit:
    if ( logFileName != logFileBuffer && logFileName != modulePath ) {
        LocalFree( logFileName );
    }

    //
    //  Chittur Subbaraman (chitturs) - 11/11/98
    //
    if ( lpszBakFileName != NULL )
    {
        LocalFree( lpszBakFileName );
    }

    return Status;

} // ClRtlInitialize

#ifdef RPC_WMI_TRACING

typedef
DWORD (*I_RpcEnableWmiTraceFunc )(
            VOID* fn,               // Rpc now uses TraceMessage, no need to pass trace func
            WPP_WIN2K_CONTROL_BLOCK ** pHandle
      );

HINSTANCE hInstRpcrt4;

#endif


DWORD
ClRtlIsServicesForMacintoshInstalled(
    OUT BOOL * pfInstalled
    )

/*++

Routine Description:

    Determines if SFM is installed on the local system.

Arguments:

    pfInstalled - pointer to a boolean flag to return whether SFM is installed
    returns: TRUE if SFM is installed
             FALSE if SFM is not installed

Return Value:

    Status of request. ERROR_SUCCESS if valid info in pfInstalled.
       Error Code otherwise. On error pfInstalled (if present) is set to FALSE

--*/

{
    HANDLE  scHandle;
    HANDLE  scServiceHandle;

    if ( ARGUMENT_PRESENT( pfInstalled ) ) {
        *pfInstalled = FALSE;
    } else {
        return ERROR_INVALID_PARAMETER;
    }
    scHandle = OpenSCManager(
        NULL,       // Open on local machine
        NULL,       // Open SERVICES_ACTIVE_DATABASE
        GENERIC_READ );
    if ( scHandle == NULL ) {
        return( GetLastError() );
    }

    scServiceHandle = OpenService(
                scHandle,
                L"macfile",
                READ_CONTROL );
    if ( scServiceHandle != NULL ) {
        *pfInstalled = TRUE;
    }
    CloseServiceHandle( scServiceHandle );
    CloseServiceHandle( scHandle );

    return ERROR_SUCCESS;

} // ClRtlIsServicesForMacintoshInstalled


DWORD
ClRtlInitWmi(
    LPCWSTR ComponentName
    )
{
#if defined(RPC_WMI_TRACING)
    {
        DWORD Status = ERROR_SUCCESS;
        PWPP_WIN2K_CONTROL_BLOCK RpcCb;
        I_RpcEnableWmiTraceFunc RpcEnableWmiTrace = 0;

        hInstRpcrt4 = LoadLibrary(L"rpcrt4.dll");
        if (hInstRpcrt4) {
            RpcEnableWmiTrace = (I_RpcEnableWmiTraceFunc)
                GetProcAddress(hInstRpcrt4, "I_RpcEnableWmiTrace");

            if (RpcEnableWmiTrace) {

                Status = (*RpcEnableWmiTrace)(0, &RpcCb);
                if (Status == ERROR_SUCCESS) {
                    WPP_SET_FORWARD_PTR(RpcTrace, WPP_VER_WIN2K_CB_FORWARD_PTR, RpcCb);
                }

            } else {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "[ClRtl] rpcrt4.dll GetWmiTraceEntryPoint failed, status %1!d!.\n",
                              GetLastError() );
            }
        }
    }
#endif // RPC_WMI_TRACING

    WPP_INIT_TRACING(NULL); // Don't need publishing
    WppAutoStart(ComponentName);
    return ERROR_SUCCESS;
}

VOID
ClRtlCleanup(
    VOID
    )
{
    if (ClRtlpInitialized) {
        ClRtlpInitialized = FALSE;
        ClRtlEventLogCleanup();
        CloseHandle ( ClRtlPrintFileMutex );
        CloseHandle ( ClRtlPrintFile );

        //Cleaning up watchdog stuff
        if(ClRtlWatchdogTimerQueue != NULL) {
        	DeleteTimerQueue(ClRtlWatchdogTimerQueue);
        	ClRtlWatchdogTimerQueue = NULL;
        	}			

        WPP_CLEANUP();
    #if defined(RPC_WMI_TRACING)
        if (hInstRpcrt4) {
            FreeLibrary(hInstRpcrt4);
            hInstRpcrt4 = NULL;
        }
    #endif
    }

    return;
}

VOID
ClRtlpWatchdogCallback(
	PVOID par,
	BOOLEAN timedOut
	)
{

    PWATCHDOGPAR pPar=(PWATCHDOGPAR)par;

	if(!timedOut) {
		// The timer was cancelled, get out.
		ClRtlLogPrint(LOG_NOISE,
		    "[ClRtl] Watchdog Timer Cancelled, ThreadId= 0x%1!x! par= %2!ws!.\n",
		    pPar->threadId,
		    pPar->par
		    );
		return;
	}

	ClRtlLogPrint(LOG_CRITICAL,
		"[ClRtl] Watchdog timer timed out, ThreadId= 0x%1!x! par= %2!ws!.\n",
		pPar->threadId,
		pPar->par
		);

#if CLUSTER_BETA
    if (WPP_LEVEL_ENABLED(Watchdog)) {
	// Breaking into NTSD if available or KD. Do it only for cluster beta builds.
	DebugBreak();
    }
#endif

}

PVOID
ClRtlSetWatchdogTimer(
	DWORD  timeout,
	LPWSTR par
	)
{

	PWATCHDOGPAR pPar;

	// Do the initialization here not in ClRtlInitialize()
	if(ClRtlWatchdogTimerQueue == NULL) {
		if((ClRtlWatchdogTimerQueue = CreateTimerQueue()) == NULL) {
			return NULL;
		}
	}

	if((pPar = LocalAlloc(LMEM_FIXED, sizeof(WATCHDOGPAR))) == NULL) {
	    return NULL;
	    }
	pPar->par = par;
	pPar->threadId = GetCurrentThreadId();

	if(!CreateTimerQueueTimer(
			&pPar->wTimer,
			ClRtlWatchdogTimerQueue,
			ClRtlpWatchdogCallback,
			(PVOID)pPar,
			timeout,
			0,
			0)) {
			LocalFree(pPar);
			return NULL;
		}

#if CLUSTER_BETA
	ClRtlLogPrint(LOG_NOISE,
		"[ClRtl] Setting watchdog timer= 0x%1!x!, Timeout= %2!u!(ms), par= %3!ws!.\n",
		pPar->wTimer,
		timeout,
		par
		);
#endif

	return (PVOID)pPar;		

}	

VOID
ClRtlCancelWatchdogTimer(
	PVOID wTimer
	)
{

    PWATCHDOGPAR pPar=(PWATCHDOGPAR)wTimer;

	if((ClRtlWatchdogTimerQueue == NULL) || (wTimer == NULL)) {
		return;
		}

	if(!DeleteTimerQueueTimer(
		ClRtlWatchdogTimerQueue,
		pPar->wTimer,
		INVALID_HANDLE_VALUE
		)) {
		ClRtlLogPrint(LOG_CRITICAL,
			"[ClRtl] Failed to cancel watchdog timer 0x%1!x!.\n",
			pPar->wTimer
			);
		}
	else {
#if CLUSTER_BETA	
		ClRtlLogPrint(LOG_NOISE,
			"[ClRtl] Cancelled watchdog timer 0x%1!x!.\n",
			pPar->wTimer
			);
#endif
		}
	LocalFree(wTimer);
}	
		
		

BOOL
ClRtlCheckForLogCorruption(
    LPSTR pszOutBuffer
    )
//
// Find the log corrupter. There should never be move than 4
// question marks in a row or character below 32 or above 128
// if English.
//
// Returns:
//      TRUE if it is safe to write
//      FALSE if it is NOT safe to write
//
{
    DWORD count;
    WCHAR  szLocale[ 32 ];
    static BOOL fLocaleFound = FALSE;
    static BOOL fEnglish = FALSE;
    DWORD localeBytes;

    if ( !pszOutBuffer )
        return FALSE;

    if ( !fLocaleFound )
    {
        localeBytes = GetLocaleInfoW(LOCALE_SYSTEM_DEFAULT,
                                     LOCALE_SENGLANGUAGE,
                                     szLocale,
                                     RTL_NUMBER_OF( szLocale ));

        if ( localeBytes != 0 )
        {
            if ( lstrcmpiW( szLocale, L"ENGLISH" ) == 0 )
            {
                fEnglish = TRUE;
            }

            fLocaleFound = TRUE;
        }
    }

    for( count = 0; *pszOutBuffer; pszOutBuffer++ )
    {
        if ( *pszOutBuffer == '?' )
        {
            count++;
            if ( count > 4 )
            {
                return FALSE;
            }
        }
        else if ( fEnglish
               && ( ( *pszOutBuffer < 32
                   && *pszOutBuffer != 0x0A    // linefeed
                   && *pszOutBuffer != 0x0D    // creturn
                   && *pszOutBuffer != 0x09 ) // tab
                 || *pszOutBuffer > 128 ) )
        {
            return FALSE;
        }
    }

    return TRUE;

} // ClRtlCheckForLogCorruption

__inline BOOL
ClRtlpIsOutputDeviceAvailable(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // normally, there is nothing to do
    //
    return ( ClRtlpDbgOutputToConsole || IsDebuggerPresent());
} // ClRtlpIsOutputDeviceAvailable

VOID
ClRtlpOutputString(
    IN PCHAR String
    )

/*++

Routine Description:

    Outputs the specified string based on the current settings

Arguments:

    String - Specifies the string to output.

Return Value:

    None.

--*/

{
    static PCRITICAL_SECTION    dbgPrintLock = NULL;
    PCRITICAL_SECTION           testPrintLock;

    //
    // synchronize threads by interlocking the assignment of the global lock.
    //
    if ( dbgPrintLock == NULL ) {
        testPrintLock = LocalAlloc( LMEM_FIXED, sizeof( CRITICAL_SECTION ));
        if ( testPrintLock == NULL ) {
            return;
        }

        InitializeCriticalSection( testPrintLock );
        InterlockedCompareExchangePointer( &dbgPrintLock, testPrintLock, NULL );

        //
        // only one thread did the exchange; the loser deallocates its
        // allocation and switches over to using the real lock
        //
        if ( dbgPrintLock != testPrintLock ) {
            DeleteCriticalSection( testPrintLock );
            LocalFree( testPrintLock );
        }
    }

    EnterCriticalSection( dbgPrintLock );

    //
    // print to console window has precedence. Besides, if console is the
    // debugger window, you get double output
    //
    if (ClRtlpDbgOutputToConsole) {
        printf( "%hs", String );
    } else if ( IsDebuggerPresent()) {
        OutputDebugStringA(String);
    }

    LeaveCriticalSection( dbgPrintLock );

} // ClRtlpOutputString

VOID
ClRtlMsgPrint(
    IN DWORD MessageId,
    ...
    )

/*++

Routine Description:

    Prints a message to the debugger or console, as appropriate

    Does not alter the formatting of the message as it occurs in the message
    file.

Arguments:

    MessageId - The message id of the string to print

    Any FormatMessage compatible arguments to be inserted in the ErrorMessage
    before it is logged.

Return Value:

    None.

--*/

{
    CHAR szOutBuffer[LOGENTRY_BUFFER_SIZE];
    DWORD Bytes;
    NTSTATUS Status;
    va_list ArgList;

    //
    // don't go any further if nothing to do
    //
    if ( !ClRtlpIsOutputDeviceAvailable()) {
        return;
    }

    va_start(ArgList, MessageId);

    try {
        Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE,
                               NULL,
                               MessageId,
                               0,
                               szOutBuffer,
                               RTL_NUMBER_OF( szOutBuffer ),
                               &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               L"LOGERROR(exception): Could not format message ID #%1!u!\n",
                               0,
                               0,
                               szOutBuffer,
                               RTL_NUMBER_OF( szOutBuffer ),
                               (va_list *) &MessageId );
    }

    va_end(ArgList);

    if (Bytes != 0) {
        if ( !ClRtlCheckForLogCorruption( szOutBuffer ) ) {
            Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   "LOGERROR: non-ASCII characters detected after formatting of message ID #%1!u!\n",
                                   0,
                                   0,
                                   szOutBuffer,
                                   RTL_NUMBER_OF( szOutBuffer ),
                                   (va_list *) &MessageId );
        }
        ClRtlpOutputString(szOutBuffer);
    }
} // ClRtlMsgPrint


VOID
ClRtlpDbgPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    va_list ArgList
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    WCHAR wszOutBuffer[LOGENTRY_BUFFER_SIZE];
    WCHAR wszInBuffer[LOGENTRY_BUFFER_SIZE];
    CHAR szOutBuffer[LOGENTRY_BUFFER_SIZE];
    NTSTATUS Status;
    DWORD Bytes;

    //
    // don't go any further if nothing to do
    //
    if ( !ClRtlpIsOutputDeviceAvailable()) {
        return;
    }

    //
    // next check that this message isn't filtered out by the current logging
    // level
    //
    if ( ClRtlDbgLogLevel != NULL ) {
        if ( LogLevel > *ClRtlDbgLogLevel ) {
            return;
        }
    }

    RtlInitAnsiString( &AnsiString, FormatString );
    UnicodeString.MaximumLength = LOGENTRY_BUFFER_SIZE;
    UnicodeString.Buffer = wszInBuffer;
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        return;
    }

    try {
        Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING,
                               UnicodeString.Buffer,
                               0,
                               0,
                               wszOutBuffer,
                               RTL_NUMBER_OF( wszOutBuffer ),
                               &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               L"LOGERROR(exception): Could not print message: %1!hs!.",
                               0,
                               0,
                               wszOutBuffer,
                               RTL_NUMBER_OF( wszOutBuffer ),
                               (va_list *) &FormatString );
    }

    if (Bytes != 0) {
        UnicodeString.Length = (USHORT) Bytes * sizeof(WCHAR);
        UnicodeString.Buffer = wszOutBuffer;
        AnsiString.MaximumLength = LOGENTRY_BUFFER_SIZE;
        AnsiString.Buffer = szOutBuffer;
        Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
        if ( NT_SUCCESS( Status ) ) {
            if ( ClRtlCheckForLogCorruption( AnsiString.Buffer ) ) {
                ClRtlpOutputString(szOutBuffer);
            }
            else
            {
                Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                                       | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       "LOGERROR: non-ASCII characters in formatted message: %1!hs!",
                                       0,
                                       0,
                                       szOutBuffer,
                                       RTL_NUMBER_OF( szOutBuffer ),
                                       (va_list *) &FormatString );

                if ( Bytes > 0 ) {
                    ClRtlpOutputString(szOutBuffer);
                    if ( szOutBuffer[ Bytes - 1 ] != '\n' ) {
                        ClRtlpOutputString( "\n" );
                    }
                }
            }
        }
    }

} // ClRtlpDbgPrint


VOID
ClRtlDbgPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    va_list ArgList;

    va_start(ArgList, FormatString);
    ClRtlpDbgPrint( LogLevel, FormatString, ArgList );
    va_end(ArgList);

} // ClRtlDbgPrint


VOID
ClRtlPrintf(
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

     Just like printf

 Return Value:
     None.

--*/
{
    char buf[128];
    va_list ArgList;

    va_start(ArgList, FormatString);

    _vsnprintf(buf, RTL_NUMBER_OF(buf), FormatString, ArgList);
    buf[ RTL_NUMBER_OF(buf) - 1 ] = 0;

    ClRtlLogPrint( 1, "%1!hs!", buf);

    va_end(ArgList);

} // ClRtlPrintf

DWORD
ClRtlpTruncateFile(
    IN HANDLE FileHandle,
    IN DWORD FileSize,
    IN LPDWORD LastPosition
    )

/*++

Routine Description:

    Truncate a file from the front.

Arguments:

    FileHandle - File handle.

    FileSize - Current End of File.

    LastPosition - Move from this last position to end-of-file to beginning.

Return Value:

    New end of file.

--*/

{
//
// The following buffer size should never be more than 1/4 the size of the
// file.
//
#define BUFFER_SIZE ( 64 * 1024 )
    DWORD   bytesLeft;
    DWORD   endPosition = 0;
    DWORD   bufferSize;
    DWORD   bytesRead;
    DWORD   bytesWritten;
    DWORD   fileSizeHigh = 0;
    DWORD   readPosition;
    DWORD   writePosition;
    PVOID   dataBuffer;


    if ( *LastPosition >= FileSize ) {
        goto error_exit;
    }

    bytesLeft = FileSize - *LastPosition;
    dataBuffer = LocalAlloc( LMEM_FIXED, BUFFER_SIZE );
    if ( !dataBuffer ) {
        goto error_exit;
    }
    endPosition = bytesLeft;

    //
    // Point back to last position for reading.
    //
    readPosition = *LastPosition;
    writePosition = 0;

    while ( bytesLeft ) {
        if ( bytesLeft >= BUFFER_SIZE ) {
            bufferSize = BUFFER_SIZE;
        } else {
            bufferSize = bytesLeft;
        }
        bytesLeft -= bufferSize;
        SetFilePointer( FileHandle,
                        readPosition,
                        &fileSizeHigh,
                        FILE_BEGIN );
        if ( ReadFile( FileHandle,
                       dataBuffer,
                       bufferSize,
                       &bytesRead,
                       NULL ) ) {

            SetFilePointer( FileHandle,
                            writePosition,
                            &fileSizeHigh,
                            FILE_BEGIN );
            WriteFile( FileHandle,
                       dataBuffer,
                       bytesRead,
                       &bytesWritten,
                       NULL );
        } else {
            endPosition = 0;
            break;
        }
        readPosition += bytesRead;
        writePosition += bytesWritten;
    }

    LocalFree( dataBuffer );

error_exit:

    //
    // Force end of file to get set.
    //
    SetFilePointer( FileHandle,
                    endPosition,
                    &fileSizeHigh,
                    FILE_BEGIN );

    SetEndOfFile( FileHandle );

    *LastPosition = endPosition;

    return(endPosition);

} // ClRtlpTruncateFile


VOID
ClRtlLogPrint(
    ULONG   LogLevel,
    PCHAR   FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to a log file.

 Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:

     None.

--*/
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    WCHAR wszInBuffer[LOGENTRY_BUFFER_SIZE];
    WCHAR wszOutBuffer[LOGENTRY_BUFFER_SIZE];
    CHAR  szOutBuffer[LOGENTRY_BUFFER_SIZE];
    DWORD MsgChars;
    DWORD PrefixChars;
    DWORD BytesWritten;
    DWORD FileSize;
    DWORD FileSizeHigh;
    NTSTATUS Status;
    SYSTEMTIME Time;
    ULONG_PTR ArgArray[9];
    va_list ArgList;
    PWCHAR logLabel;
#define CLRTL_LOG_LABEL_LENGTH  5

    //
    // init the variable arg list
    //
    va_start(ArgList, FormatString);

    ClRtlpDbgPrint( LogLevel, FormatString, ArgList );

    if ( !ClRtlPrintToFile ) {
        va_end(ArgList);
        return;
    }

    // begin_wpp config
    // CUSTOM_TYPE(level, ItemListByte(UNK0, ERR_, WARN, INFO) );
    // end_wpp

    //
    // convert nuemric LogLevel to something readable. If you change the
    // labels, make sure all log labels are the same length and that
    // CLRTL_LOG_LABEL_LENGTH reflects the new length.
    //
    switch ( LogLevel ) {
    case LOG_NOISE:
        logLabel = L"INFO ";
        break;

    case LOG_UNUSUAL:
        logLabel = L"WARN ";
        break;

    case LOG_CRITICAL:
        logLabel = L"ERR  ";
        break;

    default:
        ASSERT( 0 );
        logLabel = L"UNKN ";
        break;
    }

    GetSystemTime(&Time);

    ArgArray[0] = ClRtlProcessId;
    ArgArray[1] = GetCurrentThreadId();
    ArgArray[2] = Time.wYear;
    ArgArray[3] = Time.wMonth;
    ArgArray[4] = Time.wDay;
    ArgArray[5] = Time.wHour;
    ArgArray[6] = Time.wMinute;
    ArgArray[7] = Time.wSecond;
    ArgArray[8] = Time.wMilliseconds;

    //
    // length of this format is 43 chars without trailing null under normal
    // circumstances. FormatMessage will write a larger number if given one
    // that doesn't fit within the field width.
    //
    PrefixChars = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 L"%1!08lx!.%2!08lx!::%3!02d!/%4!02d!/%5!02d!-%6!02d!:%7!02d!:%8!02d!.%9!03d! ",
                                 0,
                                 0,
                                 wszOutBuffer,
                                 RTL_NUMBER_OF( wszOutBuffer ),
                                 (va_list*)ArgArray);

    if ( PrefixChars == 0 ) {
        va_end(ArgList);
        WmiTrace("Prefix format failed, %d: %!ARSTR!", GetLastError(), FormatString);
        return;
    }

    //
    // make sure we have some space for the log label and the message
    //
    if (( PrefixChars + CLRTL_LOG_LABEL_LENGTH + 1 ) >= LOGENTRY_BUFFER_SIZE ) {
        va_end(ArgList);
        WmiTrace("Prefix format filled buffer, %!ARSTR!", FormatString);
        return;
    }

    //
    // add on the log label at the end and adjust PrefixChars.
    //
    wcsncat( wszOutBuffer + PrefixChars, logLabel, LOGENTRY_BUFFER_SIZE - PrefixChars );
    PrefixChars += CLRTL_LOG_LABEL_LENGTH;

    // convert the message into unicode
    RtlInitAnsiString( &AnsiString, FormatString );
    UnicodeString.MaximumLength = LOGENTRY_BUFFER_SIZE;
    UnicodeString.Buffer = wszInBuffer;
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        va_end(ArgList);
        WmiTrace("AnsiToUni failed, %x: %!ARSTR!", Status, FormatString);
        return;
    }

    try {
        MsgChars = FormatMessageW(FORMAT_MESSAGE_FROM_STRING,
                                  UnicodeString.Buffer,
                                  0,
                                  0,
                                  &wszOutBuffer[PrefixChars],
                                  RTL_NUMBER_OF( wszOutBuffer ) - PrefixChars,
                                  &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        MsgChars = FormatMessageW(FORMAT_MESSAGE_FROM_STRING
                                  | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                  L"LOGERROR(exception): Could not print message: %1!hs!",
                                  0,
                                  0,
                                  &wszOutBuffer[PrefixChars],
                                  RTL_NUMBER_OF( wszOutBuffer ) - PrefixChars,
                                  (va_list *) &FormatString );
    }
    va_end(ArgList);

    if (MsgChars != 0) {

        // convert the out to Ansi
        UnicodeString.Buffer = wszOutBuffer;
        UnicodeString.Length = ((USHORT) MsgChars + (USHORT) PrefixChars) * sizeof(WCHAR);
        AnsiString.Buffer = szOutBuffer;
        AnsiString.MaximumLength = LOGENTRY_BUFFER_SIZE;
        Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            WmiTrace("UniToAnsi failed, %x: %!ARWSTR!", Status, wszOutBuffer + PrefixChars);
            return;
        }

        ClRtlAcquirePrintLock();

        FileSize = GetFileSize( ClRtlPrintFile,
                                &FileSizeHigh );
        ASSERT( FileSizeHigh == 0 );        // We're only using DWORDs!
        if ( FileSize > ClRtlPrintFileLimit ) {
            FileSize = ClRtlpTruncateFile( ClRtlPrintFile,
                                           FileSize,
                                           &ClRtlPrintFileLoWater );
        }

        SetFilePointer( ClRtlPrintFile,
                        FileSize,
                        &FileSizeHigh,
                        FILE_BEGIN );
        if ( ClRtlCheckForLogCorruption( AnsiString.Buffer ) )
        {
#if defined(ENCRYPT_TEXT_LOG)
            int i;
            for (i = 0; i < AnsiString.Length; ++i) {
                AnsiString.Buffer[i] ^= 'a';
            }
#endif
            WriteFile(ClRtlPrintFile,
                      AnsiString.Buffer,
                      AnsiString.Length,
                      &BytesWritten,
                      NULL);
#if defined(ENCRYPT_TEXT_LOG)
            for (i = 0; i < AnsiString.Length; ++i) {
                AnsiString.Buffer[i] ^= 'a';
            }
#endif
        }
        else
        {
            MsgChars = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      "LOGERROR: non-ASCII characters in formatted message: %1!hs!",
                                      0,
                                      0,
                                      &szOutBuffer[PrefixChars],
                                      RTL_NUMBER_OF( szOutBuffer ) - PrefixChars,
                                      (va_list *) &FormatString );

            if ( MsgChars > 0 ) {
                WriteFile(ClRtlPrintFile,
                          szOutBuffer,
                          PrefixChars + MsgChars,
                          &BytesWritten,
                          NULL);

                if ( szOutBuffer[ PrefixChars + MsgChars - 1 ] != '\n' ) {
                    WriteFile(ClRtlPrintFile,
                              "\n",
                              1,
                              &BytesWritten,
                              NULL);
                }

                RtlInitAnsiString( &AnsiString, szOutBuffer );
            }
        }

        if ( (ClRtlPrintFileLoWater == 0) &&
             (FileSize > (ClRtlPrintFileLimit / 2)) ) {
            ClRtlPrintFileLoWater = FileSize + BytesWritten;
        }

        ClRtlReleasePrintLock();

        WmiTrace("%!level! %!ARSTR!", *(UCHAR*)&LogLevel, AnsiString.Buffer + PrefixChars);
/*
#if defined(WMI_TRACING)
        if (ClRtlWml.Trace && ClRtlWmiReg.EnableFlags) {
            ClRtlWml.Trace(10, &ClRtlTraceGuid, ClRtlWmiReg.LoggerHandle,
                LOG(UINT, ClRtlProcessId)
                LOGASTR(AnsiString.Buffer + PrefixChars)
                0);
        }
#endif // defined(WMI_TRACING)
 */
    } else {
        WmiTrace("Format returned 0 bytes: %!ARSTR!", FormatString);
    }
    return;
} // ClRtlLogPrint


VOID
ClRtlpFlushLogBuffers(
    VOID
    )

/*++

Routine Description:

    Flush the cluster log file

Arguments:

    none

Return Value:

    none

--*/

{
    FlushFileBuffers( ClRtlPrintFile );
}

DWORD
ClRtlCreateDirectory(
    IN LPCWSTR lpszPath
    )
/*++

Routine Description:

    Creates a directory creating any subdirectories as required. Allows the
    following forms:

    [drive:][\]dir[\dir...]
    \\?\drive:\dir[\dir...]
    \\?\unc\server\share\dir[\dir...]
    \\server\share\dir[\dir...]

Arguments:

    lpszPath - Supplies the path to the directory.  It may or
               may not be terminated by a back slash.

Return Value:

    ERROR_SUCCESS if successful, else the error code.

--*/
{
    WCHAR   backSlash = L'\\';
    WCHAR   fwdSlash = L'/';
    DWORD   dwLen;
    LPWSTR  pszNext = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   expandedPathPrefix[] = L"\\\\?\\";
    WCHAR   uncPrefix[] = L"\\\\?\\UNC\\";
    DWORD   slashSkipCount = 0;
    PWCHAR  p;
    LPWSTR  dirPath = (LPWSTR)lpszPath;
    BOOL    charsAfterSlash = FALSE;

    //
    // get input string length and validate that we have a string worth using
    //
    dwLen = lstrlenW( lpszPath );
    if ( !lpszPath || dwLen == 0 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // find the first slash after the first dir spec past the "root". The
    // input string can have a number of different forms at the beginning, so
    // we look for them first.
    //
    // check for a double backslash sequence at the beginning of the
    // string. This could be an SMB path (\\server\share), a expanded storage
    // path (\\?\c:\...) or a UNC path (\\?\UNC\server\share\...)
    //
    if ( dwLen > 2 && dirPath[0]== L'\\' && dirPath[1] == L'\\')
    {
        //
        // is it expanded storage or UNC?
        //
        if (dwLen >= RTL_NUMBER_OF( expandedPathPrefix )
            &&
            wcsncmp( dirPath, expandedPathPrefix, RTL_NUMBER_OF( expandedPathPrefix ) - 1 ) == 0 )
        {
            //
            // now see if it is a UNC name
            //
            if (dwLen >= RTL_NUMBER_OF( uncPrefix )
                &&
                ClRtlStrNICmp( dirPath, uncPrefix, RTL_NUMBER_OF( uncPrefix ) - 1 ) == 0 )
            {
                //
                // skip to end of "\\?\UNC\server\share\xxx\"
                //
                slashSkipCount = 7;
            }
            else
            {
                //
                // it's a expanded storage path. skip to end of \\?\c:\xxx\
                //
                slashSkipCount = 5;
            }
        }
        else
        {
            //
            // it looks like an SMB path; skip to end of \\server\share\xxx\
            //
            slashSkipCount = 5;
        }
    }
    else
    {
        //
        // it should be a normal file path but it could relative or fully
        // qualified, with or without a drive letter. All that really matters
        // is whether there is a slash before the first dir spec. If there is,
        // then skip to the 2nd slash otherwise skip to the first slash.
        //
        if ( dirPath[0] == backSlash || dirPath[0] == fwdSlash )
        {
            //
            // skip to end of \xxx\
            //
            slashSkipCount = 2;
        }
        else if ( dwLen > 1 && dirPath[1] == L':' )
        {
            //
            // might be fully qualified path; check for slash in slot 2
            //
            if ( dwLen > 2 && ( dirPath[2] == L'\\' || dirPath[2] == L'/' )) {
                //
                // skip to end of c:\xxx\
                //
                slashSkipCount = 2;
            } else {
                //
                // skip to the end of c:xxx\
                //
                slashSkipCount = 1;
            }
        }
        else
        {
            //
            // no colon in slot 1 so must be a relative path with no drive
            // letter
            //
            slashSkipCount = 1;
        }
    }

    //
    // get pszNext to point to the appropriate slash; this allows for mixed
    // fwd and bwd slashes which is pretty sick but...
    //
    if ( slashSkipCount > 0 )
    {
        pszNext = dirPath;

        while ( *pszNext != UNICODE_NULL ) {
            if ( *pszNext == backSlash || *pszNext == fwdSlash ) {
                charsAfterSlash = FALSE;
                if ( --slashSkipCount == 0 ) {
                    break;
                }
            } else {
                charsAfterSlash = TRUE;
            }

            ++pszNext;
        }
    } else {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // check that we found all the slashes. If we're missing one slash but
    // we're sitting at the end of the string, then that is the same as
    // finding a slash
    //
    if ( !( slashSkipCount == 0 || ( charsAfterSlash && slashSkipCount == 1 ))) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // run down the directory path, inserting a NULL at every slash and call
    // CreateDirectory to create that portion of the path
    //
    while ( pszNext)
    {
        DWORD_PTR   dwptrLen;
        WCHAR       oldSlash;

        dwptrLen = pszNext - dirPath;

        dwLen = (DWORD)dwptrLen;
        oldSlash = dirPath[ dwLen ];
        dirPath[ dwLen ] = UNICODE_NULL;

        if (!CreateDirectory(dirPath, NULL))
        {
            dwError = GetLastError();
            if (dwError == ERROR_ALREADY_EXISTS)
            {
                DWORD fileAttrs;

                //
                // make sure it is a directory
                //
                fileAttrs = GetFileAttributes( dirPath );
                if ( fileAttrs != INVALID_FILE_ATTRIBUTES )
                {
                    if ( fileAttrs & FILE_ATTRIBUTE_DIRECTORY )
                    {
                        dwError = ERROR_SUCCESS;
                    }
                    else
                    {
                        dwError = ERROR_FILE_EXISTS;
                    }
                }
                else
                {
                    dwError = ERROR_FILE_EXISTS;
                }
            }

            if ( dwError != ERROR_SUCCESS )
            {
                ClRtlDbgPrint(LOG_CRITICAL,
                              "[ClRtl] CreateDirectory Failed on %1!ws!. Error %2!u!\n",
                              dirPath, dwError);
            }
        }

        dirPath[ dwLen ] = oldSlash;

        //
        // bail out if we hit an error or we're at the end of the input string
        //
        if ( dwError != ERROR_SUCCESS || *pszNext == UNICODE_NULL ) {
            break;
        }

        p = pszNext + 1;
        while ( *p != backSlash && *p != fwdSlash && *p != UNICODE_NULL )
            ++p;

        pszNext = p;
    }

    return(dwError);
}





BOOL
WINAPI
ClRtlIsPathValid(
    LPCWSTR  Path
    )

/*++

Routine Description:

    Returns true if the given path looks syntactically valid.

    This call is NOT network-aware.

Arguments:

    Path - String containing a path.

Return Value:

    TRUE if the path looks valid, otherwise FALSE.

--*/

{
    WCHAR   chPrev;
    WCHAR   chCur;
    DWORD   charCount = 0;
#ifdef    DBCS
    BOOL    fPrevLead = FALSE;
#endif

    CL_ASSERT(Path);
    CL_ASSERT(!*Path || !iswspace(*Path));        // no leading whitespace

    if ( iswalpha(*Path) && *(Path+1) == L':' ) {
        Path += 2;
    }

    chCur = *Path;
    chPrev = 0;

    while (chCur) {
        charCount++;
        if ( charCount > MAX_PATH ) {
            return(FALSE);
        }
#ifdef    DBCS
        if (fPrevLead) {
            fPrevLead = FALSE;
            chPrev = 0;
        } else {
            fPrevLead = IsDBCSLeadByte(chCur);
#endif    // DBCS

            switch ( chCur ) {

            // Explicit invalid characters
            case L'*' :
            case L';' :
            case L',' :
            case L'=' :
            case L'?' :
            case L'<' :
            case L'>' :
            case L'|' :
            case L':' :             // no ":" except as second char
                return(FALSE);      // no ":" allowed other than second char */

#if 0   // The following should be okay
            case L'\\' :
                if ( chPrev == chDirSep ) {
                    return(FALSE);  // no double "\\" in middle - but legal
                }
                break;
#endif

            default:
#if 0   // accept anything else for now
                if ( !iswalnum( chCur ) ) {
                    return(FALSE);
                }
#endif
                break;
            }

            chPrev = chCur;

#ifdef    DBCS
        }
#endif

        chCur = *(++Path);
    }

#ifdef    DBCS
    if (fPrevLead)
        return(FALSE);    // ends w/ lead byte
#endif

    return(TRUE);

} // ClRtlIsPathValid


/****
@func       DWORD | ClRtlGetClusterDirectory | Get the directory in which
            the cluster service is installed

@parm       IN LPWSTR | lpBuffer | Supplies the buffer in which the
            directory path is to be copied.

@parm       IN DWORD | dwBufSize | Supplies the size of the buffer.

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.
****/
DWORD
ClRtlGetClusterDirectory(
    IN LPWSTR   lpBuffer,
    IN DWORD    dwBufSize
    )
{
    DWORD           dwLen;
    DWORD           dwStatus;
    LPWSTR          szRegKeyName = NULL;
    HKEY            hClusSvcKey = NULL;
    LPWSTR          lpImagePath = NULL;
    WCHAR           *pTemp = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //
    if ( lpBuffer == NULL )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc
    //
    dwLen = lstrlenW( CLUSREG_KEYNAME_CLUSSVC_PARAMETERS );
    szRegKeyName = (LPWSTR) LocalAlloc ( LMEM_FIXED,
                                    ( dwLen + 1 ) *
                                    sizeof ( WCHAR ) );
    if ( szRegKeyName == NULL )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    dwLen -= lstrlenW( CLUSREG_KEYNAME_PARAMETERS );

    lstrcpyW( szRegKeyName, CLUSREG_KEYNAME_CLUSSVC_PARAMETERS );
    szRegKeyName [dwLen-1] = L'\0';

    if ( ( dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                                 szRegKeyName,
                                 &hClusSvcKey ) ) != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    lstrcpyW ( szRegKeyName, L"ImagePath" );
    //
    //  Try to query the clussvc key. If the ImagePath
    //  value is present, then get the length of the image
    //  path
    //
    dwLen = 0;
    if ( ( dwStatus = ClRtlRegQueryString( hClusSvcKey,
                                           szRegKeyName,
                                           REG_EXPAND_SZ,
                                           &lpImagePath,
                                           &dwLen,
                                           &dwLen ) ) != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    //
    //  Now expand any environment strings present in the
    //  ImagePath
    //
    if ( ( dwLen = ExpandEnvironmentStringsW( lpImagePath,
                                              lpBuffer,
                                              dwBufSize ) ) == 0 )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //
    //  If the caller-supplied buffer is not big enough to hold the
    //  path value, then return an error
    //
    if ( dwLen > dwBufSize )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    //  Replace the last '\\' character in the image path with
    //  a NULL character
    //
    pTemp = wcsrchr( lpBuffer, L'\\' );
    if ( pTemp != NULL )
    {
        *pTemp = L'\0';
    } else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

FnExit:
    LocalFree( szRegKeyName );
    if( hClusSvcKey != NULL )
    {
        RegCloseKey( hClusSvcKey );
    }
    LocalFree( lpImagePath );

    return( dwStatus );
} // ClRtlGetClusterDirectory

BOOL
ClRtlGetDriveLayoutTable(
    IN  HANDLE hDisk,
    OUT PDRIVE_LAYOUT_INFORMATION * DriveLayout,
    OUT PDWORD InfoSize OPTIONAL
    )

/*++

Routine Description:

    Get the partition table for a drive. If the buffer is not large enough,
    then realloc until we get the right sized buffer. This routine is not in
    disk.cpp since that causes additional symbols to be defined.

Arguments:

    hDisk - handle to a file on the partition

    DriveLayout - address of pointer that points to

    InfoSize - address of dword that receives size of partition table

Return Value:

    TRUE if everything went ok

--*/

{
    DWORD dwSize = 0;
    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;
    DWORD status = ERROR_INSUFFICIENT_BUFFER;
    DWORD partitionCount = 4;
    DWORD layoutSize;

    while ( status == ERROR_INSUFFICIENT_BUFFER
         || status == ERROR_BAD_LENGTH
          )
    {

        layoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                     (sizeof(PARTITION_INFORMATION) * partitionCount);
        if ( layoutSize > 2<<16 ) {
            break;
        }

        driveLayout = (PDRIVE_LAYOUT_INFORMATION)LocalAlloc( LMEM_FIXED, layoutSize );
        if ( driveLayout == NULL ) {
            break;
        }

        if (DeviceIoControl(hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            driveLayout,
                            layoutSize,
                            &dwSize,
                            NULL))
        {
            status = ERROR_SUCCESS;
            break;
        } else {
            status = GetLastError();
            LocalFree( driveLayout );
            driveLayout = NULL;
            partitionCount *= 2;
        }
    }

    *DriveLayout = driveLayout;
    if ( ARGUMENT_PRESENT( InfoSize )) {
        *InfoSize = dwSize;
    }

    return status == ERROR_SUCCESS ? TRUE : FALSE;

} // ClRtlGetDriveLayoutTable


BOOL
ClRtlPathFileExists(
    LPWSTR pwszPath
    )
/*++

Routine Description:

    Determines if a file/directory exists.  This is fast.

Arguments:

    pwszPath - Path to validate.

Return Value:

    TRUE if it exists, otherwise FALSE.

    NOTE: This was borrowed from SHLWAPI.

--*/
{
    DWORD dwErrMode;
    BOOL fResult;

    dwErrMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    fResult = ( (UINT) GetFileAttributes( pwszPath ) != (UINT) -1 );

    SetErrorMode( dwErrMode );

    return fResult;

}


DWORD
SetClusterFailureInformation(
    LPWSTR  NodeName OPTIONAL,
    DWORD   ResetPeriod,
    LONG    RetryCount,
    DWORD   RetryInterval
    )

/*++

Routine Description:

    Set the SC failure parameters for the cluster service.

Arguments:

    The args are loosely similar to the members of the SERVICE_FAILURE_ACTIONS
    structure. If RetryCount equals -1, then we set up a series of actions
    where the SC will exponentially back off restarting the service until it
    reaches 5 minutes, where it will continue to retry forever (well, until
    something good or bad happens). Otherwise, if RetryCount is positive, then
    we'll retry that many times (and zero is a valid number of retries) still
    using the same back off technique.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD status;
    BOOL success;
    HANDLE schSCManager;
    HANDLE serviceHandle;
    SERVICE_FAILURE_ACTIONS failureData;
    LPSC_ACTION failureActions;
    LONG i;
    BOOL tryForever = FALSE;

    CL_ASSERT( RetryCount >= -1 && RetryCount <= CLUSTER_FAILURE_MAX_STARTUP_RETRIES );

    ++RetryCount;   // add one more for the final action
    if ( RetryCount == 0 ) {
        DWORD tempInterval = RetryInterval;

        //
        // count the entries we need to go from our initial retry interval to
        // the final (longest) retry interval.
        //
        while ( tempInterval < CLUSTER_FAILURE_FINAL_RETRY_INTERVAL ) {
            tempInterval *= 2;
            ++RetryCount;
        }

        ++RetryCount;
        tryForever = TRUE;
    }
    CL_ASSERT( RetryCount > 0 );

    //
    // open the SC mgr and the service
    //

    schSCManager = OpenSCManager(NodeName,
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS); // access required

    if ( schSCManager ) {
        serviceHandle = OpenService(schSCManager,
                                    CLUSTER_SERVICE_NAME,
                                    SERVICE_ALL_ACCESS);

        if ( serviceHandle ) {

            failureActions = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                         RetryCount * sizeof( SC_ACTION ));
            if ( failureActions != NULL ) {

                //
                // build a list that exponentially backs off but does
                // exactly the number of retries that were specified.
                //

                for ( i = 0; i < RetryCount-1; ++i ) {
                    failureActions[i].Type = SC_ACTION_RESTART;
                    failureActions[i].Delay = RetryInterval;

                    RetryInterval = RetryInterval * 2;
                    if ( RetryInterval > CLUSTER_FAILURE_FINAL_RETRY_INTERVAL ) {
                        RetryInterval = CLUSTER_FAILURE_FINAL_RETRY_INTERVAL;
                    }
                }

                if ( tryForever ) {
                    failureActions[i].Type = SC_ACTION_RESTART;
                    failureActions[i].Delay = RetryInterval;
                } else {
                    failureActions[i].Type = SC_ACTION_NONE;
                    failureActions[i].Delay = 0;
                }

                failureData.dwResetPeriod = ResetPeriod;
                failureData.lpRebootMsg = NULL;
                failureData.lpCommand = NULL;
                failureData.cActions = RetryCount;
                failureData.lpsaActions = failureActions;

                success = ChangeServiceConfig2(serviceHandle,
                                               SERVICE_CONFIG_FAILURE_ACTIONS,
                                               &failureData);
                LocalFree( failureActions );

                if ( success ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = GetLastError();
                    ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't set SC failure info %1!u!\n", status);
                }
            } else {
                status = ERROR_OUTOFMEMORY;
                ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't allocate memory to set SM Failure actions\n");
            }

            CloseServiceHandle( serviceHandle );
        } else {
            status = GetLastError();
            ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't get SC handle to Cluster Service %1!u!\n", status);
        }

        CloseServiceHandle( schSCManager );
    } else {
        status = GetLastError();
        ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't get a handle to the SC Manager %1!u!\n", status);
    }

    return status;
} // SetClusterFailureInformation

DWORD
ClRtlSetSCMFailureActions(
    LPWSTR NodeName OPTIONAL
    )

/*++

Routine Description:

    Set the service controller failure parameters for the cluster service.

Arguments:

    NodeName - pointer to string that identifies on which node to modify the
    settings. NULL indicates the local node.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD Status;

    //
    // during startup, we start with a short retry period and then
    // exponentially back off. Set the reset period to 30 minutes.
    //
    Status = SetClusterFailureInformation(NodeName,
                                          30 * 60,
                                          CLUSTER_FAILURE_RETRY_COUNT,
                                          CLUSTER_FAILURE_INITIAL_RETRY_INTERVAL);

    if ( Status != ERROR_SUCCESS ) {
        ClRtlDbgPrint(LOG_CRITICAL,
                      "[ClRtl] Couldn't set SC startup failure info %1!u!\n",
                      Status);
    }

    return Status;
} // ClRtlSetSCMFailureActions


DWORD
ClRtlGetRunningAccountInfo(
    LPWSTR *    AccountBuffer
    )

/*++

Routine Description:

    Get the calling thread's token to obtain account info. It is returned in
    an allocated buffer in the form of "domain\user". Caller is responsible
    for freeing the buffer.

Arguments:

    AccountBuffer - address of pointer to receive allocated buffer

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    HANDLE          currentToken;
    PTOKEN_USER     tokenUserData;
    DWORD           sizeRequired;
    BOOL            success;
    DWORD           status = ERROR_SUCCESS;
    DWORD           accountNameSize = 128;
    LPWSTR          accountName;
    DWORD           domainNameSize = DNS_MAX_NAME_BUFFER_LENGTH;
    LPWSTR          domainName;
    SID_NAME_USE    sidType;
    DWORD           nameSize = 0;
    HMODULE         secur32Handle;
    FARPROC         getUserNameEx;
    INT_PTR         returnValue;

    //
    // initialize in case the caller doesn't check the return status (tsk, tsk!)
    //
    *AccountBuffer = NULL;

    //
    // rather than link in yet another DLL, we'll load secur32 dynamically and
    // get a pointer to GetUserNameEx.
    //
    secur32Handle = LoadLibraryW( L"secur32.dll" );
    if ( secur32Handle ) {
        getUserNameEx = GetProcAddress( secur32Handle, "GetUserNameExW" );
        if ( getUserNameEx ) {
            //
            // get the length the first time, allocate a buffer and then get the data
            //
            returnValue = (*getUserNameEx)( NameSamCompatible, NULL, &nameSize );
            success = (BOOL)returnValue;

            *AccountBuffer = LocalAlloc( LMEM_FIXED, nameSize * sizeof( WCHAR ));
            if ( *AccountBuffer != NULL ) {

                returnValue = (*getUserNameEx)( NameSamCompatible, *AccountBuffer, &nameSize );
                success = (BOOL)returnValue;
                if ( !success ) {
                    status = GetLastError();
                }
            }
            else {
                status = GetLastError();
            }
        } else {
            status = GetLastError();
        }

        FreeLibrary( secur32Handle );
    }
    else {
        status = GetLastError();
    }

    return status;

#if 0
    //
    // check if there is a thread token
    //
    if (!OpenThreadToken(GetCurrentThread(),
                         MAXIMUM_ALLOWED,
                         TRUE,
                         &currentToken))
    {
        // get the process token
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &currentToken )) {
            return GetLastError();
        }
    }

    //
    // get the size needed
    //
    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  NULL,
                                  0,
                                  &sizeRequired);

    tokenUserData = LocalAlloc( LMEM_FIXED, sizeRequired );
    if ( tokenUserData == NULL ) {
        CloseHandle( currentToken );
        return GetLastError();
    }

    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  tokenUserData,
                                  sizeRequired,
                                  &sizeRequired);

    if ( !success ) {
        CloseHandle( currentToken );
        return GetLastError();
    }

    do {
        //
        // make initial allocs for account and domain name; 1 more byte to
        // hold slash separator. domain buffer holds the complete
        // 'domain\user' entry so it gets more space
        //
        domainName = LocalAlloc( LMEM_FIXED,
                                     (accountNameSize + domainNameSize + 1) * sizeof(WCHAR) );
        accountName = (LPWSTR) LocalAlloc( LMEM_FIXED, accountNameSize * sizeof(WCHAR) );

        if ( accountName == NULL || domainName == NULL ) {
            if ( accountName != NULL ) {
                LocalFree( accountName );
            }

            if ( domainName != NULL ) {
                LocalFree( domainName );
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Attempt to Retrieve the account and domain name. If
        // LookupAccountName fails because of insufficient buffer size(s)
        // accountNameSize and domainNameSize will be correctly set for the
        // next attempt.
        //
        if ( LookupAccountSid(NULL,
                              tokenUserData->User.Sid,
                              accountName,
                              &accountNameSize,
                              domainName,
                              &domainNameSize,
                              &sidType ))
        {
            wcscat( domainName, L"\\" );
            wcscat( domainName, accountName );
            *AccountBuffer = domainName;
        }
        else {
            // free the account name buffer and find out why we failed
            LocalFree( domainName );

            status = GetLastError();
        }

        //
        // domain buffer holds complete string so we can lose the account name
        // at this point
        //
        LocalFree( accountName );
        accountName = NULL;

    } while ( status == ERROR_INSUFFICIENT_BUFFER );

    return status;
#endif

} // ClRtlGetRunningAccountInfo

#if 0
//
// no longer needed. Keep it around just in case
//
DWORD
ClRtlGetServiceAccountInfo(
    LPWSTR *    AccountBuffer
    )

/*++

Routine Description:

    Query SCM for the cluster service account info. It is returned in an
    allocated buffer in the form of "domain\user". Caller is responsible for
    freeing the buffer.

Arguments:

    AccountBuffer - address of pointer to receive allocated buffer

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD status = ERROR_SUCCESS;
    HANDLE schSCManager;
    HANDLE serviceHandle = NULL;
    LPQUERY_SERVICE_CONFIG scConfigData = NULL;
    ULONG bytesNeeded;
    BOOL success;

    //
    // open a handle to the service controller manager to query the account
    // under which the cluster service was started
    //

    schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS); // access required

    if ( schSCManager == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    serviceHandle = OpenService(schSCManager,
                                CLUSTER_SERVICE_NAME,
                                SERVICE_ALL_ACCESS);

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    success = QueryServiceConfig(serviceHandle, NULL, 0, &bytesNeeded);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    scConfigData = LocalAlloc( LMEM_FIXED, bytesNeeded );
    if ( scConfigData == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    success = QueryServiceConfig(serviceHandle,
                                 scConfigData,
                                 bytesNeeded,
                                 &bytesNeeded);
    if ( !success ) {
        status = GetLastError();
        goto error_exit;
    }

    *AccountBuffer = LocalAlloc(LMEM_FIXED,
                                (wcslen( scConfigData->lpServiceStartName ) + 1 ) * sizeof(WCHAR));

    if ( *AccountBuffer == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    wcscpy( *AccountBuffer, scConfigData->lpServiceStartName );

error_exit:
    if ( serviceHandle != NULL ) {
        CloseServiceHandle( serviceHandle );
    }

    if ( schSCManager != NULL ) {
        CloseServiceHandle( schSCManager );
    }

    if ( scConfigData != NULL ) {
        LocalFree( scConfigData );
    }

    return status;
} // ClRtlGetServiceAccountInfo
#endif

BOOL
ClRtlCopyFileAndFlushBuffers(
    IN LPCWSTR lpszSourceFile,
    IN LPCWSTR lpszDestinationFile
    )
/*++

Routine Description:

    Copy a source file to a destination file and flush the destination file buffers.

Arguments:

    lpszSourceFile - The source file name.

    lpszDestinationFile - The destination file name.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Copy the file, block until completed. Note that CopyFile family of APIs do not flush the metadata or
    //  the data. So, we need to do that explicitly here.
    //
    if ( !CopyFileEx( lpszSourceFile,       // Source file
                      lpszDestinationFile,  // Destination file
                      NULL,                 // Progress routine
                      NULL,                 // Callback parameter
                      NULL,                 // Cancel status
                      0 ) )                 // Copy flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CLRTL] ClRtlCopyFileAndFlushBuffers:: Failed to copy %1!ws! to %2!ws!, Status=%3!u!\n",
                      lpszSourceFile,
                      lpszDestinationFile,
                      dwStatus);
        goto FnExit;
    }

    //
    //  Open the newly created destination file
    //
    hFile =  CreateFile( lpszDestinationFile,                   // File name
                         GENERIC_READ | GENERIC_WRITE,          // Access mode
                         0,                                     // Share mode
                         NULL,                                  // Security attribs
                         OPEN_EXISTING,                         // Creation disposition
                         FILE_ATTRIBUTE_NORMAL,                 // Flags and attributes
                         NULL );                                // Template file

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CLRTL] ClRtlCopyFileAndFlushBuffers: Failed to open file %1!ws!, Status=%2!u!...\n",
                      lpszDestinationFile,
                      dwStatus);
        goto FnExit;
    }

    //
    //  Flush the file buffers to avoid corrupting the file on a power failure.
    //
    if ( !FlushFileBuffers( hFile ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CLRTL] ClRtlCopyFileAndFlushBuffers: Failed to flush buffers for %1!ws!, Status=%2!u!...\n",
                      lpszDestinationFile,
                      dwStatus);
        goto FnExit;
    }

FnExit:
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle ( hFile );
    }

    if ( dwStatus != ERROR_SUCCESS )
    {
        SetLastError( dwStatus );
        return ( FALSE );
    } else
    {
        return ( TRUE );
    }
}// ClRtlCopyFileAndFlushBuffers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\fixup.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FixUp.c

Abstract:

    This module contains common security routines for
    NT Clusters rolling upgrade and backward compatibility.

Author:

    Galen Barbee (galenb) 31-Mar-1998

--*/

#include "clusrtlp.h"

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT4Format(
	IN PSECURITY_DESCRIPTOR psd
	)

/*++

Routine Description:

		Convert the SD from nt 5 to nt 4 format.  This means enforcing the
		following rules:

		1. Convert denied ACE to allowed ACE.  Convert "Full Control" access
		mask to CLUAPI_NO_ACCESS.

Arguments:

		psd			[IN] Security descriptor.

Return Value:

		The new SD in self-Relative format

--*/

{
    PACL	                pacl;
    BOOL	                bHasDACL;
    BOOL	                bDACLDefaulted;
    PSECURITY_DESCRIPTOR	psec = NULL;

    if (NULL == psd) {
    	return NULL;
    }

    psec = ClRtlCopySecurityDescriptor(psd);

    if ( psec == NULL ) {
        return NULL;
    }

    if ( (GetSecurityDescriptorDacl(psec, (LPBOOL) &bHasDACL, (PACL *) &pacl, (LPBOOL) &bDACLDefaulted)) &&
         ( bHasDACL != FALSE ) ) {

	    ACL_SIZE_INFORMATION	asiAclSize;
	    DWORD					dwBufLength;

	    dwBufLength = sizeof(asiAclSize);

	    if (GetAclInformation(pacl, &asiAclSize, dwBufLength, AclSizeInformation)) {

		    ACCESS_DENIED_ACE *	pAce;
            DWORD               dwIndex;

		    for (dwIndex = 0; dwIndex < asiAclSize.AceCount;  dwIndex++) {

		        if (GetAce(pacl, dwIndex, (LPVOID *) &pAce)) {

					if (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)	{

						if (pAce->Mask & SPECIFIC_RIGHTS_ALL) {
							pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
							pAce->Mask = CLUSAPI_NO_ACCESS;
						}

					} // end if (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)

				} // end if (GetAce())

			} // end for

	    } // end if (GetAclInformation())

	} // end if (HrGetSecurityDescriptorDacl()) and DACL is present

	ASSERT(IsValidSecurityDescriptor(psec));

	return psec;

}  //*** ClRtlConvertClusterSDToNT4Format()

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT5Format(
	IN PSECURITY_DESCRIPTOR psd
	)

/*++

Routine Description:

		Convert the SD from nt 5 to nt 4 format.  This means enforcing the
		following rules:

		1. Convert allowed ACE with mask CLUAPI_NO_ACCESS to denied ACE mask full control.

Arguments:

		psd			[IN] Security descriptor.

Return Value:

		The new SD in self-Relative format

--*/

{
    PACL	pacl;
    BOOL	bHasDACL;
    BOOL	bDACLDefaulted;
    PSECURITY_DESCRIPTOR	psec = NULL;

    if (NULL == psd) {
    	return NULL;
    }

    psec = ClRtlCopySecurityDescriptor(psd);

    if ( psec == NULL ) {
        return NULL;
    }

    if ( (GetSecurityDescriptorDacl(psec, (LPBOOL) &bHasDACL, (PACL *) &pacl, (LPBOOL) &bDACLDefaulted)) &&
         ( bHasDACL != FALSE ) ) {

	    ACL_SIZE_INFORMATION	asiAclSize;
	    DWORD					dwBufLength;

	    dwBufLength = sizeof(asiAclSize);

	    if (GetAclInformation(pacl, &asiAclSize, dwBufLength, AclSizeInformation)) {

		    ACCESS_DENIED_ACE *	pAce;
            DWORD               dwIndex;

		    for (dwIndex = 0; dwIndex < asiAclSize.AceCount;  dwIndex++) {

		        if (GetAce(pacl, dwIndex, (LPVOID *) &pAce)) {

					if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) {

						if (pAce->Mask & CLUSAPI_NO_ACCESS)	{
							pAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
							pAce->Mask = SPECIFIC_RIGHTS_ALL;
						}

					} // end if (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)

				} // end if (GetAce())

			} // end for

	    } // end if (GetAclInformation())

	} // end if (HrGetSecurityDescriptorDacl()) and DACL is present

	ASSERT(IsValidSecurityDescriptor(psec));

	return psec;

}  //*** ClRtlConvertClusterSDToNT5Format()

static GENERIC_MAPPING gmFileShareMap =
{
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};

#define SPECIFIC_CHANGE     (DELETE | FILE_GENERIC_WRITE)
#define SPECIFIC_READ       (FILE_GENERIC_READ | FILE_LIST_DIRECTORY | FILE_EXECUTE)
#define GENERIC_CHANGE      (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE)

PSECURITY_DESCRIPTOR
ClRtlConvertFileShareSDToNT4Format(
	IN PSECURITY_DESCRIPTOR psd
	)

/*++

Routine Description:

		Convert the SD from nt 5 to nt 4 format.  This means enforcing the
		following rules:

Arguments:

		psd			[IN] Security descriptor.

Return Value:

		The new SD in self-Relative format

--*/

{
    PACL	                pacl;
    BOOL	                bHasDACL;
    BOOL	                bDACLDefaulted;
    PSECURITY_DESCRIPTOR	psec = NULL;

    if (NULL == psd) {
    	return NULL;
    }

    psec = ClRtlCopySecurityDescriptor(psd);

    if ( psec == NULL ) {
        return NULL;
    }

    if ( (GetSecurityDescriptorDacl(psec, (LPBOOL) &bHasDACL, (PACL *) &pacl, (LPBOOL) &bDACLDefaulted)) &&
         ( bHasDACL != FALSE ) ) {

	    ACL_SIZE_INFORMATION	asiAclSize;
	    DWORD					dwBufLength;
        ACCESS_MASK             amTemp1;
        ACCESS_MASK             amTemp2;

	    dwBufLength = sizeof(asiAclSize);

	    if (GetAclInformation(pacl, &asiAclSize, dwBufLength, AclSizeInformation)) {

		    ACCESS_DENIED_ACE *	pAce;
			DWORD				dwSid;
            DWORD               dwIndex;

		    for (dwIndex = 0; dwIndex < asiAclSize.AceCount;  dwIndex++) {

                amTemp1 = 0;
                amTemp2 = 0;

		        if (GetAce(pacl, dwIndex, (LPVOID *) &pAce)) {

					// delete deny read ACEs since they don't mean anything to AclEdit
					if ((pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
					   (pAce->Mask == SPECIFIC_READ)) {

						dwSid = pAce->SidStart;

                        if (DeleteAce(pacl, dwIndex)) {
                            asiAclSize.AceCount -= 1;
                            dwIndex -= 1;
                        }
                        else {
                            ClRtlDbgPrint(LOG_UNUSUAL,
                                          "[ClRtl] DeteteAce failed removing ACE #%1!d! due to error %2!d!\n",
                                          dwIndex,
                                          GetLastError());
                        }

                        continue;
                    }

					// convert deny change deny read ACEs to deny all ACEs
					if ((pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
					   (pAce->Mask == (SPECIFIC_CHANGE | SPECIFIC_READ))) {
                        pAce->Mask = GENERIC_ALL;
                        continue;
                    }

					// convert deny change ACEs to allow read (read only) ACEs
					if ((pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
					   (pAce->Mask == SPECIFIC_CHANGE)) {
                        pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
                        pAce->Mask = GENERIC_READ | GENERIC_EXECUTE;
                        continue;
                    }

					// convert specific allow change to generic allow change
					if ((pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) &&
					   (pAce->Mask == SPECIFIC_CHANGE)) {
                        pAce->Mask = GENERIC_CHANGE;
                        continue;
                    }

					// convert specific all to generic all
                    if ((pAce->Mask & gmFileShareMap.GenericAll) == gmFileShareMap.GenericAll) {
                        amTemp1 |= GENERIC_ALL;
                        amTemp2 |= gmFileShareMap.GenericAll;
                    }
                    else {


						// convert specific read to generic read
                        if ((pAce->Mask & gmFileShareMap.GenericRead) == gmFileShareMap.GenericRead) {
                            amTemp1 |= GENERIC_READ;
                            amTemp2 |= gmFileShareMap.GenericRead;
                        }

						// convert specific write to generic write which includes delete
                        if ((pAce->Mask & gmFileShareMap.GenericWrite) == gmFileShareMap.GenericWrite) {
                            amTemp1 |= (GENERIC_WRITE | DELETE);
                            amTemp2 |= gmFileShareMap.GenericWrite;
                        }

						// convert specific execute to generic execute
                        if ((pAce->Mask & gmFileShareMap.GenericExecute) == gmFileShareMap.GenericExecute) {
                            amTemp1 |= GENERIC_EXECUTE;
                            amTemp2 |= gmFileShareMap.GenericExecute;
                        }
                    }

                    pAce->Mask &= ~amTemp2;   // turn off specific bits
                    pAce->Mask |= amTemp1;    // turn on generic bits
				} // end if (GetAce())

			} // end for

	    } // end if (GetAclInformation())

	} // end if (HrGetSecurityDescriptorDacl()) and DACL is present

	ASSERT(IsValidSecurityDescriptor(psec));

	return psec;

}  //*** ClRtlConvertFileShareSDToNT4Format()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\directoryutilities.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      DirectoryUtils.cpp
//
//  Description:
//      Useful functions for manipulating directies.
//
//  Maintained By:
//      Galen Barbee (GalenB)   05-DEC-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <objbase.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <wchar.h>
#include <Dsgetdc.h>
#include <Lm.h>

#if !defined( THR ) 
#define THR( _hr ) _hr
#endif

#if !defined( TW32 ) 
#define TW32( _sc ) _sc
#endif


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrCreateDirectoryPath(
//      LPWSTR pszDirectoryPathInOut
//      )
//
//  Descriptions:
//      Creates the directory tree as required.
//
//  Arguments:
//      pszDirectoryPathOut
//          Must be MAX_PATH big. It will contain the trace log file path to
//          create.
//
//  Return Values:
//      S_OK - Success
//      other HRESULTs for failures
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateDirectoryPath( LPWSTR pszDirectoryPath )
{
    LPTSTR  psz;
    BOOL    fReturn;
    DWORD   dwAttr;
    HRESULT hr = S_OK;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    // skip X:\ part
    psz = wcschr( pszDirectoryPath, L'\\' );
//    Assert( psz != NULL );
    if ( psz != NULL )
    {
        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //
        psz = wcschr( psz + 1, L'\\' );
        while ( psz != NULL )
        {
            // Terminate the directory path at the current level.
            *psz = 0;

            //
            // Create a directory at the current level.
            //
            dwAttr = GetFileAttributes( pszDirectoryPath );
            if ( 0xFFFFffff == dwAttr )
            {
//                DebugMsg( TEXT("DEBUG: Creating %ws"), pszDirectoryPath );
                fReturn = CreateDirectory( pszDirectoryPath, NULL );
                if ( ! fReturn )
                {
                    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                    goto Error;
                } // if: creation failed

            }  // if: directory not found
            else if ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
            {
                hr = THR( HRESULT_FROM_WIN32( ERROR_DIRECTORY ) );
                goto Error;
            } // else: file found

            //
            // Restore the \ and find the next one.
            //
            *psz = L'\\';
            psz = wcschr( psz + 1, L'\\' );

        } // while: found slash

    } // if: found slash

    //
    // Create the target directory.
    //
    dwAttr = GetFileAttributes( pszDirectoryPath );
    if ( 0xFFFFffff == dwAttr )
    {
        fReturn = CreateDirectory( pszDirectoryPath, NULL );
        if ( ! fReturn )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );

        } // if: creation failed

    } // if: path not found

Error:

    return hr;

} //*** HrCreateDirectoryPath()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\dbgrpt.cpp ===
/***
*DbgRpt.c - Debug Cluster Reporting Functions
*
*       Copyright (c) 1988-1998, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <malloc.h>
#include <mbstring.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>

#include <windows.h>

#define CLRTL_INCLUDE_DEBUG_REPORTING
#include "ClRtlDbg.h"
#include <strsafe.h>

#define _ClRtlInterlockedIncrement InterlockedIncrement
#define _ClRtlInterlockedDecrement InterlockedDecrement

/*---------------------------------------------------------------------------
 *
 * Debug Reporting
 *
 --------------------------------------------------------------------------*/

static int ClRtlMessageWindow(
    int,
    const char *,
    const char *,
    const char *,
    const char *
    );

static int __clrtlMessageBoxA(
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType
    );

extern "C"
{
_CLRTL_REPORT_HOOK _pfnReportHook;

long _clrtlAssertBusy = -1;

int _ClRtlDbgMode[_CLRTLDBG_ERRCNT] = {
    _CLRTLDBG_MODE_DEBUG,
    _CLRTLDBG_MODE_DEBUG | _CLRTLDBG_MODE_WNDW,
    _CLRTLDBG_MODE_DEBUG | _CLRTLDBG_MODE_WNDW
    };

_HFILE _ClRtlDbgFile[_CLRTLDBG_ERRCNT] = {
    _CLRTLDBG_INVALID_HFILE,
    _CLRTLDBG_INVALID_HFILE,
    _CLRTLDBG_INVALID_HFILE
    };
}

static const char * _ClRtlDbgModeMsg[_CLRTLDBG_ERRCNT] = { "Warning", "Error", "Assertion Failed" };

/***
*void _ClRtlDebugBreak - call OS-specific debug function
*
*Purpose:
*       call OS-specific debug function
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#undef _ClRtlDbgBreak

extern "C" void _cdecl _ClRtlDbgBreak(
    void
    )
{
    DebugBreak();

} //*** _ClRtlDbgBreak()

/***
*int _ClRtlSetReportMode - set the reporting mode for a given report type
*
*Purpose:
*       set the reporting mode for a given report type
*
*Entry:
*       int nRptType    - the report type
*       int fMode       - new mode for given report type
*
*Exit:
*       previous mode for given report type
*
*Exceptions:
*
*******************************************************************************/
extern "C" int __cdecl _ClRtlSetReportMode(
    int nRptType,
    int fMode
    )
{
    int oldMode;

    if (nRptType < 0 || nRptType >= _CLRTLDBG_ERRCNT)
        return -1;

    if (fMode == _CLRTLDBG_REPORT_MODE)
        return _ClRtlDbgMode[nRptType];

    /* verify flags values */
    if (fMode & ~(_CLRTLDBG_MODE_FILE | _CLRTLDBG_MODE_DEBUG | _CLRTLDBG_MODE_WNDW))
        return -1;

    oldMode = _ClRtlDbgMode[nRptType];

    _ClRtlDbgMode[nRptType] = fMode;

    return oldMode;

} //*** _ClRtlSetReportMode()

/***
*int _ClRtlSetReportFile - set the reporting file for a given report type
*
*Purpose:
*       set the reporting file for a given report type
*
*Entry:
*       int nRptType    - the report type
*       _HFILE hFile    - new file for given report type
*
*Exit:
*       previous file for given report type
*
*Exceptions:
*
*******************************************************************************/
extern "C" _HFILE __cdecl _ClRtlSetReportFile(
    int nRptType,
    _HFILE hFile
    )
{
    _HFILE oldFile;

    if (nRptType < 0 || nRptType >= _CLRTLDBG_ERRCNT)
        return _CLRTLDBG_HFILE_ERROR;

    if (hFile == _CLRTLDBG_REPORT_FILE)
        return _ClRtlDbgFile[nRptType];

    oldFile = _ClRtlDbgFile[nRptType];

    if (_CLRTLDBG_FILE_STDOUT == hFile)
        _ClRtlDbgFile[nRptType] = GetStdHandle(STD_OUTPUT_HANDLE);

    else if (_CLRTLDBG_FILE_STDERR == hFile)
        _ClRtlDbgFile[nRptType] = GetStdHandle(STD_ERROR_HANDLE);
    else
        _ClRtlDbgFile[nRptType] = hFile;

    return oldFile;

} //*** _ClRtlSetReportFile()


/***
*_CLRTL_REPORT_HOOK _ClRtlSetReportHook() - set client report hook
*
*Purpose:
*       set client report hook
*
*Entry:
*       _CLRTL_REPORT_HOOK pfnNewHook - new report hook
*
*Exit:
*       return previous hook
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CLRTL_REPORT_HOOK __cdecl _ClRtlSetReportHook(
    _CLRTL_REPORT_HOOK pfnNewHook
    )
{
    _CLRTL_REPORT_HOOK pfnOldHook = _pfnReportHook;
    _pfnReportHook = pfnNewHook;
    return pfnOldHook;

} //*** _ClRtlSetReportHook()


#define MAXLINELEN 64
#define MAX_MSG 512
#define TOOLONGMSG "_ClRtlDbgReport: String too long or IO Error"


/***
*int _ClRtlDbgReport() - primary reporting function
*
*Purpose:
*       Display a message window with the following format.
*
*       ================= Microsft Visual C++ Debug Library ================
*
*       {Warning! | Error! | Assertion Failed!}
*
*       Program: c:\test\mytest\foo.exe
*       [Module: c:\test\mytest\bar.dll]
*       [File: c:\test\mytest\bar.c]
*       [Line: 69]
*
*       {<warning or error message> | Expression: <expression>}
*
*       [For information on how your program can cause an assertion
*        failure, see the Visual C++ documentation on asserts]
*
*       (Press Retry to debug the application)
*
*       ===================================================================
*
*Entry:
*       int             nRptType    - report type
*       const char *    szFile      - file name
*       int             nLine       - line number
*       const char *    szModule    - module name
*       const char *    szFormat    - format string
*       ...                         - var args
*
*Exit:
*       if (MessageBox)
*       {
*           Abort -> aborts
*           Retry -> return TRUE
*           Ignore-> return FALSE
*       }
*       else
*           return FALSE
*
*Exceptions:
*
*******************************************************************************/
extern "C" int __cdecl _ClRtlDbgReport(
    int nRptType,
    const char * szFile,
    int nLine,
    const char * szModule,
    const char * szFormat,
    ...
    )
{
    int retval;
    va_list arglist;
    char szLineMessage[MAX_MSG] = {0};
    char szOutMessage[MAX_MSG] = {0};
    char szUserMessage[MAX_MSG] = {0};
    #define ASSERTINTRO1 "Assertion failed: "
    #define ASSERTINTRO2 "Assertion failed!"

    va_start(arglist, szFormat);

    if (nRptType < 0 || nRptType >= _CLRTLDBG_ERRCNT)
        return -1;

    /*
     * handle the (hopefully rare) case of
     *
     * 1) ASSERT while already dealing with an ASSERT
     *      or
     * 2) two threads asserting at the same time
     */
    if (_CLRTLDBG_ASSERT == nRptType && _ClRtlInterlockedIncrement(&_clrtlAssertBusy) > 0)
    {
        /* use only 'safe' functions -- must not assert in here! */
        static int (APIENTRY *pfnwsprintfA)(LPSTR, LPCSTR, ...) = NULL;

        if (NULL == pfnwsprintfA)
        {
            HINSTANCE hlib = LoadLibraryA("user32.dll");

            if (NULL == hlib || NULL == (pfnwsprintfA =
                        (int (APIENTRY *)(LPSTR, LPCSTR, ...))
                        GetProcAddress(hlib, "wsprintfA")))
                return -1;
        }

        (*pfnwsprintfA)( szOutMessage,
            "Second Chance Assertion Failed: File %s, Line %d\n",
            szFile, nLine);

        OutputDebugStringA(szOutMessage);

        _ClRtlInterlockedDecrement(&_clrtlAssertBusy);

        _ClRtlDbgBreak();
        return -1;
    }

    szUserMessage[ MAX_MSG - 1 ] = 0;
    if (szFormat && StringCbVPrintfA( szUserMessage,
                   MAX_MSG-max(sizeof(ASSERTINTRO1),sizeof(ASSERTINTRO2))-1,
                   szFormat,
                   arglist) != S_OK ) {
        PCHAR dot;
        dot = szUserMessage + MAX_MSG - 4;
        StringCbCopyA( dot, 4, "..." );
    }
    if (_CLRTLDBG_ASSERT == nRptType) {
        if ( szFormat == 0 ) {
            StringCbCopyA( szLineMessage, MAX_MSG, ASSERTINTRO1 );
        }
        else {
            StringCbCopyA( szLineMessage, MAX_MSG, ASSERTINTRO2 );
        }
    }
    StringCbCatA( szLineMessage, MAX_MSG, szUserMessage );

    if (_CLRTLDBG_ASSERT == nRptType)
    {
        if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_FILE) {
            StringCbCatA( szLineMessage, MAX_MSG, "\r" );
        }
        StringCbCatA( szLineMessage, MAX_MSG, "\n" );
    }

    if (szFile)
    {
        if ( StringCbPrintfA(szOutMessage, MAX_MSG, "%s(%d) : %s",
            szFile, nLine, szLineMessage) != S_OK )
        StringCbCopyA( szOutMessage, MAX_MSG, TOOLONGMSG );
    }
    else {
        StringCbCopyA( szOutMessage, MAX_MSG, szLineMessage );
    }

    /* user hook may handle report */
    if (_pfnReportHook && (*_pfnReportHook)(nRptType, szOutMessage, &retval))
    {
        if (_CLRTLDBG_ASSERT == nRptType)
            _ClRtlInterlockedDecrement(&_clrtlAssertBusy);
        return retval;
    }

    if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_FILE)
    {
        if (_ClRtlDbgFile[nRptType] != _CLRTLDBG_INVALID_HFILE)
        {
            DWORD written;
            WriteFile(_ClRtlDbgFile[nRptType], szOutMessage, strlen(szOutMessage), &written, NULL);
        }
    }

    if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_DEBUG)
    {
        OutputDebugStringA(szOutMessage);
    }

    if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_WNDW)
    {
        char szLine[20];

        retval = ClRtlMessageWindow(nRptType, szFile, nLine ? _itoa(nLine, szLine, 10) : NULL, szModule, szUserMessage);
        if (_CLRTLDBG_ASSERT == nRptType)
            _ClRtlInterlockedDecrement(&_clrtlAssertBusy);
        return retval;
    }

    if (_CLRTLDBG_ASSERT == nRptType)
        _ClRtlInterlockedDecrement(&_clrtlAssertBusy);
    /* ignore */
    return FALSE;

} //*** _ClRtlDbgReport()


/***
*static int ClRtlMessageWindow() - report to a message window
*
*Purpose:
*       put report into message window, allow user to choose action to take
*
*Entry:
*       int             nRptType      - report type
*       const char *    szFile        - file name
*       const char *    szLine        - line number
*       const char *    szModule      - module name
*       const char *    szUserMessage - user message
*
*Exit:
*       if (MessageBox)
*       {
*           Abort -> aborts
*           Retry -> return TRUE
*           Ignore-> return FALSE
*       }
*       else
*           return FALSE
*
*Exceptions:
*
*******************************************************************************/
static int ClRtlMessageWindow(
        int nRptType,
        const char * szFile,
        const char * szLine,
        const char * szModule,
        const char * szUserMessage
        )
{
    int nCode;
    char *szShortProgName;
    char *szShortModuleName;
    char szExeName[MAX_PATH];
    char szOutMessage[MAX_MSG];

    _CLRTL_ASSERTE(szUserMessage != NULL);

    /* Shorten program name */
    if (!GetModuleFileNameA(NULL, szExeName, MAX_PATH))
        StringCbCopyA(szExeName, MAX_PATH, "<program name unknown>");

    szShortProgName = szExeName;

    if (strlen(szShortProgName) > MAXLINELEN)
    {
        szShortProgName += MAXLINELEN - 4;
        StringCbCopyA( szShortProgName, 4, "..." );
    }

    /* Shorten module name */
    szShortModuleName = (char *) szModule;

    if (szShortModuleName && strlen(szShortModuleName) > MAXLINELEN)
    {
        szShortModuleName += MAXLINELEN - 4;
        StringCbCopyA( szShortModuleName, 4, "..." );
    }

    if ( StringCbPrintfA( szOutMessage, MAX_MSG,  
            "Debug %s!\n\nProgram: %s%s%s%s%s%s%s%s%s%s%s"
            "\n\n(Press Retry to debug the application)",
            _ClRtlDbgModeMsg[nRptType],
            szShortProgName,
            szShortModuleName ? "\nModule: " : "",
            szShortModuleName ? szShortModuleName : "",
            szFile ? "\nFile: " : "",
            szFile ? szFile : "",
            szLine ? "\nLine: " : "",
            szLine ? szLine : "",
            szUserMessage[0] ? "\n\n" : "",
            szUserMessage[0] && _CLRTLDBG_ASSERT == nRptType ? "Expression: " : "",
            szUserMessage[0] ? szUserMessage : "",
            0 /*_CLRTLDBG_ASSERT == nRptType*/ ? // Don't display this text, it's superfluous
            "\n\nFor information on how your program can cause an assertion"
            "\nfailure, see the Visual C++ documentation on asserts."
            : "") != S_OK )
        StringCbCopyA( szOutMessage, MAX_MSG, TOOLONGMSG );

    /* Report the warning/error */
    nCode = __clrtlMessageBoxA(
                        szOutMessage,
                        "Microsoft Visual C++ Debug Library",
                        MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

    /* Abort: abort the program */
    if (IDABORT == nCode)
    {
        /* raise abort signal */
        raise(SIGABRT);

        /* We usually won't get here, but it's possible that
           SIGABRT was ignored.  So exit the program anyway. */

        _exit(3);
    }

    /* Retry: return 1 to call the debugger */
    if (IDRETRY == nCode)
        return 1;

    /* Ignore: continue execution */
    return 0;

} //*** ClRtlMessageWindow()


/***
*__clrtlMessageBoxA - call MessageBoxA dynamically.
*
*Purpose:
*       Avoid static link with user32.dll. Only load it when actually needed.
*
*Entry:
*       see MessageBoxA docs.
*
*Exit:
*       see MessageBoxA docs.
*
*Exceptions:
*
*******************************************************************************/
static int __clrtlMessageBoxA(
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType
    )
{
    static int (APIENTRY *pfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT) = NULL;
    static HWND (APIENTRY *pfnGetActiveWindow)(void) = NULL;
    static HWND (APIENTRY *pfnGetLastActivePopup)(HWND) = NULL;

    HWND hWndParent = NULL;

    if (NULL == pfnMessageBoxA)
    {
        HINSTANCE hlib = LoadLibraryA("user32.dll");

        if (NULL == hlib || NULL == (pfnMessageBoxA =
                    (int (APIENTRY *)(HWND, LPCSTR, LPCSTR, UINT))
                    GetProcAddress(hlib, "MessageBoxA")))
            return 0;

        pfnGetActiveWindow = (HWND (APIENTRY *)(void))
                    GetProcAddress(hlib, "GetActiveWindow");

        pfnGetLastActivePopup = (HWND (APIENTRY *)(HWND))
                    GetProcAddress(hlib, "GetLastActivePopup");
    }

    if (pfnGetActiveWindow)
        hWndParent = (*pfnGetActiveWindow)();

    if (hWndParent != NULL && pfnGetLastActivePopup)
        hWndParent = (*pfnGetLastActivePopup)(hWndParent);

    return (*pfnMessageBoxA)(hWndParent, lpText, lpCaption, uType);

} //*** __clrtlMessageBoxA()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\eventlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This module provides common eventlog services for the cluster service

Author:

    John Vert (jvert) 9/13/1996

Revision History:

--*/
#define UNICODE 1
#include "clusrtlp.h"

HANDLE           LocalEventLog=NULL;
CRITICAL_SECTION EventLogLock;

//
// [GN] June 19/1999: added Async EventReporting
//
// Use ClRtlEventLogSetWorkQueue to set a queue
// for async event reporting. If it the queue is not set,
// event reporting is synchronous as it used to be before
//

static CLRTL_WORK_ITEM EvtReporterWorkItem;
static PCLRTL_WORK_QUEUE EvtReporterWorkQueue;

#if 0
//
// additional data is stored after this structure. lpStrings is the base of an
// array that will continue. Following the strings is the area pointed by
// lpRawData if there is any. Following that are the strings themselves. They
// are pointed to by the entries in lpStrings.
//

    +------------------+
    | EVENT_LOG_PACKET |
    +------------------+
    |  lpStrings[0]    |
    |  lpStrings[1]    |
    |  lpStrings[2]    |
    |  ...             |
    +------------------+
    |  lpRawData area  |
    |  (maybe missing) |
    |                  |
    +------------------+
    |  string0         |
    |  string1         |
    |  ...             |
    +------------------+

#endif

typedef struct _EVENT_LOG_PACKET {
    WORD       wType;
    WORD       wCategory;
    DWORD      dwEventID;
    WORD       wNumStrings;
    DWORD      dwDataSize;
    LPVOID     lpRawData;
    LPWSTR     lpStrings[0];
} *PEVENT_LOG_PACKET, EVENT_LOG_PACKET;

VOID
ClRtlEventLogSetWorkQueue(
    PCLRTL_WORK_QUEUE WorkQueue
    )
{
    EnterCriticalSection( &EventLogLock );

    EvtReporterWorkQueue = WorkQueue;
    
    LeaveCriticalSection( &EventLogLock );
}

VOID
EvtReporter(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Reports queued event via advapi32!ReportEvent

Arguments:

     IoContext == EVENT_LOG_PACKET

Return Value:

     None

--*/
{
    PEVENT_LOG_PACKET data = (PEVENT_LOG_PACKET)IoContext;
    
    ReportEventW(LocalEventLog,
                 data->wType,
                 data->wCategory,
                 data->dwEventID,
                 NULL,
                 data->wNumStrings,
                 data->dwDataSize,
                 data->lpStrings,
                 data->lpRawData);
    LocalFree(data);
}



VOID
ClRtlEventLogInit(
    VOID
    )
/*++

Routine Description:

    initializes the event log

Arguments:

    None

Return Value:

    None

--*/

{

    InitializeCriticalSection(&EventLogLock);

    EvtReporterWorkQueue = 0;
    
    ClRtlInitializeWorkItem(
        &EvtReporterWorkItem,
        EvtReporter,
        0
        );
}

VOID
ClRtlEventLogCleanup(
    VOID
    )
{
    DeleteCriticalSection( &EventLogLock );
}

PEVENT_LOG_PACKET
ClRtlpBuildEventPacket(
    WORD       wType,
    WORD       wCategory,
    DWORD      dwEventID,
    WORD       wNumStrings,
    DWORD      dwDataSize,
    LPCWSTR   *lpStrings,
    LPVOID     lpRawData
    )
{
    PEVENT_LOG_PACKET data = 0;
    DWORD Count;
    UINT  i;
    LPBYTE ptr;

    Count = sizeof(EVENT_LOG_PACKET) + 
            dwDataSize + 
            wNumStrings * (sizeof(LPCWSTR) + sizeof(UNICODE_NULL));

    for (i = 0; i < wNumStrings; ++i) {
        int len = lstrlenW( lpStrings[i] );
        Count += len * sizeof(WCHAR); // (null is already accounted for)
    }

    data = LocalAlloc(LMEM_FIXED, Count);
    if (!data) {
        return 0;
    }

    data->wType     = wType;
    data->wCategory = wCategory;
    data->dwEventID = dwEventID;
    data->wNumStrings = wNumStrings;
    data->dwDataSize = dwDataSize;
    data->lpRawData =  &data->lpStrings[wNumStrings];
    // lpStrings will be filled later

    if (dwDataSize) {
        CopyMemory(data->lpRawData, lpRawData, dwDataSize);
    }

    ptr = (LPBYTE)data->lpRawData + dwDataSize;
    for (i = 0; i < wNumStrings; ++i) {
        int nBytes = (lstrlenW( lpStrings[i] ) + 1) * sizeof(WCHAR);
        CopyMemory(ptr, lpStrings[i], nBytes);
        data->lpStrings[i] = (LPWSTR)ptr;
        ptr += nBytes;
    }

    CL_ASSERT(ptr <= (LPBYTE)data + Count); 
    return data;
}




VOID
ClRtlpReportEvent(
    WORD       wType,
    WORD       wCategory,
    DWORD      dwEventID,
    WORD       wNumStrings,
    DWORD      dwDataSize,
    LPCWSTR   *lpStrings,
    LPVOID     lpRawData
    )
/*++

Routine Description:

    Common routine for reporting an event to the event log. Opens a handle
    to the event log if necessary.

Arguments:

    Identical arguments to ReportEventW

Return Value:

    None

--*/

{
    BOOL Success = FALSE;
    DWORD Status;

    //
    // If the event log hasn't been opened, try and open it now.
    //
    if (LocalEventLog == NULL) {
        EnterCriticalSection(&EventLogLock);
        if (LocalEventLog == NULL) {
            LocalEventLog = RegisterEventSource(NULL, L"ClusSvc");
        }
        LeaveCriticalSection(&EventLogLock);
        if (LocalEventLog == NULL) {
            Status = GetLastError();
            return;
        }
    }

    if (EvtReporterWorkQueue) {
        PEVENT_LOG_PACKET data = 
            ClRtlpBuildEventPacket(wType,
                                   wCategory,
                                   dwEventID,
                                   wNumStrings,
                                   dwDataSize,
                                   lpStrings,
                                   lpRawData);
        if (data) {
            EnterCriticalSection( &EventLogLock );
            if (EvtReporterWorkQueue) {
                Status = ClRtlPostItemWorkQueue(
                            EvtReporterWorkQueue,
                            &EvtReporterWorkItem,
                            0,
                            (ULONG_PTR)data
                            );
                if (Status == ERROR_SUCCESS) {
                    // worker will free data //
                    data = NULL;
                    Success = TRUE;
                }
            }
            LeaveCriticalSection( &EventLogLock );
            LocalFree( data ); // free(0) is OK
            if (Success) {
                return;
            }
        }
    }

    Success = ReportEventW(LocalEventLog,
                           wType,
                           wCategory,
                           dwEventID,
                           NULL,
                           wNumStrings,
                           dwDataSize,
                           lpStrings,
                           lpRawData);

}


VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      0,
                      dwByteCount,
                      NULL,
                      lpBytes);
}


VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }
    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      1,
                      dwByteCount,
                      &Arg1,
                      lpBytes);
}


VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies the first insertion string

    Arg2 - Supplies the second insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;
    LPCWSTR ArgArray[2];

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ArgArray[0] = Arg1;
    ArgArray[1] = Arg2;

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      2,
                      dwByteCount,
                      ArgArray,
                      lpBytes);
}


VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies the first insertion string

    Arg2 - Supplies the second insertion string

    Arg3 - Supplies the third insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;
    LPCWSTR ArgArray[3];

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ArgArray[0] = Arg1;
    ArgArray[1] = Arg2;
    ArgArray[2] = Arg3;

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      3,
                      dwByteCount,
                      ArgArray,
                      lpBytes);
}


VOID
ClusterLogEvent4(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3,
    IN LPCWSTR Arg4
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies the first insertion string

    Arg2 - Supplies the second insertion string

    Arg3 - Supplies the third insertion string

    Arg4 - Supplies the fourth insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;
    LPCWSTR ArgArray[4];

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ArgArray[0] = Arg1;
    ArgArray[1] = Arg2;
    ArgArray[2] = Arg3;
    ArgArray[3] = Arg4;

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      4,
                      dwByteCount,
                      ArgArray,
                      lpBytes);
}


VOID
ClusterCommonLogError(
    IN ULONG MessageId,
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    )
/*++

Routine Description:

    Logs an error to the eventlog

Arguments:

    MessageId - Supplies the message ID to use.

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    ErrCode - Supplies the specific error code.

Return Value:

    None.

--*/

{
    WCHAR LineString[20];
    WCHAR ErrString[32];
    WCHAR FileName[MAX_PATH];
    WCHAR Buffer[256];
    LPWSTR Strings[3];
    DWORD Bytes;

    LineString[ RTL_NUMBER_OF( LineString ) - 1 ] = UNICODE_NULL;
    _snwprintf( LineString, RTL_NUMBER_OF( LineString ) - 1,  L"%d", Line );

    ErrString[ RTL_NUMBER_OF( ErrString ) - 1 ] = UNICODE_NULL;
    _snwprintf( ErrString, RTL_NUMBER_OF( ErrString ) - 1, L"%d", ErrCode);

    FileName[ RTL_NUMBER_OF( FileName ) - 1 ] = UNICODE_NULL;
    mbstowcs(FileName, File, RTL_NUMBER_OF( FileName ) - 1);

    Strings[0] = LineString;
    Strings[1] = FileName;
    Strings[2] = ErrString;

    ClRtlpReportEvent(EVENTLOG_ERROR_TYPE,
                      (WORD)LogModule,
                      MessageId,
                      3,
                      0,
                      Strings,
                      NULL);

    Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK,       // remove embedded line breaks
                           NULL,
                           MessageId,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(WCHAR),
                           (va_list *)Strings);

    if (Bytes != 0) {
        OutputDebugStringW(Buffer);
        ClRtlLogPrint(LOG_CRITICAL, "%1!ws!\n",Buffer);
    }
}


VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    )
/*++

Routine Description:

    Logs a fatal error to the eventlog and breaks into the debugger if present.
    Exits the process on fatal error.

Arguments:

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    ErrCode - Supplies the specific error code.

Return Value:

    None.

--*/

{
    ClusterCommonLogError(UNEXPECTED_FATAL_ERROR,
                          LogModule,
                          Line,
                          File,
                          ErrCode);

    if (IsDebuggerPresent()) {
        DebugBreak();
    }

    ClRtlpFlushLogBuffers();
    ExitProcess(ErrCode);

}


VOID
ClusterLogNonFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    )
/*++

Routine Description:

    Logs a nonfatal error to the eventlog

Arguments:

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    ErrCode - Supplies the specific error code.

Return Value:

    None.

--*/

{
    ClusterCommonLogError(LOG_FAILURE,
                          LogModule,
                          Line,
                          File,
                          ErrCode);
}


VOID
ClusterLogAssertionFailure(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN LPSTR Expression
    )
/*++

Routine Description:

    Logs an assertion failure to the eventlog.

Arguments:

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    Express - Supplies the ASSERTion expression


Return Value:

    None.

--*/

{
    WCHAR LineString[10];
    WCHAR FileName[MAX_PATH];
    WCHAR Buffer[256];
    LPWSTR Strings[4];
    DWORD Bytes;

    LineString[ RTL_NUMBER_OF( LineString ) - 1 ] = UNICODE_NULL;
    _snwprintf( LineString, RTL_NUMBER_OF( LineString ) - 1,  L"%d", Line );

    FileName[ RTL_NUMBER_OF( FileName ) - 1 ] = UNICODE_NULL;
    mbstowcs(FileName, File, RTL_NUMBER_OF( FileName ) - 1);

    Buffer[ RTL_NUMBER_OF( Buffer ) - 1 ] = UNICODE_NULL;
    mbstowcs(Buffer, Expression, RTL_NUMBER_OF( Buffer) - 1);

    Strings[0] = LineString;
    Strings[1] = FileName;
    Strings[2] = Buffer;

    ClRtlpReportEvent(EVENTLOG_ERROR_TYPE,
                     (WORD)LogModule,
                     ASSERTION_FAILURE,
                     3,
                     0,
                     Strings,
                     NULL);

    Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK,       // removed embedded line breaks
                           NULL,
                           ASSERTION_FAILURE,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(WCHAR),
                           (va_list *)Strings);
    if (Bytes != 0) {
        OutputDebugStringW(Buffer);
        ClRtlLogPrint(LOG_CRITICAL, "%1!ws!\n",Buffer);
    }
    if (IsDebuggerPresent()) {
        DebugBreak();
    } else {
        ClRtlpFlushLogBuffers();
        ExitProcess(Line);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\cleanup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Cleanup.cpp
//
//  Abstract:
//      Implementation of the functions related to cleaning up a node that has
//      been evicted.
//
//  Author:
//      Vijayendra Vasu (vvasu) 17-AUG-2000
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////

#define UNICODE 1
#define _UNICODE 1


/////////////////////////////////////////////////////////////////////////////
// Include files
/////////////////////////////////////////////////////////////////////////////
#include "clusrtlp.h"

#include <objbase.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgServer.h>
#include <ClusCfgClient.h>
#include <clusrtl.h>
#include <clusudef.h>

/////////////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////////////

#ifdef DBG
    const DWORD PERIODIC_CLEANUP_INTERVAL = 60 * 1000;      // 1 minute
#else
    const DWORD PERIODIC_CLEANUP_INTERVAL = 15 * 60 * 1000; // 15 minutes
#endif


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlCleanupNode()
//
//  Routine Description:
//      Cleanup a node that has been evicted. This method tries to instantiate
//      the cleanup COM component locally (even if a remote node is being cleaned up)
//      and will therefore not work if called from computer which do not have this
//      component registered.
//
//  Arguments:
//      const WCHAR * pcszEvictedNodeNameIn
//          Name of the node on which cleanup is to be initiated. If this is NULL
//          the local node is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that will elapse before cleanup is started
//          on the target node. If some other process cleans up the target node while
//          delay is in progress, the delay is terminated. If this value is zero,
//          the node is cleaned up immediately.
//
//      DWORD dwTimeoutIn
//          Number of milliseconds that this method will wait for cleanup to complete.
//          This timeout is independent of the delay above, so if dwDelayIn is greater
//          than dwTimeoutIn, this method will most probably timeout. Once initiated,
//          however, cleanup will run to completion - this method just may not wait for it
//          to complete.
//
//  Return Value:
//      S_OK
//          If the cleanup operations were successful
//
//      RPC_S_CALLPENDING
//          If cleanup is not complete in dwTimeoutIn milliseconds
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT ClRtlCleanupNode(
      const WCHAR * pcszEvictedNodeNameIn
    , DWORD dwDelayIn
    , DWORD dwTimeoutIn
    )
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrInit;
    IClusCfgEvictCleanup *      pcceEvict = NULL;
    ICallFactory *              pcfCallFactory = NULL;
    ISynchronize *              psSync = NULL;
    AsyncIClusCfgEvictCleanup * paicceAsyncEvict = NULL;


    //
    //  Initialize COM - make sure it really init'ed or that we're just trying
    //  to change modes on the calling thread.  Attempting to change to mode
    //  is not reason to fail this function.
    //
    hrInit = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( ( hrInit != S_OK ) && ( hrInit != S_FALSE ) && ( hrInit != RPC_E_CHANGED_MODE ) )
    {
        hr = hrInit;
        goto Exit;
    } // if:

    hr = CoCreateInstance(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , __uuidof( pcceEvict )
            , reinterpret_cast< void ** >( &pcceEvict )
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to synchronous evict interface

    hr = pcceEvict->QueryInterface( __uuidof( pcfCallFactory ), reinterpret_cast< void ** >( &pcfCallFactory ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the call factory interface

    hr = pcfCallFactory->CreateCall(
          __uuidof( paicceAsyncEvict )
        , NULL
        , __uuidof( paicceAsyncEvict )
        , reinterpret_cast< IUnknown ** >( &paicceAsyncEvict )
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the asynchronous evict interface

    hr = paicceAsyncEvict->QueryInterface< ISynchronize >( &psSync );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the synchronization interface

    // Initiate cleanup
    if ( pcszEvictedNodeNameIn != NULL )
    {
        hr = paicceAsyncEvict->Begin_CleanupRemoteNode( pcszEvictedNodeNameIn, dwDelayIn );
    } // if: we are cleaning up a remote node
    else
    {
        hr = paicceAsyncEvict->Begin_CleanupLocalNode( dwDelayIn );
    } // else: we are cleaning up the local node

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not initiate cleanup

    // Wait for specified time.
    hr = psSync->Wait( 0, dwTimeoutIn );
    if ( FAILED( hr ) || ( hr == RPC_S_CALLPENDING ) )
    {
        goto Cleanup;
    } // if: we could not wait till cleanup completed

    // Finish cleanup
    if ( pcszEvictedNodeNameIn != NULL )
    {
        hr = paicceAsyncEvict->Finish_CleanupRemoteNode();
    } // if: we are cleaning up a remote node
    else
    {
        hr = paicceAsyncEvict->Finish_CleanupLocalNode();
    } // else: we are cleaning up the local node

Cleanup:

    //
    // Free acquired resources
    //

    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if: we had obtained a pointer to the synchronous evict interface

    if ( pcfCallFactory != NULL )
    {
        pcfCallFactory->Release();
    } // if: we had obtained a pointer to the call factory interface

    if ( psSync != NULL )
    {
        psSync->Release();
    } // if: we had obtained a pointer to the synchronization interface

    if ( paicceAsyncEvict != NULL )
    {
        paicceAsyncEvict->Release();
    } // if: we had obtained a pointer to the asynchronous evict interface

    //
    //  Did the call to CoInitializeEx() above succeed?  If it did then
    //  we need to call CoUnitialize().  Mode changed means we don't need
    //  to call CoUnitialize().
    //
    if ( hrInit != RPC_E_CHANGED_MODE  )
    {
        CoUninitialize();
    } // if:

Exit:

    return hr;

} //*** ClRtlCleanupNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlAsyncCleanupNode()
//
//  Routine Description:
//      Cleanup a node that has been evicted. This method does not initiate
//      any COM component on the machine on which this call is made and therefore,
//      does not require the cleanup COM component to be registered on the local
//      machine.
//
//  Arguments:
//      const WCHAR * pcszEvictedNodeNameIn
//          Name of the node on which cleanup is to be initiated. If this is NULL
//          the local node is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that will elapse before cleanup is started
//          on the target node. If some other process cleans up the target node while
//          delay is in progress, the delay is terminated. If this value is zero,
//          the node is cleaned up immediately.
//
//      DWORD dwTimeoutIn
//          Number of milliseconds that this method will wait for cleanup to complete.
//          This timeout is independent of the delay above, so if dwDelayIn is greater
//          than dwTimeoutIn, this method will most probably timeout. Once initiated,
//          however, cleanup will run to completion - this method just may not wait for it
//          to complete.
//
//  Return Value:
//      S_OK
//          If the cleanup operations were successful
//
//      RPC_S_CALLPENDING
//          If cleanup is not complete in dwTimeoutIn milliseconds
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT ClRtlAsyncCleanupNode(
      const WCHAR * pcszEvictedNodeNameIn
    , DWORD         dwDelayIn
    , DWORD         dwTimeoutIn
    )
{
    HRESULT     hr = S_OK;
    HRESULT     hrInit = S_OK;
    IDispatch * pDisp = NULL;

    //
    //  Initialize COM - make sure it really init'ed or that we're just trying
    //  to change modes on the calling thread.  Attempting to change to mode
    //  is not reason to fail this function.
    //
    hrInit = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( ( hrInit != S_OK ) && ( hrInit != S_FALSE ) && ( hrInit != RPC_E_CHANGED_MODE ) )
    {
        hr = hrInit;
        goto Exit;
    } // if:

    MULTI_QI mqiInterfaces[] =
    {
        { &IID_IDispatch, NULL, S_OK },
    };

    COSERVERINFO    csiServerInfo;
    COSERVERINFO *  pcsiServerInfoPtr = &csiServerInfo;

    if ( pcszEvictedNodeNameIn == NULL )
    {
        pcsiServerInfoPtr = NULL;
    } // if: we have to cleanup the local node
    else
    {
        csiServerInfo.dwReserved1 = 0;
        csiServerInfo.pwszName = const_cast< LPWSTR >( pcszEvictedNodeNameIn );
        csiServerInfo.pAuthInfo = NULL;
        csiServerInfo.dwReserved2 = 0;
    } // else: we have to clean up a remote node

    //
    //  Instantiate this component on the evicted node.
    //
    hr = CoCreateInstanceEx(
              CLSID_ClusCfgAsyncEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , pcsiServerInfoPtr
            , sizeof( mqiInterfaces ) / sizeof( mqiInterfaces[0] )
            , mqiInterfaces
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not instantiate the evict processing component

    pDisp = reinterpret_cast< IDispatch * >( mqiInterfaces[ 0 ].pItf );

    {
        OLECHAR *   pszMethodName = L"CleanupNode";
        DISPID      dispidCleanupNode;
        VARIANT     vResult;

        VARIANTARG  rgvaCleanupNodeArgs[ 3 ];

        DISPPARAMS  dpCleanupNodeParams = {
                          rgvaCleanupNodeArgs
                        , NULL
                        , sizeof( rgvaCleanupNodeArgs ) / sizeof( rgvaCleanupNodeArgs[ 0 ] )
                        , 0
                        };

        // Get the dispatch id of the CleanupNode() method.
        hr = pDisp->GetIDsOfNames( IID_NULL, &pszMethodName, 1, LOCALE_SYSTEM_DEFAULT, &dispidCleanupNode );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: we could not get the dispid of the CleanupNode() method

        //
        // Initialize the arguments. Note, the parameters are stored in the reverse order in the array.
        //

        // Initialize the return value.
        VariantInit( &vResult );

        // The first parameter is the name of the node.
        VariantInit( &rgvaCleanupNodeArgs[ 2 ] );
        rgvaCleanupNodeArgs[ 2 ].vt = VT_BSTR;
        rgvaCleanupNodeArgs[ 2 ].bstrVal = NULL;

        // The second parameter is the delay.
        VariantInit( &rgvaCleanupNodeArgs[ 1 ] );
        rgvaCleanupNodeArgs[ 1 ].vt = VT_UI4;
        rgvaCleanupNodeArgs[ 1 ].ulVal = dwDelayIn;

        // The third parameter is the timeout.
        VariantInit( &rgvaCleanupNodeArgs[ 0 ] );
        rgvaCleanupNodeArgs[ 0 ].vt = VT_UI4;
        rgvaCleanupNodeArgs[ 0 ].ulVal = dwTimeoutIn;

        //
        //  Invoke the CleanupNode() method.
        //
        hr = pDisp->Invoke(
              dispidCleanupNode
            , IID_NULL
            , LOCALE_SYSTEM_DEFAULT
            , DISPATCH_METHOD
            , &dpCleanupNodeParams
            , &vResult
            , NULL
            , NULL
            );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: we could not invoke the CleanupNode() method

        hr = vResult.scode;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: CleanupNode() failed
    } // block:

Cleanup:

    //
    // Free acquired resources
    //

    if ( pDisp != NULL )
    {
        pDisp->Release();
    } // if: we had obtained a pointer to the IDispatch interface

    //
    //  Did the call to CoInitializeEx() above succeed?  If it did then
    //  we need to call CoUnitialize().  Mode changed means we don't need
    //  to call CoUnitialize().
    //
    if ( hrInit != RPC_E_CHANGED_MODE  )
    {
        CoUninitialize();
    } // if:

Exit:

    return hr;

} //*** ClRtlAsyncCleanupNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlHasNodeBeenEvicted()
//
//  Routine Description:
//      Finds out if a registry value indicating that this node has been
//      evicted, is set or not
//
//  Arguments:
//      BOOL *  pfNodeEvictedOut
//          Pointer to the boolean variable that will be set to TRUE if
//          the node has been evicted, but not cleaned up and FALSE
//          otherwise
//
//  Return Value:
//      ERROR_SUCCESS
//          If the eviction state could be successfully determined.
//
//      Other Win32 error codes
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ClRtlHasNodeBeenEvicted( BOOL *  pfNodeEvictedOut )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY  hNodeStateKey = NULL;

    do
    {
        DWORD   dwEvictState = 0;
        DWORD   dwType;
        DWORD   dwSize;

        // Validate parameter
        if ( pfNodeEvictedOut == NULL )
        {
            dwError = ERROR_INVALID_PARAMETER;
            break;
        } // if: the output parameter is invalid

        // Initialize output.
        *pfNodeEvictedOut = FALSE;

        // Open a registry key that holds a value indicating that this node has been evicted.
        dwError = RegOpenKeyEx(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_NODE_DATA
            , 0
            , KEY_ALL_ACCESS
            , &hNodeStateKey
            );

        if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // if: RegOpenKeyEx() has failed

        // Read the required registry value
        dwSize = sizeof( dwEvictState );
        dwError = RegQueryValueEx(
              hNodeStateKey
            , CLUSREG_NAME_EVICTION_STATE
            , 0
            , &dwType
            , reinterpret_cast< BYTE * >( &dwEvictState )
            , &dwSize
            );

        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            // This is ok - absence of the value indicates that this node has not been evicted.
            dwEvictState = 0;
            dwError = ERROR_SUCCESS;
        } // if: RegQueryValueEx did not find the value
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // else if: RegQueryValueEx() has failed

        *pfNodeEvictedOut = ( dwEvictState == 0 ) ? FALSE : TRUE;
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Free acquired resources
    //

    if ( hNodeStateKey != NULL )
    {
        RegCloseKey( hNodeStateKey );
    } // if: we had opened the node state registry key

    return dwError;
} //*** ClRtlHasNodeBeenEvicted()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlPeriodicCleanupThreadProc
//
//  Routine Description:
//      Thread proc for any periodic cleanup tasks that the cluster service
//      may need.
//
//  Arguments:
//      LPVOID lpvThreadContext
//          The context arguments for this thread.
//
//  Return Value:
//      ERROR_SUCCESS
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD
ClRtlPeriodicCleanupThreadProc(
    LPVOID lpvThreadContextIn
    )
{
    for ( ; ; )
    {
        Sleep( PERIODIC_CLEANUP_INTERVAL );
        CoFreeUnusedLibrariesEx( 0, 0 );
    } // for:

    return ERROR_SUCCESS;   // There isn't anyone around to see this...

} //*** ClRtlPeriodicCleanupThreadProc


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlInitiatePeriodicCleanupThread
//
//  Routine Description:
//      Initiate a thread the does period cleanup tasks while the serivce
//      is running.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the cleanup was successfully initiated
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
ClRtlInitiatePeriodicCleanupThread( void )
{
    HRESULT hr = S_OK;
    HANDLE  hThread = NULL;
    DWORD   dwThreadID = 0;

    //
    //  Create the thread...
    //

    hThread = CreateThread( NULL, 0, ClRtlPeriodicCleanupThreadProc, NULL, 0, &dwThreadID );
    if ( hThread != NULL )
    {
        CloseHandle( hThread );
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    } // else:

    return hr;

} //*** ClRtlInitiateEvictNotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\hash.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hash.c

Abstract:

    This is a fairly generic hash table implementation.  This is used to form
    a lookup table for mapping pointers to dwords, so we can send dwords over
    the wire.  This is for sundown.

Author:

    Ken Peery (kpeery) 26-Feb-1999

Revision History:

--*/
#include "clusrtlp.h"

//
//  PLIST_ENTRY
//  NextListEntry(
//      PLIST_ENTRY ListHead
//      );
//

#define NextListEntry(ListHead)  (ListHead)->Flink



//
// local routines
//
DWORD
ClRtlFindUniqueIdHashUnSafe(
    IN PCL_HASH pTable,
    OUT PDWORD  pId
);

PVOID
ClRtlGetEntryHashUnSafe(
    IN PCL_HASH pTable,
    IN DWORD    Id
    );



VOID
ClRtlInitializeHash(
    PCL_HASH pTable
    )
/*++

Routine Description:

    Initializes a hash table for use.

Arguments:

    pTable - Supplies a pointer to a hash table structure to initialize

Return Value:

    None.

--*/

{
    DWORD index;

    if (NULL == pTable) {
        // 
        // We should never call this routine with NULL
        //
        return;
    }

    ZeroMemory(pTable,sizeof(CL_HASH));

    for(index=0; index < MAX_CL_HASH; index++) {
        InitializeListHead(&pTable->Head[index].ListHead);
    }
    
    InitializeCriticalSection(&pTable->Lock);
}



VOID
ClRtlDeleteHash(
    IN PCL_HASH pTable
    )
/*++

Routine Description:

    Releases all resources used by a hash table

Arguments:

    pTable - supplies the hash table to be deleted

Return Value:

    None.

--*/

{
    DWORD index;

    PLIST_ENTRY pItem;

    if (NULL == pTable)
        return;

    EnterCriticalSection(&pTable->Lock);

    for(index=0; index < MAX_CL_HASH; index++) {

        while(!IsListEmpty(&pTable->Head[index].ListHead)) {

            pItem=RemoveHeadList(&pTable->Head[index].ListHead);
            LocalFree(pItem);
        }

    }

    LeaveCriticalSection(&pTable->Lock);

    DeleteCriticalSection(&pTable->Lock);
}



PVOID
ClRtlRemoveEntryHash(
    IN PCL_HASH pTable,
    IN DWORD    Id
    )
/*++

Routine Description:

    Removes the item specified by the Id from the list.  If the item is
    not there then return NULL.  Then save off the pData field and delete this
    entry from the list.  Then return the pData field.

Arguments:

    Id     - the id for the entry to remove
    pTable - the hash table to search

Return Value:

    The pData field of the entry with the matching id, or NULL.

--*/

{
    DWORD index;
    PVOID pData;

    PCL_HASH_ITEM  pItem;

    pData=NULL;
    pItem=NULL;

    if ((Id == 0) || (pTable == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);  
        return NULL;
    }

    index = Id % MAX_CL_HASH;

    //
    // Lock the table for the search
    //

    EnterCriticalSection(&pTable->Lock);

    if (pTable->Head[index].Id == Id) {

        //
        // if the entry is in the head
        //

        pData=pTable->Head[index].pData;

        if (IsListEmpty(&pTable->Head[index].ListHead)) {
    
            //
            // there are no other entries so just zero this one out
            //

            pTable->Head[index].Id = 0;
            pTable->Head[index].pData = NULL;

        } else {
    
            //
            // if there is at least one other entry move that one into the 
            // head and delete it
            //

            pItem=(PCL_HASH_ITEM)RemoveHeadList(&pTable->Head[index].ListHead);
        
            pTable->Head[index].Id = pItem->Id;
            pTable->Head[index].pData = pItem->pData;

            LocalFree(pItem);
        }

    } else {

        pItem=(PCL_HASH_ITEM)NextListEntry(&pTable->Head[index].ListHead);
        do
        {
            if (pItem->Id == Id)
            {
                pData=pItem->pData;

                RemoveEntryList(&pItem->ListHead);
                LocalFree(pItem);

                break;
            }

            pItem=(PCL_HASH_ITEM)NextListEntry(&pItem->ListHead);

        } while(pItem != &pTable->Head[index]);
        
    }

    // cache the now free value

    pTable->CacheFreeId[index]=Id;

    LeaveCriticalSection(&pTable->Lock);

    return(pData);
}



DWORD
ClRtlFindUniqueIdHashUnSafe(
    IN PCL_HASH pTable,
    OUT PDWORD  pId
)

/*++

Routine Description:

    If the tables last id value should rollover we have to make sure that the
    id choosen is unique.  This should only happen under extreme conditions
    but even still we must find a unique id as quickly as possible, the calling
    routine should already have the critical section at this point. 

Arguments:

    pTable - Supplies the hash table to search 

    pId    - sideffect to hold the id or 0 on error

Return Value:

    ERROR_SUCCESS or the appropate Win32 error code.

NOTENOTE:
    This algorithm is fairly slow essentially it is a sequential search with
    a small cache for previously freed values.  We would do better if we kept
    a ranged free list somewhere so that if we rollover we pick from the list.
    The free list would have to be maintained even before we rollover to make 
    sure we had all the available values.

--*/

{
    DWORD OldId;
    DWORD dwErr, index;
    BOOL  bFoundUniqueId;

    PCL_HASH_ITEM pItem;

    dwErr=ERROR_INVALID_PARAMETER;
    bFoundUniqueId=FALSE;
    *pId=0;

    OldId=pTable->LastId;
    
    do
    {
        index=pTable->LastId % MAX_CL_HASH;

        //
        // first check to see if there is a free value in the cache
        //
        if (pTable->CacheFreeId[index] != 0)
        {
            bFoundUniqueId=TRUE;
            *pId=pTable->CacheFreeId[index];
            pTable->CacheFreeId[index]=0;
            break;
        }

        //
        // if the cache is empty at this index, determine if this value
        // is in use.
        //
        if (NULL == ClRtlGetEntryHashUnSafe(pTable, pTable->LastId)) {
            bFoundUniqueId=TRUE;
            *pId=pTable->LastId;
            break; 
        } 

        //
        // ok, this id is in use and nothing in the cache, try the next id 
        //
        pTable->LastId++;
    
        if (pTable->LastId == 0) {
            pTable->LastId++;
        }

    } while(!bFoundUniqueId && (OldId != pTable->LastId));

    if (bFoundUniqueId) {
        dwErr=ERROR_SUCCESS;
    }

    return(dwErr);
}



DWORD
ClRtlInsertTailHash(
    IN PCL_HASH pTable,
    IN PVOID    pData,
    OUT PDWORD  pId
    )

/*++

Routine Description:

    Inserts a new pData value into the tail of one of the entries for the 
    hash table.  The unique id for this entry is returned or 0 on failure.

Arguments:

    pTable - Supplies the hash table to add the entry.

    pData  - Supplies the data entry to be added to the table.

    pId    - sideffect to hold the id or 0 on error

Return Value:

    ERROR_SUCCESS or the appropate Win32 error code.

--*/

{
    DWORD index;
    DWORD dwErr;

    PCL_HASH_ITEM pItem;

    *pId=0;
    dwErr=ERROR_SUCCESS;
    
    if (pTable == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }
    
    EnterCriticalSection(&pTable->Lock);

    pTable->LastId++;

    if (pTable->LastId == 0) {
        pTable->bRollover = TRUE;
        pTable->LastId++;
    }

    index=pTable->LastId % MAX_CL_HASH;

    *pId=pTable->LastId;

    if (pTable->Head[index].Id == 0) {

        //
        // if the first entry then add it to the head
        // 
        // if we rollover, but the head is empty then the id is unique.
        //
        
        pTable->Head[index].Id = *pId;
        pTable->Head[index].pData = pData;

        if (pTable->CacheFreeId[index] == *pId) {
            pTable->CacheFreeId[index]=0;
        }

    } else {

        // if this is not the first entry then add it to the end.

        pItem=(PCL_HASH_ITEM)LocalAlloc(LMEM_FIXED,sizeof(CL_HASH_ITEM));

        if (NULL == pItem) {

            dwErr=ERROR_NOT_ENOUGH_MEMORY;

        } else {

            if (pTable->bRollover) {
                dwErr=ClRtlFindUniqueIdHashUnSafe(pTable, pId);
            }

            if (dwErr == ERROR_SUCCESS)
            {
                pItem->Id = *pId;
                pItem->pData = pData;
    
                index= *pId % MAX_CL_HASH;

                if (pTable->CacheFreeId[index] == *pId) {
                    pTable->CacheFreeId[index]=0;
                }

                InsertTailList(&pTable->Head[index].ListHead,&pItem->ListHead);
            }
            else
            {
                LocalFree(pItem);
            }
        }
    }

    LeaveCriticalSection(&pTable->Lock);

    return(dwErr);
}



PVOID
ClRtlGetEntryHash(
    IN PCL_HASH pTable,
    IN DWORD    Id
    )
/*++

Routine Description:

    Gets the data portion of the item specified by the Id from the hash table.
    If the item is not there then return NULL. 

Arguments:

    Id     - the id for the entry to find
    pTable - the hash table to search

Return Value:

    The pData field of the entry with the matching id, or NULL.

--*/

{
    PVOID pData;

    pData=NULL;

    if ((Id == 0) || (pTable == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);  
        return NULL;
    }

    //
    // Lock the table for the search
    //

    EnterCriticalSection(&pTable->Lock);

    pData=ClRtlGetEntryHashUnSafe(pTable,Id);

    LeaveCriticalSection(&pTable->Lock);

    if (pData == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);  
    }

    return(pData);
}



PVOID
ClRtlGetEntryHashUnSafe(
    IN PCL_HASH pTable,
    IN DWORD    Id
    )
/*++

Routine Description:

    Gets the data portion of the item specified by the Id from the hash table.
    If the item is not there then return NULL. 

Arguments:

    Id     - the id for the entry to find
    pTable - the hash table to search

Return Value:

    The pData field of the entry with the matching id, or NULL.

--*/

{
    DWORD index;
    PVOID pData;

    PCL_HASH_ITEM  pItem;

    pData=NULL;
    pItem=NULL;

    if (Id == 0) { 
        return NULL;
    }

    index = Id % MAX_CL_HASH;

    if (pTable->Head[index].Id == Id) {

        //
        // if the entry is in the head
        //

        pData=pTable->Head[index].pData;

    } else {

        pItem=(PCL_HASH_ITEM)NextListEntry(&pTable->Head[index].ListHead);
        do 
        {
            if (pItem->Id == Id) {

                pData=pItem->pData;
                break;
            }

            pItem=(PCL_HASH_ITEM)NextListEntry(&pItem->ListHead);

        } while(pItem != &pTable->Head[index]);
        
    }

    return(pData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\makefile.inc ===
$(O)\tdisk.res: tdisk.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\ipaddr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   ipaddr.c

Abstract:

    Ip Address validation routines.

Author:

    Sunita Shrivastava (sunitas)           July 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    sunitas     07-19-97    created


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <llinfo.h>
#include <wchar.h>
#include <ipexport.h>
#include <cluster.h>
#include <icmpapi.h>
#include <llinfo.h>
#include <ipinfo.h>


//
// Define IP Address ping test data
//
#define ICMP_TTL          128
#define ICMP_TOS            0
#define ICMP_TIMEOUT      500
#define ICMP_TRY_COUNT      4
#define ICMP_BUFFER_SIZE  (sizeof(ICMP_ECHO_REPLY) + 8)





BOOL
ClRtlIsDuplicateTcpipAddress(
    IN IPAddr   IpAddr
    )
/*++

Routine Description:

    This routine checks whether a give IP Address already exists on the
    network.

Arguments:

    IpAddr - The IP Address to check for.

Return Value:

    TRUE if the specified address exists on the network.
    FALSE otherwise.

--*/
{
    DWORD                   status;
    IP_OPTION_INFORMATION   icmpOptionInfo;
    HANDLE                  icmpHandle;
    DWORD                   numberOfReplies;
    DWORD                   i;
    UCHAR                   icmpBuffer[ICMP_BUFFER_SIZE];
    PICMP_ECHO_REPLY        reply;


    icmpHandle = IcmpCreateFile();

    if (icmpHandle != INVALID_HANDLE_VALUE) {
        icmpOptionInfo.OptionsData = NULL;
        icmpOptionInfo.OptionsSize = 0;
        icmpOptionInfo.Ttl = ICMP_TTL;
        icmpOptionInfo.Tos = ICMP_TOS;
        icmpOptionInfo.Flags = 0;

        for (i=0; i<ICMP_TRY_COUNT; i++) {

            numberOfReplies = IcmpSendEcho(
                                  icmpHandle,
                                  IpAddr,
                                  NULL,
                                  0,
                                  &icmpOptionInfo,
                                  icmpBuffer,
                                  ICMP_BUFFER_SIZE,
                                  ICMP_TIMEOUT
                                  );

            reply = (PICMP_ECHO_REPLY) icmpBuffer;

            while (numberOfReplies != 0) {

                if (reply->Status == IP_SUCCESS) {
                    IcmpCloseHandle( icmpHandle );
                    return(TRUE);
                }

                reply++;
                numberOfReplies--;
            }
        }

        IcmpCloseHandle( icmpHandle );
    }

    return(FALSE);

} // ClRtlIsDuplicateTcpipAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\netname.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netname.c

Abstract:

    Routines for validating a network name and making sure
    that it is ok to use.

Author:

    John Vert (jvert) 4/15/1997

Revision History:

--*/
#include "clusrtlp.h"
#include <lmerr.h>
#include <lmcons.h>
#include "icanon.h"
#include "netcan.h"
#include <nb30.h>
#include <msgrutil.h>
#include <lmaccess.h>
#include <lmuse.h>
#include <lmwksta.h>
#include <netlogon.h>
#include <logonp.h>
#include <windns.h>
#include <ipexport.h>

NET_API_STATUS
NET_API_FUNCTION
NetpCheckNetBiosNameNotInUse(
    LPWSTR pszName
    );


BOOL
ClRtlIsNetNameValid(
    IN LPCWSTR NetName,
    OUT OPTIONAL CLRTL_NAME_STATUS *Result,
    IN BOOL CheckIfExists
    )
/*++

Routine Description:

    Validates a network name to make sure it is ok to use.
    If it is not ok, it optionally returns the reason.

    The checks this routine does include:
        Name must not be zero length (NetNameEmpty)
        After conversion to OEM, name must be <= MAX_COMPUTERNAME_LENGTH (NetNameTooLong)
        No spaces (NetNameInvalidChars)
        No internet characters "@, (NetNameInvalidChars)
        Name already present on network (NetNameInUse)

    This routine is netbios-centric in that the name passed in must meet the
    criteria for a valid netbios name. At some point, we'll need to pass in
    the type of validation since it is possible on NT5 to configure a
    netbios-less environment.

Arguments:

    NetName - Supplies the network name.

    Result - if present, returns the exact check that failed.

    CheckIfExists - Specifies whether a check should be made to
        see if the network name exists on the network.

Return Value:

    TRUE - the network name is valid.

    FALSE - the network name is not valid.

--*/

{
    DWORD UnicodeSize;
    WCHAR NetBiosName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD NetBiosSize = sizeof(NetBiosName)/sizeof(NetBiosName[0]);
    BOOL Valid = FALSE;
    CLRTL_NAME_STATUS Reason = NetNameOk;
    DWORD Status;

    //
    // Check the Unicode length.
    //
    UnicodeSize = lstrlenW(NetName);
    if (UnicodeSize == 0) {
        Reason = NetNameEmpty;
        goto error_exit;
    }
    if (UnicodeSize > MAX_COMPUTERNAME_LENGTH) {
        Reason = NetNameTooLong;
        goto error_exit;
    }

    //
    // Now we need to check for an invalid DNS name. If this fails, it is
    // probably because of additional invalid characters. Currently we do not
    // support the thing net setup does where it creates an alternate DNS name
    // that is different than the netbios name. There should be no periods in
    // this name as well, since that will cause the DNS validate name check to
    // fail when this name is brought online.
    //
    Status = DnsValidateName_W( NetName, DnsNameHostnameLabel );
    if ( Status != ERROR_SUCCESS ) {
        if ( Status == DNS_ERROR_NON_RFC_NAME ) {
            Reason = NetNameDNSNonRFCChars;
            // Don't bail out yet, as the name might have more serious problems.
        } else {
            Reason = NetNameInvalidChars;
            goto error_exit;
        }
    }

    //
    // netbios names are converted to multi-byte before being registered. Make
    // sure that conversion doesn't truncate the name.
    //
    if (DnsHostnameToComputerNameW(NetName, NetBiosName, &NetBiosSize) != 0) {
        if (NetBiosSize < UnicodeSize) { // the name needs truncation
            Reason = NetNameTooLong;
            goto error_exit;
        }
    }
    else {
        Reason = NetNameSystemError; // tell the user to call GetLastError
        goto error_exit;
    }
    
    //
    // Now call NetpwNameValidate. This will only check for invalid characters since
    // we have already validated the length.
    //
    if (NetpwNameValidate((LPWSTR)NetName, NAMETYPE_COMPUTER, 0) != ERROR_SUCCESS) {
        Reason = NetNameInvalidChars;
        goto error_exit;
    }

    //
    // Finally, check to see if this name is already present on the network.
    //
    if (CheckIfExists) {
        Status = NetpCheckNetBiosNameNotInUse((LPWSTR)NetName);
        if (Status != NERR_Success) {
            Reason = NetNameInUse;
            goto error_exit;
        }
    }

    if (Reason == NetNameOk) {
        Valid = TRUE;
    }

error_exit:
    if (ARGUMENT_PRESENT(Result)) {
        *Result = Reason;
    }
    return(Valid);
}

#define clearncb(x)     memset((char *)x,'\0',sizeof(NCB))

/*++

Routine Description:

    FmtNcbName - format a name NCB-style

    Given a name, a name type, and a destination address, this
    function copies the name and the type to the destination in
    the format used in the name fields of a Network Control
    Block.


    SIDE EFFECTS

    Modifies 16 bytes starting at the destination address.

Arguments:

    DestBuf - Pointer to the destination buffer.

    Name - Unicode NUL-terminated name string

    Type - Name type number (0, 3, 5, or 32) (3=NON_FWD, 5=FWD)



Return Value:

    NERR_Success - The operation was successful

    Translated Return Code from the Rtl Translate routine.

    NOTE: This should only be called from UNICODE

--*/

NET_API_STATUS
MsgFmtNcbName(
    char *  DestBuf,
    WCHAR * Name,
    DWORD   Type)
  {
    DWORD           i;                // Counter
    NTSTATUS        ntStatus;
    OEM_STRING      ansiString;
    UNICODE_STRING  unicodeString;
    PCHAR           pAnsiString;


    //
    // Convert the unicode name string into an ansi string - using the
    // current locale.
    //
    unicodeString.Length = (USHORT)(wcslen(Name) * sizeof(WCHAR));
    unicodeString.MaximumLength = unicodeString.Length + sizeof(WCHAR);
    unicodeString.Buffer = Name;

    ntStatus = RtlUnicodeStringToOemString(
                &ansiString,
                &unicodeString,
                TRUE);          // Allocate the ansiString Buffer.

    if (!NT_SUCCESS(ntStatus)) {

        return RtlNtStatusToDosError( ntStatus );
    }

    pAnsiString = ansiString.Buffer;
    *(pAnsiString+ansiString.Length) = '\0';

    //
    // copy each character until a NUL is reached, or until NCBNAMSZ-1
    // characters have been copied.
    //
    for (i=0; i < NCBNAMSZ - 1; ++i) {
        if (*pAnsiString == '\0') {
            break;
        }

        //
        // Copy the Name
        //

        *DestBuf++ = (char)toupper(*pAnsiString++);
    }



    //
    // Free the buffer that RtlUnicodeStringToOemString created for us.
    // NOTE:  only the ansiString.Buffer portion is free'd.
    //

    RtlFreeOemString( &ansiString);

    //
    // Pad the name field with spaces
    //
    for(; i < NCBNAMSZ - 1; ++i) {
        *DestBuf++ = ' ';
    }

    //
    // Set the name type.
    //

    *DestBuf = (CHAR) Type;     // Set name type

    return(NERR_Success);
  }

NET_API_STATUS
NET_API_FUNCTION
NetpCheckNetBiosNameNotInUse(
    LPWSTR pszName
    )

/*++

Routine Description:

    Attempt to discover the if the name is in use. If the name shows up on any
    LANA then consider it in use.

Arguments:

    pszName - name to check

Return Value:

    NERR_Success if ok, NERR_NameInUse otherwise

--*/

{
    //
    // initial and delta value used to allocate NAME_BUFFER buffers
    //
#define NUM_NAME_BUFFERS    10

    NCB                     ncb;
    LANA_ENUM               lanaBuffer;
    DWORD                   index;
    UCHAR                   nbStatus;
    NET_API_STATUS          netStatus = NERR_Success;
    DWORD                   numNameBuffers = NUM_NAME_BUFFERS;
    WORD                    aStatBufferSize = (WORD)(sizeof(ADAPTER_STATUS)+ numNameBuffers * sizeof(NAME_BUFFER));
    UCHAR                   staticAStat[ sizeof(ADAPTER_STATUS)+ NUM_NAME_BUFFERS * sizeof(NAME_BUFFER) ];
    PADAPTER_STATUS         adapterStatus;
    PNAME_BUFFER            nameBuffer;

    //
    // Find the number of networks by sending an enum request via
    // Netbios. there is no (easy) way to distinguish netbt from IPX.
    //
    clearncb(&ncb);
    ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
    ncb.ncb_buffer = (PUCHAR)&lanaBuffer;
    ncb.ncb_length = sizeof(LANA_ENUM);

    nbStatus = Netbios (&ncb);
    if (nbStatus != NRC_GOODRET) {
        return( NetpNetBiosStatusToApiStatus( nbStatus ) );
    }

    //
    // clear the NCB and format the remote name appropriately.
    //
    clearncb(&ncb);
    netStatus = MsgFmtNcbName( (char *)ncb.ncb_callname, pszName, 0x20);
    if ( netStatus != NERR_Success ) {
        return ( netStatus );
    }

    //
    // have our buffers initially point to the static buffer
    //
    adapterStatus = (PADAPTER_STATUS)staticAStat;
    nameBuffer = (PNAME_BUFFER)(adapterStatus + 1);

    //
    // cycle through the lanas, issueing an adapter status on the remote name.
    //
    for ( index = 0; index < lanaBuffer.length && netStatus == NERR_Success; index++ ) {
        NetpNetBiosReset( lanaBuffer.lana[index] );

    astat_retry:
        ncb.ncb_command = NCBASTAT;
        ncb.ncb_buffer = (PUCHAR)adapterStatus;
        ncb.ncb_length = aStatBufferSize;
        ncb.ncb_lana_num = lanaBuffer.lana[index];
        nbStatus = Netbios( &ncb );

        if ( nbStatus == NRC_INCOMP ) {

            //
            // buffer not large enough and we don't know how big a buffer we
            // need. allocate a larger buffer and retry the request until we
            // get success or another type of failure.
            //
            if ( (PUCHAR)adapterStatus != staticAStat ) {
                LocalFree( adapterStatus );
            }

            numNameBuffers += NUM_NAME_BUFFERS;
            aStatBufferSize = (WORD)(sizeof(ADAPTER_STATUS)+ numNameBuffers * sizeof(NAME_BUFFER));
            adapterStatus = LocalAlloc( LMEM_FIXED, aStatBufferSize );

            if ( adapterStatus == NULL ) {
                return netStatus;       // err on the side of caution
            }

            nameBuffer = (PNAME_BUFFER)(adapterStatus + 1);
            goto astat_retry;
        } else
        if ( nbStatus == NRC_GOODRET ) {

            //
            // got something back. Look through the list of names to make sure
            // our name is really online. We couldv'e gotten here through a
            // stale name registration.
            //
            while ( adapterStatus->name_count-- ) {
                if (( nameBuffer->name_flags & GROUP_NAME ) == 0 ) {
                    if ( _strnicmp( nameBuffer->name, ncb.ncb_callname, NCBNAMSZ - 1 ) == 0 ) {
                        netStatus = NERR_NameInUse;
                        break;
                    }
                }
                ++nameBuffer;
            }
        }

        if ( netStatus != NERR_Success ) {
            break;
        }
    }

    if ( (PUCHAR)adapterStatus != staticAStat ) {
        LocalFree( adapterStatus );
    }

    return( netStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\inststat.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      InstallState.cpp
//
//  Desription:
//      The function(s) in this file are used to interrogate the state of the
//      Clustering Services installation.
//
//  Author:
//      C. Brent Thomas (a-brentt) 6 May 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include <clusrtlp.h>
#include <stdlib.h>
#include "clusrtl.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlGetClusterInstallState
//
//  Routine Description:
//      This function retrieves an indicator of the state of the Cluster Server
//      installation.
//
//  Arguments:
//      pszNodeName - Name of the node to check, or NULL for the local machine.
//      peState - State value returned from this function:
//          eClusterInstallStateUnknown - indicates that the state of the Cluster
//                                        Server installation could not be determined.
//          eClusterInstallStateFilesCopied - indicates that clusocm.dll has prevoiusly,
//                                            successfully copied the Cluster Server files.
//          eClusterInstallStateConfigured - indicates that the Cluster Server has previously
//                                           been configured successfully.
//          See cluster\inc\clusrtl.h for the definition of eClusterInstallState.
//
//  Return Value:
//      Any error codes returned from RegConnectRegistryW, RegOpenKeyExW, or RegQueryValueExW.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD ClRtlGetClusterInstallState(
    IN LPCWSTR pszNodeName,
    OUT eClusterInstallState * peState
    )
{
    HKEY  hKey = NULL;
    HKEY  hParentKey = HKEY_LOCAL_MACHINE;
    DWORD dwStatus;     // returned by registry API functions
    DWORD dwClusterInstallState;
    DWORD dwValueType;
    DWORD dwDataBufferSize = sizeof( DWORD );

    *peState = eClusterInstallStateUnknown;

    // Connect to a remote computer if specified.

    if ( pszNodeName != NULL )
    {
        dwStatus = RegConnectRegistryW( pszNodeName, HKEY_LOCAL_MACHINE, &hParentKey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            goto FnExit;
        } // if:  error connecting to remote registry
    } // if:  node name specified

    // Read the registry key that indicates whether cluster files are installed.

    dwStatus = RegOpenKeyExW( hParentKey,
                                CLUSREG_KEYNAME_NODE_DATA,
                                0,         // reserved
                                KEY_READ,
                                &hKey );

    // Was the registry key opened successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    // Read the entry.
    dwStatus = RegQueryValueExW( hKey,
                                  CLUSREG_NAME_INSTALLATION_STATE,
                                  0, // reserved
                                  &dwValueType,
                                  (LPBYTE) &dwClusterInstallState,
                                  &dwDataBufferSize );

    // Was the value read successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        }
        goto FnExit;
    }
    if ( dwValueType == REG_DWORD )
    {
        *peState = (eClusterInstallState) dwClusterInstallState;
    }

FnExit:    
    // Close the registry key.
    if ( hKey )
    {
        RegCloseKey( hKey );
    }
    if ( hParentKey != HKEY_LOCAL_MACHINE )
    {
        RegCloseKey( hParentKey );
    }

    return ( dwStatus );

} //*** ClRtlGetClusterInstallState()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlSetClusterInstallState
//
//  Routine Description:
//      This function sets the registry value that records the state of the 
//      Clustering Service installation.
//
//  Arguments:
//      hInstance - The handle to the application instance - necessary for the calls
//          to LoadString.
//    
//      eInstallState - the state to which the registry value should be set.
//
//  Return Value:
//      TRUE - indicates that the registry value was set successfully
//      FALSE - indicates that some error occured.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL ClRtlSetClusterInstallState( eClusterInstallState eInstallState )
{
    //initialize return to FALSE
    BOOL     fReturnValue = FALSE;

    // Set the state of the ClusterInstallationState registry key to indicate
    // that Cluster Server has been configured.

    HKEY     hKey;

    DWORD    dwStatus;     // returned by registry API functions

    // Attempt to open an existing key in the registry.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                CLUSREG_KEYNAME_NODE_DATA,
                                0,         // reserved
                                KEY_WRITE,
                                &hKey );

    // Was the regustry key opened successfully ?

    if ( dwStatus == ERROR_SUCCESS )
    {
        // Update the value.

        DWORD dwClusterInstallState = eInstallState;

        DWORD dwValueType = REG_DWORD;
        DWORD dwDataBufferSize = sizeof( DWORD );

        dwStatus = RegSetValueExW( hKey,
                                    CLUSREG_NAME_INSTALLATION_STATE,
                                    0, // reserved
                                    dwValueType,
                                    (LPBYTE) &dwClusterInstallState,
                                    dwDataBufferSize );

        // Close the registry key.

        RegCloseKey( hKey );

        // Was the value set successfully?

        if ( dwStatus == ERROR_SUCCESS )
        {
            fReturnValue = TRUE;
        }
    }

    return ( fReturnValue );

} //*** ClRtlSetClusterInstallState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\notifications.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Notifications.cpp
//
//  Abstract:
//      Implementation of functions that send out notifications.
//
//  Author:
//      Galen Barbee        GalenB  20-SEP-2001
//      Vijayendra Vasu     vvasu   17-AUG-2000
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////

#define UNICODE 1
#define _UNICODE 1


/////////////////////////////////////////////////////////////////////////////
// Include files
/////////////////////////////////////////////////////////////////////////////
#include <objbase.h>
#include <ClusCfgInternalGuids.h>
#include <ClusCfgServer.h>
#include "clusrtl.h"


/////////////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlStartupNotifyThreadProc
//
//  Routine Description:
//      Thread proc that invokes the startup notification processing and
//      unloads the COM libraries.
//
//  Arguments:
//      lpvThreadContextIn
//          The context arguments for this thread.
//
//  Return Value:
//      ERROR_SUCCESS
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD
ClRtlStartupNotifyThreadProc(
    LPVOID lpvThreadContextIn
    )
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrInit = S_OK;
    IClusCfgStartupNotify * pccsnNotify = NULL;

    //
    //  Initialize COM - make sure it really init'ed or that we're just trying
    //  to change modes on the calling thread.  Attempting to change the mode
    //  is not reason to fail this function.
    //

    hrInit = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( ( hrInit != S_OK ) && ( hrInit != S_FALSE ) && ( hrInit != RPC_E_CHANGED_MODE ) )
    {
        hr = hrInit;
        goto Cleanup;
    } // if:

    hr = CoCreateInstance(
              CLSID_ClusCfgStartupNotify
            , NULL
            , CLSCTX_LOCAL_SERVER
            , __uuidof( pccsnNotify )
            , reinterpret_cast< void ** >( &pccsnNotify )
            );
    if ( FAILED( hr ) )
    {
        goto CleanupCOM;
    } // if: we could not get a pointer to synchronous notification interface

    hr = pccsnNotify->SendNotifications();
    if ( FAILED( hr ) )
    {
        goto CleanupCOM;
    } // if:

CleanupCOM:

    if ( pccsnNotify != NULL )
    {
        pccsnNotify->Release();
    } // if: we had obtained a pointer to the synchronous notification interface

    //
    //  Free the no longer needed COM libraries...
    //

    CoFreeUnusedLibrariesEx( 0, 0 );

    //
    //  Did the call to CoInitializeEx() above succeed?  If it did then
    //  we need to call CoUnitialize().  Mode changed means we don't need
    //  to call CoUnitialize().
    //

    if ( hrInit != RPC_E_CHANGED_MODE )
    {
        CoUninitialize();
    } // if:

Cleanup:

    return ERROR_SUCCESS;   // There isn't anyone around to see this...

} //*** ClRtlStartupNotifyThreadProc


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlInitiateStartupNotification
//
//  Routine Description:
//      Initiate operations that inform interested parties that the cluster
//      service is starting up.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the notification process was successfully initiated
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
ClRtlInitiateStartupNotification( void )
{
    HRESULT hr = S_OK;
    HANDLE  hThread = NULL;
    DWORD   dwThreadID = 0;

    //
    //  Create the thread...
    //

    hThread = CreateThread( NULL, 0, ClRtlStartupNotifyThreadProc, NULL, 0, &dwThreadID );
    if ( hThread != NULL )
    {
        CloseHandle( hThread );
        hr = S_OK;
    } // if:
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    } // else:

    return hr;

} //*** ClRtlInitiateStartupNotification


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlEvictNotifyThreadProc
//
//  Routine Description:
//      Thread proc that invokes the evict notification processing and unloads
//      the COM libraries.
//
//  Arguments:
//      LPVOID lpvThreadContext
//          The context arguments for this thread.
//
//  Return Value:
//      ERROR_SUCCESS
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD
ClRtlEvictNotifyThreadProc(
    LPVOID lpvThreadContextIn
    )
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrInit = S_OK;
    IClusCfgEvictNotify *   pccenNotify = NULL;
    BSTR                    bstrEvictedNodeName = NULL;

    bstrEvictedNodeName = (BSTR) lpvThreadContextIn;

    //
    //  Initialize COM - make sure it really init'ed or that we're just trying
    //  to change modes on the calling thread.  Attempting to change the mode
    //  is not reason to fail this function.
    //

    hrInit = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( ( hrInit != S_OK ) && ( hrInit != S_FALSE ) && ( hrInit != RPC_E_CHANGED_MODE ) )
    {
        hr = hrInit;
        goto Cleanup;
    } // if:

    hr = CoCreateInstance(
              CLSID_ClusCfgEvictNotify
            , NULL
            , CLSCTX_LOCAL_SERVER
            , __uuidof( pccenNotify )
            , reinterpret_cast< void ** >( &pccenNotify )
            );
    if ( FAILED( hr ) )
    {
        goto CleanupCOM;
    } // if: we could not get a pointer to synchronous notification interface

    //
    //  Make the sync COM call...
    //

    hr = pccenNotify->SendNotifications( bstrEvictedNodeName );
    if ( FAILED( hr ) )
    {
        goto CleanupCOM;
    } // if:

CleanupCOM:

    if ( pccenNotify != NULL )
    {
        pccenNotify->Release();
    } // if: we had obtained a pointer to the synchronous notification interface

    //
    //  Free the no longer needed COM libraries...
    //

    CoFreeUnusedLibrariesEx( 0, 0 );

    //
    //  Did the call to CoInitializeEx() above succeed?  If it did then
    //  we need to call CoUnitialize().  Mode changed means we don't need
    //  to call CoUnitialize().
    //

    if ( hrInit != RPC_E_CHANGED_MODE )
    {
        CoUninitialize();
    } // if:

Cleanup:

    //
    //  This routine must clean this up!
    //

    SysFreeString( bstrEvictedNodeName );

    return ERROR_SUCCESS;   // There isn't anyone around to see this...

} //*** ClRtlEvictNotifyThreadProc


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlInitiateEvictNotification
//
//  Routine Description:
//      Initiate operations that inform interested parties that a node
//      has been evicted from the cluster.
//
//  Arguments:
//      pcszNodeNameIn
//          The name of the node that was evicted.  Since this function is
//          not called when the last node is evicted this argument should
//          never be NULL.
//
//  Return Value:
//      S_OK
//          If the notification process was successfully initiated
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
ClRtlInitiateEvictNotification(
    LPCWSTR   pcszNodeNameIn
    )
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeName = NULL;
    HANDLE  hThread = NULL;
    DWORD   dwThreadID = 0;

    //
    //  Validate our arguments...
    //

    if ( pcszNodeNameIn == NULL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    } // if:

    //
    //  Copy the node name into dynamic memory.  BSTRs work well here since we
    //  don't have to keep track of the length...
    //

    bstrNodeName = SysAllocString( pcszNodeNameIn );
    if ( bstrNodeName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

    //
    //  Create the thread...
    //

    hThread = CreateThread( NULL, 0, ClRtlEvictNotifyThreadProc, bstrNodeName, 0, &dwThreadID );
    if ( hThread == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // else:

    CloseHandle( hThread );

    //
    //  Now that the thread has been launched we can give away ownership of
    //  this memory to the thread as we don't want to delete it below.
    //
    //  It's the thread procs responsibility to cleanup this memory.
    //

    bstrNodeName = NULL;            // give away ownership...

    hr = S_OK;

Cleanup:

    SysFreeString( bstrNodeName );

    return hr;

} //*** ClRtlInitiateEvictNotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\lananame.c ===
/*++

Copyright (c) 1996-2002 Microsoft Corporation

Module Name:

    lananame.c

Abstract:

    This module contains routines for discovering the Connectoid name
    associated with a netbios LANA number.

Author:

    Charlie Wickham (charlwi) 07-May-2002

--*/

#define UNICODE 1
#define _UNICODE 1

#include <windows.h>

#include <lmcons.h>
#include <nb30.h>
#include <msgrutil.h>
#include <iphlpapi.h>
#include <objbase.h>

#include "clusrtl.h"

#define clearncb(x)     memset((char *)x,'\0',sizeof(NCB))

DWORD
ClRtlpGetConnectoidNameFromAdapterIndex(
    IN  PCLRTL_NET_ADAPTER_ENUM ClusAdapterEnum,
    IN  DWORD                   AdapterIndex,
    OUT LPWSTR *                ConnectoidName
    )

/*++

Routine Description:

    Look through the adapter enum struct for the matching adapter index. If
    found, create a new buffer and copy the connetoid name into it.

Arguments:

    ClusAdapterEnum - pointer to struct describing adapters on the node

    AdapterIndex - IP's (?) adapter index value

    ConnectoidName - address of pointer to receive address of new buffer

Return Value:

    appropriate Win32 error code

--*/

{
    DWORD   status = ERROR_NOT_FOUND;
    DWORD   index;
    LPWSTR  cName;

    PCLRTL_NET_ADAPTER_INFO  adapterInfo = ClusAdapterEnum->AdapterList;

    for ( index = 0; index < ClusAdapterEnum->AdapterCount; ++index ) {
        if ( adapterInfo->Index == AdapterIndex ) {
            //
            // dup the string into a new buffer since we're going to clobber
            // the adapter info at some point.
            //
            cName = LocalAlloc( 0, ( wcslen( adapterInfo->ConnectoidName ) + 1 ) * sizeof(WCHAR) );
            if ( cName == NULL ) {
                return GetLastError();
            }

            wcscpy( cName, adapterInfo->ConnectoidName );
            *ConnectoidName = cName;
            return ERROR_SUCCESS;
        }

        adapterInfo = adapterInfo->Next;
    }

    return status;
} // ClRtlpGetConnectoidNameFromAdapterIndex

DWORD
ClRtlpGetAdapterIndexFromMacAddress(
    PUCHAR              MacAddress,
    DWORD               MacAddrLength,
    PIP_ADAPTER_INFO    IpAdapterInfo,
    DWORD *             AdapterIndex
    )

/*++

Routine Description:

    For the specified MAC address, look through IP helper's Adatper Info
    struct and find the matching adapter. Copy its index into AdapterIndex.

Arguments:

    MacAddress - pointer to buffer holding MAC address of NIC.

    MacAddrLength - length, in bytes, of address in MacAddress

    IpAdapterInfo - pointer to data returned from IP helper GetAdaptersInfo()

    AdapterIndex - pointer to DWORD that receives the index (if found)

Return Value:

    appropriate Win32 error code

--*/

{
    DWORD   status = ERROR_NOT_FOUND;

    while ( IpAdapterInfo != NULL ) {
        if ( IpAdapterInfo->AddressLength == MacAddrLength ) {
            if ( memcmp( MacAddress, IpAdapterInfo->Address, MacAddrLength ) == 0 ) {
                *AdapterIndex = IpAdapterInfo->Index;
                return ERROR_SUCCESS;
            }
        }

        IpAdapterInfo = IpAdapterInfo->Next;
    }
    
    return status;
} // ClRtlpGetAdapterIndexFromMacAddress

DWORD
ClRtlpGetConnectoidNameFromMacAddress(
    PUCHAR                  MacAddress,
    DWORD                   MacAddrLength,
    LPWSTR *                ConnectoidName,
    PCLRTL_NET_ADAPTER_ENUM ClusAdapterEnum,
    PIP_ADAPTER_INFO        IpAdapterInfo
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    DWORD   status;
    DWORD   adapterIndex;

    //
    // get index from IP helper using MAC address
    //
    status = ClRtlpGetAdapterIndexFromMacAddress(MacAddress,
                                                 MacAddrLength,
                                                 IpAdapterInfo,
                                                 &adapterIndex );

    if ( status == ERROR_SUCCESS ) {
        status = ClRtlpGetConnectoidNameFromAdapterIndex( ClusAdapterEnum, adapterIndex, ConnectoidName );
    }

    return status;

} // ClRtlpGetConnectoidNameFromMacAddress

DWORD
ClRtlGetConnectoidNameFromLANA(
    IN  UCHAR       LanaNumber,
    OUT LPWSTR *    ConnectoidName
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    DWORD   status = ERROR_NOT_FOUND;
    NCB     ncb;

    UCHAR                   nbStatus;
    WORD                    aStatBufferSize = (WORD)(sizeof(ADAPTER_STATUS));
    UCHAR                   astatBuffer[ sizeof(ADAPTER_STATUS) ];
    PADAPTER_STATUS         adapterStatus = (PADAPTER_STATUS)astatBuffer;

    PCLRTL_NET_ADAPTER_ENUM clusAdapterEnum = NULL;

    PIP_ADAPTER_INFO        ipAdapterInfo = NULL;
    DWORD                   ipAdapterInfoSize = 0;

    //
    // get our home grown list of adapter info. The connectoid name is in here
    // but we can't match it directly to a MAC address. The adapter index is
    // in here which we can match to a structure in IP helper API.
    //
    clusAdapterEnum = ClRtlEnumNetAdapters();
    if ( clusAdapterEnum == NULL ) {
        status = GetLastError();
        goto cleanup;
    }

retry_ip_info:
    status = GetAdaptersInfo( ipAdapterInfo, &ipAdapterInfoSize );
    if ( status == ERROR_BUFFER_OVERFLOW ) {
        ipAdapterInfo = LocalAlloc( 0, ipAdapterInfoSize );
        if ( ipAdapterInfo == NULL ) {
            status = GetLastError();
            goto cleanup;
        }

        goto retry_ip_info;
    }
    else if ( status != ERROR_SUCCESS ) {
        goto cleanup;
    }

    //
    // clear the NCB and format the remote name appropriately.
    //
    clearncb(&ncb);
    ncb.ncb_callname[0] = '*';

    NetpNetBiosReset( LanaNumber );

    ncb.ncb_command = NCBASTAT;
    ncb.ncb_buffer = astatBuffer;
    ncb.ncb_length = aStatBufferSize;
    ncb.ncb_lana_num = LanaNumber;
    nbStatus = Netbios( &ncb );

    if ( nbStatus == NRC_GOODRET ) {
        status = ClRtlpGetConnectoidNameFromMacAddress(adapterStatus->adapter_address,
                                                       sizeof( adapterStatus->adapter_address ),
                                                       ConnectoidName,
                                                       clusAdapterEnum,
                                                       ipAdapterInfo );
    }
    else {
        status = NetpNetBiosStatusToApiStatus( nbStatus );
    }

cleanup:
    if ( clusAdapterEnum != NULL ) {
        ClRtlFreeNetAdapterEnum( clusAdapterEnum );
    }

    if ( ipAdapterInfo != NULL ) {
        LocalFree( ipAdapterInfo );
    }

    return status;

} // ClRtlGetConnectoidNameFromLANA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\netcfg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   netcfg.c

Abstract:

    System network configuration grovelling routines

Author:

    Mike Massa (mikemas)           May 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     05-19-97    created


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>

#include <cluster.h>
#include <objbase.h>
#include <devguid.h>

#include <netcon.h>
#include <netconp.h>

#include <regstr.h>

#include <iphlpapi.h>

//
// Private Constants
//
#define TCPIP_INTERFACES_KEY    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"
#define STRING_ARRAY_DELIMITERS " \t,;"

//
// Lan Connection Interface structures, and functions.
//
typedef struct _LANCON_PROPS
{
    GUID                guidId;
    LPWSTR              pszwDeviceName;
    LPWSTR              pszwName;
    NETCON_MEDIATYPE    MediaType;
    NETCON_STATUS       Status;
} LANCON_PROPS;

void ClRtlpFreeLanconProperties(LANCON_PROPS* pLanConProps)
{
    if (pLanConProps)
    {
        LocalFree(pLanConProps->pszwDeviceName);
        LocalFree(pLanConProps->pszwName);
        LocalFree(pLanConProps);
    }
}

HRESULT ClRtlpGetLanconPropsForConnection(IN INetConnection* pNetCon, OUT LANCON_PROPS** ppLanConProps)
{
    HRESULT hr = S_OK;
    INetLanConnection* pNetLanCon = NULL;
    LANCON_PROPS* pLanConProps = NULL;

    *ppLanConProps = NULL;

    if (!pNetCon)
    {
        return E_INVALIDARG;
    }
    if (!ppLanConProps)
    {
        return E_POINTER;
    }

    hr = INetConnection_QueryInterface(pNetCon, &IID_INetLanConnection, &pNetLanCon);
    if (SUCCEEDED(hr))
    {
        pLanConProps = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(LANCON_PROPS));

        if (pLanConProps)
        {
            LANCON_INFO LanCon;
            WCHAR pszConnectionName[MAX_PATH];
            DWORD cchMax = MAX_PATH-1;

            pLanConProps->MediaType = NCM_LAN; // We only get here for LAN type devices (so NCM_LAN is a given).

            hr = INetLanConnection_GetInfo(pNetLanCon, LCIF_COMP | LCIF_NAME, &LanCon);
            if (SUCCEEDED(hr))
            {
                pLanConProps->guidId = LanCon.guid;

                pLanConProps->pszwDeviceName = LocalAlloc(LMEM_FIXED, 
                    lstrlenW(LanCon.szwConnName) * sizeof(WCHAR) + sizeof(UNICODE_NULL));
                if (pLanConProps->pszwDeviceName)
                {
                    lstrcpyW(pLanConProps->pszwDeviceName, LanCon.szwConnName);                    
                    CoTaskMemFree(LanCon.szwConnName);
    
                    hr = HrLanConnectionNameFromGuidOrPath(&pLanConProps->guidId, NULL, pszConnectionName, &cchMax);
                    if (SUCCEEDED(hr))
                    {
                        pLanConProps->pszwName = LocalAlloc(LMEM_FIXED, 
                            lstrlenW(pszConnectionName) * sizeof(WCHAR) + sizeof(UNICODE_NULL));
                        if (pLanConProps->pszwName)
                        {   
                            NETCON_STATUS  Status;
                            lstrcpyW(pLanConProps->pszwName, pszConnectionName);
                 
                            hr = HrGetPnpDeviceStatus(&pLanConProps->guidId, &pLanConProps->Status);
                            if (SUCCEEDED(hr))
                            {
                                *ppLanConProps = pLanConProps;
                                INetLanConnection_Release(pNetLanCon);
                                return S_OK;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        INetLanConnection_Release(pNetLanCon);
    }
    
    if (pLanConProps)
    {
        ClRtlpFreeLanconProperties(pLanConProps);
    }
    
    return hr;
}


//
// Allocing and cloning helper functions
//

#define AllocGracefully(status, result, len, name)                                  \
  result = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, len);                             \
  if (!result) {                                                                    \
      status = GetLastError();                                                      \
      ClRtlLogPrint(LOG_CRITICAL,                                                   \
                    "[ClNet] alloc of %1!hs! (%2!d! bytes) failed, status %3!d!\n", \
                    name,len,status);                                               \
      goto exit_gracefully;                                                         \
  } else {                                                                          \
      status = ERROR_SUCCESS;                                                       \
  }

#define CloneAnsiString(Status,AnsiStr,WideResult) { \
   SIZE_T len = _mbstrlen(AnsiStr) + 1; \
   AllocGracefully(status, WideResult, len * sizeof(WCHAR), # AnsiStr); \
   mbstowcs(WideResult, AnsiStr, len); \
}

#define CloneWideString(Status,WideStr,WideResult) { \
   SIZE_T _size = (wcslen(WideStr) + 1) * sizeof(WCHAR); \
   AllocGracefully(Status, WideResult, _size * sizeof(WCHAR), # WideStr); \
   memcpy(WideResult, WideStr, _size); \
}

VOID
ClRtlpDeleteInterfaceInfo(
    PCLRTL_NET_INTERFACE_INFO  InterfaceInfo
    )
{
    if (InterfaceInfo) {
        LocalFree(InterfaceInfo->InterfaceAddressString);
        LocalFree(InterfaceInfo->NetworkAddressString);
        LocalFree(InterfaceInfo->NetworkMaskString);

        LocalFree(InterfaceInfo);
    }
}  // DeleteInterfaceInfo

PCLRTL_NET_INTERFACE_INFO
ClRtlpCreateInterfaceInfo(
    IN CONST PIP_ADDR_STRING IpAddr
    )
{
    DWORD status;
    PCLRTL_NET_INTERFACE_INFO This = 0;
    ULONG Addr, Mask, Network;

    Addr = inet_addr(IpAddr->IpAddress.String);
    Mask = inet_addr(IpAddr->IpMask.String);
    Network = Addr & Mask;

    if ( (INADDR_NONE == Addr) ||
         (INADDR_NONE == Mask) ||
         ((0 == Network) && Addr && Mask)
       )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] Bad ip addr/mask: %1!X! %2!X! %3!X!\n",
            Addr,
            Mask,
            Network
            );
        status = ERROR_INVALID_PARAMETER;
        goto exit_gracefully;
    }

    AllocGracefully(
        status,
        This,
        sizeof(CLRTL_NET_INTERFACE_INFO),
        "CLRTL_NET_INTERFACE_INFO"
        );

    This->Context = IpAddr -> Context;

    This->InterfaceAddress = Addr;
    This->NetworkMask      = Mask;
    This->NetworkAddress   = Network;

    CloneAnsiString(
        status,
        IpAddr->IpAddress.String,
        This->InterfaceAddressString
        );
    CloneAnsiString(
        status,
        IpAddr->IpMask.String,
        This->NetworkMaskString
        );

    status = ClRtlTcpipAddressToString(
                 Network,
                 &(This->NetworkAddressString)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] ClRtlTcpipAddressToString of %1!X! failed, "
            "status %2!d!\n",
            Network,
            status
            );
        goto exit_gracefully;
    }

exit_gracefully:

    if (status != ERROR_SUCCESS) {
        SetLastError(status);
        if (This) {
            ClRtlpDeleteInterfaceInfo(This);
            This = 0;
        }
    }

    return This;
} // CreateInterfaceInfo

VOID
ClRtlpDeleteAdapter(
    PCLRTL_NET_ADAPTER_INFO adapterInfo
    )
{
    if (adapterInfo) {
        PCLRTL_NET_INTERFACE_INFO interfaceInfo;

        interfaceInfo = adapterInfo->InterfaceList;

        while (interfaceInfo != NULL) {
            PCLRTL_NET_INTERFACE_INFO next = interfaceInfo->Next;

            ClRtlpDeleteInterfaceInfo(interfaceInfo);

            interfaceInfo = next;
        }

        LocalFree(adapterInfo->DeviceGuid);
        LocalFree(adapterInfo->ConnectoidName);
        LocalFree(adapterInfo->DeviceName);
        LocalFree(adapterInfo->AdapterDomainName);
        LocalFree(adapterInfo->DnsServerList);

        LocalFree(adapterInfo);

        return;
    }
} // DeleteAdapter

DWORD
ClRtlpCreateAdapter(
    IN  PIP_ADAPTER_INFO AdapterInfo,
    OUT PCLRTL_NET_ADAPTER_INFO * ppAdapter)
{
    DWORD status;
    PCLRTL_NET_ADAPTER_INFO adapter = 0;
    *ppAdapter = 0;

    AllocGracefully(status, adapter, sizeof(*adapter), "NET_ADAPTER_INFO");
    ZeroMemory(adapter, sizeof(*adapter));

    //
    // Assumption here is that:
    //
    // AdapterName contains Guid in the form {4082164E-A4B5-11D2-89C3-E37CB6BB13FC}
    // We need to store it without curly brackets
    //

    {
        SIZE_T len = _mbstrlen(AdapterInfo->AdapterName); // not including 0, but including { and } //
        AllocGracefully(status, adapter->DeviceGuid,
                        sizeof(WCHAR) * (len - 1), "adapter->DeviceGuid");
        mbstowcs(adapter->DeviceGuid, AdapterInfo->AdapterName+1, len-1);
        adapter->DeviceGuid[len - 2] = UNICODE_NULL;
    }


    adapter->Index = AdapterInfo->Index;
    {
        PIP_ADDR_STRING IpAddr = &AdapterInfo->IpAddressList;
        while ( IpAddr ) {
            PCLRTL_NET_INTERFACE_INFO interfaceInfo;

            interfaceInfo = ClRtlpCreateInterfaceInfo(IpAddr);

            if (!interfaceInfo) {
                // CreateInterfaceInfo logs the error message //
                // clean up will be done by DeleteAdapter     //
                status = GetLastError();
                goto exit_gracefully;
            }

            interfaceInfo->Next = adapter->InterfaceList;
            adapter->InterfaceList = interfaceInfo;
            ++(adapter->InterfaceCount);

            IpAddr = IpAddr -> Next;
        }

        if (adapter->InterfaceList) {
            adapter->InterfaceList->Flags |= CLRTL_NET_INTERFACE_PRIMARY;
        }
    }

exit_gracefully:
    if (status != ERROR_SUCCESS) {
        ClRtlpDeleteAdapter(adapter);
    } else {
        *ppAdapter = adapter;
    }

    return status;
} // CreateAdapter


PCLRTL_NET_ADAPTER_ENUM
ClRtlpCreateAdapterEnum()
{
    DWORD                   status;
    DWORD                   len;

    PIP_ADAPTER_INFO        SingleAdapter = 0;
    PIP_ADAPTER_INFO        AdapterInfo = 0;
    PCLRTL_NET_ADAPTER_ENUM AdapterEnum = 0;

    len = 0;
    for(;;) {
        status = GetAdaptersInfo(AdapterInfo, &len);
        if (status == ERROR_SUCCESS) {
            break;
        }
        if (status != ERROR_BUFFER_OVERFLOW) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[ClNet] GetAdaptersInfo returned %1!d!\n", status);
            goto exit_gracefully;
        }
        LocalFree(AdapterInfo);    // LocalFree(0) is OK //
        AllocGracefully(status, AdapterInfo, len, "IP_ADAPTER_INFO");
    }

    AllocGracefully(status, AdapterEnum,
                    sizeof(*AdapterEnum), "PCLRTL_NET_ADAPTER_ENUM");
    ZeroMemory(AdapterEnum, sizeof(*AdapterEnum));

    SingleAdapter = AdapterInfo;

    while (SingleAdapter) {
        if (SingleAdapter->Type != MIB_IF_TYPE_LOOPBACK &&
            SingleAdapter->Type != MIB_IF_TYPE_PPP &&
            SingleAdapter->Type != MIB_IF_TYPE_SLIP )
        {
            PCLRTL_NET_ADAPTER_INFO Adapter = 0;

            status = ClRtlpCreateAdapter(SingleAdapter, &Adapter);
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[ClNet] CreateAdapter %1!d! failed, status %2!d!\n",
                              AdapterEnum->AdapterCount, status);
                goto exit_gracefully;
            }

            //
            // Push the adapter into Enumeration List
            //
            Adapter->Next = AdapterEnum->AdapterList;
            AdapterEnum->AdapterList = Adapter;
            ++(AdapterEnum->AdapterCount);
        }

        SingleAdapter = SingleAdapter->Next;
    }

exit_gracefully:
    if (status != ERROR_SUCCESS) {
        SetLastError(status);
        ClRtlFreeNetAdapterEnum(AdapterEnum);
        AdapterEnum = 0;
    }

    LocalFree(AdapterInfo);
    return AdapterEnum;
} // CreateAdapterEnum


HKEY
ClRtlpFindAdapterKey(
    HKEY   TcpInterfacesKey,
    LPWSTR AdapterGuidString
    )

/*++

Routine Description:

    Given the adapter GUID, look through the key names under
    TCP's Interfaces key and see if a match can be found. The
    key names should have the GUID as some part of the name.

Arguments:

    TcpInterfacesKey - handle to TCP's interfaces area

    AdapterGuidString - pointer to string representing adapter's GUID

Return Value:

    Handle to the interface key; otherwise NULL

--*/

{
    HKEY AdapterInterfaceKey = NULL;
    WCHAR KeyName[REGSTR_MAX_VALUE_LENGTH + 1];
    DWORD KeyLength = sizeof( KeyName )/sizeof(TCHAR);
    DWORD index = 0;
    BOOL FoundMatch = FALSE;
    size_t SubStringPos;
    DWORD Status;
    FILETIME FileTime;

    //
    // enum the key names under the interfaces
    //
    do {
        Status = RegEnumKeyEx(TcpInterfacesKey,
                              index,
                              KeyName,
                              &KeyLength,
                              NULL,
                              NULL,
                              NULL,
                              &FileTime);
        if ( Status != ERROR_SUCCESS ) {
            break;
        }

        //
        // find the beginning of the match
        //
        _wcsupr( KeyName );
        if (wcsstr( KeyName, AdapterGuidString )) {
            FoundMatch = TRUE;
            break;
        }

        ++index;
        KeyLength = sizeof( KeyName )/sizeof(TCHAR);
    } while ( TRUE );

    if ( FoundMatch ) {

        Status = RegOpenKeyW(TcpInterfacesKey,
                             KeyName,
                             &AdapterInterfaceKey);
        if ( Status != ERROR_SUCCESS ) {
            AdapterInterfaceKey = NULL;
        }
    }

    return AdapterInterfaceKey;
} // FindAdapterKey


DWORD
ClRtlpConvertIPAddressString(
    LPSTR       DnsServerString,
    PDWORD      ServerCount,
    PDWORD *    ServerList)

/*++

Routine Description:

    Convert the string of DNS server addresses to binary

Arguments:

    DnsServerString - concat'ed string of IP addresses that can be separated
        by white space of commas

    ServerCount - pointer to DWORD that receives # of addresses detected

    ServerList - pointer to DWORD array of converted IP addresses

Return Value:

    ERROR_SUCCESS if everything went ok

--*/

{
#define MAX_DNS_SERVER_ADDRESSES    100

    PCHAR stringPointer = DnsServerString;
    DWORD stringCount = 0;
    PDWORD serverList = NULL;
    LPSTR stringAddress[ MAX_DNS_SERVER_ADDRESSES ];

    //
    // count how many addresses are in the string and null terminate them for
    // inet_addr
    //

    stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
    stringAddress[0] = stringPointer;
    stringCount = 1;

    while (stringCount < MAX_DNS_SERVER_ADDRESSES &&
           (stringPointer = strpbrk(stringPointer, STRING_ARRAY_DELIMITERS)))
    {
        *stringPointer++ = '\0';
        stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
        stringAddress[stringCount] = stringPointer;
        if (*stringPointer) {
            ++stringCount;
        }
    }

    serverList = LocalAlloc( LMEM_FIXED, stringCount * sizeof( DWORD ));
    if ( serverList == NULL ) {
        return GetLastError();
    }

    *ServerCount = stringCount;
    *ServerList = serverList;

    while ( stringCount-- ) {
        serverList[ stringCount ] = inet_addr( stringAddress[ stringCount ]);
    }

    return ERROR_SUCCESS;
} // ConvertIPAddressString


typedef BOOLEAN (*ENUM_CALLBACK)(LANCON_PROPS *,
                                 INetConnection *,
                                 PVOID Context);
HRESULT
ClRtlpHrEnumConnections(
    IN ENUM_CALLBACK enumCallback,
    IN PVOID Context
    )
/*++

Routine Description:

    Enumerate Connection Manager Connections

Arguments:

    enumCallback     - callback to be called for every connection
    Context          - to be passed to a callback

Return Value:

    S_OK or HRESULT error code

--*/
{
    HRESULT                   hr;
    INetConnectionManager     * NcManager = NULL;
    IEnumNetConnection        * EnumNc = NULL;
    INetConnection            * NetConnection = NULL;
    LANCON_PROPS              * NcProps = NULL;
    DWORD                     dwNumConnectionsReturned;
    LPWSTR                    deviceGuidString = NULL;

    //
    // instantiate a connection mgr object and enum the connections
    //
    hr = CoCreateInstance((REFCLSID)&CLSID_ConnectionManager,
                          NULL,
                          CLSCTX_LOCAL_SERVER,
                          (REFIID)&IID_INetConnectionManager,
                          &NcManager);
    if (FAILED(hr)) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[ClNet] INetConnectionManager_CoCreateInstance failed, status %1!X!\n",
                      hr);
        goto exit_gracefully;
    }

    hr = INetConnectionManager_EnumConnections(NcManager,
                                               NCME_DEFAULT,
                                               &EnumNc);
    if (FAILED(hr)) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] INetConnectionManager_EnumConnections failed, status %1!X!\n",
             hr);
        goto exit_gracefully;
    }

    IEnumNetConnection_Reset( EnumNc );

    while (TRUE) {
        hr = IEnumNetConnection_Next(EnumNc,
                                     1,
                                     &NetConnection,
                                     &dwNumConnectionsReturned);
        if (FAILED(hr)) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[ClNet] IEnumNetConnection_Next failed, status %1!X!\n",
                 hr);
            goto exit_gracefully;
        }

        if ( dwNumConnectionsReturned == 0 ) {
            hr = S_OK;
            break;
        }

        hr = ClRtlpGetLanconPropsForConnection(NetConnection, &NcProps);
        if (SUCCEEDED( hr )) {
            BOOLEAN bCont;

            bCont = enumCallback(NcProps, NetConnection, Context);

            ClRtlpFreeLanconProperties(NcProps);
            NcProps = 0;
            if (!bCont) {
                break;
            }
        }
        INetConnection_Release( NetConnection ); NetConnection = NULL;
    }

exit_gracefully:

    if (EnumNc != NULL) {
        IEnumNetConnection_Release( EnumNc );
    }

    if (NcManager != NULL) {
        INetConnectionManager_Release( NcManager );
    }

    return hr;

} // HrEnumConnections


VOID
ClRtlpProcessNetConfigurationAdapter(
    HKEY                      TcpInterfacesKey,
    PCLRTL_NET_ADAPTER_ENUM   adapterEnum,
    LANCON_PROPS              * NCProps,
    LPWSTR                    DeviceGuidString
    )

/*++

Routine Description:

    For a given conn mgr object, determine if it is in use by
    TCP. This is acheived by comparing the adapter ID in the tcpip
    adapter enumeration with the connection object's guid.

Arguments:

    TcpInterfacessKey - handle to the root of the TCP\Parameters\Interfaces area

    adapterEnum - pointer to enumeration of adapters and their interfaces
        actually in use by TCP

    NCProps - Connectoid properties.

    DeviceGuidString - Guid for the connectoid (and for the associated adapter).

Return Value:

    None

--*/

{
    HKEY AdaptersKey;
    HKEY DHCPAdaptersKey = NULL;
    HKEY InterfacesKey = NULL;
    PCLRTL_NET_ADAPTER_INFO adapterInfo = NULL;
    DWORD valueSize;
    DWORD valueType;
    LPWSTR valueName;
    LPSTR ansiValueName;
    BOOL ignoreAdapter = FALSE;
    DWORD NTEContext;
    DWORD Status;
    BOOL dhcpEnabled;

    //
    // Get the TCP/IP interfaces registry key for this adapter.
    //
    InterfacesKey = ClRtlpFindAdapterKey(
                        TcpInterfacesKey,
                        DeviceGuidString
                        );

    if (InterfacesKey == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClNet] No Interfaces key for %1!ws!\n",
            DeviceGuidString
            );
        goto exit_gracefully;
    }

    //
    // see if we should be ignoring this adapter per the registry
    //
    valueSize = sizeof(DWORD);
    Status = RegQueryValueExW(InterfacesKey,
                              L"MSCSHidden",
                              NULL,
                              &valueType,
                              (LPBYTE) &ignoreAdapter,
                              &valueSize);

    if ( Status != ERROR_SUCCESS ) {
        ignoreAdapter = FALSE;
    }

    //
    // Search the enum for this adapter.
    //
    adapterInfo = ClRtlFindNetAdapterById(adapterEnum, DeviceGuidString);

    if (adapterInfo != NULL) {
        CloneWideString(Status, NCProps->pszwDeviceName, adapterInfo->DeviceName);
        CloneWideString(Status, NCProps->pszwName,       adapterInfo->ConnectoidName);

        //
        // Check if this is a hidden netcard.
        //
        if ( ignoreAdapter ) {
            adapterInfo->Flags |= CLRTL_NET_ADAPTER_HIDDEN;
        }

        //
        // Store the NCStatus in the adapter info structure
        //
        adapterInfo->NCStatus = NCProps->Status;

        //
        // get the domain name and DHCP server list (if any) associated
        // with this adapter.  The Domain value has precedence over
        // DhcpDomain. If that value is empty/doesn't exist, then use
        // DhcpDomain only if EnableDHCP is set to one.
        //
        Status = ClRtlRegQueryDword(InterfacesKey,
                                    L"EnableDHCP",
                                    &dhcpEnabled,
                                    NULL);

        if ( Status != ERROR_SUCCESS ) {
            dhcpEnabled = FALSE;
        }

        valueName = L"Domain";
        valueSize = 0;
        Status = RegQueryValueExW(InterfacesKey,
                                  valueName,
                                  NULL,
                                  &valueType,
                                  (LPBYTE)NULL,
                                  &valueSize);

        if ( Status != ERROR_SUCCESS || valueSize == sizeof(UNICODE_NULL)) {

            //
            // it didn't exist or the value was NULL. if were using DHCP,
            // then check to see if DHCP supplied domain name was
            // specified
            //
            if ( dhcpEnabled ) {
                valueName = L"DhcpDomain";
                Status = RegQueryValueExW(InterfacesKey,
                                          valueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)NULL,
                                          &valueSize);
            } else {
                Status = ERROR_FILE_NOT_FOUND;
            }
        }

        if ( Status == ERROR_SUCCESS && valueSize > sizeof(UNICODE_NULL)) {

            //
            // legit domain name was found (somewhere). store it in the
            // adapter info
            //
            adapterInfo->AdapterDomainName = LocalAlloc(LMEM_FIXED,
                                                        valueSize +
                                                        sizeof(UNICODE_NULL));

            if ( adapterInfo->AdapterDomainName != NULL ) {

                Status = RegQueryValueExW(InterfacesKey,
                                          valueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)adapterInfo->AdapterDomainName,
                                          &valueSize);

                if ( Status != ERROR_SUCCESS ) {

                    LocalFree( adapterInfo->AdapterDomainName );
                    adapterInfo->AdapterDomainName = NULL;
                }
#if CLUSTER_BETA
                else {
                    ClRtlLogPrint(LOG_NOISE,
                                    "            %1!ws! key: %2!ws!\n",
                                     valueName,
                                     adapterInfo->AdapterDomainName);
                }
#endif
            } else {
                Status = GetLastError();
            }
        }

        //
        // now get the DNS server list in a similar fashion. The
        // NameServer value has precedence over DhcpNameServer but we only
        // check the DHCP values if DHCP is enabled (just like
        // above). Note that we use the Ansi APIs since we need to convert
        // the IP addresses into binary form and there is no wide char
        // form of inet_addr.
        //
        ansiValueName = "NameServer";
        valueSize = 0;
        Status = RegQueryValueExA(InterfacesKey,
                                  ansiValueName,
                                  NULL,
                                  &valueType,
                                  (LPBYTE)NULL,
                                  &valueSize);

        if ( Status != ERROR_SUCCESS || valueSize == 1 ) {
            if ( dhcpEnabled ) {
                ansiValueName = "DhcpNameServer";
                Status = RegQueryValueExA(InterfacesKey,
                                          ansiValueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)NULL,
                                          &valueSize);
            } else {
                Status = ERROR_FILE_NOT_FOUND;
            }
        }

        if ( Status == ERROR_SUCCESS && valueSize > 0 ) {
            PCHAR nameServerString;

            nameServerString = LocalAlloc( LMEM_FIXED, valueSize + 1 );

            if ( nameServerString != NULL ) {

                Status = RegQueryValueExA(InterfacesKey,
                                          ansiValueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)nameServerString,
                                          &valueSize);

                if ( Status == ERROR_SUCCESS ) {
                    DWORD serverCount;
                    PDWORD serverList;

#if CLUSTER_BETA
                    ClRtlLogPrint(LOG_NOISE,
                                    "            %1!hs! key: %2!hs!\n",
                                     ansiValueName,
                                     nameServerString);
#endif
                    Status = ClRtlpConvertIPAddressString(
                                 nameServerString,
                                 &serverCount,
                                 &serverList
                                 );

                    if ( Status == ERROR_SUCCESS ) {
                        adapterInfo->DnsServerCount = serverCount;
                        adapterInfo->DnsServerList = serverList;
                    } else {
                        adapterInfo->DnsServerCount = 0;
                        adapterInfo->DnsServerList = NULL;
                    }
                } else {
                    adapterInfo->DnsServerCount = 0;
                    adapterInfo->DnsServerList = NULL;
                }

                LocalFree( nameServerString );
            } else {
                Status = GetLastError();
            }
        }
    }

    if ( adapterInfo == NULL ) {
        //
        // TCP/IP is not bound to this adapter right now. PnP?
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[ClNet] Tcpip is not bound to adapter %1!ws!.\n",
            DeviceGuidString
            );
    }

exit_gracefully:

    if (InterfacesKey != NULL) {
        RegCloseKey( InterfacesKey );
    }

    return;
} // ProcessNetConfigurationAdapter


typedef struct _CONFIGURATION_CONTEXT
{
    PCLRTL_NET_ADAPTER_ENUM   adapterEnum;
    HKEY                      TcpInterfacesKey;
}
CONFIGURATION_CONTEXT, *PCONFIGURATION_CONTEXT;

typedef WCHAR GUIDSTR[32 * 3];
VOID GuidToStr(LPGUID Guid, PWCHAR buf)
{
    //
    // GUIDs look like this: 4082164E-A4B5-11D2-89C3-E37CB6BB13FC
    //
    wsprintfW(
        buf,
        L"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
        Guid->Data1, Guid->Data2, Guid->Data3,
        Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
        Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]
        );
}

BOOLEAN
ClRtlpProcessConfigurationCallback(
    LANCON_PROPS * NCProps,
    INetConnection * NetConnection,
    PVOID Context
    )
{
    PCONFIGURATION_CONTEXT Ctx =
        (PCONFIGURATION_CONTEXT) Context;

    if ( NCProps->MediaType == NCM_LAN &&
         NCProps->Status != NCS_HARDWARE_NOT_PRESENT &&
         NCProps->Status != NCS_HARDWARE_DISABLED &&
         NCProps->Status != NCS_HARDWARE_MALFUNCTION)
    {
        GUIDSTR deviceGuidString;
        GuidToStr(&NCProps->guidId, deviceGuidString);

        ClRtlpProcessNetConfigurationAdapter(
            Ctx->TcpInterfacesKey,
            Ctx->adapterEnum,
            NCProps,
            deviceGuidString
            );
        //
        // the strings in the properties struct are either kept or
        // or freed in ProcessNetConfigurationAdapter. If they are
        // used, then they are freed when the adapter enum is freed
        //
    }
    return TRUE;
} // ProcessConfigurationCallback


PCLRTL_NET_ADAPTER_ENUM
ClRtlEnumNetAdapters(
    VOID
    )
/*++

Routine Description:

    Enumerates all of the installed network adapters to which TCP/IP
    is bound.

Arguments:

    None.

Return Value:

    A pointer to a network adapter enumeration, if successful.
    NULL if unsuccessful. Extended error information is available from
    GetLastError().

--*/
{
    DWORD                     status;
    PCLRTL_NET_ADAPTER_INFO   adapterInfo = NULL;
    CONFIGURATION_CONTEXT     Ctx;
    PVOID                    wTimer;

    ZeroMemory(&Ctx, sizeof(Ctx));

    //
    // First get the list of bound adapters & interfaces from the
    // tcpip stack.
    //
    Ctx.adapterEnum = ClRtlpCreateAdapterEnum();
    if (Ctx.adapterEnum == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                        "[ClNet] GetTcpipAdaptersAndInterfaces failed %1!u!\n", status);

        SetLastError(status);
        return(NULL);
    }

    //
    // Open the Services portion of the registry
    //
    status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         TCPIP_INTERFACES_KEY,
                         &Ctx.TcpInterfacesKey);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] Open of TCP Params key failed - %1!u!\n",
            status
            );

        goto exit_gracefully;
    }

	// This function might hang, so setting the watchdog timer to 2 mins (2 * 60 * 1000) ms
	wTimer = ClRtlSetWatchdogTimer(120000, L"Calling EnumConnections");

    status = ClRtlpHrEnumConnections(
                 ClRtlpProcessConfigurationCallback,
                 &Ctx
                 );

    ClRtlCancelWatchdogTimer(wTimer);

    if (status != S_OK) {
        goto exit_gracefully;
    }

    //
    // Finally, ensure that we found a name for each adapter in the enum.
    //
    for (adapterInfo = Ctx.adapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
         )
    {
        if (adapterInfo->ConnectoidName == NULL) {
            if ( adapterInfo->InterfaceCount > 0 ) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[ClNet] No installed adapter was found for IP address %1!ws!\n",
                     adapterInfo->InterfaceList->InterfaceAddressString
                     );
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[ClNet] No installed adapter was found for Tcpip IF entity %1!u!\n",
                     adapterInfo->Index
                     );
            }
            status = ERROR_FILE_NOT_FOUND;
            goto exit_gracefully;
        }
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
                    "[ClNet] Successfully enumerated all adapters and interfaces\n");
#endif

    status = ERROR_SUCCESS;

exit_gracefully:

    if (Ctx.TcpInterfacesKey != NULL) {
        RegCloseKey(Ctx.TcpInterfacesKey);
    }

    if (status != ERROR_SUCCESS) {
        if (Ctx.adapterEnum != NULL) {
            ClRtlFreeNetAdapterEnum(Ctx.adapterEnum);
            Ctx.adapterEnum = NULL;
        }

        SetLastError(status);
    }

    return(Ctx.adapterEnum);

} // ClRtlEnumNetAdapters


VOID
ClRtlFreeNetAdapterEnum(
    IN PCLRTL_NET_ADAPTER_ENUM  AdapterEnum
    )
/*++

Routine Description:

    Frees a network adapter enumeration structure.

Arguments:

    AdapterEnum  -  A pointer to the structure to be freed.

Return Value:

    None.

--*/
{
    if (AdapterEnum) {
        PCLRTL_NET_ADAPTER_INFO p = AdapterEnum -> AdapterList;
        while (p) {
            PCLRTL_NET_ADAPTER_INFO next = p->Next;
            ClRtlpDeleteAdapter(p);
            p = next;
        }
        LocalFree(AdapterEnum);
    }
}  // ClRtlFreeNetAdapterEnum


PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterById(
    PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    LPWSTR                    AdapterId
    )
{
    PCLRTL_NET_ADAPTER_INFO  adapterInfo;


    for ( adapterInfo = AdapterEnum->AdapterList;
          adapterInfo != NULL;
          adapterInfo = adapterInfo->Next
        )
    {
        if (wcscmp(AdapterId, adapterInfo->DeviceGuid) == 0) {
            if (!adapterInfo->Ignore) {
                return(adapterInfo);
            }
            else {
                return(NULL);
            }
        }
    }

    return(NULL);

} // ClRtlFindNetAdapterById


PCLRTL_NET_INTERFACE_INFO
ClRtlFindNetInterfaceByNetworkAddress(
    IN PCLRTL_NET_ADAPTER_INFO   AdapterInfo,
    IN LPWSTR                    NetworkAddress,
    IN LPWSTR                    NetworkMask
    )
{
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;

    for (interfaceInfo = AdapterInfo->InterfaceList;
         interfaceInfo != NULL;
         interfaceInfo = interfaceInfo->Next
        )
    {
        if (interfaceInfo->Ignore == FALSE) {
            //
            // We only look at the primary interface on the
            // adapter right now.
            //
            if (interfaceInfo->Flags & CLRTL_NET_INTERFACE_PRIMARY)
            {
                if ((wcscmp(interfaceInfo->NetworkAddressString, NetworkAddress) == 0) &&
                    (wcscmp(interfaceInfo->NetworkMaskString, NetworkMask) == 0))
                {
                    return(interfaceInfo);
                }
            }
        }
    }

    return(NULL);

} // ClRtlFindNetInterfaceByNetworkAddress


PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByNetworkAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       NetworkAddress,
    IN  LPWSTR                       NetworkMask,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    )
{
    PCLRTL_NET_ADAPTER_INFO    adapterInfo;
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;


    for ( adapterInfo = AdapterEnum->AdapterList;
          adapterInfo != NULL;
          adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Ignore == FALSE) {
            for (interfaceInfo = adapterInfo->InterfaceList;
                 interfaceInfo != NULL;
                 interfaceInfo = interfaceInfo->Next
                )
            {
                if (interfaceInfo->Ignore == FALSE) {
                    //
                    // We only look at the primary interface on the
                    // adapter right now.
                    //
                    if (interfaceInfo->Flags & CLRTL_NET_INTERFACE_PRIMARY) {
                        if ((wcscmp(interfaceInfo->NetworkAddressString, NetworkAddress) == 0) &&
                            (wcscmp(interfaceInfo->NetworkMaskString, NetworkMask) == 0))
                        {
                            *InterfaceInfo = interfaceInfo;

                            return(adapterInfo);
                        }
                    }
                }
            }
        }
    }

    *InterfaceInfo = NULL;

    return(NULL);

} // ClRtlFindNetAdapterByNetworkAddress


PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByInterfaceAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       InterfaceAddressString,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    )
/*++

    For a given IP interface address, find the
    adapter that is hosting that address.

--*/

{
    PCLRTL_NET_ADAPTER_INFO    adapterInfo;
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;

    for ( adapterInfo = AdapterEnum->AdapterList;
          adapterInfo != NULL;
          adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Ignore == FALSE) {
            for (interfaceInfo = adapterInfo->InterfaceList;
                 interfaceInfo != NULL;
                 interfaceInfo = interfaceInfo->Next
                )
            {
                if (interfaceInfo->Ignore == FALSE ) {

                    if ( wcscmp( interfaceInfo->InterfaceAddressString,
                                 InterfaceAddressString ) == 0 ) {
                        *InterfaceInfo = interfaceInfo;
                        return(adapterInfo);
                    }
                }
            }
        }
    }

    *InterfaceInfo = NULL;
    return(NULL);

} // ClRtlFindNetAdapterByInterfaceAddress

PCLRTL_NET_INTERFACE_INFO
ClRtlGetPrimaryNetInterface(
    IN PCLRTL_NET_ADAPTER_INFO  AdapterInfo
    )
{
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;


    for (interfaceInfo = AdapterInfo->InterfaceList;
         interfaceInfo != NULL;
         interfaceInfo = interfaceInfo->Next
        )
    {
        if (interfaceInfo->Flags & CLRTL_NET_INTERFACE_PRIMARY) {
            if (!interfaceInfo->Ignore) {
                return(interfaceInfo);
            }
            else {
                return(NULL);
            }
        }
    }

    return(NULL);

} // ClRtlGetPrimaryNetInterface


LPWSTR
ClRtlGetConnectoidName(
    INetConnection * NetConnection
    )
{
    DWORD                 status;
    LANCON_PROPS *   NcProps = NULL;
    LPWSTR                name = NULL;


    status = ClRtlpGetLanconPropsForConnection(NetConnection, &NcProps);

    if (SUCCEEDED( status )) {
        DWORD nameLength = (lstrlenW(NcProps->pszwName) * sizeof(WCHAR)) +
                           sizeof(UNICODE_NULL);

        name = LocalAlloc(LMEM_FIXED, nameLength);

        if (name != NULL) {
            lstrcpyW(name, NcProps->pszwName);
        }
        else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        ClRtlpFreeLanconProperties( NcProps );
    }
    else {
        SetLastError(status);
    }

    return(name);

} // ClRtlGetConnectoidName


typedef struct _FIND_CONNECTOID_CONTEXT
{
    GUID    ConnectoidGuid;
    LPCWSTR ConnectoidName;
    INetConnection * NetConnection;
}
FIND_CONNECTOID_CONTEXT, *PFIND_CONNECTOID_CONTEXT;

BOOLEAN
ClRtlpFindConnectoidByGuidCallback(
    LANCON_PROPS * NcProp,
    INetConnection * NetConnection,
    PVOID Context
    )
{
    PFIND_CONNECTOID_CONTEXT Ctx =
        (PFIND_CONNECTOID_CONTEXT) Context;

    if ( IsEqualGUID(&Ctx->ConnectoidGuid, &NcProp->guidId) ) {
        INetConnection_AddRef(NetConnection);
        Ctx->NetConnection = NetConnection;
        return FALSE;
    }
    return TRUE;
} // FindConnectoidByGuidCallback

INetConnection *
ClRtlFindConnectoidByGuid(
    LPWSTR ConnectoidGuidStr
    )
{
    FIND_CONNECTOID_CONTEXT Ctx;
    HRESULT hr;
    RPC_STATUS rpcStatus;
    ZeroMemory(&Ctx, sizeof(Ctx));

    rpcStatus = UuidFromStringW (
                    (LPWSTR)ConnectoidGuidStr,
                    &Ctx.ConnectoidGuid);
    if (rpcStatus != ERROR_SUCCESS) {
        SetLastError( HRESULT_FROM_WIN32(rpcStatus) );
        return 0;
    }

    hr = ClRtlpHrEnumConnections(ClRtlpFindConnectoidByGuidCallback, &Ctx);
    if (hr != S_OK) {
        SetLastError(hr);
        return 0;
    } else {
        return Ctx.NetConnection;
    }
} // ClRtlFindConnectoidByGuid

BOOLEAN
ClRtlpFindConnectoidByNameCallback(
    LANCON_PROPS * NcProp,
    INetConnection * NetConnection,
    PVOID Context
    )
{
    PFIND_CONNECTOID_CONTEXT Ctx =
        (PFIND_CONNECTOID_CONTEXT) Context;

    if ( lstrcmpiW(Ctx->ConnectoidName, NcProp->pszwName) == 0 ) {
        INetConnection_AddRef(NetConnection);
        Ctx->NetConnection = NetConnection;
        return FALSE;
    }
    return TRUE;
} // FindConnectoidByNameCallback

INetConnection *
ClRtlFindConnectoidByName(
    LPCWSTR ConnectoidName
    )
{
    FIND_CONNECTOID_CONTEXT Ctx;
    HRESULT hr;
    ZeroMemory(&Ctx, sizeof(Ctx));

    Ctx.ConnectoidName = ConnectoidName;

    hr = ClRtlpHrEnumConnections(ClRtlpFindConnectoidByNameCallback, &Ctx);
    if (hr != S_OK) {
        SetLastError(hr);
        return 0;
    } else {
        return Ctx.NetConnection;
    }
} // ClRtlFindConnectoidByName


DWORD
ClRtlSetConnectoidName(
    INetConnection *  NetConnection,
    LPWSTR            NewConnectoidName
    )

/*++

Routine Description:

    Set the conn mgr object in the connections folder to the
    supplied name. This routine must deal with collisions since
    the name change could be the result of a node joining the
    cluster whose conn obj name in the connection folder had
    changed while the cluster service was stopped on that node.

    If a collision is detected, the existing name is changed to
    have an "(previous)" appended to it.

Arguments:

    NetConnection - Connect object to set.

    NewConnectoidName - new name

Return Value:

    Win32 error status

--*/
{
    DWORD               status = E_UNEXPECTED;
    INetConnection *    connectoidObj;
    LPWSTR              tempName;
    ULONG               iteration = 2;
    GUIDSTR             connectoidGuid;

    //
    // first see if there is a collision with the new name. If so,
    // we'll rename the collided name, since we need to make all
    // the cluster connectoids the same.
    //
    connectoidObj = ClRtlFindConnectoidByName( NewConnectoidName );

    if ( connectoidObj != NULL ) {
        LANCON_PROPS *   NcProps = NULL;


        status = ClRtlpGetLanconPropsForConnection(connectoidObj, &NcProps);

        if (SUCCEEDED( status )) {

            GuidToStr(&NcProps->guidId, connectoidGuid);
            ClRtlpFreeLanconProperties( NcProps );
        }
        else {
            wsprintf(
                &(connectoidGuid[0]),
                L"????????-????-????-????-??????????????"
                );
        }

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClNet] New connectoid name '%1!ws!' collides with name of "
            "existing connectoid (%2!ws!). Renaming existing connectoid.\n",
            NewConnectoidName,
            connectoidGuid
            );

        //
        // allocate enough space for the connectoid name with a trailing
        // "(ddd)". 3 digits for the number should be enough
        //
        tempName = LocalAlloc(
                       LMEM_FIXED,
                       (wcslen( NewConnectoidName ) + 6) * sizeof(WCHAR)
                       );

        if ( tempName == NULL ) {
            INetConnection_Release( connectoidObj );
            return ERROR_OUTOFMEMORY;
        }

        do {
            wsprintf( tempName, L"%s(%u)", NewConnectoidName, iteration++ );
            status = INetConnection_Rename( connectoidObj, tempName );
        } while ( !SUCCEEDED( status ) && iteration <= 999 );

        if ( iteration > 999 ) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[ClNet] Failed to create a unique name for connectoid "
                "'%1!ws!' (%2!ws!)\n",
                NewConnectoidName,
                connectoidGuid
                );

            INetConnection_Release( connectoidObj );

            return(ERROR_DUP_NAME);
        }

        ClRtlLogPrint(LOG_NOISE, 
            "[ClNet] Renamed existing connectoid '%1!ws!' (%2!ws!) to '%3!ws!' "
            "due to a collision with the name of cluster network.\n",
            NewConnectoidName,
            connectoidGuid,
            tempName
            );

        INetConnection_Release( connectoidObj );
    }

    //
    // now set the connectoid to the new name
    //
    status = INetConnection_Rename( NetConnection, NewConnectoidName );

    return status;

} // ClRtlSetConnectoidName



DWORD
ClRtlFindConnectoidByNameAndSetName(
    LPWSTR ConnectoidName,
    LPWSTR NewConnectoidName
    )
{
    DWORD               status = E_UNEXPECTED;
    INetConnection *    connectoidObj;

    connectoidObj = ClRtlFindConnectoidByName( ConnectoidName );

    if ( connectoidObj != NULL ) {
        status = ClRtlSetConnectoidName(connectoidObj, NewConnectoidName);

        INetConnection_Release( connectoidObj );
    }
    else {
        status = GetLastError();
    }

    return(status);

} // ClRtlFindConnectoidByNameAndSetName



DWORD
ClRtlFindConnectoidByGuidAndSetName(
    LPWSTR ConnectoidGuid,
    LPWSTR NewConnectoidName
    )
{
    DWORD               status = E_UNEXPECTED;
    INetConnection *    connectoidObj;

    connectoidObj = ClRtlFindConnectoidByGuid( ConnectoidGuid );

    if ( connectoidObj != NULL ) {
        status = ClRtlSetConnectoidName(connectoidObj, NewConnectoidName);

        INetConnection_Release( connectoidObj );
    }
    else {
        status = GetLastError();
    }

    return(status);

} // ClRtlFindConnectoidByGuidAndSetName


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\oscheck.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    oscheck.c

Abstract:

    Checks all the nooks and crannies of the OS to make sure
    it is ok to run a cluster on it.

Author:

    John Vert (jvert) 11/11/1996

Revision History:

--*/
#include <clusrtlp.h>

#include <winbase.h>

static
DWORD
GetEnableClusterRegValue(
    DWORD * pdwValue
    )
/*++

Routine Description:

    Read the registry override registry value for enabling clusters.

Arguments:

    pdwValue - Return value read from the registry.

Return Value:

    ERROR_SUCCESS if the operation was successful.

    Win32 error code on failure.

--*/

{
    DWORD   sc;
    HKEY    hkey = NULL;
    DWORD   dwType;
    DWORD   cbValue = sizeof( DWORD );

    if ( !ARGUMENT_PRESENT( pdwValue ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Default to the value 0 - not Enabled!
    //
    *pdwValue = 0;

    //
    // Open the registry key containing the value.
    //

    sc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server"),
            0,
            KEY_READ,
            &hkey );
    if ( sc != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Read the override value.
    //

    sc = RegQueryValueEx(
            hkey,
            TEXT("EnableCluster"),
            0,
            &dwType,
            (LPBYTE) pdwValue,
            &cbValue );
    if ( sc != ERROR_SUCCESS ) {
        goto Cleanup;
    }

Cleanup:
    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return( sc );

} // GetEnableClusterRegValue



DWORD
GetServicePack(
    VOID
    )
/*++

Routine Description:

    Figures out what service pack is installed

Arguments:

    None

Return Value:

    The service pack number.

--*/

{
    OSVERSIONINFOW Version;
    LPWSTR p;
    DWORD sp;

    //
    // Check for required operating system version.
    //
    Version.dwOSVersionInfoSize = sizeof(Version);
    GetVersionExW(&Version);
    if (lstrlenW(Version.szCSDVersion) < lstrlenW(L"Service Pack ")) {
        return(0);
    }

    p = &Version.szCSDVersion[0] + lstrlenW(L"Service Pack ");

    sp = wcstoul(p, NULL, 10);

    return(sp);

} // GetServicePack



BOOL
ClRtlIsOSValid(
    VOID
    )
/*++

Routine Description:

    Checks all the nooks and crannies of the OS to see if it is OK to have
    a cluster there.

Arguments:

    None.

Return Value:

    TRUE if it's ok.

    FALSE if it's not ok.

--*/

{
    BOOL            fIsValid = FALSE;
    OSVERSIONINFOEX osiv;
    DWORDLONG       dwlConditionMask;

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // The following call to VerifyVersionInfo() will test the OS level and that the
    // product suite is Enterprise.
    
    osiv.dwMajorVersion = 5;
    osiv.dwMinorVersion = 1;
    osiv.wServicePackMajor = 0;
    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;
 
    dwlConditionMask = (DWORDLONG) 0L;
 
    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if ( VerifyVersionInfo( &osiv,
                            VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR |
                            VER_SUITENAME,
                            dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // Check if embedded
    //
    osiv.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    if ( VerifyVersionInfo( &osiv,
                            VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR |
                            VER_SUITENAME,
                            dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // Is the default node limit greater than 0?
    //
    if ( ClRtlGetDefaultNodeLimit( ClRtlGetSuiteType() ) > 0 ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // If we get here, the this version of the OS won't support clustering.
    //
    SetLastError( ERROR_CLUSTER_WRONG_OS_VERSION );

Cleanup:
    return( fIsValid );

} // ClRtlIsOSValid


BOOL
ClRtlIsOSTypeValid(
    VOID
    )
/*++

Routine Description:

    Checks to see if the operating system type (server, Enterprise, whatever) is
    ok to install a cluster.

Arguments:

    None.

Return Value:

    TRUE if it's ok.

    FALSE if it's not ok.

--*/

{
    BOOL            fIsValid = FALSE;
    OSVERSIONINFOEX osiv;
    DWORDLONG       dwlConditionMask;

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // The call to VerifyVersionInfo will test whether product suite is Advanced
    // Server, aka "Enterprise".
   
    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;

    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
   
    // Is this Datacenter or Advanced Server?

    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    // Is this Embedded NT?

    osiv.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // Is the default node limit greater than 0?
    //
    if ( ClRtlGetDefaultNodeLimit( ClRtlGetSuiteType() ) > 0 ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // If we get here, the this version of the OS won't support clustering.
    //
    SetLastError( ERROR_CLUSTER_WRONG_OS_VERSION );

Cleanup:
    return( fIsValid );

} // ClRtlIsOSTypeValid

//*********************************************************

#define DATACENTER_DEFAULT_NODE_LIMIT 8
#define ADVANCEDSERVER_DEFAULT_NODE_LIMIT 8
#define EMBEDDED_DEFAULT_NODE_LIMIT 4
#define SERVER_DEFAULT_NODE_LIMIT 0 // ** not used currently **

//*********************************************************

DWORD
ClRtlGetDefaultNodeLimit(
    DWORD SuiteType
    )
/*++

Routine Description:

    Determines the default maximum number of nodes allowed in the cluster, based
    on the product suite.

Arguments:

    None.

Return Value:

    The default maximum number of nodes allowed in the cluster.

    Note that this function will return ZERO if the product suite is neither
    DataCenter, Advanced Server (aka Enterprise), nor Embedded.

--*/

{
    DWORD   NodeLimit;
    
    switch( SuiteType )
    {
        case DataCenter:
            NodeLimit = DATACENTER_DEFAULT_NODE_LIMIT;
            break;

        case Enterprise:
            NodeLimit = ADVANCEDSERVER_DEFAULT_NODE_LIMIT;
            break;

        case EmbeddedNT:
            NodeLimit = EMBEDDED_DEFAULT_NODE_LIMIT;
            break;

        case VER_SERVER_NT:
        default:
        {
            DWORD       dwOverride;

            //
            // Check the override registry value.
            //
            GetEnableClusterRegValue( &dwOverride );
            if ( dwOverride != 0 ) {
                NodeLimit = 2;
            } else {
                NodeLimit = 0;
            }
        }
            
    }

    return( NodeLimit );

}  // ClRtlGetDefaultNodeLimit



DWORD
ClRtlGetSuiteType(
    void
    )

/*++

Routine Description:

    Returns the current product suite type.

Arguments:

    None.

Return Value:

    Returns the product suite type DataCenter or Enterprise (aka Advanced Server)
    Returns zero if not DataCenter or Enterprise

--*/

{
    DWORD           dwSuiteType = 0;
    OSVERSIONINFOEX osiv;
    DWORDLONG       dwlConditionMask;

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // First check if product suite is DataCenter.

    osiv.wSuiteMask = VER_SUITE_DATACENTER;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
   
    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) == TRUE )
    {
      // This is DataCenter.

      dwSuiteType = DataCenter;
      goto Cleanup;
    }

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // Next check if this is Advanced Server (Enterprise).

    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) == TRUE )
    {
        dwSuiteType = Enterprise;
        goto Cleanup;
    }

    // Next check if this is Embedded.

    osiv.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) == TRUE )
    {
        dwSuiteType = EmbeddedNT;
        goto Cleanup;
    }

    // Finally check if this is any Server.

    if ( GetVersionEx( (LPOSVERSIONINFO) &osiv ) ) {
        if ( osiv.wProductType == VER_NT_SERVER ) {
            dwSuiteType = VER_SERVER_NT;
            goto Cleanup;
        }
    }

Cleanup:
    return( dwSuiteType );

} // ClRtlGetSuiteType

BOOL
ClRtlIsProcessRunningOnWin64(
    HANDLE hProcess
    )

/*++

Routine Description:

    Returns if the current process is running on Win64

Arguments:

    hProcess : A handle to the process

Return Value:

    Returns TRUE is the process is running on Win64 else returns FALSE.

--*/

{
    BOOL bIsProcessRunningOnWin64 = FALSE;
    BOOL bIsWow64Process;

    //the following was recommended as the way to do 64 bit detection by Samer Arafeh
#ifdef  _WIN64
    bIsProcessRunningOnWin64 = 1;
#else
    if (IsWow64Process(hProcess, &bIsWow64Process)) 
    {
        if (bIsWow64Process != FALSE) 
        {
            bIsProcessRunningOnWin64 = TRUE;
        }
    }
#endif

    return(bIsProcessRunningOnWin64);
    
} // ClRtlIsProcessRunningOnWin64

DWORD ClRtlCheck64BitCompatibility(
    BOOL bIsClusterRunningWin64,
    BOOL bIsNewNodeRunningWin64)
/*++

Routine Description:
    Checks if a node is compatible with the cluster in terms of its bitness.

Arguments:

    bIsClusterRunningWin64 - If the sponsorer(and as a result the cluster) is running on win64.
    bIsNewNodeRunningWin64 - TRUE if the new node or joiner is running on win64.

Return Value:
    Returns ERROR_CLUSTER_INCOMPATIBLE_VERSIONS if the new node must not be allowed to 
    join a cluster due to incompatibility in its bitness else returns ERROR_SUCCESS


--*/
{    


    if (bIsClusterRunningWin64 != bIsNewNodeRunningWin64)
    {
        //SS: need to change the error description to include
        //a message about 32/64 bit incompatibility
        return (ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);
    }
    return(ERROR_SUCCESS);
}



DWORD   ClRtlCheckProcArchCompatibility(
    WORD   wClusterProcessorArchitecture,
    WORD   wNodeProcessorArchitecture)
/*++

Routine Description:
    Checks if a node is compatible with the cluster processor architecture

Arguments:

    wClusterProcessorArchitecture - If the sponsorer(and as a result the cluster) is running on win64.
    wNodeProcessorArchitecture - The processor architecture for a node.

Return Value:
    Returns ERROR_CLUSTER_INCOMPATIBLE_VERSIONS if the new node must not be allowed to 
    join a cluster due to incompatibility in their processor architecture else returns ERROR_SUCCESS

--*/
{

    if (wClusterProcessorArchitecture != wNodeProcessorArchitecture)
    {
        return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);
    }
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\qfstrans.cpp ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    QfsTrans.cpp

Abstract:

    This is a private interface for communications between
    Qfs redirection layer and MNS resource.

Author:

    GorN 8-March-2002

Revision History:

--*/

extern "C" {
#include "clusrtlp.h"
#include "QfsTrans.h"
};

WCHAR SharedMem_MappedFileName[] = L"\\MajorityNodeSet_SharedMemTransport_ver_1.0";

void SharedMem_Cleanup(PSHARED_MEM_CONTEXT Ctxt)
{
    if (Ctxt->Mem) {
        UnmapViewOfFile(Ctxt->Mem);
        Ctxt->Mem = NULL;
    }
    if (Ctxt->FileMappingHandle) {
        CloseHandle(Ctxt->FileMappingHandle);
        Ctxt->FileMappingHandle = 0;
    }
    if (Ctxt->FileHandle) {
        CloseHandle(Ctxt->FileHandle);
        Ctxt->FileHandle = 0;
    }
}

#define USE_FILE_MAPPING    1

DWORD SharedMem_Create(PSHARED_MEM_CONTEXT Ctxt, 
    IN DWORD CreateMode,
    IN DWORD RetrySeconds,
    IN DWORD RequiredSize)
/*++

Routine Description:

    Opens/Create shared file and mapped it into memory

Arguments:

    CreateMode - OPEN_EXISTING for a client, CREATE_ALWAYS for a server side
    RetrySeconds - for how many seconds to retry the CreateFile if it fails
    RequiredSize - how big the file should be (if CreateMode == CREATE_ALWAYS)

Return Value:

    Win32 Status of request

--*/
{
    WCHAR fname[MAX_PATH];
    DWORD Status=ERROR_SUCCESS;
    
    ZeroMemory(Ctxt, sizeof(*Ctxt));

#if !USE_FILE_MAPPING

    Status = ClRtlGetClusterDirectory( fname, MAX_PATH - sizeof(SharedMem_MappedFileName) );
    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[Qfs] SharedMem_Create: Error %1!d! in getting cluster dir !!!\n", Status);
        goto exit_gracefully;
    }

    wcscat(fname, SharedMem_MappedFileName);

    // Try a few times to open a file
    // (Say resmon was able to restart before Qfs layer closed the file)
    for(;;) {
        Ctxt->FileHandle = CreateFile(
            fname,                            // file name
            GENERIC_READ | GENERIC_WRITE,               // access mode
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,         // share
            NULL, // SD
            CreateMode,
            FILE_ATTRIBUTE_TEMPORARY | FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_DELETE_ON_CLOSE, 
            NULL                        // handle to template file
            );
        if (Ctxt->FileHandle != INVALID_HANDLE_VALUE) {
            break;
        }
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[Qfs] SharedMem_Create: failed to open the file, %1!d!\n", Status);
        if (RetrySeconds-- == 0) {
            // no more retries. Return failure
            goto exit_gracefully;
        }
        ClRtlLogPrint(LOG_UNUSUAL, "[Qfs] Retrying in 1 second\n");
        Sleep(1000);
    }

    ClRtlLogPrint(LOG_NOISE, "[Qfs] SharedMem_Create: Created %1!ws!\n", fname);

    if (CreateMode == OPEN_EXISTING) {
        // Figure out the length of the file
        Ctxt->MappingSize = GetFileSize(Ctxt->FileHandle, NULL);
        if (Ctxt->MappingSize == INVALID_FILE_SIZE)
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[Qfs] SharedMem_Create: failed to get the file size, %1!d!\n", Status);
            goto exit_gracefully;
        }
    } else {
        Ctxt->MappingSize = RequiredSize;

        if (!SetFilePointer(Ctxt->FileHandle, Ctxt->MappingSize, 0, FILE_BEGIN)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[Qfs] SharedMem_Create: failed to move file pointer, %1!d!\n", Status);
            goto exit_gracefully;
        }

        if (!SetEndOfFile(Ctxt->FileHandle)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[Qfs] SharedMem_Create: failed to set end of file, %1!d!\n", Status);
            goto exit_gracefully;
        }
    }    

    Ctxt->FileMappingHandle = CreateFileMapping(
        Ctxt->FileHandle,                       // handle to file
        NULL, // security
        PAGE_READWRITE, 0,0,NULL); // 0 offset, no name

    if (Ctxt->FileMappingHandle == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[Qfs] SharedMem_Create: failed to create file mapping, %1!d!\n", GetLastError());
        goto exit_gracefully;
    }

#else
    wsprintf(fname, L"Global%ws", SharedMem_MappedFileName);

    if (CreateMode == OPEN_EXISTING) {
        Ctxt->FileMappingHandle = OpenFileMappingW(FILE_MAP_WRITE, FALSE, fname);

        if (Ctxt->FileMappingHandle == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
            "[Qfs] SharedMem_Create: failed to open file mapping, %1!d!\n", Status);
            goto exit_gracefully;
        }
    }
    else {
        Ctxt->FileMappingHandle = CreateFileMappingW(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            RequiredSize,
            fname);

        if (Ctxt->FileMappingHandle == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
            "[Qfs] SharedMem_Create: failed to open file mapping, %1!d!\n", Status);
            goto exit_gracefully;
        }
        else if((Status = GetLastError()) == ERROR_ALREADY_EXISTS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[Qfs] SharedMem_Create: file mapping already exists, exiting...\n");
            goto exit_gracefully;
        }
        Status = ERROR_SUCCESS;
    }

    if (CreateMode == CREATE_ALWAYS) {
        // Acl the object.
        Status = ClRtlSetObjSecurityInfo(Ctxt->FileMappingHandle,
                    SE_KERNEL_OBJECT,
                    GENERIC_ALL,
                    GENERIC_ALL,
                    0
                    );
        
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[Qfs] SharedMem_Create: failed to ACL the file map, %1!d!\n", Status);
            goto exit_gracefully;
        }
    }

#endif

    Ctxt->Mem = MapViewOfFile(
        Ctxt->FileMappingHandle,   // handle to file-mapping object
        FILE_MAP_WRITE,       // access mode
        0,0,0); // offset 0, map entire file

    if (Ctxt->Mem == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[Qfs] SharedMem_Create: failed to map view of the file, %1!d!\n", GetLastError());
        goto exit_gracefully;
    }

    ClRtlLogPrint(LOG_NOISE, "[Qfs] SharedMem_Create: Created %1!ws!\n", fname);
    
exit_gracefully:
    if (Status != ERROR_SUCCESS) {
        SharedMem_Cleanup(Ctxt);
    }
    return Status;
}

//////////////////////////////////////////////////////////////////////
//////////   Thread Counter Code ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

DWORD ThreadCounter_Init(PMTHREAD_COUNTER tc)
{
    tc->LastThreadLeft = CreateEvent(NULL, TRUE, FALSE, NULL); // manual. non-signalled
    tc->Count = 1;
    if (tc->LastThreadLeft == NULL) {
        DWORD Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[Qfs] ThreadCounter: Failed to allocate the event, error %1!d!\n", Status);
        return Status;
    }
    return ERROR_SUCCESS;
}

void ThreadCounter_Inc(PMTHREAD_COUNTER tc)
{
    DWORD result = InterlockedIncrement(&tc->Count);
}

void ThreadCounter_Dec(PMTHREAD_COUNTER tc)
{
    DWORD result = InterlockedDecrement(&tc->Count);
    if(result == 0) {
        SetEvent(tc->LastThreadLeft);
    }
}

void ThreadCounter_Rundown(PMTHREAD_COUNTER tc)
{
    if (tc->Count == 0) {
        ClRtlLogPrint(LOG_UNUSUAL, "[Qfs] No running threads. No need to rundown\n");
    } else {
        ThreadCounter_Dec(tc);
        WaitForSingleObject(tc->LastThreadLeft, INFINITE);
    }
}

void ThreadCounter_Cleanup(PMTHREAD_COUNTER tc)
{
    if (tc->LastThreadLeft) {
        CloseHandle(tc->LastThreadLeft);
        tc->LastThreadLeft = NULL;
    }
}

enum {SHARED_MEM_HEADER_VERSION = 1};

typedef struct _SHARED_MEM_HEADER {
    DWORD Version;
    DWORD JobBufferCount;
    DWORD ServerPid;
    DWORD State;
    LONG     FilledBuffersMask;
    HANDLE EventHandles[MAX_JOB_BUFFERS + 2];
    
    JOB_BUF JobBuffers[1];
} SHARED_MEM_HEADER, *PSHARED_MEM_HEADER;

//////////////////////////////////////////////////////////////////////
//////////   S  E  R  V  E  R     C  O  D  E  //////////////////////////////////
//////////////////////////////////////////////////////////////////////

VOID MemServer_Cleanup(PSHARED_MEM_SERVER Server)
{
    SharedMem_Cleanup(&Server->ShMem);
    ThreadCounter_Cleanup(&Server->ThreadCounter);
    for(DWORD i = 0; i < Server->nBuffers + 2; ++i) {
        if (Server->EventHandles[i]) {
            CloseHandle(Server->EventHandles[i]);
            Server->EventHandles[i] = 0;
        }
    }
}

DWORD WINAPI DoWork(
    LPVOID lpParameter)
{
    JOB_BUF  volatile* JobBuf = (JOB_BUF  volatile*)lpParameter;
    PSHARED_MEM_SERVER Server = (PSHARED_MEM_SERVER)JobBuf->ServerCookie;
    int BufferNo = (int)(JobBuf - Server->JobBuffers);

    Server->DoRealWork((PJOB_BUF)JobBuf, Server->DoRealWorkContext);

    ThreadCounter_Dec(&Server->ThreadCounter);
    SetEvent(Server->BufferReady[BufferNo]);
    
    return ERROR_SUCCESS;
}

VOID CALLBACK ServerAttentionCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired)
{
    PSHARED_MEM_SERVER Server = (PSHARED_MEM_SERVER)lpParameter;
    LONG FilledBuffers = 0;
    LONG ValueRead, OldValue;

    TimerOrWaitFired; // unused

    ClRtlLogPrint(LOG_NOISE,"[Qfs] ServerAttentionCallback fired\n");

    do {
        ValueRead = *Server->FilledBuffersMask;
        OldValue = InterlockedExchangeAdd(Server->FilledBuffersMask, -ValueRead);
        FilledBuffers += ValueRead;
    } while (ValueRead != OldValue);

    // Queue work items for all the filled buffers //
    for (DWORD i = 0; i < Server->nBuffers; ++i)
    {
        if ( (1 << i) & FilledBuffers ) {
            ThreadCounter_Inc(&Server->ThreadCounter);
            Server->JobBuffers[i].ServerCookie = Server;
            if (!QueueUserWorkItem(DoWork,&Server->JobBuffers[i],WT_EXECUTELONGFUNCTION)) {
                DWORD Status = GetLastError();
                Server->JobBuffers[i].hdr.Status = Status; 
                ClRtlLogPrint(LOG_CRITICAL,"[Qfs] Failed to queue a work item, %1!d!\n", Status);
                ThreadCounter_Dec(&Server->ThreadCounter);
                SetEvent(Server->BufferReady[i]);
            }
        }
    }
}

DWORD MemServer_Online(
    PSHARED_MEM_SERVER Server, 
    int nBuffers,
    DoRealWorkCallback DoRealWork, 
    PVOID DoRealWorkContext)
{
    DWORD Status = ERROR_SUCCESS;
    DWORD RequiredSize = sizeof(SHARED_MEM_HEADER) + (nBuffers-1) * sizeof(JOB_BUF);

    ZeroMemory(Server, sizeof(*Server));

    Server->DoRealWork = DoRealWork;
    Server->DoRealWorkContext = DoRealWorkContext;

    if (nBuffers > MAX_JOB_BUFFERS) {
        return  ERROR_TOO_MANY_SESS;
    }
    
    Status = ThreadCounter_Init(&Server->ThreadCounter);
    if (Status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    for (int i = 0; i < nBuffers + 2; ++i)
    {
        Server->EventHandles[i] = CreateEvent(NULL,FALSE,FALSE,NULL);// auto,non-signaled
        if (Server->EventHandles[i] == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,"Failed to create an event, %1!d!\n", Status);
            goto exit_gracefully;
        }
    }
    Server->Attention = Server->EventHandles[0];
    Server->GoingOffline = Server->EventHandles[1];
    Server->BufferReady = Server->EventHandles + 2;
    Server->nBuffers = nBuffers;

    Status = SharedMem_Create(&Server->ShMem, CREATE_ALWAYS, 6, RequiredSize);
    if (Status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    PSHARED_MEM_HEADER hdr = (PSHARED_MEM_HEADER)Server->ShMem.Mem;
    hdr->Version = SHARED_MEM_HEADER_VERSION;
    hdr->JobBufferCount = nBuffers;

    Server->JobBuffers = hdr->JobBuffers;
    Server->FilledBuffersMask = &hdr->FilledBuffersMask;
    memcpy(hdr->EventHandles, Server->EventHandles, sizeof(HANDLE)*(nBuffers+2));

    // store the current process id last, since it is the first thing client looks at to see
    // whether the server is ready
    InterlockedExchange((volatile LONG*)&hdr->ServerPid, GetCurrentProcessId()); 

    if (!RegisterWaitForSingleObject( 
            &Server->AttentionWaitRegistration,       // wait handle
            Server->Attention,                // handle to object
            ServerAttentionCallback,  // timer callback function
            Server,                  // callback function parameter
            INFINITE,          // time-out interval
            WT_EXECUTEINWAITTHREAD))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[QfsServer] Failed to register a wait handler, status %1!d!\n", Status);
    }

exit_gracefully:
    if (Status != ERROR_SUCCESS) {
        MemServer_Cleanup(Server);
    }
    return Status;
}

void MemServer_Offline(PSHARED_MEM_SERVER Server)
{
    UnregisterWaitEx(Server->AttentionWaitRegistration, INVALID_HANDLE_VALUE);
    // wait for all threads launched to complete
    ThreadCounter_Rundown(&Server->ThreadCounter);
    SetEvent(Server->GoingOffline);
    MemServer_Cleanup(Server);
}

//////////////////////////////////////////////////////////////////////
//////////   C  L  I  E  N  T     C  O  D  E  //////////////////////////////////
//////////////////////////////////////////////////////////////////////


enum { Disconnected, Connected, Draining};

DWORD MemClient_Init(PSHARED_MEM_SERVER Client)
{
    DWORD Status = ERROR_SUCCESS;
    ZeroMemory(Client, sizeof(*Client));
    InitializeCriticalSection(&Client->Lock);
    Client->State = Disconnected;
    Client->FreeBufferCountSemaphore = NULL; // initialized during connect
    return Status;
}

void MemClient_Disconnect(PSHARED_MEM_SERVER Client) // Called with Client->Lock held
{
    ClRtlLogPrint(LOG_NOISE, "[Qfs] Disconnecting ...\n");

    SharedMem_Cleanup(&Client->ShMem);

    if (Client->GoingOfflineWaitRegistration) {
        UnregisterWaitEx(Client->GoingOfflineWaitRegistration, NULL);
        Client->GoingOfflineWaitRegistration = NULL;
    }
    if (Client->ServerProcessWaitRegistration) {
        UnregisterWaitEx(Client->ServerProcessWaitRegistration, NULL);
        Client->ServerProcessWaitRegistration = NULL;
    }
    
    Client->Attention = NULL;
    Client->GoingOffline = NULL;
    Client->BufferReady = NULL;
    Client->State = Disconnected;
    
    for(DWORD i = 0; i < Client->nBuffers + 2; ++i) {
        if (Client->EventHandles[i]) {
            CloseHandle(Client->EventHandles[i]);
            Client->EventHandles[i] = 0;
        }
    }

    if (Client->ServerProcess) {
        CloseHandle(Client->ServerProcess);
        Client->ServerProcess = 0;
    }

    if (Client->FreeBufferCountSemaphore) {
        CloseHandle(Client->FreeBufferCountSemaphore);
        Client->FreeBufferCountSemaphore = NULL;
    }
}

void MemClient_Cleanup(PSHARED_MEM_SERVER Client) 
{
    MemClient_Disconnect(Client); // don't need to acquire Client lock for cleanup
    DeleteCriticalSection(&Client->Lock);
}

VOID CALLBACK MemClient_DisconnectCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired)
{
    PSHARED_MEM_SERVER Client = (PSHARED_MEM_SERVER)lpParameter;
    TimerOrWaitFired; // unused

    ClRtlLogPrint(LOG_NOISE, "[Qfs] DisconnectCallback fired\n");

    EnterCriticalSection(&Client->Lock);
    if (Client->ConnectionRefcount > 0) {
        ClRtlLogPrint(LOG_NOISE, "[Qfs] I/O in progress. Last thread to exit will cleanup\n");
    } else if (Client->State == Disconnected) {
        ClRtlLogPrint(LOG_NOISE, "[Qfs] Already disconnected. Nothing to do\n");
    } else {
        MemClient_Disconnect(Client);
    }
    LeaveCriticalSection(&Client->Lock);
}

DWORD MemClient_Connect(PSHARED_MEM_SERVER Client) // Called with Client->Lock held
{
    DWORD Status = ERROR_SUCCESS;
    DWORD Retry = 3;
    
    Status = SharedMem_Create(&Client->ShMem, OPEN_EXISTING, 0, 0);
    if (Status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }
    
    PSHARED_MEM_HEADER volatile hdr = (PSHARED_MEM_HEADER)Client->ShMem.Mem;

    // There is a chance that we connected to the shared memory immediately after
    // server process created it, but before it initialized it properly
    while (hdr->ServerPid == 0) {
        Sleep(1000);
        if (Retry -- == 0) {
            Status = ERROR_PIPE_NOT_CONNECTED;
            ClRtlLogPrint(LOG_CRITICAL,
                "[Qfs] Connect, Server is not up, error %2!d!\n", hdr->ServerPid, Status);
            goto exit_gracefully;
        }
        ClRtlLogPrint(LOG_UNUSUAL, "[Qfs] Connect, server is not up yet, retrying ...\n");
    }

    Client->nBuffers = hdr->JobBufferCount;
    Client->FilledBuffersMask = &hdr->FilledBuffersMask;
    Client->JobBuffers = hdr->JobBuffers;

    Client->FreeBufferCountSemaphore = CreateSemaphore(0, Client->nBuffers, Client->nBuffers, 0);
    if (Client->FreeBufferCountSemaphore == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[Qfs] Connect, Failed to create semaphore %1!d!, error %2!d!\n", Client->nBuffers, Status);
        goto exit_gracefully;
    }
    
    Client->ServerProcess = OpenProcess(
            PROCESS_DUP_HANDLE|SYNCHRONIZE, FALSE, hdr->ServerPid);
    if (Client->ServerProcess == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[Qfs] Connect, Failed to open process %1!d!, error %2!d!\n", hdr->ServerPid, Status);
        goto exit_gracefully;
    }

    for (DWORD i = 0; i < Client->nBuffers + 2; ++i) 
    {
        if (!DuplicateHandle(
                Client->ServerProcess, hdr->EventHandles[i], 
                GetCurrentProcess(),  &Client->EventHandles[i],
                0, FALSE, DUPLICATE_SAME_ACCESS))
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[Qfs] Connect, Failed to dup the handle %1!p!, error %2!d!\n", 
                hdr->EventHandles[i], Status);
        }
    }

    Client->Attention = Client->EventHandles[0];
    Client->GoingOffline = Client->EventHandles[1];
    Client->BufferReady = Client->EventHandles + 2;  

    Client->State = Connected;

    if (!RegisterWaitForSingleObject( 
            &Client->ServerProcessWaitRegistration,       // wait handle
            Client->ServerProcess,                // handle to object
            MemClient_DisconnectCallback,  // timer callback function
            Client,                  // callback function parameter
            INFINITE,          // time-out interval
            WT_EXECUTEINWAITTHREAD))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[QfsServer] Failed to register a SP wait handler, status %1!d!\n", Status);
        goto exit_gracefully;
    }
    
    if (!RegisterWaitForSingleObject( 
            &Client->GoingOfflineWaitRegistration,       // wait handle
            Client->GoingOffline,                // handle to object
            MemClient_DisconnectCallback,  // timer callback function
            Client,                  // callback function parameter
            INFINITE,          // time-out interval
            WT_EXECUTEINWAITTHREAD))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[QfsServer] Failed to register a GO wait handler, status %1!d!\n", Status);
        goto exit_gracefully;
    }    

    ClRtlLogPrint(LOG_NOISE, "[Qfs] Connected\n");
    
exit_gracefully:
    if (Status != ERROR_SUCCESS) {
        MemClient_Disconnect(Client);
    }
    return Status;
}

DWORD MemClient_ReserveBuffer(PSHARED_MEM_SERVER Client, PJOB_BUF *j)
{
    DWORD Status = ERROR_SUCCESS;

    EnterCriticalSection(&Client->Lock);
    // Figure out whether there is a live connection
    if (Client->State == Draining) {
        Status = ERROR_BROKEN_PIPE;
    } else if (Client->State == Disconnected) {
        Status = MemClient_Connect(Client);
    } else if ( // server died or went offline
         (WaitForSingleObject(Client->GoingOffline,0) == WAIT_OBJECT_0)
       ||(WaitForSingleObject(Client->ServerProcess,0) == WAIT_OBJECT_0))
    {
        if (Client->ConnectionRefcount == 0) { // no in-flight i/o
            MemClient_Disconnect(Client);
            Status = MemClient_Connect(Client);
        } else {
            Status = ERROR_BROKEN_PIPE;
        }
    }
    if (Status != ERROR_SUCCESS) {
        goto fnExit;
    }
    // Refcount the connection and drop the lock, so that we can wait for a free buffer
    ClRtlLogPrint(LOG_NOISE,
        "[Qfs] Reserve RefCount++ %1!d! => %2!d!\n", Client->ConnectionRefcount, Client->ConnectionRefcount+1);
    Client->ConnectionRefcount += 1;
    LeaveCriticalSection(&Client->Lock);

    WaitForSingleObject(Client->FreeBufferCountSemaphore, INFINITE);

    EnterCriticalSection(&Client->Lock);    
    for(DWORD i = 0; i < Client->nBuffers; ++i) {
        if ( ((1 << i) & Client->BusyBuffers) == 0 ) {
            *j = &Client->JobBuffers[i];
            Client->BusyBuffers |= (1 << i);
            Client->JobBuffers[i].ClientCookie = Client;
            break;
        }
    }
fnExit:    
    LeaveCriticalSection(&Client->Lock);
    return Status;
}

DWORD MemClient_DeliverBuffer(PJOB_BUF j)
{
    PSHARED_MEM_SERVER Client = (PSHARED_MEM_SERVER)j->ClientCookie;
    int n = (int)(j - Client->JobBuffers);
    HANDLE WaitHandles[3] = 
        {Client->BufferReady[n], Client->ServerProcess, Client->GoingOffline};
    DWORD wait;
    
    InterlockedExchangeAdd(Client->FilledBuffersMask, 1 << n);
    SetEvent(Client->Attention);
    
    wait = WaitForMultipleObjects(3, WaitHandles, FALSE, INFINITE); 
    if (wait == WAIT_FAILED) {
        DWORD Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[Qfs] DeliverBuffer. Wait failed, error %1!d!\n", Status);
        return Status;
    }
    if (wait == WAIT_OBJECT_0) {
        return ERROR_SUCCESS;
    }
    Client->State = Draining; // safe (State will be changed to (Dis)Connected when all I/O drained)
    return ERROR_BROKEN_PIPE;
}

VOID MemClient_Release(PJOB_BUF j) 
{
    PSHARED_MEM_SERVER Client = (PSHARED_MEM_SERVER)j->ClientCookie;
    int n = (int)(j - Client->JobBuffers);

    EnterCriticalSection(&Client->Lock);    
    
    Client->BusyBuffers &= ~(1 << n); // mark the buffer as free
    ReleaseSemaphore(Client->FreeBufferCountSemaphore, 1, NULL);

    ClRtlLogPrint(LOG_NOISE,
        "[Qfs] Release RefCount-- %1!d! => %2!d!\n", Client->ConnectionRefcount, Client->ConnectionRefcount-1);
    
    if (--Client->ConnectionRefcount  == 0) {
        // Do we need to disconnect?
        if ( (WaitForSingleObject(Client->GoingOffline,0) == WAIT_OBJECT_0)
           ||(WaitForSingleObject(Client->ServerProcess,0) == WAIT_OBJECT_0))
        {
            MemClient_Disconnect(Client);
        }
    }
    LeaveCriticalSection(&Client->Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\regutil.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   regutil.c

Abstract:

    Utilities for accessing the system registry.

Author:

    Mike Massa (mikemas)           May 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     05-19-97    created


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>



LPCWSTR
ClRtlMultiSzEnum(
    IN LPCWSTR MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    )

/*++

 Routine Description:

     Parses a REG_MULTI_SZ string and returns the specified substring.

 Arguments:

    MszString        - A pointer to the REG_MULTI_SZ string.

    MszStringLength  - The length of the REG_MULTI_SZ string in characters,
                       including the terminating null character.

    StringIndex      - Index number of the substring to return. Specifiying
                       index 0 retrieves the first substring.

 Return Value:

    A pointer to the specified substring.

--*/
{
    LPCWSTR   string = MszString;

    if ( MszStringLength < 2  ) {
        return(NULL);
    }

    //
    // Find the start of the desired string.
    //
    while (StringIndex) {

        while (MszStringLength >= 1) {
            MszStringLength -= 1;

            if (*string++ == UNICODE_NULL) {
                break;
            }
        }

        //
        // Check for index out of range.
        //
        if ( MszStringLength < 2 ) {
            return(NULL);
        }

        StringIndex--;
    }

    if ( MszStringLength < 2 ) {
        return(NULL);
    }

    return(string);
}


DWORD
ClRtlMultiSzRemove(
    IN LPWSTR lpszMultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Removes the specified string from the supplied REG_MULTI_SZ.
    The MULTI_SZ is edited in place.

Arguments:

    lpszMultiSz - Supplies the REG_MULTI_SZ string that lpString should
        be removed from.

    StringLength - Supplies the length (in characters) of lpszMultiSz
        Returns the new length (in characters) of lpszMultiSz

    lpString - Supplies the string to be removed from lpszMultiSz

Return Value:

    ERROR_SUCCESS if successful

    ERROR_FILE_NOT_FOUND if the string was not found in the MULTI_SZ

    Win32 error code otherwise

--*/

{
    PCHAR Dest, Src;
    DWORD CurrentLength;
    DWORD i;
    LPCWSTR Next;
    DWORD NextLength;

    //
    // Scan through the strings in the returned MULTI_SZ looking
    // for a match.
    //
    CurrentLength = *StringLength;
    for (i=0; ;i++) {
        Next = ClRtlMultiSzEnum(lpszMultiSz, *StringLength, i);
        if (Next == NULL) {
            //
            // The value was not in the specified multi-sz
            //
            break;
        }
        NextLength = lstrlenW(Next)+1;
        CurrentLength -= NextLength;
        if (lstrcmpiW(Next, lpString)==0) {
            //
            // Found the string, delete it and return
            //
            Dest = (PCHAR)Next;
            Src = (PCHAR)Next + (NextLength*sizeof(WCHAR));
            CopyMemory(Dest, Src, CurrentLength*sizeof(WCHAR));
            *StringLength -= NextLength;
            return(ERROR_SUCCESS);
        }
    }

    return(ERROR_FILE_NOT_FOUND);
}


DWORD
ClRtlMultiSzAppend(
    IN OUT LPWSTR *MultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Appends the specified string to the supplied REG_MULTI_SZ.
    The passed in MultiSz will be freed with LocalFree. A new
    MultiSz large enough to hold the new value will be allocated
    with LocalAlloc and returned in *MultiSz

Arguments:

    lpszMultiSz - Supplies the REG_MULTI_SZ string that lpString should
        be appended to.
        Returns the new REG_MULTI_SZ string with lpString appended

    StringLength - Supplies the length (in characters) of lpszMultiSz
        Returns the new length (in characters) of lpszMultiSz

    lpString - Supplies the string to be appended to lpszMultiSz

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LPWSTR NewMultiSz;
    DWORD Length;
    DWORD NewLength;

    if (*MultiSz == NULL) {

        //
        // There is no multi-sz, create a new multi-sz with lpString as the
        // only entry.
        //
        NewLength = lstrlenW(lpString)+2;
        NewMultiSz = LocalAlloc(LMEM_FIXED, NewLength*sizeof(WCHAR));
        if (NewMultiSz == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        CopyMemory(NewMultiSz, lpString, (NewLength-1)*sizeof(WCHAR));
    } else {
        //
        // Append this string to the existing MULTI_SZ
        //
        Length = lstrlenW(lpString) + 1;
        NewLength = *StringLength + Length;
        NewMultiSz = LocalAlloc(LMEM_FIXED, NewLength * sizeof(WCHAR));
        if (NewMultiSz == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        CopyMemory(NewMultiSz, *MultiSz, *StringLength * sizeof(WCHAR));
        CopyMemory(NewMultiSz + *StringLength - 1, lpString, Length * sizeof(WCHAR));
        NewMultiSz[NewLength-1] = L'\0';
        //Free the passed in MultiSz
        LocalFree(*MultiSz);
    }

    NewMultiSz[NewLength-1] = L'\0';
    *MultiSz = NewMultiSz;
    *StringLength = NewLength;
    return(ERROR_SUCCESS);

}


DWORD
ClRtlMultiSzLength(
    IN LPCWSTR lpszMultiSz
    )
/*++

Routine Description:

    Determines the length (in characters) of a multi-sz. The calculated
    length includes all trailing NULLs.

Arguments:

    lpszMultiSz - Supplies the multi-sz

Return Value:

    The length (in characters) of the supplied multi-sz

--*/

{
    LPCWSTR p;
    DWORD Length=0;

    if(!lpszMultiSz)
        return 0;
        
    if (*lpszMultiSz == UNICODE_NULL)
        return 1;
        
    p=lpszMultiSz;
    do {
        while (p[Length++] != L'\0') {
        }
    } while ( p[Length++] != L'\0' );

    return(Length);
}


LPCWSTR
ClRtlMultiSzScan(
    IN LPCWSTR lpszMultiSz,
    IN LPCWSTR lpszString
    )
/*++

Routine Description:

    Scans a multi-sz looking for an entry that matches the specified string.
    The match is done case-insensitive.

Arguments:

    lpszMultiSz - Supplies the multi-sz to scan.

    lpszString - Supplies the string to look for

Return Value:

    A pointer to the string in the supplied multi-sz if found.

    NULL if not found.

--*/

{
    DWORD dwLength;
    DWORD i;
    LPCWSTR sz;

    dwLength = ClRtlMultiSzLength(lpszMultiSz);
    for (i=0; ; i++) {
        sz = ClRtlMultiSzEnum(lpszMultiSz,
                              dwLength,
                              i);
        if (sz == NULL) {
            break;
        }
        if (lstrcmpiW(sz, lpszString) == 0) {
            break;
        }
    }

    return(sz);
}


DWORD
ClRtlRegQueryDword(
    IN  HKEY    hKey,
    IN  LPWSTR  lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    )

/*++

Routine Description:

    Reads a REG_DWORD registry value. If the value is not present, then
    default to the value supplied in lpDefaultValue (if present).

Arguments:

    hKey        - Open key for the value to be read.

    lpValueName - Unicode name of the value to be read.

    lpValue     - Pointer to the DWORD into which to read the value.

    lpDefaultValue - Optional pointer to a DWORD to use as a default value.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HKEY    Key;
    DWORD   Status;
    DWORD   ValueType;
    DWORD   ValueSize = sizeof(DWORD);


    Status = RegQueryValueExW(
                 hKey,
                 lpValueName,
                 NULL,
                 &ValueType,
                 (LPBYTE)lpValue,
                 &ValueSize
                 );

    if ( Status == ERROR_SUCCESS ) {
        if ( ValueType != REG_DWORD ) {
            Status = ERROR_INVALID_PARAMETER;
        }
    } else {
        if ( ARGUMENT_PRESENT( lpDefaultValue ) ) {
            *lpValue = *lpDefaultValue;
            Status = ERROR_SUCCESS;
        }
    }

    return(Status);

} // ClRtlRegQueryDword



DWORD
ClRtlRegQueryString(
    IN     HKEY     Key,
    IN     LPWSTR   ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = RegQueryValueExW(
                 Key,
                 ValueName,
                 NULL,
                 &valueType,
                 (LPBYTE) *StringBuffer,
                 StringSize
                 );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = LocalAlloc(LMEM_FIXED, *StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            LocalFree(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = RegQueryValueExW(
                     Key,
                     ValueName,
                     NULL,
                     &valueType,
                     (LPBYTE) *StringBuffer,
                     StringSize
                     );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // ClRtlRegQueryString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\queue.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Generic efficient queue package.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

--*/
#include "clusrtlp.h"


DWORD
ClRtlInitializeQueue(
    PCL_QUEUE Queue
    )
/*++

Routine Description:

    Initializes a queue for use.

Arguments:

    Queue - Supplies a pointer to a queue structure to initialize

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;

    InitializeListHead(&Queue->ListHead);
    InitializeCriticalSection(&Queue->Lock);
    Queue->Count = 0;

    Queue->Event = CreateEvent(NULL,
                               TRUE,
                               FALSE,
                               NULL);
    if (Queue->Event == NULL) {
        Status = GetLastError();
        DeleteCriticalSection(&Queue->Lock);
    } else {
        Queue->Abort = CreateEvent(NULL,
                                   TRUE,
                                   FALSE,
                                   NULL);
        if (Queue->Abort == NULL) {
            Status = GetLastError();
            CloseHandle(Queue->Event);
            DeleteCriticalSection(&Queue->Lock);
        } else {
            Status = ERROR_SUCCESS;
        }
    }

    return(Status);

}


VOID
ClRtlDeleteQueue(
    IN PCL_QUEUE Queue
    )
/*++

Routine Description:

    Releases all resources used by a queue.

Arguments:

    Queue - supplies the queue to be deleted

Return Value:

    None.

--*/

{

    DeleteCriticalSection(&Queue->Lock);
    CloseHandle(Queue->Event);
    CloseHandle(Queue->Abort);

    //
    // Zero the memory in order to cause grief to people who try
    // and use a deleted queue.
    //
    ZeroMemory(Queue, sizeof(CL_QUEUE));
}


VOID
ClRtlRundownQueue(
    IN PCL_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Runs down a queue that is about to be destroyed. Any threads currently
    waiting on the queue are unwaited (ClRtlRemoveHeadQueue will return NULL)
    and the contents of the queue (if any) are returned to the caller for
    cleanup.

Arguments:

    Queue - supplies the queue to be rundown

    ListHead - returns the list of items currently in the queue.

Return Value:

    None.

--*/
{
    EnterCriticalSection(&Queue->Lock);
    //
    // Set the aborted event to awaken any threads currently
    // blocked on the queue.
    //
    SetEvent(Queue->Abort);

    //
    // Move the contents of the list into the passed in listhead
    //
    if (IsListEmpty(&Queue->ListHead)) {
        InitializeListHead(ListHead);
    } else {
        *ListHead = Queue->ListHead;
        ListHead->Flink->Blink = ListHead;
        ListHead->Blink->Flink = ListHead;
    }
    Queue->ListHead.Flink = Queue->ListHead.Blink = NULL;
    Queue->Count = 0;

    LeaveCriticalSection(&Queue->Lock);
}


PLIST_ENTRY
ClRtlRemoveHeadQueue(
    IN PCL_QUEUE Queue
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

Return Value:

    Pointer to list entry removed from the head of the queue.

--*/

{
    return(ClRtlRemoveHeadQueueTimeout(Queue, INFINITE,NULL,NULL));
}



PLIST_ENTRY
ClRtlRemoveHeadQueueTimeout(
    IN PCL_QUEUE Queue,
    IN DWORD dwMilliseconds,
    IN CLRTL_CHECK_HEAD_QUEUE_CALLBACK pfnCallback,
    IN OUT PVOID pvContext
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

    Callback - Checks to see whether we should return the event if
        we find one.  This simulates a peek.

    Context - Caller-defined data to be passed in with callback.

Return Value:

    Pointer to list entry removed from the head of the queue.

    NULL if the wait times out, the queue is run down, or the name exceeds
        the buffer length. If this routine returns NULL, GetLastError 
        will return ERROR_INVALID_HANDLE (if the queue has been rundown),
        WAIT_TIMEOUT (to indicate a timeout has occurred)

--*/

{
    DWORD Status;
    PLIST_ENTRY Entry;
    BOOL Empty;
    HANDLE WaitArray[2];
Retry:
    if (Queue->Count == 0) {
        //
        // Block until something is inserted on the queue
        //
        WaitArray[0] = Queue->Abort;
        WaitArray[1] = Queue->Event;
        Status = WaitForMultipleObjects(2, WaitArray, FALSE, dwMilliseconds);
        if ((Status == WAIT_OBJECT_0) ||
            (Status == WAIT_FAILED))  {
            //
            // The queue has been rundown, return NULL immediately.
            //
            SetLastError(ERROR_INVALID_HANDLE);
            return(NULL);
        } else if (Status == WAIT_TIMEOUT) {
            SetLastError(WAIT_TIMEOUT);
            return(NULL);
        }
        CL_ASSERT(Status == 1);
    }

    //
    // Lock the queue and try to remove something
    //
    EnterCriticalSection(&Queue->Lock);
    if (Queue->Count == 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&Queue->Lock);
        goto Retry;
    }

    CL_ASSERT(!IsListEmpty(&Queue->ListHead));

    if ( NULL != pfnCallback ) {
        //
        // We've got a callback function - if it returns ERROR_SUCCESS then dequeue.
        // Otherwise return NULL and SetLastError to whatever error code the callback returns.
        //
        Entry = (&Queue->ListHead)->Flink;
        Status = (*pfnCallback)( Entry, pvContext );
        
        if ( ERROR_SUCCESS == Status ) {
            //
            // The entry is appropriate to pass back.
            //
            Entry = RemoveHeadList(&Queue->ListHead);
        } else {
            Entry = NULL;
        }
        
    } else {
        Entry = RemoveHeadList(&Queue->ListHead);
        Status = ERROR_SUCCESS;
    }

    //
    // Only decrement the count if we removed the event
    //
    if ( NULL != Entry ) {
        //
        // Decrement count and check for empty list.
        //
        if (--Queue->Count == 0) {

            //
            // The queue has transitioned from full to empty,
            // reset the event.
            //
            CL_ASSERT(IsListEmpty(&Queue->ListHead));
            ResetEvent(Queue->Event);
        }
    }
    LeaveCriticalSection(&Queue->Lock);

    SetLastError( Status );
    return(Entry);
}


VOID
ClRtlInsertTailQueue(
    IN PCL_QUEUE Queue,
    IN PLIST_ENTRY Item
    )

/*++

Routine Description:

    Inserts a new entry on the tail of the queue.

Arguments:

    Queue - Supplies the queue to add the entry to.

    Item - Supplies the entry to be added to the queue.

Return Value:

    None.

--*/

{

    EnterCriticalSection(&Queue->Lock);

    InsertTailList(&Queue->ListHead, Item);
    if (++Queue->Count == 1) {
        //
        // The queue has transitioned from empty to full, set
        // the event to awaken any waiters.
        //
        SetEvent(Queue->Event);
    }

    LeaveCriticalSection(&Queue->Lock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\registryvaluename.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      RegistryValueName.cpp
//
//  Abstract:
//      Implementation of the CRegistryValueName class.
//
//  Maintained by:
//      George Potts    (GPotts)    22-APR-2002
//      Vijayendra Vasu (vvasu)     05-FEB-1999
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////

#define UNICODE 1
#define _UNICODE 1

#pragma warning( push ) // Make sure the includes don't change our pragmas.
#include "clusrtlp.h"
#include <string.h>
#include <tchar.h>
#include "RegistryValueName.h"
#include <strsafe.h>
#pragma warning( pop )

/////////////////////////////////////////////////////////////////////////////
//
//  Set the file's warning level to 4.  We can't yet do this
//  for the whole directory.
//
/////////////////////////////////////////////////////////////////////////////
#pragma warning( push, 4 )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScReallocateString
//
//  Routine Description:
//      Delete the old buffer, allocate a new one, and copy in the new string.
//
//  Arguments:
//      ppszOldStringInout
//      pcchOldStringInout   [IN/OUT]
//      pszNewString    [IN]
//
//  Return Value:
//      ERROR_NOT_ENOUGH_MEMORY     Error allocating memory.
//
//      Win32 Error
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
ScReallocateString(
      LPWSTR * ppszOldStringInout
    , size_t * pcchOldStringInout
    , LPCWSTR  pszNewString
    )
{
    DWORD   sc = ERROR_SUCCESS;
    HRESULT hr;
    LPWSTR  pszTemp = NULL;
    size_t  cchString;

    //
    //  If is safe to do this without checking since
    //  we control the args that are sent to this
    //  function.
    //
    delete [] *ppszOldStringInout;
    *ppszOldStringInout = NULL;
    *pcchOldStringInout = 0;

    //
    //  If pszNewString is NULL then the it is appropriate
    //  the ppszOldStringInout remain NULL too.
    //
    if ( pszNewString == NULL )
    {
        sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if:

    cchString = wcslen( pszNewString ) + 1;
    pszTemp = new WCHAR[ cchString ];
    if ( pszTemp == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if:

    hr = StringCchCopyW( pszTemp, cchString, pszNewString );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    *ppszOldStringInout = pszTemp;
    *pcchOldStringInout = cchString;

    pszTemp = NULL;

Cleanup:

    delete [] pszTemp;

    return sc;

} //*** ScReallocateString


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryValueName::ScAssignName
//
//  Routine Description:
//      Deallocates the old buffer, allocates a new one, and initialize
//      it to the string in the pszNewNameIn buffer.
//
//  Arguments:
//      pszName         [IN] Name to assign to the value
//
//  Return Value:
//      ERROR_NOT_ENOUGH_MEMORY     Error allocating memory.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CRegistryValueName::ScAssignName(
    LPCWSTR pszNewNameIn
    )
{

    return ScReallocateString( &m_pszName, &m_cchName, pszNewNameIn );

} //*** ScAssignName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryValueName::ScAssignKeyName
//
//  Routine Description:
//      Deallocates the old buffer, allocates a new one, and initialize
//      it to the string in the pszNewNameIn buffer.
//
//  Arguments:
//      pszName         [IN] Name to assign to the value
//
//  Return Value:
//      ERROR_NOT_ENOUGH_MEMORY     Error allocating memory.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CRegistryValueName::ScAssignKeyName(
    LPCWSTR pszNewNameIn
    )
{

    return ScReallocateString( &m_pszKeyName, &m_cchKeyName, pszNewNameIn );

} //*** ScAssignKeyName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryValueName::ScInit
//
//  Routine Description:
//      Initialize the class.
//
//  Arguments:
//      pszNameIn      [IN] Old value name.
//      pszKeyNameIn   [IN] Old key name.
//
//  Return Value:
//      ERROR_NOT_ENOUGH_MEMORY     Error allocating memory.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRegistryValueName::ScInit(
      LPCWSTR  pszNameIn
    , LPCWSTR  pszKeyNameIn
    )
{
    DWORD   sc = ERROR_SUCCESS;
    LPWSTR  pszBackslashPointer;
    size_t  cchTemp = 0;
    HRESULT hr;

    //
    // pszNameIn corresponds to the value name, and pszKeyNameIn corresponds to
    // the key name.  If the value name is null we just store the key name.
    // If the key name doesn't contain a backslash we just store each
    // of the values.  If the value name contains a backslash we pull out
    // everything before it and slap it on the key name.
    //
    // Example:
    //
    //      { "x\\y", "a\\b" } => { "y", "a\\b\\x" }
    //
    //

    //
    // Start with a clean slate.
    //
    FreeBuffers();

    if ( pszNameIn == NULL )
    {
        sc = ScAssignKeyName( pszKeyNameIn );
        goto Cleanup;
    } // if: no value name specified

    //
    // Look for a backslash in the name.
    //
    pszBackslashPointer = wcsrchr( pszNameIn, L'\\' );
    if ( pszBackslashPointer == NULL )
    {
        //
        // The name does not contain a backslash.
        // No memory allocation need be made.
        //
        sc = ScAssignName( pszNameIn );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:

        sc = ScAssignKeyName( pszKeyNameIn );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:

        goto Cleanup;
    } // if: no backslash found

    //
    // Copy everything past the backslash to m_pszName.
    //
    sc = ScAssignName( pszBackslashPointer + 1 );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    //
    // Count up how much buffer we need - pszKeyNameIn + everything
    // before the backslash.
    //
    m_cchKeyName = 0;
    if ( pszKeyNameIn != NULL )
    {
        m_cchKeyName = wcslen( pszKeyNameIn );
    } // if: key name specified

    m_cchKeyName += ( pszBackslashPointer - pszNameIn );

    //
    // If pszKeyNameIn wasn't specified and there's nothing before the backslash
    // then there's nothing to do - we already assigned m_pszName.
    //
    if ( m_cchKeyName == 0 )
    {
        goto Cleanup;
    } // if:

    //
    // Add one for a possible separating backslash and another for NULL.
    //
    m_cchKeyName += 2;

    m_pszKeyName = new WCHAR[ m_cchKeyName ];
    if ( m_pszKeyName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if:

    //
    // If we have pszKeyNameIn then copy that to the beginning of the buffer.
    //
    if ( pszKeyNameIn != NULL )
    {
        WCHAR * pwch = NULL;

        //
        // Copy the old key name if it exists into the new buffer and
        // append a backslash character to it.
        //
        hr = StringCbCopyExW( m_pszKeyName, m_cchKeyName, pszKeyNameIn, &pwch, NULL, 0 );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        } // if:

        //
        // Make sure we don't append a second backslash.
        //
        cchTemp = wcslen( m_pszKeyName );
        if ( ( cchTemp > 0 ) && ( m_pszKeyName[ cchTemp - 1 ] != L'\\' ) )
        {
            *pwch = L'\\';
            pwch++;
            *pwch = L'\0';
        } // if:
    } // if: key name specified
    else
    {
        //
        // Make sure we're null-terminated for the concatenation.
        //
        m_pszKeyName[ 0 ] = L'\0';
    } // else: no key name specified

    //
    // Concatenate all the characters of pszNameIn up to (but not including)
    // the last backslash character.
    //
    cchTemp = pszBackslashPointer - pszNameIn;
    hr = StringCchCatNW( m_pszKeyName, m_cchKeyName, pszNameIn, cchTemp );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        FreeBuffers();
    } // if:

    return sc;

} //*** CRegistryValueName::ScInit


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegistryValueName::FreeBuffers
//
//  Routine Description:
//      Cleanup our allocations.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CRegistryValueName::FreeBuffers( void )
{
    delete [] m_pszName;
    m_pszName = NULL;
    m_cchName = 0;

    delete [] m_pszKeyName;
    m_pszKeyName = NULL;
    m_cchKeyName = 0;

} //*** CRegistryValueName::FreeBuffers

#pragma warning( pop )  // Reset the pragma level.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\registryvaluename.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      RegistryValueName.h
//
//  Implementation File:
//      RegistryValueName.cpp
//
//  Description:
//      Definition of the CRegistryValueName class.
//
//  Maintained by:
//      George Potts    (GPotts)    22-APR-2002
//      Vijayendra Vasu (vvasu)     05-FEB-1999
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Class CRegistryValueName
//
//  When initialized, this class takes as input the Name and KeyName
//  fields of a property table item. It then initializes its member
//  variables m_pszName and m_pszKeyName as follows.
//
//  m_pszName contains all the characters of Name after the last backslash
//  character.
//  To m_pszKeyName is appended all the characters of Name upto (but not
//  including) the last backslash character.
//
//  For example: If Name is "Groups\AdminExtensions" and KeyName is NULL,
//  m_pszKeyName will be "Groups" and m_pszName will be "AdminExtensions"
//
//  The allocated memory is automatically freed during the destruction of
//  the CRegistryValueName object.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CRegistryValueName
{
private:

    LPWSTR  m_pszName;
    LPWSTR  m_pszKeyName;
    size_t  m_cchName;
    size_t  m_cchKeyName;

    // Disallow copying.
    const CRegistryValueName & operator =( const CRegistryValueName & rhs );
    CRegistryValueName( const CRegistryValueName & source );

    DWORD ScAssignName( LPCWSTR pszNewNameIn );
    DWORD ScAssignKeyName( LPCWSTR pszNewNameIn );

public:

    //
    // Construction.
    //

    // Default constructor
    CRegistryValueName( void )
        : m_pszName( NULL )
        , m_pszKeyName( NULL )
        , m_cchName( 0 )
        , m_cchKeyName( 0 )
    {
    } //*** CRegistryValueName

    // Destructor
    ~CRegistryValueName( void )
    {
        FreeBuffers();

    } //*** ~CRegistryValueName

    //
    // Initialization and deinitialization routines.
    //

    // Initialize the object
    DWORD ScInit( LPCWSTR pszNameIn, LPCWSTR pszKeyNameIn );

    // Deallocate buffers
    void FreeBuffers( void );

public:
    //
    // Access methods.
    //

    LPCWSTR PszName( void ) const
    {
        return m_pszName;

    } //*** PszName

    LPCWSTR PszKeyName( void ) const
    {
        return m_pszKeyName;

    } //*** PszKeyName

}; //*** class CRegistryValueName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\security.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    Security.c

Abstract:

    This module contains common security routines for
    NT Clusters.

Author:

    John Vert (jvert) 12-Mar-1996

--*/

#include "clusrtlp.h"
#include "api_rpc.h"
#include <aclapi.h>
#include <accctrl.h>
#include <malloc.h>
#include <windns.h>

//
// Use this SD to adjust access to tokens so that the cluster
// service can access and adjust privileges.
//
// This is initialized in ClRtlBuildClusterServiceSecurityDescriptor()
// and freed in ClRtlFreeClusterServiceSecurityDescriptor( ).
//
PSECURITY_DESCRIPTOR g_pClusterSecurityDescriptor = NULL;

//
// local defines
//
#define FREE_IF_NOT_NULL( _ptr, _func ) \
    if (( _ptr ) != NULL ) {            \
        _func( _ptr );                  \
    }

LONG
MapSAToRpcSA (
    IN LPSECURITY_ATTRIBUTES lpSA,
    OUT PRPC_SECURITY_ATTRIBUTES lpRpcSA
    )

/*++

Routine Description:

    Maps a SECURITY_ATTRIBUTES structure to a RPC_SECURITY_ATTRIBUTES
    structure by converting the SECURITY_DESCRIPTOR to a form where it can
    be marshalled/unmarshalled.

Arguments:

    lpSA - Supplies a pointer to the SECURITY_ATTRIBUTES structure to be
        converted.

    lpRpcSA - Supplies a pointer to the converted RPC_SECURITY_ATTRIBUTES
        structure.  The caller should free (using RtlFreeHeap) the field
        lpSecurityDescriptor when its finished using it.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_ATTRIBUTES is
        succesfully mapped.

--*/

{
    LONG    Error;

    ASSERT( lpSA != NULL );
    ASSERT( lpRpcSA != NULL );

    //
    // Map the SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR.
    //
    lpRpcSA->RpcSecurityDescriptor.lpSecurityDescriptor = NULL;

    if( lpSA->lpSecurityDescriptor != NULL ) {
        Error = MapSDToRpcSD(
                    lpSA->lpSecurityDescriptor,
                    &lpRpcSA->RpcSecurityDescriptor
                    );
    } else {
        lpRpcSA->RpcSecurityDescriptor.cbInSecurityDescriptor = 0;
        lpRpcSA->RpcSecurityDescriptor.cbOutSecurityDescriptor = 0;
        Error = ERROR_SUCCESS;
    }

    if( Error == ERROR_SUCCESS ) {

        //
        //
        // The supplied SECURITY_DESCRIPTOR was successfully converted
        // to self relative format so assign the remaining fields.
        //

        lpRpcSA->nLength = lpSA->nLength;

        lpRpcSA->bInheritHandle = ( BOOLEAN ) lpSA->bInheritHandle;
    }

    return Error;

} // MapSAToRpcSA

LONG
MapSDToRpcSD (
    IN  PSECURITY_DESCRIPTOR lpSD,
    IN OUT PRPC_SECURITY_DESCRIPTOR lpRpcSD
    )

/*++

Routine Description:

    Maps a SECURITY_DESCRIPTOR to a RPC_SECURITY_DESCRIPTOR by converting
    it to a form where it can be marshalled/unmarshalled.

Arguments:

    lpSD - Supplies a pointer to the SECURITY_DESCRIPTOR
        structure to be converted.

    lpRpcSD - Supplies a pointer to the converted RPC_SECURITY_DESCRIPTOR
        structure. Memory for the security descriptor is allocated if
        not provided. The caller must take care of freeing up the memory
        if necessary.

Return Value:

    LONG - Returns ERROR_SUCCESS if the SECURITY_DESCRIPTOR is
        succesfully mapped.

--*/

{
    DWORD   cbLen;
    LONG    lStatus;
    BOOL    fAllocated = FALSE;

    ASSERT( lpSD != NULL );
    ASSERT( lpRpcSD != NULL );

    if( RtlValidSecurityDescriptor( lpSD )) {

        cbLen = RtlLengthSecurityDescriptor( lpSD );
        CL_ASSERT( cbLen > 0 );

        //
        //  If we're not provided a buffer for the security descriptor,
        //  allocate it.
        //
        if ( !lpRpcSD->lpSecurityDescriptor ) {

            //
            // Allocate space for the converted SECURITY_DESCRIPTOR.
            //
            lpRpcSD->lpSecurityDescriptor =
                 ( PBYTE ) RtlAllocateHeap(
                                RtlProcessHeap( ), 0,
                                cbLen
                                );

            //
            // If the memory allocation failed, return.
            //
            if( lpRpcSD->lpSecurityDescriptor == NULL ) {
                return ERROR_OUTOFMEMORY;
            }

            lpRpcSD->cbInSecurityDescriptor = cbLen;
            fAllocated = TRUE;

        } else {

            //
            //  Make sure that the buffer provided is big enough
            //
            if ( lpRpcSD->cbInSecurityDescriptor < cbLen ) {
                return ERROR_OUTOFMEMORY;
            }
        }

        //
        //  Set the size of the transmittable buffer
        //
        lpRpcSD->cbOutSecurityDescriptor = cbLen;

        //
        // Convert the supplied SECURITY_DESCRIPTOR to self relative form.
        //

        lStatus = RtlNtStatusToDosError(
                        RtlMakeSelfRelativeSD(
                        lpSD,
                        lpRpcSD->lpSecurityDescriptor,
                        &lpRpcSD->cbInSecurityDescriptor)
                        );

        if ( ( lStatus != ERROR_SUCCESS ) && ( fAllocated ) ) {
            RtlFreeHeap ( RtlProcessHeap( ), 0, lpRpcSD->lpSecurityDescriptor ); 
        }

        return lStatus;
    } else {

        //
        // The supplied SECURITY_DESCRIPTOR is invalid.
        //

        return ERROR_INVALID_PARAMETER;
    }

} // MapSDToRpcSD

DWORD
ClRtlSetObjSecurityInfo(
    IN HANDLE           hObject,
    IN SE_OBJECT_TYPE   SeObjType,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryOneMask
    )
/*++

Routine Description:

    Sets the proper security on the cluster object(registry root/cluster files
    directory).

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD                       Status;
    PACL                        pAcl = NULL;
    DWORD                       cbDaclSize;
    PACCESS_ALLOWED_ACE         pAce;
    PSID                        pAdminSid = NULL;
    PSID                        pOwnerSid = NULL;
    PSID                        pEveryoneSid = NULL;
    PULONG                      pSubAuthority;
    SID_IDENTIFIER_AUTHORITY    SidIdentifierNtAuth = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaCreator = SECURITY_CREATOR_SID_AUTHORITY;
    DWORD AceIndex = 0;

    //
    // Create the local Administrators group SID.
    //
    pAdminSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 2 ));
    if (pAdminSid == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    if (!InitializeSid(pAdminSid, &SidIdentifierNtAuth, 2)) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Set the sub-authorities on the ACE for the local Administrators group.
    //
    pSubAuthority  = GetSidSubAuthority( pAdminSid, 0 );
    *pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    pSubAuthority  = GetSidSubAuthority( pAdminSid, 1 );
    *pSubAuthority = DOMAIN_ALIAS_RID_ADMINS;

    //
    // Create the owner's SID
    //
    pOwnerSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 1 ));
    if (pOwnerSid == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    if (!InitializeSid(pOwnerSid, &siaCreator, 1)) {
        Status = GetLastError();
        goto error_exit;
    }

    pSubAuthority = GetSidSubAuthority(pOwnerSid, 0);
    *pSubAuthority = SECURITY_CREATOR_OWNER_RID;

    //
    // Create the Everyone SID
    //
    pEveryoneSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 1 ));
    if (pEveryoneSid == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }
    if (!InitializeSid(pEveryoneSid, &siaWorld, 1)) {
        Status = GetLastError();
        goto error_exit;
    }

    pSubAuthority = GetSidSubAuthority(pEveryoneSid, 0);
    *pSubAuthority = SECURITY_WORLD_RID;

    //
    // now calculate the size of the buffer needed to hold the
    // ACL and its ACEs and initialize it.
    //
    cbDaclSize = sizeof(ACL) +
        3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(pAce->SidStart)) +
        GetLengthSid(pAdminSid) + GetLengthSid(pOwnerSid) + GetLengthSid(pEveryoneSid);

    pAcl = (PACL)LocalAlloc( LMEM_FIXED, cbDaclSize );
    if ( pAcl == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    if ( !InitializeAcl( pAcl,  cbDaclSize, ACL_REVISION )) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // add in the specified ACEs
    //
    if (dwAdminMask) {
        //
        // Add the ACE for the local Administrators group to the DACL
        //
        if ( !AddAccessAllowedAce( pAcl,
                                   ACL_REVISION,
                                   dwAdminMask,
                                   pAdminSid )) {
            Status = GetLastError();
            goto error_exit;
        }
        GetAce(pAcl, AceIndex, (PVOID *)&pAce);
        ++AceIndex;
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    if (dwOwnerMask) {
        //
        // Add the ACE for the Creator/Owner to the DACL
        //
        if ( !AddAccessAllowedAce( pAcl,
                                   ACL_REVISION,
                                   dwOwnerMask,
                                   pOwnerSid )) {
            Status = GetLastError();
            goto error_exit;
        }
        GetAce(pAcl, AceIndex, (PVOID *)&pAce);
        ++AceIndex;
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    if (dwEveryOneMask) {
        //
        // Add the ACE for Everyone to the DACL
        //
        if ( !AddAccessAllowedAce( pAcl,
                                   ACL_REVISION,
                                   dwEveryOneMask,
                                   pEveryoneSid )) {
            Status = GetLastError();
            goto error_exit;
        }
        GetAce(pAcl, AceIndex, (PVOID *)&pAce);
        ++AceIndex;
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

    //
    // Now that we have an ACL we can set the appropriate security.
    //
    Status = SetSecurityInfo(hObject,
                             SeObjType,
                             DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                             NULL,
                             NULL,
                             pAcl,
                             NULL);

error_exit:
    if (pAdminSid != NULL) {
        LocalFree(pAdminSid);
    }
    if (pOwnerSid != NULL) {
        LocalFree(pOwnerSid);
    }
    if (pEveryoneSid != NULL) {
        LocalFree(pEveryoneSid);
    }
    if (pAcl != NULL) {
        LocalFree(pAcl);
    }

    return(Status);

} // ClRtlSetObjSecurityInfo

DWORD
ClRtlFreeClusterServiceSecurityDescriptor( )
/*++

  Frees the security descriptor that is used to give the cluster
  service access to tokens.

--*/
{
    LocalFree( g_pClusterSecurityDescriptor );
    g_pClusterSecurityDescriptor = NULL;

    return ERROR_SUCCESS;
} // ClRtlFreeClusterServiceSecurityDescriptor

DWORD
ClRtlBuildClusterServiceSecurityDescriptor(
    PSECURITY_DESCRIPTOR * poutSD
    )
/*++

Routine Description:

    Builds a security descriptor that gives the cluster service
    access to tokens. It places this in a global that can be
    reused when other tokens are generated.

    This should be called when the process starts to initialize
    the global. It can pass in NULL if no reference is needed
    right away.

    NOTE: poutSD should NOT be freed by the caller.

Arguments:

Return Value:

--*/
{
    NTSTATUS                Status;
    HANDLE                  ProcessToken = NULL;
    ULONG                   AclLength;
    ULONG                   SDLength;
    PACL                    NewDacl = NULL;
    ULONG                   TokenUserSize;
    PTOKEN_USER             ProcessTokenUser = NULL;
    SECURITY_DESCRIPTOR     SecurityDescriptor;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GlobalLocalSystemSid = NULL;
    PSID GlobalAliasAdminsSid = NULL;

    // If we already have a SD, reuse it.
    if ( g_pClusterSecurityDescriptor != NULL ) {
        Status = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Build the two well known sids we need.
    //
    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &GlobalLocalSystemSid
                );
    if ( ! NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &GlobalAliasAdminsSid
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    //
    // Open the process token to find out the user sid
    //

    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY | WRITE_DAC,
                &ProcessToken
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    // find out the size
    Status = NtQueryInformationToken(
                ProcessToken,
                TokenUser,
                NULL,
                0,
                &TokenUserSize
                );
    CL_ASSERT( Status == STATUS_BUFFER_TOO_SMALL );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        goto Cleanup;
    }

    ProcessTokenUser = (PTOKEN_USER) LocalAlloc( 0, TokenUserSize );
    if ( ProcessTokenUser == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                ProcessToken,
                TokenUser,
                ProcessTokenUser,
                TokenUserSize,
                &TokenUserSize
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    AclLength = 3 * sizeof( ACCESS_ALLOWED_ACE ) - 3 * sizeof( ULONG ) +
                RtlLengthSid( ProcessTokenUser->User.Sid ) +
                RtlLengthSid( GlobalLocalSystemSid ) +
                RtlLengthSid( GlobalAliasAdminsSid ) +
                sizeof( ACL );

    NewDacl = (PACL) LocalAlloc(0, AclLength );

    if (NewDacl == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    CL_ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ProcessTokenUser->User.Sid
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 GlobalAliasAdminsSid
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 GlobalLocalSystemSid
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    CL_ASSERT( NT_SUCCESS( Status ));

    // Convert the newly created SD into a relative SD to make cleanup
    // easier.
    SDLength = sizeof( SECURITY_DESCRIPTOR_RELATIVE ) + AclLength;
    pNewSD = (PSECURITY_DESCRIPTOR) LocalAlloc( 0, SDLength );
    if ( pNewSD == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ( !MakeSelfRelativeSD( &SecurityDescriptor, pNewSD, &SDLength ) ) {
        Status = GetLastError( );
        if ( Status != STATUS_BUFFER_TOO_SMALL ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] MakeSelfRelativeSD failed 0x%1!.8x!\n", Status );
            goto Cleanup;
        }

        LocalFree( pNewSD );
        pNewSD = (PSECURITY_DESCRIPTOR) LocalAlloc( 0, SDLength );
        if ( pNewSD == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    if ( !MakeSelfRelativeSD( &SecurityDescriptor, pNewSD, &SDLength ) ) {
        Status = GetLastError( );
        goto Cleanup;
    }

    // give ownership to global
    g_pClusterSecurityDescriptor = pNewSD;
    pNewSD = NULL;

Cleanup:
    if (ProcessTokenUser != NULL) {
        LocalFree( ProcessTokenUser );
    }

    if (NewDacl != NULL) {
        LocalFree( NewDacl );
    }

    if (ProcessToken != NULL) {
        NtClose(ProcessToken);
    }

    // This should be NULL if successful.
    if ( pNewSD != NULL ) {
        LocalFree( pNewSD );
    }

    // If successful and the caller wanted to reference the SD, assign it now.
    if ( Status == ERROR_SUCCESS && poutSD != NULL ) {
        *poutSD = g_pClusterSecurityDescriptor;
    }

    if ( GlobalLocalSystemSid != NULL )
    {
        RtlFreeSid( GlobalLocalSystemSid );
    }

    if ( GlobalAliasAdminsSid != NULL )
    {
        RtlFreeSid( GlobalAliasAdminsSid );
    }

    if ( ! NT_SUCCESS( Status ) ) {
        ClRtlLogPrint(LOG_NOISE, "[ClRtl] ClRtlBuildClusterServiceSecurityDescriptor exit. Status = 0x%1!.8x!\n", Status );
    }

    return (DWORD) Status;      // hack it to a DWORD...

} // ClRtlBuildClusterServiceSecurityDescriptor


NTSTATUS
ClRtlImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN ACCESS_MASK AccessMask
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.

    AccessMask - Access control to the new token.

Return Value:

    STATUS_SUCCESS -  The thread is now impersonating the calling process.

    Other - Status values returned by:

            NtOpenProcessToken()
            NtDuplicateToken()
            NtSetInformationThread()

--*/

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Token1,
        Token2;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE
        Qos;

    PSECURITY_DESCRIPTOR
        pSecurityDescriptor = NULL;

    Status = ClRtlBuildClusterServiceSecurityDescriptor( &pSecurityDescriptor );
    if(NT_SUCCESS(Status))
    {
        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

        Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        Qos.ImpersonationLevel = ImpersonationLevel;
        Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        Qos.EffectiveOnly = FALSE;
        ObjectAttributes.SecurityQualityOfService = &Qos;
        ObjectAttributes.SecurityDescriptor = pSecurityDescriptor;

        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_DUPLICATE, &Token1 );

        if (NT_SUCCESS(Status)) {
            Status = NtDuplicateToken(
                         Token1,
                         AccessMask,
                         &ObjectAttributes,
                         FALSE,                 //EffectiveOnly
                         TokenImpersonation,
                         &Token2
                         );

            if (NT_SUCCESS(Status)) {
                Status = NtSetInformationThread(
                             NtCurrentThread(),
                             ThreadImpersonationToken,
                             &Token2,
                             sizeof(HANDLE)
                             );

                IgnoreStatus = NtClose( Token2 );
            }

            IgnoreStatus = NtClose( Token1 );
        }
    }

    return(Status);

} // ClRtlImpersonateSelf


DWORD
ClRtlEnableThreadPrivilege(
    IN  ULONG        Privilege,
    OUT BOOLEAN      *pWasEnabled
    )
/*++

Routine Description:

    Enables a privilege for the current thread.

Arguments:

    Privilege - The privilege to be enabled.

    pWasEnabled - Returns whether this privilege was originally
        enabled or disabled.  This should be passed into
        ClRtlRestoreThreadPrivilege() for restoring the privileges of
        the thread back.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{

    DWORD           Status;
    BOOL            bImpersonate = FALSE;

    //obtain a token that impersonates the security context
    //of the calling process
    Status = ClRtlImpersonateSelf( SecurityImpersonation, TOKEN_ALL_ACCESS );

    if ( !NT_SUCCESS( Status ) )
    {
        CL_LOGFAILURE(Status);
        goto FnExit;
    }

    bImpersonate = TRUE;
    //
    // Enable the required privilege
    //

    Status = RtlAdjustPrivilege(Privilege, TRUE, TRUE, pWasEnabled);

    if (!NT_SUCCESS(Status)) {
        CL_LOGFAILURE(Status);
        goto FnExit;

    }

FnExit:
    if (Status != ERROR_SUCCESS)
    {
        if (bImpersonate)
        {
            //if this failed and if we
            //
            // terminate impersonation
            //
            HANDLE  NullHandle;


            NullHandle = NULL;

            NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &NullHandle,
                sizeof( HANDLE ) );
        }
    }
    return(Status);
} // ClRtlEnableThreadPrivilege

DWORD
ClRtlRestoreThreadPrivilege(
    IN ULONG        Privilege,
    IN BOOLEAN      WasEnabled
    )
/*++

Routine Description:

    Restores the privilege for the current thread.

Arguments:

    Privilege - The privilege to be enabled.

    WasEnabled - TRUE to restore this privilege to enabled state.
        FALSE otherwise.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status = ERROR_SUCCESS;
    HANDLE  NullHandle;
    DWORD   ReturnStatus = ERROR_SUCCESS;
    //
    // If the privilege was originally disabled, disable it now.
    // Else we dont have to do anything.
    //

    if (!WasEnabled)
    {
        ReturnStatus = RtlAdjustPrivilege(Privilege,
                                      WasEnabled, TRUE, &WasEnabled);
        if (!NT_SUCCESS(ReturnStatus)) {
            CL_LOGFAILURE(ReturnStatus);
            //we still need to terminate the impersonation
        }
    }

    //
    // terminate impersonation
    //

    NullHandle = NULL;

    Status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    (PVOID) &NullHandle,
                    sizeof( HANDLE ) );

    if ( !NT_SUCCESS( Status ) )
    {

        CL_LOGFAILURE(Status);
        //Let the first error be reported
        if (ReturnStatus != ERROR_SUCCESS)
            ReturnStatus = Status;
        goto FnExit;

    }

FnExit:
    return (ReturnStatus);
} // ClRtlRestoreThreadPrivilege

PSECURITY_DESCRIPTOR
ClRtlCopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psd
    )

/*++

Routine Description:

    Copy an NT security descriptor. The security descriptor must
    be in self-relative (not absolute) form. Delete the result using LocalFree()

Arguments:

    psd - the SD to copy

Return Value:

    NULL if an error occured or an invalid SD
    Call GetLastError for more detailed information

--*/

{
    PSECURITY_DESCRIPTOR        pSelfSecDesc = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD                       dwLen = 0;
    DWORD                       cbSelfSecDesc = 0;
    DWORD                       dwRevision = 0;
    DWORD                       status = ERROR_SUCCESS;

    if (NULL == psd) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    //
    // following call was embedded in an ASSERT. Having this check all the
    // time is important since the rest of the ACL APIs depend on the
    // structure being correct.
    //
    if ( !IsValidSecurityDescriptor( psd )) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        return NULL;
    }

    if ( ! GetSecurityDescriptorControl( psd, &sdc, &dwRevision ) ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE, "[ClRtl] CopySecurityDescriptor: GetSecurityDescriptorControl() failed:%1!d1\n", GetLastError());
        SetLastError( status );
        return NULL;    // actually, should probably return an error
    }

    dwLen = GetSecurityDescriptorLength(psd);

    pSelfSecDesc = LocalAlloc( LMEM_ZEROINIT, dwLen );

    if (pSelfSecDesc == NULL) {
        ClRtlLogPrint(LOG_NOISE, "[ClRtl] CopySecurityDescriptor: LocalAlloc() SECURITY_DESCRIPTOR (2) failed\n");
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;    // actually, should probably return an error
    }

    cbSelfSecDesc = dwLen;

    if (!MakeSelfRelativeSD(psd, pSelfSecDesc, &cbSelfSecDesc)) {
        if ( ( sdc & SE_SELF_RELATIVE ) == 0 ) {
            ClRtlLogPrint(LOG_NOISE, "[ClRtl] CopySecurityDescriptor: MakeSelfRelativeSD failed, 0x%1!.8x!\n", GetLastError());
        } // if: only log this error if the old SD was not already self-relative

        // assume it failed because it was already self-relative
        CopyMemory(pSelfSecDesc, psd, dwLen);
    }

    ASSERT( IsValidSecurityDescriptor( pSelfSecDesc ));

    return pSelfSecDesc;

}  //*** ClRtlCopySecurityDescriptor()

static VOID
ClRtlGetSidTypeDesc(
    SID_NAME_USE    SidType,
    LPSTR           pszSidType,
    size_t          cchSidType
    )

/*++

Routine Description:

    Convert the SidType into a meaningful string.

Arguments:

    SidType - numerical value of SID type

    pszSidType - pointer to buffer to receive string desc.

    cchSidType - size, in chars, of pszSidType

Return Value:

        none

--*/

{
    PCHAR   pszSidDesc;

    if ((pszSidType != NULL) && (cchSidType > 0))
    {
        switch (SidType)
        {
            case SidTypeUser:
                pszSidDesc = "has a user SID for";
                break;

            case SidTypeGroup:
                pszSidDesc = "has a group SID for";
                break;

            case SidTypeDomain:
                pszSidDesc = "has a domain SID for";
                break;

            case SidTypeAlias:
                pszSidDesc = "has an alias SID for";
                break;

            case SidTypeWellKnownGroup:
                pszSidDesc = "has an SID for a well-known group for";
                break;

            case SidTypeDeletedAccount:
                pszSidDesc = "has an SID for a deleted account for";
                break;

            case SidTypeInvalid:
                pszSidDesc = "has an invalid SID for";
                break;

            case SidTypeUnknown:
            default:
                pszSidDesc = "has an unknown SID type:";
                break;

        } // switch: SidType

        pszSidType [ cchSidType - 1 ] = 0;
        strncpy(pszSidType, pszSidDesc, cchSidType - 1);

    } // if: buffer not null and has space allocated

}  //*** ClRtlGetSidTypeDesc()

static VOID
ClRtlExamineSid(
    PSID        pSid,
    LPSTR       lpszOldIndent
    )

/*++

Routine Description:

    Dump the SID.

Arguments:

    pSid -
    lpzOldIndent -

Return Value:

        none

--*/

{
    CHAR            szUserName [128];
    CHAR            szDomainName [ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD           cbUser  = sizeof(szUserName);
    DWORD           cbDomain = sizeof(szDomainName);
    SID_NAME_USE    SidType;

    if ( LookupAccountSidA( NULL, pSid, szUserName, &cbUser, szDomainName, &cbDomain, &SidType ) )
    {
        char    szSidType [128];

        ClRtlGetSidTypeDesc( SidType, szSidType, sizeof( szSidType ) );
        ClRtlLogPrint( LOG_NOISE, "%1!hs!%2!hs! %3!hs!\\%4!hs!\n", lpszOldIndent, szSidType, szDomainName, szUserName ) ;
    }

}  // *** ClRtlExamineSid()

VOID
ClRtlExamineMask(
    ACCESS_MASK amMask,
    LPSTR       lpszOldIndent
    )

/*++

Routine Description:

    Dump the AccessMask context.

Arguments:

    amMask -
    lpzOldIndent -

Return Value:

        none

--*/

{
    #define STANDARD_RIGHTS_ALL_THE_BITS 0x00FF0000L
    #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

    CHAR  szIndent[100];
    CHAR  ucIndentBitsBuf[100];
    DWORD dwGenericBits;
    DWORD dwStandardBits;
    DWORD dwSpecificBits;
    DWORD dwAccessSystemSecurityBit;
    DWORD dwExtraBits;

    szIndent[ sizeof( szIndent ) - 1 ] = 0;
    _snprintf( szIndent, sizeof( szIndent ) - 1, "%s    ",  lpszOldIndent );

    ucIndentBitsBuf[ sizeof( ucIndentBitsBuf ) - 1 ] = 0;
    _snprintf( ucIndentBitsBuf, sizeof( ucIndentBitsBuf ) - 1,
               "%s                           ",
               szIndent);

    dwStandardBits            = (amMask & STANDARD_RIGHTS_ALL_THE_BITS);
    dwSpecificBits            = (amMask & SPECIFIC_RIGHTS_ALL         );
    dwAccessSystemSecurityBit = (amMask & ACCESS_SYSTEM_SECURITY      );
    dwGenericBits             = (amMask & GENERIC_RIGHTS_ALL_THE_BITS );

    // **************************************************************************
    // *
    // * Print then decode the standard rights bits
    // *
    // **************************************************************************

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Standard Rights        == 0x%2!.8x!\n", szIndent, dwStandardBits);

    if (dwStandardBits) {

        if ((dwStandardBits & DELETE) == DELETE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! DELETE\n", ucIndentBitsBuf, DELETE);
        }

        if ((dwStandardBits & READ_CONTROL) == READ_CONTROL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! READ_CONTROL\n", ucIndentBitsBuf, READ_CONTROL);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_READ) == STANDARD_RIGHTS_READ) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_READ\n", ucIndentBitsBuf, STANDARD_RIGHTS_READ);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_WRITE) == STANDARD_RIGHTS_WRITE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_WRITE\n", ucIndentBitsBuf, STANDARD_RIGHTS_WRITE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_EXECUTE) == STANDARD_RIGHTS_EXECUTE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_EXECUTE\n", ucIndentBitsBuf, STANDARD_RIGHTS_EXECUTE);
        }

        if ((dwStandardBits & WRITE_DAC) == WRITE_DAC) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! WRITE_DAC\n", ucIndentBitsBuf, WRITE_DAC);
        }

        if ((dwStandardBits & WRITE_OWNER) == WRITE_OWNER) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! WRITE_OWNER\n", ucIndentBitsBuf, WRITE_OWNER);
        }

        if ((dwStandardBits & SYNCHRONIZE) == SYNCHRONIZE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! SYNCHRONIZE\n", ucIndentBitsBuf, SYNCHRONIZE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_REQUIRED) == STANDARD_RIGHTS_REQUIRED) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_REQUIRED\n", ucIndentBitsBuf, STANDARD_RIGHTS_REQUIRED);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_ALL) == STANDARD_RIGHTS_ALL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! STANDARD_RIGHTS_ALL\n", ucIndentBitsBuf, STANDARD_RIGHTS_ALL);
        }

        dwExtraBits = dwStandardBits & (~(DELETE
                                          | READ_CONTROL
                                          | STANDARD_RIGHTS_READ
                                          | STANDARD_RIGHTS_WRITE
                                          | STANDARD_RIGHTS_EXECUTE
                                          | WRITE_DAC
                                          | WRITE_OWNER
                                          | SYNCHRONIZE
                                          | STANDARD_RIGHTS_REQUIRED
                                          | STANDARD_RIGHTS_ALL));
        if (dwExtraBits) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs! Extra standard bits    == 0x%2!.8x! <-This is a problem, should be all 0s\n", szIndent, dwExtraBits);
        }
    }

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Specific Rights        == 0x%2!.8x!\n", szIndent, dwSpecificBits);

    // **************************************************************************
    // *
    // * Print then decode the ACCESS_SYSTEM_SECURITY bit
    // *
    // *************************************************************************

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Access System Security == 0x%2!.8x!\n", szIndent, dwAccessSystemSecurityBit);

    // **************************************************************************
    // *
    // * Print then decode the generic rights bits, which will rarely be on
    // *
    // * Generic bits are nearly always mapped by Windows NT before it tries to do
    // *   anything with them.  You can ignore the fact that generic bits are
    // *   special in any way, although it helps to keep track of what the mappings
    // *   are so that you don't have any surprises
    // *
    // * The only time the generic bits are not mapped immediately is if they are
    // *   placed in an inheritable ACE in an ACL, or in an ACL that will be
    // *   assigned by default (such as the default DACL in an access token).  In
    // *   that case they're mapped when the child object is created (or when the
    // *   default DACL is used at object creation time)
    // *
    // **************************************************************************

    ClRtlLogPrint(LOG_NOISE, "%1!hs! Generic Rights         == 0x%2!.8x!\n", szIndent, dwGenericBits);

    if (dwGenericBits) {

        if ((dwGenericBits & GENERIC_READ) == GENERIC_READ) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_READ\n", ucIndentBitsBuf, GENERIC_READ);
        }

        if ((dwGenericBits & GENERIC_WRITE) == GENERIC_WRITE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_WRITE\n", ucIndentBitsBuf, GENERIC_WRITE);
        }

        if ((dwGenericBits & GENERIC_EXECUTE) == GENERIC_EXECUTE) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_EXECUTE\n", ucIndentBitsBuf, GENERIC_EXECUTE);
        }

        if ((dwGenericBits & GENERIC_ALL) == GENERIC_ALL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!0x%2!.8x! GENERIC_ALL\n", ucIndentBitsBuf, GENERIC_ALL);
        }

        dwExtraBits = dwGenericBits & (~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL));
        if (dwExtraBits) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs! Extra generic bits     == 0x%2!.8x! <-This is a problem, should be all 0s\n", szIndent, dwExtraBits);
        }
    }

}  // *** ClRtlExamineMask()

static BOOL
ClRtlExamineACL(
    PACL    paclACL,
    LPSTR   lpszOldIndent
    )

/*++

Routine Description:

    Dump the Access Control List contents.

Arguments:

    paclACL - pointer to ACL

    lpzOldIndent - pointer to indent string.

Return Value:

    TRUE - ?

--*/

{
    CHAR                       szIndent[ 64 ];
    PCHAR                      pIndentBuffer;
    CHAR                       spacesToIndent[] = "    ";
    DWORD                      indentChars;

    ACL_SIZE_INFORMATION       asiAclSize;
    ACL_REVISION_INFORMATION   ariAclRevision;
    DWORD                      dwBufLength;
    DWORD                      dwAcl_i;
    ACCESS_ALLOWED_ACE *       paaAllowedAce;
    BOOL                       returnValue = TRUE;

    //
    // get length of current indent, add our indent, and either use the
    // builtin buffer or allocate one that is large enough. If we fail to
    // allocate, set it to the passed in indent buffer.
    //
    indentChars = strlen( lpszOldIndent ) + RTL_NUMBER_OF( spacesToIndent );
    if ( indentChars > sizeof( szIndent )) {
        pIndentBuffer = LocalAlloc( LMEM_FIXED, indentChars );
        if ( pIndentBuffer == NULL ) {
            pIndentBuffer = lpszOldIndent;
        }
    } else {
        pIndentBuffer = szIndent;
        indentChars = sizeof( szIndent );
    }

    if ( pIndentBuffer != lpszOldIndent ) {
        strncpy( pIndentBuffer, lpszOldIndent, indentChars - RTL_NUMBER_OF( spacesToIndent ));
        pIndentBuffer[ indentChars - RTL_NUMBER_OF( spacesToIndent ) ] = 0;
        strcat( pIndentBuffer, spacesToIndent );
    }

    if (!IsValidAcl(paclACL)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - IsValidAcl() failed.\n", pIndentBuffer);
        returnValue = FALSE;
        goto Cleanup;
    }

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(paclACL, &asiAclSize, dwBufLength, AclSizeInformation)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - GetAclInformation failed.\n", pIndentBuffer);
        returnValue = FALSE;
        goto Cleanup;
    }

    dwBufLength = sizeof(ariAclRevision);

    if (!GetAclInformation(paclACL, (LPVOID) &ariAclRevision, dwBufLength, AclRevisionInformation)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - GetAclInformation failed\n", pIndentBuffer);
        returnValue = FALSE;
        goto Cleanup;
    }

    ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL has %2!d! ACE(s), %3!d! bytes used, %4!d! bytes free\n",
                pIndentBuffer,
                asiAclSize.AceCount,
                asiAclSize.AclBytesInUse,
                asiAclSize.AclBytesFree);

    switch (ariAclRevision.AclRevision) {
        case ACL_REVISION1:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL revision is %2!d! == ACL_REVISION1\n", pIndentBuffer, ariAclRevision.AclRevision);
            break;
        case ACL_REVISION2:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL revision is %2!d! == ACL_REVISION2\n", pIndentBuffer, ariAclRevision.AclRevision);
            break;
        default:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACL revision is %2!d! == ACL Revision is an IMPOSSIBLE ACL revision!!! Perhaps a new revision was added...\n",
                        pIndentBuffer,
                        ariAclRevision.AclRevision);
            returnValue = FALSE;
            break;
    }

    if ( returnValue == FALSE ) {
        goto Cleanup;
    }

    for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount;  dwAcl_i++) {

        if (!GetAce(paclACL, dwAcl_i, (LPVOID *) &paaAllowedAce)) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineACL() - GetAce failed.\n", pIndentBuffer);
            returnValue = FALSE;
            goto Cleanup;
        }

        ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! size %3!d!\n", pIndentBuffer, dwAcl_i, paaAllowedAce->Header.AceSize);

        {
            char    szBuf [512];

            szBuf[ RTL_NUMBER_OF( szBuf ) - 1 ] = 0;
            _snprintf(szBuf, RTL_NUMBER_OF( szBuf ) - 1, "%sACE %d ", pIndentBuffer, dwAcl_i);
            ClRtlExamineSid(&(paaAllowedAce->SidStart), szBuf );
        }

        {
            DWORD dwAceFlags = paaAllowedAce->Header.AceFlags;

            ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! flags 0x%3!.2x!\n", pIndentBuffer, dwAcl_i, dwAceFlags);

            if (dwAceFlags) {

                DWORD   dwExtraBits;

#define ACE_INDENT "            "

                if ((dwAceFlags & OBJECT_INHERIT_ACE) == OBJECT_INHERIT_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x01 OBJECT_INHERIT_ACE\n", pIndentBuffer);
                }

                if ((dwAceFlags & CONTAINER_INHERIT_ACE) == CONTAINER_INHERIT_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x02 CONTAINER_INHERIT_ACE\n", pIndentBuffer);
                }

                if ((dwAceFlags & NO_PROPAGATE_INHERIT_ACE) == NO_PROPAGATE_INHERIT_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x04 NO_PROPAGATE_INHERIT_ACE\n", pIndentBuffer);
                }

                if ((dwAceFlags & INHERIT_ONLY_ACE) == INHERIT_ONLY_ACE) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x08 INHERIT_ONLY_ACE\n", pIndentBuffer);
                }

                if ((dwAceFlags & VALID_INHERIT_FLAGS) == VALID_INHERIT_FLAGS) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x0F VALID_INHERIT_FLAGS\n", pIndentBuffer);
                }

                if ((dwAceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) == SUCCESSFUL_ACCESS_ACE_FLAG) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x40 SUCCESSFUL_ACCESS_ACE_FLAG\n", pIndentBuffer);
                }

                if ((dwAceFlags & FAILED_ACCESS_ACE_FLAG) == FAILED_ACCESS_ACE_FLAG) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT "0x80 FAILED_ACCESS_ACE_FLAG\n", pIndentBuffer);
                }

                dwExtraBits = dwAceFlags & (~(OBJECT_INHERIT_ACE
                                              | CONTAINER_INHERIT_ACE
                                              | NO_PROPAGATE_INHERIT_ACE
                                              | INHERIT_ONLY_ACE
                                              | VALID_INHERIT_FLAGS
                                              | SUCCESSFUL_ACCESS_ACE_FLAG
                                              | FAILED_ACCESS_ACE_FLAG));
                if (dwExtraBits) {
                    ClRtlLogPrint(LOG_NOISE, "%1!hs!" ACE_INDENT " Extra AceFlag bits     == 0x%2!.8x! <-This is a problem, should be all 0s\n",
                                pIndentBuffer,
                                dwExtraBits);
                }
            }
        }

        switch (paaAllowedAce->Header.AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is an ACCESS_ALLOWED_ACE_TYPE\n", pIndentBuffer, dwAcl_i);
                break;
            case ACCESS_DENIED_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is an ACCESS_DENIED_ACE_TYPE\n", pIndentBuffer, dwAcl_i);
                break;
            case SYSTEM_AUDIT_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is a  SYSTEM_AUDIT_ACE_TYPE\n", pIndentBuffer, dwAcl_i);
                break;
            case SYSTEM_ALARM_ACE_TYPE:
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is a  SYSTEM_ALARM_ACE_TYPE\n", pIndentBuffer, dwAcl_i);
                break;
            default :
                ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! is an IMPOSSIBLE ACE_TYPE!!! Run debugger, examine value!\n", pIndentBuffer, dwAcl_i);
                returnValue = FALSE;
        }

        ClRtlLogPrint(LOG_NOISE, "%1!hs!ACE %2!d! mask                  == 0x%3!.8x!\n", pIndentBuffer, dwAcl_i, paaAllowedAce->Mask);

        ClRtlExamineMask(paaAllowedAce->Mask, pIndentBuffer);
    }

Cleanup:
    if ( pIndentBuffer != lpszOldIndent && pIndentBuffer != szIndent ) {
        LocalFree( pIndentBuffer );
    }

    return returnValue;

}  // *** ClRtlExamineACL()

BOOL
ClRtlExamineSD(
    PSECURITY_DESCRIPTOR    psdSD,
    LPSTR                   pszPrefix
    )

/*++

Routine Description:

    Dump the Security descriptor context.

Arguments:

    psdSD - the SD to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    PACL                        paclDACL;
    PACL                        paclSACL;
    BOOL                        bHasDACL        = FALSE;
    BOOL                        bHasSACL        = FALSE;
    BOOL                        bDaclDefaulted  = FALSE;
    BOOL                        bSaclDefaulted  = FALSE;
    BOOL                        bOwnerDefaulted = FALSE;
    BOOL                        bGroupDefaulted = FALSE;
    PSID                        psidOwner;
    PSID                        psidGroup;
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD                       dwSDRevision;
    DWORD                       dwSDLength;
    char                        szIndent [34];

    //
    // copy and possibly truncate the prefix. Leave space for the tacked on
    // space and trailing NULL
    //
    strncpy(szIndent, pszPrefix, sizeof(szIndent) - 2);
    szIndent[ sizeof( szIndent ) - 2 ] = 0;
    strcat(szIndent, " ");

    if (!IsValidSecurityDescriptor(psdSD)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - IsValidSecurityDescriptor failed.\n", szIndent);
        return FALSE;
    }

    dwSDLength = GetSecurityDescriptorLength(psdSD);

    if (!GetSecurityDescriptorDacl(psdSD, (LPBOOL) &bHasDACL, (PACL *) &paclDACL, (LPBOOL) &bDaclDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorDacl failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorSacl(psdSD, (LPBOOL) &bHasSACL, (PACL *) &paclSACL, (LPBOOL) &bSaclDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorSacl failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorOwner(psdSD, (PSID *)&psidOwner, (LPBOOL)&bOwnerDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorOwner failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorGroup(psdSD, (PSID *) &psidGroup, (LPBOOL) &bGroupDefaulted)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorGroup failed.\n", szIndent);
        return FALSE;
    }

    if (!GetSecurityDescriptorControl(
                                psdSD,
                                (PSECURITY_DESCRIPTOR_CONTROL) &sdcSDControl,
                                (LPDWORD) &dwSDRevision)) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - GetSecurityDescriptorControl failed.\n", szIndent);
        return FALSE;
    }

    switch (dwSDRevision) {
        case SECURITY_DESCRIPTOR_REVISION1:
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD is valid.  SD is %2!d! bytes long.  SD revision is %3!d! == SECURITY_DESCRIPTOR_REVISION1\n", szIndent, dwSDLength, dwSDRevision);
            break;
        default :
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD is valid.  SD is %2!d! bytes long.  SD revision is %3!d! == ! SD Revision is an IMPOSSIBLE SD revision!!! Perhaps a new revision was added...\n",
                        szIndent,
                        dwSDLength,
                        dwSDRevision);
            return FALSE;
    }

    if (SE_SELF_RELATIVE & sdcSDControl) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD is in self-relative format (all SDs returned by the system are)\n", szIndent);
    }

    if (NULL == psidOwner) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner is NULL, so SE_OWNER_DEFAULTED is ignored\n", szIndent);
    }
    else {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner is Not NULL\n", szIndent);
        if (bOwnerDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner-Defaulted flag is TRUE\n", szIndent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Owner-Defaulted flag is FALSE\n", szIndent);
        }
    }

    // **************************************************************************
    // *
    // * The other use for psidGroup is for Macintosh client support
    // *
    // **************************************************************************

    if (NULL == psidGroup) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Group is NULL, so SE_GROUP_DEFAULTED is ignored. SD's Group being NULL is typical, GROUP in SD(s) is mainly for POSIX compliance\n", szIndent);
    }
    else {
        if (bGroupDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Group-Defaulted flag is TRUE\n", szIndent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's Group-Defaulted flag is FALSE\n", szIndent);
        }
    }

    if (SE_DACL_PRESENT & sdcSDControl) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL is Present\n", szIndent);
        if (bDaclDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL-Defaulted flag is TRUE\n", szIndent);
        } else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL-Defaulted flag is FALSE\n", szIndent);
        }

        if (NULL == paclDACL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD has a NULL DACL explicitly specified (allows all access to Everyone). This does not apply to this SD, but for comparison, a non-NULL DACL pointer to a 0-length ACL allows  no access to anyone\n", szIndent);
        }
        else if(!ClRtlExamineACL(paclDACL, szIndent))  {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - ClRtlExamineACL failed.\n", szIndent);
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's DACL is Not Present, so SE_DACL_DEFAULTED is ignored. SD has no DACL at all (allows all access to Everyone)\n", szIndent);
    }

    if (SE_SACL_PRESENT & sdcSDControl) {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL is Present\n", szIndent);
        if (bSaclDefaulted) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL-Defaulted flag is TRUE\n", szIndent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL-Defaulted flag is FALSE\n", szIndent);
        }

        if (NULL == paclSACL) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!SD has a NULL SACL explicitly specified\n", szIndent);
        }
        else if (!ClRtlExamineACL(paclSACL, szIndent)) {
            ClRtlLogPrint(LOG_NOISE, "%1!hs!ClRtlExamineSD() - ClRtlExamineACL failed.\n", szIndent);
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, "%1!hs!SD's SACL is Not Present, so SE_SACL_DEFAULTED is ignored. SD has no SACL at all (or we did not request to see it)\n", szIndent);
    }

    return TRUE;

}  // *** ClRtlExamineSD()

DWORD
ClRtlBuildDefaultClusterSD(
    IN PSID                 pOwnerSid,
    PSECURITY_DESCRIPTOR *  SD,
    ULONG *                 SizeSD
    )
/*++

Routine Description:

    Builds the default security descriptor to control access to
    the cluster API

    Modified permissions in ACEs in order to augment cluster security
    administration.

Arguments:

    pOwnerSid - Supplies the SID that the cluster account runs in

    SD - Returns a pointer to the created security descriptor. This
        should be freed by the caller.

    SizeSD - Returns the size in bytes of the security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD                       Status;
    HANDLE                      Token;
    PACL                        pAcl = NULL;
    DWORD                       cbDaclSize;
    PSECURITY_DESCRIPTOR        psd;
    PSECURITY_DESCRIPTOR        NewSD;
    BYTE                        SDBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PACCESS_ALLOWED_ACE         pAce;
    PSID                        pAdminSid = NULL;
    PSID                        pSystemSid = NULL;
    PSID                        pNetServiceSid = NULL;
    PULONG                      pSubAuthority;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    ULONG                       NewSDLen;

    psd = (PSECURITY_DESCRIPTOR) SDBuffer;

    //
    // allocate and init the Administrators group sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pAdminSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // allocate and init the SYSTEM sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSystemSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( pOwnerSid == NULL ) {
        pOwnerSid = pAdminSid;
    }

    //
    // allocate and init the Network Service sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_NETWORK_SERVICE_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pNetServiceSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Set up the DACL that will allow admins all access.
    // It should be large enough to hold 3 ACEs and their SIDs
    //
    cbDaclSize = sizeof( ACL ) +
        3 * ( sizeof( ACCESS_ALLOWED_ACE ) - sizeof( pAce->SidStart )) +
        GetLengthSid( pAdminSid ) +
        GetLengthSid( pSystemSid ) +
        GetLengthSid( pNetServiceSid );

    pAcl = (PACL) LocalAlloc( LPTR, cbDaclSize );
    if ( pAcl == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );
    InitializeAcl( pAcl,  cbDaclSize, ACL_REVISION );

    //
    // Add the ACE for the local Administrators group to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_ALL_ACCESS, // What the admin can do
                               pAdminSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Add the ACE for the SYSTEM account to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_ALL_ACCESS, // What local system can do
                               pSystemSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Add the ACE for the Network Service account to the DACL
    //
    if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_ALL_ACCESS, // What net services can do
                               pNetServiceSid ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !GetAce( pAcl, 0, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !GetAce( pAcl, 1, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !GetAce( pAcl, 2, (PVOID *) &pAce ) ) {

        Status = GetLastError();
        goto error_exit;
    }

    pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

    if ( !SetSecurityDescriptorDacl( psd, TRUE, pAcl, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorOwner( psd, pOwnerSid, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorGroup( psd, pOwnerSid, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    if ( !SetSecurityDescriptorSacl( psd, TRUE, NULL, FALSE ) ) {
        Status = GetLastError();
        goto error_exit;
    }

    NewSDLen = 0 ;

    if ( !MakeSelfRelativeSD( psd, NULL, &NewSDLen ) ) {
        Status = GetLastError();
        if ( Status != ERROR_INSUFFICIENT_BUFFER ) {    // Duh, we're trying to find out how big the buffer should be?
            goto error_exit;
        }
    }

    NewSD = LocalAlloc( LPTR, NewSDLen );
    if ( NewSD ) {
        if ( !MakeSelfRelativeSD( psd, NewSD, &NewSDLen ) ) {
            Status = GetLastError();
            LocalFree( NewSD );
            goto error_exit;
        }

        Status = ERROR_SUCCESS;
        *SD = NewSD;
        *SizeSD = NewSDLen;
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

error_exit:
    if ( pAdminSid != NULL ) {
        FreeSid( pAdminSid );
    }

    if ( pSystemSid != NULL ) {
        FreeSid( pSystemSid );
    }

    if ( pNetServiceSid != NULL ) {
        FreeSid( pNetServiceSid );
    }

    if ( pAcl != NULL ) {
        LocalFree( pAcl );
    }

    return( Status );

}  // *** ClRtlBuildDefaultClusterSD()


static BOOL
ClRtlGetTokenInformation(
    HANDLE                  hClientToken,
    TOKEN_INFORMATION_CLASS ticRequest,
    PBYTE *                 ppb,
    LPSTR                   pszPrefix
    )

/*++

Routine Description:

    Get the requested information from the passed in client token.

Arguments:

    hClientToken - the client token to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    PBYTE   _pb = NULL;
    DWORD   _cb = 64;
    DWORD   _cbNeeded = 0;
    DWORD   _sc = NO_ERROR;

    //
    // Get the user information from the client token.
    //
    do {
        _pb = LocalAlloc( LMEM_ZEROINIT, _cb );
        if ( _pb == NULL ) {
            _sc = GetLastError();
            ClRtlLogPrint( LOG_NOISE,  "%1!hs!ClRtlGetTokenInformation() - LocalAlloc() failed:%2!d!\n", pszPrefix, _sc ) ;
            return FALSE;
        } // if: LocalAlloc failed

        if ( ! GetTokenInformation( hClientToken, ticRequest, _pb, _cb, &_cbNeeded ) ) {
            _sc = GetLastError();
            LocalFree( _pb );
            _pb = NULL;
            if ( _sc == ERROR_INSUFFICIENT_BUFFER ) {
                _cb = _cbNeeded;
                continue;
            } // if: buffer size is too small
            else {
                ClRtlLogPrint( LOG_NOISE,  "%1!hs!ClRtlGetTokenInformation() - GetTokenInformation() failed:%2!d!\n", pszPrefix, _sc ) ;
                return FALSE;
            } // else: fatal error
        } // if: GetTokenInformation failed

        break;  // everything is ok and we can exit the loop normally

    } while( TRUE );

    *ppb = _pb;

    return TRUE;

}  // *** ClRtlGetTokenInformation()

BOOL
ClRtlExamineClientToken(
    HANDLE  hClientToken,
    LPSTR   pszPrefix
    )

/*++

Routine Description:

    Dump the client token.

Arguments:

    hClientToken - the client token to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    char    _szIndent [33];
    char    _szBuf [128];
    PBYTE   _pb = NULL;

    //
    // allow space for the blank and trailing null
    //
    _szIndent[ RTL_NUMBER_OF( _szIndent ) - 2 ] = 0;
    strncpy( _szIndent, pszPrefix, RTL_NUMBER_OF( _szIndent ) - 2 );
    strcat( _szIndent, " " );

    //
    // Get the user information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenUser, &_pb, _szIndent ) ) {
        PTOKEN_USER _ptu = NULL;

        wsprintfA( _szBuf, "%sClientToken ", _szIndent );

        _ptu = (PTOKEN_USER) _pb;
        ClRtlExamineSid( _ptu->User.Sid, _szBuf );

        LocalFree( _pb );
        _pb = NULL;
    }

    //
    // Get the user's group information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenGroups, &_pb, _szIndent ) ) {
        PTOKEN_GROUPS   _ptg = NULL;
        DWORD           _nIndex = 0;

        wsprintfA( _szBuf, "%s   ClientToken ", _szIndent );

        _ptg = (PTOKEN_GROUPS) _pb;

        for ( _nIndex = 0; _nIndex < _ptg->GroupCount; _nIndex++ )
        {
            ClRtlExamineSid( _ptg->Groups[ _nIndex ].Sid, _szBuf );
        }

        LocalFree( _pb );
        _pb = NULL;
    }

    //
    // Get the token type information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenType, &_pb, _szIndent ) ) {
        PTOKEN_TYPE _ptt = NULL;

        wsprintfA( _szBuf, "%s   ClientToken type is", _szIndent );

        _ptt = (PTOKEN_TYPE) _pb;

        if ( *_ptt == TokenPrimary ) {
            ClRtlLogPrint( LOG_NOISE,  "%1!hs! primary.\n", _szBuf ) ;
        }

        if ( *_ptt == TokenImpersonation ) {
            ClRtlLogPrint( LOG_NOISE,  "%1!hs! impersonation.\n", _szBuf ) ;
        }

        LocalFree( _pb );
        _pb = NULL;
    }

    //
    // Get the token impersonation level information from the client token.
    //
    if ( ClRtlGetTokenInformation( hClientToken, TokenImpersonationLevel, &_pb, _szIndent ) ) {
        PSECURITY_IMPERSONATION_LEVEL _psil = NULL;

        wsprintfA( _szBuf, "%s   ClientToken security impersonation level is", _szIndent );

        _psil = (PSECURITY_IMPERSONATION_LEVEL) _pb;

        switch ( *_psil )
        {
            case SecurityAnonymous :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Anonymous.\n", _szBuf ) ;
                break;

            case SecurityIdentification :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Identification.\n", _szBuf ) ;
                break;

            case SecurityImpersonation :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Impersonation.\n", _szBuf ) ;
                break;

            case SecurityDelegation :
                ClRtlLogPrint( LOG_NOISE,  "%1!hs! Delegation.\n", _szBuf ) ;
                break;
        }

        LocalFree( _pb );
        _pb = NULL;
    }

    return TRUE;

}  // *** ClRtlExamineClientToken()

DWORD
ClRtlIsCallerAccountLocalSystemAccount(
    OUT PBOOL pbIsLocalSystemAccount
    )
/*++

Routine Description:

    This function checks whether the caller's account is the local system
    account.

Arguments:

    pbIsLocalSystemAccount - The caller's account is local system account or not.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code on failure.

Remarks:

    Must be called by an impersonating thread.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY
            siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID    psidLocalSystem = NULL;

    *pbIsLocalSystemAccount = FALSE;

    if ( !AllocateAndInitializeSid(
                    &siaNtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &psidLocalSystem ) )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    if ( !CheckTokenMembership(
                NULL,
                psidLocalSystem,
                pbIsLocalSystemAccount ) )
    {
        dwStatus = GetLastError();
    }

FnExit:
    if( psidLocalSystem != NULL )
    {
        FreeSid( psidLocalSystem );
    }

    return( dwStatus );

} // ClRtlIsCallerAccountLocalSystemAccount


PTOKEN_USER
ClRtlGetSidOfCallingThread(
    VOID
    )

/*++

Routine Description:

    Get the SID associated with the calling thread (or process if the thread
    has no token)

Arguments:

    none

Return Value:

    pointer to TOKEN_USER data; null if error with last error set on thread

--*/

{
    HANDLE      currentToken;
    PTOKEN_USER tokenUserData;
    DWORD       sizeRequired;
    BOOL        success;

    // check if there is a thread token
    if (!OpenThreadToken(GetCurrentThread(),
                         MAXIMUM_ALLOWED,
                         TRUE,
                         &currentToken))
    {
        // get the process token
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &currentToken )) {
            return NULL;
        }
    }

    //
    // get the size needed
    //
    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  NULL,
                                  0,
                                  &sizeRequired);

    tokenUserData = LocalAlloc( LMEM_FIXED, sizeRequired );
    if ( tokenUserData == NULL ) {
        CloseHandle( currentToken );
        return NULL;
    }

    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  tokenUserData,
                                  sizeRequired,
                                  &sizeRequired);

    CloseHandle( currentToken );

    if ( !success ) {
        LocalFree( tokenUserData );
        return NULL;
    }

    return tokenUserData;
} // ClRtlGetSidOfCallingThread

#if 0
//
// not needed but no point in throwing it away just yet
//
DWORD
ClRtlConvertDomainAccountToSid(
    IN LPWSTR   AccountInfo,
    OUT PSID *  AccountSid
    )

/*++

Routine Description:

    For the given credentials, look up the account SID for the specified
    domain.

Arguments:

    AccountInfo - pointer to string of the form 'domain\user'

    AccountSid - address of pointer that receives the SID for this user

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSidSize = 128;
    DWORD dwDomainNameSize = DNS_MAX_NAME_BUFFER_LENGTH;
    LPWSTR pwszDomainName;
    SID_NAME_USE SidType;
    PSID accountSid;

    do {
        //
        // Attempt to allocate a buffer for the SID.
        //
        accountSid = LocalAlloc( LMEM_FIXED, dwSidSize );
        pwszDomainName = (LPWSTR) LocalAlloc( LMEM_FIXED, dwDomainNameSize * sizeof(WCHAR) );

        // Was space allocated for the SID and domain name successfully?

        if ( accountSid == NULL || pwszDomainName == NULL ) {
            if ( accountSid != NULL ) {
                LocalFree( accountSid );
            }

            if ( pwszDomainName != NULL ) {
                LocalFree( pwszDomainName );
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Attempt to Retrieve the SID and domain name. If LookupAccountName fails
        // because of insufficient buffer size(s) dwSidSize and dwDomainNameSize
        // will be set correctly for the next attempt.
        //
        if ( !LookupAccountName( NULL,
                                 AccountInfo,
                                 accountSid,
                                 &dwSidSize,
                                 pwszDomainName,
                                 &dwDomainNameSize,
                                 &SidType ))
        {
            // free the Sid buffer and find out why we failed
            LocalFree( accountSid );

            dwStatus = GetLastError();
        }

        // domain name isn't needed at any time
        LocalFree( pwszDomainName );
        pwszDomainName = NULL;

    } while ( dwStatus == ERROR_INSUFFICIENT_BUFFER );

    if ( dwStatus == ERROR_SUCCESS ) {
        *AccountSid = accountSid;
    }

    return dwStatus;
} // ClRtlConvertDomainAccountToSid
#endif

DWORD
AddAceToAcl(
    IN  PACL        pOldAcl,
    IN  PSID        pClientSid,
    IN  ACCESS_MASK AccessMask,
    OUT PACL *      ppNewAcl
    )
/*++

Routine Description:

    This routine creates a new ACL by copying the ACEs from the old ACL and
    creating a new ACE with pClientSid and AccessMask. Stolen from
    \nt\ds\ds\src\ntdsa\dra\remove.c

Arguments:

    pOldAcl - pointer to old ACL with its ACEs

    pClientSid - SID to add

    AccessMask - access mask associated with SID

    pNewAcl - brand spanking new ACL with ACE for the SID and access mask

Return Values:

    ERROR_SUCCESS if the ace was put in the sd

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL  fStatus;

    ACL_SIZE_INFORMATION     AclSizeInfo;
    ACL_REVISION_INFORMATION AclRevInfo;
    ACCESS_ALLOWED_ACE       Dummy;

    PVOID  FirstAce = 0;
    PACL   pNewAcl = 0;

    ULONG NewAclSize, NewAceCount, AceSize;

    // Parameter check
    if ( !pOldAcl || !pClientSid || !ppNewAcl ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Init the out parameter
    *ppNewAcl = NULL;

    memset( &AclSizeInfo, 0, sizeof( AclSizeInfo ) );
    memset( &AclRevInfo, 0, sizeof( AclRevInfo ) );

    //
    // Get the old sd's values
    //
    fStatus = GetAclInformation( pOldAcl,
                                 &AclSizeInfo,
                                 sizeof( AclSizeInfo ),
                                 AclSizeInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = GetAclInformation( pOldAcl,
                                 &AclRevInfo,
                                 sizeof( AclRevInfo ),
                                 AclRevisionInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Calculate the new sd's values
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( Dummy.SidStart )
              + GetLengthSid( pClientSid );

    NewAclSize  = AceSize + AclSizeInfo.AclBytesInUse;
    NewAceCount = AclSizeInfo.AceCount + 1;

    //
    // Init the new acl
    //
    pNewAcl = LocalAlloc( 0, NewAclSize );
    if ( NULL == pNewAcl )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    fStatus = InitializeAcl( pNewAcl,
                             NewAclSize,
                             AclRevInfo.AclRevision );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Copy the old into the new
    //
    fStatus = GetAce( pOldAcl,
                      0,
                      &FirstAce );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = AddAce( pNewAcl,
                      AclRevInfo.AclRevision,
                      0,
                      FirstAce,
                      AclSizeInfo.AclBytesInUse - sizeof( ACL ) );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Finally, add the new ace
    //
    fStatus = AddAccessAllowedAce( pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pClientSid );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    // Assign the out parameter
    *ppNewAcl = pNewAcl;

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( ERROR_SUCCESS != WinError )
    {
        if ( pNewAcl )
        {
            LocalFree( pNewAcl );
        }
    }

    return WinError;

} // AddAceToAcl

DWORD
ClRtlAddAceToSd(
    IN  PSECURITY_DESCRIPTOR    pOldSd,
    IN  PSID                    pClientSid,
    IN  ACCESS_MASK             AccessMask,
    OUT PSECURITY_DESCRIPTOR *  ppNewSd
    )

/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and
    AccessMask. Stolen from \nt\ds\ds\src\ntdsa\dra\remove.c

Arguments:

    pOldSd - existing SD in self relative format

    pClientSid - SID to add to an ACE

    AccessMask - 'nuff said

    pNewAcl - pointer to new SD that contains new ACE

Return Values:

    ERROR_SUCCESS if the ace was put in the sd

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    BOOL   fStatus;

    PSECURITY_DESCRIPTOR pNewSelfRelativeSd = NULL;
    DWORD                NewSelfRelativeSdSize = 0;
    PACL                 pNewDacl  = NULL;

    SECURITY_DESCRIPTOR  AbsoluteSd;
    PACL                 pDacl  = NULL;
    PACL                 pSacl  = NULL;
    PSID                 pGroup = NULL;
    PSID                 pOwner = NULL;

    DWORD AbsoluteSdSize = sizeof( SECURITY_DESCRIPTOR );
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD GroupSize = 0;
    DWORD OwnerSize = 0;


    // Parameter check
    if ( !pOldSd || !pClientSid || !ppNewSd ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Init the out parameter
    *ppNewSd = NULL;

    RtlZeroMemory( &AbsoluteSd, AbsoluteSdSize );

    //
    // Break out the components of the self-relative SD by making it
    // absolute. First get the sizes of the components.
    //
    fStatus = MakeAbsoluteSD( pOldSd,
                              &AbsoluteSd,
                              &AbsoluteSdSize,
                              pDacl,
                              &DaclSize,
                              pSacl,
                              &SaclSize,
                              pOwner,
                              &OwnerSize,
                              pGroup,
                              &GroupSize );

    if ( !fStatus && ( ERROR_INSUFFICIENT_BUFFER == ( WinError = GetLastError() ))) {
        WinError = ERROR_SUCCESS;

        if ( 0 == DaclSize )
        {
            // No Dacl? We can't write to the dacl, then
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        if ( DaclSize > 0 ) {
            pDacl = LocalAlloc( LMEM_FIXED, DaclSize );
            if ( pDacl == NULL ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        if ( SaclSize > 0 ) {
            pSacl = LocalAlloc( LMEM_FIXED, SaclSize );
            if ( pSacl == NULL ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        if ( OwnerSize > 0 ) {
            pOwner = LocalAlloc( LMEM_FIXED, OwnerSize );
            if ( pOwner == NULL ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        if ( GroupSize > 0 ) {
            pGroup = LocalAlloc( LMEM_FIXED, GroupSize );
            if ( pGroup == NULL ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        fStatus = MakeAbsoluteSD( pOldSd,
                                  &AbsoluteSd,
                                  &AbsoluteSdSize,
                                  pDacl,
                                  &DaclSize,
                                  pSacl,
                                  &SaclSize,
                                  pOwner,
                                  &OwnerSize,
                                  pGroup,
                                  &GroupSize );

        if ( !fStatus ) {
            WinError = GetLastError();
        }
    }

    if ( ERROR_SUCCESS != WinError ) {
        goto Cleanup;
    }

    //
    // Create a new dacl with the new ace
    //
    WinError = AddAceToAcl(pDacl,
                           pClientSid,
                           AccessMask,
                           &pNewDacl );

    if ( ERROR_SUCCESS != WinError ) {
        goto Cleanup;
    }

    //
    // Set the dacl
    //
    fStatus = SetSecurityDescriptorDacl( &AbsoluteSd,
                                         TRUE,     // dacl is present
                                         pNewDacl,
                                         FALSE );  //  facl is not defaulted

    if ( !fStatus ) {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Make the new SD self relative; get the size first
    //
    fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                   pNewSelfRelativeSd,
                                   &NewSelfRelativeSdSize );

    if ( !fStatus && ( ERROR_INSUFFICIENT_BUFFER == ( WinError = GetLastError() ))) {
        WinError = ERROR_SUCCESS;

        pNewSelfRelativeSd = LocalAlloc( 0, NewSelfRelativeSdSize );

        if ( pNewSelfRelativeSd ) {
            fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                           pNewSelfRelativeSd,
                                           &NewSelfRelativeSdSize );

            if ( !fStatus ) {
                WinError = GetLastError();
            }
        }
        else {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( pNewDacl ) {
        LocalFree( pNewDacl );
    }

    if ( ERROR_SUCCESS == WinError ) {
        *ppNewSd = pNewSelfRelativeSd;
    }
    else if ( pNewSelfRelativeSd ) {
        LocalFree( pNewSelfRelativeSd );
    }

    if ( pDacl != NULL ) {
        LocalFree( pDacl );
    }

    if ( pSacl != NULL ) {
        LocalFree( pSacl );
    }

    if ( pGroup != NULL ) {
        LocalFree( pGroup );
    }

    if ( pOwner != NULL ) {
        LocalFree( pOwner );
    }

    return WinError;

} // ClRtlAddAceToSd

DWORD
ClRtlAddClusterServiceAccountToWinsta0DACL(
    VOID
    )

/*++

Routine Description:

    Modify the DACL on the interactive window station (Winsta0) and its
    desktop such that resmon child processes (such as gennap resources) can
    display on the desktop if so desired.

    MEGA-IMPORTANT: this routine must be synchronized in a multi-threaded
    environment, i.e., make sure that you're holding a lock of some sort
    before calling it. It won't solve the race condition on setting the DACL
    that exists between processes but it will make sure that the window
    station APIs work correctly.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if it worked...

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    LPWSTR                  accountInfo = NULL;
    PTOKEN_USER             sidData = NULL;
    HWINSTA                 winsta0 = NULL;
    HWINSTA                 previousWinStation = NULL;
    HDESK                   desktop = NULL;
    SECURITY_INFORMATION    requestedSI = DACL_SECURITY_INFORMATION;
    BOOL                    success;
    DWORD                   lengthRequired = 0;
    DWORD                   lengthRequired2;
    DWORD                   i;
    PSECURITY_DESCRIPTOR    winstaSD = NULL;
    PSECURITY_DESCRIPTOR    deskSD = NULL;
    PSECURITY_DESCRIPTOR    newSD = NULL;
    BOOL                    hasDACL;
    PACL                    dacl;
    BOOL                    daclDefaulted;

    //
    // first see if we have the access we need by trying to open the
    // interactive window station and its default desktop. if so, don't go any
    // further and return success
    //
    winsta0 = OpenWindowStation( L"winsta0", FALSE, GENERIC_ALL );
    if ( winsta0 != NULL ) {

        previousWinStation = GetProcessWindowStation();
        success = SetProcessWindowStation( winsta0 );

        if ( success ) {

            //
            // if we have window station access, we should have desktop as well
            //
            desktop = OpenDesktop( L"default", 0, FALSE, GENERIC_ALL );
            SetProcessWindowStation( previousWinStation );
            previousWinStation = NULL;

            if ( desktop != NULL ) {
                //
                // always switch the winstation back to the previous one
                // before closing the desktop and winstation handles
                //
                CloseDesktop( desktop );
                CloseWindowStation( winsta0 );
                return ERROR_SUCCESS;
            }
        }
        CloseWindowStation( winsta0 );
    }

    //
    // get the SID of the account associated with this thread. This is the
    // account that will be added to the DACL
    //
    sidData = ClRtlGetSidOfCallingThread();
    if ( sidData == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] ClRtlGetSidOfCallingThread failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // open handles to Winsta0 and its default desktop. Temporarily switch to
    // winsta0 to get its default desktop
    //
    winsta0 = OpenWindowStation( L"winsta0", TRUE, MAXIMUM_ALLOWED );
    if ( winsta0 == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] OpenWindowStation failed. Status %1!u!\n", status );
        goto error_exit;
    }

    previousWinStation = GetProcessWindowStation();
    success = SetProcessWindowStation( winsta0 );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetProcessWindowStation(winsta0) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    desktop = OpenDesktop( L"default", 0, TRUE, MAXIMUM_ALLOWED );
    if ( desktop == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] OpenDesktop(default) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // get the SD and its DACL for Winsta0
    //
    success = GetUserObjectSecurity(winsta0,
                                    &requestedSI,
                                    NULL,
                                    0,
                                    &lengthRequired);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurityLen(winsta0) failed. Status %1!u!\n", status );
            goto error_exit;
        }
    }

    //
    // If UserObjectLen grew on us more than a few times,
    // something is fishy, so we will fail the request
    //
    for(i = 0; i < 5; ++i) {
        winstaSD = LocalAlloc( LMEM_FIXED, lengthRequired );
        if ( winstaSD == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        success = GetUserObjectSecurity(winsta0,
                                        &requestedSI,
                                        winstaSD,
                                        lengthRequired,
                                        &lengthRequired2);
        if ( success ) {
            status = ERROR_SUCCESS;
            break;
        }

        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(winsta0) failed. Status %1!u!\n", status );
            goto error_exit;
        }

        lengthRequired = lengthRequired2;
        LocalFree(winstaSD);
        winstaSD = NULL;
    }

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(winsta0) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // build a new SD that includes our service account SID giving it complete
    // access
    //
    status = ClRtlAddAceToSd( winstaSD, sidData->User.Sid, GENERIC_ALL, &newSD );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] ClRtlAddAceToSd(winsta) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    //
    // set the new SD on Winsta0
    //
    success = SetUserObjectSecurity( winsta0, &requestedSI, newSD );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetUOSecurity(winsta0) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    LocalFree( newSD );
    newSD = NULL;

    //
    // repeat the process for the desktop SD and its DACL
    //
    success = GetUserObjectSecurity(desktop,
                                    &requestedSI,
                                    NULL,
                                    0,
                                    &lengthRequired);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurityLen(desktop) failed. Status %1!u!\n", status );
            goto error_exit;
        }
    }

    //
    // If UserObjectLen grew on us more than a few times,
    // something is fishy, so we will fail the request
    //
    for (i = 0; i < 5; ++i) {
        deskSD = LocalAlloc( LMEM_FIXED, lengthRequired );
        if ( deskSD == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        success = GetUserObjectSecurity(desktop,
                                        &requestedSI,
                                        deskSD,
                                        lengthRequired,
                                        &lengthRequired2);
        if ( success ) {
            status = ERROR_SUCCESS;
            break;
        }

        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(desktop) failed. Status %1!u!\n", status );
            goto error_exit;
        }

        lengthRequired = lengthRequired2;
        LocalFree(deskSD);
        deskSD = NULL;
    }
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] GetUOSecurity(desktop) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    status = ClRtlAddAceToSd( deskSD, sidData->User.Sid, GENERIC_ALL, &newSD );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] ClRtlAddAceToSd(desktop) failed. Status %1!u!\n", status );
        goto error_exit;
    }

    success = SetUserObjectSecurity( desktop, &requestedSI, newSD );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetUserObjectSecurity(desktop) failed. Status %1!u!\n", status );
    }

error_exit:

    FREE_IF_NOT_NULL( newSD, LocalFree );

    FREE_IF_NOT_NULL( deskSD, LocalFree );

    FREE_IF_NOT_NULL( winstaSD, LocalFree );

    //
    // always switch the winstation back to the previous one before closing
    // the desktop and winstation handles
    //
    if ( previousWinStation != NULL ) {
        success = SetProcessWindowStation( previousWinStation );
        if ( !success ) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, "[ClRtl] SetWindowsStation(previous) failed. Status %1!u!\n", status );
        }
    }

    FREE_IF_NOT_NULL( desktop, CloseDesktop );

    FREE_IF_NOT_NULL( winsta0, CloseWindowStation );

    FREE_IF_NOT_NULL( sidData, LocalFree );

    FREE_IF_NOT_NULL( accountInfo, LocalFree );

    return status;

} // ClRtlAddClusterServiceAccountToWinsta0DACL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\rpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    Handy utility functions for supporting RPC

Author:

    John Vert (jvert) 2-Jan-1996

Revision History:

--*/
#include "clusrtlp.h"
#include "rpc.h"

void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_FIXED, len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    LocalFree(ptr);
}

LPWSTR
ClRtlMakeGuid(
    VOID
    )
/*++

Routine Description:

    Creates a new GUID in string form.

Arguments:

    None.

Return Value:

    A pointer to the GUID string if successful.
    NULL if unsuccessful.

Notes:

    The storage for the GUID string must be freed by the caller.
    Sometimes, the GUID storage is copied to a buffer that is
    allocated using another allocator. At that point, the free
    routines can't tell where free method to call. Sometimes this
    causes a problem. To get around this problem, antoher buffer
    is allocated such that the free methods will always work.

--*/
{
    DWORD    sc;
    UUID     guid;
    LPWSTR   guidString = NULL;
    LPWSTR   guidBuffer = NULL;


    sc = UuidCreate( &guid );
    if ( ( sc == RPC_S_OK ) || ( sc == RPC_S_UUID_LOCAL_ONLY ) ) {

        sc = UuidToString( &guid, &guidString );
        if ( sc == RPC_S_OK ) {

            guidBuffer = LocalAlloc( LMEM_FIXED, ( wcslen( guidString ) + 1 ) * sizeof( WCHAR ) );
            if ( guidBuffer != NULL )
                wcscpy( guidBuffer, guidString );

        } 

    }

    //
    // if either UuidCreate or UuidToString fails, sc will reflect that
    // failure which should be set by this function. If LocalAlloc fails, it
    // will have called SetLastError and we want to propagate that value back
    // to the caller.
    //
    if ( sc != RPC_S_OK )
        SetLastError( sc );

    if ( guidString != NULL )
    {
        RpcStringFree( &guidString );
    } // if:

    return( guidBuffer );

}  // ClRtlMakeGuid
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\tcpcfg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   tcpcfg.c

Abstract:

    TCP/IP translation routines

Author:

    Mike Massa (mikemas)           July 15, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-15-97    created


--*/
#include "clusrtlp.h"
#include <tdi.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <ntddtcp.h>
#include <winsock2.h>
#include <wchar.h>



//
// Private Constants
//
#define MAX_ADDRESS_STRING_LENGTH    15
#define MAX_ENDPOINT_STRING_LENGTH    5

VOID
ClRtlQueryTcpipInformation(
    OUT  LPDWORD   MaxAddressStringLength,
    OUT  LPDWORD   MaxEndpointStringLength,
    OUT  LPDWORD   TdiAddressInfoLength
    )
/*++

Routine Description:

    Returns information about the TCP/IP protocol.

Arguments:

    MaxAddressStringLength - A pointer to a variable into which to place
                             the maximum length, in characters, of a TCP/IP
                             network address value in string format, including
                             the terminating NULL. If this parameter is NUL,
                             it will be skipped.

    MaxEndpointStringLength - A pointer to a variable into which to place
                             the maximum length, in characters, of a TCP/IP
                             transport endpoint value in string format,
                             including the terminating NUL. If this parameter
                             is NULL, it will be skipped.

Return Value:

    None.

--*/
{
    if (MaxAddressStringLength != NULL) {
        *MaxAddressStringLength = MAX_ADDRESS_STRING_LENGTH;
    }

    if (MaxEndpointStringLength != NULL) {
        *MaxEndpointStringLength = MAX_ENDPOINT_STRING_LENGTH;
    }

    if (TdiAddressInfoLength != NULL) {
        *TdiAddressInfoLength =  sizeof(TDI_ADDRESS_INFO) -
                                 sizeof(TRANSPORT_ADDRESS) +
                                 sizeof(TA_IP_ADDRESS);
    }

    return;

} // ClRtlQueryTcpipInformation


DWORD
ClRtlTcpipAddressToString(
    ULONG     AddressValue,
    LPWSTR *  AddressString
    )
/*++

Routine Description:

    Converts a binary representation of a TCP/IP network address,
    in network byte order, into a string representation.

Arguments:

     AddressValue - The binary value, in network byte order, to convert.

     AddressString - A pointer to a pointer to a unicode string buffer into
                     which to place the converted value. If this parameter
                     is NULL, the string buffer will be allocated and
                     must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD              status;
    NTSTATUS           ntStatus;
    UNICODE_STRING     unicodeString;
    ANSI_STRING        ansiString;
    LPSTR              ansiBuffer;
    LPWSTR             addressString;
    BOOLEAN            allocatedStringBuffer = FALSE;
    USHORT             maxStringLength = (MAX_ADDRESS_STRING_LENGTH + 1) *
                                         sizeof(WCHAR);


    if (*AddressString == NULL) {
        addressString = LocalAlloc(LMEM_FIXED, maxStringLength);

        if (addressString == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        allocatedStringBuffer = TRUE;
    }
    else {
        addressString = *AddressString;
    }

    ansiBuffer = inet_ntoa(*((struct in_addr *) &AddressValue));

    if (ansiBuffer == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    RtlInitAnsiString(&ansiString, ansiBuffer);

    unicodeString.Buffer = addressString;
    unicodeString.Length = 0;
    unicodeString.MaximumLength = maxStringLength;

    ntStatus = RtlAnsiStringToUnicodeString(
                   &unicodeString,
                   &ansiString,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        goto error_exit;
    }

    *AddressString = addressString;

    return(ERROR_SUCCESS);

error_exit:

    if (allocatedStringBuffer) {
        LocalFree(addressString);
    }

    return(status);

}  // ClRtlTcpipAddressToString


DWORD
ClRtlTcpipStringToAddress(
    LPCWSTR AddressString,
    PULONG  AddressValue
    )
/*++

Routine Description:

    Converts a string representation of a TCP/IP network address
    into a binary representation in network byte order.  The string must
    be formatted in the canonical IP Address form (xxx.xxx.xxx.xxx).
    Leading zeros are optional.

Arguments:

    AddressString  - A pointer to the string to convert.

    AddressValue - A pointer to a variable into which to place the converted
                   binary value. The value will be in network byte order.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  unicodeString;
    STRING          ansiString;
    ULONG           address;


    //
    // Make sure the string is formatted correctly.
    //
    {
        DWORD   periodCount = 0;
        DWORD   digitCount = 0;
        BOOLEAN isValid = TRUE;
        LPCWSTR addressString = AddressString;
        LPCWSTR digitString = AddressString;

        while (*addressString != L'\0') {
            if (*addressString == L'.') {
                // Character is a period.  There must be exactly
                // three periods.  There must be at least one
                // digit before each period.
                periodCount++;
                if ((digitCount == 0) || (periodCount > 3)) {
                    isValid = FALSE;
                } else if (wcstoul(digitString, NULL, 10) > 255) {
                    isValid = FALSE;
                } else {
                    digitCount = 0;
                    digitString = addressString + 1;
                }
            } else if (iswdigit(*addressString)) {
                // Character is a digit.  There can be up to three
                // decimal digits before each period, and the value
                // can not exceed 255.
                digitCount++;
                if (digitCount > 3) {
                    isValid = FALSE;
                }
            }
            else {
                // Character is not a digit.
                isValid = FALSE;
            }

            if (!isValid)
                break;
            addressString++;
        }
        if ((periodCount != 3) ||
            (digitCount == 0) ||
            (wcstoul(digitString, NULL, 10) > 255)) {
            isValid = FALSE;
        }
        if (!isValid)
            return(ERROR_INVALID_PARAMETER);
    }

    RtlInitUnicodeString(&unicodeString, AddressString);

    status = RtlUnicodeStringToAnsiString(
                 &ansiString,
                 &unicodeString,
                 TRUE
                 );

    if (status == STATUS_SUCCESS) {
        address = inet_addr(ansiString.Buffer);

        RtlFreeAnsiString(&ansiString);

        if (address == INADDR_NONE) {
           if (lstrcmpW(AddressString, L"255.255.255.255") != 0) {
               return(ERROR_INVALID_PARAMETER);
           }
        }

        *AddressValue = address;

        return(ERROR_SUCCESS);
    }

    return(status);

}  // ClRtlTcpipStringToAddress


DWORD
ClRtlTcpipEndpointToString(
    USHORT    EndpointValue,
    LPWSTR *  EndpointString
    )
/*++

Routine Description:

    Converts a binary representation of a TCP/IP transport endpoint,
    in network byte order, into a string representation.

Arguments:

     EndpointValue - The binary value, in network byte order, to convert.

     EndpointString - A pointer to a pointer to a unicode string buffer into
                      which to place the converted value. If this parameter
                      is NULL, the string buffer will be allocated and
                      must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD              status;
    NTSTATUS           ntStatus;
    ULONG              endpointValue;
    LPWSTR             endpointString;
    USHORT             maxStringLength =  (MAX_ENDPOINT_STRING_LENGTH + 1) *
                                          sizeof(WCHAR);


    if (*EndpointString == NULL) {
        endpointString = LocalAlloc(LMEM_FIXED, maxStringLength);

        if (endpointString == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        *EndpointString = endpointString;
    }
    else {
        endpointString = *EndpointString;
    }

    endpointValue = 0;
    endpointValue = ntohs(EndpointValue);

    _ultow( endpointValue, endpointString, 10);

    return(ERROR_SUCCESS);

}  // ClRtlTcpipEndpointToString


DWORD
ClRtlTcpipStringToEndpoint(
    LPCWSTR  EndpointString,
    PUSHORT  EndpointValue
    )
/*++

Routine Description:

    Converts a string representation of a TCP/IP transport endpoint
    into a binary representation in network byte order.

Arguments:

    EndpointString  - A pointer to the string to convert.

    EndpointValue - A pointer to a variable into which to place the converted
                    binary value. The value will be in network byte order.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    ULONG   endpoint;
    DWORD   length = lstrlenW(EndpointString);


    if ( (length == 0) || (length > MAX_ENDPOINT_STRING_LENGTH) ) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    endpoint = wcstoul(EndpointString, NULL, 10);

    if (endpoint > 0xFFFF) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    *EndpointValue = (USHORT) htons( ((USHORT) endpoint) );

    return(ERROR_SUCCESS);

}  // ClRtlTcpipStringToEndpoint


BOOL
ClRtlIsValidTcpipAddress(
    IN ULONG   Address
    )
{

    //
    // Convert to little-endian format, since that is what the broken
    // winsock macros require.
    //
    Address = ntohl(Address);

    if ( (Address == 0) ||
         (!IN_CLASSA(Address) && !IN_CLASSB(Address) && !IN_CLASSC(Address))
       )
    {
        return(FALSE);
    }

    return(TRUE);

} // ClRtlIsValidTcpipAddress



BOOL
ClRtlIsValidTcpipSubnetMask(
    IN ULONG   SubnetMask
    )
{

    if ( (SubnetMask == 0xffffffff) || (SubnetMask == 0)) {
        return(FALSE);
    }

    return(TRUE);

} // ClRtlIsValidTcpipSubnetMask

BOOL
ClRtlIsValidTcpipAddressAndSubnetMask(
    IN ULONG   Address,
    IN ULONG   SubnetMask
    )
{
    ULONG NetOnly = Address & SubnetMask;
    ULONG HostOnly = Address & ~SubnetMask;

    //
    // make sure the address/subnet combination makes sense.
    // This assumes that the address has already been validated
    // by a call to ClRtlIsValidTcpipAddress
    //

    return !( NetOnly == 0            ||
              NetOnly == SubnetMask   ||
              HostOnly == 0           ||
              HostOnly == ~SubnetMask
            );

} // ClRtlIsValidTcpipAddressAndSubnetMask


DWORD
ClRtlBuildTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    IN  LPWSTR    TransportEndpoint,
    OUT LPVOID *  TdiAddress,
    OUT LPDWORD   TdiAddressLength
    )
/*++

Routine Description:

    Builds a TDI Transport Address structure containing the specified
    NetworkAddress and TransportEndpoint. The memory for the TDI address
    is allocated by this routine and must be freed by the caller.

Arguments:

    NetworkAddress - A pointer to a unicode string containing the
                     network address to encode.

    TransportEndpoint - A pointer to a unicode string containing the
                        transport endpoint to encode.

    TdiAddress - On output, contains the address of the TDI Transport
                 Address structure.

    TdiAddressLength - On output, contains the length of the TDI Transport
                       address structure.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    PTA_IP_ADDRESS          taIpAddress;
    ULONG                   ipAddress;
    USHORT                  udpPort;


    status = ClRtlTcpipStringToAddress(NetworkAddress, &ipAddress);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = ClRtlTcpipStringToEndpoint(TransportEndpoint, &udpPort);

    if (lstrlenW(TransportEndpoint) > MAX_ENDPOINT_STRING_LENGTH) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    taIpAddress = LocalAlloc(LMEM_FIXED, sizeof(TA_IP_ADDRESS));

    if (taIpAddress == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(taIpAddress, sizeof(TA_IP_ADDRESS));

    taIpAddress->TAAddressCount = 1;
    taIpAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    taIpAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    taIpAddress->Address[0].Address[0].in_addr = ipAddress;
    taIpAddress->Address[0].Address[0].sin_port = udpPort;

    *TdiAddress = taIpAddress;
    *TdiAddressLength = sizeof(TA_IP_ADDRESS);

    return(ERROR_SUCCESS);

}  // ClRtlBuildTcpipTdiAddress


DWORD
ClRtlBuildLocalTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    OUT LPVOID    TdiAddress,
    OUT LPDWORD   TdiAddressLength
    )
/*++

Routine Description:

    Builds a TDI Transport Address structure which can be used to open
    a local TDI Address Object. The TransportEndpoint is chosen by the
    transport. The memory for the TDI address is allocated by this
    routine and must be freed by the caller.

Arguments:

    NetworkAddress - A pointer to a unicode string containing the
                     network address to encode.

    TdiAddress - On output, contains the address of the TDI Transport
                 Address structure.

    TdiAddressLength - On output, contains the length of the TDI Transport
                       address structure.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{

    return(ClRtlBuildTcpipTdiAddress(
               NetworkAddress,
               L"0",
               TdiAddress,
               TdiAddressLength
               ));

}  // ClRtlBuildLocalTcpipTdiAddress


DWORD
ClRtlParseTcpipTdiAddress(
    IN  LPVOID    TdiAddress,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    )
/*++

Routine Description:

    Extracts the NetworkAddress and TransportEndpoint values from
    a TDI address.

Arguments:

    TdiAddress - A pointer to the TDI TRANSPORT_ADDRESS structure to parse.

    NetworkAddress - A pointer to a pointer to a unicode string into which
                     the parsed network address will be placed. If this
                     parameter is NULL, the target string buffer will be
                     allocated and must be freed by the caller.

    TransportEndpoint - A pointer to a pointer to a unicode string into
                        which the parsed transport endpoint will be placed.
                        If this parameter is NULL, the target string buffer
                        will be allocated and must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    LONG                        i;
    TA_ADDRESS *                currentAddr;
    TDI_ADDRESS_IP UNALIGNED *  validAddr = NULL;
    PTRANSPORT_ADDRESS          addrList = TdiAddress;
    DWORD                       status;
    BOOLEAN                     allocatedAddressString = FALSE;


    currentAddr = (TA_ADDRESS *)addrList->Address;

    for (i = 0; i < addrList->TAAddressCount; i++) {
        if (currentAddr->AddressType == TDI_ADDRESS_TYPE_IP) {
            if (currentAddr->AddressLength >= TDI_ADDRESS_LENGTH_IP) {
                validAddr = (TDI_ADDRESS_IP UNALIGNED *) currentAddr->Address;
                break;

            }
        } else {
            currentAddr = (TA_ADDRESS *)(currentAddr->Address +
                currentAddr->AddressLength);
        }
    }

    if (validAddr == NULL) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    if (*NetworkAddress == NULL) {
        allocatedAddressString = TRUE;
    }

    status = ClRtlTcpipAddressToString(
                 validAddr->in_addr,
                 NetworkAddress
                 );

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = ClRtlTcpipEndpointToString(
                 validAddr->sin_port,
                 TransportEndpoint
                 );

    if (status != ERROR_SUCCESS) {
        if (allocatedAddressString) {
            LocalFree(*NetworkAddress);
            *NetworkAddress = NULL;
        }

        return(status);
    }

    return(ERROR_SUCCESS);

}  // ClRtlParseTcpipTdiAddress


DWORD
ClRtlParseTcpipTdiAddressInfo(
    IN  LPVOID    TdiAddressInfo,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    )
/*++

Routine Description:

    Extracts the NetworkAddress and TransportEndpoint values from
    a TDI_ADDRESS_INFO structure.

Arguments:

    TdiAddressInfo - A pointer to the TDI_ADDRESS_INFO  structure to parse.

    NetworkAddress - A pointer to a pointer to a unicode string into which
                     the parsed network address will be placed. If this
                     parameter is NULL, the target string buffer will be
                     allocated and must be freed by the caller.

    TransportEndpoint - A pointer to a pointer to a unicode string into
                        which the parsed transport endpoint will be placed.
                        If this parameter is NULL, the target string buffer
                        will be allocated and must be freed by the caller.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD status;
    PTDI_ADDRESS_INFO   addressInfo = TdiAddressInfo;


    status = ClRtlParseTcpipTdiAddress(
                 &(addressInfo->Address),
                 NetworkAddress,
                 TransportEndpoint
                 );

    return(status);

}  // ClRtlParseTcpipTdiAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\rtlprop.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    rtlprop.c

Abstract:

    Implements the management of properties.

Author:

    Rod Gamache (rodga) 7-Jan-1996

Revision History:

    David Potter (davidp) 12-Mar-1997
        Moved to CLUSRTL.

--*/

#define UNICODE 1
#define _UNICODE 1

#pragma warning( push )
#include "clusrtlp.h"
#include "stdio.h"
#include "stdlib.h"
#include "RegistryValueName.h"
#include <strsafe.h>
#pragma warning( pop )

#pragma warning( push, 4 )

//  CL_ASSERT( 0 ) will error under W4
#pragma warning( disable : 4127 )   // conditional expression is constant

#define CLRTL_NULL_STRING L"\0"

//
// Data alignment notes - Charlie Wickham (Q4/2000)
//
// All data in property lists are aligned on 32b boundaries (64b platforms
// were not a consideration when this code was originally written). Quadword
// data types (large ints and double star pointers in parameter tables) that
// don't fall on quadword aligned boundaries will cause alignment faults when
// dereferenced. Any references to a quadword data type may require that the
// prop list data be copied into a properly aligned temporary structure. That
// structure can then used for the duration of the
// routine. ClRtlpSet{U}LargeIntProperty uses this technique. Otherwise, you
// must use the UNALIGNED keyword if there is any chance the quadword could be
// improperly aligned.
//
// Parameter blocks, which are used by resource DLLs to hold the current
// property values, are expected to be naturally aligned. This means that if
// the param block contains pointers, they must be correctly aligned. A number
// of routines in this file use double star pointers where the value of the
// double star pointer is the address of an offset into the parameter
// block. If these offsets are wrong for quad data types, the resmon process
// will get an alignment fault and die.
//
// Amazingly (or luckily depending on your point of view), the whole set of
// CLUSPROP_* structures are quad aligned. All new CLUSPROP structs must be
// constructed such that any member requiring quad alignment is properly
// aligned.
//

//
// Static function prototypes.
//

static
DWORD
WINAPI
ClRtlpSetDwordProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_DWORD pInDwordValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetLongProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LONG pInLongValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetULargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_ULARGE_INTEGER pInULargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetLargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LARGE_INTEGER pInLargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_SZ pInStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetMultiStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_MULTI_SZ pInMultiStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );

static
DWORD
WINAPI
ClRtlpSetBinaryProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_BINARY pInBinaryValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    );



DWORD
WINAPI
ClRtlEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    return the names of all properties in the specified property table as a
    a sequence of null terminated strings

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   totalBufferLength = 0;
    DWORD                   cchProperties;
    PRESUTIL_PROPERTY_ITEM  property;
    LPWSTR                  psz = pszOutProperties;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( pPropertyTable == NULL )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlEnumProperties: pPropertyTable == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    cchProperties = cbOutPropertiesSize / sizeof( WCHAR );

    //
    // Clear the output buffer
    //
    if ( pszOutProperties != NULL )
    {
        ZeroMemory( pszOutProperties, cbOutPropertiesSize );
    }

    //
    // Get the size of all property names for this object.
    //
    for ( property = pPropertyTable ; property->Name != NULL ; property++ )
    {
        totalBufferLength += ((DWORD) wcslen( property->Name ) + 1) * sizeof(WCHAR);
    }

    totalBufferLength += sizeof(UNICODE_NULL);

    //
    // If the output buffer is big enough, copy the property names.
    //
    if ( totalBufferLength > cbOutPropertiesSize )
    {
        *pcbRequired = totalBufferLength;
        totalBufferLength = 0;
        if ( pszOutProperties == NULL )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            status = ERROR_MORE_DATA;
        }
    }
    else
    {
        DWORD   cchCurrentNameSize;
        size_t  cchRemaining;
        HRESULT hr;

        for ( property = pPropertyTable ; property->Name != NULL ; property++ )
        {
            hr = StringCchCopyExW( psz, cchProperties, property->Name, NULL, &cchRemaining, 0 );
            if ( FAILED( hr ) )
            {
                status = HRESULT_CODE( hr );
                goto Cleanup;
            }
            cchCurrentNameSize = cchProperties - (DWORD) cchRemaining + 1;
            *pcbBytesReturned += cchCurrentNameSize * sizeof(WCHAR);
            psz += cchCurrentNameSize;
            cchProperties -= cchCurrentNameSize;
        } // if:

        *psz = L'\0';
        *pcbBytesReturned += sizeof(WCHAR);
    }

Cleanup:

    return status;

} // ClRtlEnumProperties



DWORD
WINAPI
ClRtlEnumPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    return the names of all private properties stored in the cluster database
    as a sequence of null terminated strings

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       totalBufferLength = 0;
    DWORD       cchProperties;
    LPWSTR      psz = pszOutProperties;
    DWORD       ival;
    DWORD       currentNameLength = 20;
    DWORD       nameLength;
    DWORD       dataLength;
    DWORD       type;
    LPWSTR      pszName;
    HRESULT     hr;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    cchProperties = cbOutPropertiesSize / sizeof( WCHAR );

    //
    // Validate inputs
    //
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) )
    {

        ClRtlDbgPrint( LOG_CRITICAL,
                       "ClRtlEnumPrivateProperties: hkeyClusterKey or pClusterRegApis == NULL. "
                       "Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pszOutProperties != NULL )
    {
        ZeroMemory( pszOutProperties, cbOutPropertiesSize );
    }

    //
    // Allocate a property name buffer.
    //
    pszName = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) ) );
    if ( pszName == NULL )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate all properties to find the total size.
    //
    ival = 0;
    for( ;; )
    {
        //
        // Read the next property.
        //
        nameLength = currentNameLength;
        dataLength = 0;
        status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                   ival,
                                                   pszName,
                                                   &nameLength,
                                                   &type,
                                                   NULL,
                                                   &dataLength );
        if ( status == ERROR_NO_MORE_ITEMS )
        {
            status = ERROR_SUCCESS;
            break;
        } // if:
        else if ( status == ERROR_MORE_DATA )
        {

            CL_ASSERT( (nameLength+1) > currentNameLength );

            LocalFree( pszName );

            currentNameLength = nameLength + 1; // returned value doesn't include terminating NULL
            pszName = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) ) );
            if ( pszName == NULL )
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } // if:

            continue; // retry

        } // else if:
        else if ( status != ERROR_SUCCESS )
        {
            break;
        } // else if:

        totalBufferLength += (nameLength + 1) * sizeof(WCHAR);
        ++ival;
    } // for:

    //
    // Continue only if the operations so far have been successful.
    //
    if ( status == ERROR_SUCCESS )
    {

        if ( totalBufferLength != 0 )
        {
            totalBufferLength += sizeof(UNICODE_NULL);
        }

        //
        // If the output buffer is big enough, copy the property names.
        //
        if ( totalBufferLength > cbOutPropertiesSize )
        {
            *pcbRequired = totalBufferLength;
            totalBufferLength = 0;
            if ( (pszOutProperties == NULL) ||
                 (cbOutPropertiesSize == 0) )
            {
                status = ERROR_SUCCESS;
            } // if:
            else
            {
                status = ERROR_MORE_DATA;
            } // else:
        } // if:
        else if ( totalBufferLength != 0 )
        {
            //
            // Enumerate all properties for copying
            //
            for ( ival = 0; ; ival++ )
            {
                //
                // Read the next property.
                //
                nameLength = currentNameLength;
                dataLength = 0;
                status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                           ival,
                                                           pszName,
                                                           &nameLength,
                                                           &type,
                                                           NULL,
                                                           &dataLength );

                if ( status == ERROR_NO_MORE_ITEMS )
                {
                    status = ERROR_SUCCESS;
                    break;
                } // if:
                else if ( status == ERROR_MORE_DATA )
                {
                    //
                    // but it can if a new property is added in between the
                    // first enumeration and this one.
                    //
                    CL_ASSERT( 0 ); // THIS SHOULDN'T HAPPEN
                } // else if:
                else if ( status != ERROR_SUCCESS )
                {
                    break;
                } // else if:

                //CL_ASSERT( (DWORD)wcslen( name ) == nameLength );
                hr = StringCchCopyW( psz, cchProperties, pszName );
                if ( FAILED( hr ) )
                {
                    status = HRESULT_CODE( hr );
                    goto Cleanup;
                }
                nameLength++;
                psz += nameLength;
                cchProperties -= nameLength;
                *pcbBytesReturned += nameLength * sizeof(WCHAR);
            } // for:

            *psz = L'\0';
            *pcbBytesReturned += sizeof(WCHAR);
        } // else if:
    } // if:

Cleanup:

    LocalFree( pszName );

    return status;

} // ClRtlEnumPrivateProperties


DWORD
WINAPI
ClRtlGetProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Using the specified cluster database key, build a property list of the
    properties identifed in the specified property table.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property list to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           itemCount = 0;
    DWORD           totalBufferLength = 0;
    PVOID           outBuffer = pOutPropertyList;
    DWORD           bufferLength = cbOutPropertyListSize;
    PRESUTIL_PROPERTY_ITEM  property;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ||
         (pPropertyTable == NULL) )
    {

        ClRtlDbgPrint( LOG_CRITICAL,
                       "ClRtlGetProperties: hkeyClusterKey, pClusterRegApis, or "
                       "pPropertyTable == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pOutPropertyList != NULL )
    {
        ZeroMemory( pOutPropertyList, cbOutPropertyListSize );
    }

    //
    // Get the size of all properties for this object.
    //
    property = pPropertyTable;
    while ( property->Name != NULL )
    {
        status = ClRtlGetPropertySize( hkeyClusterKey,
                                       pClusterRegApis,
                                       property,
                                       &totalBufferLength,
                                       &itemCount );

        if ( status != ERROR_SUCCESS )
        {
            break;
        }
        property++;
    } // while:


    //
    // Continue only if the operations so far have been successful.
    //
    if ( status == ERROR_SUCCESS )
    {
        //
        // Count for item count at front of return data and endmark.
        //
        totalBufferLength += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);

        //
        // Verify the size of all the properties
        //
        if ( totalBufferLength > cbOutPropertyListSize )
        {
            *pcbRequired = totalBufferLength;
            totalBufferLength = 0;
            if ( pOutPropertyList == NULL )
            {
                status = ERROR_SUCCESS;
            }
            else
            {
                status = ERROR_MORE_DATA;
            }
        }
        else
        {
            *(LPDWORD)outBuffer = itemCount;
            outBuffer = (PVOID)( (PUCHAR)outBuffer + sizeof(itemCount) );
            bufferLength -= sizeof(itemCount);

            //
            // Now fetch all of the properties.
            //
            property = pPropertyTable;
            while ( property->Name != NULL )
            {
                status = ClRtlGetProperty( hkeyClusterKey,
                                           pClusterRegApis,
                                           property,
                                           &outBuffer,
                                           &bufferLength );

                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                property++;
            } // while:

            // Don't forget the ENDMARK
            *(LPDWORD)outBuffer = CLUSPROP_SYNTAX_ENDMARK;

            if ( (status != ERROR_SUCCESS) &&
                 (status != ERROR_MORE_DATA) )
            {
                totalBufferLength = 0;
            }
        }

        *pcbBytesReturned = totalBufferLength;
    }

    return(status);

} // ClRtlGetProperties



DWORD
WINAPI
ClRtlGetAllProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Using the specified cluster database key, build a property list of the
    properties identifed in the specified property table as well as any other
    props that are not listed in the property table (the unknown props).

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER      cbhKnownPropBuffer;
    CLUSPROP_BUFFER_HELPER      cbhUnknownPropBuffer;
    DWORD                       cbKnownPropBufferSize;
    DWORD                       cbUnknownPropBufferSize;
    DWORD                       sc = ERROR_SUCCESS;
    DWORD                       scUnknown;
    DWORD                       dwSavedData;
    DWORD                       cbUnknownRequired = 0;
    DWORD                       cbUnknownReturned = 0;


    cbhKnownPropBuffer.pb = static_cast< LPBYTE >( pOutPropertyList );
    cbKnownPropBufferSize = cbOutPropertyListSize;

    //
    // First get the 'known' properties.
    //
    sc = ClRtlGetProperties(
                hkeyClusterKey,
                pClusterRegApis,
                pPropertyTable,
                cbhKnownPropBuffer.pb,
                cbKnownPropBufferSize,
                pcbReturned,
                pcbRequired
                );

    if ( sc != ERROR_SUCCESS )
    {
        *pcbReturned = 0;

        if ( sc != ERROR_MORE_DATA )
        {
            *pcbRequired = 0;
            return sc;
        }

        // We already know that there is insufficient space.
        scUnknown = ClRtlGetUnknownProperties(
                            hkeyClusterKey,
                            pClusterRegApis,
                            pPropertyTable,
                            NULL,
                            0,
                            &cbUnknownReturned,
                            &cbUnknownRequired
                            );

        if ( ( scUnknown != ERROR_SUCCESS ) &&
             ( scUnknown != ERROR_MORE_DATA ) )
        {
            *pcbRequired = 0;
             return scUnknown;
        }

        //
        // If both known and unknown properties exist, only one endmark
        // is required. So, subtract endmark size from total required size.
        //
        if ( ( *pcbRequired > sizeof(DWORD) ) &&
             ( cbUnknownRequired > sizeof(DWORD) ) )
        {
             *pcbRequired -= sizeof(CLUSPROP_SYNTAX);
        }

        //
        // Subtract off the size of the property count for the
        // unknown property list.
        //
        *pcbRequired += cbUnknownRequired - sizeof(DWORD);
        return sc;
    } // if: call to ClRtlGetProperties failed

    // If we are here then the call to ClRtlGetProperties succeeded.

    //
    // Calculate the position in the output buffer where unknown properties
    // should be stored.  Subtract off the size of the property count for
    // the unknown property list.  These calculations will cause the buffer
    // pointer to overlap the known property list buffer by one DWORD.
    //
    cbhUnknownPropBuffer.pb = cbhKnownPropBuffer.pb + *pcbReturned - sizeof(DWORD);
    cbUnknownPropBufferSize = cbKnownPropBufferSize - *pcbReturned + sizeof(DWORD);

    // If there are known properties, move the unknown property list
    // buffer pointer to overlap that as well.
    if ( *pcbReturned > sizeof(DWORD) )
    {
        cbhUnknownPropBuffer.pb -= sizeof(CLUSPROP_SYNTAX);
        cbUnknownPropBufferSize += sizeof(CLUSPROP_SYNTAX);
    } // if: a nonzero number of properties has been returned.

    //
    // Save the DWORD we are about to overlap.
    //
    dwSavedData = *(cbhUnknownPropBuffer.pdw);

    scUnknown = ClRtlGetUnknownProperties(
                        hkeyClusterKey,
                        pClusterRegApis,
                        pPropertyTable,
                        cbhUnknownPropBuffer.pb,
                        cbUnknownPropBufferSize,
                        &cbUnknownReturned,
                        &cbUnknownRequired
                        );

    if ( scUnknown == ERROR_SUCCESS )
    {
        //
        // The order of the next three statements is very important
        // since the known and the unknown property buffers can overlap.
        //
        DWORD nUnknownPropCount = cbhUnknownPropBuffer.pList->nPropertyCount;
        *(cbhUnknownPropBuffer.pdw) = dwSavedData;
        cbhKnownPropBuffer.pList->nPropertyCount += nUnknownPropCount;

        //
        // If both known and unknown properties exist, only one endmark
        // is required. So, subtract endmark size from total returned size.
        //
        if ( ( *pcbReturned > sizeof(DWORD) ) &&
             ( cbUnknownReturned > sizeof(DWORD) ) )
        {
            *pcbReturned -= sizeof(CLUSPROP_SYNTAX);
        }

        //
        // Add in the size of the unknown property list minus the
        // size of the unknown property list property count.
        //
        *pcbReturned += cbUnknownReturned - sizeof(DWORD);
        *pcbRequired = 0;

    } // if: call to ClRtlGetUnknownProperties succeeded
    else
    {
        if ( scUnknown == ERROR_MORE_DATA )
        {
            *pcbRequired = *pcbReturned;
            *pcbReturned = 0;

            //
            // Both known and unknown properties exist. Only one endmark
            // is required. So, subtract endmark size from total required size.
            //
            if ( ( *pcbRequired > sizeof(DWORD) ) &&
                 ( cbUnknownRequired > sizeof(DWORD) ) )
            {
                 *pcbRequired -= sizeof(CLUSPROP_SYNTAX);
            }

            //
            // Add in the size of the unknown property list minus the
            // size of the unknown property list property count.
            //
            *pcbRequired += cbUnknownRequired - sizeof(DWORD);

        } // if: ClRtlGetUnknownProperties returned ERROR_MORE_DATA
        else
        {
            *pcbRequired = 0;
            *pcbReturned = 0;

        } // else: ClRtlGetUnknownProperties failed for some unknown reason.

    } // else: Call to ClRtlGetUnknownProperties failed.

    return scUnknown;

} //*** ClRtlGetAllProperties()


DWORD
WINAPI
ClRtlGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    )

/*++

Routine Description:

    Read properties based on the contents of the specified property table from
    the cluster database and place them into the specified parameter block.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the properties are stored.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutParams - Parameter block to read into.

    bCheckForRequiredProperties - Boolean value specifying whether missing
        required properties should cause an error.

    pszNameOfPropInError - String pointer in which to return the name of the
        property in error (optional).

Return Value:

    ERROR_SUCCESS - Properties read successfully.

    ERROR_INVALID_DATA - Required property not present.

    ERROR_INVALID_PARAMETER -

    A Win32 error code on failure.

--*/

{
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    HKEY                    key;
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   valueType;
    DWORD                   valueSize;
    LPWSTR                  pszInValue;
    LPBYTE                  pbInValue;
    DWORD                   dwInValue;
    LPWSTR *                ppszOutValue;
    LPBYTE *                ppbOutValue;
    LPDWORD                 pdwOutValue;
    LPLONG                  plOutValue;
    ULARGE_INTEGER *        pullOutValue;
    LARGE_INTEGER *         pllOutValue;
    CRegistryValueName      rvn;
    HRESULT                 hr;


    if ( pszNameOfPropInError != NULL )
    {
        *pszNameOfPropInError = NULL;
    }

    if ( (hkeyClusterKey == NULL) ||
         (pPropertyTable == NULL) ||
         (pOutParams == NULL) ||
         (pClusterRegApis == NULL) ||
         (pClusterRegApis->pfnOpenKey == NULL) ||
         (pClusterRegApis->pfnCloseKey == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) )
    {

        ClRtlDbgPrint( LOG_CRITICAL,
                       "ClRtlGetPropertiesToParameterBlock: hkeyClusterKey, pPropertyTable, "
                       "pOutParams, pClusterRegApis, or required pfns == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    while ( propertyItem->Name != NULL )
    {
        //
        // Use the wrapper class CRegistryValueName to parse value name to see if it
        // contains a backslash.
        //
        status = rvn.ScInit( propertyItem->Name, propertyItem->KeyName );
        if ( status != ERROR_SUCCESS )
        {
            break;
        } // if:

        //
        // If the value resides at a different location, open the key.
        //
        if ( rvn.PszKeyName() != NULL )
        {
            status = (*pClusterRegApis->pfnOpenKey)(
                            hkeyClusterKey,
                            rvn.PszKeyName(),
                            KEY_ALL_ACCESS,
                            (void **) &key
                            );

            // If key could not be opened, then we may need to put the default value
            // for the property item.
            if ( status != ERROR_SUCCESS )
            {
                status = ERROR_FILE_NOT_FOUND;
            }

        }
        else
        {
            key = hkeyClusterKey;
        }

        switch ( propertyItem->Format )
        {
            case CLUSPROP_FORMAT_DWORD:
                pdwOutValue = (LPDWORD) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(DWORD);

                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS )
                {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) pdwOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS )
                {
                    if ( valueType != REG_DWORD )
                    {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_DWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_DWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                }
                else if (   (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) )
                {
                    *pdwOutValue = propertyItem->Default;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_LONG:
                plOutValue = (LPLONG) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(LONG);
                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS )
                {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) plOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS )
                {
                    if ( valueType != REG_DWORD )
                    {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_DWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_DWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                }
                else if (   (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             !bCheckForRequiredProperties) )
                {
                    *plOutValue = propertyItem->Default;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                pullOutValue = (ULARGE_INTEGER *) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(ULARGE_INTEGER);

                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS )
                {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) pullOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS )
                {
                    if ( valueType != REG_QWORD )
                    {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_QWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_QWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                }
                else if (   (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) )
                {
                    pullOutValue->QuadPart = propertyItem->ULargeIntData->Default.QuadPart;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pllOutValue = (LARGE_INTEGER *) &pOutParams[propertyItem->Offset];
                valueSize = sizeof(LARGE_INTEGER);

                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS )
                {
                    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                                rvn.PszName(),
                                                                &valueType,
                                                                (LPBYTE) pllOutValue,
                                                                &valueSize );
                }

                if ( status == ERROR_SUCCESS )
                {
                    if ( valueType != REG_QWORD )
                    {

                        ClRtlDbgPrint( LOG_CRITICAL,
                                       "ClRtlGetPropertiesToParameterBlock: Property '%1!ls!' "
                                       "expected to be REG_QWORD (%2!d!), was %3!d!.\n",
                                       propertyItem->Name, REG_QWORD, valueType );
                        status = ERROR_INVALID_PARAMETER;
                    }
                }
                else if (   (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) )
                {
                    pllOutValue->QuadPart = propertyItem->LargeIntData->Default.QuadPart;
                    status = ERROR_SUCCESS;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszOutValue = (LPWSTR *) &pOutParams[propertyItem->Offset];
                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS )
                {
                    pszInValue = ClRtlGetSzValue( key,
                                                  rvn.PszName(),
                                                  pClusterRegApis );
                }
                else
                {
                    pszInValue = NULL;
                    SetLastError(status);
                }

                if ( pszInValue == NULL )
                {
                    status = GetLastError();
                    if ( (status == ERROR_FILE_NOT_FOUND) &&
                         (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                          ! bCheckForRequiredProperties) )
                    {

                        status = ERROR_SUCCESS;

                        // Deallocate old value.
                        if ( *ppszOutValue != NULL )
                        {
                            LocalFree( *ppszOutValue );
                            *ppszOutValue = NULL;
                        }

                        // If a default is specified, copy it.
                        if ( propertyItem->lpDefault != NULL )
                        {
                            size_t  cchTemp;

                            cchTemp = wcslen( (LPCWSTR) propertyItem->lpDefault ) + 1;
                            *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, cchTemp * sizeof(WCHAR) );
                            if ( *ppszOutValue == NULL )
                            {
                                status = GetLastError();
                            }
                            else
                            {
                                // We have no idea how big the buffer is.
                                hr = StringCchCopyW(
                                        *ppszOutValue,
                                        cchTemp,
                                        (LPCWSTR)propertyItem->lpDefault
                                        );
                                if ( FAILED( hr ) )
                                {
                                    status = HRESULT_CODE( hr );
                                    break;
                                }

                            } // else:
                        } // if:
                    } // if:
                }
                else
                {
                    if ( *ppszOutValue != NULL )
                    {
                        LocalFree( *ppszOutValue );
                    }
                    *ppszOutValue = pszInValue;
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppbOutValue = (LPBYTE *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (PDWORD) &pOutParams[propertyItem->Offset+sizeof(LPBYTE*)];
                // If OpenKey has succeeded.
                if ( status == ERROR_SUCCESS )
                {
                    status = ClRtlGetBinaryValue( key,
                                                  rvn.PszName(),
                                                  &pbInValue,
                                                  &dwInValue,
                                                  pClusterRegApis );
                }

                if ( status == ERROR_SUCCESS )
                {
                    if ( *ppbOutValue != NULL )
                    {
                        LocalFree( *ppbOutValue );
                    }
                    *ppbOutValue = pbInValue;
                    *pdwOutValue = dwInValue;
                }
                else if (   (status == ERROR_FILE_NOT_FOUND) &&
                            (!(propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED) ||
                             ! bCheckForRequiredProperties) )
                {

                    status = ERROR_SUCCESS;

                    // Deallocate old value.
                    if ( *ppbOutValue != NULL )
                    {
                        LocalFree( *ppbOutValue );
                        *ppbOutValue = NULL;
                    }

                    *pdwOutValue = 0;

                    // If a default is specified, copy it.
                    if ( propertyItem->lpDefault != NULL )
                    {
                        *ppbOutValue = (LPBYTE) LocalAlloc( LMEM_FIXED, propertyItem->Minimum );
                        if ( *ppbOutValue == NULL )
                        {
                            status = GetLastError();
                        }
                        else
                        {
                            CopyMemory( *ppbOutValue, (const PVOID) propertyItem->lpDefault, propertyItem->Minimum );
                            *pdwOutValue = propertyItem->Minimum;
                        }
                    }
                }
                break;
        }

        //
        // Close the key if we opened it.
        //
        if ( (rvn.PszKeyName() != NULL) &&
             (key != NULL) )
        {
            (*pClusterRegApis->pfnCloseKey)( key );
        }

        //
        // Handle any errors that occurred.
        //
        if ( status != ERROR_SUCCESS )
        {
            if ( pszNameOfPropInError != NULL )
            {
                *pszNameOfPropInError = propertyItem->Name;
            }
            if ( propertyItem->Flags & RESUTIL_PROPITEM_REQUIRED )
            {
                if ( status == ERROR_FILE_NOT_FOUND )
                {
                    status = ERROR_INVALID_DATA;
                }
                break;
            }
            else
            {
                status = ERROR_SUCCESS;
            }
        }

        //
        // Advance to the next property.
        //
        propertyItem++;
    } // while:

    return status;

} // ClRtlGetPropertiesToParameterBlock



DWORD
WINAPI
ClRtlPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Constructs a property list from a parameter block.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    pcbOutPropertyListSize - Supplies the size of the output buffer.

    pInParams - Supplies the input parameter block.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    ERROR_MORE_DATA - Output buffer isn't big enough to build the property list.

    A Win32 error code on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   nameSize;
    DWORD                   dataSize;
    DWORD                   bufferIncrement;
    DWORD                   totalBufferSize = 0;
    LPDWORD                 ptrItemCount;
    WORD                    propertyFormat;
    BOOL                    copying = TRUE;
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR *                ppszValue;
    PBYTE *                 ppbValue;
    PDWORD                  pdwValue;
    ULARGE_INTEGER *        pullValue;
    LPWSTR                  pszUnexpanded;
    LPWSTR                  pszExpanded = NULL;
    HRESULT                 hr;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (pPropertyTable == NULL) ||
         (pInParams == NULL) ||
         (pcbOutPropertyListSize == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlPropertyListFromParameterBlock: pPropertyTable, pInParams, or pcbOutPropertyListSize == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer.
    //
    if ( pOutPropertyList != NULL )
    {
        ZeroMemory( pOutPropertyList, *pcbOutPropertyListSize );
    }
    else
    {
        copying = FALSE;
    }

    //
    // Need a DWORD of item count.
    //
    props.pb = (LPBYTE) pOutPropertyList;
    ptrItemCount = props.pdw++;

    totalBufferSize += sizeof(DWORD);
    if ( totalBufferSize > *pcbOutPropertyListSize )
    {
        copying = FALSE;
    }

    while ( propertyItem->Name != NULL )
    {
        //
        // Copy the property name.
        //
        nameSize = ((DWORD) wcslen( propertyItem->Name ) + 1) * sizeof(WCHAR);
        bufferIncrement = sizeof(CLUSPROP_PROPERTY_NAME) + ALIGN_CLUSPROP( nameSize );
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
        {
            props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            props.pName->cbLength = nameSize;
            hr = StringCbCopyW( props.pName->sz, props.pName->cbLength, propertyItem->Name );
            if ( FAILED( hr ) )
            {
                status = HRESULT_CODE( hr );
                break;
            }
            props.pb += bufferIncrement;
        }
        else
        {
            copying = FALSE;
        }

        //
        // Copy the property value.
        //
        propertyFormat = (WORD) propertyItem->Format;
        switch ( propertyItem->Format )
        {

            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                pdwValue = (PDWORD) &pInParams[propertyItem->Offset];
                bufferIncrement = sizeof(CLUSPROP_DWORD);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pDwordValue->cbLength = sizeof(DWORD);
                    props.pDwordValue->dw = *pdwValue;
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pullValue = (ULARGE_INTEGER *) &pInParams[propertyItem->Offset];
                bufferIncrement = sizeof(CLUSPROP_ULARGE_INTEGER);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pULargeIntegerValue->cbLength = sizeof(ULARGE_INTEGER);
                    //
                    // props maybe mis-aligned for quadword. Use the two DWORD
                    // copy variant
                    //
                    props.pULargeIntegerValue->li.u = pullValue->u;
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszValue = (LPWSTR *) &pInParams[propertyItem->Offset];
                pszUnexpanded = *ppszValue;
                if ( *ppszValue != NULL )
                {
                    dataSize = ((DWORD) wcslen( *ppszValue ) + 1) * sizeof(WCHAR);
                }
                else
                {
                    dataSize = sizeof(WCHAR);
                }
                bufferIncrement = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( dataSize );
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pStringValue->cbLength = dataSize;
                    if ( *ppszValue != NULL )
                    {
                        hr = StringCbCopyW( props.pStringValue->sz, dataSize, *ppszValue );
                        if ( FAILED( hr ) )
                        {
                            status = HRESULT_CODE( hr );
                            break;
                        }
                    }
                    else
                    {
                        props.pStringValue->sz[0] = L'\0';
                    }
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }

                //
                // See if there is a different expanded string and, if so,
                // return it as an additional value in the value list.
                //
                if ( pszUnexpanded != NULL )
                {
                    pszExpanded = ClRtlExpandEnvironmentStrings( pszUnexpanded );
                    if ( pszExpanded == NULL )
                    {
                        status = GetLastError();
                        break;
                    }
                    if ( wcscmp( pszExpanded, pszUnexpanded ) != 0 )
                    {
                        dataSize = ((DWORD) wcslen( pszExpanded ) + 1) * sizeof( WCHAR );
                        bufferIncrement = sizeof( CLUSPROP_SZ ) + ALIGN_CLUSPROP( dataSize );
                        totalBufferSize += bufferIncrement;
                        if ( totalBufferSize <= *pcbOutPropertyListSize )
                        {
                            props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                            props.pStringValue->cbLength = dataSize;
                            hr = StringCbCopyW( props.pStringValue->sz, dataSize, pszExpanded );
                            if ( FAILED( hr ) )
                            {
                                status = HRESULT_CODE( hr );
                                break;
                            }
                            props.pb += bufferIncrement;
                        }
                        else
                        {
                            copying = FALSE;
                        }
                    }
                    LocalFree( pszExpanded );
                    pszExpanded = NULL;
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                ppszValue = (LPWSTR *) &pInParams[propertyItem->Offset];
                pdwValue = (PDWORD) &pInParams[propertyItem->Offset+sizeof(LPWSTR*)];
                if ( *ppszValue != NULL )
                {
                    bufferIncrement = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( *pdwValue );
                }
                else
                {
                    bufferIncrement = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( sizeof(WCHAR) );
                }
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    if ( *ppszValue != NULL )
                    {
                        props.pStringValue->cbLength = *pdwValue;
                        CopyMemory( props.pStringValue->sz, *ppszValue, *pdwValue );
                    }
                    else
                    {
                        props.pStringValue->cbLength = sizeof(WCHAR);
                        props.pStringValue->sz[0] = L'\0';
                    }
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            case CLUSPROP_FORMAT_BINARY:
                ppbValue = (PBYTE *) &pInParams[propertyItem->Offset];
                pdwValue = (PDWORD) &pInParams[propertyItem->Offset+sizeof(PBYTE*)];
                if ( *ppbValue != NULL )
                {
                    bufferIncrement = sizeof(CLUSPROP_BINARY) + ALIGN_CLUSPROP( *pdwValue );
                }
                else
                {
                    bufferIncrement = sizeof(CLUSPROP_BINARY);
                }
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = propertyFormat;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    if ( *ppbValue != NULL )
                    {
                        props.pBinaryValue->cbLength = *pdwValue;
                        CopyMemory( props.pBinaryValue->rgb, *ppbValue, *pdwValue );
                    }
                    else
                    {
                        props.pBinaryValue->cbLength = 0;
                    }
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            default:
                break;
        }

        if ( status != ERROR_SUCCESS )
        {
            break;
        }

        //
        // Add the value-closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
        {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
            (*ptrItemCount)++;
        }
        else
        {
            copying = FALSE;
        }

        //
        // Advance to the next property.
        //
        propertyItem++;
    } // while:

    if ( status == ERROR_SUCCESS )
    {
        // Don't forget the ENDMARK.
        totalBufferSize += sizeof(CLUSPROP_SYNTAX);
        if ( copying && (totalBufferSize <= *pcbOutPropertyListSize) )
        {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
        }
        else
        {
            copying = FALSE;
        }

        //
        // Return size of data.
        //
        if ( copying == FALSE )
        {
            *pcbRequired = totalBufferSize;
            *pcbBytesReturned = 0;
            status = ERROR_MORE_DATA;
        }
        else
        {
            *pcbRequired = 0;
            *pcbBytesReturned = totalBufferSize;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // ClRtlPropertyListFromParameterBlock



DWORD
WINAPI
ClRtlGetPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Read the private properties for a given object from the cluster database
    and build a property list.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    ERROR_MORE_DATA - Output buffer isn't big enough to build the property list.

    A Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       ival;
    DWORD       currentNameLength = 80;
    DWORD       currentDataLength = 80;
    DWORD       nameLength;
    DWORD       dataLength;
    DWORD       dataLengthExpanded;
    DWORD       type;
    LPWSTR      name;
    PUCHAR      data;
    LPDWORD     ptrItemCount;
    DWORD       itemCount = 0;
    BOOL        copying = TRUE;
    DWORD       totalBufferSize = 0;
    DWORD       bufferIncrement;
    DWORD       bufferIncrementExpanded;
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR      pszExpanded = NULL;
    HRESULT     hr;


    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnEnumValue == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPrivateProperties: hkeyClusterKey or pClusterRegApis->pfnEnumValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pOutPropertyList != NULL )
    {
        ZeroMemory( pOutPropertyList, cbOutPropertyListSize );
    }
    else
    {
        copying = FALSE;
    }

    //
    // Need a DWORD of item count.
    //
    props.pb = (LPBYTE) pOutPropertyList;
    ptrItemCount = props.pdw++;

    totalBufferSize += sizeof(DWORD);
    if ( totalBufferSize > cbOutPropertyListSize )
    {
        copying = FALSE;
    }

    //
    // Allocate a property name buffer.
    //
    name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
    if ( name == NULL )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Allocate a property value data buffer.
    //
    data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
    if ( data == NULL )
    {
        LocalFree( name );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate all properties and return them!
    //
    for ( ival = 0; ; ival++ )
    {
retry:
        //
        // Read the next property.
        //
        nameLength = currentNameLength;
        dataLength = currentDataLength;
        status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                   ival,
                                                   name,
                                                   &nameLength,
                                                   &type,
                                                   data,
                                                   &dataLength );

        if ( status == ERROR_MORE_DATA )
        {
            if ( (nameLength+1) > currentNameLength )
            {
                currentNameLength = nameLength+1;
                LocalFree( name );
                name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
                if ( name == NULL )
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            if ( dataLength > currentDataLength )
            {
                currentDataLength = dataLength;
                LocalFree( data );
                data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
                if ( data == NULL )
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            goto retry;
        }
        else if ( status == ERROR_NO_MORE_ITEMS )
        {
            status = ERROR_SUCCESS;
            break;
        }
        else if ( status != ERROR_SUCCESS )
        {
            break;
        }

        //
        // Skip this property if it isn't of a known type.
        //
        if ( (type != REG_SZ) &&
             (type != REG_EXPAND_SZ) &&
             (type != REG_MULTI_SZ) &&
             (type != REG_BINARY) &&
             (type != REG_DWORD) &&
             (type != REG_QWORD) )
        {
            continue;
        }

        itemCount++;

        //
        // Copy the property name.
        // Need a DWORD for the next name Syntax + DWORD for name byte count +
        // the namelength (in bytes? + NULL?)... must be rounded!
        //
        bufferIncrement = sizeof(CLUSPROP_PROPERTY_NAME)
                            + ALIGN_CLUSPROP( (nameLength + 1) * sizeof(WCHAR) );
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
        {
            props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            props.pName->cbLength = (nameLength + 1) * sizeof(WCHAR);
            hr = StringCbCopyW( props.pName->sz, props.pName->cbLength, name );
            if ( FAILED( hr ) )
            {
                status = HRESULT_CODE( hr );
                break;
            }
            props.pb += bufferIncrement;
        }
        else
        {
            copying = FALSE;
        }

        switch ( type )
        {

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
            case REG_BINARY:
                bufferIncrement = sizeof(CLUSPROP_BINARY)
                                    + ALIGN_CLUSPROP( dataLength );
                totalBufferSize += bufferIncrement;
                if ( ( type == REG_SZ )
                  || ( type == REG_EXPAND_SZ ) )
                {
                    pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR) data );
                    if ( pszExpanded == NULL )
                    {
                        status = GetLastError();
                        break;
                    }
                    if ( wcsncmp( pszExpanded, (LPCWSTR) data, dataLength / sizeof( WCHAR ) ) != 0 )
                    {
                        dataLengthExpanded = ((DWORD) wcslen( pszExpanded ) + 1) * sizeof( WCHAR );
                        bufferIncrementExpanded = sizeof( CLUSPROP_SZ ) + ALIGN_CLUSPROP( dataLengthExpanded );
                        totalBufferSize += bufferIncrementExpanded;
                    }
                }
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
                {
                    if ( type == REG_SZ )
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_SZ;
                    }
                    else if ( type == REG_EXPAND_SZ )
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
                    }
                    else if ( type == REG_MULTI_SZ )
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_MULTI_SZ;
                    }
                    else
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_BINARY;
                    }
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pBinaryValue->cbLength = dataLength;
                    CopyMemory( props.pBinaryValue->rgb, data, dataLength );
                    props.pb += bufferIncrement;

                    //
                    // For SZ or EXPAND_SZ, see if there is a different
                    // expanded string and, if so, return it as an additional
                    // value in the value list.
                    //
                    if (    ( type == REG_SZ )
                        ||  ( type == REG_EXPAND_SZ ) )
                    {
                        if ( wcsncmp( pszExpanded, (LPCWSTR) data, dataLength / sizeof( WCHAR ) ) != 0 )
                        {
                            props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                            props.pStringValue->cbLength = dataLengthExpanded;
                            hr = StringCbCopyW( props.pStringValue->sz, props.pStringValue->cbLength, pszExpanded );
                            if ( FAILED( hr ) )
                            {
                                status = HRESULT_CODE( hr );
                                break;
                            }
                            props.pb += bufferIncrementExpanded;
                        }
                    }
                }
                else
                {
                    copying = FALSE;
                }
                if ( ( ( type == REG_SZ ) || ( type == REG_EXPAND_SZ ) )
                  && ( pszExpanded != NULL ) )
                {
                    LocalFree( pszExpanded );
                    pszExpanded = NULL;
                }
                break;

            case REG_DWORD:
                bufferIncrement = sizeof(CLUSPROP_DWORD);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_DWORD;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pDwordValue->cbLength = sizeof(DWORD);
                    props.pDwordValue->dw = *(LPDWORD)data;
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            case REG_QWORD:
                bufferIncrement = sizeof(CLUSPROP_ULARGE_INTEGER);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pULargeIntegerValue->cbLength = sizeof(ULARGE_INTEGER);
                    //
                    // data (the local var) is aligned since it was
                    // LocalAlloc'ed but props might not be. Use the two DWORD
                    // copy variant.
                    //
                    props.pULargeIntegerValue->li.u = ((ULARGE_INTEGER *)data)->u;
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            default:
                break;
        } // switch:

        if ( status != ERROR_SUCCESS )
        {
            break;
        }

        //
        // Add the closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
        {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
        }
        else
        {
            copying = FALSE;
        }

    } // for:

    if ( status == ERROR_SUCCESS )
    {
        //
        // Add the closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
        {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
        }
        else
        {
            copying = FALSE;
        }
    }

    LocalFree( name );
    LocalFree( data );

    if ( status == ERROR_SUCCESS )
    {
        if ( !copying )
        {
            *pcbRequired = totalBufferSize;
            status = ERROR_MORE_DATA;
        }
        else
        {
            *ptrItemCount = itemCount;
            *pcbBytesReturned = totalBufferSize;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // ClRtlGetPrivateProperties



DWORD
WINAPI
ClRtlGetUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Read the unknown properties for a given object from the cluster database
    and build a property list; unknown is defined to be anything not in the
    specified property table.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    ERROR_MORE_DATA - Output buffer isn't big enough to build the property list.

    A Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       ival;
    DWORD       currentNameLength = 80;
    DWORD       currentDataLength = 80;
    DWORD       nameLength;
    DWORD       dataLength;
    DWORD       dataLengthExpanded;
    DWORD       type;
    LPWSTR      name;
    PUCHAR      data;
    LPDWORD     ptrItemCount;
    DWORD       itemCount = 0;
    BOOL        copying = TRUE;
    DWORD       totalBufferSize = 0;
    DWORD       bufferIncrement;
    DWORD       bufferIncrementExpanded;
    CLUSPROP_BUFFER_HELPER  props;
    PRESUTIL_PROPERTY_ITEM  property;
    BOOL        found;
    LPWSTR      pszExpanded = NULL;
    HRESULT     hr;


    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnEnumValue == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPrivateProperties: hkeyClusterKey or pClusterRegApis->pfnEnumValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Clear the output buffer
    //
    if ( pOutPropertyList != NULL )
    {
        ZeroMemory( pOutPropertyList, cbOutPropertyListSize );
    }
    else
    {
        copying = FALSE;
    }

    //
    // Need a DWORD of item count.
    //
    props.pb = (LPBYTE) pOutPropertyList;
    ptrItemCount = props.pdw++;

    totalBufferSize += sizeof(DWORD);
    if ( totalBufferSize > cbOutPropertyListSize )
    {
        copying = FALSE;
    }

    //
    // Allocate a property name buffer.
    //
    name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
    if ( name == NULL )
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Allocate a property value data buffer.
    //
    data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
    if ( data == NULL )
    {
        LocalFree( name );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate all properties and return them!
    //
    for ( ival = 0; ; ival++ )
    {
retry:
        //
        // Read the next property.
        //
        nameLength = currentNameLength;
        dataLength = currentDataLength;
        status = (*pClusterRegApis->pfnEnumValue)( hkeyClusterKey,
                                                   ival,
                                                   name,
                                                   &nameLength,
                                                   &type,
                                                   data,
                                                   &dataLength );

        if ( status == ERROR_MORE_DATA )
        {
            if ( (nameLength+1) > currentNameLength )
            {
                currentNameLength = nameLength+1;
                LocalFree( name );
                name = (LPWSTR) LocalAlloc( LMEM_FIXED, currentNameLength * sizeof(WCHAR) );
                if ( name == NULL )
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            if ( dataLength > currentDataLength )
            {
                currentDataLength = dataLength;
                LocalFree( data );
                data = (PUCHAR) LocalAlloc( LMEM_FIXED, currentDataLength );
                if ( data == NULL )
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            goto retry;
        }
        else if ( status == ERROR_NO_MORE_ITEMS )
        {
            status = ERROR_SUCCESS;
            break;
        }
            else if ( status != ERROR_SUCCESS )
        {
            break;
        }

        //
        // Skip this property if it isn't of a known type.
        //
        if ( (type != REG_SZ) &&
             (type != REG_EXPAND_SZ) &&
             (type != REG_MULTI_SZ) &&
             (type != REG_BINARY) &&
             (type != REG_DWORD) &&
             (type != REG_QWORD) )
        {
            continue;
        }

        //
        // Check if this property item is 'known'. If so, continue.
        //
        found = FALSE;
        property = pPropertyTable;
        while ( property->Name != NULL )
        {
            if ( lstrcmpiW( property->Name, name ) == 0 )
            {
                found = TRUE;
                break;
            }
            property++;
        }
        if ( found )
        {
            continue;
        }

        itemCount++;

        //
        // Copy the property name.
        // Need a DWORD for the next name Syntax + DWORD for name byte count +
        // the namelength (in bytes? + NULL?)... must be rounded!
        //
        bufferIncrement = sizeof(CLUSPROP_PROPERTY_NAME)
                            + ALIGN_CLUSPROP( (nameLength + 1) * sizeof(WCHAR) );
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
        {
            props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
            props.pName->cbLength = (nameLength + 1) * sizeof(WCHAR);
            hr = StringCbCopyW( props.pName->sz, props.pName->cbLength, name );
            if ( FAILED( hr ) )
            {
                status = HRESULT_CODE( hr );
                break;
            }
            props.pb += bufferIncrement;
        }
        else
        {
            copying = FALSE;
        }

        switch ( type )
        {

            case REG_SZ:
            case REG_EXPAND_SZ:
            case REG_MULTI_SZ:
            case REG_BINARY:
                bufferIncrement = sizeof(CLUSPROP_BINARY)
                                    + ALIGN_CLUSPROP( dataLength );
                totalBufferSize += bufferIncrement;
                if ( type == REG_EXPAND_SZ )
                {
                    pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR) data );
                    if ( pszExpanded == NULL )
                    {
                        status = GetLastError();
                        break;
                    }
                    if ( wcsncmp( pszExpanded, (LPCWSTR) data, dataLength ) != 0 )
                    {
                        dataLengthExpanded = ((DWORD) wcslen( pszExpanded ) + 1) * sizeof( WCHAR );
                        bufferIncrementExpanded = sizeof( CLUSPROP_SZ ) + ALIGN_CLUSPROP( dataLengthExpanded );
                        totalBufferSize += bufferIncrementExpanded;
                    }
                }
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
                {
                    if ( type == REG_SZ )
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_SZ;
                    }
                    else if ( type == REG_EXPAND_SZ )
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
                    }
                    else if ( type == REG_MULTI_SZ )
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_MULTI_SZ;
                    }
                    else
                    {
                        props.pSyntax->wFormat = CLUSPROP_FORMAT_BINARY;
                    }
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pBinaryValue->cbLength = dataLength;
                    CopyMemory( props.pBinaryValue->rgb, data, dataLength );
                    props.pb += bufferIncrement;

                    //
                    // For SZ or EXPAND_SZ, see if there is a different
                    // expanded string and, if so, return it as an additional
                    // value in the value list.
                    //
                    if (    ( type == REG_SZ )
                        ||  ( type == REG_EXPAND_SZ ) )
                    {
                        if ( pszExpanded != NULL )
                        {
                            if ( wcsncmp( pszExpanded, (LPCWSTR) data, dataLength ) != 0 )
                            {
                                props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                                props.pStringValue->cbLength = dataLengthExpanded;
                                hr = StringCbCopyW( props.pStringValue->sz, props.pStringValue->cbLength, pszExpanded );
                                if ( FAILED( hr ) )
                                {
                                    status = HRESULT_CODE( hr );
                                    break;
                                }
                                props.pb += bufferIncrementExpanded;
                            }
                        }
                    }
                }
                else
                {
                    copying = FALSE;
                }
                if ( type == REG_EXPAND_SZ )
                {
                    LocalFree( pszExpanded );
                    pszExpanded = NULL;
                }
                break;

            case REG_DWORD:
                bufferIncrement = sizeof(CLUSPROP_DWORD);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_DWORD;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pDwordValue->cbLength = sizeof(DWORD);
                    props.pDwordValue->dw = *(LPDWORD)data;
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            case REG_QWORD:
                bufferIncrement = sizeof(CLUSPROP_ULARGE_INTEGER);
                totalBufferSize += bufferIncrement;
                if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
                {
                    props.pSyntax->wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
                    props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;
                    props.pULargeIntegerValue->cbLength = sizeof(ULARGE_INTEGER);
                    //
                    // data (the local var) is aligned since it was
                    // LocalAlloc'ed but props might not be. Use the two DWORD
                    // copy variant.
                    //
                    props.pULargeIntegerValue->li.u = ((ULARGE_INTEGER *)data)->u;
                    props.pb += bufferIncrement;
                }
                else
                {
                    copying = FALSE;
                }
                break;

            default:
                break;
        }

        //
        // Add the closing endmark.
        //
        bufferIncrement = sizeof(CLUSPROP_SYNTAX);
        totalBufferSize += bufferIncrement;
        if ( copying && (totalBufferSize <= cbOutPropertyListSize) )
        {
            props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            props.pb += bufferIncrement;
        }
        else
        {
            copying = FALSE;
        }

    }

    LocalFree( name );
    LocalFree( data );

    if ( !copying )
    {
        *pcbRequired = totalBufferSize;
        status = ERROR_MORE_DATA;
    }
    else
    {
        *ptrItemCount = itemCount;
        *pcbBytesReturned = totalBufferSize;
        status = ERROR_SUCCESS;
    }

    return(status);

} // ClRtlGetUnknownProperties



DWORD
WINAPI
ClRtlAddUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Adds the unknown properties for a given object to the end of the specified
    property list. Unknown is defined to be any registry values in the cluster
    key that are not named in the property table.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - On input, contains the number of bytes in use in the
        output buffer.  On output, contains the total number of bytes in
        pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    CLUSPROP_BUFFER_HELPER  copyBuffer;
    CLUSPROP_BUFFER_HELPER  outBuffer;
    DWORD                   bufferLength;
    DWORD                   bytesReturned;
    DWORD                   required;

    //
    // Allocate a buffer for getting 'unknown' properties.
    //
    if ( (cbOutPropertyListSize > *pcbBytesReturned) &&
         (*pcbRequired == 0) )
    {
        bufferLength = cbOutPropertyListSize + (2 * sizeof(DWORD)) - *pcbBytesReturned;
        outBuffer.pb = (LPBYTE) LocalAlloc( LMEM_FIXED, bufferLength );
        if ( outBuffer.pb == NULL )
        {
            *pcbBytesReturned = 0;
            *pcbRequired = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else
    {
        bufferLength = 0;
        outBuffer.pb = NULL;
    }

    //
    // Get the 'unknown' properties.
    //
    status = ClRtlGetUnknownProperties( hkeyClusterKey,
                                        pClusterRegApis,
                                        pPropertyTable,
                                        outBuffer.pb,
                                        bufferLength,
                                        &bytesReturned,
                                        &required );
    if ( status == ERROR_SUCCESS )
    {
        //
        // Copy properties if any were found.
        //
        if ( bytesReturned > sizeof(DWORD) )
        {
            //
            // Copy the unknown property data to the end of the property list.
            //
            CL_ASSERT( bytesReturned <= bufferLength );
            copyBuffer.pb = (LPBYTE) pOutPropertyList;
            copyBuffer.pList->nPropertyCount += outBuffer.pList->nPropertyCount;
            copyBuffer.pb += *pcbBytesReturned - sizeof(CLUSPROP_SYNTAX);
            CopyMemory( copyBuffer.pb, outBuffer.pb + sizeof(DWORD), bytesReturned - sizeof(DWORD) );
            *pcbBytesReturned += bytesReturned - sizeof(DWORD) - sizeof(CLUSPROP_SYNTAX);
        }
    }
    else if ( ( status == ERROR_MORE_DATA ) && ( required == sizeof(DWORD) ) )
    {
        required = 0;
        status = ERROR_SUCCESS;
    }
    else
    {
        if ( *pcbRequired == 0 )
        {
            *pcbRequired = *pcbBytesReturned;
        }
        *pcbBytesReturned = 0;
    }

    //
    // If there are any properties, the number of bytes required will include
    // both a property count (DWORD) and an endmark (CLUSPROP_SYNTAX).
    // Subtract these off because these appear in both lists.
    //
    if ( required > sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX) )
    {
        required -= sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
    }

    //
    // Free the out buffer (which may be NULL)
    //
    LocalFree( outBuffer.pb );

    //
    // Adjust lengths
    //
    *pcbRequired += required;

    return(status);

} // ClRtlAddUnknownProperties



DWORD
WINAPI
ClRtlGetPropertySize(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    )

/*++

Routine Description:

    Get the total number of bytes required for the property identified by
    pPropertyTableItem.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.


    pPropertyTableItem - Supplies the property table item for the property
        whose size is to be returned.

    pcbOutPropertyListSize - Supplies the size of the output buffer
        required to add this property to a property list.

    pnPropertyCount - The count of properties is incremented.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_INVALID_PARAMETER -

    A Win32 error code on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   valueType;
    DWORD   bytesReturned;
    DWORD   headerLength;
    PVOID   key;
    LPWSTR  pszValue = NULL;
    LPWSTR  pszExpanded = NULL;
    CRegistryValueName rvn;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPropertySize: hkeyClusterKey or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Use the wrapper class CRegistryValueName to parse value name to see if it
    // contains a backslash.
    //
    status = rvn.ScInit( pPropertyTableItem->Name, pPropertyTableItem->KeyName );
    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL )
    {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPropertySize: pClusterRegApis->pfnOpenValue or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
            return(ERROR_BAD_ARGUMENTS);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);

    }
    else
    {
        key = hkeyClusterKey;
    }

    //
    // Read the value size.
    //
    if ( status == ERROR_SUCCESS )
    {
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    NULL,
                                                    &bytesReturned );
    }

    //
    // If the value is not present, return the default value.
    //
    if ( status == ERROR_FILE_NOT_FOUND )
    {

        switch ( pPropertyTableItem->Format )
        {

            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(DWORD);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(ULARGE_INTEGER);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 )
                {
                    bytesReturned = pPropertyTableItem->Minimum;
                }
                else
                {
                    bytesReturned = sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 )
                {
                    bytesReturned = ((DWORD) wcslen((LPCWSTR)pPropertyTableItem->lpDefault) + 1) * sizeof(WCHAR);
                    pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR)pPropertyTableItem->lpDefault );
                    if ( pszExpanded == NULL )
                    {
                        status = GetLastError();
                    }
                    else if ( wcscmp( (LPCWSTR)pPropertyTableItem->lpDefault, pszExpanded ) != 0 )
                    {
                        bytesReturned += ALIGN_CLUSPROP( ((DWORD) wcslen( pszExpanded ) + 1) * sizeof( WCHAR ) );
                        bytesReturned += sizeof(CLUSPROP_SZ);
                    }
                    LocalFree( pszExpanded );
                }
                else
                {
                    bytesReturned = ((DWORD) wcslen(CLRTL_NULL_STRING) + 1) * sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_BINARY:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 )
                {
                    bytesReturned = pPropertyTableItem->Minimum;
                }
                else
                {
                    bytesReturned = 0;
                }
                valueType = pPropertyTableItem->Format;
                break;

            default:
                valueType = CLUSPROP_FORMAT_UNKNOWN;
                break;
        }
    }
    else if ( status == ERROR_SUCCESS )
    {
        switch ( valueType )
        {
            case REG_DWORD:
                if ((pPropertyTableItem->Format == CLUSPROP_FORMAT_DWORD) ||
                    (pPropertyTableItem->Format == CLUSPROP_FORMAT_LONG))
                {
                    valueType = pPropertyTableItem->Format;
                }
                else
                {
                    valueType = CLUSPROP_FORMAT_UNKNOWN;
                }
                break;

            case REG_QWORD:
                if ((pPropertyTableItem->Format == CLUSPROP_FORMAT_ULARGE_INTEGER) ||
                    (pPropertyTableItem->Format == CLUSPROP_FORMAT_LARGE_INTEGER))
                {
                    valueType = pPropertyTableItem->Format;
                }
                else
                {
                    valueType = CLUSPROP_FORMAT_UNKNOWN;
                }
                break;

            case REG_MULTI_SZ:
                valueType = CLUSPROP_FORMAT_MULTI_SZ;
                break;

            case REG_SZ:
            case REG_EXPAND_SZ:
                //
                // Include the size of the expanded string in both REG_SZ and REG_EXPAND_SZ
                //
                pszValue = ClRtlGetSzValue( (HKEY) key,
                                            rvn.PszName(),
                                            pClusterRegApis );
                if ( pszValue != NULL )
                {
                    pszExpanded = ClRtlExpandEnvironmentStrings( pszValue );
                    if ( pszExpanded == NULL )
                    {
                        status = GetLastError();
                    }
                    else if ( wcscmp( pszValue, pszExpanded ) != 0 )
                    {
                        bytesReturned += ALIGN_CLUSPROP( ((DWORD) wcslen( pszExpanded ) + 1) * sizeof( WCHAR ) );
                        bytesReturned += sizeof(CLUSPROP_SZ);
                    }
                    LocalFree( pszValue );
                    LocalFree( pszExpanded );
                }

                if ( valueType == REG_SZ )
                {
                    valueType = CLUSPROP_FORMAT_SZ;
                }
                else
                {
                    valueType = CLUSPROP_FORMAT_EXPAND_SZ;
                }
                break;

            case REG_BINARY:
                valueType = CLUSPROP_FORMAT_BINARY;
                break;

            default:
                valueType = CLUSPROP_FORMAT_UNKNOWN;
                break;
        }
    }

    if ( status == ERROR_FILE_NOT_FOUND )
    {
        status = ERROR_SUCCESS;
    }
    else if ( status == ERROR_SUCCESS )
    {
        if ( pPropertyTableItem->Format != valueType )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetPropertySize: Property '%1!ls!' format %2!d! expected, was %3!d!.\n", rvn.PszKeyName(), pPropertyTableItem->Format, valueType );
            status = ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // calculate the size of the "header" which consists of a property
            // name structure, the length of the property name, the size of
            // the property value structure minus the size of the storage area
            // (property specific) and the syntax endmark.
            //

            //assume that the size of dword and long
            //is fixed to 32 bits
            if (( valueType == CLUSPROP_FORMAT_DWORD ) ||
                ( valueType == CLUSPROP_FORMAT_LONG ))
            {
                headerLength = sizeof(CLUSPROP_PROPERTY_NAME)
                                + (((DWORD) wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                                + sizeof(CLUSPROP_DWORD)
                                - 4   // CLUSPROP_DWORD.dw (specified by bytesReturned)
                                + sizeof(CLUSPROP_SYNTAX); // for endmark
            }
            else if (( valueType == CLUSPROP_FORMAT_ULARGE_INTEGER ) ||
                     ( valueType == CLUSPROP_FORMAT_LARGE_INTEGER ))
            {
                headerLength = sizeof(CLUSPROP_PROPERTY_NAME)
                                + (((DWORD) wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                                + sizeof(CLUSPROP_ULARGE_INTEGER)
                                - 8   // CLUSPROP_ULARGE_INTEGER.li (specified by bytesReturned)
                                + sizeof(CLUSPROP_SYNTAX); // for endmark
            }
            else
            {
                // NOTE: This assumes SZ, EXPAND_SZ, MULTI_SZ, and BINARY are the same size
                headerLength = sizeof(CLUSPROP_PROPERTY_NAME)
                                + (((DWORD) wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                                + sizeof(CLUSPROP_BINARY)
                                + sizeof(CLUSPROP_SYNTAX); // for endmark
            }

            headerLength = ALIGN_CLUSPROP( headerLength );
            bytesReturned = ALIGN_CLUSPROP( bytesReturned );
            *pcbOutPropertyListSize += (bytesReturned + headerLength);
            *pnPropertyCount += 1;
        }
    }

    //
    // Close the key if we opened it.
    //
    if ( ( rvn.PszKeyName() != NULL ) &&
         ( key != NULL ) )
    {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(status);

} // ClRtlGetPropertySize



DWORD
WINAPI
ClRtlGetProperty(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    )

/*++

Routine Description:

    build a property list entry for the property specified by the property
    table item.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTableItem - Pointer to the property item to process.

    pOutPropertyItem - Supplies the output buffer.

    pcbOutPropertyItemSize - Pointer that receives the number of bytes written to the
        output buffer

Return Value:

    ERROR_SUCCESS -

    ERROR_BAD_ARGUMENTS -

    ERROR_MORE_DATA -

Notes:

    The buffer size has already been determined to be large enough to hold
    the return data.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   valueType;
    DWORD   bytesReturned;
    DWORD   bufferSize;
    PVOID   dataBuffer;
    DWORD   nameLength;
    PVOID   key = NULL;
    CLUSTER_PROPERTY_FORMAT format;
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR  pszExpanded = NULL;
    CRegistryValueName rvn;
    HRESULT hr;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetProperty: hkeyClusterKey or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Use the wrapper class CRegistryValueName to parse value name to see if it
    // contains a backslash.
    //
    status = rvn.ScInit( pPropertyTableItem->Name, pPropertyTableItem->KeyName );
    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL )
    {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetProperty: pClusterRegApis->pfnOpenValue or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
            return(ERROR_BAD_ARGUMENTS);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);
    }
    else
    {
        key = hkeyClusterKey;
    }

    //
    // Find out if this property is available
    //
    if ( status == ERROR_SUCCESS )
    {
        status = (*pClusterRegApis->pfnQueryValue)( key,
                                                    rvn.PszName(),
                                                    &valueType,
                                                    NULL,
                                                    &bytesReturned );
    }

    //
    // If the value is not present, return the default value.
    //
    if ( status == ERROR_FILE_NOT_FOUND )
    {
        switch ( pPropertyTableItem->Format )
        {

            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(DWORD);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                status = ERROR_SUCCESS;
                bytesReturned = sizeof(ULARGE_INTEGER);
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 )
                {
                    bytesReturned = pPropertyTableItem->Minimum;
                }
                else
                {
                    bytesReturned = sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 )
                {
                    bytesReturned = ((DWORD) wcslen((LPCWSTR)pPropertyTableItem->lpDefault) + 1) * sizeof(WCHAR);
                }
                else
                {
                    bytesReturned = ((DWORD) wcslen(CLRTL_NULL_STRING) + 1) * sizeof(WCHAR);
                }
                valueType = pPropertyTableItem->Format;
                break;

            case CLUSPROP_FORMAT_BINARY:
                status = ERROR_SUCCESS;
                if ( pPropertyTableItem->Default != 0 )
                {
                    bytesReturned = pPropertyTableItem->Minimum;
                }
                else
                {
                    bytesReturned = 0;
                }
                valueType = pPropertyTableItem->Format;
                break;

            default:
                valueType = CLUSPROP_FORMAT_UNKNOWN;
                break;
        }
    }

    if ( status == ERROR_SUCCESS )
    {
        //
        // Get the property format
        //
        switch ( pPropertyTableItem->Format )
        {
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                format = (enum CLUSTER_PROPERTY_FORMAT) pPropertyTableItem->Format;
                break;

            default:
                format = CLUSPROP_FORMAT_UNKNOWN;
                break;

        }

        props.pb = (LPBYTE) *pOutPropertyItem;

        //
        // Copy the property name, which includes its syntax and length.
        //
        nameLength = ((DWORD) wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR);
        props.pSyntax->dw = CLUSPROP_SYNTAX_NAME;
        props.pName->cbLength = nameLength;
        hr = StringCbCopyW( props.pName->sz, props.pName->cbLength, pPropertyTableItem->Name );
        if ( FAILED( hr ) )
        {
            status = HRESULT_CODE( hr );
            goto Cleanup;
        }

        bytesReturned = sizeof(*props.pName) + ALIGN_CLUSPROP( nameLength );
        *pcbOutPropertyItemSize -= bytesReturned;
        props.pb += bytesReturned;

        //
        // Copy the property value header.
        //
        props.pSyntax->wFormat = (USHORT)format;
        props.pSyntax->wType = CLUSPROP_TYPE_LIST_VALUE;

        //
        // Read the property value.
        //
        if ( pPropertyTableItem->Format == CLUSPROP_FORMAT_DWORD ||
             pPropertyTableItem->Format == CLUSPROP_FORMAT_LONG )
        {
            bufferSize = *pcbOutPropertyItemSize
                        - (sizeof(*props.pDwordValue) - sizeof(props.pDwordValue->dw));
            dataBuffer = &props.pDwordValue->dw;
        }
        else if ( pPropertyTableItem->Format == CLUSPROP_FORMAT_ULARGE_INTEGER ||
                  pPropertyTableItem->Format == CLUSPROP_FORMAT_ULARGE_INTEGER )
        {
            bufferSize = *pcbOutPropertyItemSize
                        - (sizeof(*props.pULargeIntegerValue) - sizeof(props.pULargeIntegerValue->li));
            dataBuffer = &props.pULargeIntegerValue->li;
        }
        else
        {
            // NOTE: This assumes that CLUSPROP_SZ, CLUSPROP_MULTI_SZ, and
            // CLUSPROP_BINARY are all the same size
            bufferSize = *pcbOutPropertyItemSize - sizeof(*props.pBinaryValue);
            dataBuffer = props.pBinaryValue->rgb;
        }
        bytesReturned = bufferSize;
        if ( key == NULL )
        {
            status = ERROR_FILE_NOT_FOUND;
        }
        else
        {
            status = (*pClusterRegApis->pfnQueryValue)( key,
                                                        rvn.PszName(),
                                                        &valueType,
                                                        (LPBYTE) dataBuffer,
                                                        &bytesReturned );
        }

        //
        // If the value is not present, return the default value.
        //
        if ( status == ERROR_FILE_NOT_FOUND )
        {
            switch ( pPropertyTableItem->Format )
            {

                case CLUSPROP_FORMAT_DWORD:
                case CLUSPROP_FORMAT_LONG:
                    //assume size of dword and long is the same
                    status = ERROR_SUCCESS;
                    bytesReturned = sizeof(DWORD);
                    props.pDwordValue->dw = pPropertyTableItem->Default;
                    break;

                case CLUSPROP_FORMAT_ULARGE_INTEGER:
                case CLUSPROP_FORMAT_LARGE_INTEGER:
                    status = ERROR_SUCCESS;
                    bytesReturned = sizeof(ULARGE_INTEGER);
                    props.pULargeIntegerValue->li.u = pPropertyTableItem->ULargeIntData->Default.u;
                    break;

                case CLUSPROP_FORMAT_MULTI_SZ:
                    status = ERROR_SUCCESS;
                    if ( pPropertyTableItem->Default != 0 )
                    {
                        bytesReturned = pPropertyTableItem->Minimum;
                        if ( bufferSize >= bytesReturned )
                        {
                            CopyMemory( dataBuffer, (LPCWSTR)pPropertyTableItem->lpDefault, bytesReturned );
                        }
                    }
                    else
                    {
                        bytesReturned = sizeof(WCHAR);
                    }
                    break;

                case CLUSPROP_FORMAT_SZ:
                case CLUSPROP_FORMAT_EXPAND_SZ:
                    status = ERROR_SUCCESS;
                    if ( pPropertyTableItem->Default != 0 )
                    {
                        bytesReturned = ((DWORD) wcslen((LPCWSTR)pPropertyTableItem->lpDefault) + 1) * sizeof(WCHAR);
                        if ( bufferSize >= bytesReturned )
                        {
                            hr = StringCbCopyW( (LPWSTR) dataBuffer, bytesReturned, (LPCWSTR) pPropertyTableItem->lpDefault );
                            if ( FAILED( hr ) )
                            {
                                status = HRESULT_CODE( hr );
                                break;
                            }
                        }
                    }
                    else
                    {
                        bytesReturned = ((DWORD) wcslen(CLRTL_NULL_STRING) + 1) * sizeof(WCHAR);
                    }
                    break;

                case CLUSPROP_FORMAT_BINARY:
                    status = ERROR_SUCCESS;
                    if ( pPropertyTableItem->Default != 0 )
                    {
                        bytesReturned = pPropertyTableItem->Minimum;
                        if ( bufferSize >= bytesReturned )
                        {
                            CopyMemory( dataBuffer, (LPBYTE)pPropertyTableItem->lpDefault, bytesReturned );
                        }
                    }
                    else
                    {
                        bytesReturned = 0;
                    }
                    break;

                default:
                    break;
            }
        } // if: ERROR_FILE_NOT_FOUND

        if ( bufferSize < bytesReturned )
        {
            status = ERROR_MORE_DATA;
        }
        else if ( status == ERROR_SUCCESS )
        {
            props.pValue->cbLength = bytesReturned;

            // Round the bytes used up to the next DWORD boundary.
            bytesReturned = ALIGN_CLUSPROP( bytesReturned );

            bytesReturned += sizeof(*props.pValue);
            props.pb += bytesReturned;

            //
            // If this is an SZ or EXPAND_SZ, see if the expanded value should
            // be added to the value list.
            //
            if (    ( pPropertyTableItem->Format == CLUSPROP_FORMAT_SZ )
                ||  ( pPropertyTableItem->Format == CLUSPROP_FORMAT_EXPAND_SZ ) )
            {
                pszExpanded = ClRtlExpandEnvironmentStrings( (LPCWSTR) dataBuffer );
                if ( pszExpanded == NULL )
                {
                    status = GetLastError();
                }
                else
                {
                    if ( lstrcmpiW( pszExpanded, (LPCWSTR) dataBuffer ) != 0 )
                    {
                        props.pSyntax->dw = CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ;
                        bufferSize = ((DWORD) wcslen( pszExpanded ) + 1) * sizeof( WCHAR );
                        props.pStringValue->cbLength = bufferSize;
                        bufferSize = ALIGN_CLUSPROP( bufferSize );

                        hr = StringCbCopyW( props.pStringValue->sz, props.pStringValue->cbLength, pszExpanded );
                        if ( FAILED( hr ) )
                        {
                            status = HRESULT_CODE( hr );
                        }
                        else
                        {
                            bytesReturned += sizeof( *props.pStringValue ) + bufferSize;
                            props.pb += sizeof( *props.pStringValue ) + bufferSize;
                        }
                    }
                    LocalFree( pszExpanded );
                }
            }

            if ( status == ERROR_SUCCESS )
            {
                // Add the value list endmark.
                props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                props.pb += sizeof(*props.pSyntax);
                bytesReturned += sizeof(*props.pSyntax);

                *pcbOutPropertyItemSize -= bytesReturned;
                *pOutPropertyItem = (PVOID)props.pb;
            } // if:  ERROR_SUCCESS
        } // else if:  ERROR_SUCCESS
    } // if:  ERROR_SUCCESS

    if ( status == ERROR_FILE_NOT_FOUND )
    {
        status = ERROR_SUCCESS;
    }

Cleanup:

    //
    // Close the key if we opened it.
    //
    if ( (rvn.PszKeyName() != NULL) &&
         (key != NULL) )
    {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(status);

} // ClRtlGetProperty



DWORD
WINAPI
ClRtlpSetPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    write the properties identified in the property table from the property
    list to the cluster database. Update the values in the optional parameter
    block if the block's values are different from those in the property list.

Arguments:

    hkeyClusterKey - The opened cluster database key where properties are to
        be written.  If not specified, the property list will only be
        validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    Reserved - Reserved for future use.

    bAllowUnknownProperties - Don't fail if unknown properties are found.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the property list (input buffer) and the parameter block.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_BAD_ARGUMENTS - hkeyClusterKey is specified but proper cluster
        registry APIs are not specified, or no property table is specified.

    ERROR_INVALID_DATA - No property list is specified or the format of the
        property list is invalid.

    ERROR_INSUFFICIENT_BUFFER - The property list buffer isn't large enough to
        contain all the data it indicates it should contain.

    ERROR_INVALID_PARAMETER - The property list isn't formatted properly.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem;
    DWORD                   inBufferSize;
    DWORD                   itemCount;
    DWORD                   dataSize;
    PVOID                   key;
    CLUSPROP_BUFFER_HELPER  propList;
    PCLUSPROP_PROPERTY_NAME propName;
    CRegistryValueName      rvn;

    UNREFERENCED_PARAMETER( Reserved );

    if ( ( (hkeyClusterKey != NULL) &&
           (pClusterRegApis->pfnSetValue == NULL) ) ||
         ( pPropertyTable == NULL ) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: hkeyClusterKey or pClusterRegApis->pfnSetValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    if ( pInPropertyList == NULL )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: pInPropertyList == NULL. Returning ERROR_INVALID_DATA\n" );
        return(ERROR_INVALID_DATA);
    }

    propList.pb = (LPBYTE) pInPropertyList;
    inBufferSize = cbInPropertyListSize;

    //
    // Get the number of items in this list
    //
    if ( inBufferSize < sizeof(DWORD) )
    {
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    itemCount = propList.pList->nPropertyCount;
    propList.pdw++;
    inBufferSize -= sizeof(*propList.pdw);

    //
    // Parse the rest of the items in the buffer.
    //
    while ( itemCount-- )
    {
        //
        // Verify that the buffer is big enough to contain the
        // property name and a value.
        //
        propName = propList.pName;
        if ( inBufferSize < sizeof(*propName) )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        dataSize = sizeof(*propName) + ALIGN_CLUSPROP( propName->cbLength );
        if ( inBufferSize < dataSize + sizeof(CLUSPROP_VALUE) )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax of the property name is correct.
        //
        if ( propName->Syntax.dw != CLUSPROP_SYNTAX_NAME )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: not a name syntax.\n" );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Verify that the length is correct for the string.
        //
        if ( propName->cbLength != (wcslen( propName->sz ) + 1) * sizeof(WCHAR) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: property name size doesn't match stored length.\n" );
            return(ERROR_INVALID_DATA);
        }

        //
        // Move the buffer pointer to the property value.
        //
        propList.pb += dataSize;
        inBufferSize -= dataSize;

        //
        // Find the property name in the list of known properties.
        //
        propertyItem = pPropertyTable;
        while ( propertyItem->Name != NULL )
        {

            if ( lstrcmpiW( propName->sz, propertyItem->Name ) == 0 )
            {
                //
                // Verify that the buffer is big enough to contain the value.
                //
                dataSize = sizeof(*propList.pValue)
                            + ALIGN_CLUSPROP( propList.pValue->cbLength )
                            + sizeof(CLUSPROP_SYNTAX); // endmark
                if ( inBufferSize < dataSize )
                {
                    return(ERROR_INSUFFICIENT_BUFFER);
                }

                //
                // Verify that the syntax type is LIST_VALUE.
                //
                if ( propList.pSyntax->wType != CLUSPROP_TYPE_LIST_VALUE )
                {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' type CLUSPROP_TYPE_LIST_VALUE (%2!d!) expected, was %3!d!.\n", propName->sz, CLUSPROP_TYPE_LIST_VALUE, propList.pSyntax->wType );
                    return(ERROR_INVALID_PARAMETER);
                }

                //
                // Verify that this property should be of this format.
                //
                if ( propList.pSyntax->wFormat != propertyItem->Format )
                {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' format %2!d! expected, was %3!d!.\n", propName->sz, propertyItem->Format, propList.pSyntax->wType );
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // Make sure we are allowed to set this item.
                //
                if ( propertyItem->Flags & RESUTIL_PROPITEM_READ_ONLY )
                {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' is non-writable.\n", propName->sz );
                    return(ERROR_INVALID_PARAMETER);
                }

                //
                // Use the wrapper class CRegistryValueName to parse value name to see if it
                // contains a backslash.
                //
                status = rvn.ScInit( propertyItem->Name, propertyItem->KeyName );
                if ( status != ERROR_SUCCESS )
                {
                    return status;
                }

                //
                // If the value resides at a different location, create the key.
                //
                if ( (hkeyClusterKey != NULL) &&
                     (rvn.PszKeyName() != NULL) )
                {

                    DWORD disposition;

                    if ( (pClusterRegApis->pfnCreateKey == NULL) ||
                         (pClusterRegApis->pfnCloseKey == NULL)  )
                    {
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: pClusterRegApis->pfnCreateKey or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
                        return(ERROR_BAD_ARGUMENTS);
                    }

                    if ( hXsaction != NULL )
                    {
                        if ( pClusterRegApis->pfnLocalCreateKey == NULL )
                        {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: pClusterRegApis->pfnLocalCreateKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
                            return(ERROR_BAD_ARGUMENTS);
                        }

                        status = (*pClusterRegApis->pfnLocalCreateKey)(hXsaction,
                                                               hkeyClusterKey,
                                                               rvn.PszKeyName(),
                                                               0,
                                                               KEY_ALL_ACCESS,
                                                               NULL,
                                                               &key,
                                                               &disposition );
                    }

                    else
                    {
                        status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                               rvn.PszKeyName(),
                                                               0,
                                                               KEY_ALL_ACCESS,
                                                               NULL,
                                                               &key,
                                                               &disposition );
                    }

                    if ( status != ERROR_SUCCESS )
                    {
                        return(status);
                    }
                }
                else
                {
                    key = hkeyClusterKey;
                }

                //
                // Validate, write, and save the property data.
                //
                switch ( propList.pSyntax->wFormat )
                {
                    case CLUSPROP_FORMAT_DWORD:
                        status = ClRtlpSetDwordProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pDwordValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_LONG:
                        status = ClRtlpSetLongProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pLongValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_ULARGE_INTEGER:
                        status = ClRtlpSetULargeIntegerProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pULargeIntegerValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_LARGE_INTEGER:
                        status = ClRtlpSetLargeIntegerProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pLargeIntegerValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        status = ClRtlpSetStringProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pStringValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_MULTI_SZ:
                        status = ClRtlpSetMultiStringProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pStringValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    case CLUSPROP_FORMAT_BINARY:
                        status = ClRtlpSetBinaryProperty(
                                    hXsaction,
                                    key,
                                    pClusterRegApis,
                                    propertyItem,
                                    rvn,
                                    propList.pBinaryValue,
                                    bForceWrite,
                                    pOutParams );
                        break;

                    default:
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' unknown format %2!d! specified.\n", propName->sz, propList.pSyntax->wFormat );
                        status = ERROR_INVALID_PARAMETER;
                        break;

                } // switch:  value data format

                //
                // Close the key if we opened it.
                //
                if ( (hkeyClusterKey != NULL) &&
                     (rvn.PszKeyName() != NULL) )
                {
                    (*pClusterRegApis->pfnCloseKey)( key );
                }

                //
                // If an error occurred processing the property, cleanup and return.
                //
                if ( status != ERROR_SUCCESS )
                {
                    return(status);
                }

                //
                // Move the buffer past the value.
                //
                propList.pb += dataSize;
                inBufferSize -= dataSize;

                break;

            }
            else
            {
                propertyItem++;
                //
                // If we reached the end of the list, then return failure
                // if we do not allow unknown properties.
                //
                if ( (propertyItem->Name == NULL) &&
                     ! bAllowUnknownProperties )
                {
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' not found.\n", propName->sz );
                    return(ERROR_INVALID_PARAMETER);
                }
            }

        }

        //
        // If no property name was found, this is an invalid parameter if
        // we don't allow unknown properties.  Otherwise advance past the
        // property value.
        //
        if ( propertyItem->Name == NULL)
        {
            if ( ! bAllowUnknownProperties )
            {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPropertyTable: Property '%1!ls!' not found.\n", propName->sz );
                return(ERROR_INVALID_PARAMETER);
            }

            //
            // Advance the buffer pointer past the value in the value list.
            //
            while ( (propList.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (inBufferSize > 0) )
            {
                // ASSERT(inBufferSize > sizeof(*propList.pValue) + ALIGN_CLUSPROP(propList.pValue->cbLength));
                propList.pb += sizeof(*propList.pValue) + ALIGN_CLUSPROP(propList.pValue->cbLength);
                inBufferSize -= sizeof(*propList.pValue) + ALIGN_CLUSPROP(propList.pValue->cbLength);
            }  // while:  more values in the list

            //
            // Advance the buffer pointer past the value list endmark.
            //
            // ASSERT(inBufferSize >= sizeof(*propList.pSyntax));
            propList.pb += sizeof(*propList.pSyntax); // endmark
            inBufferSize -= sizeof(*propList.pSyntax);
        }
    }

    //
    // Now find any parameters that are not represented in the property
    // table. All of these extra properties will just be set without validation.
    //
    if ( (status == ERROR_SUCCESS) &&
         (pInPropertyList != NULL) &&
         bAllowUnknownProperties )
    {
        status = ClRtlpSetNonPropertyTable( hXsaction,
                                            hkeyClusterKey,
                                            pClusterRegApis,
                                            pPropertyTable,
                                            NULL,
                                            pInPropertyList,
                                            cbInPropertyListSize );
    }

    return(status);

} // ClRtlpSetPropertyTable



static
DWORD
WINAPI
ClRtlpSetDwordProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_DWORD pInDwordValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a DWORD property, write it to the cluster database (or delete it
    if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInDwordValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    PDWORD  pdwValue;

    UNREFERENCED_PARAMETER( bForceWrite );

    bZeroLengthData = ( pInDwordValue->cbLength == 0 );

    //
    // Validate the property data if not zero length.
    //
    if ( ! bZeroLengthData )
    {
        //
        // Verify the length of the value.
        //
        if ( pInDwordValue->cbLength != sizeof(DWORD) )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetDwordProperty: Property '%1!ls!' length %2!d! not DWORD length.\n", rrvnModifiedNames.PszName(), pInDwordValue->cbLength );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  data in value not size of DWORD

        //
        // Verify that the value is within the valid range.
        //
        if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  ((LONG) pInDwordValue->dw > (LONG) pPropertyItem->Maximum))
            || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  (pInDwordValue->dw > pPropertyItem->Maximum)) )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetDwordProperty: Property '%1!ls!' value %2!u! too large.\n", rrvnModifiedNames.PszName(), pInDwordValue->dw );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value too high
        if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  ((LONG) pInDwordValue->dw < (LONG) pPropertyItem->Minimum))
            || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  (pInDwordValue->dw < pPropertyItem->Minimum)) )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetDwordProperty: Property '%1!ls!' value %2!u! too small.\n", rrvnModifiedNames.PszName(), pInDwordValue->dw );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value to low
    } // if:  non-zero length data

    pdwValue = (PDWORD) &pOutParams[pPropertyItem->Offset];

    //
    // Write the value to the cluster database.
    // If the data length is zero, delete the value.
    //
    if ( hkey != NULL )
    {
        if ( bZeroLengthData )
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName() );
            }
            else
            {
                status = (*pClusterRegApis->pfnDeleteValue)(
                                hkey,
                                rrvnModifiedNames.PszName() );
            } // if/else:  doing/not doing a transaction

            //
            // If the property doesn't exist in the
            // cluster database, fix the status.
            //
            if ( status == ERROR_FILE_NOT_FOUND )
            {
                status = ERROR_SUCCESS;
            } // if:  property already doesn't exist
        }
        else
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalSetValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_DWORD,
                                (CONST BYTE *) &pInDwordValue->dw,
                                sizeof(DWORD) );
            }
            else
            {
                status = (*pClusterRegApis->pfnSetValue)(
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_DWORD,
                                (CONST BYTE *) &pInDwordValue->dw,
                                sizeof(DWORD) );
            } // if/else:  doing/not doing a transaction
        } // if/else:  zero length data
    } // if:  writing data

    //
    // Save the value to the output Parameter block.
    // If the data length is zero, set to the default.
    //
    if (    (status == ERROR_SUCCESS)
        &&  (pOutParams != NULL) )
    {
        if ( bZeroLengthData )
        {
            *pdwValue = pPropertyItem->Default;
        }
        else
        {
            *pdwValue = pInDwordValue->dw;
        } // if/else:  zero length data
    } // if:  data written successfully and parameter block specified
Cleanup:

    return status;

} // ClRtlpSetDwordProperty



static
DWORD
WINAPI
ClRtlpSetLongProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LONG pInLongValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a LONG property, write it to the cluster database (or delete it
    if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInLongValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    PLONG   plValue;

    UNREFERENCED_PARAMETER( bForceWrite );

    bZeroLengthData = ( pInLongValue->cbLength == 0 );

    //
    // Validate the property data if not zero length.
    //
    if ( ! bZeroLengthData )
    {
        //
        // Verify the length of the value.
        //
        if ( pInLongValue->cbLength != sizeof(LONG) )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetLongProperty: Property '%1!ls!' length %2!d! not LONG length.\n", rrvnModifiedNames.PszName(), pInLongValue->cbLength );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  data in value not size of LONG

        //
        // Verify that the value is within the valid range.
        //
        if ( pInLongValue->l > (LONG) pPropertyItem->Maximum )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetLongProperty: Property '%1!ls!' value %2!d! too large.\n", rrvnModifiedNames.PszName(), pInLongValue->l );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value too high
        if ( pInLongValue->l < (LONG) pPropertyItem->Minimum )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetLongProperty: Property '%1!ls!' value %2!d! too small.\n", rrvnModifiedNames.PszName(), pInLongValue->l );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value too small
    } // if:  non-zero length data

    plValue = (PLONG) &pOutParams[pPropertyItem->Offset];

    //
    // Write the value to the cluster database.
    // If the data length is zero, delete the value.
    //
    if ( hkey != NULL )
    {
        if ( bZeroLengthData )
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName() );
            }
            else
            {
                status = (*pClusterRegApis->pfnDeleteValue)(
                                hkey,
                                rrvnModifiedNames.PszName() );
            } // if/else:  doing/not doing a transaction

            //
            // If the property doesn't exist in the
            // cluster database, fix the status.
            //
            if ( status == ERROR_FILE_NOT_FOUND )
            {
                status = ERROR_SUCCESS;
            } // if:  property already doesn't exist
        }
        else
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalSetValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_DWORD,
                                (CONST BYTE *) &pInLongValue->l,
                                sizeof(LONG) );
            }
            else
            {
                status = (*pClusterRegApis->pfnSetValue)(
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_DWORD,
                                (CONST BYTE *) &pInLongValue->l,
                                sizeof(LONG) );
            } // if/else:  doing/not doing a transaction
        } // if/else:  zero length data
    } // if:  writing data

    //
    // Save the value to the output Parameter block.
    // If the data length is zero, set to the default.
    //
    if (    (status == ERROR_SUCCESS)
        &&  (pOutParams != NULL) )
    {
        if ( bZeroLengthData )
        {
            *plValue = (LONG) pPropertyItem->Default;
        }
        else
        {
            *plValue = pInLongValue->l;
        } // if/else:  zero length data
    } // if:  data written successfully and parameter block specified

Cleanup:

    return status;

} // ClRtlpSetLongProperty



static
DWORD
WINAPI
ClRtlpSetULargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_ULARGE_INTEGER pInULargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a ULARGE_INTEGER property, write it to the cluster database (or
    delete it if it is zero length), and save it in the specified parameter
    block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInULargeIntegerValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    BOOL                bZeroLengthData;
    ULARGE_INTEGER *    pullOutParamValue;      // pointer to optional Output paramter block
    ULARGE_INTEGER      ullPropListValue;

    UNREFERENCED_PARAMETER( bForceWrite );

    //
    // proplists are dword aligned and therefore might cause an alignment
    // fault when we make the range checks. Copy it (by DWORDs) into a
    // properly aligned automatic variable.
    //
    ullPropListValue.u = pInULargeIntegerValue->li.u;

    bZeroLengthData = ( pInULargeIntegerValue->cbLength == 0 );

    //
    // Validate the property data if not zero length.
    //
    if ( ! bZeroLengthData )
    {
        //
        // Verify the length of the value.
        //
        if ( pInULargeIntegerValue->cbLength != sizeof(ULARGE_INTEGER) )
        {
            ClRtlDbgPrint(LOG_UNUSUAL,
                          "ClRtlpSetULargeIntegerProperty: Property '%1!ls!' length %2!d! "
                          "not ULARGE_INTEGER length.\n",
                          rrvnModifiedNames.PszName(),
                          pInULargeIntegerValue->cbLength );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  data in value not size of DWORD

        //
        // Verify that the value is within the valid range. first check
        // the max value
        //
        if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  ((LONGLONG)ullPropListValue.QuadPart > (LONGLONG)pPropertyItem->ULargeIntData->Maximum.QuadPart))
            || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  (ullPropListValue.QuadPart > pPropertyItem->ULargeIntData->Maximum.QuadPart)) )
        {
            ClRtlDbgPrint(LOG_UNUSUAL,
                          "ClRtlpSetULargeIntegerProperty: Property '%1!ls!' value %2!I64u! "
                          "too large.\n",
                          rrvnModifiedNames.PszName(),
                          ullPropListValue.QuadPart );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value too high

        if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  ((LONGLONG)ullPropListValue.QuadPart < (LONGLONG)pPropertyItem->ULargeIntData->Minimum.QuadPart))
            || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  (ullPropListValue.QuadPart < pPropertyItem->ULargeIntData->Minimum.QuadPart)) )
        {
            ClRtlDbgPrint(LOG_UNUSUAL,
                          "ClRtlpSetULargeIntegerProperty: Property '%1!ls!' value "
                          "%2!I64u! too small.\n",
                          rrvnModifiedNames.PszName(),
                          ullPropListValue.QuadPart );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value to low
    } // if:  non-zero length data

    //
    // Write the value to the cluster database.
    // If the data length is zero, delete the value.
    //
    if ( hkey != NULL )
    {
        if ( bZeroLengthData )
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName() );
            }
            else
            {
                status = (*pClusterRegApis->pfnDeleteValue)(
                                hkey,
                                rrvnModifiedNames.PszName() );
            } // if/else:  doing/not doing a transaction

            //
            // If the property doesn't exist in the
            // cluster database, fix the status.
            //
            if ( status == ERROR_FILE_NOT_FOUND )
            {
                status = ERROR_SUCCESS;
            } // if:  property already doesn't exist
        }
        else
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalSetValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_QWORD,
                                (CONST BYTE *) &ullPropListValue.QuadPart,
                                sizeof(ULARGE_INTEGER) );
            }
            else
            {
                status = (*pClusterRegApis->pfnSetValue)(
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_QWORD,
                                (CONST BYTE *) &ullPropListValue.QuadPart,
                                sizeof(ULARGE_INTEGER) );
            } // if/else:  doing/not doing a transaction
        } // if/else:  zero length data
    } // if:  writing data

    //
    // Save the value to the output Parameter block.
    // If the data length is zero, set to the default.
    //
    if (    (status == ERROR_SUCCESS)  &&  (pOutParams != NULL) )
    {
        pullOutParamValue = (ULARGE_INTEGER *) &pOutParams[pPropertyItem->Offset];

        if ( bZeroLengthData )
        {
            pullOutParamValue->QuadPart = pPropertyItem->ULargeIntData->Default.QuadPart;
        }
        else
        {
            pullOutParamValue->QuadPart = ullPropListValue.QuadPart;
        } // if/else:  zero length data
    } // if:  data written successfully and parameter block specified
Cleanup:

    return status;

} // ClRtlpSetULargeIntegerProperty


static
DWORD
WINAPI
ClRtlpSetLargeIntegerProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_LARGE_INTEGER pInLargeIntegerValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a LARGE_INTEGER property, write it to the cluster database (or
    delete it if it is zero length), and save it in the specified parameter
    block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInLargeIntegerValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    BOOL            bZeroLengthData;
    LARGE_INTEGER * pllOutParamValue;
    LARGE_INTEGER   llPropListValue;

    UNREFERENCED_PARAMETER( bForceWrite );

    //
    // proplists are dword aligned and therefore might cause an alignment
    // fault when we make the range checks. Copy it (by DWORDs) into a
    // properly aligned automatic variable.
    //
    llPropListValue.u = pInLargeIntegerValue->li.u;

    bZeroLengthData = ( pInLargeIntegerValue->cbLength == 0 );

    //
    // Validate the property data if not zero length.
    //
    if ( ! bZeroLengthData )
    {
        //
        // Verify the length of the value.
        //
        if ( pInLargeIntegerValue->cbLength != sizeof(LARGE_INTEGER) )
        {
            ClRtlDbgPrint(LOG_UNUSUAL,
                          "ClRtlpSetLargeIntegerProperty: Property '%1!ls!' length %2!d! "
                          "not LARGE_INTEGER length.\n",
                          rrvnModifiedNames.PszName(),
                          pInLargeIntegerValue->cbLength );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  data in value not size of DWORD

        //
        // Verify that the value is within the valid range.
        //
        if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  ((LONGLONG)llPropListValue.QuadPart > (LONGLONG)pPropertyItem->LargeIntData->Maximum.QuadPart))
            || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  (llPropListValue.QuadPart > pPropertyItem->LargeIntData->Maximum.QuadPart)) )
        {
            ClRtlDbgPrint(LOG_UNUSUAL,
                          "ClRtlpSetLargeIntegerProperty: Property '%1!ls!' value %2!I64d! "
                          "too large.\n",
                          rrvnModifiedNames.PszName(),
                          llPropListValue.QuadPart );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value too high

        if ( (      (pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  ((LONGLONG)llPropListValue.QuadPart < (LONGLONG)pPropertyItem->LargeIntData->Minimum.QuadPart))
            || (    !(pPropertyItem->Flags & RESUTIL_PROPITEM_SIGNED)
                &&  (llPropListValue.QuadPart < pPropertyItem->LargeIntData->Minimum.QuadPart)) )
        {
            ClRtlDbgPrint(LOG_UNUSUAL,
                          "ClRtlpSetLargeIntegerProperty: Property '%1!ls!' value "
                          "%2!I64d! too small.\n",
                          rrvnModifiedNames.PszName(),
                          llPropListValue.QuadPart );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  value to low
    } // if:  non-zero length data

    //
    // Write the value to the cluster database.
    // If the data length is zero, delete the value.
    //
    if ( hkey != NULL )
    {
        if ( bZeroLengthData )
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName() );
            }
            else
            {
                status = (*pClusterRegApis->pfnDeleteValue)(
                                hkey,
                                rrvnModifiedNames.PszName() );
            } // if/else:  doing/not doing a transaction

            //
            // If the property doesn't exist in the
            // cluster database, fix the status.
            //
            if ( status == ERROR_FILE_NOT_FOUND )
            {
                status = ERROR_SUCCESS;
            } // if:  property already doesn't exist
        }
        else
        {
            if ( hXsaction )
            {
                status = (*pClusterRegApis->pfnLocalSetValue)(
                                hXsaction,
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_QWORD,
                                (CONST BYTE *) &llPropListValue.QuadPart,
                                sizeof(LARGE_INTEGER) );
            }
            else
            {
                status = (*pClusterRegApis->pfnSetValue)(
                                hkey,
                                rrvnModifiedNames.PszName(),
                                REG_QWORD,
                                (CONST BYTE *) &llPropListValue.QuadPart,
                                sizeof(LARGE_INTEGER) );
            } // if/else:  doing/not doing a transaction
        } // if/else:  zero length data
    } // if:  writing data

    //
    // Save the value to the output Parameter block.
    // If the data length is zero, set to the default.
    //
    if ( (status == ERROR_SUCCESS)  &&  (pOutParams != NULL) )
    {
        pllOutParamValue = (LARGE_INTEGER *) &pOutParams[pPropertyItem->Offset];

        if ( bZeroLengthData )
        {
            pllOutParamValue->QuadPart = pPropertyItem->LargeIntData->Default.QuadPart;
        }
        else
        {
            pllOutParamValue->QuadPart = llPropListValue.QuadPart;
        } // if/else:  zero length data
    } // if:  data written successfully and parameter block specified

Cleanup:

    return status;

} // ClRtlpSetLargeIntegerProperty


static
DWORD
WINAPI
ClRtlpSetStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_SZ pInStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a string property (SZ or EXPAND_SZ), write it to the cluster
    database (or delete it if it is zero length), and save it in the
    specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInStringValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    LPWSTR *    ppszValue;
    DWORD   dwType;
    size_t  cbValLen;
    HRESULT hr;

    bZeroLengthData = ( pInStringValue->cbLength == 0 );

    //
    // Validate the property data if not zero length.
    //
    if ( ! bZeroLengthData )
    {
        //
        // Verify the length of the value.
        //
        if ( pInStringValue->cbLength != (wcslen( pInStringValue->sz ) + 1) * sizeof(WCHAR) )
        {
            ClRtlDbgPrint( LOG_UNUSUAL, "ClRtlpSetStringProperty: Property '%1!ls!' length %2!d! doesn't match zero-term. length.\n", rrvnModifiedNames.PszName(), pInStringValue->cbLength );
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        } // if:  string length doesn't match length in property
    } // if:  non-zero length data

    ppszValue = (LPWSTR *) &pOutParams[pPropertyItem->Offset];

    //
    // If the data changed, write it and save it.
    // Do this even if only the case of the data changed.
    //
    if (    (pOutParams == NULL)
        ||  (*ppszValue == NULL)
        ||  bZeroLengthData
        ||  bForceWrite
        ||  (wcsncmp( *ppszValue, pInStringValue->sz, pInStringValue->cbLength / sizeof( WCHAR ) ) != 0) )
    {


        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL )
        {
            if ( bZeroLengthData )
            {
                if ( hXsaction )
                {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                }
                else
                {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND )
                {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            }
            else
            {
                if ( pPropertyItem->Format == CLUSPROP_FORMAT_EXPAND_SZ )
                {
                    dwType = REG_EXPAND_SZ;
                }
                else
                {
                    dwType = REG_SZ;
                } // if/else:  property format is EXPAND_SZ
                if ( hXsaction )
                {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    dwType,
                                    (CONST BYTE *) &pInStringValue->sz,
                                    pInStringValue->cbLength );
                }
                else
                {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    dwType,
                                    (CONST BYTE *) &pInStringValue->sz,
                                    pInStringValue->cbLength );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)
            &&  (pOutParams != NULL) )
        {

            if ( *ppszValue != NULL )
            {
                LocalFree( *ppszValue );
            } // if:  previous value in parameter block

            if ( bZeroLengthData )
            {
                // If a default is specified, copy it.
                if ( pPropertyItem->lpDefault != NULL )
                {
                    cbValLen = (wcslen( (LPCWSTR) pPropertyItem->lpDefault ) + 1) * sizeof(WCHAR);
                    *ppszValue = (LPWSTR) LocalAlloc(
                                              LMEM_FIXED,
                                              cbValLen
                                              );
                    if ( *ppszValue == NULL )
                    {
                        status = GetLastError();
                        ClRtlDbgPrint(LOG_CRITICAL,
                                      "ClRtlpSetStringProperty: error allocating memory for default "
                                      "SZ value '%1!ls!' in parameter block for property '%2!ls!'.\n",
                                      pPropertyItem->lpDefault,
                                      rrvnModifiedNames.PszName() );
                        goto Cleanup;
                    } // if:  error allocating memory
                    hr = StringCbCopyW( *ppszValue, cbValLen, (LPCWSTR) pPropertyItem->lpDefault );
                    if ( FAILED( hr ) )
                    {
                        status = HRESULT_CODE( hr );
                        goto Cleanup;
                    }
                }
                else
                {
                    *ppszValue = NULL;
                } // if/else:  default value specified
            }
            else
            {
                *ppszValue = (LPWSTR) LocalAlloc( LMEM_FIXED, pInStringValue->cbLength );
                if ( *ppszValue == NULL )
                {
                    status = GetLastError();
                    ClRtlDbgPrint(LOG_CRITICAL,
                                  "ClRtlpSetStringProperty: error allocating memory for SZ "
                                  "value '%1!ls!' in parameter block for property '%2!ls!'.\n",
                                  pInStringValue->cbLength,
                                  rrvnModifiedNames.PszName() );
                    goto Cleanup;
                } // if:  error allocating memory

                hr = StringCbCopyW( *ppszValue, pInStringValue->cbLength, pInStringValue->sz );
                if ( FAILED( hr ) )
                {
                    status = HRESULT_CODE( hr );
                    goto Cleanup;
                }
            } // if/else:  zero length data
        } // if:  data written successfully and parameter block specified
    } // if:  value changed or zero-length value

Cleanup:

    return status;

} // ClRtlpSetStringProperty



static
DWORD
WINAPI
ClRtlpSetMultiStringProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_MULTI_SZ pInMultiStringValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a MULTI_SZ property, write it to the cluster database (or delete
    it if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInMultiStringValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    LPWSTR *    ppszValue;
    PDWORD  pdwValue;
    DWORD   dwType;

    bZeroLengthData = ( pInMultiStringValue->cbLength == 0 );

    ppszValue = (LPWSTR *) &pOutParams[pPropertyItem->Offset];
    pdwValue = (PDWORD) &pOutParams[pPropertyItem->Offset + sizeof(LPWSTR *)];

    //
    // If the data changed, write it and save it.
    // Do this even if only the case of the data changed.
    //
    if (    (pOutParams == NULL)
        ||  (*ppszValue == NULL)
        ||  (*pdwValue != pInMultiStringValue->cbLength)
        ||  bZeroLengthData
        ||  bForceWrite
        ||  (memcmp( *ppszValue, pInMultiStringValue->sz, *pdwValue ) != 0) )
    {

        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL )
        {
            if ( bZeroLengthData )
            {
                if ( hXsaction )
                {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                }
                else
                {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND )
                {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            }
            else
            {
                if ( pPropertyItem->Format == CLUSPROP_FORMAT_MULTI_SZ )
                {
                    dwType = REG_MULTI_SZ;
                }
                else
                {
                    dwType = REG_SZ;
                } // if/else:  property format is EXPAND_SZ
                if ( hXsaction )
                {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    dwType,
                                    (CONST BYTE *) &pInMultiStringValue->sz,
                                    pInMultiStringValue->cbLength );
                }
                else
                {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    dwType,
                                    (CONST BYTE *) &pInMultiStringValue->sz,
                                    pInMultiStringValue->cbLength );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)
            &&  (pOutParams != NULL) )
        {

            if ( *ppszValue != NULL )
            {
                LocalFree( *ppszValue );
            } // if:  previous value in parameter block

            if ( bZeroLengthData )
            {
                // If a default is specified, copy it.
                if ( pPropertyItem->lpDefault != NULL )
                {
                    *ppszValue = (LPWSTR) LocalAlloc( LMEM_FIXED, pPropertyItem->Minimum );
                    if ( *ppszValue == NULL )
                    {
                        status = GetLastError();
                        *pdwValue = 0;
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetMultiStringProperty: error allocating memory for default MULTI_SZ value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                        goto Cleanup;
                    } // if:  error allocating memory
                    CopyMemory( *ppszValue, pPropertyItem->lpDefault, pPropertyItem->Minimum );
                    *pdwValue = pPropertyItem->Minimum;
                }
                else
                {
                    *ppszValue = NULL;
                    *pdwValue = 0;
                } // if/else:  default value specified
            }
            else
            {
                *ppszValue = (LPWSTR) LocalAlloc( LMEM_FIXED, pInMultiStringValue->cbLength );
                if ( *ppszValue == NULL )
                {
                    status = GetLastError();
                    *pdwValue = 0;
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetMultiStringProperty: error allocating memory for MULTI_SZ value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                    goto Cleanup;
                } // if:  error allocating memory
                CopyMemory( *ppszValue, pInMultiStringValue->sz, pInMultiStringValue->cbLength );
                *pdwValue = pInMultiStringValue->cbLength;
            } // if/else:  zero length data
        } // if:  data written successfully and parameter block specified
    } // if:  value changed or zero-length value

Cleanup:

    return status;

} // ClRtlpSetMultiStringProperty



static
DWORD
WINAPI
ClRtlpSetBinaryProperty(
    IN HANDLE hXsaction,
    IN PVOID hkey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyItem,
    IN const CRegistryValueName & rrvnModifiedNames,
    IN PCLUSPROP_BINARY pInBinaryValue,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Validate a BINARY property, write it to the cluster database (or delete
    it if it is zero length), and save it in the specified parameter block.

Arguments:

    hXsaction - Transaction handle.

    hkey - The opened cluster database key where the property is to be written.
        If not specified, the property will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyItem - The property from a property table to set/validate.

    rrvnModifiedNames - If the name of the property contains a backslash
        this object contains the modified name and keyname.

    pInBinaryValue - The value from the property list to set/validate.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameter block in which to return the data.  If specified,
        parameters will only be written if they are different between
        the input data and the parameter block, unless bForceWrite == TRUE.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA - The format of the data is invalid for a property
        list value.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    bZeroLengthData;
    PBYTE * ppbValue;
    PDWORD  pdwValue;

    bZeroLengthData = ( pInBinaryValue->cbLength == 0 );

    ppbValue = (PBYTE *) &pOutParams[pPropertyItem->Offset];
    pdwValue = (PDWORD) &pOutParams[pPropertyItem->Offset + sizeof(PBYTE *)];

    //
    // If the data changed, write it and save it.
    // Do this even if only the case of the data changed.
    //
    if (    (pOutParams == NULL)
        ||  (*ppbValue == NULL)
        ||  (*pdwValue != pInBinaryValue->cbLength)
        ||  bZeroLengthData
        ||  bForceWrite
        ||  (memcmp( *ppbValue, pInBinaryValue->rgb, *pdwValue ) != 0) )
    {

        //
        // Write the value to the cluster database.
        // If the data length is zero, delete the value.
        //
        if ( hkey != NULL )
        {
            if ( bZeroLengthData )
            {
                if ( hXsaction )
                {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                }
                else
                {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName() );
                } // if/else:  doing/not doing a transaction

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND )
                {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist
            }
            else
            {
                if ( hXsaction )
                {
                    status = (*pClusterRegApis->pfnLocalSetValue)(
                                    hXsaction,
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_BINARY,
                                    (CONST BYTE *) &pInBinaryValue->rgb,
                                    pInBinaryValue->cbLength );
                }
                else
                {
                    status = (*pClusterRegApis->pfnSetValue)(
                                    hkey,
                                    rrvnModifiedNames.PszName(),
                                    REG_BINARY,
                                    (CONST BYTE *) &pInBinaryValue->rgb,
                                    pInBinaryValue->cbLength );
                } // if/else:  doing/not doing a transaction
            } // if/else:  zero length data
        } // if:  writing data

        //
        // Save the value to the output Parameter block.
        // If the data length is zero, set to the default.
        //
        if (    (status == ERROR_SUCCESS)
            &&  (pOutParams != NULL) )
        {

            if ( *ppbValue != NULL )
            {
                LocalFree( *ppbValue );
            } // if:  previous value in parameter block

            if ( bZeroLengthData )
            {
                // If a default is specified, copy it.
                if ( pPropertyItem->lpDefault != NULL )
                {
                    *ppbValue = (LPBYTE) LocalAlloc( LMEM_FIXED, pPropertyItem->Minimum );
                    if ( *ppbValue == NULL )
                    {
                        status = GetLastError();
                        *pdwValue = 0;
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetBinaryProperty: error allocating memory for default BINARY value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                        goto Cleanup;
                    } // if:  error allocating memory
                    CopyMemory( *ppbValue, pPropertyItem->lpDefault, pPropertyItem->Minimum );
                    *pdwValue = pPropertyItem->Minimum;
                }
                else
                {
                    *ppbValue = NULL;
                    *pdwValue = 0;
                } // if/else:  default value specified
            }
            else
            {
                *ppbValue = (LPBYTE) LocalAlloc( LMEM_FIXED, pInBinaryValue->cbLength );
                if ( *ppbValue == NULL )
                {
                    status = GetLastError();
                    *pdwValue = 0;
                    ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetBinaryProperty: error allocating memory for BINARY value in parameter block for property '%1!ls!'.\n", rrvnModifiedNames.PszName() );
                    goto Cleanup;
                } // if:  error allocating memory
                CopyMemory( *ppbValue, pInBinaryValue->rgb, pInBinaryValue->cbLength );
                *pdwValue = pInBinaryValue->cbLength;
            } // if/else:  zero length data
            } // if:  data written successfully and parameter block specified
        } // if:  value changed or zero-length value

Cleanup:

    return status;

} // ClRtlpSetBinaryProperty



DWORD
WINAPI
ClRtlpSetNonPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

    Write the properties in the property list which are not specified in the
    property table to the cluster database.

Arguments:

    hXsaction - Local Transaction handle.

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem;
    DWORD                   inBufferSize;
    DWORD                   itemCount;
    DWORD                   dataSize;
    CLUSPROP_BUFFER_HELPER  propList;
    PCLUSPROP_PROPERTY_NAME pName;
    BOOL                    bZeroLengthData;
    CRegistryValueName      rvn;

    UNREFERENCED_PARAMETER( Reserved );

    //
    // If hKeyClusterKey is present then 'normal' functions must be present.
    //
    if ( ( (hkeyClusterKey != NULL) &&
           ((pClusterRegApis->pfnSetValue == NULL) ||
           (pClusterRegApis->pfnCreateKey == NULL) ||
           (pClusterRegApis->pfnOpenKey == NULL) ||
           (pClusterRegApis->pfnCloseKey == NULL)
         )) ||
         ( pPropertyTable == NULL ) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: pClusterRegApis->pfnSetValue, pfnCreateKey, pfnOpenKey, or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // If hKeyClusterKey and hXsaction are present
    // then 'local' functions must be present.
    //
    if ( ((hkeyClusterKey != NULL) &&
           (hXsaction != NULL )) &&
           ((pClusterRegApis->pfnLocalCreateKey == NULL) ||
           (pClusterRegApis->pfnLocalDeleteValue == NULL)
         ) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: pClusterRegApis->pfnpfnLocalCreateKey or pfnLocalDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    if ( pInPropertyList == NULL )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: pInPropertyList == NULL. Returning ERROR_INVALID_DATA\n" );
        return(ERROR_INVALID_DATA);
    }

    propList.pb = (LPBYTE) pInPropertyList;
    inBufferSize = cbInPropertyListSize;

    //
    // Get the number of items in this list
    //
    if ( inBufferSize < sizeof(DWORD) )
    {
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    itemCount = propList.pList->nPropertyCount;
    propList.pdw++;

    //
    // Parse the rest of the items in the buffer.
    //
    while ( itemCount-- )
    {
        //
        // Verify that the buffer is big enough to contain the
        // property name and a value.
        //
        pName = propList.pName;
        if ( inBufferSize < sizeof(*pName) )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        dataSize = sizeof(*pName) + ALIGN_CLUSPROP( pName->cbLength );
        if ( inBufferSize < dataSize + sizeof(CLUSPROP_VALUE) )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax of the property name is correct.
        //
        if ( pName->Syntax.dw != CLUSPROP_SYNTAX_NAME )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: syntax %1!d! not a name syntax.\n", pName->Syntax.dw );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Verify that the length is correct for the string.
        //
        if ( pName->cbLength != (wcslen( pName->sz ) + 1) * sizeof(WCHAR) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: name is not a valid C string.\n" );
            return(ERROR_INVALID_DATA);
        }

        //
        // Move the buffer pointer to the property value.
        //
        propList.pb += dataSize;
        inBufferSize -= dataSize;

        //
        // Find the property name in the list of known properties.
        //
        propertyItem = pPropertyTable;
        while ( propertyItem->Name != NULL )
        {

            if ( lstrcmpiW( pName->sz, propertyItem->Name ) == 0 )
            {
                //
                // Verify that the buffer is big enough to contain the value.
                //
                do {
                    dataSize = sizeof(*propList.pValue)
                                + ALIGN_CLUSPROP( propList.pValue->cbLength );
                    if ( inBufferSize < dataSize )
                    {
                        return(ERROR_INSUFFICIENT_BUFFER);
                    }

                    //
                    // Skip this value.
                    //
                    propList.pb += dataSize;
                    inBufferSize -= dataSize;
                } while ( propList.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK );

                //
                // Skip the endmark.
                //
                dataSize = sizeof( CLUSPROP_SYNTAX );
                if ( inBufferSize < dataSize )
                {
                    return(ERROR_INSUFFICIENT_BUFFER);
                }
                propList.pb += dataSize;
                inBufferSize -= dataSize;

                break;

            }
            else
            {
                propertyItem++;
            }
        } // while:

        //
        // If no property name was found, just save this item.
        //
        if ( propertyItem->Name == NULL)
        {
            //
            // Verify that the buffer is big enough to contain the value.
            //
            dataSize = sizeof(*propList.pValue)
                        + ALIGN_CLUSPROP( propList.pValue->cbLength );
            if ( inBufferSize < dataSize + sizeof( CLUSPROP_SYNTAX ) )
            {
                return(ERROR_INSUFFICIENT_BUFFER);
            }

            //
            // Verify that the syntax type is LIST_VALUE.
            //
            if ( propList.pSyntax->wType != CLUSPROP_TYPE_LIST_VALUE )
            {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' type CLUSPROP_TYPE_LIST_VALUE (%2!d!) expected, was %3!d!.\n", pName->sz, CLUSPROP_TYPE_LIST_VALUE, propList.pSyntax->wType );
                return(ERROR_INVALID_PARAMETER);
            }

            //
            // If the value is not specified, delete the property.
            //
            bZeroLengthData = ( propList.pValue->cbLength == 0 );
            if ( bZeroLengthData )
            {

                if ( hkeyClusterKey != NULL )
                {
                    PVOID key = NULL;

                    //
                    // Use the wrapper class CRegistryValueName to parse value name to see if it
                    // contains a backslash.
                    //
                    status = rvn.ScInit( pName->sz, NULL );
                    if ( status != ERROR_SUCCESS )
                    {
                        break;
                    }

                    //
                    // If the value resides at a different location, open the key.
                    //
                    if ( rvn.PszKeyName() != NULL )
                    {
                        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                                 rvn.PszKeyName(),
                                                                 KEY_ALL_ACCESS,
                                                                 &key);

                        if ( status != ERROR_SUCCESS )
                        {
                            break;
                        }

                    }
                    else
                    {
                        key = hkeyClusterKey;
                    }

                    if ( hXsaction != NULL )
                    {
                        status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                            hXsaction,
                                            key,
                                            rvn.PszName() );
                    }
                    else
                    {
                        status = (*pClusterRegApis->pfnDeleteValue)(
                                            key,
                                            rvn.PszName() );
                    }

                    //
                    // If the property doesn't exist in the
                    // cluster database, fix the status.
                    //
                    if ( status == ERROR_FILE_NOT_FOUND )
                    {
                        status = ERROR_SUCCESS;
                    } // if:  property already doesn't exist

                    //
                    // Close the key if we opened it.
                    //
                    if ( (rvn.PszKeyName() != NULL) &&
                         (key != NULL) )
                    {
                        (*pClusterRegApis->pfnCloseKey)( key );
                    }

                } // if:  key specified
            }
            else
            {
                PVOID key = NULL;
                DWORD disposition;

                if ( hkeyClusterKey != NULL )
                {
                    //
                    // Use the wrapper class CRegistryValueName to parse value name to see if it
                    // contains a backslash.
                    //
                    status = rvn.ScInit( pName->sz, NULL );
                    if ( status != ERROR_SUCCESS )
                    {
                        break;
                    }

                    //
                    // If the value resides at a different location, open the key.
                    //
                    if ( rvn.PszKeyName() != NULL )
                    {

                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalCreateKey)( hXsaction,
                                                                            hkeyClusterKey,
                                                                            rvn.PszKeyName(),
                                                                            0,
                                                                            KEY_ALL_ACCESS,
                                                                            NULL,
                                                                            &key,
                                                                            &disposition);
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                                       rvn.PszKeyName(),
                                                                       0,
                                                                       KEY_ALL_ACCESS,
                                                                       NULL,
                                                                       &key,
                                                                       &disposition);
                        }

                        if ( status != ERROR_SUCCESS )
                        {
                            break;
                        }

                    }
                    else
                    {
                        key = hkeyClusterKey;
                    }
                }

                switch ( propList.pSyntax->wFormat )
                {
                    case CLUSPROP_FORMAT_DWORD:
                        //
                        // Verify the length of the value.
                        //
                        if ( propList.pDwordValue->cbLength != sizeof(DWORD) )
                        {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! not DWORD length.\n", pName->sz, propList.pDwordValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction != NULL )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_DWORD,
                                                                               (CONST BYTE*)&propList.pDwordValue->dw,
                                                                               sizeof(DWORD) );
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_DWORD,
                                                                          (CONST BYTE*)&propList.pDwordValue->dw,
                                                                          sizeof(DWORD) );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_LONG:
                        //
                        // Verify the length of the value.
                        //
                        if ( propList.pLongValue->cbLength != sizeof(LONG) )
                        {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! not LONG length.\n", pName->sz, propList.pLongValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction != NULL )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_DWORD,
                                                                               (CONST BYTE*)&propList.pLongValue->l,
                                                                               sizeof(LONG) );
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_DWORD,
                                                                          (CONST BYTE*)&propList.pLongValue->l,
                                                                          sizeof(LONG) );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_ULARGE_INTEGER:
                    case CLUSPROP_FORMAT_LARGE_INTEGER:
                        //
                        // Verify the length of the value.
                        //
                        if ( propList.pULargeIntegerValue->cbLength != sizeof(ULARGE_INTEGER) )
                        {
                            ClRtlDbgPrint(LOG_CRITICAL,
                                          "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! "
                                          "not QWORD length.\n",
                                          pName->sz,
                                          propList.pULargeIntegerValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database. Alignment
                        // is not an issue since the SetValue API treats the
                        // data as a stream of bytes instead of a large int.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)(
                                             hXsaction,
                                             key,
                                             rvn.PszName(),
                                             REG_QWORD,
                                             (CONST BYTE*)&propList.pULargeIntegerValue->li.QuadPart,
                                             sizeof(ULARGE_INTEGER));
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)(
                                             key,
                                             rvn.PszName(),
                                             REG_QWORD,
                                             (CONST BYTE*)&propList.pULargeIntegerValue->li.QuadPart,
                                             sizeof(ULARGE_INTEGER));
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_SZ:
                        //
                        // Verify the length of the value.
                        //
                        if ( propList.pStringValue->cbLength != (wcslen( propList.pStringValue->sz ) + 1) * sizeof(WCHAR) )
                        {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! doesn't match null-term. length.\n", pName->sz, propList.pStringValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction != NULL )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_SZ,
                                                                               (CONST BYTE*)propList.pStringValue->sz,
                                                                               propList.pStringValue->cbLength );
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_SZ,
                                                                          (CONST BYTE*)propList.pStringValue->sz,
                                                                          propList.pStringValue->cbLength );
                            }
                        }

                        break;


                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        //
                        // Verify the length of the value.
                        //
                        if ( propList.pStringValue->cbLength != (wcslen( propList.pStringValue->sz ) + 1) * sizeof(WCHAR) )
                        {
                            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' length %2!d! doesn't match null-term. length.\n", pName->sz, propList.pStringValue->cbLength );
                            status = ERROR_INVALID_DATA;
                            break;
                        }

                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction != NULL )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_EXPAND_SZ,
                                                                               (CONST BYTE*)propList.pStringValue->sz,
                                                                               propList.pStringValue->cbLength );
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_EXPAND_SZ,
                                                                          (CONST BYTE*)propList.pStringValue->sz,
                                                                          propList.pStringValue->cbLength );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_MULTI_SZ:
                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction != NULL )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_MULTI_SZ,
                                                                               (CONST BYTE*)propList.pStringValue->sz,
                                                                               propList.pStringValue->cbLength );
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_MULTI_SZ,
                                                                          (CONST BYTE*)propList.pStringValue->sz,
                                                                          propList.pStringValue->cbLength );
                            }
                        }

                        break;

                    case CLUSPROP_FORMAT_BINARY:
                        //
                        // Write the value to the cluster database.
                        //
                        if ( key != NULL )
                        {
                            if ( hXsaction )
                            {
                                status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                               key,
                                                                               rvn.PszName(),
                                                                               REG_BINARY,
                                                                               (CONST BYTE*)propList.pBinaryValue->rgb,
                                                                               propList.pStringValue->cbLength );
                            }
                            else
                            {
                                status = (*pClusterRegApis->pfnSetValue)( key,
                                                                          rvn.PszName(),
                                                                          REG_BINARY,
                                                                          (CONST BYTE*)propList.pBinaryValue->rgb,
                                                                          propList.pStringValue->cbLength );
                            }
                        }

                        break;

                    default:
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetNonPropertyTable: Property '%1!ls!' unknown format %2!d! specified.\n", pName->sz, propList.pSyntax->wFormat );
                        status = ERROR_INVALID_PARAMETER;
                        break;

                } // switch

                //
                // Close the key if we opened it.
                //
                if ( (rvn.PszKeyName() != NULL) &&
                     (key != NULL) )
                {
                    (*pClusterRegApis->pfnCloseKey)( key );
                }

            } // if/else:  zero length data

            //
            // Move the buffer past the value.
            //
            do {
                dataSize = sizeof(*propList.pValue)
                            + ALIGN_CLUSPROP( propList.pValue->cbLength );
                propList.pb += dataSize;
                inBufferSize -= dataSize;
            } while ( propList.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK );
            dataSize = sizeof( CLUSPROP_SYNTAX );
            propList.pb += dataSize;
            inBufferSize -= dataSize;
        }

        if ( status != ERROR_SUCCESS )
        {
            break;
        }
    }

    return(status);

} // ClRtlpSetNonPropertyTable



DWORD
WINAPI
ClRtlSetPropertyParameterBlock(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    IN OUT OPTIONAL LPBYTE pOutParams
    )

/*++

Routine Description:

    Write the properties as defined by the property table from the parameter
    block to the cluster database. Then parse the property list and write any
    properties that are not in the property table to the cluster database.

Arguments:

    hXsaction - Transaction key used when called from the cluster service.

    hkeyClusterKey - The opened registry key for this object's parameters.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pPropertyTable - Pointer to the property table to process.

    pInParams - Parameter block to set.

    pInPropertyList - Full property list.

    cbInPropertyListSize - Size of the input full property list.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameters block to copy pInParams to.  If specified,
        parameters will only be written if they are different between
        the two parameter blocks.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem;
    PVOID   key;
    LPWSTR *    ppszInValue;
    LPWSTR *    ppszOutValue;
    PBYTE * ppbInValue;
    PBYTE * ppbOutValue;
    PDWORD  pdwInValue;
    PDWORD  pdwOutValue;
    size_t  cbValLen;
    HRESULT hr;

    ULARGE_INTEGER *    pullInValue;
    ULARGE_INTEGER *    pullOutValue;

    CRegistryValueName      rvn;

    UNREFERENCED_PARAMETER( Reserved );

    //
    // If hKeyClusterKey is present then 'normal' functions must be present.
    //
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis->pfnCreateKey == NULL) ||
         (pClusterRegApis->pfnSetValue == NULL) ||
         (pClusterRegApis->pfnCloseKey == NULL) ||
         (pPropertyTable == NULL) ||
         (pInParams == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: hkeyClusterKey, pClusterRegApis->pfnCreateKey, pfnSetValue, or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // If hXsaction is present then 'local' functions must be present.
    //
    if ( (hXsaction != NULL ) &&
           ((pClusterRegApis->pfnLocalCreateKey == NULL) ||
           (pClusterRegApis->pfnLocalSetValue == NULL)
         ) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: pClusterRegApis->pfnLocalCreateKey or pfnLocalSetValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Parse the property table.
    //
    propertyItem = pPropertyTable;
    while ( propertyItem->Name != NULL )
    {
        //
        // Make sure we are allowed to set this item.
        //
        if ( propertyItem->Flags & RESUTIL_PROPITEM_READ_ONLY )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: Property '%1!ls!' is non-writable.\n", propertyItem->Name );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Use the wrapper class CRegistryValueName to parse value name to see if it
        // contains a backslash.
        //
        status = rvn.ScInit(  propertyItem->Name, propertyItem->KeyName );
        if ( status != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If the value resides at a different location, create the key.
        //
        if ( rvn.PszKeyName() != NULL )
        {

            DWORD disposition;

            if ( hXsaction != NULL )
            {
                status = (*pClusterRegApis->pfnLocalCreateKey)( hXsaction,
                                                                hkeyClusterKey,
                                                                rvn.PszKeyName(),
                                                                0,
                                                                KEY_ALL_ACCESS,
                                                                NULL,
                                                                &key,
                                                                &disposition );
            }
            else
            {
                status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                           rvn.PszKeyName(),
                                                           0,
                                                           KEY_ALL_ACCESS,
                                                           NULL,
                                                           &key,
                                                           &disposition );
            }

            if ( status != ERROR_SUCCESS )
            {
                return(status);
            }
        }
        else
        {
            key = hkeyClusterKey;
        }

        switch ( propertyItem->Format )
        {
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                pdwInValue = (PDWORD) &pInParams[propertyItem->Offset];
                pdwOutValue = (PDWORD) &pOutParams[propertyItem->Offset];

                //
                // Write the value to the cluster database.
                //
                if ( hXsaction != NULL )
                {
                    status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                   key,
                                                                   rvn.PszName(),
                                                                   REG_DWORD,
                                                                   (CONST BYTE*)pdwInValue,
                                                                   sizeof(DWORD) );
                }
                else
                {
                    status = (*pClusterRegApis->pfnSetValue)( key,
                                                              rvn.PszName(),
                                                              REG_DWORD,
                                                              (CONST BYTE*)pdwInValue,
                                                              sizeof(DWORD) );
                }

                //
                // Save the value to the output Parameter block.
                //
                if ( (status == ERROR_SUCCESS) &&
                     (pOutParams != NULL) )
                {
                    *pdwOutValue = *pdwInValue;
                }
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pullInValue = (ULARGE_INTEGER *) &pInParams[propertyItem->Offset];
                pullOutValue = (ULARGE_INTEGER *) &pOutParams[propertyItem->Offset];

                //
                // Write the value to the cluster database.
                //
                if ( hXsaction != NULL )
                {
                    status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                   key,
                                                                   rvn.PszName(),
                                                                   REG_QWORD,
                                                                   (CONST BYTE*)pullInValue,
                                                                   sizeof(ULARGE_INTEGER) );
                }
                else
                {
                    status = (*pClusterRegApis->pfnSetValue)( key,
                                                              rvn.PszName(),
                                                              REG_QWORD,
                                                              (CONST BYTE*)pullInValue,
                                                              sizeof(ULARGE_INTEGER) );
                }

                //
                // Save the value to the output Parameter block.
                //
                if ( (status == ERROR_SUCCESS) && (pOutParams != NULL) )
                {
                    pullOutValue->u = pullInValue->u;
                }
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszInValue = (LPWSTR *) &pInParams[propertyItem->Offset];
                ppszOutValue = (LPWSTR *) &pOutParams[propertyItem->Offset];

                //
                // If the data changed, write it and save it.
                // Do this even if only the case of the data changed.
                //
                if ( bForceWrite ||
                     (pOutParams == NULL) ||
                     (*ppszOutValue == NULL) ||
                     (*ppszInValue == NULL) || 
                     (wcscmp( *ppszInValue, *ppszOutValue ) != 0) )
                {

                    //
                    // Write the value to the cluster database.
                    //
                    if ( *ppszInValue != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           (propertyItem->Format == CLUSPROP_FORMAT_EXPAND_SZ
                                                                                 ? REG_EXPAND_SZ
                                                                                 : REG_SZ),
                                                                           (CONST BYTE*)*ppszInValue,
                                                                           ((DWORD) wcslen(*ppszInValue) + 1) * sizeof(WCHAR) );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      (propertyItem->Format == CLUSPROP_FORMAT_EXPAND_SZ
                                                                            ? REG_EXPAND_SZ
                                                                            : REG_SZ),
                                                                      (CONST BYTE*)*ppszInValue,
                                                                      ((DWORD) wcslen(*ppszInValue) + 1) * sizeof(WCHAR) );
                        }
                    }

                    //
                    // Save the value to the output Parameter block.
                    //
                    if ( (status == ERROR_SUCCESS) &&
                         (pOutParams != NULL) )
                    {
                        if ( *ppszOutValue != NULL )
                        {
                            LocalFree( *ppszOutValue );
                        }
                        if ( *ppszInValue == NULL )
                        {
                            *ppszOutValue = NULL;
                        }
                        else
                        {
                            cbValLen = (wcslen( *ppszInValue )+1) * sizeof(WCHAR);
                            *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, cbValLen );
                            if ( *ppszOutValue == NULL )
                            {
                                status = GetLastError();
                                ClRtlDbgPrint(
                                    LOG_CRITICAL,
                                    "ClRtlSetPropertyParameterBlock: error allocating memory for "
                                    "SZ value '%1!ls!' in parameter block for property '%2!ls!'.\n",
                                    *ppszInValue,
                                    propertyItem->Name );
                                break;
                            }
                            hr =  StringCbCopyW( *ppszOutValue, cbValLen, *ppszInValue );
                            if ( FAILED( hr ) )
                            {
                                status = HRESULT_CODE( hr );
                                break;
                            }
                        } // else:
                    } // if:
                } // if:
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
                ppszInValue = (LPWSTR *) &pInParams[propertyItem->Offset];
                pdwInValue = (PDWORD) &pInParams[propertyItem->Offset+sizeof(LPWSTR*)];
                ppszOutValue = (LPWSTR *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (PDWORD) &pOutParams[propertyItem->Offset+sizeof(LPWSTR*)];

                //
                // If the data changed, write it and save it.
                //
                if ( bForceWrite ||
                     (pOutParams == NULL) ||
                     (*ppszOutValue == NULL) ||
                     (*pdwInValue != *pdwOutValue) ||
                     (*ppszInValue == NULL) || 
                     (memcmp( *ppszInValue, *ppszOutValue, *pdwInValue ) != 0) )
                {

                    //
                    // Write the value to the cluster database.
                    //
                    if ( *ppszInValue != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_MULTI_SZ,
                                                                           (CONST BYTE*)*ppszInValue,
                                                                           *pdwInValue );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_MULTI_SZ,
                                                                      (CONST BYTE*)*ppszInValue,
                                                                      *pdwInValue );
                        }
                    }

                    //
                    // Save the value to the output Parameter block.
                    //
                    if ( (status == ERROR_SUCCESS) &&
                         (pOutParams != NULL) )
                    {
                        if ( *ppszOutValue != NULL )
                        {
                            LocalFree( *ppszOutValue );
                        }
                        if ( *ppszInValue == NULL )
                        {
                            *ppszOutValue = NULL;
                        }
                        else
                        {
                            *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, *pdwInValue );
                            if ( *ppszOutValue == NULL )
                            {
                                status = GetLastError();
                                *pdwOutValue = 0;
                                ClRtlDbgPrint(
                                    LOG_CRITICAL,
                                    "ClRtlSetPropertyParameterBlock: error allocating memory for "
                                    "MULTI_SZ value in parameter block for property '%1!ls!'.\n",
                                    propertyItem->Name );
                                break;
                            }
                            CopyMemory( *ppszOutValue, *ppszInValue, *pdwInValue );
                            *pdwOutValue = *pdwInValue;
                        }
                    }
                }
                break;

            case CLUSPROP_FORMAT_BINARY:
                ppbInValue = (PBYTE *) &pInParams[propertyItem->Offset];
                pdwInValue = (PDWORD) &pInParams[propertyItem->Offset+sizeof(LPWSTR*)];
                ppbOutValue = (PBYTE *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (PDWORD) &pOutParams[propertyItem->Offset+sizeof(PBYTE*)];

                //
                // If the data changed, write it and save it.
                //
                if ( bForceWrite ||
                     (pOutParams == NULL) ||
                     (*ppbOutValue == NULL) ||
                     (*pdwInValue != *pdwOutValue) ||
                     (*ppbInValue == NULL) || 
                     (memcmp( *ppbInValue, *ppbOutValue, *pdwInValue ) != 0) )
                {

                    //
                    // Write the value to the cluster database.
                    //
                    if ( *ppbInValue != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_BINARY,
                                                                           (CONST BYTE*)*ppbInValue,
                                                                           *pdwInValue );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_BINARY,
                                                                      (CONST BYTE*)*ppbInValue,
                                                                      *pdwInValue );
                        }
                    }

                    //
                    // Save the value to the output Parameter block.
                    //
                    if ( (status == ERROR_SUCCESS) &&
                         (pOutParams != NULL) )
                    {
                        if ( *ppbOutValue != NULL )
                        {
                            LocalFree( *ppbOutValue );
                        }
                        if ( *ppbInValue == NULL )
                        {
                            *ppbOutValue = NULL;
                        }
                        else
                        {
                            *ppbOutValue = (LPBYTE) LocalAlloc( LMEM_FIXED, *pdwInValue );
                            if ( *ppbOutValue == NULL )
                            {
                                status = GetLastError();
                                *pdwOutValue = 0;
                                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: error allocating memory for BINARY value in parameter block for property '%1!ls!'.\n", propertyItem->Name );
                                break;
                            }
                            CopyMemory( *ppbOutValue, *ppbInValue, *pdwInValue );
                            *pdwOutValue = *pdwInValue;
                        }
                    }
                }
                break;

            default:
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlSetPropertyParameterBlock: Property '%1!ls!' unknown format %2!d! specified.\n", propertyItem->Name, propertyItem->Format );
                status = ERROR_INVALID_PARAMETER;
                break;

        }

        //
        // Close the key if we opened it.
        //
        if ( rvn.PszKeyName() != NULL )
        {
            (*pClusterRegApis->pfnCloseKey)( key );
        }

        //
        // If an error occurred processing the property, cleanup and return.
        //
        if ( status != ERROR_SUCCESS )
        {
            return(status);
        }

        propertyItem++;

    }

    //
    // Now find any parameters that are not represented in the property
    // table. All of these extra properties will just be set without validation.
    //
    if ( (status == ERROR_SUCCESS) &&
         (pInPropertyList != NULL) )
    {
        status = ClRtlpSetNonPropertyTable( hXsaction,
                                            hkeyClusterKey,
                                            pClusterRegApis,
                                            pPropertyTable,
                                            NULL,
                                            pInPropertyList,
                                            cbInPropertyListSize );
    }

    return(status);

} // ClRtlSetPropertyParameterBlock



DWORD
WINAPI
ClRtlpSetPrivatePropertyList(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:



Arguments:

    hkeyClusterKey - The opened registry key for this resource's parameters.
        If not specified, the property list will only be validated.

    pClusterRegApis - Supplies a structure of function pointers for accessing
        the cluster database.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   inBufferSize;
    DWORD                   itemCount;
    DWORD                   dataSize;
    DWORD                   valueSize;
    CLUSPROP_BUFFER_HELPER  bufSizeTest;
    CLUSPROP_BUFFER_HELPER  buf;
    PCLUSPROP_PROPERTY_NAME pName;
    BOOL                    bZeroLengthData;
    CRegistryValueName      rvn;

    if ( (hkeyClusterKey != NULL) &&
         ( (pClusterRegApis->pfnSetValue == NULL) ||
           (pClusterRegApis->pfnCreateKey == NULL) ||
           (pClusterRegApis->pfnOpenKey == NULL) ||
           (pClusterRegApis->pfnCloseKey == NULL) ||
           (pClusterRegApis->pfnDeleteValue == NULL)
         ) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: pClusterRegApis->pfnCreateKey, pfnOpenKey, pfnSetValue, pfnCloseKey, or pfnDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }
    if ( pInPropertyList == NULL )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: pInPropertyList == NULL. Returning ERROR_INVALID_DATA\n" );
        return(ERROR_INVALID_DATA);
    }

    //
    // If hXsaction is present then 'local' functions must be present.
    //
    if ( (hXsaction != NULL ) &&
         ( (pClusterRegApis->pfnLocalCreateKey == NULL) ||
           (pClusterRegApis->pfnLocalDeleteValue == NULL)
         ) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: pClusterRegApis->pfnLocalCreateKey or pfnLocalDeleteValue == NULL. Returning ERROR_BAD_ARGUMENTS\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    buf.pb = (LPBYTE) pInPropertyList;
    inBufferSize = cbInPropertyListSize;

    //
    // Get the number of items in this list
    //
    if ( inBufferSize < sizeof(DWORD) )
    {
        return(ERROR_INSUFFICIENT_BUFFER);
    }
    itemCount = buf.pList->nPropertyCount;
    buf.pdw++;

    //
    // Parse the rest of the items in the buffer.
    //
    while ( itemCount-- )
    {
        pName = buf.pName;
        if ( inBufferSize < sizeof(*pName) )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }
        dataSize = sizeof(*pName) + ALIGN_CLUSPROP( pName->cbLength );
        if ( inBufferSize < dataSize + sizeof(CLUSPROP_VALUE) )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax of the property name is correct.
        //
        if ( pName->Syntax.dw != CLUSPROP_SYNTAX_NAME )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: syntax %1!d! not a name syntax.\n", pName->Syntax.dw );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // Verify that the length is correct for the string.
        //
        if ( pName->cbLength != (wcslen( pName->sz ) + 1) * sizeof(WCHAR) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "SetPrivatePropertyList: name is not a valid C string.\n" );
            return(ERROR_INVALID_DATA);
        }

        //
        // Move the buffer pointer to the property value.
        //
        buf.pb += dataSize;
        inBufferSize -= dataSize;

        //
        // Verify that the buffer is big enough to contain the value.
        //
        bufSizeTest.pb = buf.pb;
        dataSize = 0;
        do {
            valueSize = sizeof( *bufSizeTest.pValue )
                        + ALIGN_CLUSPROP( bufSizeTest.pValue->cbLength );
            bufSizeTest.pb += valueSize;
            dataSize += valueSize;
        } while ( bufSizeTest.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK );
        dataSize += sizeof( CLUSPROP_SYNTAX );
        if ( inBufferSize < dataSize )
        {
            return(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Verify that the syntax type is SPECIAL.
        //
        if ( buf.pSyntax->wType != CLUSPROP_TYPE_LIST_VALUE )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: Property '%1!ls!' type CLUSPROP_TYPE_LIST_VALUE (%2!d!) expected, was %3!d!.\n", pName->sz, CLUSPROP_TYPE_LIST_VALUE, buf.pSyntax->wType );
            return(ERROR_INVALID_PARAMETER);
        }

        //
        // If the value is not specified, delete the property.
        //
        bZeroLengthData = ( buf.pValue->cbLength == 0 );
        if ( bZeroLengthData )
        {
            if ( hkeyClusterKey != NULL )
            {
                PVOID key = NULL;

                //
                // Use the wrapper class CRegistryValueName to parse value name to see if it
                // contains a backslash.
                //
                status = rvn.ScInit( pName->sz, NULL );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }

                //
                // If the value resides at a different location, open the key.
                //
                if ( rvn.PszKeyName() != NULL )
                {
                    status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                             rvn.PszKeyName(),
                                                             KEY_ALL_ACCESS,
                                                             &key);

                    if ( status != ERROR_SUCCESS )
                    {
                        break;
                    }

                }
                else
                {
                    key = hkeyClusterKey;
                }

                if ( hXsaction != NULL )
                {
                    status = (*pClusterRegApis->pfnLocalDeleteValue)(
                                                hXsaction,
                                                key,
                                                rvn.PszName() );
                }
                else
                {
                    status = (*pClusterRegApis->pfnDeleteValue)(
                                                key,
                                                rvn.PszName() );
                }

                //
                // If the property doesn't exist in the
                // cluster database, fix the status.
                //
                if ( status == ERROR_FILE_NOT_FOUND )
                {
                    status = ERROR_SUCCESS;
                } // if:  property already doesn't exist

                //
                // Close the key if we opened it.
                //
                if ( (rvn.PszKeyName() != NULL) &&
                     (key != NULL) )
                {
                    (*pClusterRegApis->pfnCloseKey)( key );
                }

            } // if:  key specified
        }
        else
        {
            PVOID key = NULL;
            DWORD disposition;

            if ( hkeyClusterKey != NULL )
            {
                //
                // Use the wrapper class CRegistryValueName to parse value name to see if it
                // contains a backslash.
                //
                status = rvn.ScInit( pName->sz, NULL );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }

                //
                // If the value resides at a different location, open the key.
                //
                if ( rvn.PszKeyName() != NULL )
                {

                    if ( hXsaction != NULL )  {
                        status = (*pClusterRegApis->pfnLocalCreateKey)(
                                                                   hXsaction,
                                                                   hkeyClusterKey,
                                                                   rvn.PszKeyName(),
                                                                   0,
                                                                   KEY_ALL_ACCESS,
                                                                   NULL,
                                                                   &key,
                                                                   &disposition);

                    }
                    else
                    {
                        status = (*pClusterRegApis->pfnCreateKey)( hkeyClusterKey,
                                                                   rvn.PszKeyName(),
                                                                   0,
                                                                   KEY_ALL_ACCESS,
                                                                   NULL,
                                                                   &key,
                                                                   &disposition);
                    }

                    if ( status != ERROR_SUCCESS )
                    {
                        break;
                    }

                }
                else
                {
                    key = hkeyClusterKey;
                }
            }

            //
            // Parse the property and set it in the cluster database
            //
            switch ( buf.pSyntax->wFormat )
            {
                case CLUSPROP_FORMAT_DWORD:
                case CLUSPROP_FORMAT_LONG:
                    //
                    // Verify the length of the value.
                    //
                    if ( buf.pDwordValue->cbLength != sizeof(DWORD) )
                    {
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: Property '%1!ls!' length %2!d! not DWORD or LONG length.\n", pName->sz, buf.pDwordValue->cbLength );
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_DWORD,
                                                                           (CONST BYTE*)&buf.pDwordValue->dw,
                                                                           sizeof(DWORD) );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_DWORD,
                                                                      (CONST BYTE*)&buf.pDwordValue->dw,
                                                                      sizeof(DWORD));
                        }
                    }
                    break;

                case CLUSPROP_FORMAT_ULARGE_INTEGER:
                case CLUSPROP_FORMAT_LARGE_INTEGER:
                    //
                    // Verify the length of the value.
                    //
                    if ( buf.pULargeIntegerValue->cbLength != sizeof(ULARGE_INTEGER) )
                    {
                        ClRtlDbgPrint(LOG_CRITICAL,
                                      "ClRtlpSetPrivatePropertyList: Property '%1!ls!' length "
                                      "%2!d! not ULARGE_INTEGER or LARGE_INTEGER length.\n",
                                      pName->sz,
                                      buf.pULargeIntegerValue->cbLength );
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)(
                                         hXsaction,
                                         key,
                                         rvn.PszName(),
                                         REG_QWORD,
                                         (CONST BYTE*)&buf.pULargeIntegerValue->li.QuadPart,
                                         sizeof(ULARGE_INTEGER) );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)(
                                         key,
                                         rvn.PszName(),
                                         REG_QWORD,
                                         (CONST BYTE*)&buf.pULargeIntegerValue->li.QuadPart,
                                         sizeof(ULARGE_INTEGER));
                        }
                    }
                    break;

               case CLUSPROP_FORMAT_SZ:
               case CLUSPROP_FORMAT_EXPAND_SZ:
                    //
                    // Verify the length of the value.
                    //
                    if ( buf.pStringValue->cbLength != (wcslen( buf.pStringValue->sz ) + 1) * sizeof(WCHAR) )
                    {
                        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpSetPrivatePropertyList: Property '%1!ls!' length %2!d! doesn't match null-term. length.\n", pName->sz, buf.pStringValue->cbLength );
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           (buf.pSyntax->wFormat == CLUSPROP_FORMAT_EXPAND_SZ
                                                                                ? REG_EXPAND_SZ
                                                                                : REG_SZ),
                                                                           (CONST BYTE*)buf.pStringValue->sz,
                                                                           buf.pStringValue->cbLength);
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      (buf.pSyntax->wFormat == CLUSPROP_FORMAT_EXPAND_SZ
                                                                            ? REG_EXPAND_SZ
                                                                            : REG_SZ),
                                                                      (CONST BYTE*)buf.pStringValue->sz,
                                                                      buf.pStringValue->cbLength);
                        }
                    }
                    break;

                case CLUSPROP_FORMAT_MULTI_SZ:
                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_MULTI_SZ,
                                                                           (CONST BYTE*)buf.pStringValue->sz,
                                                                           buf.pStringValue->cbLength );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_MULTI_SZ,
                                                                      (CONST BYTE*)buf.pStringValue->sz,
                                                                      buf.pStringValue->cbLength );
                        }
                    }
                    break;

                case CLUSPROP_FORMAT_BINARY:
                    //
                    // Write the value to the cluster database.
                    //
                    if ( key != NULL )
                    {
                        if ( hXsaction != NULL )
                        {
                            status = (*pClusterRegApis->pfnLocalSetValue)( hXsaction,
                                                                           key,
                                                                           rvn.PszName(),
                                                                           REG_BINARY,
                                                                           (CONST BYTE*)buf.pBinaryValue->rgb,
                                                                           buf.pBinaryValue->cbLength );
                        }
                        else
                        {
                            status = (*pClusterRegApis->pfnSetValue)( key,
                                                                      rvn.PszName(),
                                                                      REG_BINARY,
                                                                      (CONST BYTE*)buf.pBinaryValue->rgb,
                                                                      buf.pBinaryValue->cbLength );
                        }
                    }
                    break;

                default:
                    status = ERROR_INVALID_PARAMETER; // not tested

            } // switch

            //
            // Close the key if we opened it.
            //
            if ( (rvn.PszKeyName() != NULL) &&
                 (key != NULL) )
            {
                (*pClusterRegApis->pfnCloseKey)( key );
            }

        } // if/else:  zero length data

        if ( status != ERROR_SUCCESS )
        {
            break;
        }

        //
        // Move the buffer past the value.
        //
        buf.pb += dataSize;
        inBufferSize -= dataSize;

    }

    return(status);

} // ClRtlpSetPrivatePropertyList



DWORD
WINAPI
ClRtlpFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    IN BOOL bReturnExpandedValue
    )

/*++

Routine Description:

    Finds the specified string property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

    bReturnExpandedValue - TRUE = return expanded value if one is present,
        FALSE = return the first value.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_FILE_NOT_FOUND -

    ERROR_NOT_ENOUGH_MEMORY -

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    LPWSTR                  listValueData;
    DWORD                   listByteLength;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a string property.
            //
            if ( (props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_SZ) &&
                 (props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_EXPAND_SZ) )
            {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpFindSzProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list string syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it
            // and copy the value in.
            //
            if ( pszPropertyValue != NULL )
            {
                //
                // If caller wants the expanded value, look at any
                // additional values in the value list to see if one
                // was returned.
                //
                listValueData = props.pStringValue->sz;
                listByteLength = props.pStringValue->cbLength;
                if ( bReturnExpandedValue )
                {
                    //
                    // Skip past values in the value list looking for
                    // an expanded string value.
                    //
                    while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                            (cbPropertyListSize > 0) )
                    {
                        byteCount = sizeof(*props.pValue) + ALIGN_CLUSPROP(listByteLength);
                        cbPropertyListSize -= byteCount;
                        props.pb += byteCount;
                        if ( props.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_EXPANDED_SZ )
                        {
                            listValueData = props.pStringValue->sz;
                            listByteLength = props.pStringValue->cbLength;
                            break;
                        }
                    }
                }

                //
                // Allocate a buffer for the string value and
                // copy the value from the property list.
                //
                valueData = (LPWSTR) LocalAlloc( LMEM_FIXED, listByteLength );
                if ( valueData == NULL )
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                CopyMemory( valueData, listValueData, listByteLength );
                *pszPropertyValue = valueData;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list (one or more values + endmark).
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= byteCount;
                props.pb += byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlpFindSzProperty



DWORD
WINAPI
ClRtlFindDwordProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    )

/*++

Routine Description:

    Finds the specified DWORD property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pdwPropertyValue - the matching DWORD value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_FILE_NOT_FOUND -

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a dword property.
            //
            if ( props.pDwordValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_DWORD )  {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlFindDwordProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list DWORD syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, copy it into their output buffer
            //
            if ( pdwPropertyValue )
            {
                *pdwPropertyValue = props.pDwordValue->dw;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindDwordProperty

DWORD
WINAPI
ClRtlFindLongProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValue
    )
/*++

Routine Description:

    Finds the specified LONG in the Value List buffer pointed at by Buffer.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    plPropertyValue - the matching long value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_FILE_NOT_FOUND -

    A Win32 error code on failure.

--*/
{
    CLUSPROP_BUFFER_HELPER  props;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            (cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a long property.
            //
            if ( props.pLongValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_DWORD )  {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlFindLongProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list LONG syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, copy it into their output buffer
            //
            if ( plPropertyValue)
            {
                *plPropertyValue = props.pLongValue->l;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindLongProperty


DWORD
WINAPI
ClRtlFindULargeIntegerProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT PULARGE_INTEGER pullPropertyValue
    )

/*++

Routine Description:

    Finds the specified ULARGE_INTEGER property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pullPropertyValue - the matching ULARGE_INTEGER value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_FILE_NOT_FOUND -

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a LARGE INT property.
            //
            if ( props.pULargeIntegerValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER )  {
                ClRtlDbgPrint(LOG_CRITICAL,
                              "ClRtlFindULargeIntegerProperty: Property '%1!ls!' syntax "
                              "(%2!d!, %3!d!) not proper list ULARGE_INTEGER syntax.\n",
                              pszPropertyName,
                              props.pSyntax->wType,
                              props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, copy it into their output
            // buffer. Don't assume that props is aligned; use the double
            // DWORD copy variant.
            //
            if ( pullPropertyValue )
            {
                pullPropertyValue->u = props.pULargeIntegerValue->li.u;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindULargeIntegerProperty


DWORD
WINAPI
ClRtlFindLargeIntegerProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT PLARGE_INTEGER pllPropertyValue
    )

/*++

Routine Description:

    Finds the specified LARGE_INTEGER property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pllPropertyValue - the matching ULARGE_INTEGER value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_FILE_NOT_FOUND -

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a large int property.
            //
            if ( props.pLargeIntegerValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_LARGE_INTEGER )  {
                ClRtlDbgPrint(LOG_CRITICAL,
                              "ClRtlFindLargeIntegerProperty: Property '%1!ls!' syntax "
                              "(%2!d!, %3!d!) not proper list ULARGE_INTEGER syntax.\n",
                              pszPropertyName,
                              props.pSyntax->wType,
                              props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, copy it into their output
            // buffer. Don't assume that props is aligned; use the double
            // DWORD copy variant.
            //
            if ( pllPropertyValue )
            {
                pllPropertyValue->u = props.pLargeIntegerValue->li.u;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindLargeIntegerProperty


DWORD
WINAPI
ClRtlFindBinaryProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified binary property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pbPropertyValue - the matching binary value found.

    pcbPropertyValueSize - the length of the matching binary value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_NOT_ENOUGH_MEMORY -

    ERROR_FILE_NOT_FOUND -

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    PBYTE                   valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a binary property.
            //
            if ( props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_BINARY )
            {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpFindBinaryProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list binary syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pbPropertyValue )
            {
                valueData = (PBYTE) LocalAlloc( LMEM_FIXED, props.pBinaryValue->cbLength );
                if ( !valueData )
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                CopyMemory( valueData, props.pBinaryValue->rgb, props.pBinaryValue->cbLength );
                *pbPropertyValue = valueData;
            }

            //
            // If caller wants the value size, copy it now
            //
            if ( pcbPropertyValueSize )
            {
                *pcbPropertyValueSize = props.pBinaryValue->cbLength;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindBinaryProperty



DWORD
WINAPI
ClRtlFindMultiSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified multiple string property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching multiple string value found.

    pcbPropertyValueSize - the length of the matching multiple string value found.

Return Value:

    ERROR_SUCCESS if successful.

    ERROR_INVALID_DATA -

    ERROR_NOT_ENOUGH_MEMORY -

    ERROR_FILE_NOT_FOUND -

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER  props;
    LPWSTR                  valueData;
    DWORD                   itemCount;
    DWORD                   byteCount;

    props.pb = (LPBYTE) pPropertyList;
    itemCount = *(props.pdw++);
    cbPropertyListSize -= sizeof(DWORD);

    while ( itemCount-- &&
            ((LONG)cbPropertyListSize > 0) )
    {
        //
        // If we found the specified property, validate the entry and return
        // the value to the caller.
        //
        if ( (props.pName->Syntax.dw == CLUSPROP_SYNTAX_NAME) &&
             (lstrcmpiW( props.pName->sz, pszPropertyName ) == 0) )
        {
            //
            // Calculate the size of the name and move to the value.
            //
            byteCount = ALIGN_CLUSPROP(props.pName->cbLength);
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Make sure this is a multi-sz property.
            //
            if ( props.pStringValue->Syntax.dw != CLUSPROP_SYNTAX_LIST_VALUE_MULTI_SZ )
            {
                ClRtlDbgPrint( LOG_CRITICAL, "ClRtlpFindMultiSzProperty: Property '%1!ls!' syntax (%2!d!, %3!d!) not proper list MultiSz syntax.\n", pszPropertyName, props.pSyntax->wType, props.pSyntax->wFormat );
                return(ERROR_INVALID_DATA);
            }

            //
            // If caller wants the value, allocate a buffer for it.
            //
            if ( pszPropertyValue )
            {
                valueData = (LPWSTR) LocalAlloc( LMEM_FIXED, props.pMultiSzValue->cbLength );
                if ( !valueData )
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                CopyMemory( valueData, props.pBinaryValue->rgb, props.pMultiSzValue->cbLength );
                *pszPropertyValue = valueData;
            }

            //
            // If caller wants the value size, copy it now
            //
            if ( pcbPropertyValueSize )
            {
                *pcbPropertyValueSize = props.pMultiSzValue->cbLength;
            }

            //
            // We found the property so return success.
            //
            return(ERROR_SUCCESS);

        }
        else
        {
            //
            // Skip the name (value header + size of data).
            //
            byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
            cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
            props.pb += sizeof(*props.pValue) + byteCount;

            //
            // Skip it's value list and endmark.
            //
            while ( (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) &&
                    (cbPropertyListSize > 0) )
            {
                byteCount = ALIGN_CLUSPROP(props.pValue->cbLength);
                cbPropertyListSize -= sizeof(*props.pValue) + byteCount;
                props.pb += sizeof(*props.pValue) + byteCount;
            }
            cbPropertyListSize -= sizeof(*props.pSyntax);
            props.pb += sizeof(*props.pSyntax);
        }
    }

    return(ERROR_FILE_NOT_FOUND);

} // ClRtlFindMultiSzProperty



DWORD
WINAPI
ClRtlGetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    )

/*++

Routine Description:

    Queries a REG_BINARY or REG_MULTI_SZ value out of the cluster
    database and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    ppbOutValue - Supplies the address of a pointer in which to return the value.

    pcbOutValueSize - Supplies the address of a DWORD in which to return the
        size of the value.

    pfnQueryValue - Address of QueryValue function.

Return Value:

    ERROR_SUCCESS - The value was read successfully.

    ERROR_BAD_ARGUMENTS -

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory for the value.

    Win32 error code - The operation failed.

--*/

{
    LPBYTE value = NULL;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;

    PVOID key = NULL;
    CRegistryValueName rvn;

    //
    // Initialize the output parameters.
    //
    *ppbOutValue = NULL;
    *pcbOutValueSize = 0;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetBinaryValue: hkeyClusterKey, pClusterRegApis, or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
        return(ERROR_BAD_ARGUMENTS);
    }

    //
    // Use the wrapper class CRegistryValueName to parse value name to see if it
    // contains a backslash.
    //
    status = rvn.ScInit( pszValueName, NULL );
    if ( status != ERROR_SUCCESS )
    {
       return status;
    }

    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL )
    {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetBinaryValue: pClusterRegApis->pfnOpenKey or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
            return(ERROR_BAD_ARGUMENTS);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);

    }
    else
    {
        key = hkeyClusterKey;
    }

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                rvn.PszName(),
                                                &valueType,
                                                NULL,
                                                &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) )
    {
        goto Cleanup;
    }

    //if the size is zero, just return
    if (valueSize == 0)
    {
        goto Cleanup;
    }
    //
    // Allocate a buffer to read the value into.
    //
    value = (LPBYTE) LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL )
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Read the value from the cluster database.
    //
    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                pszValueName,
                                                &valueType,
                                                (LPBYTE)value,
                                                &valueSize );

    if ( status != ERROR_SUCCESS )
    {
        LocalFree( value );
    }
    else
    {
        *ppbOutValue = value;
        *pcbOutValueSize = valueSize;
    }

Cleanup:

    //
    // Close the key if we opened it.
    //
    if ( (rvn.PszKeyName() != NULL) &&
         (key != NULL) )
    {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(status);

} // ClRtlGetBinaryValue



LPWSTR
WINAPI
ClRtlGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    )

/*++

Routine Description:

    Queries a REG_SZ or REG_EXPAND_SZ value out of the cluster database
    and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    pfnQueryValue - Address of QueryValue function.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR value;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;
    PVOID key = NULL;
    CRegistryValueName rvn;

    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ||
         (pClusterRegApis->pfnQueryValue == NULL) )
    {
        ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetSzValue: hkeyClusterKey, pClusterRegApis, or pClusterRegApis->pfnQueryValue == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
        SetLastError(ERROR_BAD_ARGUMENTS);
        return(NULL);
    }

    //
    // Use the wrapper class CRegistryValueName to parse value name to see if it
    // contains a backslash.
    //
    status = rvn.ScInit( pszValueName, NULL );
    if ( status != ERROR_SUCCESS )
    {
        SetLastError(status);
        return(NULL);
    }
    //
    // If the value resides at a different location, open the key.
    //
    if ( rvn.PszKeyName() != NULL )
    {
        if ( (pClusterRegApis->pfnOpenKey == NULL) ||
             (pClusterRegApis->pfnCloseKey == NULL) )
        {
            ClRtlDbgPrint( LOG_CRITICAL, "ClRtlGetSzValue: pClusterRegApis->pfnOpenKey or pfnCloseKey == NULL. Returning ERROR_BAD_ARGUMENTS.\n" );
            SetLastError(ERROR_BAD_ARGUMENTS);
            return(NULL);
        }

        status = (*pClusterRegApis->pfnOpenKey)( hkeyClusterKey,
                                                 rvn.PszKeyName(),
                                                 KEY_READ,
                                                 &key);

    }
    else
    {
        key = hkeyClusterKey;
    }

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                rvn.PszName(),
                                                &valueType,
                                                NULL,
                                                &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) )
    {
        SetLastError( status );
        value = NULL;
        goto Cleanup;
    }

    //
    // Add on the size of the null terminator.
    //
    valueSize += sizeof(UNICODE_NULL);

    //
    // Allocate a buffer to read the string into.
    //
    value = (PWSTR) LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        value = NULL;
        goto Cleanup;
    }

    //
    // Read the value from the cluster database.
    //
    status = (*pClusterRegApis->pfnQueryValue)( key,
                                                rvn.PszName(),
                                                &valueType,
                                                (LPBYTE)value,
                                                &valueSize );
    if ( status != ERROR_SUCCESS )
    {
        LocalFree( value );
        value = NULL;
    }
    else if ( (valueType != REG_SZ) &&
              (valueType != REG_EXPAND_SZ) &&
              (valueType != REG_MULTI_SZ) )
    {
        status = ERROR_INVALID_PARAMETER;
        LocalFree( value );
        SetLastError( status );
        value = NULL;
    }

Cleanup:

    //
    // Close the key if we opened it.
    //
    if ( (rvn.PszKeyName() != NULL) &&
         (key != NULL) )
    {
        (*pClusterRegApis->pfnCloseKey)( key );
    }

    return(value);

} // ClRtlGetSzValue



DWORD
WINAPI
ClRtlDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to return.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    ERROR_SUCCESS - Parameter block duplicated successfully.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    LPWSTR *    ppszInValue;
    LPDWORD     pdwInValue;
    LPWSTR *    ppszOutValue;
    LPDWORD     pdwOutValue;
    size_t      cbValLen;
    HRESULT     hr;

    ULARGE_INTEGER *    pullInValue;
    ULARGE_INTEGER *    pullOutValue;

    //
    // loop through the entries in the property table
    //
    while ( propertyItem->Name != NULL )
    {
        switch ( propertyItem->Format )
        {
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_LONG:
                pdwInValue = (LPDWORD) &pInParams[propertyItem->Offset];
                pdwOutValue = (LPDWORD) &pOutParams[propertyItem->Offset];
                *pdwOutValue = *pdwInValue;
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_LARGE_INTEGER:
                pullInValue = (ULARGE_INTEGER *) &pInParams[propertyItem->Offset];
                pullOutValue = (ULARGE_INTEGER *) &pOutParams[propertyItem->Offset];
                pullOutValue->QuadPart = pullInValue->QuadPart;
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
                ppszInValue = (LPWSTR *) &pInParams[propertyItem->Offset];
                ppszOutValue = (LPWSTR *) &pOutParams[propertyItem->Offset];
                if ( *ppszInValue == NULL )
                {
                    if ( propertyItem->lpDefault != NULL )
                    {
                        cbValLen = (wcslen( (LPCWSTR) propertyItem->lpDefault ) + 1) * sizeof(WCHAR);
                        *ppszOutValue = (LPWSTR) LocalAlloc(
                                                     LMEM_FIXED,
                                                     cbValLen
                                                     );
                        if ( *ppszOutValue == NULL )
                        {
                            status = GetLastError();
                        }
                        else
                        {
                            hr = StringCbCopyW( *ppszOutValue, cbValLen, (LPCWSTR) propertyItem->lpDefault );
                            if ( FAILED( hr ) )
                            {
                                status = HRESULT_CODE( hr );
                                break;
                            }
                        }
                    }
                    else
                    {
                        *ppszOutValue = NULL;
                    }
                }
                else
                {
                    cbValLen = (wcslen( *ppszInValue ) + 1) * sizeof(WCHAR);
                    *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, cbValLen );
                    if ( *ppszOutValue == NULL )
                    {
                        status = GetLastError();
                    }
                    else
                    {
                        hr = StringCbCopyW( *ppszOutValue, cbValLen, *ppszInValue );
                        if ( FAILED( hr ) )
                        {
                            status = HRESULT_CODE( hr );
                            break;
                        }
                    }
                }
                break;

            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppszInValue = (LPWSTR *) &pInParams[propertyItem->Offset];
                pdwInValue = (LPDWORD) &pInParams[propertyItem->Offset + sizeof(LPCWSTR)];
                ppszOutValue = (LPWSTR *) &pOutParams[propertyItem->Offset];
                pdwOutValue = (LPDWORD) &pOutParams[propertyItem->Offset + sizeof(LPWSTR)];
                if ( *ppszInValue == NULL )
                {
                    if ( propertyItem->lpDefault != NULL )
                    {
                        *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, propertyItem->Minimum );
                        if ( *ppszOutValue == NULL )
                        {
                            status = GetLastError();
                            *pdwOutValue = 0;
                        }
                        else
                        {
                            *pdwOutValue = propertyItem->Minimum;
                            CopyMemory( *ppszOutValue, (const PVOID) propertyItem->lpDefault, *pdwOutValue );
                        }
                    }
                    else
                    {
                        *ppszOutValue = NULL;
                        *pdwOutValue = 0;
                    }
                }
                else
                {
                    *ppszOutValue = (LPWSTR) LocalAlloc( LMEM_FIXED, *pdwInValue );
                    if ( *ppszOutValue == NULL )
                    {
                        status = GetLastError();
                        *pdwOutValue = 0;
                    }
                    else
                    {
                        CopyMemory( *ppszOutValue, *ppszInValue, *pdwInValue );
                        *pdwOutValue = *pdwInValue;
                    }
                }
                break;
        }
        propertyItem++;
    }

    //
    // If an error occurred, make sure we don't leak memory.
    //
    if ( status != ERROR_SUCCESS )
    {
        ClRtlFreeParameterBlock( pOutParams, pInParams, pPropertyTable );
    }

    return(status);

} // ClRtlDupParameterBlock



void
WINAPI
ClRtlFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to free.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    None.

--*/

{
    PRESUTIL_PROPERTY_ITEM  propertyItem = pPropertyTable;
    LPCWSTR *   ppszInValue;
    LPWSTR *    ppszOutValue;

    while ( propertyItem->Name != NULL )
    {
        switch ( propertyItem->Format )
        {
            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                ppszInValue = (LPCWSTR *) &pInParams[propertyItem->Offset];
                ppszOutValue = (LPWSTR *) &pOutParams[propertyItem->Offset];

                if ( (pInParams == NULL) || (*ppszInValue != *ppszOutValue) )
                {
                    LocalFree( *ppszOutValue );
                }
                break;
        }
        propertyItem++;
    }

} // ClRtlFreeParameterBlock



DWORD
WINAPI
ClRtlMarshallPropertyTable(
    IN PRESUTIL_PROPERTY_ITEM    pPropertyTable,
    IN OUT  DWORD                dwSize,
    IN OUT  LPBYTE               pBuffer,
    OUT     DWORD                *Required
    )
/*++

Routine Description

    Rohit (rjain) : It marshalls the pPropertyTable into a buffer so that the
    buffer can be passed as an argument to the NmUpdatePerformFixups2 handler

    This function assumes that the value field in all the elements of the
    table is 0.

    The marshalled buffer has the following format:

    +-----------------------------------------------+
    |   Count of marshalled prop table items        |
    +-----------------------------------------------+
    |   Number of bytes in prop name string         |
    +-----------------------------------------------+
    |   Prop Name string (variable length)          |
    +-----------------------------------------------+
    |   Number of bytes in key name (can be zero)   |
    +-----------------------------------------------+
    |   Key name string (optional; variable length  |
    +-----------------------------------------------+
    |   Prop Format                                 |
    +-----------------------------------------------+
    |   Default Value                               |
    +-----------------------------------------------+
    |   Min                                         |
    +-----------------------------------------------+
    |   Max                                         |
    +-----------------------------------------------+
    |   Flags                                       |
    +-----------------------------------------------+
    |   Offset                                      |
    +-----------------------------------------------+

    The processing for the strings don't force the next entry to be DWORD
    aligned.

Arguments
    pPropertyTable - This table is converted to buffer

    dwSize         - size in bytes of the pbuffer supplied

    pbuffer        - byte array into which pPropertyTable is copied

    Required       - number of bytes required

Return Value
    returns
        ERROR_SUCCESS on success,
        ERROR_MORE_DATA if the size of pbuffer is insufficient

++*/

{
    DWORD                   dwPosition=sizeof(DWORD);
    PRESUTIL_PROPERTY_ITEM  pPropertyItem=pPropertyTable;
    BOOL                    copying = TRUE;
    DWORD                   items=0;
    DWORD                   dwNameLength;
    DWORD                   dwKeyLength;
    DWORD                   status=ERROR_SUCCESS;

    *Required=sizeof(DWORD); // first DWORD will contain the number of items in PropertyTable
    while(pPropertyItem->Name != NULL)
    {
        items++;
        dwNameLength=((DWORD) wcslen(pPropertyItem->Name)+1)*sizeof(WCHAR);
        if(pPropertyItem->KeyName==NULL)
        {
            dwKeyLength=0;
        }
        else
        {
            dwKeyLength=((DWORD) wcslen(pPropertyItem->KeyName)+1)*sizeof(WCHAR);
        }

        //
        // total is the lengths of the strings plus 2 DWORDs for string counts
        // and 6 DWORDs for the remaining values
        //
        *Required+=(dwNameLength+dwKeyLength+8*sizeof(DWORD));

        // if pbufer is smaller than needed, copying is turned off
        // and only the required size is calculated
        if ((copying && (dwSize < *Required)))
            copying=FALSE;

        if(copying)
        {

            // copy length of name and then the name itself

            CopyMemory(pBuffer+dwPosition,&dwNameLength,sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,pPropertyItem->Name,dwNameLength);
            dwPosition+=dwNameLength;

            //copy length of keyname and then the keyname itself

            CopyMemory(pBuffer+dwPosition,&dwKeyLength,sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));
            if(dwKeyLength!=0)
            {
                CopyMemory(pBuffer+dwPosition,pPropertyItem->KeyName,dwKeyLength);
                dwPosition+=dwKeyLength;
            }
            //now copy remaining fields
            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Format),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            // ISSUE-2000/11/21-charlwi
            // this needs to be fixed for Large Int properties since they
            // don't store their values in Default, Minimum, and Maximum.

            //IMP: the default value is always assumed to be a DWORD. This is
            // because the values for properties in PropertyTable are stored
            // in a seperate parameter list. See ClRtlSetPropertyTable
            //
            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Default),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Minimum),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Maximum),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Flags),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));

            CopyMemory(pBuffer+dwPosition,&(pPropertyItem->Offset),sizeof(DWORD));
            dwPosition+=(sizeof(DWORD));
        }
        //
        // Advance to the next property.
        //
        pPropertyItem++;
    }
    if(copying)
    {
        CopyMemory(pBuffer,&items,sizeof(DWORD));
        status=ERROR_SUCCESS;
    }
    else
    {
        status=ERROR_MORE_DATA;
    }

    return status;

} // MarshallPropertyTable



DWORD
WINAPI
ClRtlUnmarshallPropertyTable(
    IN OUT PRESUTIL_PROPERTY_ITEM   *ppPropertyTable,
    IN LPBYTE                       pBuffer
    )

/*++

Routine Description
    Rohit (rjain) : It unmarshalls the pBuffer into a RESUTIL_PROPERTY_ITEM table

Arguments
    pPropertyTable - This is the resulting table

    pbuffer        - marshalled byte array
Return Value
    returns
        ERROR_SUCCESS on success,
        Win32 error on error
++*/
{
    PRESUTIL_PROPERTY_ITEM          propertyItem;
    DWORD                           items;
    DWORD                           dwPosition=sizeof(DWORD);
    DWORD                           dwLength;
    DWORD                           i;
    DWORD                           status=ERROR_SUCCESS;

    if((pBuffer==NULL) ||(ppPropertyTable==NULL))
    {
        ClRtlDbgPrint( LOG_CRITICAL, "[ClRtl] Uncopy PropertyTable: Bad Argumnets\r\n");
        return ERROR_BAD_ARGUMENTS;
    }

    CopyMemory(&items,pBuffer,sizeof(DWORD));
    *ppPropertyTable=(PRESUTIL_PROPERTY_ITEM)LocalAlloc(LMEM_FIXED,(items+1)*sizeof(RESUTIL_PROPERTY_ITEM));
    if(*ppPropertyTable == NULL)
    {
        status=GetLastError();
        goto Cleanup;
    }
    propertyItem=*ppPropertyTable;
    for(i=0; i<items; i++)
    {

        CopyMemory(&dwLength,pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=sizeof(DWORD);
        propertyItem->Name = NULL;
        propertyItem->Name=(LPWSTR)LocalAlloc(LMEM_FIXED,dwLength);
        if(propertyItem->Name == NULL)
        {
            status=GetLastError();
            goto Cleanup;
        }
        CopyMemory(propertyItem->Name,pBuffer+dwPosition,dwLength);
        dwPosition+=dwLength;

        CopyMemory(&dwLength,pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=sizeof(DWORD);
        propertyItem->KeyName=NULL;
        if (dwLength!=0)
        {
            propertyItem->KeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,dwLength);
            if(propertyItem->KeyName == NULL)
            {
                status=GetLastError();
                goto Cleanup;
            }
            CopyMemory(propertyItem->KeyName,pBuffer+dwPosition,dwLength);
            dwPosition+=dwLength;
        }
        //now rest of the fields - all DWORDS
        CopyMemory(&(propertyItem->Format),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        // ISSUE-2000/11/21-charlwi
        // this needs to be fixed for Large Int properties since they don't
        // store their values in Default, Minimum, and Maximum.

        // IMP: the default value is always passed as a  DWORD. This is
        // because the values for properties in PropertyTable are stored
        // in a seperate parameter list so the value here won't be used.
        // See ClRtlSetPropertyTable
        //

        CopyMemory(&(propertyItem->Default),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Minimum),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Maximum),pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Flags),  pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        CopyMemory(&(propertyItem->Offset), pBuffer+dwPosition,sizeof(DWORD));
        dwPosition+=(sizeof(DWORD));

        propertyItem++;
    } // for:

    // the last entry is marked NULL to indicate the end of table
    propertyItem->Name=NULL;

Cleanup:

    return status;

} // UnmarshallPropertyTable



LPWSTR
WINAPI
ClRtlExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    )

/*++

Routine Description:

    Expands environment strings and returns an allocated buffer containing
    the result.

Arguments:

    pszSrc - Source string to expand.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    DWORD   status;
    DWORD   cchDst = 0;
    LPWSTR  pszDst = NULL;

    //
    // Get the required length of the output string.
    //
    cchDst = ExpandEnvironmentStringsW( pszSrc, NULL, 0 );
    if ( cchDst == 0 )
    {
        status = GetLastError();
    }
    else
    {
        //
        // Allocate a buffer for the expanded string.
        //
        pszDst = (LPWSTR) LocalAlloc( LMEM_FIXED, cchDst * sizeof(WCHAR) );
        if ( pszDst == NULL )
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Get the expanded string.
            //
            cchDst = ExpandEnvironmentStringsW( pszSrc, pszDst, cchDst );
            if ( cchDst == 0 )
            {
                status = GetLastError();
                LocalFree( pszDst );
                pszDst = NULL;
            }
            else
            {
                status = ERROR_SUCCESS;
            }
        }
    }

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
    }
    return(pszDst);

} // ClRtlExpandEnvironmentStrings



DWORD
WINAPI
ClRtlGetPropertyFormatSize(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    )

/*++

Routine Description:

    Get the total number of bytes required for this property item format.

Arguments:

    pPropertyTableItem - Supplies the property table item for the property
        format whose size is to be returned.

    pcbOutPropertyListSize - Supplies the size of the output buffer
        required to add this property to a property list.

    pnPropertyCount - The count of properties is incremented.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_INVALID_PARAMETER -

    A Win32 error code on failure.

--*/

{
    DWORD   valueLength;
    DWORD   nameLength;

    //
    // We will return a name, value pair.
    // each of which must be aligned.
    //
    // Get the format type.
    //PCLUSPROP_SYNTAX propSyntax;
    //WORD    formatType;
    //propSyntax = (PCLUSPROP_SYNTAX) &pPropertyTableItem->Format;
    //formatType = propSyntax->wFormat;

    nameLength = sizeof(CLUSPROP_PROPERTY_NAME)
                    + (((DWORD) wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR))
                    + sizeof(CLUSPROP_SYNTAX); // for endmark

    nameLength = ALIGN_CLUSPROP( nameLength );
    valueLength = ALIGN_CLUSPROP( sizeof(CLUSPROP_WORD) );
    *pcbOutPropertyListSize += (valueLength + nameLength);
    *pnPropertyCount += 1;

    return(ERROR_SUCCESS);

} // ClRtlGetPropertyFormatSize



DWORD
WINAPI
ClRtlGetPropertyFormat(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT PVOID * pOutPropertyBuffer,
    IN OUT LPDWORD pcbOutPropertyBufferSize
    )

/*++

Routine Description:

    Get the total number of bytes required for this property item format.

Arguments:

    pPropertyTableItem - Supplies the property table item for the property
        format whose size is to be returned.

    pcbOutPropertyBuffer - Supplies the size of the output buffer
        required to add this property to a property list.

    pcbPropertyBufferSize - The size

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_INVALID_PARAMETER -

    A Win32 error code on failure.

--*/

{
    WORD    formatType;
    DWORD   nameLength;
    DWORD   bytesReturned;
    PCLUSPROP_SYNTAX propSyntax;
    CLUSPROP_BUFFER_HELPER  props;
    DWORD   sc = ERROR_SUCCESS;
    HRESULT hr;

    props.pb = (LPBYTE) *pOutPropertyBuffer;
    //
    // We will return a name, value pair.
    // each of which must be aligned.
    //
    // Get the format type.
    propSyntax = (PCLUSPROP_SYNTAX) &pPropertyTableItem->Format;
    formatType = propSyntax->wFormat;

    //
    // Copy the property name, which includes its syntax and length.
    //
    nameLength = ((DWORD) wcslen( pPropertyTableItem->Name ) + 1) * sizeof(WCHAR);
    props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
    props.pName->cbLength = nameLength;
    hr = StringCbCopyW( props.pName->sz, props.pName->cbLength, pPropertyTableItem->Name );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

    bytesReturned = sizeof(*props.pName) + ALIGN_CLUSPROP( nameLength );
    *pcbOutPropertyBufferSize -= bytesReturned;
    props.pb += bytesReturned;

    //
    // Copy the property value, syntax, length, and ENDMARK
    //
    props.pWordValue->Syntax.wFormat = CLUSPROP_FORMAT_WORD;
    props.pWordValue->Syntax.wType = CLUSPROP_TYPE_LIST_VALUE;
    props.pName->cbLength = sizeof(WORD);
    props.pWordValue->w = formatType;
    bytesReturned = sizeof(*props.pWordValue) + sizeof(CLUSPROP_SYNTAX);
    props.pb += sizeof(*props.pWordValue);
    props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    props.pb += sizeof(CLUSPROP_SYNTAX);
    bytesReturned = sizeof(*props.pWordValue) + sizeof(CLUSPROP_SYNTAX);
    *pcbOutPropertyBufferSize -= bytesReturned;

    *pOutPropertyBuffer = props.pb;

Cleanup:

    return sc;

} // ClRtlGetPropertyFormat



DWORD
WINAPI
ClRtlGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyFormatList,
    IN DWORD cbOutPropertyFormatListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the 'known' property formats for a given object - given its
    property table.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           itemCount = 0;
    DWORD           totalBufferLength = 0;
    PVOID           outBuffer = pOutPropertyFormatList;
    DWORD           bufferLength = cbOutPropertyFormatListSize;
    PRESUTIL_PROPERTY_ITEM  property;

    *pcbBytesReturned = 0;
    *pcbRequired = 0;

    //
    // Clear the output buffer
    //
    if ( pOutPropertyFormatList != NULL )
    {
        ZeroMemory( pOutPropertyFormatList, cbOutPropertyFormatListSize );
    }

    //
    // Get the size of all properties for this object.
    //
    property = pPropertyTable;
    while ( property->Name != NULL )
    {
        status = ClRtlGetPropertyFormatSize(
                                       property,
                                       &totalBufferLength,
                                       &itemCount );

        if ( status != ERROR_SUCCESS )
        {
            break;
        }
        property++;
    }


    //
    // Continue only if the operations so far have been successful.
    //
    if ( status == ERROR_SUCCESS )
    {
        //
        // Count for item count at front of return data and endmark.
        //
        totalBufferLength += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);

        //
        // Verify the size of all the properties
        //
        if ( totalBufferLength > cbOutPropertyFormatListSize )
        {
            *pcbRequired = totalBufferLength;
            totalBufferLength = 0;
            if ( pOutPropertyFormatList == NULL )
            {
                status = ERROR_SUCCESS;
            }
            else
            {
                status = ERROR_MORE_DATA;
            }
        }
        else
        {
            *(LPDWORD)outBuffer = itemCount;
            outBuffer = (PVOID)( (PUCHAR)outBuffer + sizeof(itemCount) );
            bufferLength -= sizeof(itemCount);

            //
            // Now fetch all of the property Formats.
            //
            property = pPropertyTable;
            while ( property->Name != NULL )
            {
                status = ClRtlGetPropertyFormat(
                                           property,
                                           &outBuffer,
                                           &itemCount );

                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                property++;
            }

            // Don't forget the ENDMARK
            *(LPDWORD)outBuffer = CLUSPROP_SYNTAX_ENDMARK;

            if ( (status != ERROR_SUCCESS) &&
                 (status != ERROR_MORE_DATA) )
            {
                totalBufferLength = 0;
            }
        }

        *pcbBytesReturned = totalBufferLength;
    }

    return(status);

} // ClRtlGetPropertyFormats

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\tdisk.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    Test harness for the disk.cpp module

Author:

    John Vert (jvert) 10/10/1996

Revision History:

--*/
#include "stdlib.h"

#include "disk.h"

VOID
DiskFatalError(
    IN DWORD MessageId,
    IN DWORD ErrCode,
    IN LPSTR File,
    IN DWORD Line
    );

class CTestApp : public CWinApp
{
public:
    CTestApp::CTestApp();
    virtual BOOL InitInstance();
    DECLARE_MESSAGE_MAP()

};

BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
        //{{AFX_MSG_MAP(CTestApp)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG
END_MESSAGE_MAP()

CTestApp TestApp;


CTestApp::CTestApp()
{
}
VOID
OutputPhysicalPartition(
    IN CPhysicalPartition *Partition,
    IN DWORD Indent
    )
{
    LARGE_INTEGER EndingOffset;
    DWORD i;
    for (i=0; i<Indent; i++) {
        printf(" ");
    }
    printf("%d(%d): ",
           Partition->m_Info.PartitionNumber,
           Partition->m_Info.PartitionType);
    EndingOffset.QuadPart = Partition->m_Info.StartingOffset.QuadPart +
                            Partition->m_Info.PartitionLength.QuadPart;
    if (Partition->m_Info.StartingOffset.HighPart > 0) {
        printf("%lx%08lx - ",
               Partition->m_Info.StartingOffset.HighPart,
               Partition->m_Info.StartingOffset.LowPart);
    } else {
        printf("%lx - ",Partition->m_Info.StartingOffset.LowPart);
    }
    if (EndingOffset.HighPart > 0) {
        printf("%lx%08lx - ",
               EndingOffset.HighPart,
               EndingOffset.LowPart);
    } else {
        printf("%lx - ",EndingOffset.LowPart);
    }
    printf(" (%dMB)\n", Partition->m_Info.PartitionLength.QuadPart / (1024*1024));
}

VOID
OutputPhysicalDisk(
    IN CPhysicalDisk *Disk,
    IN DWORD Indent
    )
{
    DWORD i;
    for (i=0; i<Indent; i++) {
        printf(" ");
    }
    printf("%ws Harddisk%d (%08lx) ",
            Disk->m_Identifier,
            Disk->m_DiskNumber,
            Disk->m_Signature);
    if (Disk->m_IsSCSI) {
        printf("port %d, bus %d, TID %d\n",
               Disk->m_ScsiAddress.PortNumber,
               Disk->m_ScsiAddress.PathId,
               Disk->m_ScsiAddress.TargetId);
    } else {
        printf(" not SCSI\n");
    }

    //
    // Dump out all the partitions
    //
    POSITION pos = Disk->m_PartitionList.GetHeadPosition();
    while (pos != NULL) {
        OutputPhysicalPartition(Disk->m_PartitionList.GetNext(pos), Indent+4);
    }

}


VOID
OutputLogicalDisk(
    IN CLogicalDrive *Drive,
    IN DWORD Indent
    )
{
    DWORD i;
    for (i=0; i<Indent; i++) {
        printf(" ");
    }
    printf("%c: %-16ws\t(%s)\t(%s)\n",
           Drive->m_DriveLetter,
           (LPCTSTR)Drive->m_VolumeLabel,
           Drive->m_IsNTFS ? "  NTFS  " : "not NTFS",
           Drive->m_IsSticky ? "  sticky  " : "not sticky");
    printf("\t%ws\n",(LPCTSTR)Drive->m_Identifier);
}

BOOL
CTestApp::InitInstance()
{
    CDiskConfig Config;
    BOOL Success;
    PFT_INFO ftInfo;
    LARGE_INTEGER startingOffset;
    LARGE_INTEGER partLength;
    DWORD status;

//#define DISKINFO_TEST
#ifdef DISKINFO_TEST
    ftInfo = DiskGetFtInfo();

    status = DiskAddDiskInfo( ftInfo, 0, 0x385849FB);
    printf( "DiskAddDisk status = %u\n", status);

    startingOffset.QuadPart = 0x4000;
    partLength.QuadPart = 0xFF4FC000I64;
    status = DiskAddDriveLetter( ftInfo, 0x385849FB, startingOffset, partLength, 'C');
    printf("AddDriveLetter for C: %u\n", status);

    startingOffset.QuadPart = 0xFF504000I64;
    partLength.QuadPart = 0x5FC000I64;
    status = DiskAddDriveLetter( ftInfo, 0x385849FB, startingOffset, partLength, 'G');
    printf("AddDriveLetter for G: %u\n", status);

    status = DiskAddDiskInfo( ftInfo, 1, 0x19B25E84);
    printf( "DiskAddDisk status = %u\n", status);

    startingOffset.QuadPart = 0x4000I64;
    partLength.QuadPart = 0x7FCFC000I64;
    status = DiskAddDriveLetter( ftInfo, 0x19B25E84, startingOffset, partLength, 'D');
    printf("AddDriveLetter for D: %u\n", status);

    startingOffset.QuadPart = 0x7FD00000I64;
    partLength.QuadPart = 0x7FE00000I64;
    status = DiskAddDriveLetter( ftInfo, 0x19B25E84, startingOffset, partLength, 'E');
    printf("AddDriveLetter for E: %u\n", status);

    DiskFreeFtInfo( ftInfo );
    return 1;
#endif // DISKINFO_TEST
    //
    // Initialize the disk configuration
    //
    Success = Config.Initialize();
    if (!Success) {
        fprintf(stderr, "Disk initialization failed\n");
    }


    //
    // Display the physical disk configuration
    //

    printf("Physical disk configuration\n");
    POSITION pos = Config.m_PhysicalDisks.GetStartPosition();
    while( pos != NULL )
    {
        CPhysicalDisk* pDisk;
        int Index;

        Config.m_PhysicalDisks.GetNextAssoc( pos, Index, pDisk );
        OutputPhysicalDisk(pDisk,4);
    }

    //
    // Display the logical disk configuration
    //

    printf("\nLogical disk configuration\n");
    pos = Config.m_LogicalDrives.GetStartPosition();
    while( pos != NULL )
    {
        CLogicalDrive* pDisk;
        WCHAR Letter;

        Config.m_LogicalDrives.GetNextAssoc( pos, Letter, pDisk );
        OutputLogicalDisk(pDisk,4);
    }
    return(1);
}


VOID
DiskErrorFatal(
    INT MessageId,
    DWORD Error,
    LPSTR File,
    DWORD Line
    )
{
    fprintf(stderr, "A fatal error occurred.\n");
    fprintf(stderr, "\tMessage %d\n",MessageId);
    fprintf(stderr, "\tErrCode %d\n",Error);
    fprintf(stderr, "\tFile %s\n, line %d",File, Line);
    exit(1);
}


VOID
DiskErrorLogInfo(
    PCHAR Format,
    ...
    )
{

    CHAR Buffer[256];
    DWORD Bytes;
    va_list ArgList;

    va_start(ArgList, Format);

    vprintf(Format, ArgList);

    va_end(ArgList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clussprt\rpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    Handy utility functions for supporting RPC

Author:

    Sunita Shrivastava (sunitas) 22-Jan-1997

Revision History:

--*/
#include "rpc.h"

void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_FIXED, len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clussprt\clussprt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clussprt.c

Abstract:

    Public interfaces for managing clusters.

Author:

    Sunita Shrivastava (sunitas) 15-Jan-1997

Revision History:

--*/
#include "clusprtp.h"


//
// General Cluster Support Routines for base components
//

/****
@doc    EXTERNAL INTERFACES CLUSSVC CLUSSPRT EVTLOG
****/

/****
@func       HANDLE WINAPI | BindToClusterSvc| This returns a handle via which
            you can talk to the cluster service.

@parm       IN LPWSTR | lpszClusterName | A pointer to the cluster name.  If NULL,
            this connects to the local cluster service.

@rdesc      Returns a handle to the binding if successful, else returns NULL.
            Error can be obtained by calling GetLastError().

@comm       The handle obtained from this must be passed on to other apis exported
            by this module.  It must be freed eventually by calling UnbindFromClusterSvc().

@xref       <f UnbindFromClusterSvc>
****/
HANDLE
WINAPI
BindToClusterSvc(IN LPWSTR lpszClusterName)
{
    WCHAR           *pBinding = NULL;
    PCLUSTER_SPRT    pCluster;
    DWORD           Status = ERROR_SUCCESS;
    
    pCluster = LocalAlloc(LMEM_ZEROINIT, sizeof(CLUSTER_SPRT));
    if (pCluster == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError( Status );
        return NULL;
    }
    pCluster->dwSignature = CLUSTER_SPRT_SIGNATURE;

    if ((lpszClusterName == NULL) ||
        (lpszClusterName[0] == '\0')) 
    {
        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncalrpc",
                                          NULL,
                                          NULL, // dynamic endpoint
                                          NULL,
                                          &pBinding);
        if (Status != RPC_S_OK) 
        {
            goto FnExit;
        }

    } 
    else 
    {
        //
        // Try to connect to the cluster via UDP.
        //
        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncadg_ip_udp",
                                          (LPWSTR)lpszClusterName,
                                          NULL,
                                          NULL,
                                          &pBinding);
        if (Status != RPC_S_OK) {
            goto FnExit;
        }
    }
    //bind to the cluster svc and save the binding handle
    Status = RpcBindingFromStringBindingW(pBinding, &pCluster->RpcBinding);
    RpcStringFreeW(&pBinding);
    if (Status != RPC_S_OK) {
        goto FnExit;
    }

    Status = RpcBindingSetAuthInfoW(pCluster->RpcBinding,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_CONNECT,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);

FnExit:
    if (Status != ERROR_SUCCESS) 
    {
        if (pCluster->RpcBinding)
            RpcBindingFree(&(pCluster->RpcBinding));
        LocalFree(pCluster);
        pCluster=NULL;
        SetLastError(Status);
    }
    return((HANDLE)pCluster);
}


/****
@func       DWORD | UnbindFromClusterSvc| This uninitializes the cluster
            wide eventlog replicating services.

@parm       IN HANDLE | hCluster | A handle to the binding context obtained
            via BindToClusterSvc().
            
@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       Frees the context related with this binding.

@xref       <f UnbindFromClusterSvc>
****/
DWORD
WINAPI
UnbindFromClusterSvc(IN HANDLE hCluster)
{
    DWORD   Status = ERROR_SUCCESS;
    PCLUSTER_SPRT    pCluster = (PCLUSTER_SPRT)hCluster;
    
    
    if (!pCluster || (pCluster->dwSignature != CLUSTER_SPRT_SIGNATURE) || !(pCluster->RpcBinding))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    RpcBindingFree(&(pCluster->RpcBinding));
    LocalFree(pCluster);

FnExit:
    return(Status);
}



/****
@func       DWORD | PropagateEvents| This eventlog service calls the
            local cluster service via this api to propagate events
            within a cluster.

@parm       IN HANDLE | hCluster | handle to a cluster binding context
            returned by BindToClusterSvc().

@parm       IN DWORD | dwEventInfoSize | Size of the event info structure
            that contains the events to be propagated.

@parm       IN PPACKEDEVENTINFO| pPackedEventInfo | A pointer to the packed
            event information structure.
            
@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This calls ApiEvPropEvents() in the cluster via lrpc.

@xref       <f BindToClusterSvc>
****/
DWORD
WINAPI
PropagateEvents(
    IN HANDLE       hCluster,
    IN DWORD        dwEventInfoSize,
    IN PPACKEDEVENTINFO pPackedEventInfo)
{
    DWORD Status=ERROR_SUCCESS;
    PCLUSTER_SPRT pCluster=(PCLUSTER_SPRT)hCluster;

    if (!pCluster || (pCluster->dwSignature != CLUSTER_SPRT_SIGNATURE) || !(pCluster->RpcBinding))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    RpcTryExcept {
    //call the cluster service
        Status = ApiEvPropEvents(pCluster->RpcBinding, 
                    dwEventInfoSize, (UCHAR *)pPackedEventInfo);
    }
    
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

FnExit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clussprt\clusprtp.h ===
#ifndef _CLUSPRTP_H
#define _CLUSPRTP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusprtp.h

Abstract:

    Private header file for cluster support api

Author:

    Sunita Shrivastava (sunitas) 15-Jan-1997

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "api_rpc.h"

//
// Define CLUSTER structure. There is one cluster structure created
// for each OpenCluster API call. An HCLUSTER is really a pointer to
// this structure.
//

#define CLUSTER_SPRT_SIGNATURE 'SULC'


typedef struct _CLUSTER_SPRT {
    DWORD dwSignature;
    RPC_BINDING_HANDLE RpcBinding;
} CLUSTER_SPRT, *PCLUSTER_SPRT;

HANDLE
WINAPI
BindToClusterSvc(
    IN LPWSTR lpszClusterName);

DWORD
WINAPI
UnbindFromClusterSvc(
    IN HANDLE hCluster);


DWORD
WINAPI
PropagateEvents(
    IN HANDLE       hCluster,
    IN DWORD        dwEventInfoSize,
    IN PPACKEDEVENTINFO pPackedEventInfo);


#endif //_CLUSPRTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\ext\atlsnap\inc\atlsnap.cpp ===
void __cdecl operator delete(void* p)
{
	_free_dbg(p, _NORMAL_BLOCK);
}

void* __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}
#include <atlsnap.h>

const IID IID_ISnapInDataInterface = {0x1FABD781,0xECDA,0x11D0,{0xAA,0xCE,0x00,0xAA,0x00,0xC0,0x01,0x89}};

const UINT CSnapInBaseData::m_CCF_NODETYPE			= RegisterClipboardFormat(CCF_NODETYPE);;
const UINT CSnapInBaseData::m_CCF_SZNODETYPE		= RegisterClipboardFormat(CCF_SZNODETYPE);  
const UINT CSnapInBaseData::m_CCF_DISPLAY_NAME		= RegisterClipboardFormat(CCF_DISPLAY_NAME); 
const UINT CSnapInBaseData::m_CCF_SNAPIN_CLASSID	= RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
const UINT CSnapInBaseData::m_CCF_SCOPEDATAITEM	= RegisterClipboardFormat(_T("CCF_SCOPEDATAITEM"));
const UINT CSnapInBaseData::m_CCF_RESULTDATAITEM = RegisterClipboardFormat(_T("CCF_RESULTDATAITEM"));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\threadq.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   threadq.c

Abstract:

    Generic Worker Thread Queue Package

Author:

    Mike Massa (mikemas)           April 5, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-05-96    created

Notes:

    Worker Thread Queues provide a single mechanism for processing
    overlapped I/O completions as well as deferred work items. Work
    queues are created and destroyed using ClRtlCreateWorkQueue()
    and ClRtlDestroyWorkQueue(). Overlapped I/O completions are
    directed to a work queue by associating an I/O handle with a work
    queue using ClRtlAssociateIoHandleWorkQueue(). Deferred work items
    are posted to a work queue using ClRtlPostItemWorkQueue().

    Work queues are implemented using I/O completion ports. Each work
    queue is serviced by a set of threads which dispatch work items
    to specified work routines. Threads are created dynamically, up to
    a specified maximum, to ensure that there is always a thread waiting
    to service new work items. The priority of the threads servicing a
    work queue can be specified.

    [Future enhancement: dynamically shrink the thread pool when the
    incoming work rate drops off. Currently, threads continue to service
    the work queue until it is destroyed.]

    Special care must be taken when destroying a work queue to ensure
    that all threads terminate properly and no work items are lost.
    See the notes under ClRtlDestroyWorkQueue.

--*/

#include "clusrtlp.h"


//
// Private Types
//
typedef struct _CLRTL_WORK_QUEUE {
    HANDLE    IoCompletionPort;
    LONG      MaximumThreads;
    LONG      TotalThreads;
    LONG      WaitingThreads;
    LONG      ReserveThreads;
    LONG      ConcurrentThreads;
    DWORD     Timeout;
    int       ThreadPriority;
    HANDLE    StopEvent;
} CLRTL_WORK_QUEUE;


//
// Private Routines
//
DWORD
ClRtlpWorkerThread(
    LPDWORD  Context
    )
{
    PCLRTL_WORK_QUEUE       workQueue = (PCLRTL_WORK_QUEUE) Context;
    DWORD                   bytesTransferred;
    BOOL                    ioSuccess;
    ULONG_PTR               ioContext;
    LPOVERLAPPED            overlapped;
    PCLRTL_WORK_ITEM        workItem;
    DWORD                   status;
    LONG                    interlockedResult;
    DWORD                   threadId;
    HANDLE                  threadHandle;
    DWORD                   timeout;
    LONG                    myThreadId;


    timeout = workQueue->Timeout;
    myThreadId = GetCurrentThreadId();

    if (!SetThreadPriority(GetCurrentThread(), workQueue->ThreadPriority)) {
        status = GetLastError();

        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[WTQ] Thread %1!u! unable to set priority to %2!d!, status %3!u!\n",
            myThreadId,
            workQueue->ThreadPriority,
            status
            );
    }

#if THREADQ_VERBOSE
    ClRtlLogPrint(
        LOG_CRITICAL,
        "[WTQ] Thread %1!u! started, queue %2!lx!.\n",
        myThreadId,
        workQueue
        );
#endif

    while (TRUE) {

        InterlockedIncrement(&(workQueue->WaitingThreads));

        ioSuccess = GetQueuedCompletionStatus(
                        workQueue->IoCompletionPort,
                        &bytesTransferred,
                        &ioContext,
                        &overlapped,
                        timeout
                        );

        interlockedResult = InterlockedDecrement(
                                &(workQueue->WaitingThreads)
                                );

        if (overlapped) {
            //
            // Something was dequeued.
            //
            workItem = CONTAINING_RECORD(
                           overlapped,
                           CLRTL_WORK_ITEM,
                           Overlapped
                           );

            if (interlockedResult == 0) {
                //
                // No more threads are waiting. Fire another one up.
                // Make sure we haven't started too many first.
                //
                interlockedResult = InterlockedDecrement(
                                        &(workQueue->ReserveThreads)
                                        );

                if (interlockedResult > 0) {
                    //
                    // We haven't started too many
                    //

#if THREADQ_VERBOSE
                    ClRtlLogPrint(
                        LOG_NOISE,
                        "[WTQ] Thread %1!u! starting another thread for queue %2!lx!.\n",
                        myThreadId,
                        workQueue
                        );
#endif // 0

                    InterlockedIncrement(&(workQueue->TotalThreads));

                    threadHandle = CreateThread(
                                       NULL,
                                       0,
                                       ClRtlpWorkerThread,
                                       workQueue,
                                       0,
                                       &threadId
                                       );

                    if (threadHandle == NULL) {
                        InterlockedDecrement(&(workQueue->TotalThreads));
                        InterlockedIncrement(&(workQueue->ReserveThreads));

                        status = GetLastError();

                        ClRtlLogPrint(
                            LOG_CRITICAL,
                            "[WTQ] Thread %1!u! failed to create thread, %2!u!\n",
                            myThreadId,
                            status
                            );
                    }
                    else {
                        CloseHandle(threadHandle);
                    }
                }
                else {
                    InterlockedIncrement(&(workQueue->ReserveThreads));
                }
            } // end if (interlockedResult == 0)

            if (ioSuccess) {
                (*(workItem->WorkRoutine))(
                    workItem,
                    ERROR_SUCCESS,
                    bytesTransferred,
                    ioContext
                    );
            }
            else {
                //
                // The item was posted with an error.
                //
                status = GetLastError();

                (*(workItem->WorkRoutine))(
                    workItem,
                    status,
                    bytesTransferred,
                    ioContext
                    );
            }

            continue;
        }
        else {
            //
            // No item was dequeued
            //
            if (ioSuccess) {
                //
                // This is our cue to start the termination process.
                // Set the timeout to zero to make sure we don't block
                // after the port is drained.
                //
                timeout = 0;
#if THREADQ_VERBOSE
                ClRtlLogPrint(
                    LOG_NOISE,
                    "[WTQ] Thread %1!u! beginning termination process\n",
                    myThreadId
                    );
#endif // 0
            }
            else {
                status = GetLastError();

                if (status == WAIT_TIMEOUT) {
                    //
                    // No more items pending, time to exit.
                    //
                    CL_ASSERT(timeout == 0);

                    break;
                }

                CL_ASSERT(status == WAIT_TIMEOUT);

                ClRtlLogPrint(
                    LOG_CRITICAL,
                    "[WTQ] Thread %1!u! No item, strange status %2!u! on queue %3!lx!\n",
                    myThreadId,
                    status,
                    workQueue
                    );
            }
        } // end if (overlapped)
    } // end while(TRUE)

    CL_ASSERT(workQueue->TotalThreads > 0);
    InterlockedIncrement(&(workQueue->ReserveThreads));
    InterlockedDecrement(&(workQueue->TotalThreads));

#if THREADQ_VERBOSE
    ClRtlLogPrint(LOG_NOISE, "[WTQ] Thread %1!u! exiting.\n", myThreadId);
#endif // 0

    //
    // Let the ClRtlDestroyWorkQueue know we are terminating.
    //
    SetEvent(workQueue->StopEvent);

    return(ERROR_SUCCESS);
}


//
// Public Routines
//
PCLRTL_WORK_QUEUE
ClRtlCreateWorkQueue(
    IN DWORD  MaximumThreads,
    IN int    ThreadPriority
    )
/*++

Routine Description:

    Creates a work queue and a dynamic pool of threads to service it.

Arguments:

    MaximumThreads - The maximum number of threads to create to service
                     the queue.

    ThreadPriority - The priority level at which the queue worker threads
                     should run.

Return Value:

    A pointer to the created queue if the routine is successful.

    NULL if the routine fails. Call GetLastError for extended
    error information.

--*/
{
    DWORD               status;
    PCLRTL_WORK_QUEUE   workQueue = NULL;
    DWORD               threadId;
    HANDLE              threadHandle = NULL;
    HANDLE              bogusHandle = NULL;


    if (MaximumThreads == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    bogusHandle = CreateFileW(
                      L"NUL",
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_FLAG_OVERLAPPED,
                      NULL
                      );


    if (bogusHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] bogus file creation failed, %1!u!\n", status);
        return(NULL);
    }

    workQueue = LocalAlloc(
                    LMEM_FIXED | LMEM_ZEROINIT,
                    sizeof(CLRTL_WORK_QUEUE)
                    );

    if (workQueue == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    workQueue->MaximumThreads = MaximumThreads;
    workQueue->TotalThreads = 1;
    workQueue->WaitingThreads = 0;
    workQueue->ReserveThreads = MaximumThreads - 1;
    workQueue->ConcurrentThreads = 0;
    workQueue->Timeout = INFINITE;
    workQueue->ThreadPriority = ThreadPriority;

    workQueue->IoCompletionPort = CreateIoCompletionPort(
                                      bogusHandle,
                                      NULL,
                                      0,
                                      workQueue->ConcurrentThreads
                                      );

    CloseHandle(bogusHandle); bogusHandle = NULL;

    if (workQueue->IoCompletionPort == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] Creation of I/O Port failed, %1!u!\n", status);
    }

    workQueue->StopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (workQueue->StopEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] Creation of stop event failed, %1!u!\n", status);
        goto error_exit;
    }

    threadHandle = CreateThread(
                       NULL,
                       0,
                       ClRtlpWorkerThread,
                       workQueue,
                       0,
                       &threadId
                       );

    if (threadHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[WTQ] Failed to create worker thread, %1!u!\n", status);
        goto error_exit;
    }

    CloseHandle(threadHandle);

    return(workQueue);


error_exit:

    if (bogusHandle != NULL) {
        CloseHandle(bogusHandle);
    }

    if (workQueue != NULL) {
        if (workQueue->IoCompletionPort != NULL) {
            CloseHandle(workQueue->IoCompletionPort);
        }

        if (workQueue->StopEvent != NULL) {
            CloseHandle(workQueue->StopEvent);
        }

        LocalFree(workQueue);
    }

    SetLastError(status);

    return(NULL);
}


VOID
ClRtlDestroyWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue
    )
/*++

Routine Description:

    Destroys a work queue and its thread pool.

Arguments:

    WorkQueue  - The queue to destroy.

Return Value:

    None.

Notes:

    The following rules must be observed in order to safely destroy a
    work queue:

        1) No new work items may be posted to the queue once all previously
           posted items have been processed by this routine.

        2) WorkRoutines must be able to process items until this
           call returns. After the call returns, no more items will
           be delivered from the specified queue.

    One workable cleanup procedure is as follows: First, direct the
    WorkRoutines to silently discard completed items. Next, eliminate
    all sources of new work. Finally, destroy the work queue. Note that
    when in discard mode, the WorkRoutines may not access any structures
    which will be destroyed by eliminating the sources of new work.

--*/
{
    BOOL   posted;
    DWORD  status;


#if THREADQ_VERBOSE
    ClRtlLogPrint(LOG_NOISE, "[WTQ] Destroying work queue %1!lx!\n", WorkQueue);
#endif // 0


    while (WorkQueue->TotalThreads != 0) {
#if THREADQ_VERBOSE
        ClRtlLogPrint(
            LOG_NOISE,
            "[WTQ] Destroy: Posting terminate item, thread cnt %1!u!\n",
            WorkQueue->TotalThreads
            );
#endif // 0

        posted = PostQueuedCompletionStatus(
                     WorkQueue->IoCompletionPort,
                     0,
                     0,
                     NULL
                     );

        if (!posted) {
            status = GetLastError();

            ClRtlLogPrint(
                LOG_CRITICAL,
                "[WTQ] Destroy: Failed to post termination item, %1!u!\n",
                status
                );

            CL_ASSERT(status == ERROR_SUCCESS);

            break;
        }
#if THREADQ_VERBOSE
        ClRtlLogPrint(LOG_NOISE, "[WTQ] Destroy: Waiting for a thread to terminate.\n");
#endif // 0

        status = WaitForSingleObject(WorkQueue->StopEvent, INFINITE);

        CL_ASSERT(status == WAIT_OBJECT_0);

#if THREADQ_VERBOSE
        ClRtlLogPrint(LOG_NOISE, "[WTQ] Destroy: A thread terminated.\n");
#endif // 0
    }

    CloseHandle(WorkQueue->IoCompletionPort);
    CloseHandle(WorkQueue->StopEvent);

    LocalFree(WorkQueue);

#if THREADQ_VERBOSE
    ClRtlLogPrint(LOG_NOISE, "[WTQ] Work queue %1!lx! destroyed\n", WorkQueue);
#endif // 0

    return;
}


DWORD
ClRtlPostItemWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Posts a specified work item to a specified work queue.

Arguments:

    WorkQueue         - A pointer to the work queue to which to post the item.

    WorkItem          - A pointer to the item to post.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes
                        transferred during the operation. For other work items,
                        the semantics of this parameter may be defined by
                        the caller.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the operation was submitted.
                        Of other work items, the semantics of this parameter
                        may be defined by the caller.

Return Value:

    ERROR_SUCCESS if the item was posted successfully.
    A Win32 error code if the post operation fails.

--*/
{
    BOOL  posted;

    posted = PostQueuedCompletionStatus(
                 WorkQueue->IoCompletionPort,
                 BytesTransferred,
                 IoContext,
                 &(WorkItem->Overlapped)
                 );

    if (posted) {
        return(ERROR_SUCCESS);
    }

    return(GetLastError());
}


DWORD
ClRtlAssociateIoHandleWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN HANDLE             IoHandle,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Associates a specified I/O handle, opened for overlapped I/O
    completion, with a work queue. All pending I/O operations on
    the specified handle will be posted to the work queue when
    completed. An initialized CLRTL_WORK_ITEM must be used to supply
    the OVERLAPPED structure whenever an I/O operation is submitted on
    the specified handle.

Arguments:

    WorkQueue     - The work queue with which to associate the I/O handle.

    IoHandle      - The I/O handle to associate.

    IoContext     - A context value to associate with the specified handle.
                    This value will be supplied as a parameter to the
                    WorkRoutine which processes completions for this
                    handle.

Return Value:

    ERROR_SUCCESS if the association completes successfully.
    A Win32 error code if the association fails.

--*/
{
    HANDLE   portHandle;


    portHandle = CreateIoCompletionPort(
                     IoHandle,
                     WorkQueue->IoCompletionPort,
                     IoContext,
                     WorkQueue->ConcurrentThreads
                     );

    if (portHandle != NULL) {
        CL_ASSERT(portHandle == WorkQueue->IoCompletionPort);

        return(ERROR_SUCCESS);
    }

    return(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\clusrtl\vercheck.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      VerCheck.cpp
//
//  Abstract:
//      Contains the implementation of the ClRtlIsVersionCheckingDisabled()
//      function that checks if the cluster version checking has been disabled
//      on a particular computer or not.
//
//  Author:
//      Vijayendra Vasu (VVasu) 11-NOV-2000
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <malloc.h>
#include "clusudef.h"
#include "clusrtl.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	ClRtlIsVersionCheckingDisabled()
//
//	Routine Description:
//		Checks if cluster version checking has been disabled on a particular
//      computer.
//
//	Arguments:
//      const WCHAR * pcszNodeNameIn
//          Name of the node on which the test for the version checking state
//          is to be performed. If NULL, this function checks if cluster
//          version checking in disabled on the local node.
//
//      BOOL *  pfVerCheckDisabledOut
//          Pointer to the boolean variable that will be set to TRUE if
//          version checking is disabled on pcszNodeNameIn and FALSE otherwise.
//
//	Return Value:
//      ERROR_SUCCESS
//          If all went well.
//
//      Other Win32 error codes
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ClRtlIsVersionCheckingDisabled(
      const WCHAR * pcszNodeNameIn
    , BOOL *        pfVerCheckDisabledOut
    )
{
    DWORD       dwError = ERROR_SUCCESS;
    HKEY        hRemoteRegistry = NULL;
    HKEY        hClusSvcParamsKey = NULL;
    WCHAR *     pszTempString = NULL;

    do
    {
        HKEY    hParentKey = HKEY_LOCAL_MACHINE;
        DWORD   dwVersionCheck = 0;
        DWORD   dwType;
        DWORD   dwSize;

        // Validate parameter.
        if ( pfVerCheckDisabledOut == NULL )
        {
            dwError = ERROR_INVALID_PARAMETER;
            break;
        } // if: the output parameter is invalid

        // Initialize output.
        *pfVerCheckDisabledOut = FALSE;

        // Connect to the remote registry, if required.
        if ( pcszNodeNameIn != NULL )
        {
            const WCHAR *   pcszDoubleBackslashes = L"\\\\";
            DWORD           cchComputerNameSize = wcslen( pcszNodeNameIn ) + 1;
            DWORD           cchPrefixLen = wcslen( pcszDoubleBackslashes );

            // Allocate space for and prefix the computer name with '\\'
            pszTempString = reinterpret_cast< WCHAR * >( malloc( ( cchPrefixLen + cchComputerNameSize ) * sizeof( *pszTempString ) ) );
            if ( pszTempString == NULL )
            {
                dwError = ERROR_OUTOFMEMORY;
                break;
            } // if: memory allocation failed

            wcsncpy( pszTempString, pcszDoubleBackslashes, cchPrefixLen );
            wcsncpy( pszTempString + cchPrefixLen, pcszNodeNameIn, cchComputerNameSize );

            // Open the registry on the remote computer.
            dwError = RegConnectRegistry( pszTempString, HKEY_LOCAL_MACHINE, &hRemoteRegistry );
            if ( dwError != ERROR_SUCCESS )
            {
                break;
            } // if: RegConnectRegistry() has failed

            hParentKey = hRemoteRegistry;
        } // if: a remote computer needs to be contacted.

        // Open the cluster service parameters registry key.
        dwError = RegOpenKeyEx(
              hParentKey
            , CLUSREG_KEYNAME_CLUSSVC_PARAMETERS
            , 0
            , KEY_QUERY_VALUE
            , &hClusSvcParamsKey
            );

        if ( dwError != ERROR_SUCCESS )
        {
            if ( dwError == ERROR_FILE_NOT_FOUND )
            {
                // This is ok - absence of the value indicates that the cluster service 
                // does not exist on the target computer.
                dwError = ERROR_SUCCESS;
            } // if: RegOpenKeyEx did not find the key

            break;
        } // if: RegOpenKeyEx() has failed

        // Read the required registry value
        dwSize = sizeof( dwVersionCheck );
        dwError = RegQueryValueEx(
              hClusSvcParamsKey
            , CLUSREG_NAME_SVC_PARAM_NOVER_CHECK
            , 0
            , &dwType
            , reinterpret_cast< BYTE * >( &dwVersionCheck )
            , &dwSize
            );

        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            // This is ok - absence of the value indicates that version checking is not disabled.
            dwVersionCheck = 0;
            dwError = ERROR_SUCCESS;
        } // if: RegQueryValueEx did not find the value
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // else if: RegQueryValueEx() has failed

        *pfVerCheckDisabledOut = ( dwVersionCheck == 0 ) ? FALSE : TRUE;
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Free acquired resources
    //

    if ( hRemoteRegistry != NULL )
    {
        RegCloseKey( hRemoteRegistry );
    } // if: we had opened the remote registry

    if ( hClusSvcParamsKey != NULL )
    {
        RegCloseKey( hClusSvcParamsKey );
    } // if: we had opened the cluster service parameters registry key

    // Free the allocated temporary string. (note, free( NULL ) is valid)
    free( pszTempString );
    
    return dwError;
} //*** ClRtlIsVersionCheckingDisabled()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clrtldbg.h ===
/***
*ClRtlDbg.h - Supports debugging features for clusters (from the C runtime library).
*
*		Copyright (c) 1994-1998, Microsoft Corporation. All rights reserved.
*
*Purpose:
*		Support Cluster debugging features.
*
*		[Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CLRTLDBG_H_
#define __CLRTLDBG_H_


#ifdef	__cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef CLRTL_INCLUDE_DEBUG_REPORTING

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _CLRTL_ASSERT(expr) ((void)0)

#define _CLRTL_ASSERTE(expr) ((void)0)


#define _CLRTL_RPT0(rptno, msg)

#define _CLRTL_RPT1(rptno, msg, arg1)

#define _CLRTL_RPT2(rptno, msg, arg1, arg2)

#define _CLRTL_RPT3(rptno, msg, arg1, arg2, arg3)

#define _CLRTL_RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _CLRTL_RPTF0(rptno, msg)

#define _CLRTL_RPTF1(rptno, msg, arg1)

#define _CLRTL_RPTF2(rptno, msg, arg1, arg2)

#define _CLRTL_RPTF3(rptno, msg, arg1, arg2, arg3)

#define _CLRTL_RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _ClRtlSetReportHook(f)			((void)0)
#define _ClRtlSetReportMode(t, f) 		((int)0)
#define _ClRtlSetReportFile(t, f) 		((void)0)

#define _ClRtlDbgBreak()				((void)0)


#else /* CLRTL_INCLUDE_DEBUG_REPORTING */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CLRTLIMP */

#ifndef _CLRTLIMP
//#ifdef	_DLL
//#define _CLRTLIMP __declspec(dllimport)
//#else	/* ndef _DLL */
#define _CLRTLIMP
//#endif	/* _DLL */
#endif	/* _CLRTLIMP */

/* Define NULL pointer value */

#ifndef NULL
#ifdef	__cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CLRTLDBG_WARN			0
#define _CLRTLDBG_ERROR			1
#define _CLRTLDBG_ASSERT 		2
#define _CLRTLDBG_ERRCNT 		3

#define _CLRTLDBG_MODE_FILE		0x1
#define _CLRTLDBG_MODE_DEBUG	0x2
#define _CLRTLDBG_MODE_WNDW		0x4
#define _CLRTLDBG_REPORT_MODE	-1

#define _CLRTLDBG_INVALID_HFILE ((_HFILE)-1)
#define _CLRTLDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CLRTLDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CLRTLDBG_FILE_STDERR   ((_HFILE)-5)
#define _CLRTLDBG_REPORT_FILE   ((_HFILE)-6)

//#if 	defined(_DLL) && defined(_M_IX86)
//#define _clrtlAssertBusy	 (*__p__clrtlAssertBusy())
//_CLRTLIMP long * __cdecl __p__clrtlAssertBusy(void);
//#else	/* !(defined(_DLL) && defined(_M_IX86)) */
//_CLRTLIMP extern long _clrtlAssertBusy;
//#endif	/* defined(_DLL) && defined(_M_IX86) */

typedef int (__cdecl * _CLRTL_REPORT_HOOK)(int, char *, int *);

_CLRTLIMP _CLRTL_REPORT_HOOK __cdecl _ClRtlSetReportHook(
		_CLRTL_REPORT_HOOK
		);

_CLRTLIMP int __cdecl _ClRtlSetReportMode(
		int,
		int
		);

_CLRTLIMP _HFILE __cdecl _ClRtlSetReportFile(
		int,
		_HFILE
		);

_CLRTLIMP int __cdecl _ClRtlDbgReport(
		int,
		const char *,
		int,
		const char *,
		const char *,
		...);

/* Asserts */

#define _CLRTL_ASSERT(expr) \
		do { if (!(expr) && \
				(1 == _ClRtlDbgReport(_CLRTLDBG_ASSERT, __FILE__, __LINE__, NULL, NULL))) \
			 _ClRtlDbgBreak(); } while (0)

#define _CLRTL_ASSERTE(expr) \
		do { if (!(expr) && \
				(1 == _ClRtlDbgReport(_CLRTLDBG_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
			 _ClRtlDbgBreak(); } while (0)


/* Reports with no file/line info */

#define _CLRTL_RPT0(rptno, msg) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, "%s", msg))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT1(rptno, msg, arg1) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT2(rptno, msg, arg1, arg2) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT3(rptno, msg, arg1, arg2, arg3) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
		do { if ((1 == _ClRtlDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))) \
				_ClRtlDbgBreak(); } while (0)


/* Reports with file/line info */

#define _CLRTL_RPTF0(rptno, msg) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, "%s", msg))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF1(rptno, msg, arg1) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF2(rptno, msg, arg1, arg2) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF3(rptno, msg, arg1, arg2, arg3) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))) \
				_ClRtlDbgBreak(); } while (0)

#define _CLRTL_RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
		do { if ((1 == _ClRtlDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))) \
				_ClRtlDbgBreak(); } while (0)

#if 	defined(_M_IX86) && !defined(_CLRTL_PORTABLE)
#define _ClRtlDbgBreak() __asm { int 3 }
#elif	defined(_M_ALPHA) && !defined(_CLRTL_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _ClRtlDbgBreak() _BPT()
#else
_CLRTLIMP void __cdecl _ClRtlDbgBreak(
		void
		);
#endif

#endif // CLRTL_INCLUDE_DEBUG_REPORTING

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // __CLRTLDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\ext\atlsnap\inc\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#ifndef UNICODE
#error "Only Unicode builds supported"
#endif

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")


// Wrappers for propertypage
#pragma comment(lib, "comctl32.lib")

#pragma warning( push )
#pragma warning( disable : 4100 )
template <class T>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		if(uMsg == PSPCB_CREATE)
		{
			ATLASSERT(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	BEGIN_MSG_MAP(CSnapInPropertyPageImpl< T >)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}

#if _ATL_VER < 0x0300
	//Overridden to reference overridden DialogProc
	static INT_PTR CALLBACK StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CSnapInPropertyPageImpl< T >* pThis = (CSnapInPropertyPageImpl< T >*)_Module.ExtractCreateWndData();
		ATLASSERT(pThis != NULL);
		pThis->m_hWnd = hWnd;
		pThis->m_thunk.Init((WNDPROC)DialogProc, pThis);
		DLGPROC pProc = (DLGPROC) &(pThis->m_thunk.thunk);
		DLGPROC pOldProc;
		pOldProc = (DLGPROC) ::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
	#ifdef _DEBUG
		// check if somebody has subclassed us already since we discard it
		if(pOldProc != StartDialogProc)
			ATLTRACE(_T("ATL: Subclassing through a hook discarded.\n"));
	#endif
		return pProc(hWnd, uMsg, wParam, lParam);
	}

	// Overriden for handling WM_NCDESTROY correctly
	static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
#ifdef _M_IX86
	__asm mov dword ptr[hWnd], ecx
#endif
		CSnapInPropertyPageImpl< T >* pThis = (CSnapInPropertyPageImpl< T >*)hWnd;
		LRESULT lRes;
		if(pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0))
		{
			switch (uMsg)
			{
			case WM_COMPAREITEM:
			case WM_VKEYTOITEM:
			case WM_CHARTOITEM:
			case WM_INITDIALOG:
			case WM_QUERYDRAGICON:
			case WM_CTLCOLORMSGBOX:
			case WM_CTLCOLOREDIT:
			case WM_CTLCOLORLISTBOX:
			case WM_CTLCOLORBTN:
			case WM_CTLCOLORDLG:
			case WM_CTLCOLORSCROLLBAR:
			case WM_CTLCOLORSTATIC:
				return lRes;
				break;
			}
			::SetWindowLongPtr(pThis->m_hWnd, DWLP_MSGRESULT, lRes);
			return TRUE;
		}
		if(uMsg == WM_NCDESTROY)
		{
			// clear out window handle
			HWND hWnd2 = pThis->m_hWnd;
			pThis->m_hWnd = NULL;
			// clean up after dialog is destroyed
			pThis->OnFinalMessage(hWnd2);
		}
		return FALSE;
	}
	virtual void OnFinalMessage(HWND hWnd)
	{
	};
#endif
};

#if _ATL_VER < 0x0300
// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSnapInSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSnapInSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSnapInSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};
#endif

/*class CSnapInBitmap
{
public:
	HBITMAP m_hBitmap;

	CSnapInBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }
	~CSnapInBitmap()
	{
		if(m_hBitmap != NULL)
			DeleteObject();
	}

	CSnapInBitmap& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
		return m_hBitmap;
	}
	HBITMAP LoadBitmap(UINT nIDResource)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}
// Operations
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
};
*/
class CSnapInItem;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;

    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;

    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(Command)(long lCommandID,		
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;

    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		DATA_OBJECT_TYPES type) = 0;

    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;

    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf,
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
        UNREFERENCED_PARAMETER( pDataObject );
        UNREFERENCED_PARAMETER( pDefault );
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA,
			NULL,
			DVASPECT_CONTENT,
			-1,
			TYMED_HGLOBAL
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME"));
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
};

class CSnapInObjectRoot
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSnapInSimpleMap <UINT, IUnknown*> m_toolbarMap;

	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
        UNREFERENCED_PARAMETER( pformatetcIn );
        UNREFERENCED_PARAMETER( pmedium );
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
        UNREFERENCED_PARAMETER( pformatetc );
        UNREFERENCED_PARAMETER( advf );
        UNREFERENCED_PARAMETER( pAdvSink );
        UNREFERENCED_PARAMETER( pdwConnection );
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
        UNREFERENCED_PARAMETER( dwConnection );
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
        UNREFERENCED_PARAMETER( ppenumAdvise );
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			// review change to QI
			hr = S_OK;
			m_spConsole = pUnknown;
			if (m_spConsole == NULL)
			{
				ATLTRACE(_T("QI for IConsole failed\n"));
				hr = E_UNEXPECTED;
			}
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else			
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
		}
		return hr;
	}


    STDMETHOD(Notify)(
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentDataImpl::Notify\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
		ATLASSERT(m_pNode != NULL);


		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}

    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}

    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComQIPtr<IConsole, &IID_IConsole> m_spConsole;

	protected:
		CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(_T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(_T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeaderCtrl;
			// review : change to QI
			spHeaderCtrl = lpConsole;
			if (spHeaderCtrl == NULL)
				ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentImpl::Notify\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(lpDataObject, &pItem, &type);
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, NULL, pT, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(LONG_PTR cookie)
	{
		ATLTRACE(_T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}

    STDMETHOD(GetResultViewType)(LONG_PTR cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
	{
		ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

		if (cookie == NULL)
		{
			*ppViewType = NULL;
			*pViewOptions = MMC_VIEW_OPTIONS_NONE;
			return S_FALSE;
		}
		
		CSnapInItem* pItem = (CSnapInItem*)cookie;
		return pItem->GetResultViewType(ppViewType, pViewOptions);
	}

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(_T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}

    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T, class D>
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        LONG_PTR cookieA,
        LONG_PTR cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
		}
		return hr;
	}

    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);
			
			if (SUCCEEDED(hr))
				hr = pItem->Command(lCommandID, type);
		}
		return hr;
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
		}

		return hr;
	}

    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
	{
		ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
		

		HRESULT hr = E_POINTER;
		
		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->QueryPagesFor(type);
		}
		return hr;
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}

    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

		CSnapInItem* pItem = NULL;
		DATA_OBJECT_TYPES type;
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);

		if (event == MMCN_BTN_CLICK)
			hr = pT->GetDataClass((IDataObject*) arg, &pItem, &type);
		else if (event == MMCN_SELECT)
			hr = pT->GetDataClass((IDataObject*) param, &pItem, &type);

		if (SUCCEEDED(hr))
		{
			hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, type);
		}

		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRoot* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass.ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	~CSnapInToolbarInfo()
	{
		CleanUp();
	}

	HRESULT CleanUp()
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
		return S_OK;
	}

	TCHAR** m_pStrToolTip;
	TCHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}	

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}

    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE(_T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}

    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR buf[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = buf;
					TCHAR strStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, buf, &menuItemInfo.fState);
					LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, strStatusBar, 256);

					CONTEXTMENUITEM contextMenuItem;
					memset(&contextMenuItem, 0, sizeof(contextMenuItem));
					contextMenuItem.strName = buf;
					contextMenuItem.strStatusBarText = strStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					
					HRESULT hr;
					hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}

    STDMETHOD(Command)(long lCommandID,		
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, (CSnapInObjectRoot*) this, type);
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar,
		IExtendControlbar* pExtendControlBar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(_T("CSnapInItemImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new TCHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(TCHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}


			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
//				pInfo->m_pStrToolTip[i] = NULL;
				memset(&pButtons[i], 0, sizeof(MMCBUTTON));
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR strStatusBar[512];
					LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, strStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new TCHAR[lstrlen(strStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					lstrcpy(pInfo->m_pStrToolTip[i], strStatusBar);
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = _T("");
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = _T("");
					pButtons[i].lpButtonText = _T("");
					pButtons[i].fsType = TBSTYLE_SEP;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}

    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CSnapInSimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg,
		LPARAM param,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		CComPtr<IUnknown> spUnknown;
		HRESULT hr = pControlbar->QueryInterface(IID_IUnknown, (void**)&spUnknown);
		if (FAILED(hr))
			return hr;

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			BOOL bScope;
			bScope = (BOOL) LOWORD(arg);

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;

				if (!bSelect)
					pControlbar->Detach(pToolbar);
				else
				{
					pControlbar->Attach(TOOLBAR, pToolbar);
					for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
					{
						if (pInfo->m_pnButtonID[i])
						{
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								ENABLED,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									ENABLED));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								CHECKED,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									CHECKED));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								HIDDEN,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									HIDDEN));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								INDETERMINATE,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									INDETERMINATE));
							pToolbar->SetButtonState(pInfo->m_pnButtonID[i],
								BUTTONPRESSED,
								pT->UpdateToolbarButton(pInfo->m_pnButtonID[i],
									BUTTONPRESSED));
						}
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, (CSnapInObjectRoot*) this, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}

    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *fsState, BYTE *fsType)
	{
		*fsState = TBSTATE_ENABLED;
		*fsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID,
		bool& bHandled,
		CSnapInObjectRoot* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (lstrlen((LPCTSTR)pT->GetSZNodeType()) + 1 )* sizeof(TCHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (lstrlen((LPCTSTR)pT->GetDisplayName()) + 1) * sizeof(TCHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static const UINT GetMenuID()
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;

#pragma warning( pop )

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clstrcmp.h ===
/*++

Copyright (c) 1995-2002  Microsoft Corporation

Module Name:

    clstrcmp.h

Abstract:

    Replacement for wcsicmp and wcscmp that do not
    compare international strings correctly without
    resetting the locale first.

    We could have used lstrcmpi, but it doesn't have
    a corresponding "n" version.

Author:

    GorN 20-May-2002

Revision History:

--*/
#ifndef _CLSTRCMP_INCLUDED_
#define _CLSTRCMP_INCLUDED_

//
// Proper case insensitive compare
//
__inline int ClRtlStrICmp(LPCWSTR stra, LPCWSTR strb)
{
    return CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
        stra, -1, strb, -1) - CSTR_EQUAL; // CSTR_LT < CSTR_EQUAL < CSTR_GT
}

//
// Proper case insensitive compare
//
__inline int ClRtlStrNICmp(LPCWSTR stra, LPCWSTR strb, size_t n)
{
    size_t i;
    for (i = 0; i < n; ++i)
       if (stra[i] == 0 || strb[i] == 0) {n = i+1; break;}

    return CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
        stra, (int)n, strb, (int)n) - CSTR_EQUAL; // CSTR_LT < CSTR_EQUAL < CSTR_GT
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clnetcfg.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clnetcfg.h

Abstract:

    Network Configuration Engine definitions

Author:

    Mike Massa (mikemas) 28-Feb-1998

Revision History:

--*/

#ifndef _CLNETCFG_INCLUDED_
#define _CLNETCFG_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


//
// Structures
//

//
// Network Configuration Entry Structure
// Identifies a network and a local interface.
//
typedef struct _CLNET_CONFIG_ENTRY {
    LIST_ENTRY          Linkage;
    NM_NETWORK_INFO     NetworkInfo;
    BOOLEAN             IsInterfaceInfoValid;
    BOOLEAN             UpdateNetworkName;
    NM_INTERFACE_INFO2  InterfaceInfo;

    // Fields used by setup
    BOOL               New;
    BOOL               IsPrimed;
    LPWSTR             PreviousNetworkName;
    LIST_ENTRY         PriorityLinkage;

} CLNET_CONFIG_ENTRY, *PCLNET_CONFIG_ENTRY;


//
// Configuration Lists Structure
// Contains the set of network configuration lists emitted by the
// configuration engine.
//
typedef struct _CLNET_CONFIG_LISTS {
    LIST_ENTRY  InputConfigList;
    LIST_ENTRY  DeletedInterfaceList;
    LIST_ENTRY  UpdatedInterfaceList;
    LIST_ENTRY  CreatedInterfaceList;
    LIST_ENTRY  CreatedNetworkList;
} CLNET_CONFIG_LISTS, *PCLNET_CONFIG_LISTS;


//
// Definitions for functions supplied by the consumer of the network
// configuration engine.
//
typedef
VOID
(*LPFN_CLNETPRINT)(
    IN ULONG LogLevel,
    IN PCHAR FormatString,
    ...
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT1)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT2)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    );

typedef
VOID
(*LPFN_CLNETLOGEVENT3)(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    );


//
// Exported Routines
//
VOID
ClNetInitialize(
    IN LPFN_CLNETPRINT       Print,
    IN LPFN_CLNETLOGEVENT    LogEvent,
    IN LPFN_CLNETLOGEVENT1   LogEvent1,
    IN LPFN_CLNETLOGEVENT2   LogEvent2,
    IN LPFN_CLNETLOGEVENT3   LogEvent3
    );

LPWSTR
ClNetCopyString(
    IN LPWSTR  SourceString,
    IN BOOL    RaiseExceptionOnError
    );

VOID
ClNetInitializeConfigLists(
    PCLNET_CONFIG_LISTS  Lists
    );

DWORD
ClNetConvertEnumsToConfigList(
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 LocalNodeId,
    IN OUT PLIST_ENTRY            ConfigList,
    IN     BOOLEAN                DeleteEnums
    );

VOID
ClNetFreeNetworkEnum(
    IN PNM_NETWORK_ENUM  NetworkEnum
    );

VOID
ClNetFreeNetworkInfo(
    IN PNM_NETWORK_INFO  NetworkInfo
    );

VOID
ClNetFreeInterfaceEnum1(
    IN PNM_INTERFACE_ENUM  InterfaceEnum1
    );

VOID
ClNetFreeInterfaceEnum(
    IN PNM_INTERFACE_ENUM2  InterfaceEnum
    );

VOID
ClNetFreeInterfaceInfo(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    );

VOID
ClNetFreeNodeEnum1(
    IN PNM_NODE_ENUM  NodeEnum
    );

VOID
ClNetFreeNodeEnum(
    IN PNM_NODE_ENUM2  NodeEnum
    );

VOID
ClNetFreeNodeInfo(
    IN PNM_NODE_INFO2  NodeInfo
    );

VOID
ClNetFreeConfigEntry(
    PCLNET_CONFIG_ENTRY  ConfigEntry
    );

VOID
ClNetFreeConfigList(
    IN PLIST_ENTRY  ConfigList
    );

VOID
ClNetFreeConfigLists(
    PCLNET_CONFIG_LISTS  Lists
    );

LPWSTR
ClNetMakeInterfaceName(
    LPWSTR  Prefix,      OPTIONAL
    LPWSTR  NodeName,
    LPWSTR  AdapterName
    );

DWORD
ClNetConfigureNetworks(
    IN     LPWSTR                LocalNodeId,
    IN     LPWSTR                LocalNodeName,
    IN     LPWSTR                DefaultClusnetEndpoint,
    IN     CLUSTER_NETWORK_ROLE  DefaultNetworkRole,
    IN     BOOL                  NetNameHasPrecedence,
    IN OUT PCLNET_CONFIG_LISTS   ConfigLists,
    IN OUT LPDWORD               MatchedNetworkCount,
    IN OUT LPDWORD               NewNetworkCount
    );
/*++

Notes:

    Output interface lists must be processed in the following order to
    guarantee correctness:
        1 - RenamedInterfaceList
        2 - DeletedInterfaceList
        3 - UpdatedInterfaceList
        4 - CreatedInterfaceList
        5 - CreatedNetworkList

--*/


#ifdef __cplusplus
}
#endif


#endif // ifndef _CLNETCFG_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\cluster.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    cluster.h

Abstract:

    Top-level include file for all user-mode components in the cluster
    project.

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSTER_H
#define _CLUSTER_H


#include "resapi.h"
#include "clusdef.h"
#include "clusudef.h"
#include "clusrtl.h"
#include "clusapi.h"


//
// Global Debugging Definitions
//

#if DBG

#define CL_SIG_FIELD                  DWORD    Signature;
#define CL_INIT_SIG(pstruct, sig)     ( (pstruct)->Signature = (sig) )
#define CL_ASSERT_SIG(pstruct, sig)   CL_ASSERT((pstruct)->Signature == (sig))

#else // DBG

#define CL_SIG_FIELD
#define CL_INIT_SIG(pstruct, sig)
#define CL_ASSERT_SIG(pstruct, sig)

#endif // DBG

#endif //_CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clusdef.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusdef.h

Abstract:

    Common definitions for user-mode and kernel-mode components of the
    cluster project.

Author:

    Mike Massa (mikemas) 15-Feb-1997

Revision History:

--*/
#ifndef _CLUSDEF_H
#define _CLUSDEF_H


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Cluster node ID definition
//
typedef ULONG CL_NODE_ID;

#define ClusterMinNodeId         1
#define ClusterMinNodeIdString   L"1"
#define ClusterDefaultMaxNodes   16
#define ClusterAnyNodeId         0
#define ClusterInvalidNodeId     0xFFFFFFFF


//
// Default clusnet endpoint value assigned by IANA
//
#define CLUSNET_DEFAULT_ENDPOINT_STRING   L"3343"    // our UDP port number

//
// Default role for a cluster network.
//
#define CL_DEFAULT_NETWORK_ROLE    ClusterNetworkRoleInternalAndClient


//
// Cluster network ID definition
//
typedef ULONG CL_NETWORK_ID, *PCL_NETWORK_ID;

#define ClusterAnyNetworkId         0
#define ClusterInvalidNetworkId     0xFFFFFFFF

//
// ClusNet node communication state definition
//
typedef enum {
    ClusnetNodeCommStateOffline = 0,
    ClusnetNodeCommStateOfflinePending = 1,
    ClusnetNodeCommStateUnreachable = 2,
    ClusnetNodeCommStateOnlinePending = 3,
    ClusnetNodeCommStateOnline = 4
} CLUSNET_NODE_COMM_STATE, *PCLUSNET_NODE_COMM_STATE;

//
// ClusNet network state definition
//
typedef enum {
    ClusnetNetworkStateOffline = 0,
    ClusnetNetworkStateOfflinePending = 1,
    ClusnetNetworkStatePartitioned = 2,
    ClusnetNetworkStateOnlinePending = 3,
    ClusnetNetworkStateOnline = 4
} CLUSNET_NETWORK_STATE, *PCLUSNET_NETWORK_STATE;

//
// ClusNet interface state definition
//
typedef enum {
    ClusnetInterfaceStateOffline = 0,
    ClusnetInterfaceStateOfflinePending = 1,
    ClusnetInterfaceStateUnreachable = 2,
    ClusnetInterfaceStateOnlinePending = 3,
    ClusnetInterfaceStateOnline = 4
} CLUSNET_INTERFACE_STATE, *PCLUSNET_INTERFACE_STATE;

//
// ClusNet node membership state. This tracks the internal
// membership state maintained by the membership engine in the cluster
// service. This enum MUST start at zero since it is used as an index
// into a state table.
//

typedef enum {
    ClusnetNodeStateAlive = 0,
    ClusnetNodeStateJoining,
    ClusnetNodeStateDead,
    ClusnetNodeStateNotConfigured,
    ClusnetNodeStateLastEntry
} CLUSNET_NODE_STATE, *PCLUSNET_NODE_STATE;

//
// ClusNet Event definitions
//
typedef enum _CLUSNET_EVENT_TYPE {
    ClusnetEventNone                    = 0x00000000,
    ClusnetEventNodeUp                  = 0x00000001,
    ClusnetEventNodeDown                = 0x00000002,
    ClusnetEventPoisonPacketReceived    = 0x00000004,
    ClusnetEventHalt                    = 0x00000008,

    ClusnetEventNetInterfaceUp          = 0x00000010,
    ClusnetEventNetInterfaceUnreachable = 0x00000020,
    ClusnetEventNetInterfaceFailed      = 0x00000040,

    ClusnetEventAddAddress              = 0x00000100,
    ClusnetEventDelAddress              = 0x00000200,

    ClusnetEventMulticastSet            = 0x00001000,

    ClusnetEventAll                     = 0xFFFFFFFF
} CLUSNET_EVENT_TYPE, *PCLUSNET_EVENT_TYPE;

typedef struct {
    ULONG                 Epoch;
    CLUSNET_EVENT_TYPE    EventType;
    CL_NODE_ID            NodeId;
    CL_NETWORK_ID         NetworkId;
} CLUSNET_EVENT, *PCLUSNET_EVENT;

//
// Add types for Clussvc to clusnet Heartbeating.
//
typedef enum _ClussvcHangAction {
    ClussvcHangActionDisable = 0,
    ClussvcHangActionLog = 1,
    ClussvcHangActionTerminateService = 2,
    ClussvcHangActionBugCheckMachine = 3,
    ClussvcHangActionMax = 4
} ClussvcHangAction, *PClussvcHangAction;

//
// ClusNet NTSTATUS codes are now located in ntstatus.h
//

#ifdef __cplusplus
}
#endif // __cplusplus


#endif //_CLUSDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clusrtl.h ===
/*++

Copyright (c) 1995-2002  Microsoft Corporation

Module Name:

    clusrtl.h

Abstract:

    Header file for definitions and structures for the NT Cluster
    Run Time Library

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:

--*/

#ifndef _CLUSRTL_INCLUDED_
#define _CLUSRTL_INCLUDED_


//
// Service Message IDs
//
#pragma warning( push )
#include "clusvmsg.h"

#include "resapi.h"
#include <aclapi.h>
#include <netcon.h>
#include <winioctl.h>
#pragma warning( pop )
#include "clstrcmp.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//  Routine Description:
//
//      Initializes the cluster run time library.
//
//  Arguments:
//
//      DbgOutputToConsole - TRUE if the debug output should be written to a
//                           console window
//
//      DbgLogLevel - pointer to a DWORD that contains the current msg filter
//      level. checked by ClRtlDbgPrint.
//
//  Return Value:
//
//      ERROR_SUCCESS if the function succeeds.
//      A Win32 error code otherwise.
//

DWORD
ClRtlInitialize(
    IN  BOOL    DbgOutputToConsole,
    IN  PDWORD  DbgLogLevel
    );


//
//  Routine Description:
//
//      Cleans up the cluster run time library.
//
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      None.
//
VOID
ClRtlCleanup(
    VOID
    );

//
//  Routine Description:
//
//      Checks to see if Services for MacIntosh is installed.
//
//  Arguments:
//
//      Pointer to boolean that tells if SFM is installed.
//
//  Return Value:
//
//      Status of request.
//

DWORD
ClRtlIsServicesForMacintoshInstalled(
    OUT BOOL * pfInstalled
    );

//////////////////////////////////////////////////////////////////////////
//
// Event logging interfaces
//
//
// There are three currently defined logging levels:
//     LOG_CRITICAL - fatal error, chaos and destruction will ensue
//     LOG_UNUSUAL  - unexpected event, but will be handled
//     LOG_NOISE    - normal occurence
//
//////////////////////////////////////////////////////////////////////////

#define LOG_CRITICAL 1
#define LOG_UNUSUAL  2
#define LOG_NOISE    3

//
// A few interfaces for reporting of errors.
//
VOID
ClRtlEventLogInit(
    VOID
    );

VOID
ClRtlEventLogCleanup(
    VOID
    );



VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogNonFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogAssertionFailure(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN LPSTR Expression
    );

VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );

VOID
ClusterLogEvent4(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3,
    IN LPCWSTR Arg4
    );

//
//  Routine Description:
//
//      Prints a message to the debugger if running as a service
//      or the console window if running as a console app.
//
//  Arguments:
//
//      LogLevel - Supplies the logging level, one of
//                    LOG_CRITICAL 1
//                    LOG_UNUSUAL  2
//                    LOG_NOISE    3
//
//      FormatString     - Message string.
//
//      Any FormatMessage-compatible arguments to be inserted in the
//      ErrorMessage before it is logged.
//
//  Return Value:
//
//      None.
//
VOID
__cdecl
ClRtlDbgPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    ...
    );

//
// Same as ClRtlDbgPrint, only uses a message ID instead of a string.
//
VOID
__cdecl
ClRtlMsgPrint(
    IN DWORD MessageId,
    ...
    );

//
// Same as ClRtlDbgPrint, only logs to a file instead of screen.
//
VOID
__cdecl
ClRtlLogPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    ...
    );

//
// Macros/prototypes for unexpected error handling.
//

WINBASEAPI
BOOL
APIENTRY
IsDebuggerPresent(
    VOID
    );

#define CL_UNEXPECTED_ERROR(_errcode_)              \
    ClusterLogFatalError(LOG_CURRENT_MODULE,        \
                         __LINE__,                  \
                         __FILE__,                  \
                        (_errcode_))

#if DBG
#define CL_ASSERT( exp )                                    \
    if (!(exp)) {                                           \
        ClusterLogAssertionFailure(LOG_CURRENT_MODULE,      \
                                   __LINE__,                \
                                   __FILE__,                \
                                   #exp);                   \
    }

#define CL_LOGFAILURE( _errcode_ )                  \
ClusterLogNonFatalError(LOG_CURRENT_MODULE,         \
                         __LINE__,                  \
                         __FILE__,                  \
                        (_errcode_))
#else
#define CL_ASSERT( exp )
#define CL_LOGFAILURE( _errorcode_ )
#endif

// Use the following to put cluster specific errors in the event log

#define CL_LOGCLUSINFO( _errcode_ )        \
ClusterLogEvent0(LOG_NOISE,                \
                 LOG_CURRENT_MODULE,       \
                 __FILE__,                 \
                 __LINE__,                 \
                 (_errcode_),              \
                 0,                        \
                 NULL)

#define CL_LOGCLUSWARNING( _errcode_ )     \
ClusterLogEvent0(LOG_UNUSUAL,              \
                 LOG_CURRENT_MODULE,       \
                 __FILE__,                 \
                 __LINE__,                 \
                 (_errcode_),              \
                 0,                        \
                 NULL)


#define CL_LOGCLUSWARNING1(_msgid_,_arg1_)          \
    ClusterLogEvent1(LOG_UNUSUAL,                   \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CL_LOGCLUSERROR( _errcode_ )        \
ClusterLogEvent0(LOG_CRITICAL,              \
                 LOG_CURRENT_MODULE,        \
                 __FILE__,                  \
                 __LINE__,                  \
                 (_errcode_),               \
                 0,                         \
                 NULL)

#define CL_LOGCLUSERROR1(_msgid_,_arg1_)            \
    ClusterLogEvent1(LOG_CRITICAL,                  \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CL_LOGCLUSERROR2(_msgid_,_arg1_, _arg2_)    \
    ClusterLogEvent2(LOG_CRITICAL,                  \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))


//////////////////////////////////////////////////////////////////////////
//
// General-purpose hash table package
//
//////////////////////////////////////////////////////////////////////////

#define MAX_CL_HASH  16                         // the size of the table

typedef struct _CL_HASH_ITEM {
    LIST_ENTRY ListHead;
    DWORD      Id;
    PVOID      pData;
} CL_HASH_ITEM, *PCL_HASH_ITEM;

typedef struct _CL_HASH {
    CRITICAL_SECTION Lock;
    BOOL             bRollover;                 // flag to handle rollover
    DWORD            LastId;                    // last id used
    DWORD            CacheFreeId[MAX_CL_HASH];  // a cache of available id's
    CL_HASH_ITEM     Head[MAX_CL_HASH];
} CL_HASH, *PCL_HASH;


VOID
ClRtlInitializeHash(
    IN PCL_HASH pTable
    );

DWORD
ClRtlInsertTailHash(
    IN PCL_HASH pTable,
    IN PVOID    pData,
    OUT LPDWORD pId
    );

PVOID
ClRtlGetEntryHash(
    IN PCL_HASH pTable,
    IN DWORD Id
    );

PVOID
ClRtlRemoveEntryHash(
    IN PCL_HASH pTable,
    IN DWORD Id
    );

VOID
ClRtlDeleteHash(
    IN PCL_HASH pTable
    );


//////////////////////////////////////////////////////////////////////////
//
// General-purpose queue package.
//
//////////////////////////////////////////////////////////////////////////
typedef struct _CL_QUEUE {
    LIST_ENTRY ListHead;
    CRITICAL_SECTION Lock;
    HANDLE Event;
    DWORD Count;
    HANDLE Abort;
} CL_QUEUE, *PCL_QUEUE;

DWORD
ClRtlInitializeQueue(
    IN PCL_QUEUE Queue
    );

VOID
ClRtlDeleteQueue(
    IN PCL_QUEUE Queue
    );

PLIST_ENTRY
ClRtlRemoveHeadQueue(
    IN PCL_QUEUE Queue
    );


typedef
DWORD
(*CLRTL_CHECK_HEAD_QUEUE_CALLBACK)(
    IN PLIST_ENTRY ListEntry,
    IN PVOID Context
    );
/*++

Routine Description:

    Called by ClRtlRemoveHeadQueueTimeout to determine
    whether or not an entry at the head of the queue is
    appropriate to dequeue and return or not.

Arguments:

    ListEntry - value of the PLIST_ENTRY we're examining

    Context - caller-defined data

Return Value:

    ERROR_SUCCESS if it's appropriate to return the event.

    A Win32 error code if the initialization failed.  This value
    can be retrieved by calling GetLastError().

--*/

PLIST_ENTRY
ClRtlRemoveHeadQueueTimeout(
    IN PCL_QUEUE Queue,
    IN DWORD dwMilliseconds,
    IN CLRTL_CHECK_HEAD_QUEUE_CALLBACK pfnCallback,
    IN PVOID pvContext
    );

VOID
ClRtlInsertTailQueue(
    IN PCL_QUEUE Queue,
    IN PLIST_ENTRY Item
    );

VOID
ClRtlRundownQueue(
    IN PCL_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    );


//////////////////////////////////////////////////////////////////////////
//
// General-purpose buffer pool package.
//
//////////////////////////////////////////////////////////////////////////

//
// Buffer pool definition.
//
typedef struct _CLRTL_BUFFER_POOL *PCLRTL_BUFFER_POOL;


//
// Maximum number of buffers that can be allocated from a pool.
//
#define CLRTL_MAX_POOL_BUFFERS  0xFFFFFFFE


//
// Routines for utilizing buffer pools.
//
typedef
DWORD
(*CLRTL_BUFFER_CONSTRUCTOR)(
    PVOID Buffer
    );
/*++

Routine Description:

    Called to initialize a buffer which has been newly allocated
    from system memory.

Arguments:

    Buffer  - A pointer to the buffer to initialize.

Return Value:

    ERROR_SUCCESS if the initialization succeeded.

    A Win32 error code if the initialization failed.

--*/


typedef
VOID
(*CLRTL_BUFFER_DESTRUCTOR)(
    PVOID Buffer
    );
/*++

Routine Description:

    Called to cleanup a buffer which is about to be returned to
    system memory.

Arguments:

    Buffer  - A pointer to the buffer to cleanup.

Return Value:

    None.

--*/


PCLRTL_BUFFER_POOL
ClRtlCreateBufferPool(
    IN DWORD                      BufferSize,
    IN DWORD                      MaximumCached,
    IN DWORD                      MaximumAllocated,
    IN CLRTL_BUFFER_CONSTRUCTOR   Constructor,         OPTIONAL
    IN CLRTL_BUFFER_DESTRUCTOR    Destructor           OPTIONAL
    );
/*++

Routine Description:

    Creates a pool from which fixed-size buffers may be allocated.

Arguments:

    BufferSize        - Size of the buffers managed by the pool.

    MaximumCached     - The maximum number of buffers to cache in the pool.
                        Must be less than or equal to MaximumAllocated.

    MaximumAllocated  - The maximum number of buffers to allocate from
                        system memory. Must be less than or equal to
                        CLRTL_MAX_POOL_BUFFERS.

    Constructor       - An optional routine to be called when a new buffer
                        is allocated from system memory. May be NULL

    Destructor        - An optional routine to be called when a buffer
                        is returned to system memory. May be NULL.

Return Value:

    A pointer to the created buffer pool or NULL on error.
    Extended error information is available from GetLastError().

--*/


VOID
ClRtlDestroyBufferPool(
    IN PCLRTL_BUFFER_POOL  Pool
    );
/*++

Routine Description:

    Destroys a previously created buffer pool.

Arguments:

    Pool  - A pointer to the pool to destroy.

Return Value:

    None.

Notes:

    The pool will not actually be destroyed until all outstanding
    buffers have been returned. Each outstanding buffer is effectively
    a reference on the pool.

--*/


PVOID
ClRtlAllocateBuffer(
    IN PCLRTL_BUFFER_POOL Pool
    );
/*++

Routine Description:

    Allocates a buffer from a previously created buffer pool.

Arguments:

    Pool - A pointer to the pool from which to allocate the buffer.

Return Value:

    A pointer to the allocated buffer if the routine was successfull.
    NULL if the routine failed. Extended error information is available
    by calling GetLastError().

--*/


VOID
ClRtlFreeBuffer(
    PVOID Buffer
    );
/*++

Routine Description:

    Frees a buffer back to its owning pool.

Arguments:

    Buffer   - The buffer to free.

Return Value:

    None.

--*/



//////////////////////////////////////////////////////////////////////////
//
// General-purpose worker thread queue package.
//
//////////////////////////////////////////////////////////////////////////

typedef struct _CLRTL_WORK_ITEM *PCLRTL_WORK_ITEM;

typedef
VOID
(*PCLRTL_WORK_ROUTINE)(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );
/*++

Routine Description:

    Called to process an item posted to a work queue.

Arguments:

    WorkItem          - The work item to process.

    Status            - If the work item represents a completed I/O operation,
                        this parameter contains the completion status of the
                        operation.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes tranferred
                        during the operation. For other work items, the
                        semantics of this parameter are defined by the caller
                        of ClRtlPostItemWorkQueue.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the I/O was submitted. For
                        other work items, the semantics of this parameter are
                        defined by the caller of ClRtlPostItemWorkQueue.

Return Value:

    None.

--*/


//
// Work Item Structure.
//
typedef struct _CLRTL_WORK_ITEM {
    OVERLAPPED             Overlapped;
    PCLRTL_WORK_ROUTINE    WorkRoutine;
    PVOID                  Context;
} CLRTL_WORK_ITEM;


//
// Work queue definition.
//
typedef struct _CLRTL_WORK_QUEUE  *PCLRTL_WORK_QUEUE;


//
// Routines For Utilizing Work Queues
//

#define ClRtlInitializeWorkItem(Item, Routine, Ctx)                   \
            ZeroMemory(&((Item)->Overlapped), sizeof(OVERLAPPED));    \
            (Item)->WorkRoutine = (Routine);                          \
            (Item)->Context = (Ctx);


PCLRTL_WORK_QUEUE
ClRtlCreateWorkQueue(
    IN DWORD  MaximumThreads,
    IN int    ThreadPriority
    );
/*++

Routine Description:

    Creates a work queue and a dynamic pool of threads to service it.

Arguments:

    MaximumThreads - The maximum number of threads to create to service
                     the queue.

    ThreadPriority - The priority level at which the queue worker threads
                     should run.

Return Value:

    A pointer to the created queue if the routine is successful.

    NULL if the routine fails. Call GetLastError for extended
    error information.

--*/


VOID
ClRtlDestroyWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue
    );
/*++

Routine Description:

    Destroys a work queue and its thread pool.

Arguments:

    WorkQueue  - The queue to destroy.

Return Value:

    None.

Notes:

    The following rules must be observed in order to safely destroy a
    work queue:

        1) No new work items may be posted to the queue once all previously
           posted items have been processed by this routine.

        2) WorkRoutines must be able to process items until this
           call returns. After the call returns, no more items will
           be delivered from the specified queue.

    One workable cleanup procedure is as follows: First, direct the
    WorkRoutines to silently discard completed items. Next, eliminate
    all sources of new work. Finally, destroy the work queue. Note that
    when in discard mode, the WorkRoutines may not access any structures
    which will be destroyed by eliminating the sources of new work.

--*/


DWORD
ClRtlPostItemWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              BytesTransferred,  OPTIONAL
    IN ULONG_PTR          IoContext          OPTIONAL
    );
/*++

Routine Description:

    Posts a specified work item to a specified work queue.

Arguments:

    WorkQueue         - A pointer to the work queue to which to post the item.

    WorkItem          - A pointer to the item to post.

    BytesTransferred  - If the work item represents a completed I/O operation,
                        this parameter contains the number of bytes
                        transferred during the operation. For other work items,
                        the semantics of this parameter may be defined by
                        the caller.

    IoContext         - If the work item represents a completed I/O operation,
                        this parameter contains the context value associated
                        with the handle on which the operation was submitted.
                        Of other work items, the semantics of this parameter
                        may be defined by the caller.

Return Value:

    ERROR_SUCCESS if the item was posted successfully.
    A Win32 error code if the post operation fails.

--*/


DWORD
ClRtlAssociateIoHandleWorkQueue(
    IN PCLRTL_WORK_QUEUE  WorkQueue,
    IN HANDLE             IoHandle,
    IN ULONG_PTR          IoContext
    );
/*++

Routine Description:

    Associates a specified I/O handle, opened for overlapped I/O
    completion, with a work queue. All pending I/O operations on
    the specified handle will be posted to the work queue when
    completed. An initialized CLRTL_WORK_ITEM must be used to supply
    the OVERLAPPED structure whenever an I/O operation is submitted on
    the specified handle.

Arguments:

    WorkQueue     - The work queue with which to associate the I/O handle.

    IoHandle      - The I/O handle to associate.

    IoContext     - A context value to associate with the specified handle.
                    This value will be supplied as a parameter to the
                    WorkRoutine which processes completions for this
                    handle.

Return Value:

    ERROR_SUCCESS if the association completes successfully.
    A Win32 error code if the association fails.

--*/


//////////////////////////////////////////////////////////////////////////
//
// Utilities for accessing the NT system registry.
//
//////////////////////////////////////////////////////////////////////////
DWORD
ClRtlRegQueryDword(
    IN  HKEY    hKey,
    IN  LPWSTR  lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    );

DWORD
ClRtlRegQueryString(
    IN     HKEY     Key,
    IN     LPWSTR   ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );


//////////////////////////////////////////////////////////////////////////
//
// Routines for groveling and managing network configuration.
// Currently, these are specific to TCP/IP.
//
//////////////////////////////////////////////////////////////////////////

//
// Transport interface information structure
//
// The "Ignore" field is intitialized to FALSE. If it is set to
// TRUE by an application, the enum search functions will ignore
// the entry.
//
typedef struct _CLRTL_NET_INTERFACE_INFO {
    struct _CLRTL_NET_INTERFACE_INFO *  Next;
    ULONG                               Context;
    ULONG                               Flags;
    ULONG                               InterfaceAddress;
    LPWSTR                              InterfaceAddressString;
    ULONG                               NetworkAddress;
    LPWSTR                              NetworkAddressString;
    ULONG                               NetworkMask;
    LPWSTR                              NetworkMaskString;
    BOOLEAN                             Ignore;
} CLRTL_NET_INTERFACE_INFO, *PCLRTL_NET_INTERFACE_INFO;

#define CLRTL_NET_INTERFACE_PRIMARY   0x00000001
#define CLRTL_NET_INTERFACE_DYNAMIC   0x00000002

//
// Adapter information structure
//
// The "Ignore" field is intitialized to FALSE. If it is set to
// TRUE by an application, the enum search functions will ignore
// the entry.
//
typedef struct _CLRTL_NET_ADAPTER_INFO {
    struct _CLRTL_NET_ADAPTER_INFO *   Next;
    LPWSTR                             ConnectoidName;    // INetConnection::get_Name
    LPWSTR                             DeviceGuid;        // GUID for INetConnection
    BSTR                               DeviceName;        // INetConnection::get_DeviceName
    LPWSTR                             AdapterDomainName; // adapter specific domain
    ULONG                              Index;
    ULONG                              Flags;
    NETCON_STATUS                      NCStatus;          // INetConnection::GetProperties->Status
    ULONG                              InterfaceCount;
    PCLRTL_NET_INTERFACE_INFO          InterfaceList;
    BOOLEAN                            Ignore;
    DWORD                              DnsServerCount;
    PDWORD                             DnsServerList;
} CLRTL_NET_ADAPTER_INFO, *PCLRTL_NET_ADAPTER_INFO;

#define CLRTL_NET_ADAPTER_HIDDEN      0x00000001


typedef struct {
    ULONG                    AdapterCount;
    PCLRTL_NET_ADAPTER_INFO  AdapterList;
} CLRTL_NET_ADAPTER_ENUM, *PCLRTL_NET_ADAPTER_ENUM;


PCLRTL_NET_ADAPTER_ENUM
ClRtlEnumNetAdapters(
    VOID
    );

VOID
ClRtlFreeNetAdapterEnum(
    IN PCLRTL_NET_ADAPTER_ENUM  AdapterEnum
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterById(
    PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    LPWSTR                    AdapterId
    );

PCLRTL_NET_INTERFACE_INFO
ClRtlFindNetInterfaceByNetworkAddress(
    IN PCLRTL_NET_ADAPTER_INFO   AdapterInfo,
    IN LPWSTR                    NetworkAddress,
    IN LPWSTR                    NetworkMask
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByNetworkAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       NetworkAddress,
    IN  LPWSTR                       NetworkMask,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    );

PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByInterfaceAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       InterfaceAddressString,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    );

PCLRTL_NET_INTERFACE_INFO
ClRtlGetPrimaryNetInterface(
    IN PCLRTL_NET_ADAPTER_INFO  AdapterInfo
    );

VOID
ClRtlQueryTcpipInformation(
    OUT  LPDWORD   MaxAddressStringLength,
    OUT  LPDWORD   MaxEndpointStringLength,
    OUT  LPDWORD   TdiAddressInfoLength
    );

DWORD
ClRtlTcpipAddressToString(
    ULONG     AddressValue,
    LPWSTR *  AddressString
    );

DWORD
ClRtlTcpipStringToAddress(
    LPCWSTR AddressString,
    PULONG  AddressValue
    );

DWORD
ClRtlTcpipEndpointToString(
    USHORT    EndpointValue,
    LPWSTR *  EndpointString
    );

DWORD
ClRtlTcpipStringToEndpoint(
    LPCWSTR  EndpointString,
    PUSHORT  EndpointValue
    );

BOOL
ClRtlIsValidTcpipAddress(
    IN ULONG   Address
    );

BOOL
ClRtlIsDuplicateTcpipAddress(
    IN ULONG   Address
    );

BOOL
ClRtlIsValidTcpipSubnetMask(
    IN ULONG   SubnetMask
    );

BOOL
ClRtlIsValidTcpipAddressAndSubnetMask(
    IN ULONG   Address,
    IN ULONG   SubnetMask
    );

__inline
BOOL
ClRtlAreTcpipAddressesOnSameSubnet(
    ULONG Address1,
    ULONG Address2,
    ULONG SubnetMask
    )
{
    BOOL fReturn;

    if ( ( Address1 & SubnetMask ) == ( Address2 & SubnetMask ) )
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
    }

    return fReturn;
}

//#define ClRtlAreTcpipAddressesOnSameSubnet(_Addr1, _Addr2, _Mask) \
//            ( ((_Addr1 & _Mask) == (_Addr2 & _Mask)) ? TRUE : FALSE )


DWORD
ClRtlBuildTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    IN  LPWSTR    TransportEndpoint,
    OUT LPVOID *  TdiAddress,
    OUT LPDWORD   TdiAddressLength
    );

DWORD
ClRtlBuildLocalTcpipTdiAddress(
    IN  LPWSTR    NetworkAddress,
    OUT LPVOID    TdiAddress,
    OUT LPDWORD   TdiAddressLength
    );

DWORD
ClRtlParseTcpipTdiAddress(
    IN  LPVOID    TdiAddress,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    );

DWORD
ClRtlParseTcpipTdiAddressInfo(
    IN  LPVOID    TdiAddressInfo,
    OUT LPWSTR *  NetworkAddress,
    OUT LPWSTR *  TransportEndpoint
    );

//
// Validate network name
//
typedef enum CLRTL_NAME_STATUS {
    NetNameOk,
    NetNameEmpty,
    NetNameTooLong,
    NetNameInvalidChars,
    NetNameInUse,
    NetNameSystemError,
    NetNameDNSNonRFCChars
} CLRTL_NAME_STATUS;

BOOL
ClRtlIsNetNameValid(
    IN LPCWSTR NetName,
    OUT OPTIONAL CLRTL_NAME_STATUS *Result,
    IN BOOL CheckIfExists
    );


//
// Security related routines
//
LONG
MapSAToRpcSA(
    IN LPSECURITY_ATTRIBUTES lpSA,
    IN OUT struct _RPC_SECURITY_ATTRIBUTES *pRpcSA
    );

LONG
MapSDToRpcSD(
    IN PSECURITY_DESCRIPTOR lpSD,
    IN OUT struct _RPC_SECURITY_DESCRIPTOR *pRpcSD
    );

DWORD
ClRtlSetObjSecurityInfo(
    IN HANDLE           hObject,
    IN SE_OBJECT_TYPE   SeObjType,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryOneMask
    );

DWORD
ClRtlFreeClusterServiceSecurityDescriptor( void );

DWORD
ClRtlBuildClusterServiceSecurityDescriptor(
    PSECURITY_DESCRIPTOR * poutSD
    );

DWORD
ClRtlEnableThreadPrivilege(
    IN  ULONG        Privilege,
    OUT BOOLEAN      *pWasEnabled
    );

DWORD
ClRtlRestoreThreadPrivilege(
    IN ULONG        Privilege,
    IN BOOLEAN      WasEnabled
    );

PSECURITY_DESCRIPTOR
ClRtlCopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psd
    );

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT4Format(
    IN PSECURITY_DESCRIPTOR psd
    );

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT5Format(
    IN PSECURITY_DESCRIPTOR psd
    );

PSECURITY_DESCRIPTOR
ClRtlConvertFileShareSDToNT4Format(
    IN PSECURITY_DESCRIPTOR psd
    );

BOOL
ClRtlExamineSD(
    PSECURITY_DESCRIPTOR    psdSD,
    LPSTR                   pszPrefix
    );

VOID
ClRtlExamineMask(
    ACCESS_MASK amMask,
    LPSTR       lpszOldIndent
    );

DWORD
ClRtlBuildDefaultClusterSD(
    IN PSID                     pOwnerSid,
    OUT PSECURITY_DESCRIPTOR *  SD,
    OUT ULONG *                 SizeSD
    );

BOOL
ClRtlExamineClientToken(
    HANDLE  hClientToken,
    LPSTR   pszPrefix
    );

DWORD
ClRtlIsCallerAccountLocalSystemAccount(
    OUT PBOOL pbIsLocalSystemAccount
    );

//
// OS checker
//
DWORD
GetServicePack(
    VOID
    );

BOOL
ClRtlIsOSValid(
    VOID
    );

DWORD
ClRtlGetSuiteType(
    VOID
    );

BOOL
ClRtlIsProcessRunningOnWin64(
    HANDLE hProcess
    );

DWORD ClRtlCheck64BitCompatibility(
    BOOL bIsClusterRunningWin64,
    BOOL bIsNewNodeRunningWin64
    );


DWORD   ClRtlCheckProcArchCompatibility(
    WORD   wClusterProcessorArchitecture,
    WORD   wNodeProcessorArchitecture
    );

BOOL
ClRtlIsOSTypeValid(
    VOID
    );

//
// A few MULTI_SZ string manipulation routines
//
DWORD
ClRtlMultiSzAppend(
    IN OUT LPWSTR *MultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    );

DWORD
ClRtlMultiSzRemove(
    IN LPWSTR lpszMultiSz,
    IN OUT LPDWORD StringLength,
    IN LPCWSTR lpString
    );

LPCWSTR
ClRtlMultiSzEnum(
    IN LPCWSTR MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    );

DWORD
ClRtlMultiSzLength(
    IN LPCWSTR lpszMultiSz
    );

LPCWSTR
ClRtlMultiSzScan(
    IN LPCWSTR lpszMultiSz,
    IN LPCWSTR lpszString
    );

DWORD
ClRtlCreateDirectory(
    IN LPCWSTR lpszPath
    );

BOOL
WINAPI
ClRtlIsPathValid(
    IN LPCWSTR lpszPath
    );

DWORD
ClRtlGetClusterDirectory(
    IN LPWSTR   lpBuffer,
    IN DWORD    dwBufSize
    );

typedef LONG (*PFNCLRTLCREATEKEY)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PVOID * phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    );

typedef LONG (*PFNCLRTLOPENKEY)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszSubKey,
    IN REGSAM samDesired,
    OUT PVOID * phkResult
    );

typedef LONG (*PFNCLRTLCLOSEKEY)(
    IN PVOID ClusterKey
    );

typedef LONG (*PFNCLRTLENUMVALUE)(
    IN PVOID ClusterKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef LONG (*PFNCLRTLSETVALUE)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );

typedef LONG (*PFNCLRTLQUERYVALUE)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );



typedef DWORD (*PFNCLRTLDELETEVALUE)(
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName
    );

typedef LONG (*PFNCLRTLLOCALCREATEKEY)(
    IN HANDLE hXsaction,
    IN PVOID ClusterKey,
    IN LPCWSTR lpszSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PVOID * phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    );

typedef LONG (*PFNCLRTLLOCALSETVALUE)(
    IN HANDLE hXsaction,
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );

typedef LONG (*PFNCLRTLLOCALDELETEVALUE)(
    IN HANDLE hXsaction,
    IN PVOID ClusterKey,
    IN LPCWSTR lpszValueName
    );

typedef struct _CLUSTER_REG_APIS {
    PFNCLRTLCREATEKEY   pfnCreateKey;
    PFNCLRTLOPENKEY     pfnOpenKey;
    PFNCLRTLCLOSEKEY    pfnCloseKey;
    PFNCLRTLSETVALUE    pfnSetValue;
    PFNCLRTLQUERYVALUE  pfnQueryValue;
    PFNCLRTLENUMVALUE   pfnEnumValue;
    PFNCLRTLDELETEVALUE pfnDeleteValue;
    PFNCLRTLLOCALCREATEKEY      pfnLocalCreateKey;
    PFNCLRTLLOCALSETVALUE       pfnLocalSetValue;
    PFNCLRTLLOCALDELETEVALUE    pfnLocalDeleteValue;
} CLUSTER_REG_APIS, *PCLUSTER_REG_APIS;

DWORD
WINAPI
ClRtlEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlEnumPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPrivateProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPropertySize(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

DWORD
WINAPI
ClRtlGetProperty(
    IN PVOID ClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ClRtlpSetPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ClRtlpSetNonPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ClRtlSetPropertyParameterBlock(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ClRtlGetAllProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * ppszNameOfPropInError
    );

DWORD
WINAPI
ClRtlPropertyListFromParameterBlock(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlAddUnknownProperties(
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM ppPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlpFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    IN BOOL bReturnExpandedValue
    );

__inline
DWORD
WINAPI
ClRtlFindSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )
{
    return ClRtlpFindSzProperty(
        pPropertyList,
        cbPropertyListSize,
        pszPropertyName,
        pszPropertyValue,
        FALSE /* bReturnExpandedValue */
        );

} //*** ClRtlFindSzProperty()

__inline
DWORD
WINAPI
ClRtlFindExpandSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )
{
    return ClRtlpFindSzProperty(
        pPropertyList,
        cbPropertyListSize,
        pszPropertyName,
        pszPropertyValue,
        FALSE /* bReturnExpandedValue */
        );

} //*** ClRtlFindExpandSzProperty()

__inline
DWORD
WINAPI
ClRtlFindExpandedSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )
{
    return ClRtlpFindSzProperty(
        pPropertyList,
        cbPropertyListSize,
        pszPropertyName,
        pszPropertyValue,
        TRUE /* bReturnExpandedValue */
        );

} //*** ClRtlFindExpandedSzProperty()

DWORD
WINAPI
ClRtlFindDwordProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    );

DWORD
WINAPI
ClRtlFindLongProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValue
    );

DWORD
WINAPI
ClRtlFindBinaryProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ClRtlFindMultiSzProperty(
    IN const PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    );

__inline
DWORD
WINAPI
ClRtlVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    )
{
    return ClRtlpSetPropertyTable(
        NULL,
        NULL,
        NULL,
        pPropertyTable,
        Reserved,
        bAllowUnknownProperties,
        pInPropertyList,
        cbInPropertyListSize,
        FALSE, // bForceWrite
        pOutParams);
}

__inline
DWORD
WINAPI
ClRtlSetPropertyTable(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    )
{
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ){
        return(ERROR_BAD_ARGUMENTS);
    }
    return ClRtlpSetPropertyTable(
        hXsaction,
        hkeyClusterKey,
        pClusterRegApis,
        pPropertyTable,
        Reserved,
        bAllowUnknownProperties,
        pInPropertyList,
        cbInPropertyListSize,
        bForceWrite,
        pOutParams);
}

DWORD
WINAPI
ClRtlpSetPrivatePropertyList(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    );

__inline
DWORD
WINAPI
ClRtlVerifyPrivatePropertyList(
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )
{
    return ClRtlpSetPrivatePropertyList( NULL, NULL, NULL, pInPropertyList, cbInPropertyListSize );
}

__inline
DWORD
WINAPI
ClRtlSetPrivatePropertyList(
    IN HANDLE hXsaction,
    IN PVOID hkeyClusterKey,
    IN const PCLUSTER_REG_APIS pClusterRegApis,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )
{
    if ( (hkeyClusterKey == NULL) ||
         (pClusterRegApis == NULL) ){
        return(ERROR_BAD_ARGUMENTS);
    }
    return ClRtlpSetPrivatePropertyList(
        hXsaction,
        hkeyClusterKey,
        pClusterRegApis,
        pInPropertyList,
        cbInPropertyListSize
        );
}

DWORD
WINAPI
ClRtlGetBinaryValue(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName,
    OUT LPBYTE * OutValue,
    OUT LPDWORD OutValueSize,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    );

LPWSTR
WINAPI
ClRtlGetSzValue(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName,
    IN const PCLUSTER_REG_APIS pClusterRegApis
    );

DWORD
WINAPI
ClRtlDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

void
WINAPI
ClRtlFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

DWORD
WINAPI
ClRtlMarshallPropertyTable(
    IN PRESUTIL_PROPERTY_ITEM    pPropertyTable,
    IN OUT  DWORD                dwSize,
    IN OUT  LPBYTE               pBuffer,
    OUT     DWORD                *Required
    );

DWORD
WINAPI
ClRtlUnmarshallPropertyTable(
    IN OUT PRESUTIL_PROPERTY_ITEM   *ppPropertyTable,
    IN LPBYTE                       pBuffer
    );

LPWSTR
WINAPI
ClRtlExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    );


DWORD
WINAPI
ClRtlGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyFormatList,
    IN DWORD cbOutPropertyFormatListSize,
    OUT LPDWORD pcbReturned,
    OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ClRtlGetPropertyFormat(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ClRtlGetPropertyFormatSize(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

//
// Miscellaneous Routines
//
LPWSTR
ClRtlMakeGuid(
    VOID
    );

LPWSTR
ClRtlGetConnectoidName(
    INetConnection * NetConnection
    );

INetConnection *
ClRtlFindConnectoidByGuid(
    LPWSTR ConnectoidGuid
    );

INetConnection *
ClRtlFindConnectoidByName(
    LPCWSTR ConnectoidName
    );

DWORD
ClRtlSetConnectoidName(
    INetConnection *  NetConnection,
    LPWSTR            NewConnectoidName
    );


DWORD
ClRtlFindConnectoidByGuidAndSetName(
    LPWSTR ConnectoidGuid,
    LPWSTR NewConnectoidName
    );

DWORD
ClRtlFindConnectoidByNameAndSetName(
    LPWSTR ConnectoidName,
    LPWSTR NewConnectoidName
    );

DWORD
ClRtlGetConnectoidNameFromLANA(
    IN  UCHAR       LanaNumber,
    OUT LPWSTR *    ConnectoidName
    );

///////////////////////////////////////////////////////////////////////////
//
//	General purpose Watchdog timer.
//
///////////////////////////////////////////////////////////////////////////


PVOID
ClRtlSetWatchdogTimer(
	DWORD timeout,
	LPWSTR par
	);

VOID
ClRtlCancelWatchdogTimer(
	PVOID wTimer
	);

/* commented out 16 Nov 1998 by GalenB because the DS work has been postponed
//
// Active Directory Services (DS) Publication Routines
//
HRESULT
HrClRtlAddClusterNameToDS(
    const TCHAR *pClusterName,
    const HCLUSTER hCluster
);

HRESULT
HrClRtlMoveClusterNodeDS(
    const TCHAR *pClusterName,
    const HCLUSTER hCluster,
    const TCHAR *pNodeName
);
end of commented out code */

// Apis and defines for cluster installation state
// This enum is used to indicate the state of the Cluster Server installation.
// The registry key that indicates the state of the Cluster Server installation
// will be a DWORD representation of one of the following values.

typedef enum
{
   eClusterInstallStateUnknown,
   eClusterInstallStateFilesCopied,
   eClusterInstallStateConfigured,
   eClusterInstallStateUpgraded
} eClusterInstallState;

DWORD
ClRtlGetClusterInstallState(
    IN LPCWSTR pszNodeName,
    OUT eClusterInstallState * peState
    );

BOOL
ClRtlSetClusterInstallState(
    IN eClusterInstallState InstallState
    );

//
// Routine to get drive layout table
//
BOOL
ClRtlGetDriveLayoutTable(
    IN  HANDLE hDisk,
    OUT PDRIVE_LAYOUT_INFORMATION * DriveLayout,
    OUT PDWORD InfoSize OPTIONAL
    );

DWORD ClRtlGetDefaultNodeLimit(
    IN DWORD SuiteType);

//
// If async event reporting is required,
// use the following function to set
// a work queue
//
VOID
ClRtlEventLogSetWorkQueue(
    PCLRTL_WORK_QUEUE WorkQueue
    );



//
// Fast check to see if a file or directory exists.
//
BOOL
ClRtlPathFileExists(
    LPWSTR pwszPath
    );

//
// set default failure actions in service controller
//
DWORD
ClRtlSetSCMFailureActions(
    LPWSTR NodeName OPTIONAL
    );

//
// Initialize Wmi tracing (noop if wmi is disabled)
//
DWORD
ClRtlInitWmi(
    LPCWSTR ComponentName
    );

//
// Get the cluster service domain account info
//
DWORD
ClRtlGetServiceAccountInfo(
    LPWSTR *    AccountBuffer
    );

//
// set the DACL for Winsta0 and its desktop such that any genapp process can
// access it
//
DWORD
ClRtlAddClusterServiceAccountToWinsta0DACL(
    VOID
    );

//
// add the SID with AccessMask to the SD specified by pOldSd. return the new
// self-relative SD in ppNewSd
//
DWORD
ClRtlAddAceToSd(
    IN  PSECURITY_DESCRIPTOR    pOldSd,
    IN  PSID                    pClientSid,
    IN  ACCESS_MASK             AccessMask,
    OUT PSECURITY_DESCRIPTOR *  ppNewSd
    );

//
// Cleanup a node that has been evicted (requires cleanup COM component to be registered locally).
// This function should only be called from the cluster service.
//
HRESULT ClRtlCleanupNode(
      const WCHAR *     pcszEvictedNodeNameIn
    , DWORD             dwDelayIn
    , DWORD             dwTimeoutIn
    );

//
// Asynchronously cleanup a node that has been evicted.
//
HRESULT ClRtlAsyncCleanupNode(
      const WCHAR * pcszEvictedNodeNameIn
    , DWORD dwDelayIn
    , DWORD dwTimeoutIn
    );

//
// Find out if a registry value indicating that this node has been evicted, is set or not
//
DWORD
ClRtlHasNodeBeenEvicted(
    BOOL * pfNodeEvictedOut
    );

//
// Initiate operations that inform interested parties that the cluster
// service is starting up
//
HRESULT
ClRtlInitiateStartupNotification( void );

//
// Initiate operations that inform interested parties that the a node has
// been evicted from the cluster.
//
HRESULT
ClRtlInitiateEvictNotification( LPCWSTR pcszNodeNameIn );

//
// Start a thread that will perform any periodic cleanup needed while the
// service is running.
//
HRESULT
ClRtlInitiatePeriodicCleanupThread( void );

//
// get the domain account in the form of 'user\domain'
//
DWORD
ClRtlGetRunningAccountInfo(
    LPWSTR *    AccountBuffer
    );

//
// Checks if cluster version checking has been disabled on a particular computer.
//
DWORD
ClRtlIsVersionCheckingDisabled(
      const WCHAR * pcszNodeNameIn
    , BOOL *        pfVerCheckDisabledOut
    );

//
// Copy a source file to a destination and flush the destination file buffers.
//
BOOL
ClRtlCopyFileAndFlushBuffers(
    IN LPCWSTR lpszSourceFile,
    IN LPCWSTR lpszDestinationFile
    );

#ifdef __cplusplus
}
#endif

#endif // ifndef _CLUSRTL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clusterwarnings.h ===
// This first line keeps us at least as stringent as the build:
// - from %_ntroot%\base\public\sdk\inc\warning.h
//
#include <warning.h>

/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    RHSWarnings.h

Abstract:
    This header turns on warnings for Level 3 that are normally
    associated with Level 4.

Author:

    Conor Morrison      X-1             17-Jan-2001

Revision History:
--*/
#ifndef IA64
#if 0
//! Would like to get these back in...
#pragma warning ( 3 : 4701 )      // local variable 'name' may be used without having been initialized
#pragma warning ( 3 : 4706 )      // assignment within conditional expression

// These warnings turned off to keep the noise down!
//
#pragma warning ( 3 : 4100 )      // 'identifier' : unreferenced formal parameter
#pragma warning ( 3 : 4201 )      // nonstandard extension used : nameless struct/union
#pragma warning ( 3 : 4127 )      // conditional expression is constant
#pragma warning ( 3 : 4211 )      // nonstandard extension used : redefined extern to static
#pragma warning ( 3 : 4232 )      // nonstandard extension used : 'identifier' : address of dllimport 'dllimport' is not static, identity not guaranteed
#pragma warning ( 3 : 4214 )      // nonstandard extension used : bit field types other than int
#pragma warning ( 3 : 4057 )      // 'operator' : 'identifier1' indirection to slightly different base types from 'identifier2'
#pragma warning ( 3 : 4245 )      // 'conversion' : conversion from 'type1' to 'type2', signed/unsigned mismatch
#pragma warning ( 3 : 4152 )      // non standard extension, function/data ptr conversion in expression
#pragma warning ( 3 : 4514 )      // unreferenced inline/local function has been removed
#pragma warning ( 3 : 4505 )      // 'function' : unreferenced local function has been removed
#pragma warning ( 3 : 4131 )      // 'function' : uses old-style declarator
#endif

#if 1
#pragma warning ( 3 : 4239 )      // nonstandard extension used : 'token' : conversion from 'type' to 'type'

#pragma warning ( 3 : 4019 )      // empty statement at global scope
#pragma warning ( 3 : 4032 )      // formal parameter 'number' has different type when promoted

#pragma warning ( 3 : 4061 )      // enumerate 'identifier' in switch of enum 'identifier' is not explicitly handled by a case label
#pragma warning ( 3 : 4092 )      // sizeof returns 'unsigned long'
#pragma warning ( 3 : 4112 )      // #line requires an integer between 1 and 32767
#pragma warning ( 3 : 4121 )      // 'symbol' : alignment of a member was sensitive to packing
#pragma warning ( 3 : 4125 )      // decimal digit terminates octal escape sequence
#pragma warning ( 3 : 4128 )      // storage-class specifier after type
#pragma warning ( 3 : 4130 )      // 'operator ' : logical operation on address of string constant
#pragma warning ( 3 : 4132 )      // 'object' : const object should be initialized
#pragma warning ( 3 : 4134 )      // conversion between pointers to members of same class
#pragma warning ( 3 : 4200 )      // nonstandard extension used : zero-sized array in struct/union
#pragma warning ( 3 : 4202 )      // nonstandard extension used : '...': prototype parameter in name list illegal
#pragma warning ( 3 : 4206 )      // nonstandard extension used : translation unit is empty
#pragma warning ( 3 : 4207 )      // nonstandard extension used : extended initializer form
#pragma warning ( 3 : 4208 )      // nonstandard extension used : delete [exp] - exp evaluated but ignored
#pragma warning ( 3 : 4209 )      // nonstandard extension used : benign typedef redefinition
#pragma warning ( 3 : 4210 )      // nonstandard extension used : function given file scope
#pragma warning ( 3 : 4212 )      // nonstandard extension used : function declaration used ellipsis
#pragma warning ( 3 : 4213 )      // nonstandard extension used : cast on l-value
#pragma warning ( 3 : 4220 )      // varargs matches remaining parameters
#pragma warning ( 3 : 4221 )      // nonstandard extension used : 'identifier' : cannot be initialized using address of automatic variable 
#pragma warning ( 3 : 4223 )      // nonstandard extension used : non-lvalue array converted to pointer
#pragma warning ( 3 : 4233 )      // nonstandard extension used : 'keyword' keyword only supported in C++, not C
#pragma warning ( 3 : 4234 )      // nonstandard extension used: 'keyword' keyword reserved for future use
#pragma warning ( 3 : 4235 )      // nonstandard extension used : 'keyword' keyword not supported in this product
#pragma warning ( 3 : 4236 )      // nonstandard extension used : 'keyword' is an obsolete keyword, see documentation for __declspec(dllexport )
#pragma warning ( 3 : 4238 )      // nonstandard extension used : class rvalue used as lvalue
#pragma warning ( 3 : 4244 )      // 'conversion' conversion from 'type1' to 'type2', possible loss of data
#pragma warning ( 3 : 4268 )      // 'identifier' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros
#pragma warning ( 3 : 4355 )      // 'this' : used in base member initializer list
#pragma warning ( 3 : 4504 )      // type still ambiguous after parsing 'number' tokens, assuming declaration
#pragma warning ( 3 : 4507 )      // explicit linkage specified after default linkage was used
#pragma warning ( 3 : 4515 )      // 'namespace' : namespace uses itself
#pragma warning ( 3 : 4516 )      // 'class::symbol' : access-declarations are deprecated; member using-declarations provide a better alternative
#pragma warning ( 3 : 4517 )      // access-declarations are deprecated; member using-declarations provice a better alternative
#pragma warning ( 3 : 4611 )      // interaction between '_setjmp' and C++ object destruction is non-portable
#pragma warning ( 3 : 4663 )      // C++ language change: to explicitly specialize class template 'identifier' use the following syntax:
#pragma warning ( 3 : 4665 )      // C++ language change: assuming 'declaration' is an explicit specialization of a function template
#pragma warning ( 3 : 4670 )      // 'identifier' : this base class is inaccessible
#pragma warning ( 3 : 4671 )      // 'identifier' : the copy constructor is inaccessible
#pragma warning ( 3 : 4672 )      // 'identifier1' : ambiguous. First seen as 'identifier2'
#pragma warning ( 3 : 4673 )      // throwing 'identifier' the following types will not be considered at the catch site
#pragma warning ( 3 : 4674 )      // 'identifier' : the destructor is inaccessible
#pragma warning ( 3 : 4699 )      // Note: pre-compiled header usage information message
#pragma warning ( 3 : 4705 )      // statement has no effect
#pragma warning ( 3 : 4709 )      // comma operator within array index expression
#pragma warning ( 3 : 4727 )      // conditional expression is constant

//#pragma warning ( 3 : 4710 )      // 'function' : function not inlined

#endif
#endif // ifndef IA64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\sources.inc ===
!INCLUDE $(PROJECT_ROOT)\cluster\sources.inc

C_DEFINES=$(C_DEFINES) -DSTRSAFE_LIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clusudef.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    clusudef.h

Abstract:

    This module contains definitions of constants used across
    multiple user-mode targets in the cluster project.

Revision History:


Environment:

    User-mode only.

--*/

#ifndef _CLUSUDEF_H_
#define _CLUSUDEF_H_

//default cluster settings
#define CLUSTER_SHUTDOWN_TIMEOUT    60      // default shutdown timeout in minutes

//
// Default cluster property settings
//
#define CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_TIMEOUT_SECS   4 * 60  // Default deadlock timeout in secs
#define CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_THRESHOLD      3       // Default deadlock threshold
#define CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_PERIOD_SECS    30 * 60 // Default deadlock period in secs

//
// Minimum cluster property settings
//
#define CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS   3 * 60 // Minimum deadlock timeout in secs
#define CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_THRESHOLD      0                                                                    
#define CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_PERIOD_SECS    CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS                                                                    

//
// Maximum cluster property settings
//
#define CLUSTER_RESOURCE_DLL_MAXIMUM_DEADLOCK_TIMEOUT_SECS   ((DWORD) -1)                                                                    
#define CLUSTER_RESOURCE_DLL_MAXIMUM_DEADLOCK_THRESHOLD      ((DWORD) -1) 
#define CLUSTER_RESOURCE_DLL_MAXIMUM_DEADLOCK_PERIOD_SECS    ((DWORD) -1) 

//
// Default group property definitions
//
#define CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD    10
#define CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD       6
#define CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE    ClusterGroupPreventFailback
#define CLUSTER_GROUP_FAILBACK_WINDOW_NONE          ((DWORD) -1)
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END   CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_DEFAULT_LOADBAL_STATE         1

//
// Minimum group property definitions
//
#define CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD    0
#define CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD       0
#define CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_START CLUSTER_GROUP_FAILBACK_WINDOW_NONE
#define CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_END   CLUSTER_GROUP_FAILBACK_WINDOW_NONE

//
// Maximum group property definitions
//
#define CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD    ((DWORD) -1)
#define CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD       1193
#define CLUSTER_GROUP_MAXIMUM_AUTO_FAILBACK_TYPE    (ClusterGroupFailbackTypeCount - 1)
#define CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START 23
#define CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END   23

//
// Default resource property definitions
//
#define CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL  ((DWORD) -1)
#define CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE        CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_IS_ALIVE           CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL
#define CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION     ClusterResourceRestartNotify
#define CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD  3
#define CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD     (900 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE  ((DWORD)-1)
#define CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT    (3 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_STARTUP    (5 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_SAMPLE     (    10 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_LOADBAL_ANALYSIS   (5 * 60 * 1000)
#define CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE   ((DWORD) -1)

//
// Minimum resource property definitions
//
#define CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE        10
#define CLUSTER_RESOURCE_MINIMUM_IS_ALIVE           10
#define CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD  0
#define CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD     0
#define CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT    10
#define CLUSTER_RESOURCE_MINIMUM_PERSISTENT_STATE   ((DWORD) -1)

//
// Maximum resource property definitions
//
#define CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE        ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI     ((DWORD) -2)
#define CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE           ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI        ((DWORD) -2)
#define CLUSTER_RESOURCE_MAXIMUM_RESTART_ACTION     (ClusterResourceRestartActionCount - 1)
#define CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD  ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD     ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT    ((DWORD) -1)
#define CLUSTER_RESOURCE_MAXIMUM_PERSISTENT_STATE      1

//
// Default resource type property definitions
//
#define CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE     (5 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_IS_ALIVE        (60 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_QUORUM_CAPABLE      FALSE

//
// Minimum resource type property definitions
//
#define CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE     10
#define CLUSTER_RESTYPE_MINIMUM_IS_ALIVE        10

//
// Maximum resource type property definitions
//
#define CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE     ((DWORD) -1)
#define CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE        ((DWORD) -1)

//
// Default quorum definitions
//
#define CLUSTER_QUORUM_DEFAULT_ARBITRATION_TIMEOUT 60
#define CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE     4 * 1024 * 1024  // 4096 K(4 Meg) PSS:Reqquest a higher sizes
#define CLUSTER_QUORUM_MIN_LOG_SIZE             32 * 1024 //32 K

#define CLUSREG_NAME_SVC_PARAM_NOVER_CHECK  L"NoVersionCheck"
#define CLUSREG_NAME_SVC_PARAM_NOREP_EVTLOGGING  L"NoRepEvtLogging"
#define CLUSREG_NAME_SVC_PARAM_NOGROUPINFO_EVTLOGGING L"NoGroupInfoEvtLogging"
#define CLUSREG_NAME_SVC_PARAM_RESTORE_DB  L"RestoreDatabase"
#define CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB  L"ForceRestoreDatabase"
#define CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER  L"NewQuorumDriveLetter"
#define CLUSREG_NAME_SVC_PARAM_FORCE_QUORUM  L"ForceQuorum"
#define CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST L"ResourceDllUpgradeInProgressList"
#define CLUSREG_NAME_SVC_PARAM_RESMON_EP    L"Endpoint"

//
// Key, value, and property names
//
#define CLUSREG_KEYNAME_CLUSTER             L"Cluster"
#define CLUSREG_KEYNAME_CLUSTER_PARAMETERS  L"Cluster\\Parameters"
#define CLUSREG_KEYNAME_GROUPS              L"Groups"
#define CLUSREG_KEYNAME_NETWORKS            L"Networks"
#define CLUSREG_KEYNAME_NETINTERFACES       L"NetworkInterfaces"
#define CLUSREG_KEYNAME_NODES               L"Nodes"
#define CLUSREG_KEYNAME_QUORUM              L"Quorum"
#define CLUSREG_KEYNAME_RESOURCES           L"Resources"
#define CLUSREG_KEYNAME_RESOURCE_TYPES      L"ResourceTypes"
#define CLUSREG_KEYNAME_PARAMETERS          L"Parameters"
#define CLUSREG_KEYNAME_CLUSSVC_PARAMETERS  L"SYSTEM\\CurrentControlSet\\Services\\ClusSvc\\Parameters"
#define CLUSREG_KEYNAME_CLUSSVC             L"SYSTEM\\CurrentControlSet\\Services\\ClusSvc"
#define CLUSREG_KEYNAME_IMAGE_PATH          L"ImagePath"
#define CLUSREG_KEYNAME_WELCOME_UI          L"WelcomeUI"
#define CLUSREG_KEYNAME_RUNONCE             L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
#define CLUSREG_KEYNAME_NODE_DATA           L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server"
#define CLUSREG_KEYNAME_PREV_OS_INFO        L"PreviousOSVersionInfo"

#define CLUSREG_NAME_EVICTION_STATE         L"NodeHasBeenEvicted"
#define CLUSREG_INSTALL_DIR_VALUE_NAME      L"ClusterInstallationDirectory"
#define CLUSREG_NAME_INSTALLATION_STATE     L"ClusterInstallationState"

#define CLUSREG_NAME_CHARACTERISTICS        L"Characteristics"
#define CLUSREG_NAME_FLAGS                  L"Flags"
#define CLUSREG_NAME_ADMIN_EXT              L"AdminExtensions"
#define CLUSREG_NAME_SECURITY_DLL_NAME      L"SecurityDLL"
#define CLUSREG_NAME_SECURITY_PACKAGE_LIST  L"SecurityPackageList"

#define CLUSREG_NAME_CLUS_NAME              L"ClusterName"
#define CLUSREG_NAME_CLUS_DESC              L"Description"
    // used for NT4 SDs
#define CLUSREG_NAME_CLUS_SECURITY          L"Security"
    // used for NT5 and higher SDs
#define CLUSREG_NAME_CLUS_SD                    L"Security Descriptor"
#define CLUSREG_NAME_CLUS_CLUSTER_NAME_RES      L"ClusterNameResource"
#define CLUSREG_NAME_CLUS_REG_SEQUENCE          L"RegistrySequence"
#define CLUSREG_NAME_CLUS_SHUTDOWN_TIMEOUT      L"ShutdownTimeout"
#define CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE  L"DefaultNetworkRole"
#define CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION    L"EnableEventLogReplication"
#define CLUSREG_NAME_MAX_NODES              L"MaxNodesInCluster"
#define CLUSREG_NAME_CLUS_EVTLOGDELTA_GENERATION L"EnableEventDeltaGeneration"
#define CLUSREG_NAME_CLUS_CLUSTER_INSTANCE_ID     L"ClusterInstanceID"
#define CLUSREG_NAME_CLUS_ENABLE_RESOURCE_DLL_DEADLOCK_DETECTION     L"EnableResourceDllDeadlockDetection"
#define CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_TIMEOUT     L"ResourceDllDeadlockTimeout"
#define CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_THRESHOLD   L"ResourceDllDeadlockThreshold"
#define CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_PERIOD      L"ResourceDllDeadlockPeriod"

#define CLUSREG_NAME_NODE_NAME              L"NodeName"
#define CLUSREG_NAME_NODE_HIGHEST_VERSION   L"NodeHighestVersion"
#define CLUSREG_NAME_NODE_LOWEST_VERSION    L"NodeLowestVersion"
#define CLUSREG_NAME_NODE_DESC              L"Description"
#define CLUSREG_NAME_NODE_PAUSED            L"Paused"
#define CLUSREG_NAME_NODE_MAJOR_VERSION     L"MajorVersion"
#define CLUSREG_NAME_NODE_MINOR_VERSION     L"MinorVersion"
#define CLUSREG_NAME_NODE_BUILD_NUMBER      L"BuildNumber"
#define CLUSREG_NAME_NODE_CSDVERSION        L"CSDVersion"
#define CLUSREG_NAME_NODE_EVTLOG_PROPAGATION L"EnableEventLogReplication"
#define CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT   L"QuorumArbitrationTimeMax"
#define CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER L"QuorumArbitrationTimeMin"
#define CLUSREG_NAME_NODE_PRODUCT_SUITE     L"ProductSuite"
#define CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION    L"DisableGroupPreferredOwnerRandomization"

#define CLUSREG_NAME_GRP_NAME               L"Name"
#define CLUSREG_NAME_GRP_DESC               L"Description"
#define CLUSREG_NAME_GRP_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_GRP_FAILBACK_TYPE      L"AutoFailbackType"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_START L"FailbackWindowStart"
#define CLUSREG_NAME_GRP_FAILBACK_WIN_END   L"FailbackWindowEnd"
#define CLUSREG_NAME_GRP_FAILOVER_THRESHOLD L"FailoverThreshold"
#define CLUSREG_NAME_GRP_FAILOVER_PERIOD    L"FailoverPeriod"
#define CLUSREG_NAME_GRP_PREFERRED_OWNERS   L"PreferredOwners"
#define CLUSREG_NAME_GRP_CONTAINS           L"Contains"
#define CLUSREG_NAME_GRP_LOADBAL_STATE      L"LoadBalState"
#define CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME L"AntiAffinityClassNames"

#define CLUSREG_NAME_RES_NAME               L"Name"
#define CLUSREG_NAME_RES_TYPE               L"Type"
#define CLUSREG_NAME_RES_DESC               L"Description"
#define CLUSREG_NAME_RES_DEBUG_PREFIX       L"DebugPrefix"
#define CLUSREG_NAME_RES_SEPARATE_MONITOR   L"SeparateMonitor"
#define CLUSREG_NAME_RES_PERSISTENT_STATE   L"PersistentState"
#define CLUSREG_NAME_RES_LOOKS_ALIVE        L"LooksAlivePollInterval"
#define CLUSREG_NAME_RES_IS_ALIVE           L"IsAlivePollInterval"
#define CLUSREG_NAME_RES_RESTART_ACTION     L"RestartAction"
#define CLUSREG_NAME_RES_RESTART_THRESHOLD  L"RestartThreshold"
#define CLUSREG_NAME_RES_RESTART_PERIOD     L"RestartPeriod"
#define CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE L"RetryPeriodOnFailure"
#define CLUSREG_NAME_RES_PENDING_TIMEOUT    L"PendingTimeout"
#define CLUSREG_NAME_RES_POSSIBLE_OWNERS    L"PossibleOwners"
#define CLUSREG_NAME_RES_DEPENDS_ON         L"DependsOn"
#define CLUSREG_NAME_RES_LOADBAL_STARTUP    L"LoadBalStartupInterval"
#define CLUSREG_NAME_RES_LOADBAL_SAMPLE     L"LoadBalSampleInterval"
#define CLUSREG_NAME_RES_LOADBAL_ANALYSIS   L"LoadBalAnalysisInterval"
#define CLUSREG_NAME_RES_LOADBAL_PROCESSOR  L"LoadBalMinProcessorUnits"
#define CLUSREG_NAME_RES_LOADBAL_MEMORY     L"LoadBalMinMemoryUnits"
#define CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST L"UserModifiedPossibleNodeList"

#define CLUSREG_NAME_RESTYPE_NAME           L"Name"
#define CLUSREG_NAME_RESTYPE_DESC           L"Description"
#define CLUSREG_NAME_RESTYPE_LOOKS_ALIVE    L"LooksAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_IS_ALIVE       L"IsAlivePollInterval"
#define CLUSREG_NAME_RESTYPE_DLL_NAME       L"DllName"
#define CLUSREG_NAME_RESTYPE_DEBUG_PREFIX   L"DebugPrefix"
#define CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC L"DebugControlFunctions"
#define CLUSREG_NAME_RESTYPE_POSSIBLE_NODES L"PossibleNodes"
#define CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS L"AdminExtensions"

#define CLUSREG_NAME_NET_NAME               L"Name"
#define CLUSREG_NAME_NET_DESC               L"Description"
#define CLUSREG_NAME_NET_ROLE               L"Role"
#define CLUSREG_NAME_NET_PRIORITY           L"Priority"
#define CLUSREG_NAME_NET_TRANSPORT          L"Transport"
#define CLUSREG_NAME_NET_ADDRESS            L"Address"
#define CLUSREG_NAME_NET_ADDRESS_MASK       L"AddressMask"

#define CLUSREG_NAME_NETIFACE_NAME          L"Name"
#define CLUSREG_NAME_NETIFACE_DESC          L"Description"
#define CLUSREG_NAME_NETIFACE_NODE          L"Node"
#define CLUSREG_NAME_NETIFACE_NETWORK       L"Network"
#define CLUSREG_NAME_NETIFACE_ADAPTER_NAME  L"Adapter"
#define CLUSREG_NAME_NETIFACE_ADAPTER_ID    L"AdapterId"
#define CLUSREG_NAME_NETIFACE_ADDRESS       L"Address"
#define CLUSREG_NAME_NETIFACE_ENDPOINT      L"ClusnetEndpoint"
#define CLUSREG_NAME_NETIFACE_STATE         L"State"

#define CLUSREG_NAME_QUORUM_RESOURCE        L"Resource"
#define CLUSREG_NAME_QUORUM_PATH            L"Path"
#define CLUSREG_NAME_QUORUM_MAX_LOG_SIZE    L"MaxQuorumLogSize"
#define CLUSREG_NAME_CHECKPOINT_INTERVAL    L"CheckpointInterval"

#define CLUSREG_NAME_FAILURE_RETRY_COUNT        L"RetryCount"
#define CLUSREG_NAME_FAILURE_RETRY_INTERVAL     L"RetryInterval"

//
// Private property names
//
#define CLUSREG_NAME_PHYSDISK_SIGNATURE             L"Signature"
#define CLUSREG_NAME_PHYSDISK_DRIVE                 L"Drive"
#define CLUSREG_NAME_PHYSDISK_SKIPCHKDSK            L"SkipChkdsk"
#define CLUSREG_NAME_PHYSDISK_CONDITIONAL_MOUNT     L"ConditionalMount"
#define CLUSREG_NAME_PHYSDISK_USEMOUNTPOINTS        L"UseMountPoints"
#define CLUSREG_NAME_PHYSDISK_MPVOLGUIDS            L"MPVolGuids"
#define CLUSREG_NAME_PHYSDISK_VOLGUID               L"VolGuid"
#define CLUSREG_NAME_PHYSDISK_SERIALNUMBER          L"SerialNumber"
#define CLUSREG_NAME_GENAPP_COMMAND_LINE            L"CommandLine"
#define CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY       L"CurrentDirectory"
#define CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP   L"InteractWithDesktop"
#define CLUSREG_NAME_GENAPP_USE_NETWORK_NAME        L"UseNetworkName"
#define CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH      L"ScriptFilepath"
#define CLUSREG_NAME_GENSVC_SERVICE_NAME            L"ServiceName"
#define CLUSREG_NAME_GENSVC_STARTUP_PARAMS          L"StartupParameters"
#define CLUSREG_NAME_GENSVC_USE_NETWORK_NAME        L"UseNetworkName"
#define CLUSREG_NAME_IPADDR_NETWORK                 L"Network"
#define CLUSREG_NAME_IPADDR_ADDRESS                 L"Address"
#define CLUSREG_NAME_IPADDR_SUBNET_MASK             L"SubnetMask"
#define CLUSREG_NAME_IPADDR_ENABLE_NETBIOS          L"EnableNetBIOS"
#define CLUSREG_NAME_IPADDR_OVERRIDE_ADDRMATCH      L"OverrideAddressMatch"
#define CLUSREG_NAME_NETNAME_NAME                   L"Name"
#define CLUSREG_NAME_NETNAME_REMAP_PIPE_NAMES       L"RemapPipeNames"
#define CLUSREG_NAME_NETNAME_REQUIRE_DNS            L"RequireDNS"
#define CLUSREG_NAME_NETNAME_REQUIRE_KERBEROS       L"RequireKerberos"
#define CLUSREG_NAME_NETNAME_STATUS_NETBIOS         L"StatusNetBIOS"
#define CLUSREG_NAME_NETNAME_STATUS_DNS             L"StatusDNS"
#define CLUSREG_NAME_NETNAME_STATUS_KERBEROS        L"StatusKerberos"
#define CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR     L"DefaultSpoolDirectory"
#define CLUSREG_NAME_PRTSPOOL_DRIVER_DIRECTORY      L"ClusterDriverDirectory"
#define CLUSREG_NAME_PRTSPOOL_TIMEOUT               L"JobCompletionTimeout"
#define CLUSREG_NAME_FILESHR_SHARE_NAME             L"ShareName"
#define CLUSREG_NAME_FILESHR_PATH                   L"Path"
#define CLUSREG_NAME_FILESHR_REMARK                 L"Remark"
#define CLUSREG_NAME_FILESHR_MAX_USERS              L"MaxUsers"
#define CLUSREG_NAME_FILESHR_SECURITY               L"Security"
#define CLUSREG_NAME_FILESHR_SD                     L"Security Descriptor"
#define CLUSREG_NAME_FILESHR_SHARE_SUBDIRS          L"ShareSubDirs"
#define CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES     L"HideSubDirShares"
#define CLUSREG_NAME_FILESHR_IS_DFS_ROOT            L"IsDfsRoot"
#define CLUSREG_NAME_FILESHR_CSC_CACHE              L"CSCCache"
#define CLUSREG_NAME_DHCP_DATABASE_PATH             L"DatabasePath"
#define CLUSREG_NAME_DHCP_BACKUP_PATH               L"BackupPath"
#define CLUSREG_NAME_WINS_DATABASE_PATH             L"DatabasePath"
#define CLUSREG_NAME_WINS_BACKUP_PATH               L"BackupPath"

//
// Standard Resource Type Names
//
#define CLUS_RESTYPE_NAME_GENAPP            L"Generic Application"
#define CLUS_RESTYPE_NAME_GENSVC            L"Generic Service"
#define CLUS_RESTYPE_NAME_FTSET             L"Fault Tolerant Disk Set"
#define CLUS_RESTYPE_NAME_PHYS_DISK         L"Physical Disk"
#define CLUS_RESTYPE_NAME_IPADDR            L"IP Address"
#define CLUS_RESTYPE_NAME_NETNAME           L"Network Name"
#define CLUS_RESTYPE_NAME_FILESHR           L"File Share"
#define CLUS_RESTYPE_NAME_PRTSPLR           L"Print Spooler"
#define CLUS_RESTYPE_NAME_TIMESVC           L"Time Service"
#define CLUS_RESTYPE_NAME_LKQUORUM          L"Local Quorum"
#define CLUS_RESTYPE_NAME_DHCP              L"DHCP Service"
#define CLUS_RESTYPE_NAME_MSMQ              L"Microsoft Message Queue Server"
#define CLUS_RESTYPE_NAME_NEW_MSMQ          L"MSMQ"
#define CLUS_RESTYPE_DISPLAY_NAME_NEW_MSMQ  L"Message Queuing"
#define CLUS_RESTYPE_NAME_MSDTC             L"Distributed Transaction Coordinator"
#define CLUS_RESTYPE_NAME_WINS              L"WINS Service"
#define CLUS_RESTYPE_NAME_IIS4              L"IIS Server Instance"
#define CLUS_RESTYPE_NAME_SMTP              L"SMTP Server Instance"
#define CLUS_RESTYPE_NAME_NNTP              L"NNTP Server Instance"
#define CLUS_RESTYPE_NAME_GENSCRIPT         L"Generic Script"
#define CLUS_RESTYPE_NAME_MAJORITYNODESET   L"Majority Node Set"


#define CLUS_NAME_DEFAULT_FILESPATH L"MSCS\\"
#define MAJORITY_NODE_SET_DIRECTORY_PREFIX L"MNS."

//
// Misc. strings
//

#define  CLUSTER_SERVICE_NAME       L"ClusSvc"
#define  TIME_SERVICE_NAME          L"TimeServ"
#define  CLUSTER_DIRECTORY          L"%windir%\\cluster"
#define  CLUSTER_DATABASE_NAME      L"CLUSDB"
#define  CLUSTER_DATABASE_TMPBKP_NAME L"CLUSDB.BKP$"

//
// Clussvc Clusnet Heartbeating defines. Nobody outside NM need to know this.
//
#define CLUSTER_HEARTBEAT_TIMEOUT_KEYNAME           L"ClusSvcHeartbeatTimeout"
#define CLUSTER_HANG_RECOVERY_ACTION_KEYNAME        L"HangRecoveryAction"
#define CLUSTER_HEARTBEAT_TIMEOUT_MIN                6 // 6 secs
#define CLUSTER_HEARTBEAT_TIMEOUT_DEFAULT           60 // 1 min
#define CLUSTER_HANG_RECOVERY_ACTION_DEFAULT        ClussvcHangActionTerminateService
#define RGP_CLOCK_PERIOD                              300 // 300 ms, copied from secvice\mm\Jrgpos.h

#endif // _CLUSUDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      PropList.h
//
//  Implementation File:
//      PropListSrc.cpp
//
//  Description:
//      Definition of the CClusPropList class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-MAY-2000
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <clusapi.h>

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusPropValueList;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Macro Definitions
/////////////////////////////////////////////////////////////////////////////

#if ! defined( THR )
#define THR( _hr ) _hr
#endif

#if ! defined( TW32 )
#define TW32( _w32sc ) _w32sc
#endif

#if ! defined( TW32E )
#define TW32E( _w32sc, _errIgnore ) _w32sc
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if ! defined( Assert )
#if defined( ASSERT )
#define Assert ASSERT
#else
#include <crtdbg.h>
#define ASSERT _ASSERTE
#define Assert _ASSERTE
#endif // else: ASSERT
#endif // if: ! Assert

#if ! defined( ASSERT )
#if defined( Assert )
#define ASSERT Assert
#else
#include <crtdbg.h>
#define ASSERT _ASSERTE
#define Assert _ASSERTE
#endif // else: Assert
#endif // if: ! ASSERT

#pragma warning( push )
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CObjectProperty
//
//  Description:
//      Describes a property in a cluster property list.
//
//  Inheritance:
//      CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////

#if defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

class CObjectProperty
{
public:
    LPCWSTR                 m_pwszName;
    CLUSTER_PROPERTY_FORMAT m_propFormat;

    union CValue
    {
        CString *   pstr;
        LONG *      pl;
        DWORD *     pdw;
        BOOL *      pb;
        struct
        {
            PBYTE * ppb;
            DWORD * pcb;
        };
    };
    CValue                  m_value;
    CValue                  m_valuePrev;
    CValue                  m_valueEx;      // expand_sz value (if any)

    DWORD                   m_fFlags;

    enum ObjPropFlags
    {
        opfNew = 1
    };

    CObjectProperty::CObjectProperty( void )
    {
        m_value.pstr = NULL;
        m_value.pcb = NULL;
        m_valuePrev.pstr = NULL;
        m_valuePrev.pcb = NULL;
        m_valueEx.pstr = NULL;
        m_valueEx.pcb = NULL;
    };

    void    Set(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    void    SetExpandSz(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    // Set() to get extra EXPANDED_SZ value
    void    Set(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN CString & rstrValueEx,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_valueEx.pstr = &rstrValueEx;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    // Set() to get extra EXPANDED_SZ value
    void    SetExpandSz(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN CString & rstrValueEx,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_valueEx.pstr = &rstrValueEx;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    void    Set(
                IN LPCWSTR pwszName,
                IN LONG & rnValue,
                IN LONG & rnPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_LONG;
        m_value.pl = &rnValue;
        m_valuePrev.pl = &rnPrevValue;
        m_fFlags = fFlags;

    } //*** Set( LONG & )

    void    Set(
                IN LPCWSTR pwszName,
                IN DWORD & rdwValue,
                IN DWORD & rdwPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_DWORD;
        m_value.pdw = &rdwValue;
        m_valuePrev.pdw = &rdwPrevValue;
        m_fFlags = fFlags;

    } //*** Set( DWORD & )

    void    Set(
                IN LPCWSTR pwszName,
                IN BOOL & rbValue,
                IN BOOL & rbPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_DWORD;
        m_value.pb = &rbValue;
        m_valuePrev.pb = &rbPrevValue;
        m_fFlags = fFlags;

    } //*** Set( BOOL & )

    void    Set(
                IN LPCWSTR pwszName,
                IN PBYTE & rpbValue,
                IN DWORD & rcbValue,
                IN PBYTE & rpbPrevValue,
                IN DWORD & rcbPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_BINARY;
        m_value.ppb = &rpbValue;
        m_value.pcb = &rcbValue;
        m_valuePrev.ppb = &rpbPrevValue;
        m_valuePrev.pcb = &rcbPrevValue;
        m_fFlags = fFlags;

    } //*** Set( PBYTE & )

    void    Set(
                IN LPCWSTR pwszName,
                IN LPWSTR & rpwszValue,
                IN DWORD & rcbValue,
                IN LPWSTR & rpwszPrevValue,
                IN DWORD & rcbPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
        m_value.ppb = reinterpret_cast< PBYTE * >( &rpwszValue );
        m_value.pcb = &rcbValue;
        m_valuePrev.ppb = reinterpret_cast< PBYTE * >( &rpwszPrevValue );
        m_valuePrev.pcb = &rcbPrevValue;
        m_fFlags = fFlags;

    } //*** Set( LPWSTR & )

}; //*** class CObjectProperty

#endif  // defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropValueList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropValueList
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusPropValueList
{
public:
    //
    // Construction.
    //

    // Default constructor
    CClusPropValueList( void )
        : m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_cbBufferSize( 0 )
        , m_fAtEnd( FALSE )
    {
        m_cbhValueList.pb = NULL;
        m_cbhCurrentValue.pb = NULL;

    } //*** CClusPropValueList

    // Copy constructor.
    CClusPropValueList( IN const CClusPropValueList & rcpvl )
        : m_cbBufferSize( 0 )
        , m_fAtEnd( FALSE )
    {
        Init( rcpvl );

    } //*** CClusPropValueList

    // Buffer helper constructor.
    CClusPropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN size_t cbDataSize )
        : m_cbBufferSize( 0 )
        , m_fAtEnd( FALSE )
    {
        Init( cbhValueList, cbDataSize );

    } //*** CClusPropValueList

    // Destructor
    ~CClusPropValueList( void )
    {
        DeleteValueList();

    } //*** ~CClusPropValueList

    // Initialize the value list
    void Init( IN const CClusPropValueList & rcpvl )
    {
        Assert( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_fAtEnd            = rcpvl.m_fAtEnd;

    } //*** Init

    // Initialize the value list from a buffer helper
    void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN size_t cbDataSize )
    {
        Assert( m_cbBufferSize == 0 );

        m_cbhValueList      = cbhValueList;
        m_cbhCurrentValue   = cbhValueList;
        m_cbDataSize        = cbDataSize;
        m_cbDataLeft        = cbDataSize;
        m_fAtEnd            = FALSE;

    } //*** Init

    // Assignment operator
    void operator=( IN const CClusPropValueList & rcpvl )
    {
        Assert( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_fAtEnd            = rcpvl.m_fAtEnd;

    } //*** operator=

public:
    //
    // Accessor methods.
    //

    // Buffer helper cast operator to access the current value
    operator const CLUSPROP_BUFFER_HELPER( void ) const
    {
        return m_cbhCurrentValue;

    } //*** operator CLUSPROP_BUFFER_HELPER

    // Access the value list
    CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
    {
        return m_cbhValueList;

    } //*** CbhValueList

    // Access the current value
    CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
    {
        return m_cbhCurrentValue;

    } //*** CbhCurrentValue

    // Access the format of the current value
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

    } //*** CpfCurrentValueFormat

    // Access the format of the current format list syntax entry
    CLUSTER_PROPERTY_FORMAT CpfCurrentFormatListSyntax( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pWordValue->w );

    } //*** CpfCurrentFormatListSyntax

    // Access the type of the current value
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

    } //*** CptCurrentValueType

    // Access the syntax of the current value
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

    } //*** CpsCurrentValueSyntax

    // Access the length of the data of the current value
    DWORD CbCurrentValueLength( void ) const
    {
        DWORD cbLength;

        if ( m_cbhCurrentValue.pb == NULL )
        {
            cbLength = 0;
        } // if: no value list allocated yet
        else
        {
            cbLength = m_cbhCurrentValue.pValue->cbLength;
        } // else: value list allocated

        return cbLength;

    } //*** CbCurrentValueLength

    // Access size of the data in the buffer.
    size_t CbDataSize( void ) const
    {
        return m_cbDataSize;

    } //*** CbDataSize

    // Access amount of data left in buffer after current value
    size_t CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft

public:
    //
    // Parsing methods.
    //

    // Move to the first value in the list
    DWORD ScMoveToFirstValue( void );

    // Move the value after the current one in the list
    DWORD ScMoveToNextValue( void );

    // Query whether we are at the last value in the list or not
    DWORD ScCheckIfAtLastValue( void );

public:
    //
    // Methods for building a value list.
    //

    // Allocate a value list
    DWORD ScAllocValueList( IN size_t cbMinimum );

    // Delete the value list buffer and cleanup support variables
    void DeleteValueList( void )
    {
        //
        // If m_cbBufferSize is greater then 0 then we allocated the value list.
        // If it's zero then the value list is a part of the property list in
        // CClusPropList.
        //
        if ( m_cbBufferSize > 0 )
        {
            delete [] m_cbhValueList.pb;
            m_cbhValueList.pb = NULL;
            m_cbhCurrentValue.pb = NULL;
            m_cbBufferSize = 0;
            m_cbDataSize = 0;
            m_cbDataLeft = 0;
            m_fAtEnd = FALSE;
        } // if: we allocated anything

    } //*** DeletePropList

    // Get a value list from a resource
    DWORD ScGetResourceValueList(
                        IN HRESOURCE    hResource,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN size_t       cbInBufferSize  = 0
                        );

    // Get a value list from a resource type
    DWORD ScGetResourceTypeValueList(
                        IN HCLUSTER hCluster,
                        IN LPCWSTR  pwszResTypeName,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN size_t   cbInBufferSize  = 0
                        );

private:
    CLUSPROP_BUFFER_HELPER  m_cbhValueList;     // Pointer to the value list for parsing.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentValue;  // Pointer to the current value for parsing.
    size_t                  m_cbDataSize;       // Amount of data in the buffer.
    size_t                  m_cbDataLeft;       // Amount of data left in buffer after current value.
    size_t                  m_cbBufferSize;     // Size of the buffer if we allocated it.
    BOOL                    m_fAtEnd;           // Indicates whether at last value in list.

}; //*** class CClusPropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropList
//      CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusPropList
{
public:
    //
    // Construction.
    //

    // Default constructor
    CClusPropList( IN BOOL fAlwaysAddProp = FALSE )
        : m_fAlwaysAddProp( fAlwaysAddProp )
        , m_cbBufferSize( 0 )
        , m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_nPropsRemaining( 0 )
    {
        m_cbhPropList.pList     = NULL;
        m_cbhCurrentProp.pb     = NULL;
        m_cbhCurrentPropName.pb = NULL;

    } //*** CClusPropList

    // Destructor
    ~CClusPropList( void )
    {
        DeletePropList();

    } //*** ~CClusPropList

    // Copy list into this list (like assignment operator)
    DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN size_t cbListSize );

    // Append list into this list
    DWORD ScAppend( IN const CClusPropList & rclPropList );

    // Delete the property list buffer and cleanup support variables
    void DeletePropList( void )
    {
        delete [] m_cbhPropList.pb;
        m_cbhPropList.pb = NULL;
        m_cbhCurrentProp.pb = NULL;
        m_cbhCurrentPropName.pb = NULL;
        m_cbBufferSize = 0;
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

    } //*** DeletePropList

protected:
    //
    // Attributes.
    //

    BOOL                    m_fAlwaysAddProp;       // Indicate if properties should be added even if not different.
    CLUSPROP_BUFFER_HELPER  m_cbhPropList;          // Pointer to the beginning of the list.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentProp;       // Pointer to the current property.
    size_t                  m_cbBufferSize;         // Allocated size of the buffer.
    size_t                  m_cbDataSize;           // Amount of data in the buffer.
    size_t                  m_cbDataLeft;           // Amount of data left in buffer after current value.

private:
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentPropName;   // Pointer to the current name for parsing
    DWORD                   m_nPropsRemaining;      // Used by BMoveToNextProperty() to track end of list.
    CClusPropValueList      m_pvlValues;            // Helper class for value list of current property.

public:
    //
    // Accessor methods.
    //

    // Access the values of the current property
    const CClusPropValueList & RPvlPropertyValue( void )
    {
        return m_pvlValues;

    } //*** RPvlPropertyValue

    // Access the property list
    operator PCLUSPROP_LIST( void ) const
    {
        return m_cbhPropList.pList;

    } //*** operator PCLUSPROP_LIST

    // Access allocated size of the buffer
    size_t CbBufferSize( void ) const
    {
        return m_cbBufferSize;

    } //*** CbBufferSize

    // Access the name of the current property
    LPCWSTR PszCurrentPropertyName( void ) const
    {
        return m_cbhCurrentPropName.pName->sz;

    } //*** PszCurrentPropertyName

    // Access the current property name as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
    {
        return m_cbhCurrentPropName;

    } //*** CbhCurrentPropertyName

    // Access value list of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
    {
        return m_pvlValues.CbhValueList();

    } //*** CbhCurrentValueList

    // Access current value of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
    {
        return m_pvlValues.CbhCurrentValue();

    } //*** CbhCurrentValue

    // Access the format of the current value of the current property
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return m_pvlValues.CpfCurrentValueFormat();

    } //*** CpfCurrentValueFormat

    // Access the format of the current format list syntax entry
    CLUSTER_PROPERTY_FORMAT CpfCurrentFormatListSyntax( void ) const
    {
        return m_pvlValues.CpfCurrentFormatListSyntax();

    } //*** CpfCurrentFormatListSyntax

    // Access the type of the current value of the current property
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return m_pvlValues.CptCurrentValueType();

    } //*** CptCurrentValueType

    // Access the syntax of the current value of the current property
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return m_pvlValues.CpsCurrentValueSyntax();

    } //*** CpsCurrentValueSyntax

    // Access the length of the current value of the current property
    size_t CbCurrentValueLength( void ) const
    {
        return m_pvlValues.CbCurrentValueLength();

    } //*** CbCurrentValueLength

    PCLUSPROP_LIST Plist( void )
    {
        return m_cbhPropList.pList;

    } //*** Plist

    const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
    {
        return m_cbhPropList;

    } //*** CbhPropList

    PBYTE PbPropList( void ) const
    {
        return m_cbhPropList.pb;

    } //*** PbPropList

    size_t CbPropList( void ) const
    {
        //
        //  m_cbDataSize contains the size of the data, including
        //  the last endmark.  It does not however contain the size
        //  of the property count at the head of the list.
        //
        return m_cbDataSize + sizeof( m_cbhPropList.pList->nPropertyCount );

    } //*** CbPropList

    // Access amount of data left in buffer after current value
    size_t CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft

    DWORD Cprops( void ) const
    {
        if ( m_cbhPropList.pb == NULL )
        {
            return 0;
        } // if:  no buffer yet

        return m_cbhPropList.pList->nPropertyCount;

    } //*** Cprops

public:
    //
    // Parsing methods.
    //

    // Initialize the size after getting properties from an external source
    void InitSize( IN size_t cbSize )
    {
        Assert( m_cbhPropList.pb != NULL );
        Assert( m_cbBufferSize > 0 );

        m_cbDataSize = cbSize;
        m_cbDataLeft = cbSize;

    } //*** InitSize

    // Move to the first property in the list
    DWORD ScMoveToFirstProperty( void );

    // Move the property after the current one in the list
    DWORD ScMoveToNextProperty( void );

    // Move to a property by specifying its name
    DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

    // Move to the first value in the current property
    DWORD ScMoveToFirstPropertyValue( void )
    {
        return TW32( m_pvlValues.ScMoveToFirstValue() );

    } //*** ScMoveToFirstPropertyValue

    // Move the the value after the current on in the current property
    DWORD ScMoveToNextPropertyValue( void )
    {
        return TW32( m_pvlValues.ScMoveToNextValue() );

    } //*** ScMoveToNextPropertyValue

    // Query whether we are at the last property in the list or not
    DWORD ScCheckIfAtLastProperty( void ) const
    {
        DWORD sc;

        if ( m_nPropsRemaining <= 1 )
        {
            sc = ERROR_NO_MORE_ITEMS;
        } // if:  at the last property
        else
        {
            sc = ERROR_SUCCESS;
        } // else:  not at the last property

        return sc;

    } //*** ScCheckIfAtLastProperty

    // Query whether the list is empty or not
    BOOL BIsListEmpty( void ) const
    {
        Assert( ( m_cbhPropList.pb == NULL )
            ||  ( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) )
            );

        return ( ( m_cbhPropList.pList == NULL ) || ( m_cbhPropList.pList->nPropertyCount == 0 ) );

    } //*** BIsListEmpty

public:
    //
    // Methods for building a property list.
    //

    // Allocate a property list
    DWORD ScAllocPropList( IN size_t cbMinimum );

    void ClearPropList( void )
    {
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

        if ( m_cbBufferSize != 0 )
        {
            ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
            m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
            m_cbhCurrentPropName = m_cbhCurrentProp;
        } // if:  buffer already allocated

    } //*** ClearPropList

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LONGLONG llValue, IN LONGLONG llPrevValue );

    DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

    DWORD ScAddProp(
            IN LPCWSTR                  pwszName,
            IN const unsigned char *    pbValue,
            IN size_t                   cbValue,
            IN const unsigned char *    pbPrevValue,
            IN size_t                   cbPrevValue
            );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return TW32( ScAddProp( pwszName, pwszValue, NULL ) );

    } //*** ScAddProp

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return TW32( ScAddExpandSzProp( pwszName, pwszValue, NULL ) );

    } //*** ScAddExpandSzProp

public:
    //
    // Get Property methods.
    //

    DWORD ScGetNodeProperties(
                        IN HNODE    hNode,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN size_t   cbInBufferSize  = 0
                        );

    DWORD ScGetGroupProperties(
                        IN HGROUP   hGroup,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN size_t   cbInBufferSize  = 0
                        );

    DWORD ScGetResourceProperties(
                        IN HRESOURCE    hResource,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN size_t       cbInBufferSize  = 0
                        );

    DWORD ScGetResourceTypeProperties(
                        IN HCLUSTER hCluster,
                        IN LPCWSTR  pwszResTypeName,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN size_t   cbInBufferSize  = 0
                        );

    DWORD ScGetNetworkProperties(
                        IN HNETWORK hNetwork,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN size_t   cbInBufferSize  = 0
                        );

    DWORD ScGetNetInterfaceProperties(
                        IN HNETINTERFACE    hNetInterface,
                        IN DWORD            dwControlCode,
                        IN HNODE            hHostNode       = NULL,
                        IN LPVOID           lpInBuffer      = NULL,
                        IN size_t           cbInBufferSize  = 0
                        );

    DWORD ScGetClusterProperties(
                        IN HCLUSTER hCluster,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN size_t   cbInBufferSize  = 0
                        );

// Implementation
protected:
    void CopyProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyExpandSzProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyMultiSzProp(
            IN PCLUSPROP_MULTI_SZ       pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyProp(
            IN PCLUSPROP_DWORD          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN DWORD                    nValue
            );

#if CLUSAPI_VERSION >= 0x0500

    void CopyProp(
            IN PCLUSPROP_LONG           pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LONG                     nValue
            );

#endif // CLUSAPI_VERSION >= 0x0500

    void CopyProp(
            OUT PCLUSPROP_ULARGE_INTEGER    pprop,
            IN  CLUSTER_PROPERTY_TYPE       proptype,
            IN  ULONGLONG                   ullValue
            );

    void CopyProp(
            OUT PCLUSPROP_LARGE_INTEGER     pprop,
            IN  CLUSTER_PROPERTY_TYPE       proptype,
            IN  LONGLONG                    llValue
            );

    void CopyProp(
            IN PCLUSPROP_BINARY         pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN const unsigned char *    pb,
            IN size_t                   cb
            );

    void CopyEmptyProp(
            IN PCLUSPROP_VALUE          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN CLUSTER_PROPERTY_FORMAT  propfmt
            );

}; //*** class CClusPropList

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\clusverp.h ===
/****************************************************************************
 *                                                                          *
 *      clusverp.H        -- Version information for cluster builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

#include <ntverp.h>

//
// the following defines are used as internal version numbers to indicate
// the level of compatibility provided by this cluster service implmentation.
// These numbers are changed during product upgrades and are, essentially,
// a combination of the major, minor and QFE versions The QFE version info
// is not available but only as a text string from GetVersionEx hence we
// don't use that information directly.
//

#define CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION 4
#define CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION 0x00030893
#define CLUSTER_INTERNAL_PREVIOUS_LOWEST_VERSION 0x000200e0

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

#define VER_CLUSTER_PRODUCTNAME_STR         "Microsoft(R) Cluster service"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\diskarbp.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    diskarbp.h

Abstract:

    This module defines the structures that are used
    to perform disk arbitration in clusdisk\ driver
    and resdll\disks disk resource.
    
Authors:

    Gor Nishanov (t-gorn)     18-June-1998

Revision History:

--*/

#ifndef _DISK_ARBITRATE_P_
#define _DISK_ARBITRATE_P_

#ifndef min
#define min( a, b ) ((a) <= (b) ? (a) : (b))
#endif

typedef struct _START_RESERVE_DATA {
   ULONG  DiskSignature;
   ULONG  Version;   
   ULONG  ArbitrationSector;
   ULONG  SectorSize;
   USHORT NodeSignatureSize;
   UCHAR  NodeSignature[32]; // MAX_COMPUTERNAME_LENGTH + 1
} 
START_RESERVE_DATA, *PSTART_RESERVE_DATA;

#define START_RESERVE_DATA_V1_SIG (sizeof(START_RESERVE_DATA))

typedef struct _ARBITRATION_ID {
   LARGE_INTEGER SystemTime;
   LARGE_INTEGER SeqNo;
   UCHAR         NodeSignature[32];
} ARBITRATION_ID, *PARBITRATION_ID;

#define RESERVE_TIMER   3      // 3 seconds to perform reserves

//
// IOCTL_ARBITRATION_ESCAPE subcodes
//

typedef enum {
   AE_TEST,
   AE_READ,
   AE_WRITE,
   AE_POKE,
   AE_RESET,
   AE_RESERVE,
   AE_RELEASE,
   AE_SECTORSIZE
} ARBITRATION_ESCAPE_SUBCODES;

typedef struct _ARBITRATION_READ_WRITE_PARAMS {
   ULONG Operation;
   ULONG SectorSize;
   ULONG SectorNo;
   PVOID Buffer;
   ULONG Signature;
} ARBITRATION_READ_WRITE_PARAMS, * PARBITRATION_READ_WRITE_PARAMS;

#define ARBITRATION_READ_WRITE_PARAMS_SIZE sizeof(ARBITRATION_READ_WRITE_PARAMS)

#endif // _DISK_ARBITRATE_P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\cnetapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnetapi.h

Abstract:

    Cluster Network driver control APIs

Author:

    Mike Massa (mikemas)  14-Feb-1997

Environment:

    User Mode.

Revision History:

--*/


#ifndef _CNETAPI_INCLUDED
#define _CNETAPI_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Join Phases
//

typedef enum {
    ClusnetJoinPhase1 = 1,
    ClusnetJoinPhase2 = 2,
    ClusnetJoinPhase3 = 3,
    ClusnetJoinPhase4 = 4,
    ClusnetJoinPhaseAbort = 0xFFFFFFFF
}  CLUSNET_JOIN_PHASE;


//
// Event Handler Routines.
//
typedef
VOID
(*CLUSNET_NODE_UP_ROUTINE)(
    IN CL_NODE_ID   NodeId
    );

typedef
VOID
(*CLUSNET_NODE_DOWN_ROUTINE)(
    IN CL_NODE_ID   NodeId
    );

typedef
BOOL
(*CLUSNET_CHECK_QUORUM_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_HOLD_IO_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_RESUME_IO_ROUTINE)(
    VOID
    );

typedef
VOID
(*CLUSNET_HALT_ROUTINE)(
    IN DWORD HaltCode
    );

//
// Routines
//
HANDLE
ClusnetOpenControlChannel(
    IN ULONG ShareAccess
    );

#define ClusnetCloseControlChannel(_handle)  CloseHandle(_handle)

DWORD
ClusnetEnableShutdownOnClose(
    IN HANDLE  ControlChannel
    );

DWORD
ClusnetDisableShutdownOnClose(
    IN HANDLE  ControlChannel
    );

DWORD
ClusnetInitialize(
    IN HANDLE                             ControlChannel,
    IN CL_NODE_ID                         LocalNodeId,
    IN ULONG                              MaxNodes,
    IN CLUSNET_NODE_UP_ROUTINE            NodeUpRoutine,
    IN CLUSNET_NODE_DOWN_ROUTINE          NodeDownRoutine,
    IN CLUSNET_CHECK_QUORUM_ROUTINE       CheckQuorumRoutine,
    IN CLUSNET_HOLD_IO_ROUTINE            HoldIoRoutine,
    IN CLUSNET_RESUME_IO_ROUTINE          ResumeIoRoutine,
    IN CLUSNET_HALT_ROUTINE               HaltRoutine
    );

DWORD
ClusnetShutdown(
    IN HANDLE       ControlChannel
    );

DWORD
ClusnetRegisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    );

DWORD
ClusnetDeregisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    );

DWORD
ClusnetRegisterNetwork(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority,
    IN BOOLEAN              Restricted
    );

DWORD
ClusnetDeregisterNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    );

DWORD
ClusnetRegisterInterface(
    IN  HANDLE               ControlChannel,
    IN  CL_NODE_ID           NodeId,
    IN  CL_NETWORK_ID        NetworkId,
    IN  ULONG                Priority,
    IN  PWSTR                AdapterId,
    IN  ULONG                AdapterIdLength,
    IN  PVOID                TdiAddress,
    IN  ULONG                TdiAddressLength,
    OUT PULONG               MediaStatus
    );

DWORD
ClusnetDeregisterInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOnlineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    );

DWORD
ClusnetOfflineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    );

DWORD
ClusnetOnlineNetwork(
    IN  HANDLE          ControlChannel,
    IN  CL_NETWORK_ID   NetworkId,
    IN  PWCHAR          TdiProviderName,
    IN  PVOID           TdiBindAddress,
    IN  ULONG           TdiBindAddressLength,
    IN  LPWSTR          AdapterName,
    OUT PVOID           TdiBindAddressInfo,
    IN  PULONG          TdiBindAddressInfoLength
    );

DWORD
ClusnetOfflineNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    );

DWORD
ClusnetSetNetworkRestriction(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN BOOLEAN              Restricted,
    IN ULONG                NewPriority
    );

DWORD
ClusnetGetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              Priority
    );

DWORD
ClusnetSetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetGetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    );

DWORD
ClusnetSetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority
    );

DWORD
ClusnetGetNodeCommState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  State
    );

DWORD
ClusnetGetNetworkState(
    IN  HANDLE                  ControlChannel,
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    );

DWORD
ClusnetGetInterfaceState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    );

#ifdef MM_IN_CLUSNET

DWORD
ClusnetFormCluster(
    IN HANDLE       ControlChannel,
    IN ULONG        ClockPeriod,
    IN ULONG        SendHBRate,
    IN ULONG        RecvHBRate
    );

DWORD
ClusnetJoinCluster(
    IN     HANDLE              ControlChannel,
    IN     CL_NODE_ID          JoiningNodeId,
    IN     CLUSNET_JOIN_PHASE  Phase,
    IN     ULONG               JoinTimeout,
    IN OUT PVOID *             MessageToSend,
    OUT    PULONG              MessageLength,
    OUT    PULONG              DestNodeMask
    );

VOID
ClusnetEndJoinCluster(
    IN HANDLE  ControlChannel,
    IN PVOID   LastSentMessage
    );

DWORD
ClusnetDeliverJoinMessage(
    IN HANDLE  ControlChannel,
    IN PVOID   Message,
    IN ULONG   MessageLength
    );

DWORD
ClusnetLeaveCluster(
    IN HANDLE       ControlChannel
    );

DWORD
ClusnetEvictNode(
    IN HANDLE       ControlChannel,
    IN ULONG        NodeId
    );

#endif // MM_IN_CLUSNET

DWORD
ClusnetGetNodeMembershipState(
    IN  HANDLE ControlChannel,
    IN  ULONG NodeId,
    OUT CLUSNET_NODE_STATE * State
    );

DWORD
ClusnetSetNodeMembershipState(
    IN  HANDLE ControlChannel,
    IN  ULONG NodeId,
    IN  CLUSNET_NODE_STATE State
    );

DWORD
ClusnetSetEventMask(
    IN  HANDLE              ControlChannel,
    IN  CLUSNET_EVENT_TYPE  EventMask
    );

DWORD
ClusnetGetNextEvent(
    IN  HANDLE          ControlChannel,
    OUT PCLUSNET_EVENT  Event,
    IN  LPOVERLAPPED    Overlapped  OPTIONAL
    );

DWORD
ClusnetHalt(
    IN  HANDLE  ControlChannel
    );

DWORD
ClusnetSetMemLogging(
    IN  HANDLE  ControlChannel,
    IN  ULONG   NumberOfEntires
    );

DWORD
ClusnetSendPoisonPacket(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId
    );

DWORD
ClusnetSetOuterscreen(
    IN HANDLE          ControlChannel,
    IN ULONG           Outerscreen
    );

DWORD
ClusnetRegroupFinished(
    IN HANDLE          ControlChannel,
    IN ULONG           EventEpoch,
    IN ULONG           RegroupEpoch
    );

DWORD
ClusnetImportSecurityContexts(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      JoiningNodeId,
    IN PWCHAR          PackageName,
    IN ULONG           SignatureSize,
    IN PVOID           ServerContext,
    IN PVOID           ClientContext
    );

DWORD
ClusnetReserveEndpoint(
    IN HANDLE   ControlChannel,
    IN PWSTR    EndpointString
    );

DWORD
ClusnetConfigureMulticast(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                MulticastNetworkBrand,
    IN PVOID                MulticastAddress,
    IN ULONG                MulticastAddressLength,
    IN PVOID                Key,
    IN ULONG                KeyLength
    );

DWORD
ClusnetGetMulticastReachableSet(
    IN  HANDLE               ControlChannel,
    IN  CL_NETWORK_ID        NetworkId,
    OUT ULONG              * NodeScreen
    );

DWORD
ClusnetSetIamaliveParam(
    IN HANDLE               ControlChannel,
    IN ULONG                TimeoutTicks,
    IN ClussvcHangAction    Action
    );

DWORD
ClusnetIamalive(
    IN HANDLE               ControlChannel
    );

#if DBG

//
// Test routines - available in debug builds only.
//

DWORD
ClusnetSetDebugMask(
    IN HANDLE   ControlChannel,
    ULONG       Mask
    );

DWORD
ClusnetOnlinePendingInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOnlineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetOfflineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetFailInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    );

DWORD
ClusnetSendMmMsg(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN ULONG           Pattern
    );

#endif // DBG


#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // ndef _CNETAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\proplistsrc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      PropListSrc.cpp
//
//  Header File:
//      PropList.h
//
//  Description:
//      Implementation of the CClusPropList class.
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-MAY-2000
//
/////////////////////////////////////////////////////////////////////////////

#include <StrSafe.h>
#include <PropList.h>
#include "clstrcmp.h"

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CchMultiSz
//
//  Description:
//      Length of all of the substrings of a multisz string minus the final NULL.
//
//      (i.e., includes the nulls of the substrings, excludes the final null)
//      multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//  Arguments:
//      psz     [IN] The string to get the length of.
//
//  Return Value:
//      Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static size_t CchMultiSz(
    IN LPCWSTR psz
    )
{
    Assert( psz != NULL );

    size_t  _cchTotal = 0;
    size_t  _cchChars;

    while ( *psz != L'\0' )
    {
        _cchChars = wcslen( psz ) + 1;

        _cchTotal += _cchChars;
        psz += _cchChars;
    } // while: pointer not stopped on EOS

    return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//  NCompareMultiSz
//
//  Description:
//      Compare two MULTI_SZ buffers.
//
//  Arguments:
//      pszSource   [IN] The source string.
//      pszTarget   [IN] The target string.
//
//  Return Value:
//      If the string pointed to by pszSource is less than the string pointed
//      to by pszTarget, the return value is negative. If the string pointed
//      to by pszSource is greater than the string pointed to by pszTarget,
//      the return value is positive. If the strings are equal, the return value
//      is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
    IN LPCWSTR pszSource,
    IN LPCWSTR pszTarget
    )
{
    Assert( pszSource != NULL );
    Assert( pszTarget != NULL );

    while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
    {
        //
        // Move to end of strings.
        //
        while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
        {
            ++pszSource;
            ++pszTarget;
        } // while: pointer not stopped on EOS

        //
        // If strings are the same, skip past terminating NUL.
        // Otherwise exit the loop.
        if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
        {
            ++pszSource;
            ++pszTarget;
        } // if: both stopped on EOS
        else
        {
            break;
        } // else: stopped because something is not equal -- wr are done.

    } // while: pointer not stopped on EOS

    return *pszSource - *pszTarget;

} //*** NCompareMultiSz


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropValueList class
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScMoveToFirstValue
//
//  Description:
//      Move the cursor to the first value in the value list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS   Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToFirstValue( void )
{
    Assert( m_cbhValueList.pb != NULL );

    DWORD   _sc;

    m_cbhCurrentValue = m_cbhValueList;
    m_cbDataLeft = m_cbDataSize;
    m_fAtEnd = FALSE;

    if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
    {
        _sc = ERROR_NO_MORE_ITEMS;
    } // if: no items in the value list
    else
    {
        _sc = ERROR_SUCCESS;
    } // else: items exist in the value list

    return _sc;

} //*** CClusPropValueList::ScMoveToFirstValue

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScMoveToNextValue
//
//  Description:
//      Move the cursor to the next value in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next value successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToNextValue( void )
{
    Assert( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc     = ERROR_NO_MORE_ITEMS;
    size_t                  _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    _cbhCurrentValue = m_cbhCurrentValue;

    //
    // Don't try to move if we're already at the end.
    //
    if ( m_fAtEnd )
    {
        goto Cleanup;
    } // if: already at the end of the list

    //
    // Make sure the buffer is big enough for the value header.
    //
    if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Calculate how much to advance buffer pointer.
    //
    _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

    //
    // Make sure the buffer is big enough for the value header,
    // the data itself, and the endmark.
    //
    if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Move past the current value to the next value's syntax.
    //
    _cbhCurrentValue.pb += _cbDataSize;

    //
    // This test will ensure that the value is always valid since we won't
    // advance if the next thing is the endmark.
    //
    if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
    {
        m_cbhCurrentValue = _cbhCurrentValue;
        m_cbDataLeft -= _cbDataSize;
        _sc = ERROR_SUCCESS;
    } // if: next value's syntax is not the endmark
    else
    {
        m_fAtEnd = TRUE;
    } // else: next value's syntax is the endmark

Cleanup:

    return _sc;

} //*** CClusPropValueList::ScMoveToNextValue

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScCheckIfAtLastValue
//
//  Description:
//      Indicate whether we are on the last value in the list or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Not currently at the last value in the list.
//      ERROR_NO_MORE_ITEMS Currently at the last value in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScCheckIfAtLastValue( void )
{
    Assert( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    size_t                  _cbDataSize;

    _cbhCurrentValue = m_cbhCurrentValue;

    //
    // Don't try to recalculate if we already know
    // we're at the end of the list.
    //
    if ( m_fAtEnd )
    {
        goto Cleanup;
    } // if: already at the end of the list

    //
    // Make sure the buffer is big enough for the value header.
    //
    if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Calculate how much to advance buffer pointer.
    //
    _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

    //
    // Make sure the buffer is big enough for the value header,
    // the data itself, and the endmark.
    //
    if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Move past the current value to the next value's syntax.
    //
    _cbhCurrentValue.pb += _cbDataSize;

    //
    // We are on the last value if the next thing after this value
    // is an endmark.
    //
    if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
    {
        _sc = ERROR_NO_MORE_ITEMS;
    } // if: next value's syntax is the endmark

Cleanup:

    return _sc;

} //*** CClusPropValueList::ScCheckIfAtLastValue

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScAllocValueList
//
//  Description:
//      Allocate a value list buffer that's big enough to hold the next
//      value.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the value list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScAllocValueList( IN size_t cbMinimum )
{
    Assert( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    size_t  _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewValuelist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewValuelist = new BYTE[ _cbTotal ];
        if ( _pbNewValuelist != NULL )
        {
            ZeroMemory( _pbNewValuelist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhValueList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhValueList.pb;
                m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhValueList.pb = _pbNewValuelist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = TW32( ERROR_NOT_ENOUGH_MEMORY );
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CClusPropValueList::ScAllocValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScGetResourceValueList
//
//  Description:
//      Get value list of a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceValueList(
    IN HRESOURCE    hResource,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN size_t       cbInBufferSize
    )
{
    Assert( hResource != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterResourceControl(
                        hResource,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhValueList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cb
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocValueList( _cb ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterResourceControl(
                                hResource,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhValueList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cb
                                ) );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cb );
        m_cbDataLeft = static_cast< size_t >( _cb );
    } // else: no errors

    return _sc;

} //*** CClusPropValueList::ScGetResourceValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScGetResourceTypeValueList
//
//  Description:
//      Get value list of a resource type.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster in which the resource
//                          type resides.
//      pwszResTypeName [IN] Name of the resource type.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceTypeValueList(
    IN HCLUSTER hCluster,
    IN LPCWSTR  pwszResTypeName,
    IN DWORD    dwControlCode,
    IN HNODE    hHostNode,
    IN LPVOID   lpInBuffer,
    IN size_t   cbInBufferSize
    )
{
    Assert( hCluster != NULL );
    Assert( pwszResTypeName != NULL );
    Assert( *pwszResTypeName != L'\0' );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterResourceTypeControl(
                        hCluster,
                        pwszResTypeName,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhValueList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cb
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocValueList( _cb ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterResourceTypeControl(
                                hCluster,
                                pwszResTypeName,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhValueList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cb
                                ) );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cb );
        m_cbDataLeft = static_cast< size_t >( _cb );
    } // else: no errors

    return _sc;

} //*** CClusPropValueList::ScGetResourceTypeValueList


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScCopy
//
//  Description:
//      Copy a property list.  This function is equivalent to an assignment
//      operator.  Since this operation can fail, no assignment operator is
//      provided.
//
//  Arguments:
//      pcplPropList    [IN] The proplist to copy into this instance.
//      cbListSize      [IN] The total size of the prop list.
//
//  Return Value:
//      Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScCopy(
    IN const PCLUSPROP_LIST pcplPropList,
    IN size_t               cbListSize
    )
{
    Assert( pcplPropList != NULL );

    DWORD   _sc = ERROR_SUCCESS;

    //
    // Clean up any vestiges of a previous prop list.
    //
    if ( m_cbhPropList.pb != NULL )
    {
        DeletePropList();
    } // if: the current list is not empty

    //
    // Allocate the new property list buffer.  If successful,
    // copy the source list.
    //
    m_cbhPropList.pb = new BYTE[ cbListSize ];
    if ( m_cbhPropList.pb != NULL )
    {
        CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
        m_cbBufferSize = cbListSize;
        m_cbDataSize   = cbListSize;
        m_cbDataLeft   = cbListSize;
        _sc = ScMoveToFirstProperty();
    } // if: new succeeded
    else
    {
        _sc = TW32( ERROR_NOT_ENOUGH_MEMORY );
    } // else:

    return _sc;

} //*** CClusPropList::ScCopy

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAppend
//
//  Description:
//      Append to a property list.
//
//  Arguments:
//      rclPropList    [IN] The proplist to append onto this instance.
//
//  Return Value:
//      Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAppend( IN const CClusPropList & rclPropList )
{
    DWORD   _sc = ERROR_SUCCESS;
    size_t  _cbPropertyCountOffset;
    size_t  _cbIncrement;
    size_t  _cbDataLeft;
    PBYTE   _pbsrc = NULL;
    PBYTE   _pbdest = NULL;

    //
    //  Compute the number of bytes to get past the count of properties that
    //  is at the head of the list.  This is typically sizeof DWORD.
    //
    _cbPropertyCountOffset = sizeof( m_cbhPropList.pList->nPropertyCount );

    //
    //  Compute the allocation increment.  This is used when growing our buffer
    //  and is the amount of data to copy from the passed in list.  This includes
    //  the trailing endmark.  m_cbDataSize does not include the leading property
    //  count DWORD.
    //
    _cbIncrement = rclPropList.m_cbDataSize;

    //
    //  How much space remains in our current buffer?
    //
    _cbDataLeft = m_cbBufferSize - m_cbDataSize;

    //
    //  If the size of the list to append is larger than what we have remaining
    //  then we need to grow the list.
    //
    if ( _cbIncrement > _cbDataLeft )
    {
        _sc = TW32( ScAllocPropList( m_cbDataSize + _cbIncrement ) );
        if ( _sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:
    } // if:

    _pbdest = (PBYTE) &m_cbhPropList.pb[ _cbPropertyCountOffset + m_cbDataSize ];

    _pbsrc = (PBYTE) &rclPropList.m_cbhPropList.pList->PropertyName;

    CopyMemory( _pbdest, _pbsrc, _cbIncrement );

    //
    //  Grow our data size to match our new size.
    //
    m_cbDataSize += _cbIncrement;

    //
    //  Increment our property count to include the count of properties appended to the end
    //  of our buffer.
    //
    m_cbhPropList.pList->nPropertyCount += rclPropList.m_cbhPropList.pList->nPropertyCount;

Cleanup:

    return _sc;

} //*** CClusPropList::ScAppend

////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToFirstProperty
//
//  Description:
//      Move the cursor to the first propery in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the first property successfully.
//      ERROR_NO_MORE_ITEMS There are no properties in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToFirstProperty( void )
{
    Assert( m_cbhPropList.pb != NULL );
    Assert( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

    DWORD                   _sc;
    size_t                  _cbDataLeft;
    size_t                  _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    //
    // Make sure the buffer is big enough for the list header.
    //
    if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data

    //
    // Set the property counter to the number of properties in the list.
    //
    m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

    //
    // Point the name pointer to the first name in the list.
    //
    m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
    m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

    //
    // Check to see if there are any properties in the list.
    //
    if ( m_nPropsRemaining == 0 )
    {
        _sc = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    } // if: no properties in the list

    //
    // Make sure the buffer is big enough for the first property name.
    //
    if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Calculate how much to advance the buffer pointer.
    //
    _cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
                + ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

    //
    // Make sure the buffer is big enough for the name header
    // and the data itself.
    //
    if ( m_cbDataLeft < _cbDataSize )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Point the value buffer to the first value in the list.
    //
    _cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
    _cbDataLeft = m_cbDataLeft - _cbDataSize;
    m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

    //
    // Indicate we are successful.
    //
    _sc = ERROR_SUCCESS;

Cleanup:

    return _sc;

} //*** CClusPropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToNextProperty
//
//  Description:
//      Move the cursor to the next property in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next property successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToNextProperty( void )
{
    Assert( m_cbhPropList.pb != NULL );
    Assert( m_pvlValues.CbhValueList().pb != NULL );

    DWORD                   _sc;
    size_t                  _cbNameSize;
    size_t                  _cbDataLeft;
    size_t                  _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    CLUSPROP_BUFFER_HELPER  _cbhPropName;

    _cbhCurrentValue = m_pvlValues;
    _cbDataLeft = m_pvlValues.CbDataLeft();

    //
    // If we aren't already at the last property, attempt to move to the next one.
    //
    _sc = TW32( ScCheckIfAtLastProperty() );
    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: already at the last property (probably)

    //
    // Make sure the buffer is big enough for the value header.
    //
    if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data left

    //
    // Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
    // pointer arithmetic will give undesirable results.
    //
    while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
    {
        //
        // Make sure the buffer is big enough for the value
        // and an endmark.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
        if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
        {
            _sc = TW32( ERROR_INVALID_DATA );
            goto Cleanup;
        } // if: not enough data left

        //
        // Advance past the value.
        //
        _cbhCurrentValue.pb += _cbDataSize;
        _cbDataLeft -= _cbDataSize;
    } // while: not at endmark

    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error occurred in loop

    //
    // Advanced past the endmark.
    // Size check already performed in above loop.
    //
    _cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
    _cbhCurrentValue.pb += _cbDataSize;
    _cbDataLeft -= _cbDataSize;

    //
    // Point the name pointer to the next name in the list.
    //
    _cbhPropName = _cbhCurrentValue;
    Assert( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

    //
    // Calculate the size of the name with header.
    // Make sure the buffer is big enough for the name and an endmark.
    //
    if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data
    _cbNameSize = sizeof( *_cbhPropName.pName )
                + ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
    if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
    {
        _sc = TW32( ERROR_INVALID_DATA );
        goto Cleanup;
    } // if: not enough data

    //
    // Point the value buffer to the first value in the list.
    //
    _cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
    m_cbhCurrentPropName = _cbhPropName;
    m_cbDataLeft = _cbDataLeft - _cbNameSize;
    m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

    //
    // We've successfully advanced to the next property,
    // so there is now one fewer property remaining.
    //
    --m_nPropsRemaining;
    Assert( m_nPropsRemaining >= 1 );

    _sc = ERROR_SUCCESS;

Cleanup:

    return _sc;

} //*** CClusPropList::ScMoveToNextProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToPropertyByName
//
//  Description:
//      Find the passed in property name in the proplist.  Note that the
//      cursor is reset to the beginning at the beginning of the routine and
//      the current state of the cursor is lost.
//
//  Arguments:
//      pwszPropName    [IN] Name of the property
//
//  Return Value:
//      ERROR_SUCCESS if the property was found, other Win32 code if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
    Assert( m_cbhPropList.pb != NULL );

    DWORD   _sc;

    _sc = ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // See if this is the specified property.  If so, we're done.
            //
            if ( ClRtlStrICmp( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
            {
                break;
            } // if: property found

            //
            // Advance to the next property.
            //
            _sc = ScMoveToNextProperty();   // No TW32 because we expect an error when at the end

        } while ( _sc == ERROR_SUCCESS );   // do-while: not end of list
    } // if: successfully moved to the first property

    return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAllocPropList
//
//  Description:
//      Allocate a property list buffer that's big enough to hold the next
//      property.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the property list.
//
//  Return Value:
//      ERROR_SUCCESS
//      ERROR_NOT_ENOUGH_MEMORY
//      Other Win32 error codes
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAllocPropList( IN size_t cbMinimum )
{
    Assert( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    size_t  _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewProplist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewProplist = new BYTE[ _cbTotal ];
        if ( _pbNewProplist != NULL )
        {
            ZeroMemory( _pbNewProplist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhPropList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhPropList.pb;
                m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhPropList.pb = _pbNewProplist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = TW32( ERROR_NOT_ENOUGH_MEMORY );
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CClusPropList::ScAllocPropList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _fValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if (( pwszPrevValue != NULL ) && ( wcscmp( pwszValue, pwszPrevValue ) == 0 ))
    {
        _fValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_fAlwaysAddProp || _fValuesDifferent )
    {
        size_t  _cbNameSize;
        size_t  _cbDataSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbDataSize = (wcslen( pwszValue ) + 1) * sizeof( *pwszValue );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddMultiSzProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddMultiSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _fValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_MULTI_SZ      _pValue;

    if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _fValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_fAlwaysAddProp || _fValuesDifferent )
    {
        size_t  _cbNameSize;
        size_t  _cbDataSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbDataSize = static_cast< DWORD >( (CchMultiSz( pwszValue ) + 1) * sizeof( *pwszValue ) );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pMultiSzValue;
            CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddExpandSzProp
//
//  Description:
//      Add an EXPAND_SZ string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddExpandSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _fValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if ( ( pwszPrevValue != NULL ) && ( wcscmp( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _fValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_fAlwaysAddProp || _fValuesDifferent )
    {
        size_t  _cbNameSize;
        size_t  _cbDataSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbDataSize = (wcslen( pwszValue ) + 1) * sizeof( *pwszValue );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a DWORD property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN DWORD    nValue,
    IN DWORD    nPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_DWORD         _pValue;

    if ( m_fAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        size_t  _cbNameSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbValueSize = sizeof( CLUSPROP_DWORD )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pDwordValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a LONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LONG     nValue,
    IN LONG     nPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_LONG          _pValue;

    if ( m_fAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        size_t  _cbNameSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbValueSize = sizeof( CLUSPROP_LONG )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pLongValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a binary property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pbValue         [IN] Value of the property to set in the list.
//      cbValue         [IN] Count of bytes in pbValue.
//      pbPrevValue     [IN] Previous value of the property.
//      cbPrevValue     [IN] Count of bytes in pbPrevValue.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR                  pwszName,
    IN const unsigned char *    pbValue,
    IN size_t                   cbValue,
    IN const unsigned char *    pbPrevValue,
    IN size_t                   cbPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _fChanged = FALSE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_BINARY        _pValue;

    //
    // Determine if the buffer has changed.
    //
    if ( m_fAlwaysAddProp || (cbValue != cbPrevValue) )
    {
        _fChanged = TRUE;
    } // if: always adding the property or the value size changed
    else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
    {
        _fChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
    } // else if: value length changed

    if ( _fChanged )
    {
        size_t  _cbNameSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbValueSize = sizeof( CLUSPROP_BINARY )
                    + ALIGN_CLUSPROP( cbValue )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pBinaryValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Routine Description:
//      Add a ULONGLONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      ullValue        [IN] Value of the property to set in the list.
//      ullPrevValue    [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error codes.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR      pwszName,
    IN ULONGLONG    ullValue,
    IN ULONGLONG    ullPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                       _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME     _pName;
    PCLUSPROP_ULARGE_INTEGER    _pValue;

    if ( m_fAlwaysAddProp || ( ullValue != ullPrevValue ) )
    {
        size_t  _cbNameSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pULargeIntegerValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Routine Description:
//      Add a LONGLONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      llValue         [IN] Value of the property to set in the list.
//      llPrevValue     [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 status codes.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR      pwszName,
    IN LONGLONG     llValue,
    IN LONGLONG     llPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                       _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME     _pName;
    PCLUSPROP_ULARGE_INTEGER    _pValue;

    if ( m_fAlwaysAddProp || ( llValue != llPrevValue ) )
    {
        size_t  _cbNameSize;
        size_t  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
        _cbValueSize = sizeof( CLUSPROP_LARGE_INTEGER )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pULargeIntegerValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, llValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScSetPropToDefault
//
//  Description:
//      Add a property to the property list so that it will revert to its
//      default value.
//
//  Arguments:
//      pwszName    [IN] Name of the property.
//      cpfPropFmt  [IN] Format of property
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 status codes.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScSetPropToDefault(
    IN LPCWSTR                  pwszName,
    IN CLUSTER_PROPERTY_FORMAT  cpfPropFmt
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    size_t                  _cbNameSize;
    size_t                  _cbValueSize;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_VALUE         _pValue;

    // Calculate sizes and make sure we have a property list.
    _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                + ALIGN_CLUSPROP( (wcslen( pwszName ) + 1) * sizeof( *pwszName ) );
    _cbValueSize = sizeof( CLUSPROP_BINARY )
                + sizeof( CLUSPROP_SYNTAX ); // value list endmark

    _sc = TW32( ScAllocPropList( _cbNameSize + _cbValueSize ) );
    if ( _sc == ERROR_SUCCESS )
    {
        //
        // Set the property name.
        //
        _pName = m_cbhCurrentProp.pName;
        CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
        m_cbhCurrentProp.pb += _cbNameSize;

        //
        // Set the property value.
        //
        _pValue = m_cbhCurrentProp.pValue;
        CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
        m_cbhCurrentProp.pb += _cbValueSize;

        //
        // Increment the property count and buffer size.
        //
        m_cbhPropList.pList->nPropertyCount++;
        m_cbDataSize += _cbNameSize + _cbValueSize;
    } // if:

    return _sc;

} //*** CClusPropList::ScSetPropToDefault

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in pwsz string.  If specified as 0,
//                      the the length will be determined by a call to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz        // = 0
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;
    HRESULT _hr;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (wcslen( psz ) + 1) * sizeof( *psz );
    } // if: zero size specified
    Assert( cbsz == (wcslen( psz ) + 1) * sizeof( *psz ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    _hr = THR( StringCbCopyW( pprop->sz, cbsz, psz ) );
    if ( SUCCEEDED( _hr ) )
    {
        //
        // Set an endmark.
        //
        _cbhProps.pStringValue = pprop;
        _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
        _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    }

} //*** CClusPropList::CopyProp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyMultiSzProp
//
//  Description:
//      Copy a MULTI_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.  If specified as 0,
//                      the the length will be determined by calls to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyMultiSzProp(
    OUT PCLUSPROP_MULTI_SZ      pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (CchMultiSz( psz ) + 1) * sizeof( *psz );
    } // if: zero size specified
    Assert( cbsz == (CchMultiSz( psz ) + 1) * sizeof( *psz ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    CopyMemory( pprop->sz, psz, cbsz );

    //
    // Set an endmark.
    //
    _cbhProps.pMultiSzValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyMultiSzProp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyExpandSzProp
//
//  Description:
//      Copy an EXPAND_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyExpandSzProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;
    HRESULT _hr;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (wcslen( psz ) + 1) * sizeof( *psz );
    } // if: cbsz == 0
    Assert( cbsz == (wcslen( psz ) + 1) * sizeof( *psz ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    _hr = THR( StringCbCopyW( pprop->sz, cbsz, psz ) );
    if ( SUCCEEDED( _hr ) )
    {
        //
        // Set an endmark.
        //
        _cbhProps.pStringValue = pprop;
        _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
        _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    }

} //*** CClusPropList::CopyExpandSzProp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a DWORD property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of DWORD.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_DWORD         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN DWORD                    nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->dw = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pDwordValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a LONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of LONG.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_LONG          pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LONG                     nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->l = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pLongValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pLongValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a ULONGLONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT]   Property structure to fill.
//      proptype    [IN]    Type of LONG.
//      ullValue    [IN]    Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_ULARGE_INTEGER    pprop,
    IN  CLUSTER_PROPERTY_TYPE       proptype,
    IN  ULONGLONG                   ullValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
    pprop->Syntax.wType = static_cast< WORD >( proptype );
    pprop->cbLength = sizeof( ULONGLONG );
    //
    // pprop may not have the correct alignment for large ints; copy as two
    // DWORDs to be safe
    //
    pprop->li.u = ((ULARGE_INTEGER *)&ullValue)->u;

    //
    // Set an endmark.
    //
    _cbhProps.pULargeIntegerValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a LONGLONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT]   Property structure to fill.
//      proptype    [IN]    Type of LONG.
//      llValue     [IN]    Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_LARGE_INTEGER     pprop,
    IN  CLUSTER_PROPERTY_TYPE       proptype,
    IN  LONGLONG                    llValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_LARGE_INTEGER;
    pprop->Syntax.wType = static_cast< WORD >( proptype );
    pprop->cbLength = sizeof( LONGLONG );
    //
    // pprop may not have the correct alignment for large ints; copy as two
    // DWORDs to be safe
    //
    pprop->li.u = ((LARGE_INTEGER *)&llValue)->u;

    //
    // Set an endmark.
    //
    _cbhProps.pLargeIntegerValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pLargeIntegerValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a binary property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      pb          [IN] Block to copy.
//      cbsz        [IN] Count of bytes in pb buffer.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_BINARY        pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN const unsigned char *    pb,
    IN size_t                   cb
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = static_cast< DWORD >( cb );
    if ( cb > 0 )
    {
        CopyMemory( pprop->rgb, pb, cb );
    } // if: non-zero data length

    //
    // Set an endmark.
    //
    _cbhProps.pBinaryValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyEmptyProp
//
//  Description:
//      Copy an empty property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of property.
//      cpfPropFmt  [IN] Format of property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyEmptyProp(
    OUT PCLUSPROP_VALUE         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN CLUSTER_PROPERTY_FORMAT  cptPropFmt
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = 0;

    //
    // Set an endmark.
    //
    _cbhProps.pValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyEmptyProp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNodeProperties
//
//  Description:
//      Get properties on a node.
//
//  Arguments:
//      hNode           [IN] Handle for the node to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNodeProperties(
    IN HNODE        hNode,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN size_t       cbInBufferSize
    )
{
    Assert( hNode != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterNodeControl(
                        hNode,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterNodeControl(
                                hNode,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                            ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNodeProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetGroupProperties
//
//  Description:
//      Get properties on a group.
//
//  Arguments:
//      hGroup          [IN] Handle for the group to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetGroupProperties(
    IN HGROUP       hGroup,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN size_t       cbInBufferSize
    )
{
    Assert( hGroup != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterGroupControl(
                        hGroup,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterGroupControl(
                                hGroup,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                                ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetGroupProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetResourceProperties
//
//  Description:
//      Get properties on a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceProperties(
    IN HRESOURCE    hResource,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN size_t       cbInBufferSize
    )
{
    Assert( hResource != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterResourceControl(
                        hResource,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterResourceControl(
                                hResource,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                                ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetResourceProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetResourceTypeProperties
//
//  Description:
//      Get properties on a resource type.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster in which the resource
//                          type resides.
//      pwszResTypeName [IN] Name of the resource type.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceTypeProperties(
    IN HCLUSTER     hCluster,
    IN LPCWSTR      pwszResTypeName,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN size_t       cbInBufferSize
    )
{
    Assert( hCluster != NULL );
    Assert( pwszResTypeName != NULL );
    Assert( *pwszResTypeName != L'\0' );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterResourceTypeControl(
                        hCluster,
                        pwszResTypeName,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterResourceTypeControl(
                                hCluster,
                                pwszResTypeName,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                                ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetResourceTypeProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNetworkProperties
//
//  Description:
//      Get properties on a network.
//
//  Arguments:
//      hNetwork        [IN] Handle for the network to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetworkProperties(
    IN HNETWORK     hNetwork,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN size_t       cbInBufferSize
    )
{
    Assert( hNetwork != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterNetworkControl(
                        hNetwork,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterNetworkControl(
                                hNetwork,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                                ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNetworkProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNetInterfaceProperties
//
//  Description:
//      Get properties on a network interface.
//
//  Arguments:
//      hNetInterface   [IN] Handle for the network interface to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetInterfaceProperties(
    IN HNETINTERFACE    hNetInterface,
    IN DWORD            dwControlCode,
    IN HNODE            hHostNode,
    IN LPVOID           lpInBuffer,
    IN size_t           cbInBufferSize
    )
{
    Assert( hNetInterface != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc= ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterNetInterfaceControl(
                        hNetInterface,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterNetInterfaceControl(
                                hNetInterface,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                                ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNetInterfaceProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetClusterProperties
//
//  Description:
//      Get properties on a cluster.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetClusterProperties(
    IN HCLUSTER hCluster,
    IN DWORD    dwControlCode,
    IN HNODE    hHostNode,
    IN LPVOID   lpInBuffer,
    IN size_t   cbInBufferSize
    )
{
    Assert( hCluster != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc= ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = TW32( ScAllocPropList( _cbProps ) );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = TW32E( ClusterControl(
                        hCluster,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        static_cast< DWORD >( cbInBufferSize ),
                        m_cbhPropList.pb,
                        static_cast< DWORD >( m_cbBufferSize ),
                        &_cbProps
                        ), ERROR_MORE_DATA );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = TW32( ScAllocPropList( _cbProps ) );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = TW32( ClusterControl(
                                hCluster,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                static_cast< DWORD >( cbInBufferSize ),
                                m_cbhPropList.pb,
                                static_cast< DWORD >( m_cbBufferSize ),
                                &_cbProps
                                ) );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = static_cast< size_t >( _cbProps );
        m_cbDataLeft = static_cast< size_t >( _cbProps );
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetClusterProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\inc\qfstrans.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    QfsTrans.h

Abstract:

    Qfs interface between clussvc and resmon

Author:

    GorN 19-Sep-2001

Revision History:

--*/

#ifndef _QFSP_H_INCLUDED
#define _QFSP_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#define QFS_TRANSPORT_ver_1_0 L"28490381-dc1f-4ea2-b593-f8ca3f119dc4"
#define QfsMakePipeName(ver) L"\\\\.\\pipe\\" ver

#define QFSP_INSERT_OP_NAMES \
  OPNAME(None) \
  OPNAME(CreateFile) \
  OPNAME(CloseFile) \
  OPNAME(ReadFile) \
  OPNAME(WriteFile) \
  OPNAME(FlushFile) \
  OPNAME(DeleteFile) \
  OPNAME(FindFirstFile) \
  OPNAME(FindNextFile) \
  OPNAME(FindClose) \
  OPNAME(CreateDir) \
  OPNAME(GetDiskFreeSpace) \
  OPNAME(GetAttr) \
  OPNAME(SetAttr2) \
  OPNAME(Rename) \
  OPNAME(Connect)

#define OPNAME(Name) op ## Name,
typedef enum _JobDescription_t{
    QFSP_INSERT_OP_NAMES
    OpCount
} JobDescription_t;
#undef OPNAME

typedef struct _JobBuf_header{
    DWORD OpCode;
    DWORD Status;
    DWORD BufLen;
    DWORD Reserved;
} JOBBUF_HEADER;    

#define JOB_BUF_MAX_BUFFER (32 * 1024)

typedef struct _JobBuf{
    JOBBUF_HEADER hdr;
    ULONGLONG Offset;
    PVOID ServerCookie;
    PVOID ClientCookie;
    HANDLE Handle;

    union {
        struct { // CreateFile
            DWORD dwDesiredAccess;
            DWORD dwShareMode;
            DWORD dwCreationDisposition;
            DWORD dwFlagsAndAttributes;
        };
        struct { // GetDiskFreeSpace
            ULONGLONG FreeBytesAvailable;          // bytes available to caller
            ULONGLONG TotalNumberOfBytes;        // bytes on disk
            ULONGLONG TotalNumberOfFreeBytes; // free bytes on disk
        };
        struct { // GetAttr
            ULONGLONG EndOfFile;
            ULONGLONG AllocationSize;
            ULONGLONG CreationTime;
            ULONGLONG LastAccessTime;
            ULONGLONG LastWriteTime;
            DWORD       FileAttributes;
        };
        DWORD ClussvcProcessId; // Cluster Service Process ID.
    };

    USHORT cbSize;
    USHORT ccSize;

    union {
        UCHAR Buffer[JOB_BUF_MAX_BUFFER];
        struct {
            WCHAR FileName[JOB_BUF_MAX_BUFFER / 2 / sizeof(WCHAR)];
            WCHAR FileNameDest[JOB_BUF_MAX_BUFFER / 2 / sizeof(WCHAR)];
        };
        WIN32_FIND_DATA FindFileData;
    };
} JobBuf_t, *PJOB_BUF, JOB_BUF;

typedef struct _MTHREAD_COUNTER {
    HANDLE LastThreadLeft;
    LONG    Count;
} MTHREAD_COUNTER, *PMTHREAD_COUNTER;

typedef struct _SHARED_MEM_CONTEXT {
    HANDLE FileHandle;
    HANDLE FileMappingHandle;
    PVOID  Mem;
    DWORD  MappingSize;
} SHARED_MEM_CONTEXT, *PSHARED_MEM_CONTEXT;

enum {MAX_JOB_BUFFERS = 32};

typedef VOID (*DoRealWorkCallback) (PJOB_BUF, PVOID);

typedef struct _SHARED_MEM_SERVER {
    SHARED_MEM_CONTEXT ShMem;
    HANDLE  Attention;       // copy of EventHandle[0]
    HANDLE  GoingOffline;  // copy of EventHandle[1]
    HANDLE* BufferReady; // EventHandle + 2
    HANDLE  EventHandles[MAX_JOB_BUFFERS + 2];
    DWORD   nBuffers;
    JOB_BUF* JobBuffers;
    LONG volatile*  FilledBuffersMask;

    // client specific stuff

    CRITICAL_SECTION Lock;
    ULONG  ConnectionRefcount;
    HANDLE FreeBufferCountSemaphore;
    HANDLE ServerProcess;
    DWORD  BusyBuffers;
    DWORD  State;
    HANDLE GoingOfflineWaitRegistration;
    HANDLE ServerProcessWaitRegistration;

    // server specific stuff

    HANDLE AttentionWaitRegistration;
    MTHREAD_COUNTER  ThreadCounter;
    DoRealWorkCallback DoRealWork;
    PVOID DoRealWorkContext;
} SHARED_MEM_SERVER, *PSHARED_MEM_SERVER;

DWORD   MemServer_Online(
    PSHARED_MEM_SERVER Server, 
    int nBuffers, 
    DoRealWorkCallback DoRealWork, 
    PVOID DoRealWorkContext);

VOID       MemServer_Offline(PSHARED_MEM_SERVER Server);

DWORD    MemClient_Init(PSHARED_MEM_SERVER Client);
VOID        MemClient_Cleanup(PSHARED_MEM_SERVER Client);

DWORD MemClient_ReserveBuffer(PSHARED_MEM_SERVER Client, PJOB_BUF *j);
VOID     MemClient_Release(PJOB_BUF j);
DWORD MemClient_DeliverBuffer(PJOB_BUF j);





#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\baseclusterguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      BaseClusterGuids.h
//
//  Description:
//      This file contains the guids used by BaseCluster.
//
//  Maintained By:
//      John Franco (JFranco) 01-JUL-2002
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////

#include <initguid.h>

//
//  Minor Task IDs
//

// {DBC51A1A-5099-42be-A806-D161AC4A3878}
DEFINE_GUID( TASKID_Minor_Commit_Forming_Node,
0xdbc51a1a, 0x5099, 0x42be, 0xa8, 0x6, 0xd1, 0x61, 0xac, 0x4a, 0x38, 0x78 );

// {11ABF069-6495-49ac-81ED-F27A1E4C5F3F}
DEFINE_GUID( TASKID_Minor_Commit_Joining_Node,
0x11abf069, 0x6495, 0x49ac, 0x81, 0xed, 0xf2, 0x7a, 0x1e, 0x4c, 0x5f, 0x3f );

// {3ABE1492-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Configuring_Cluster_Node,
0x3abe1492, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE1494-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Rolling_Back_Cluster_Configuration,
0x3abe1494, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {4DE4D086-3414-4621-BA1E-43277F972D12}
DEFINE_GUID( TASKID_Minor_Commit_Already_Complete,
0x4de4d086, 0x3414, 0x4621, 0xba, 0x1e, 0x43, 0x27, 0x7f, 0x97, 0x2d, 0x12 );

// {FFC1A75D-B6C0-4bb4-8625-02AD99ABF60E}
DEFINE_GUID( TASKID_Minor_Rollback_Failed_Incomplete_Commit,
0xffc1a75d, 0xb6c0, 0x4bb4, 0x86, 0x25, 0x2, 0xad, 0x99, 0xab, 0xf6, 0xe );

// {8B3DFF03-4DFC-41d5-B508-FC425CC1E5C4}
DEFINE_GUID( TASKID_Minor_Rollback_Not_Possible,
0x8b3dff03, 0x4dfc, 0x41d5, 0xb5, 0x8, 0xfc, 0x42, 0x5c, 0xc1, 0xe5, 0xc4 );

// {3ABE14A0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Cleaning_Up_Cluster_Database,
0x3abe14A0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14A4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Form_Creating_Cluster_Database,
0x3abe14A4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14A8-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Form_Customizing_Cluster_Database,
0x3abe14A8, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14B0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Creating_ClusNet_Service,
0x3abe14B0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14B4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Starting_ClusNet_Service,
0x3abe14B4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14C0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Configuring_ClusDisk_Service,
0x3abe14C0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14C4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Starting_ClusDisk_Service,
0x3abe14C4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14D0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Configuring_Cluster_Service_Account,
0x3abe14D0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {4AA76355-C2B3-4f5b-87D6-5A11957E4280}
DEFINE_GUID( TASKID_Minor_Make_Cluster_Service_Account_Admin,
0x4aa76355, 0xc2b3, 0x4f5b, 0x87, 0xd6, 0x5a, 0x11, 0x95, 0x7e, 0x42, 0x80);

// {3ABE14E0-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Creating_Cluster_Service,
0x3abe14E0, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE14E4-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Starting_Cluster_Service,
0x3abe14E4, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {3ABE1500-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Initializing_Cluster_Join,
0x3abe1500, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );

// {1D905EE7-3118-4c2c-BD61-2E4B9C109F71}
DEFINE_GUID( TASKID_Minor_Initializing_Cluster_Form,
0x1d905ee7, 0x3118, 0x4c2c, 0xbd, 0x61, 0x2e, 0x4b, 0x9c, 0x10, 0x9f, 0x71);

// {3ABE1518-7E05-402c-81AA-1C3F1D782031}
DEFINE_GUID( TASKID_Minor_Join_Sync_Cluster_Database,
0x3abe1518, 0x7e05, 0x402c, 0x81, 0xaa, 0x1c, 0x3f, 0x1d, 0x78, 0x20, 0x31 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\baseclusterstrings.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      BaseClusterActionResources.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      David Potter    (DavidP)    06-MAR-2001
//      Vij Vasu        (Vvasu)     03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


#include <ResourceIdRanges.h>

/////////////////////////////////////////////////////////////////////
// Error strings
/////////////////////////////////////////////////////////////////////

// An error occurred attempting to read the Cluster Service installation state.
#define IDS_ERROR_GETTING_INSTALL_STATE         ( ID_BCA_START + 1 )

// An error occurred during the cluster configuration. The installation state of the Cluster Service is not correct for this operation.
#define IDS_ERROR_INCORRECT_INSTALL_STATE       ( ID_BCA_START + 2 )

// An error occurred attempting to ensure exclusive cluster configuration access. The required semaphore could not be created.
#define IDS_ERROR_SEMAPHORE_CREATION            ( ID_BCA_START + 3 )

// An error occurred attempting to ensure exclusive cluster configuration access. Another configuration session may be in progress.
#define IDS_ERROR_SEMAPHORE_ACQUISITION         ( ID_BCA_START + 4 )

// An error occurred attempting to locate the Cluster Service binaries. A registry error has occurred.
#define IDS_ERROR_GETTING_INSTALL_DIR           ( ID_BCA_START + 5 )

// An error occurred attempting to open a registry key.
#define IDS_ERROR_REGISTRY_OPEN                 ( ID_BCA_START + 6 )

// An error occurred attempting to query a registry value.
#define IDS_ERROR_REGISTRY_QUERY                ( ID_BCA_START + 7 )

// An error occurred attempting to open the configuration INF file.
#define IDS_ERROR_INF_FILE_OPEN                 ( ID_BCA_START + 8 )

// An error occurred attempting to determine the amount of free disk space.
#define IDS_ERROR_GETTING_FREE_DISK_SPACE       ( ID_BCA_START + 9 )

// Cluster configuration cannot proceed. The disk space available to create the local quorum resource is insufficient.
#define IDS_ERROR_INSUFFICIENT_DISK_SPACE       ( ID_BCA_START + 10 )

// An error occurred while attempting to determine the file system type installed on a disk.
#define IDS_ERROR_GETTING_FILE_SYSTEM           ( ID_BCA_START + 11 )

// An error occurred attempting to create a service. This operation may succeed if retried after some time or after rebooting.
#define IDS_ERROR_SERVICE_CREATE                ( ID_BCA_START + 12 )

// An error occurred while attempting to clean up a service.
#define IDS_ERROR_SERVICE_CLEANUP               ( ID_BCA_START + 13 )

// An error occurred while attempting to open a handle to the Service Control Manager.
#define IDS_ERROR_OPEN_SCM                      ( ID_BCA_START + 14 )

// An error occurred while attempting to configure the ClusSvc service.
#define IDS_ERROR_CLUSSVC_CONFIG                ( ID_BCA_START + 15 )

// An error occurred attempting to set the directory id of the cluster service directory.
#define IDS_ERROR_SET_DIRID                     ( ID_BCA_START + 16 )

// An error occurred attempting to install the cluster network provider.
#define IDS_ERROR_CLUSNET_PROV_INSTALL          ( ID_BCA_START + 17 )

// An error occurred attempting to set a registry value.
#define IDS_ERROR_REGISTRY_SET                  ( ID_BCA_START + 18 )

// An error occurred attempting to rename a registry key.
#define IDS_ERROR_REGISTRY_RENAME               ( ID_BCA_START + 19 )

// An error occurred attempting to start a service.
#define IDS_ERROR_SERVICE_START                 ( ID_BCA_START + 20 )

// An error occurred attempting to stop a service.
#define IDS_ERROR_SERVICE_STOP                  ( ID_BCA_START + 21 )

// An error occurred attempting to open the LSA policy.
#define IDS_ERROR_LSA_POLICY_OPEN               ( ID_BCA_START + 22 )

// An error occurred while the cluster database was being cleaned up.
#define IDS_ERROR_CLUSDB_CLEANUP                ( ID_BCA_START + 23 )

// An error occurred while enable a privilege for a thread.
#define IDS_ERROR_ENABLE_THREAD_PRIVILEGE       ( ID_BCA_START + 24 )

// An error occurred attempting to create the cluster hive.
#define IDS_ERROR_CLUSDB_CREATE_HIVE            ( ID_BCA_START + 25 )

// An error occurred attempting to populate the cluster hive.
#define IDS_ERROR_CLUSDB_POPULATE_HIVE          ( ID_BCA_START + 26 )

// An error occurred attempting to delete a directory.
#define IDS_ERROR_REMOVE_DIR                    ( ID_BCA_START + 27 )

// An error occurred attempting to validate the cluster service account.
#define IDS_ERROR_VALIDATING_ACCOUNT            ( ID_BCA_START + 28 )

// An error occurred attempting to get the computer name.
#define IDS_ERROR_GETTING_COMPUTER_NAME         ( ID_BCA_START + 29 )

// An error occurred attempting to get a universally unique identifier (UUID).
#define IDS_ERROR_UUID_INIT                     ( ID_BCA_START + 30 )

// An error occurred attempting to create a registry key.
#define IDS_ERROR_REGISTRY_CREATE               ( ID_BCA_START + 31 )

// An error occurred attempting to customize the cluster group.
#define IDS_ERROR_CUSTOMIZE_CLUSTER_GROUP       ( ID_BCA_START + 32 )

// An error occurred attempting to create the quorum directory.
#define IDS_ERROR_QUORUM_DIR_CREATE             ( ID_BCA_START + 33 )

// An error occurred attempting to open a handle to the ClusDisk service.
#define IDS_ERROR_CLUSDISK_OPEN                 ( ID_BCA_START + 34 )

// An error occurred attempting to configure the ClusDisk service.
#define IDS_ERROR_CLUSDISK_CONFIGURE            ( ID_BCA_START + 35 )

// An error occurred attempting to initialize the state of the ClusDisk service.
#define IDS_ERROR_CLUSDISK_INITIALIZE           ( ID_BCA_START + 36 )

// An error occurred attempting to clean up the ClusDisk service.
#define IDS_ERROR_CLUSDISK_CLEANUP              ( ID_BCA_START + 37 )

// An error occurred attempting to set the cluster service installation state.
#define IDS_ERROR_SETTING_INSTALL_STATE         ( ID_BCA_START + 38 )

// An error occurred attempting to obtain the primary domain of this computer.
#define IDS_ERROR_GETTING_PRIMARY_DOMAIN        ( ID_BCA_START + 39 )

// This computer is not part of a domain. Cluster configuration cannot proceed.
#define IDS_ERROR_NO_DOMAIN                     ( ID_BCA_START + 40 )

// An error occurred attempting to get information about the administrators group.
#define IDS_ERROR_GET_ADMIN_GROUP_INFO          ( ID_BCA_START + 41 )

// An error occurred attempting to change membership in the administrators group.
#define IDS_ERROR_ADMIN_GROUP_ADD_REMOVE        ( ID_BCA_START + 42 )

// An error occurred attempting to configure the cluster service account rights.
#define IDS_ERROR_ACCOUNT_RIGHTS_CONFIG         ( ID_BCA_START + 43 )

// An error occurred attempting to initialize a cluster create operation.
#define IDS_ERROR_CLUSTER_FORM_INIT             ( ID_BCA_START + 44 )

// An error occurred attempting to send a status report.
#define IDS_ERROR_SENDING_REPORT                ( ID_BCA_START + 45 )

// The user has aborted the configuration operation.
#define IDS_USER_ABORT                          ( ID_BCA_START + 46 )

// The name of the network used by the cluster IP address is invalid.
#define IDS_ERROR_INVALID_IP_NET                ( ID_BCA_START + 47 )

// The cluster name is invalid.
#define IDS_ERROR_INVALID_CLUSTER_NAME          ( ID_BCA_START + 48 )

// The cluster service account name is invalid.
#define IDS_ERROR_INVALID_CLUSTER_ACCOUNT       ( ID_BCA_START + 49 )

// An error occurred attempting to initialize node cleanup.
#define IDS_ERROR_CLUSTER_CLEANUP_INIT          ( ID_BCA_START + 50 )

// An error occurred attempting to make miscellaneous changes.
#define IDS_ERROR_NODE_CONFIG                   ( ID_BCA_START + 51 )

// An error occurred attempting to clean up miscellaneous changes made when this computer became part of a cluster.
#define IDS_ERROR_NODE_CLEANUP                  ( ID_BCA_START + 52 )

// An error occurred attempting to initialize the cluster add node operation.
#define IDS_ERROR_CLUSTER_JOIN_INIT             ( ID_BCA_START + 53 )

// An error occurred attempting to get a token for the cluster service account. The reason for this failure may be that your user account does not have the privilege to act as part of the operating system. Contact your administrator to obtain this privilege.
#define IDS_ERROR_GETTING_ACCOUNT_TOKEN         ( ID_BCA_START + 54 )

// 
// ( ID_BCA_START + 55 )

// An error occurred attempting to get the token for an account.
#define IDS_ERROR_GET_ACCOUNT_TOKEN             ( ID_BCA_START + 56 )

// An error occurred attempting to impersonate a user.
#define IDS_ERROR_IMPERSONATE_USER              ( ID_BCA_START + 57 )

// An error occurred attempting to verify if this node can interoperate with the sponsor cluster.
#define IDS_ERROR_JOIN_CHECK_INTEROP            ( ID_BCA_START + 58 )

// This computer cannot interoperate with the sponsor cluster due to a version incompatibility.
#define IDS_ERROR_JOIN_INCOMPAT_SPONSOR         ( ID_BCA_START + 59 )

// An error occurred attempting to add this computer to the sponsor cluster database.
#define IDS_ERROR_JOINING_SPONSOR_DB            ( ID_BCA_START + 60 )

// An error occurred attempting to get data about this computer from the sponsor cluster.
#define IDS_ERROR_GET_NEW_NODE_ID               ( ID_BCA_START + 61 )

// An error occurred attempting to evict this computer from the sponsor cluster.
#define IDS_ERROR_EVICTING_NODE                 ( ID_BCA_START + 62 )

// An error occurred attempting to synchronize the cluster database with the sponsor cluster.
#define IDS_ERROR_JOIN_SYNC_DB                  ( ID_BCA_START + 63 )

// An error occurred attempting to convert the cluster name to a NetBIOS name.
#define IDS_ERROR_CVT_CLUSTER_NAME              ( ID_BCA_START + 64 )

// The cluster binding string is invalid.
#define IDS_ERROR_INVALID_CLUSTER_BINDINGSTRING ( ID_BCA_START + 65 )

// The commit already completed. Unable to commit again.
#define IDS_ERROR_COMMIT_ALREADY_COMPLETE       ( ID_BCA_START + 66 )

// The rollback failed because the commit was not completed.
#define IDS_ERROR_ROLLBACK_FAILED_INCOMPLETE_COMMIT     ( ID_BCA_START + 67 )

// This action cannot be rolled back.
#define IDS_ERROR_ROLLBACK_NOT_POSSIBLE         ( ID_BCA_START + 68 )

// The cluster IP address is already in use.
#define IDS_ERROR_IP_ADDRESS_IN_USE             ( ID_BCA_START + 69 )

// An error occurred attempting to delete a registry key.
#define IDS_ERROR_REGISTRY_DELETE               ( ID_BCA_START + 70 )

/////////////////////////////////////////////////////////////////////
// Notification strings
/////////////////////////////////////////////////////////////////////

// Starting cluster create operation
#define IDS_TASK_FORMING_CLUSTER                ( ID_BCA_START + 800 )

// Cleaning up cluster database
#define IDS_TASK_CLEANINGUP_CLUSDB              ( ID_BCA_START + 801 )

// Creating cluster database
#define IDS_TASK_FORM_CREATING_CLUSDB           ( ID_BCA_START + 802 )

// Customizing cluster database
#define IDS_TASK_FORM_CUSTOMIZING_CLUSDB        ( ID_BCA_START + 803 )

// Configuring the ClusDisk service
#define IDS_TASK_CONFIG_CLUSDISK                ( ID_BCA_START + 804 )

// Starting the ClusDisk service
#define IDS_TASK_STARTING_CLUSDISK              ( ID_BCA_START + 805 )

// Creating the Cluster Network Provider service
#define IDS_TASK_CREATING_CLUSNET               ( ID_BCA_START + 806 )

// Starting the Cluster Network Provider service
#define IDS_TASK_STARTING_CLUSNET               ( ID_BCA_START + 807 )

// Creating the Cluster service
#define IDS_TASK_CREATING_CLUSSVC               ( ID_BCA_START + 808 )

// Starting the Cluster service
#define IDS_TASK_STARTING_CLUSSVC               ( ID_BCA_START + 809 )

// Configuring the cluster service account
#define IDS_TASK_CONFIG_CLUSSVC_ACCOUNT         ( ID_BCA_START + 810 )

// Performing miscellaneous configuration steps
#define IDS_TASK_CONFIG_NODE                    ( ID_BCA_START + 811 )

// Adding node to cluster
#define IDS_TASK_JOINING_CLUSTER                ( ID_BCA_START + 812 )

// Creating cluster database
#define IDS_TASK_JOIN_CREATING_CLUSDB           ( ID_BCA_START + 813 )

// Synchronizing the cluster database with the sponsor cluster
#define IDS_TASK_JOIN_SYNC_CLUSDB               ( ID_BCA_START + 814 )

// Initializing to add nodes to a cluster
#define IDS_TASK_JOIN_INIT                      ( ID_BCA_START + 815 )

// Initializing a cluster create operation
#define IDS_TASK_FORM_INIT                      ( ID_BCA_START + 816 )

// Adding the cluster service account to the local Administrators group
#define IDS_TASK_MAKING_CLUSSVC_ACCOUNT_ADMIN   ( ID_BCA_START + 817 )

// The cluster service account was already a member of the local Administrators group
#define IDS_TASK_CLUSSVC_ACCOUNT_ALREADY_ADMIN  ( ID_BCA_START + 818 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\caction.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CAction.cpp
//
//  Description:
//      Contains the definition of the CAction class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     25-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// For the CAction class
#include "CAction.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAction::Commit
//
//  Description:
//      This function just checks to make sure that this action has not already
//      been commmitted.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the action has already been committed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CAction::Commit( void )
{
    TraceFunc( "" );

    // Has this action already been committed?
    if ( FIsCommitComplete() )
    {
        LogMsg( "[BC] This action has already been committed. Throwing exception." );
        THROW_ASSERT( HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ALREADY_COMMITTED ) ), "This action has already been committed." );
    } // if: already committed.

    TraceFuncExit();

} //*** CAction::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAction::Rollback
//
//  Description:
//      Since the Commit() of this class does nothing, rollback does nothing
//      too. However, it checks to make sure that this action can indeed be
//      rolled back.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If this action has not been committed yet or if rollback is not
//          possible.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CAction::Rollback( void )
{
    TraceFunc( "" );

    // Check if this action list has completed successfully.
    if ( ! FIsCommitComplete() )
    {
        // Cannot rollback an incomplete action.
        LogMsg( "[BC] Cannot rollback - this action has not been committed. Throwing exception." );
        THROW_ASSERT( HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ROLLBACK_FAILED ) ), "Cannot rollback - this action has been committed." );
    } // if: this action was not completed successfully

    // Check if this list can be rolled back.
    if ( ! FIsRollbackPossible() )
    {
        // Cannot rollback an incompleted action.
        LogMsg( "[BC] This action list cannot be rolled back." );
        THROW_ASSERT( HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ROLLBACK_FAILED ) ), "This action does not allow rollbacks." );
    } // if: this action was not completed successfully

    TraceFuncExit();

} //*** CAction::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cactionlist.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CActionList.h
//
//  Description:
//      Header file for CActionList class.
//
//      The CActionList is a class the provides a functionality for a list of
//      actions. When an action list is committed, it commits each of the
//      actions in its list. Either the entire list is committed or none of
//      actions are.
//
//  Implementation Files:
//      CActionList.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the list class
#include "CList.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CActionList
//
//  Description:
//      The CActionList is a class the provides a functionality for a list of
//      actions. When an action list is committed, it commits each of the
//      actions in its list.
//
//      If any of the actions fail (indicated by throwing an exception), then 
//      all the committed actions are rolled back.
//
//      The CActionList derives from CAction since it can also be committed
//      or rolled back.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CActionList : public CAction
{
public:

    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CActionList();

    // Default virtual destructor.
    ~CActionList();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Base class method.
    // Commit this action list. This method has to be durable and consistent. It shoud
    // try as far as possible to be atomic.
    //
    void Commit();

    //
    // Base class method.
    // Rollback this action list. Be careful about throwing exceptions from this method
    // as a stack unwind might be in progress when this method is called.
    //
    void Rollback();

    // Add an action to the end of the list of actions to be performed.
    virtual void AppendAction( CAction * const paNewActionIn );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw();


protected:

    //////////////////////////////////////////////////////////////////////////
    // Protected type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CList<CAction *>    ActionPtrList;


    //////////////////////////////////////////////////////////////////////////
    // Protected accessor methods
    //////////////////////////////////////////////////////////////////////////

    // 
    // Pending action list accessor
    //
    ActionPtrList & AplGetPendingActionsList() throw()
    { 
        return m_aplPendingActions;
    }


    //////////////////////////////////////////////////////////////////////////
    // Protected member functions
    //////////////////////////////////////////////////////////////////////////

    // Call commit on the action list. Called by Commit().
    void CommitList( ActionPtrList::CIterator & rapliFirstUncommittedOut );

    // Rollback the already committed actions.
    void RollbackCommitted( const ActionPtrList::CIterator & rapliFirstUncommittedIn );


private:

    //////////////////////////////////////////////////////////////////////////
    // Private type definitions
    //////////////////////////////////////////////////////////////////////////
    typedef CAction BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // List of actions yet to be committed.
    ActionPtrList       m_aplPendingActions;

}; //*** class CActionList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\caction.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CAction.h
//
//  Description:
//      Header file for CAction class.
//
//      The CAction is the base class for all the action classes. It is an
//      abstract class which encapsulates the concept of an action - something
//      that be committed or rolled back. See IMPORTANT NOTE in the comment above
//      the class declaration.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For HRESULT, WCHAR, etc.
#include <windef.h>


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAction
//
//  Description:
//      The CAction is the base class for all the action classes. It is an
//      abstract class which encapsulates the concept of an action - something
//      that be committed or rolled back.
//
//      Typically, any class that derives from this class would also implement
//      other methods that allow for specifying what action would be performed
//      by the Commit() method.
//
//  IMPORTANT NOTE: 
//      An object of this class cannot be a part of a transaction at this stage
//      because many of the resources typically used by these actions (the registry,
//      the SCM database, etc.) do not do not support transactions.
//
//      However, a transaction-like behavior is required from each of these
//      actions. What is meant by transaction-like is that the commit and
//      rollback methods of objects of this class have to guarantee durability,
//      and consistency. While they need not be isolated, they should at least
//      try to be atomic (it may not always be possilbe to be atomic).
//
//      If any action cannot guarantee that it is at least consistency and
//      durability (and preferably atomicity) during its commit, then it should 
//      NOT derive from this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default constructor.
    CAction()
        : m_fCommitComplete( false )
        , m_fRollbackPossible( true )
    {}

    // Default virtual destructor.
    virtual 
        ~CAction() {}


    //////////////////////////////////////////////////////////////////////////
    // Pure virtual functions
    //////////////////////////////////////////////////////////////////////////

    //
    // Commit this action. This method has to be durable and consistent. It shoud
    // try as far as possible to be atomic.
    // The implementation of this method checks to see if the action has been committed
    // and throws an exception if it already has been committed.
    //
    virtual void
        Commit();

    //
    // Rollback this action. Be careful about throwing exceptions from this method
    // as a stack unwind might be in progress when this method is called.
    // The implementation of this method checks to see if the action has been committed
    // and if it can be rolled back and throws an exception otherwise.
    //
    virtual void
        Rollback();

    // Returns the number of progress messages that this action will send.
    virtual UINT
        UiGetMaxProgressTicks() const throw() { return 0; }


    //////////////////////////////////////////////////////////////////////////
    // Public accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Has this action been successfully committed.
    bool 
        FIsCommitComplete() const throw() { return m_fCommitComplete; }

    // Can this action be rolled back.
    bool 
        FIsRollbackPossible() const throw() { return m_fRollbackPossible; }


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Set the commit status.
    void
        SetCommitCompleted( bool fComplete = true ) throw() { m_fCommitComplete = fComplete; }

    // Indicate if rollback is possible
    void
        SetRollbackPossible( bool fPossible = true ) throw() { m_fRollbackPossible = fPossible; }


private:

    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Indicates if this action has been successfully committed or not.
    bool                m_fCommitComplete;

    // Indicates if this action can be rolled back or not.
    bool                m_fRollbackPossible;

}; //*** class CAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cactionlist.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CActionList.cpp
//
//  Description:
//      Contains the definition of the CActionList class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// For the CActionList class
#include "CActionList.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::CActionList
//
//  Description:
//      Default constructor of the CActionList class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList::CList()
//
//--
//////////////////////////////////////////////////////////////////////////////
CActionList::CActionList( void )
{
    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CActionList::CActionList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::~CActionList
//
//  Description:
//      Default destructor of the CActionList class. Deletes all the pointers
//      in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList::CList()
//
//--
//////////////////////////////////////////////////////////////////////////////
CActionList::~CActionList( void )
{
    TraceFunc( "" );

    ActionPtrList::CIterator apliFirst = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliCurrent = m_aplPendingActions.CiEnd();

    while ( apliCurrent != apliFirst )
    {
        --apliCurrent;

        // Delete this action.
        delete (*apliCurrent);
    }

    TraceFuncExit();

} //*** CActionList::~CActionList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::Commit
//
//  Description:
//      Commit this action list. This method iterates through the list
//      sequentially and commits each action in the list in turn. 
//
//      If the commits of any of the actions throws an exeption, then all the
//      previously committed actions are rolled back. This exception is then
//      thrown back up.      
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::Commit( void )
{
    TraceFunc( "" );

    // Iterator positioned at the first uncommitted action just past the last committed action.
    ActionPtrList::CIterator apliFirstUncommitted = m_aplPendingActions.CiBegin();

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Walk the list of pending actions and commit them.
        CommitList( apliFirstUncommitted );

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with one of the actions.

        LogMsg( "[BC] Caught an exception during commit. The performed actions will be rolled back." );

        //
        // Rollback all committed actions in the reverse order. apliFirstUncommitted
        // is at the first uncommitted action.
        // Catch any exceptions thrown during rollback to make sure that there 
        // is no collided unwind.
        //
        try
        {
            RollbackCommitted( apliFirstUncommitted );
        }
        catch( ... )
        {
            //
            // The rollback of the committed actions has failed.
            // There is nothing that we can do, is there?
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ROLLBACK_FAILED ) );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during rollback. Rollback will be aborted." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted();

    TraceFuncExit();

} //*** CActionList::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::Rollback
//
//  Description:
//      Rollback this action list. If this list was successfully committed, then
//      this method iterates through the list in the reverse order and rolls
//      back action in turn. 
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::Rollback( void )
{
    TraceFunc( "[IUnknown]" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    LogMsg( "[BC] Attempting to rollback action list." );

    // Rollback all actions starting from the last one.
    RollbackCommitted( m_aplPendingActions.CiEnd() );

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CActionList::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::AppendAction
//
//  Description:
//      Add an action to the end of the list of actions to be performed.
//
//  Arguments:
//      paNewActionIn
//          Pointer to the action that is to be added to the end of the
//          action list. This pointer cannot be NULL. The object pointed to by 
//          this pointer is deleted when this list is deleted.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If paNewActionIn is NULL.
//
//      Any that are thrown by the underlying list.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::AppendAction( CAction * paNewActionIn )
{
    TraceFunc( "" );

    // Temporarily assign pointer to smart pointer to make sure that it is
    // deleted if it is not added to the list.
    CSmartGenericPtr< CPtrTrait< CAction > >  sapTempSmartPtr( paNewActionIn );

    if ( paNewActionIn == NULL ) 
    {
        LogMsg( "[BC] Cannot append NULL action pointer to list. Throwing an exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CActionList::AppendAction() => Cannot append NULL action pointer to list"
            );

    } // if: the pointer to the action to be appended is NULL

    //
    LogMsg( "[BC] Appending action (paNewActionIn = %p) to list.", paNewActionIn );

    // Add action to the end of the list.
    m_aplPendingActions.Append( paNewActionIn );

    // The pointer has been added to the list. Give up ownership of the memory.
    sapTempSmartPtr.PRelease();

    // The rollback capability of the list is the AND of the corresponding property of its member actions.
    SetRollbackPossible( FIsRollbackPossible() && paNewActionIn->FIsRollbackPossible() );

    // Since a new action has been added, set commit completed to false.
    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CActionList::AppendAction


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::CommitList
//
//  Description:
//      Commit the action list of this object. This function is called by
//      commit to avoid having loops in a try block.
//
//  Arguments:
//       rapliFirstUncommittedOut
//          An iterator that points to the first uncommitted action.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::CommitList( ActionPtrList::CIterator & rapliFirstUncommittedOut )
{
    TraceFunc( "" );

    ActionPtrList::CIterator apliCurrent = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliLast = m_aplPendingActions.CiEnd();

    rapliFirstUncommittedOut = apliCurrent;

    while( apliCurrent != apliLast )
    {
        LogMsg( "[BC] About to commit action (pointer = %#p)", *apliCurrent );

        // Commit the current action.
         (*apliCurrent)->Commit();

        // Move to the next action.
        ++apliCurrent;

        // This is now the first uncommitted action.
        rapliFirstUncommittedOut = apliCurrent;

    } // while: there still are actions to be committed.

    TraceFuncExit();

} //*** CActionList::CommitList


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::RollbackCommitted
//
//  Description:
//      Rollback all actions that have been committed.
//
//  Arguments:
//       rapliFirstUncommittedIn
//          An iterator that points to the first uncommitted action.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CActionList::RollbackCommitted( const ActionPtrList::CIterator & rapliFirstUncommittedIn )
{
    TraceFunc( "" );

    ActionPtrList::CIterator apliFirst = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliCurrent = rapliFirstUncommittedIn;

    while ( apliCurrent != apliFirst )
    {
        --apliCurrent;
        // apliCurrent is now at the last committed action.

        LogMsg( "[BC] About to rollback action (pointer = %#p)", *apliCurrent );

        // Rollback the last un-rolledback, committed action.

        if ( (*apliCurrent)->FIsRollbackPossible() )
        {
            (*apliCurrent)->Rollback();
        } // if: this action can be rolled back
        else
        {
            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Action cannot be rolled back. Rollback was aborted." );
        } // else: this action cannot be rolled back
    } // while: more actions

    TraceFuncExit();

} //*** CActionList::RollbackCommitted


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CActionList::UiGetMaxProgressTicks
//
//  Description:
//      Returns the number of progress messages that this action will send.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
UINT
CActionList::UiGetMaxProgressTicks( void ) const throw()
{
    TraceFunc( "" );

    UINT    uiRetVal = 0;

    ActionPtrList::CIterator apliCurrent = m_aplPendingActions.CiBegin();
    ActionPtrList::CIterator apliLast = m_aplPendingActions.CiEnd();

    while ( apliCurrent != apliLast )
    {
        uiRetVal += (*apliCurrent)->UiGetMaxProgressTicks();
        ++apliCurrent;
    }

    RETURN( uiRetVal );

} //*** CActionList::UiGetMaxProgressTicks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraction.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAction.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterAction class.
//
//  Maintained By:
//      David Potter    (DavidP)    06-MAR-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// For the CBaseClusterAction class
#include "CBaseClusterAction.h"

// For the CEnableThreadPrivilege class.
#include "CEnableThreadPrivilege.h"


//////////////////////////////////////////////////////////////////////////////
// Global variables
//////////////////////////////////////////////////////////////////////////////

// Name of the cluster configuration semaphore.
const WCHAR *  g_pszConfigSemaphoreName = L"Global\\Microsoft Cluster Configuration Semaphore";


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Name of the main cluster INF file.
#define CLUSTER_INF_FILE_NAME \
    L"ClCfgSrv.INF"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::CBaseClusterAction
//
//  Description:
//      Default constructor of the CBaseClusterAction class
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAction::CBaseClusterAction( CBCAInterface * pbcaiInterfaceIn )
    : m_ebcaAction( eCONFIG_ACTION_NONE )
    , m_pbcaiInterface( pbcaiInterfaceIn )
{
    TraceFunc( "" );

    DWORD           dwBufferSize    = 0;
    UINT            uiErrorLine     = 0;
    LPBYTE          pbTempPtr       = NULL;
    DWORD           sc              = ERROR_SUCCESS;
    SmartSz         sszTemp;
    CRegistryKey    rkInstallDirKey;


    //
    // Perform a sanity check on the parameters used by this class
    //
    if ( pbcaiInterfaceIn == NULL )
    {
        LogMsg( "[BC] The pointer to the interface object is NULL. Throwing an exception." );
        THROW_ASSERT( E_INVALIDARG, "The pointer to the interface object is NULL" );
    } // if: the input pointer is NULL


    //
    // Get the cluster installation directory.
    //
    m_strClusterInstallDir.Empty();

    // Open the registry key.
    rkInstallDirKey.OpenKey(
          HKEY_LOCAL_MACHINE
        , CLUSREG_KEYNAME_NODE_DATA
        , KEY_READ
        );

    rkInstallDirKey.QueryValue(
          CLUSREG_INSTALL_DIR_VALUE_NAME
        , &pbTempPtr
        , &dwBufferSize
        );

    // Memory will be freed when this function exits.
    sszTemp.Assign( reinterpret_cast< WCHAR * >( pbTempPtr ) );

    // Copy the path into the member variable.
    m_strClusterInstallDir = sszTemp.PMem();

    // First, remove any trailing backslash characters from the quorum directory name.
    {
        WCHAR       szQuorumDirName[] = CLUS_NAME_DEFAULT_FILESPATH;
        SSIZE_T     idxLastChar;

        // Set the index to the last non-null character.
        idxLastChar = ARRAYSIZE( szQuorumDirName ) - 1;

        --idxLastChar;      // idxLastChar now points to the last non-null character

        // Iterate till we find the last character that is not a backspace.
        while ( ( idxLastChar >= 0 ) && ( szQuorumDirName[ idxLastChar ] == L'\\' ) )
        {
            --idxLastChar;
        }

        // idxLastChar now points to the last non-backslash character. Terminate the string after this character.
        szQuorumDirName[ idxLastChar + 1 ] = L'\0';

        // Determine the local quorum directory.
        m_strLocalQuorumDir = m_strClusterInstallDir + L"\\";
        m_strLocalQuorumDir += szQuorumDirName;
    }

    LogMsg(
          "[BC] The cluster installation directory is '%s'. The localquorum directory is '%s'."
        , m_strClusterInstallDir.PszData()
        , m_strLocalQuorumDir.PszData()
        );


    //
    // Open the main cluster INF file.
    //
    m_strMainInfFileName = m_strClusterInstallDir + L"\\" CLUSTER_INF_FILE_NAME;

    m_sihMainInfFile.Assign(
        SetupOpenInfFile(
              m_strMainInfFileName.PszData()
            , NULL
            , INF_STYLE_WIN4
            , &uiErrorLine
            )
        );

    if ( m_sihMainInfFile.FIsInvalid() )
    {
        sc = TW32( GetLastError() );

        LogMsg( "[BC] Could not open INF file '%s'. Error code = %#08x. Error line = %d. Cannot proceed (throwing an exception).", m_strMainInfFileName.PszData(), sc, uiErrorLine );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_INF_FILE_OPEN );

    } // if: INF file could not be opened.

    LogMsg( "[BC] The INF file '%s' has been opened.", m_strMainInfFileName.PszData() );


    // Associate the cluster installation directory with the directory id CLUSTER_DIR_DIRID
    SetDirectoryId( m_strClusterInstallDir.PszData(), CLUSTER_DIR_DIRID );

    // Set the id for the local quorum directory.
    SetDirectoryId( m_strLocalQuorumDir.PszData(), CLUSTER_LOCALQUORUM_DIRID );

    //
    // Create a semaphore that will be used to make sure that only one commit is occurring
    // at a time. But do not acquire the semaphore now. It will be acquired later.
    //
    // Note that if this component is in an STA then, more than one instance of this
    // component may have the same thread excecuting methods when multiple configuration
    // sessions are started simultaneously. The way CreateMutex works, all components that
    // have the same thread running through them will successfully acquire the mutex.
    //
    SmartSemaphoreHandle smhConfigSemaphoreHandle(
        CreateSemaphore(
              NULL                      // Default security descriptor
            , 1                         // Initial count.
            , 1                         // Maximum count.
            , g_pszConfigSemaphoreName  // Name of the semaphore
            )
        );

    // Check if creation failed.
    if ( smhConfigSemaphoreHandle.FIsInvalid() )
    {
        sc = TW32( GetLastError() );

        LogMsg( "[BC] Semaphore '%ws' could not be created. Error %#08x. Cannot proceed (throwing an exception).", g_pszConfigSemaphoreName, sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SEMAPHORE_CREATION );
    } // if: semaphore could not be created.

    m_sshConfigSemaphoreHandle = smhConfigSemaphoreHandle;

    //
    // Open and store the handle to the SCM. This will make life a lot easier for
    // other actions.
    //
    m_sscmhSCMHandle.Assign( OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ) );

    // Could we get the handle to the SCM?
    if ( m_sscmhSCMHandle.FIsInvalid() )
    {
        sc = TW32( GetLastError() );

        LogMsg( "[BC] Error %#08x occurred trying get a handle to the SCM. Cannot proceed (throwing an exception).", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_OPEN_SCM );
    }

    TraceFuncExit();

} //*** CBaseClusterAction::CBaseClusterAction


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::~CBaseClusterAction
//
//  Description:
//      Destructor of the CBaseClusterAction class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAction::~CBaseClusterAction( void ) throw()
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CBaseClusterAction::~CBaseClusterAction


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::Commit
//
//  Description:
//      Acquires a semaphore to prevent simultaneous configuration and commits
//      the action list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CAssert
//          If this object is not in the correct state when this function is
//          called.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAction::Commit( void )
{
    TraceFunc( "" );

    DWORD   dwSemaphoreState;

    // Call the base class commit method.
    BaseClass::Commit();


    LogMsg( "[BC] Initiating cluster configuration." );

    //
    // Acquire the cluster configuration semaphore.
    // It is ok to use WaitForSingleObject() here instead of MsgWaitForMultipleObjects
    // since we are not blocking.
    //
    dwSemaphoreState = WaitForSingleObject( m_sshConfigSemaphoreHandle, 0 ); // zero timeout

    // Did we get the semaphore?
    if (  ( dwSemaphoreState != WAIT_ABANDONED )
       && ( dwSemaphoreState != WAIT_OBJECT_0 )
       )
    {
        DWORD sc;

        if ( dwSemaphoreState == WAIT_FAILED )
        {
            sc = TW32( GetLastError() );
        } // if: WaitForSingleObject failed.
        else
        {
            sc = TW32( ERROR_LOCK_VIOLATION );
        } // else: could not get lock

        LogMsg( "[BC] Could not acquire configuration lock. Error %#08x. Aborting (throwing an exception).", sc );
        THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SEMAPHORE_ACQUISITION );
    } // if: semaphore acquisition failed

    // Assign the locked semaphore handle to a smart handle for safe release.
    SmartSemaphoreLock sslConfigSemaphoreLock( m_sshConfigSemaphoreHandle.HHandle() );

    LogMsg( "[BC] The configuration semaphore has been acquired.  Committing the action list." );

    // Commit the action list.
    m_alActionList.Commit();

    TraceFuncExit();

} //*** CBaseClusterAction::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAction::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method.
    BaseClass::Rollback();

    // Rollback the actions.
    m_alActionList.Rollback();

    TraceFuncExit();

} //*** CBaseClusterAction::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAction::SetDirectoryId
//
//  Description:
//      Associate a particular directory with an id in the main INF file.
//
//  Arguments:
//      pcszDirectoryNameIn
//          The full path to the directory.
//
//      uiIdIn
//          The id to associate this directory with.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If SetupSetDirectoryId fails.
//
//  Remarks:
//      m_sihMainInfFile has to be valid before this function can be called.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAction::SetDirectoryId(
      const WCHAR * pcszDirectoryNameIn
    , UINT          uiIdIn
    )
{
    TraceFunc1( "pcszDirectoryNameIn = '%ws'", pcszDirectoryNameIn );

    if ( SetupSetDirectoryId( m_sihMainInfFile, uiIdIn, pcszDirectoryNameIn ) == FALSE )
    {
        DWORD sc = TW32( GetLastError() );

        LogMsg( "[BC] Could not associate the directory '%ws' with the id %#x. Error %#08x. Cannot proceed (throwing an exception).", pcszDirectoryNameIn, uiIdIn, sc );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_SET_DIRID );
    } // if: there was an error setting the directory id.

    LogMsg( "[BC] Directory id %d associated with '%ws'.", uiIdIn, pcszDirectoryNameIn );

    TraceFuncExit();

} //*** CBaseClusterAction::SetDirectoryId
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraction.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAction.h
//
//  Description:
//      Header file for CBaseClusterAction class.
//
//      The CBaseClusterAction class is the base class for the other
//      base cluster action classes. The base cluster actions are forming a
//      cluster, joining a cluster, upgrade support and cleanup.
//
//      For each base cluster action, there is a class derived from this
//      class that performs the desired action. This class encapsulates
//      what is common to these actions.
//
//  Implementation Files:
//      CBaseClusterAction.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For MAX_PATH
#include <windows.h>

// For the CAction base class
#include "CAction.h"

// For the CActionList base class
#include "CActionList.h"

// For a few common definitions
#include "CommonDefs.h"

// For HINF, SetupCloseInfFile, etc.
#include <setupapi.h>

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations.
//////////////////////////////////////////////////////////////////////////

class CBCAInterface;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterAction
//
//  Description:
//      The CBaseClusterAction class is the base class for the other
//      base cluster action classes. The base cluster actions are forming a
//      cluster, joining a cluster, upgrade support and cleanup.
//
//      For each base cluster action, there is a class derived from this
//      class that performs the desired action. This class encapsulates
//      what is common to these actions.
//
//      An object of this class is intended for one time use only. That is,
//      after an object has been committed, it cannot be re-committed.
//
//      This class is intended to be used as a base class only. Therefore,
//      its constructors and destructors are protected
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterAction : public CAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Default destructor.
    virtual ~CBaseClusterAction() throw();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Base class method.
    // Commit this action. This method has to be durable and consistent. It shoud
    // try as far as possible to be atomic.
    //
    void Commit();

    //
    // Base class method.
    // Rollback this action. Be careful about throwing exceptions from this method
    // as a stack unwind might be in progress when this method is called.
    //
    void Rollback();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the type of this action.
    EBaseConfigAction
        EbcaGetAction() const throw()
    {
        return m_ebcaAction;
    }

    // Get the cluster installation directory.
    const CStr &
        RStrGetClusterInstallDirectory() const throw()
    {
        return m_strClusterInstallDir;
    }

    // Get the localquorum directory.
    const CStr &
        RStrGetLocalQuorumDirectory() const throw()
    {
        return m_strLocalQuorumDir;
    }

    // Get the handle to the main INF file.
    HINF
        HGetMainInfFileHandle() const throw()
    {
        return m_sihMainInfFile;
    }

    // Get the name of the main INF file.
    const CStr &
        RStrGetMainInfFileName() const throw()
    {
        return m_strMainInfFileName;
    }

    // Get the handle to the SC Manager.
    SC_HANDLE
        HGetSCMHandle() const throw()
    {
        return m_sscmhSCMHandle;
    }

    // Get the interface pointer.
    CBCAInterface *
        PBcaiGetInterfacePointer() const throw() 
    {
        return m_pbcaiInterface;
    }


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The maximum progress ticks for this object comprises of:
        // - m_alActionList.UiGetMaxProgressTicks() => The progress ticks of
        //   the contained action objects.
        return m_alActionList.UiGetMaxProgressTicks();
    }


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    //
    // Default constructor.
    // Reads the location of the cluster binaries from the registry,
    // opens the INF file, etc.
    //
    CBaseClusterAction( CBCAInterface * pbcaiInterfaceIn );


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Set the type of action being performed by this object.
    void
        SetAction( EBaseConfigAction ebcaAction )
    {
        m_ebcaAction = ebcaAction;
    }

    // Allow derived classes to modify this action list.
    CActionList &
        RalGetActionList() throw()
    {
        return m_alActionList;
    }

    // Associate a particular directory with an id in the main INF file.
    void
        SetDirectoryId( const WCHAR * pcszDirectoryNameIn, UINT uiIdIn );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // Class used to automatically release a semaphore.
    class CSemaphoreHandleTrait
    {
    public:
        //////////////////////////////////////////////////////////////////////////
        // Public types
        //////////////////////////////////////////////////////////////////////////
        typedef HANDLE ResourceType;


        //////////////////////////////////////////////////////////////////////////
        // Public methods
        //////////////////////////////////////////////////////////////////////////

        // A routine used to close a handle.
        static void CloseRoutine( ResourceType hResourceIn )
        {
            ReleaseSemaphore( hResourceIn, 1, NULL );
        } //*** CloseRoutine()

        // Get the null value for this type.
        static ResourceType HGetNullValue()
        {
            return NULL;
        } //*** HGetNullValue()

    }; //*** class CSemaphoreHandleTrait

    // A class that automatically releases a signalled semaphore.
    typedef CSmartResource< CSemaphoreHandleTrait > SmartSemaphoreLock;

    // The base class for this class.
    typedef CAction BaseClass;

    // A smart INF file handle.
    typedef CSmartResource<
        CHandleTrait<
              HINF 
            , VOID
            , SetupCloseInfFile
            , INVALID_HANDLE_VALUE
            >
        >
        SmartInfHandle;

    // Smart semaphore type
    typedef CSmartResource< CHandleTrait< HANDLE, BOOL, CloseHandle > > SmartSemaphoreHandle;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CBaseClusterAction( const CBaseClusterAction & );

    // Assignment operator
    const CBaseClusterAction & operator =( const CBaseClusterAction & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the interface class.
    CBCAInterface *         m_pbcaiInterface;

    // Action to be performed.
    EBaseConfigAction       m_ebcaAction;

    // The list of actions to be performed by this action.
    CActionList             m_alActionList;

    // The installation directory of the cluster binaries.
    CStr                    m_strClusterInstallDir;

    // The directory used to store the localquorum files.
    CStr                    m_strLocalQuorumDir;

    // Name of the main INF file.
    CStr                    m_strMainInfFileName;

    // A handle to the main INF file.
    SmartInfHandle          m_sihMainInfFile;

    // A semaphore used to ensure that only one configuration is in progress.
    SmartSemaphoreHandle     m_sshConfigSemaphoreHandle;

    // A smart handle to the Service Control Manager.
    SmartSCMHandle          m_sscmhSCMHandle;

}; //*** class CBaseClusterAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraddnode.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAddNode.h
//
//  Description:
//      Header file for CBaseClusterAddNode class.
//
//      The CBaseClusterAddNode class is a class that captures the commonality
//      between forming and joining a cluster.
//
//  Implementation Files:
//      CBaseClusterAddNode.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAction.h"

// For LsaClose, LSA_HANDLE, etc.
#include <ntsecapi.h>

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterAddNode
//
//  Description:
//      The CBaseClusterAddNode class is a class that captures the commonality
//      between forming and joining a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterAddNode : public CBaseClusterAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the name of the cluster being formed or joined.
    const CStr &
        RStrGetClusterName( void ) const throw() { return m_strClusterName; }

    // Get the NetBIOS name of the cluster being formed or joined.
    const CStr &
        RStrGetClusterNetBIOSName( void ) const throw() { return m_strClusterNetBIOSName; }

    // Get the name of this node.
    const WCHAR *
        PszGetNodeName( void ) const throw() { return m_szComputerName; }

    // Get the length of the name of this node..
    DWORD
        DwGetNodeNameLength( void ) const throw() { return m_dwComputerNameLen; }

    // Get the node highest version.
    DWORD
        DwGetNodeHighestVersion( void ) const throw() { return m_dwNodeHighestVersion; }

    // Get the node lowest version.
    DWORD
        DwGetNodeLowestVersion( void ) const throw() { return m_dwNodeLowestVersion; }

    // Get the cluster IP Address.
    DWORD
        DwGetClusterIPAddress( void ) const throw() { return m_dwClusterIPAddress; }

    // Get the cluster service account credentials.
    IClusCfgCredentials &
        GetServiceAccountCredentials( void ) const throw() { return *m_pcccServiceAccount; }

    // Get the cluster service account UPN
    CStr
        StrGetServiceAccountUPN( void );

    // Get the cluster binding string.
    const CStr &
        RStrGetClusterBindingString( void ) const throw() { return m_strClusterBindingString; }

    // Get the SID of the cluster service account.
    SID *
        PSidGetServiceAccountSID( void ) const throw() { return m_sspClusterAccountSid.PMem(); }

    // Get the LSA policy handle.
    LSA_HANDLE
        HGetLSAPolicyHandle( void ) const throw() { return m_slsahPolicyHandle.HHandle(); }

    // Get the NodeId of this node.
    virtual const WCHAR *
        PszGetNodeIdString( void ) const throw() = 0;

    // Indicates if version checking is disabled or not.
    bool
        FIsVersionCheckingDisabled( void ) const throw() { return m_fIsVersionCheckingDisabled; }


protected:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterAddNode(
          CBCAInterface *       pbcaiInterfaceIn
        , const WCHAR *         pcszClusterNameIn
        , const WCHAR *         pszClusterBindingStringIn
        , IClusCfgCredentials * pcccServiceAccountIn
        , DWORD                 dwClusterIPAddressIn
        );

    // Default destructor.
    ~CBaseClusterAddNode( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Set the name of the cluster being formed.
    void
        SetClusterName( const WCHAR * pszClusterNameIn );

    // Set the cluster IP Address
    void
        SetClusterIPAddress( DWORD dwClusterIPAddressIn )
    {
        m_dwClusterIPAddress = dwClusterIPAddressIn;
    }

    void
        SetVersionCheckingDisabled( bool fDisabledIn = true )
    {
        m_fIsVersionCheckingDisabled = fDisabledIn;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CBaseClusterAction  BaseClass;

    typedef CSmartGenericPtr< CPtrTrait< SID > >  SmartSIDPtr;

    typedef CSmartResource<
        CHandleTrait<
              LSA_HANDLE
            , NTSTATUS
            , LsaClose
            >
        >
        SmartLSAHandle;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Name of the cluster
    CStr                    m_strClusterName;
    CStr                    m_strClusterNetBIOSName;

    // Name and version information of this computer
    WCHAR                   m_szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD                   m_dwComputerNameLen;
    DWORD                   m_dwNodeHighestVersion;
    DWORD                   m_dwNodeLowestVersion;
    DWORD                   m_dwClusterIPAddress;
    bool                    m_fIsVersionCheckingDisabled;

    // Cluster service account information.
    IClusCfgCredentials *   m_pcccServiceAccount;
    CStr                    m_strClusterDomainAccount;
    CStr                    m_strClusterBindingString;
    SmartSIDPtr             m_sspClusterAccountSid;

    // Smart handle to the LSA policy.
    SmartLSAHandle          m_slsahPolicyHandle;

}; //*** class CBaseClusterAddNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclustercleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterCleanup.h
//
//  Description:
//      Header file for CBaseClusterCleanup class.
//
//      The CBaseClusterCleanup class is a class that encapsulates the
//      cleanup of a node after it has been evicted from a cluster.
//
//  Implementation Files:
//      CBaseClusterCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 29-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAction.h"

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterCleanup
//
//  Description:
//      The CBaseClusterCleanup class is a class that encapsulates the
//      cleanup of a node after it has been evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterCleanup : public CBaseClusterAction
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterCleanup(
          CBCAInterface *   pbcaiInterfaceIn
        );

    // Default destructor.
    ~CBaseClusterCleanup() throw();


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Cleanup this node.
    void 
        Commit();

    // Rolling back a cleanup operation.
    void 
        Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        return BaseClass::UiGetMaxProgressTicks();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CBaseClusterAction BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CBaseClusterCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusteraddnode.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterAddNode.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterAddNode class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header file of this class.
#include "CBaseClusterAddNode.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::CBaseClusterAddNode
//
//  Description:
//      Constructor of the CBaseClusterAddNode class.
//
//      This function also stores the parameters that are required for
//      creating a cluster and adding nodes to the cluster. At this time,
//      only minimal validation is done on the these parameters.
//
//      This function also checks if the computer is in the correct state
//      for cluster configuration.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//      pszClusterNameIn
//          Name of the cluster to be formed or joined.
//
//      pcccServiceAccountIn
//          Specifies the account to be used as the cluster service account.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAddNode::CBaseClusterAddNode(
      CBCAInterface *       pbcaiInterfaceIn
    , const WCHAR *         pcszClusterNameIn
    , const WCHAR *         pcszClusterBindingStringIn
    , IClusCfgCredentials * pcccServiceAccountIn
    , DWORD                 dwClusterIPAddressIn
    )
    : BaseClass( pbcaiInterfaceIn )
    , m_pcccServiceAccount( pcccServiceAccountIn )
    , m_strClusterBindingString( pcszClusterBindingStringIn )
    , m_fIsVersionCheckingDisabled( false )
    , m_dwClusterIPAddress( dwClusterIPAddressIn )
{
    TraceFunc( "" );

    DWORD       sc = ERROR_SUCCESS;
    NTSTATUS    nsStatus;
    CBString    bstrAccountName;
    CBString    bstrAccountDomain;
    HRESULT     hr = S_OK;
    CStr        strAccountUserPrincipalName;

    //  Hang onto credentials so that derived classes can use them.
    m_pcccServiceAccount->AddRef();
    
    hr = THR( m_pcccServiceAccount->GetIdentity( &bstrAccountName, &bstrAccountDomain ) );
    TraceMemoryAddBSTR( static_cast< BSTR >( bstrAccountName ) );
    TraceMemoryAddBSTR( static_cast< BSTR >( bstrAccountDomain ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[BC] Failed to retrieve cluster account credentials. Throwing an exception." );
        THROW_CONFIG_ERROR( hr, IDS_ERROR_INVALID_CLUSTER_ACCOUNT );
    }
    
    //
    // Perform a sanity check on the parameters used by this class
    //
    if ( ( pcszClusterNameIn == NULL ) || ( *pcszClusterNameIn == L'\0'  ) )
    {
        LogMsg( "[BC] The cluster name is invalid. Throwing an exception." );
        THROW_CONFIG_ERROR( E_INVALIDARG, IDS_ERROR_INVALID_CLUSTER_NAME );
    } // if: the cluster name is empty

    if ( bstrAccountName.Length() == 0 )
    {
        LogMsg( "[BC] The cluster account name is empty. Throwing an exception." );
        THROW_CONFIG_ERROR( E_INVALIDARG, IDS_ERROR_INVALID_CLUSTER_ACCOUNT );
    } // if: the cluster account is empty

    //
    // Set the cluster name.  This method also converts the
    // cluster name to its NetBIOS name.
    //
    SetClusterName( pcszClusterNameIn );

    strAccountUserPrincipalName = StrGetServiceAccountUPN();

    //
    // Write parameters to log file.
    //
    LogMsg( "[BC] Cluster Name => '%s'", m_strClusterName.PszData() );
    LogMsg( "[BC] Cluster Service Account  => '%s'", strAccountUserPrincipalName.PszData() );


    //
    // Open a handle to the LSA policy. This is used by several action classes.
    //
    {
        LSA_OBJECT_ATTRIBUTES       loaObjectAttributes;
        LSA_HANDLE                  hPolicyHandle;

        ZeroMemory( &loaObjectAttributes, sizeof( loaObjectAttributes ) );

        nsStatus = LsaOpenPolicy(
              NULL                                  // System name
            , &loaObjectAttributes                  // Object attributes.
            , POLICY_ALL_ACCESS                     // Desired Access
            , &hPolicyHandle                        // Policy handle
            );

        if ( nsStatus != STATUS_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred trying to open the LSA Policy.", nsStatus );
            THROW_RUNTIME_ERROR( nsStatus, IDS_ERROR_LSA_POLICY_OPEN );
        } // if LsaOpenPolicy failed.

        // Store the opened handle in the member variable.
        m_slsahPolicyHandle.Assign( hPolicyHandle );
    }

    //
    // Make sure that this computer is part of a domain.
    //
    {
        PPOLICY_PRIMARY_DOMAIN_INFO ppolDomainInfo = NULL;
        bool                        fIsPartOfDomain;

        // Get information about the primary domain of this computer.
        nsStatus = THR( LsaQueryInformationPolicy(
                              HGetLSAPolicyHandle()
                            , PolicyPrimaryDomainInformation
                            , reinterpret_cast< PVOID * >( &ppolDomainInfo )
                            ) );

        // Check if this computer is part of a domain and free the allocated memory.
        fIsPartOfDomain = ( ppolDomainInfo->Sid != NULL );
        LsaFreeMemory( ppolDomainInfo );

        if ( NT_SUCCESS( nsStatus ) == FALSE )
        {
            LogMsg( "[BC] Error %#08x occurred trying to obtain the primary domain of this computer. Cannot proceed (throwing an exception).", sc );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_GETTING_PRIMARY_DOMAIN );
        } // LsaQueryInformationPolicy() failed.

        if ( ! fIsPartOfDomain )
        {
            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME ), IDS_ERROR_NO_DOMAIN );
        } // if: this computer is not a part of a domain
    }


    //
    // Lookup the cluster service account SID and store it.
    //

    do
    {
        DWORD           dwSidSize = 0;
        DWORD           dwDomainSize = 0;
        SID_NAME_USE    snuSidNameUse;

        // Find out how much space is required by the SID.
        if ( LookupAccountNameW(
                  NULL
                , strAccountUserPrincipalName.PszData()
                , NULL
                , &dwSidSize
                , NULL
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            sc = GetLastError();

            if ( sc != ERROR_INSUFFICIENT_BUFFER )
            {
                TW32( sc );
                LogMsg( "[BC] LookupAccountNameW() failed with error %#08x while querying for required buffer size.", sc );
                break;
            } // if: something else has gone wrong.
            else
            {
                // This is expected.
                sc = ERROR_SUCCESS;
            } // if: ERROR_INSUFFICIENT_BUFFER was returned.
        } // if: LookupAccountNameW failed

        // Allocate memory for the new SID and the domain name.
        m_sspClusterAccountSid.Assign( reinterpret_cast< SID * >( new BYTE[ dwSidSize ] ) );
        SmartSz sszDomainName( new WCHAR[ dwDomainSize ] );

        if ( m_sspClusterAccountSid.FIsEmpty() || sszDomainName.FIsEmpty() )
        {
            sc = TW32( ERROR_OUTOFMEMORY );
            break;
        } // if: there wasn't enough memory for this SID.

        // Fill in the SID
        if ( LookupAccountNameW(
                  NULL
                , strAccountUserPrincipalName.PszData()
                , m_sspClusterAccountSid.PMem()
                , &dwSidSize
                , sszDomainName.PMem()
                , &dwDomainSize
                , &snuSidNameUse
                )
             ==  FALSE
           )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] LookupAccountNameW() failed with error %#08x while attempting to get the cluster account SID.", sc );
            break;
        } // if: LookupAccountNameW failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to validate the cluster service account. Cannot proceed (throwing an exception).", sc );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_VALIDATING_ACCOUNT );
    } // if: we could not get the cluster account SID


    // Check if the installation state of the cluster binaries is correct.
    {
        eClusterInstallState    ecisInstallState;

        sc = TW32( ClRtlGetClusterInstallState( NULL, &ecisInstallState ) );

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred trying to get cluster installation state. Throwing an exception.", sc );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_GETTING_INSTALL_STATE );
        } // if: there was a problem getting the cluster installation state

        LogMsg( "[BC] Current install state = %d. Required %d.", ecisInstallState, eClusterInstallStateFilesCopied );

        //
        // The installation state should be that the binaries have been copied
        // but the cluster service has not been configured.
        //
        if ( ecisInstallState != eClusterInstallStateFilesCopied )
        {
            LogMsg( "[BC] The cluster installation state is set to %d. Expected %d. Cannot proceed (throwing an exception).", ecisInstallState, eClusterInstallStateFilesCopied );

            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_INVALID_STATE ) ), IDS_ERROR_INCORRECT_INSTALL_STATE );
        } // if: the installation state is not correct

        LogMsg( "[BC] The cluster installation state is correct. Configuration can proceed." );
    }

    // Get the name and version information for this node.
    {
        m_dwComputerNameLen = sizeof( m_szComputerName );

        // Get the computer name.
        if ( GetComputerNameW( m_szComputerName, &m_dwComputerNameLen ) == FALSE )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x occurred trying to get the name of this computer. Configuration cannot proceed (throwing an exception).", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_GETTING_COMPUTER_NAME );
        } // if: GetComputerNameW() failed.

        m_dwNodeHighestVersion = CLUSTER_MAKE_VERSION( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION, VER_PRODUCTBUILD );
        m_dwNodeLowestVersion = CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION;

        LogMsg(
              "[BC] Computer Name = '%ws' (Length %d), NodeHighestVersion = %#08x, NodeLowestVersion = %#08x."
            , m_szComputerName
            , m_dwComputerNameLen
            , m_dwNodeHighestVersion
            , m_dwNodeLowestVersion
            );
    }

    TraceFuncExit();

} //*** CBaseClusterAddNode::CBaseClusterAddNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::~CBaseClusterAddNode
//
//  Description:
//      Destructor of the CBaseClusterAddNode class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterAddNode::~CBaseClusterAddNode( void ) throw()
{
    TraceFunc( "" );
    if ( m_pcccServiceAccount != NULL )
    {
        m_pcccServiceAccount->Release();
    }
    TraceFuncExit();

} //*** CBaseClusterAddNode::~CBaseClusterAddNode


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::SetClusterName
//
//  Description:
//      Set the name of the cluster being formed.
//
//  Arguments:
//      pszClusterNameIn    -- Name of the cluster.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterAddNode::SetClusterName(
    LPCWSTR pszClusterNameIn
    )
{
    TraceFunc( "" );

    BOOL    fSuccess;
    DWORD   sc;
    WCHAR   szClusterNetBIOSName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD   nSize = ARRAYSIZE( szClusterNetBIOSName );

    m_strClusterName = pszClusterNameIn;

    fSuccess = DnsHostnameToComputerNameW(
                      pszClusterNameIn
                    , szClusterNetBIOSName
                    , &nSize
                    );
    if ( ! fSuccess )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Error %#08x occurred trying to convert the cluster name '%ls' to a NetBIOS name. Throwing an exception.", sc, pszClusterNameIn );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CVT_CLUSTER_NAME );
    }

    m_strClusterNetBIOSName = szClusterNetBIOSName;

    TraceFuncExit();

} //*** CBaseClusterAddNode::SetClusterName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterAddNode::StrGetServiceAccountUPN
//
//  Description:
//      Get the User Principal Name (in domain\name format) of the cluster
//      service account.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The service account UPN.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CStr
CBaseClusterAddNode::StrGetServiceAccountUPN( void )
{
    TraceFunc( "" );

    CBString bstrName;
    CBString bstrDomain;
    HRESULT  hr = m_pcccServiceAccount->GetIdentity( &bstrName, &bstrDomain );

    if ( bstrName.IsEmpty() == FALSE )
    {
        TraceMemoryAddBSTR( static_cast< BSTR >( bstrName ) );
    }

    if ( bstrDomain.IsEmpty() == FALSE )
    {
        TraceMemoryAddBSTR( static_cast< BSTR >( bstrDomain ) );
    }

    if ( FAILED( hr ) )
    {
        LogMsg( "[BC] Failed to retrieve cluster account credentials. Throwing an exception." );
        THROW_CONFIG_ERROR( hr, IDS_ERROR_INVALID_CLUSTER_ACCOUNT );
    }

    RETURN( CStr( CStr( bstrDomain ) + CStr( L"\\" ) + CStr( bstrName ) ) );

} //*** CBaseClusterAddNode::StrGetServiceAccountUPN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclustercleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterCleanup.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterCleanup class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     30-APR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header file of this class.
#include "CBaseClusterCleanup.h"

// For the CBCAInterface class.
#include "CBCAInterface.h"

// For the CClusSvcCleanup action
#include "CClusSvcCleanup.h"

// For the CClusDBCleanup action
#include "CClusDBCleanup.h"

// For the CClusDiskCleanup action
#include "CClusDiskCleanup.h"

// For the CClusNetCleanup action
#include "CClusNetCleanup.h"

// For the CNodeCleanup action
#include "CNodeCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterCleanup::CBaseClusterCleanup
//
//  Description:
//      Constructor of the CBaseClusterCleanup class.
//
//      This function also stores the parameters that are required for
//      cluster cleanup.
//
//      This function also checks if the computer is in the correct state
//      for cleanup.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CConfigError
//          If the OS version is incorrect or if the installation state.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterCleanup::CBaseClusterCleanup(
      CBCAInterface *   pbcaiInterfaceIn
    )
    : BaseClass( pbcaiInterfaceIn )
{
    TraceFunc( "" );
    LogMsg( "[BC] The current cluster configuration task is: Node Cleanup." );

    // Check if the installation state of the cluster binaries is correct.
    {
        eClusterInstallState    ecisInstallState;

        DWORD sc = TW32( ClRtlGetClusterInstallState( NULL, &ecisInstallState ) );

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred trying to get cluster installation state. Throwing an exception.", sc );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_GETTING_INSTALL_STATE );
        } // if: there was a problem getting the cluster installation state

        LogMsg( 
              "[BC] Current install state = %d. Required %d or %d."
            , ecisInstallState
            , eClusterInstallStateConfigured
            , eClusterInstallStateUpgraded
            );
        
        //
        // The installation state for this node to be cleaned up should be that the cluster service
        // has been configured or that it has been upgraded.
        //
        if ( ( ecisInstallState != eClusterInstallStateConfigured ) && ( ecisInstallState != eClusterInstallStateUpgraded ) )
        {
            LogMsg( "[BC] The cluster installation state is set to %d. Expected %d or %d. Cannot proceed (throwing an exception).", ecisInstallState, eClusterInstallStateConfigured, eClusterInstallStateUpgraded );

            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_INVALID_STATE ) ), IDS_ERROR_INCORRECT_INSTALL_STATE );
        } // if: the installation state is not correct

        LogMsg( "[BC] The cluster installation state is correct. Configuration can proceed." );
    }

    //
    // Create a list of actions to be performed.
    // The order of appending actions is significant.
    //

    // Add the action to clean up the ClusNet service. 
    // The ClusNet service depends on the ClusSvc service and therefore cannot be 
    // stopped if the ClusSvc service is running. So, the ClusSvc service should not be
    // running when the Commit() method of this class is called.
    RalGetActionList().AppendAction( new CClusNetCleanup( this ) );

    // Add the action to clean up the ClusDisk service.
    RalGetActionList().AppendAction( new CClusDiskCleanup( this ) );

    // Add the action to clean up the cluster database.
    RalGetActionList().AppendAction( new CClusDBCleanup( this ) );

    // Add the action to clean up miscellenous actions we performed when this node joined the cluster.
    RalGetActionList().AppendAction( new CNodeCleanup( this ) );

    // Add the action to clean up the cluster service. Clean this up last for two reasons:
    // 1. The install state is changed by this action.
    // 2. If cleanup aborted for some reason and the cluster service is not deleted, it will
    //    reinitiate cleanup the next time it starts.
    RalGetActionList().AppendAction( new CClusSvcCleanup( this ) );


    // Indicate if this action can be rolled back or not.
    SetRollbackPossible( RalGetActionList().FIsRollbackPossible() );

    // Indicate that a node should be cleaned up during commit.
    SetAction( eCONFIG_ACTION_CLEANUP );

    LogMsg( "[BC] Initialization for node cleanup complete." );

    TraceFuncExit();

} //*** CBaseClusterCleanup::CBaseClusterCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterCleanup::~CBaseClusterCleanup
//
//  Description:
//      Destructor of the CBaseClusterCleanup class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterCleanup::~CBaseClusterCleanup( void ) throw()
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CBaseClusterCleanup::~CBaseClusterCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterCleanup::Commit
//
//  Description:
//      Clean up this node. This function cannot be called when the cluster
//      service is running.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterCleanup::Commit( void )
{
    TraceFunc( "" );

    LogMsg( "[BC] Initiating cluster node cleanup." );

    // Call the base class commit routine. This commits the action list.
    BaseClass::Commit();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CBaseClusterCleanup::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterCleanup::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterCleanup::Rollback( void )
{
    TraceFunc( "" );

    // Rollback the actions.
    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CBaseClusterCleanup::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterjoin.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterJoin.h
//
//  Description:
//      Header file for CBaseClusterJoin class.
//
//      The CBaseClusterJoin class is a class that encapsulates the
//      action of add a node to a cluster.
//
//  Implementation Files:
//      CBaseClusterJoin.cpp
//
//  Maintained By:
//      Ozan Ozhan (OzanO) 22-MAR-2002
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAddNode.h"

// For the CStr class.
#include "CStr.h"

// For a few smart classes
#include "SmartClasses.h"

// For the cluster API functions and types
#include "ClusAPI.h"

// For the CClusSvcAccountConfig action
#include "CClusSvcAccountConfig.h"


//////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////

// Class used to automatically release a RPC binding handle.
class CRPCBindingHandleTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef RPC_BINDING_HANDLE ResourceType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to close a handle.
    static void CloseRoutine( ResourceType hResourceIn )
    {
        RpcBindingFree( &hResourceIn );
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return NULL;
    } //*** HGetNullValue()

}; //*** class CRPCBindingHandleTrait

// A smart RPC binding handle
typedef CSmartResource< CRPCBindingHandleTrait > SmartRpcBinding;

// Smart handle to a cluster.
typedef CSmartResource<
    CHandleTrait<
          HCLUSTER
        , BOOL
        , CloseCluster
        , reinterpret_cast< HCLUSTER >( NULL )
        >
    > SmartClusterHandle;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterJoin
//
//  Description:
//      The CBaseClusterJoin class is a class that encapsulates the
//      action of add a node to a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterJoin : public CBaseClusterAddNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterJoin(
          CBCAInterface *       pbcaiInterfaceIn
        , const WCHAR *         pcszClusterNameIn
        , const WCHAR *         pcszClusterBindingStringIn
        , IClusCfgCredentials * pcccServiceAccountIn
        );

    // Default destructor.
    ~CBaseClusterJoin( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the NodeId of this node.
    virtual const WCHAR *
        PszGetNodeIdString( void ) const throw() { return m_strNodeId.PszData(); }

    // Set the NodeId of this node.
    void
        SetNodeIdString( const WCHAR * pcszNodeIdIn ) { m_strNodeId = pcszNodeIdIn; }

    // Get a handle to the cluster service account token.
    HANDLE
        HGetClusterServiceAccountToken( void ) const throw() { return m_satServiceAccountToken.HHandle(); }

    RPC_BINDING_HANDLE
        RbhGetJoinBindingHandle( void ) const throw() { return m_srbJoinBinding.HHandle(); }


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Join the cluster.
    void
        Commit( void );

    // Rollback a created cluster.
    void
        Rollback( void );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks( void ) const throw()
    {
        // The extra tick if for the "Join starting" notification.
        return BaseClass::UiGetMaxProgressTicks() + 1;
    }


private:
    // Private copy constructor to prevent copying.
    CBaseClusterJoin( const CBaseClusterJoin & );

    // Private assignment operator to prevent copying.
    CBaseClusterJoin & operator = ( const CBaseClusterJoin & );

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // The base class of this class
    typedef CBaseClusterAddNode BaseClass;

    // A smart handle to an account token.
    typedef CSmartResource< CHandleTrait< HANDLE, BOOL, CloseHandle > > SmartAccountToken;

    // A smart handle to an RPC string.
    typedef CSmartResource<
        CHandleTrait<
              LPWSTR *
            , RPC_STATUS
            , RpcStringFreeW
            , reinterpret_cast< LPWSTR * >( NULL )
            >
        >
        SmartRpcString;

    typedef CSmartGenericPtr< CPtrTrait< CClusSvcAccountConfig > > SmartAccountConfigPtr;


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Get a handle to a an account token. Note, this token is an impersonation token.
    HANDLE
        HGetAccountToken(
              IClusCfgCredentials & rcccAccountCredentials
            );

    // Check and see if this node can interoperate with the sponsor cluster.
    void
        CheckInteroperability( void );

    // Get a binding handle to the extrocluster join interface and store it.
    void
        InitializeJoinBinding( void );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Node Id of this node.
    CStr                            m_strNodeId;

    // Token for the cluster service account.
    SmartAccountToken               m_satServiceAccountToken;

    // Binding handle to the extrocluster join interface.
    SmartRpcBinding                 m_srbJoinBinding;

    // A smart pointer to a CClusSvcAccountConfig object.
    SmartAccountConfigPtr           m_spacAccountConfigAction;

}; //*** class CBaseClusterJoin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterjoin.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterJoin.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterJoin class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// For various RPC functions
#include <Rpcdce.h>

// The header file of this class.
#include "CBaseClusterJoin.h"

// For the CClusNetCreate action
#include "CClusNetCreate.h"

// For the CClusDiskJoin class
#include "CClusDiskJoin.h"

// For the CClusDBJoin action
#include "CClusDBJoin.h"

// For the CClusSvcCreate action
#include "CClusSvcCreate.h"

// For the CNodeConfig action
#include "CNodeConfig.h"

// For the CImpersonateUser class.
#include "CImpersonateUser.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::CBaseClusterJoin
//
//  Description:
//      Constructor of the CBaseClusterJoin class.
//
//      This function also stores the parameters that are required to add this
//      node to a cluster.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//      pcszClusterNameIn
//          Name of the cluster to be joined.
//
//      pcszClusterAccountNameIn
//      pcszClusterAccountPwdIn
//      pcszClusterAccountDomainIn
//          Specifies the account to be used as the cluster service account.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CConfigError
//          If the OS version is incorrect or if the installation state
//          of the cluster binaries is wrong.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterJoin::CBaseClusterJoin(
      CBCAInterface *       pbcaiInterfaceIn
    , const WCHAR *         pcszClusterNameIn
    , const WCHAR *         pcszClusterBindingStringIn
    , IClusCfgCredentials * pcccServiceAccountIn
    )
    : BaseClass(
            pbcaiInterfaceIn
          , pcszClusterNameIn
          , pcszClusterBindingStringIn
          , pcccServiceAccountIn
          , NULL
          )
{
    TraceFunc( "" );
    LogMsg( "[BC] The current cluster configuration task is: Add Nodes to Cluster." );

    if ( ( pcszClusterBindingStringIn == NULL ) || ( *pcszClusterBindingStringIn == L'\0'  ) )
    {
        LogMsg( "[BC] The cluster binding string is empty." );
        THROW_CONFIG_ERROR( E_INVALIDARG, IDS_ERROR_INVALID_CLUSTER_BINDINGSTRING );
    } // if: the cluster account is empty

    CStatusReport   srInitJoin(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Initializing_Cluster_Join
        , 0, 1
        , IDS_TASK_JOIN_INIT
        );

    // Send the next step of this status report.
    srInitJoin.SendNextStep( S_OK );


    // Create an object of the CClusSvcAccountConfig class and store a pointer to it.
    // This object will be used during Commit() of this action. This object is not
    // added to the action list below since the cluster service account has to be
    // configured before the sponsor cluster can be contacted.
    m_spacAccountConfigAction.Assign( new CClusSvcAccountConfig( this ) );
    if ( m_spacAccountConfigAction.FIsEmpty() )
    {
        LogMsg( "[BC] A memory allocation error occurred trying to configure the cluster service account (%d bytes). Throwing an exception", sizeof( CClusSvcAccountConfig ) );
        THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_JOIN_INIT );
    } // if: memory allocation failed


    //
    // Create a list of actions to be performed.
    // The order of appending actions is significant.
    //

    // Add the action to create the ClusNet service.
    RalGetActionList().AppendAction( new CClusNetCreate( this ) );

    // Add the action to create the ClusDisk service.
    RalGetActionList().AppendAction( new CClusDiskJoin( this ) );

    // Add the action to create the cluster database.
    RalGetActionList().AppendAction( new CClusDBJoin( this ) );

    // Add the action to perform miscellaneous tasks.
    RalGetActionList().AppendAction( new CNodeConfig( this ) );

    // Add the action to create the ClusSvc service.
    RalGetActionList().AppendAction( new CClusSvcCreate( this ) );


    // Indicate if rollback is possible or not.
    SetRollbackPossible( m_spacAccountConfigAction->FIsRollbackPossible() && RalGetActionList().FIsRollbackPossible() );

    // Indicate that this node should be added to a cluster during commit.
    SetAction( eCONFIG_ACTION_JOIN );

    // Send the last step of a status report.
    srInitJoin.SendNextStep( S_OK );

    LogMsg( "[BC] Initialization for adding nodes to the cluster complete." );

    TraceFuncExit();

} //*** CBaseClusterJoin::CBaseClusterJoin


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::~CBaseClusterJoin
//
//  Description:
//      Destructor of the CBaseClusterJoin class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterJoin::~CBaseClusterJoin() throw()
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CBaseClusterJoin::~CBaseClusterJoin()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::Commit
//
//  Description:
//      Add the node to the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::Commit()
{
    TraceFunc( "" );
    LogMsg( "[BC] Initiating to add the node to the cluster." );

    CStatusReport   srJoiningCluster(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Commit_Joining_Node
        , 0, 1
        , IDS_TASK_JOINING_CLUSTER
        );

    // Send the next step of this status report.
    srJoiningCluster.SendNextStep( S_OK );

    try
    {
        // First configure the cluster service account - this is required to get the account token.
        m_spacAccountConfigAction->Commit();


        // Get the cluster service account token and store it for later use.
        {
            // Get the account token.
            HANDLE hServiceAccountToken = HGetAccountToken( GetServiceAccountCredentials() );

            // Store it in a member variable. This variable automatically closes the token on destruction.
            m_satServiceAccountToken.Assign( hServiceAccountToken );

            LogMsg( "[BC] Got the cluster service account token." );
        }

        //
        // In the scope below, the cluster service account is impersonated, so that we can communicate with the
        // sponsor cluster
        //
        {
            DWORD sc;
            BOOL  fIsVersionCheckingDisabled;

            LogMsg( "[BC] Impersonating the cluster service account before communicating with the sponsor cluster." );

            // Impersonate the cluster service account, so that we can contact the sponsor cluster.
            // The impersonation is automatically ended when this object is destroyed.
            CImpersonateUser    ciuImpersonateClusterServiceAccount( HGetClusterServiceAccountToken() );

            // Check if version checking is disabled on the sponsor cluster.
            sc = ClRtlIsVersionCheckingDisabled( RStrGetClusterBindingString().PszData(), &fIsVersionCheckingDisabled );
            if ( sc != ERROR_SUCCESS )
            {
                LogMsg(
                      "[BC] Error %#08x occurred trying to determine if version checking is enabled on the '%ws' node with the '%ws' binding string."
                    , sc
                    , RStrGetClusterName().PszData()
                    , RStrGetClusterBindingString().PszData()
                    );

                LogMsg( "[BC] This is not a fatal error. Assuming that version checking is required." );

                fIsVersionCheckingDisabled = FALSE;
            } // if: an error occurred trying to determine if version checking is disabled or not

            // Store the result since it will be used later when we try to create the cluster service on this computer.
            SetVersionCheckingDisabled( fIsVersionCheckingDisabled != FALSE );

            if ( fIsVersionCheckingDisabled != FALSE )
            {
                LogMsg( "[BC] Cluster version checking is disabled on the sponsor node." );
            } // if: version checking is disabled
            else
            {
                // Make sure the this node can interoperate with the sponsor cluster. Note, this call uses
                // the cluster service account token got above.
                CheckInteroperability();
            } // else: version checking is enabled

            // Get a binding handle to the extrocluster join interface and store it.
            InitializeJoinBinding();
        } //

        // Call the base class commit routine. This commits the rest of the action list.
        BaseClass::Commit();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with one of the actions.

        LogMsg( "[BC] An error has occurred. The performed actions will be rolled back." );

        //
        // Rollback all committed actions in the reverse order.
        // Catch any exceptions thrown during rollback to make sure that there
        // is no collided unwind.
        //
        try
        {
            // If we are here, then it means that something has gone wrong in the try block above.
            // Of the two actions committed, only m_spacAccountConfigAction needs to be rolled back.
            // This is because, if BaseClass::Commit() was successful, we wouldn't be here!
            if ( m_spacAccountConfigAction->FIsCommitComplete() )
            {
                if ( m_spacAccountConfigAction->FIsRollbackPossible() )
                {
                    m_spacAccountConfigAction->Rollback();
                } // if: this action can be rolled back
                else
                {
                    LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Rollback was aborted." );
                } // else: this action cannot be rolled back
            } // if: the cluster service account has been configured
            else
            {
                LogMsg( "[BC] There is no need to cleanup this action since no part of it committed successfully." );
            } // else: the cluster service account has not been configured
        }
        catch( ... )
        {
            //
            // The rollback of the committed actions has failed.
            // There is nothing that we can do, is there?
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //
            HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ROLLBACK_FAILED ) );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. An error has occurred during rollback. Rollback will be aborted." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    // Send the last step of this status report.
    srJoiningCluster.SendNextStep( S_OK );

    TraceFuncExit();

} //*** CBaseClusterJoin::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::Rollback()
{
    TraceFunc( "" );

    // Rollback the actions.
    BaseClass::Rollback();

    // Rollback the configuration of the cluster service account.
    m_spacAccountConfigAction->Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CBaseClusterJoin::Rollback



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::HGetAccountToken
//
//  Description:
//      Gets a handle to an account token. This token is an impersonation
//      token.
//
//  Arguments:
//      rAccountCredentials
//          Specifies the account whose token is to be retrieved.
//
//  Return Value:
//      Handle to the desired token. This has to be closed using CloseHandle().
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
HANDLE
CBaseClusterJoin::HGetAccountToken(
      IClusCfgCredentials & rcccAccountCredentials
    )
{
    TraceFunc( "" );

    HANDLE   hAccountToken = NULL;
    CBString bstrAccountName;
    CBString bstrAccountDomain;
    CBString bstrAccountPassword;
    HRESULT  hr = S_OK;

    hr = THR( rcccAccountCredentials.GetCredentials( &bstrAccountName, &bstrAccountDomain, &bstrAccountPassword ) );
    TraceMemoryAddBSTR( static_cast< BSTR >( bstrAccountName ) );
    TraceMemoryAddBSTR( static_cast< BSTR >( bstrAccountDomain ) );
    TraceMemoryAddBSTR( static_cast< BSTR >( bstrAccountPassword ) );
    if ( FAILED( hr ) )
    {
        THROW_RUNTIME_ERROR( hr, IDS_ERROR_GET_ACCOUNT_TOKEN );
    }

    if (    LogonUser(
                  bstrAccountName
                , bstrAccountDomain
                , bstrAccountPassword
                , LOGON32_LOGON_SERVICE
                , LOGON32_PROVIDER_DEFAULT
                , &hAccountToken
                )
         == FALSE
       )
    {
        DWORD sc = TW32( GetLastError() );

        if ( ( bstrAccountName != NULL ) && ( bstrAccountDomain != NULL ) )
        {
            LogMsg( "[BC] Error %#08x occurred trying to get a token for the '%ws\\%ws' account. Throwing an exception.", sc, bstrAccountDomain, bstrAccountName );
        } // if: the account and domain strings are not NULL
        else
        {
            LogMsg( "[BC] Error %#08x occurred trying to get a token for the account. Throwing an exception.", sc );
        } // else: either the account or the domain name is NULL

        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( sc )
            , IDS_ERROR_GET_ACCOUNT_TOKEN
            );
    } // if: LogonUser() fails

    RETURN( hAccountToken );

} //*** CBaseClusterJoin::HGetAccountToken


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::CheckInteroperability
//
//  Description:
//      This functions checks to see if this node can interoperate with the
//      sponsor cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CConfigError
//          If this node cannot interoperate with the sponsor.
//
//  Remarks:
//      The thread calling this function should be running in the context of an
//      account that has access to the sponsor cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::CheckInteroperability( void )
{
    TraceFunc( "" );

    RPC_STATUS          rsError = RPC_S_OK;
    RPC_BINDING_HANDLE  rbhBindingHandle = NULL;
    SmartRpcBinding     srbBindingHandle;

    do
    {
        LPWSTR              pszBindingString = NULL;
        SmartRpcString      srsBindingString( &pszBindingString );

        // Create a string binding handle.
        {

            LogMsg(
                      L"[BC] Creating a binding string handle for cluster {%ws} with binding string {%ws} to check interoperability."
                    , RStrGetClusterName().PszData()
                    , RStrGetClusterBindingString().PszData()
                    );

            rsError = TW32( RpcStringBindingComposeW(
                          L"6e17aaa0-1a47-11d1-98bd-0000f875292e"
                        , L"ncadg_ip_udp"
                        , const_cast< LPWSTR >( RStrGetClusterBindingString().PszData() )
                        , NULL
                        , NULL
                        , &pszBindingString
                        ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to compose an RPC string binding." );
                break;
            } // if: RpcStringBindingComposeW() failed

            // No need to free pszBindingString - srsBindingString will automatically free it.
        }

        // Get the actual binding handle
        {

            rsError = TW32( RpcBindingFromStringBindingW( pszBindingString, &rbhBindingHandle ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to get an RPC binding handle from a string binding." );
                break;
            } // if: RpcBindingFromStringBindingW() failed

            // No need to free rbhBindingHandle - srbBindingHandle will automatically free it.
            srbBindingHandle.Assign( rbhBindingHandle );
        }

        // Resolve the binding handle
        {
            rsError = TW32( RpcEpResolveBinding( rbhBindingHandle, JoinVersion_v2_0_c_ifspec ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to resolve the RPC binding handle." );
                break;
            } // if: RpcEpResolveBinding() failed
        }

        // Set RPC security
        {
            rsError = TW32( RpcBindingSetAuthInfoW(
                              rbhBindingHandle
                            , NULL
                            , RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                            , RPC_C_AUTHN_WINNT
                            , NULL
                            , RPC_C_AUTHZ_NAME
                            ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to set security on the binding handle." );
                break;
            } // if: RpcBindingSetAuthInfoW() failed
        }
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( rsError != RPC_S_OK )
    {
        LogMsg(
              "[BC] Error %#08x occurred trying to connect to the sponsor cluster for an interoperability check with binding string {%ws}."
            , rsError
            , RStrGetClusterBindingString().PszData()
            );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( rsError ), IDS_ERROR_JOIN_CHECK_INTEROP );
    } // if: something has gone wrong

    LogMsg( L"[BC] Got RPC binding handle to check interoperability without any problems." );

    //
    // Get and verify the sponsor version
    //
    {
        DWORD                   dwSponsorNodeId;
        DWORD                   dwClusterHighestVersion;
        DWORD                   dwClusterLowestVersion;
        DWORD                   dwJoinStatus;
        DWORD                   sc;
        DWORD                   dwNodeHighestVersion = DwGetNodeHighestVersion();
        DWORD                   dwNodeLowestVersion = DwGetNodeLowestVersion();
        bool                    fVersionMismatch = false;


        //
        // From Whistler onwards, CsRpcGetJoinVersionData() will return a failure code in its last parameter
        // if the version of this node is not compatible with the sponsor version. Prior to this, the last
        // parameter always contained a success value and the cluster versions had to be compared subsequent to this
        // call. This will, however, still have to be done as long as interoperability with Win2K
        // is a requirement, since Win2K sponsors do not return an error in the last parameter.
        //

        sc = TW32( CsRpcGetJoinVersionData(
                              rbhBindingHandle
                            , 0
                            , dwNodeHighestVersion
                            , dwNodeLowestVersion
                            , &dwSponsorNodeId
                            , &dwClusterHighestVersion
                            , &dwClusterLowestVersion
                            , &dwJoinStatus
                            ) );

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred trying to verify if this node can interoperate with the sponsor cluster. Throwing an exception.", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_JOIN_CHECK_INTEROP );
        } // if: CsRpcGetJoinVersionData() failed

        LogMsg(
              "[BC] ( Node Highest, Node Lowest ) = ( %#08x, %#08x ), ( Cluster Highest, Cluster Lowest ) = ( %#08x, %#08x )."
            , dwNodeHighestVersion
            , dwNodeLowestVersion
            , dwClusterHighestVersion
            , dwClusterLowestVersion
            );

        if ( dwJoinStatus == ERROR_SUCCESS )
        {
            DWORD   dwClusterMajorVersion = CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion );

//            Assert( dwClusterMajorVersion > ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) );

            //
            //  Only want to add this node to clusters that are no more than one version back.
            //
            if ( dwClusterMajorVersion < ( CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION - 1 ) )
            {
                fVersionMismatch = true;
            } // if:
        } // if:  the join status was ok
        else
        {
            fVersionMismatch = true;
        } // else: adding this node to the cluster is not possible

        if ( fVersionMismatch )
        {
            LogMsg( "[BC] This node cannot interoperate with the sponsor cluster. Throwing an exception.", sc );
            THROW_CONFIG_ERROR( HRESULT_FROM_WIN32( TW32( ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE ) ), IDS_ERROR_JOIN_INCOMPAT_SPONSOR );
        } // if: there was a version mismatch
        else
        {
            LogMsg( "[BC] This node is compatible with the sponsor cluster." );
        } // else: this node can be added to the cluster
    }

    TraceFuncExit();

} //*** CBaseClusterJoin::CheckInteroperability


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterJoin::InitializeJoinBinding
//
//  Description:
//      Get a binding handle to the extrocluster join interface and store it.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//  Remarks:
//      The thread calling this function should be running in the context of an
//      account that has access to the sponsor cluster.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterJoin::InitializeJoinBinding( void )
{
    TraceFunc( "" );

    RPC_STATUS          rsError = RPC_S_OK;
    RPC_BINDING_HANDLE  rbhBindingHandle = NULL;

    do
    {
        LPWSTR              pszBindingString = NULL;
        SmartRpcString      srsBindingString( &pszBindingString );

        // Create a string binding handle.
        {
            LogMsg(
                  L"[BC] Creating a string binding handle for cluster {%ws} using binding string {%ws} for extro cluster join."
                , RStrGetClusterName().PszData()
                , RStrGetClusterBindingString().PszData()
                );

            rsError = TW32( RpcStringBindingComposeW(
                                  L"ffe561b8-bf15-11cf-8c5e-08002bb49649"
                                , L"ncadg_ip_udp"
                                , const_cast< LPWSTR >( RStrGetClusterBindingString().PszData() )
                                , NULL
                                , NULL
                                , &pszBindingString
                                ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BCAn error occurred trying to compose an RPC string binding." );
                break;
            } // if: RpcStringBindingComposeW() failed

            // No need to free pszBindingString - srsBindingString will automatically free it.
        }

        // Get the actual binding handle
        {

            rsError = TW32( RpcBindingFromStringBindingW( pszBindingString, &rbhBindingHandle ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to get an RPC binding handle from a string binding." );
                break;
            } // if: RpcBindingFromStringBindingW() failed

            // No need to free rbhBindingHandle - m_srbJoinBinding will automatically free it.
            m_srbJoinBinding.Assign( rbhBindingHandle );
        }

        // Resolve the binding handle
        {
            rsError = TW32( RpcEpResolveBinding( rbhBindingHandle, ExtroCluster_v2_0_c_ifspec ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to resolve the RPC binding handle." );
                break;
            } // if: RpcEpResolveBinding() failed
        }

        // Set RPC security
        {
            rsError = TW32( RpcBindingSetAuthInfoW(
                                  rbhBindingHandle
                                , NULL
                                , RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                , RPC_C_AUTHN_WINNT
                                , NULL
                                , RPC_C_AUTHZ_NAME
                                ) );
            if ( rsError != RPC_S_OK )
            {
                LogMsg( L"[BC] An error occurred trying to set security on the binding handle." );
                break;
            } // if: RpcBindingSetAuthInfoW() failed
        }

        // Make sure that the server is who it claims to be.
        rsError = TW32( TestRPCSecurity( rbhBindingHandle ) );
        if ( rsError != RPC_S_OK )
        {
            LogMsg( L"[BC] An error occurred trying to test RPC security." );
            break;
        } // if: TestRPCSecurity() failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( rsError != RPC_S_OK )
    {
        LogMsg( "[BC] Error %#08x occurred trying to get a handle to the extrocluster join interface.", rsError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( rsError ), IDS_ERROR_CLUSTER_JOIN_INIT );
    } // if: something has gone wrong

    LogMsg( L"[BC] Got RPC binding handle for extro cluster join without any problems." );

    TraceFuncExit();

} //*** CBaseClusterJoin::InitializeJoinBinding
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterform.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterForm.cpp
//
//  Description:
//      Contains the definition of the CBaseClusterForm class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header file of this class.
#include "CBaseClusterForm.h"

// For the CClusSvcAccountConfig action
#include "CClusSvcAccountConfig.h"

// For the CClusNetCreate action
#include "CClusNetCreate.h"

// For the CClusDiskForm action
#include "CClusDiskForm.h"

// For the CClusDBForm action
#include "CClusDBForm.h"

// For the CClusSvcCreate action
#include "CClusSvcCreate.h"

// For the CNodeConfig action
#include "CNodeConfig.h"


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// The minimum amount of free space in bytes, required by the
// localquorum resource (5 Mb)
#define LOCALQUORUM_MIN_FREE_DISK_SPACE 5242880

// Name of the file system required by the local quorum resource
#define LOCALQUORUM_FILE_SYSTEM L"NTFS"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterForm::CBaseClusterForm
//
//  Description:
//      Constructor of the CBaseClusterForm class.
//
//      This function also stores the parameters that are required for
//      creating a cluster.
//
//  Arguments:
//      pbcaiInterfaceIn
//          Pointer to the interface class for this library.
//
//      pszClusterNameIn
//          Name of the cluster to be formed.
//
//      pcccServiceAccountIn
//          Specifies the account to be used as the cluster service account.
//
//      dwClusterIPAddressIn
//      dwClusterIPSubnetMaskIn
//      pszClusterIPNetworkIn
//          Specifies the IP address and network of the cluster IP address.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CConfigError
//          If the OS version is incorrect or if the installation state
//          of the cluster binaries is wrong.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterForm::CBaseClusterForm(
      CBCAInterface *       pbcaiInterfaceIn
    , const WCHAR *         pcszClusterNameIn
    , const WCHAR *         pszClusterBindingStringIn
    , IClusCfgCredentials * pcccServiceAccountIn
    , DWORD                 dwClusterIPAddressIn
    , DWORD                 dwClusterIPSubnetMaskIn
    , const WCHAR *         pszClusterIPNetworkIn
    )
    : BaseClass(
            pbcaiInterfaceIn
          , pcszClusterNameIn
          , pszClusterBindingStringIn
          , pcccServiceAccountIn
          , dwClusterIPAddressIn
          )
    , m_dwClusterIPAddress( dwClusterIPAddressIn )
    , m_dwClusterIPSubnetMask( dwClusterIPSubnetMaskIn )
    , m_strClusterIPNetwork( pszClusterIPNetworkIn )

{
    TraceFunc( "" );
    LogMsg( "[BC] The current cluster configuration task is: Create a Cluster." );

    CStatusReport   srInitForm(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Initializing_Cluster_Form
        , 0, 1
        , IDS_TASK_FORM_INIT
        );

    // Send the next step of this status report.
    srInitForm.SendNextStep( S_OK );

    //
    // Write parameters to log file.
    //
    LogMsg(
          "[BC] Cluster IP Address       => %d.%d.%d.%d"
        , ( m_dwClusterIPAddress & 0x000000FF )
        , ( m_dwClusterIPAddress & 0x0000FF00 ) >> 8
        , ( m_dwClusterIPAddress & 0x00FF0000 ) >> 16
        , ( m_dwClusterIPAddress & 0xFF000000 ) >> 24
        );

    LogMsg(
          "[BC] Subnet Mask              => %d.%d.%d.%d"
        , ( m_dwClusterIPSubnetMask & 0x000000FF )
        , ( m_dwClusterIPSubnetMask & 0x0000FF00 ) >> 8
        , ( m_dwClusterIPSubnetMask & 0x00FF0000 ) >> 16
        , ( m_dwClusterIPSubnetMask & 0xFF000000 ) >> 24
        );

    LogMsg( "[BC] Cluster IP Network name => '%s'", m_strClusterIPNetwork.PszData() );


    //
    // Perform a sanity check on the parameters used by this class
    //
    if ( ( pszClusterIPNetworkIn == NULL ) || ( *pszClusterIPNetworkIn == L'\0'  ) )
    {
        LogMsg( "[BC] The cluster IP Network name is invalid. Throwing an exception." );
        THROW_CONFIG_ERROR( THR( E_INVALIDARG ), IDS_ERROR_INVALID_IP_NET );
    } // if: the cluster IP network name is empty


    //
    // Make sure that there is enough free space under the cluster directory.
    // The quorum logs for the localquorum resource will be under this directory.
    //
    {
        BOOL            fSuccess;
        ULARGE_INTEGER  uliFreeBytesAvailToUser;
        ULARGE_INTEGER  uliTotalBytes;
        ULARGE_INTEGER  uliTotalFree;
        ULARGE_INTEGER  uliRequired;

        uliRequired.QuadPart = LOCALQUORUM_MIN_FREE_DISK_SPACE;

        fSuccess = GetDiskFreeSpaceEx(
              RStrGetClusterInstallDirectory().PszData()
            , &uliFreeBytesAvailToUser
            , &uliTotalBytes
            , &uliTotalFree
            );

        if ( fSuccess == 0 )
        {
            DWORD sc = TW32( GetLastError() );

            LogMsg( "[BC] Error %#08x occurred trying to get free disk space. Throwing an exception.", sc );

            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( sc )
                , IDS_ERROR_GETTING_FREE_DISK_SPACE
                );
        } // if: GetDiskFreeSpaceEx failed

        LogMsg(
              "[BC] Free space required = %#x%08x bytes. Available = %#x%08x bytes."
            , uliRequired.HighPart
            , uliRequired.LowPart
            , uliFreeBytesAvailToUser.HighPart
            , uliFreeBytesAvailToUser.LowPart
            );

        if ( uliFreeBytesAvailToUser.QuadPart < uliRequired.QuadPart )
        {
            LogMsg( "[BC] There isn't enough free space for the Local Quorum resource. The cluster create operation cannot proceed (throwing an exception)." );

            THROW_CONFIG_ERROR(
                  HRESULT_FROM_WIN32( THR( ERROR_DISK_FULL ) )
                , IDS_ERROR_INSUFFICIENT_DISK_SPACE
                );
        } // if: there isn't enough free space for localquorum.

        LogMsg( "[BC] There is enough free space for the Local Quorum resource. The cluster create operation can proceed." );
    }

/*
//
// KB: Vij Vasu (VVasu) 07-SEP-2000. Localquorum no longer needs NTFS disks
// The code below has been commented out since it is no longer required that
// localquorum resources use NTFS disks. This was confirmed by SunitaS.
//

    //
    // Make sure that the drive on which the cluster binaries are installed has NTFS
    // on it. This is required by the localquorum resource.
    //
    {
        WCHAR   szVolumePathName[ MAX_PATH ];
        WCHAR   szFileSystemName[ MAX_PATH ];
        BOOL    fSuccess;

        fSuccess = GetVolumePathName(
              RStrGetClusterInstallDirectory().PszData()
            , szVolumePathName
            , ARRAYSIZE( szVolumePathName )
            );

        if ( fSuccess == 0 )
        {
            DWORD sc = TW32( GetLastError() );

            LogMsg( "[BC] Error %#08x occurred trying to get file system type. The cluster create operation cannot proceed (throwing an exception).", sc );

            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( sc )
                , IDS_ERROR_GETTING_FILE_SYSTEM
                );
        } // if: GetVolumePathName failed

        LogMsg( "[BC] The volume path name of the disk on which the cluster binaries reside is '%ws'.", szVolumePathName );

        fSuccess = GetVolumeInformationW(
                      szVolumePathName                                                  // root directory
                    , NULL                                                              // volume name buffer
                    , 0                                                                 // length of name buffer
                    , NULL                                                              // volume serial number
                    , NULL                                                              // maximum file name length
                    , NULL                                                              // file system options
                    , szFileSystemName                                                  // file system name buffer
                    , ARRAYSIZE( szFileSystemName )                                     // length of file system name buffer
                    );

        if ( fSuccess == 0 )
        {
            DWORD sc = TW32( GetLastError() );

            LogMsg( "[BC] Error %#08x occurred trying to get file system type. The cluster create operation cannot proceed (throwing an exception).", sc );

            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( sc )
                , IDS_ERROR_GETTING_FILE_SYSTEM
                );
        } // if: GetVolumeInformation failed

        LogMsg(
              "[BC] The file system on '%ws' is '%ws'. Required file system is '%s'."
            , szVolumePathName
            , szFileSystemName
            , LOCALQUORUM_FILE_SYSTEM
            );


        if ( NStringCchCompareNoCase( szFileSystemName, RTL_NUMBER_OF( szFileSystemName ), LOCALQUORUM_FILE_SYSTEM, RTL_NUMBER_OF( LOCALQUORUM_FILE_SYSTEM ) ) != 0 )
        {
            LogMsg( "[BC] LocalQuorum resource cannot be created on non-NTFS disk '%ws'. The cluster create operation cannot proceed (throwing an exception).", szVolumePathName );

            // MUSTDO - must define proper HRESULT for this error. ( Vvasu - 10 Mar 2000 )
            THROW_CONFIG_ERROR(
                  HRESULT_FROM_WIN32( TW32( ERROR_UNRECOGNIZED_MEDIA ) )
                , IDS_ERROR_INCORRECT_INSTALL_STATE
                );
        } // if: the file system is not correct.

        LogMsg( "[BC] LocalQuorum resource will be created on disk '%ws'. The cluster create operation can proceed.", szVolumePathName );
    }
*/

    //
    // Create a list of actions to be performed.
    // The order of appending actions is significant.
    //

    // Add the action to configure the cluster service account.
    RalGetActionList().AppendAction( new CClusSvcAccountConfig( this ) );

    // Add the action to create the ClusNet service.
    RalGetActionList().AppendAction( new CClusNetCreate( this ) );

    // Add the action to create the ClusDisk service.
    RalGetActionList().AppendAction( new CClusDiskForm( this ) );

    // Add the action to create the cluster database.
    RalGetActionList().AppendAction( new CClusDBForm( this ) );

    // Add the action to perform miscellaneous tasks.
    RalGetActionList().AppendAction( new CNodeConfig( this ) );

    // Add the action to create the ClusSvc service.
    RalGetActionList().AppendAction( new CClusSvcCreate( this ) );


    // Indicate if rollback is possible or not.
    SetRollbackPossible( RalGetActionList().FIsRollbackPossible() );

    // Indicate that a cluster should be formed during commit.
    SetAction( eCONFIG_ACTION_FORM );

    // Send the last step of a status report.
    srInitForm.SendNextStep( S_OK );

    LogMsg( "[BC] Initialization for creating a cluster has completed." );

    TraceFuncExit();

} //*** CBaseClusterForm::CBaseClusterForm


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterForm::~CBaseClusterForm
//
//  Description:
//      Destructor of the CBaseClusterForm class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusterForm::~CBaseClusterForm( void ) throw()
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CBaseClusterForm::~CBaseClusterForm


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusterForm::Commit
//
//  Description:
//      Create the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterForm::Commit( void )
{
    TraceFunc( "" );

    CStatusReport srFormingCluster(
          PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Commit_Forming_Node
        , 0, 1
        , IDS_TASK_FORMING_CLUSTER
        );

    LogMsg( "[BC] Initiating a cluster create operation." );

    // Send the next step of this status report.
    srFormingCluster.SendNextStep( S_OK );

    // Call the base class commit routine. This commits the action list.
    BaseClass::Commit();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    // Send the last step of this status report.
    srFormingCluster.SendLastStep( S_OK );

    TraceFuncExit();

} //*** CBaseClusterForm::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CBaseClusterForm::Rollback
//
//  Description:
//      Performs the rolls back of the action committed by this object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by functions called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBaseClusterForm::Rollback( void )
{
    TraceFunc( "" );

    // Rollback the actions.
    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CBaseClusterForm::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbaseclusterform.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CBaseClusterForm.h
//
//  Description:
//      Header file for CBaseClusterForm class.
//
//      The CBaseClusterForm class is a class that encapsulates the
//      formation of a cluster.
//
//  Implementation Files:
//      CBaseClusterForm.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the base class of this class.
#include "CBaseClusterAddNode.h"

// For ClusterMinNodeIdString
#include <clusdef.h>

// For the CStr class.
#include "CStr.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusterForm
//
//  Description:
//      The CBaseClusterForm class is a class that encapsulates the
//      formation of a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusterForm : public CBaseClusterAddNode
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CBaseClusterForm(
          CBCAInterface *       pbcaiInterfaceIn
        , const WCHAR *         pcszClusterNameIn
        , const WCHAR *         pcszClusterBindingStringIn
        , IClusCfgCredentials * pcccServiceAccountIn
        , DWORD                 dwClusterIPAddressIn
        , DWORD                 dwClusterIPSubnetMaskIn
        , const WCHAR *         pszClusterIPNetworkIn
        );

    // Default destructor.
    ~CBaseClusterForm( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Public accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the cluster IP address.
    DWORD DwGetIPAddress( void ) const throw() { return m_dwClusterIPAddress; }

    // Get the cluster IP subnet mask.
    DWORD DwGetIPSubnetMask( void ) const throw() { return m_dwClusterIPSubnetMask; }

    // Get the network used for the cluster IP address
    const CStr & RStrGetClusterIPNetwork( void ) const throw() { return m_strClusterIPNetwork; }

    // Get the NodeId of this node.
    virtual const WCHAR * PszGetNodeIdString( void ) const throw() { return ClusterMinNodeIdString; }


    //////////////////////////////////////////////////////////////////////////
    // Public member functions
    //////////////////////////////////////////////////////////////////////////

    // Form the cluster.
    void Commit( void );

    // Rollback a created cluster.
    void Rollback( void );

    // Returns the number of progress messages that this action will send.
    UINT UiGetMaxProgressTicks() const throw()
    {
        // The extra tick if for the "Form starting" notification.
        return BaseClass::UiGetMaxProgressTicks() + 1;
    }


private:
    // Private copy constructor to prevent copying.
    CBaseClusterForm( const CBaseClusterForm & );

    // Private assignment operator to prevent copying.
    CBaseClusterForm & operator = ( const CBaseClusterForm & );

    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CBaseClusterAddNode BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Cluster IP address and network information.
    DWORD                   m_dwClusterIPAddress;
    DWORD                   m_dwClusterIPSubnetMask;
    CStr                    m_strClusterIPNetwork;

}; //*** class CBaseClusterForm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbcainterface.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CBCAInterface.cpp
//
//  Description:
//      This file contains the implementation of the CBCAInterface
//      class.
//
//  Maintained By:
//      David Potter    (DavidP)    12-JUN-2001
//      Vij Vasu        (VVasu)     07-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "Pch.h"

// The header file for this class
#include "CBCAInterface.h"

// Needed by Dll.h
#include <CFactory.h>

// For g_cObjects
#include <Dll.h>

// For the CBaseClusterForm class
#include "CBaseClusterForm.h"

// For the CBaseClusterJoin class
#include "CBaseClusterJoin.h"

// For the CBaseClusterCleanup class
#include "CBaseClusterCleanup.h"

// For the exception classes
#include "Exceptions.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CBCAInterface" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::CBCAInterface
//
//  Description:
//      Constructor of the CBCAInterface class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBCAInterface::CBCAInterface( void )
    : m_cRef( 1 )
    , m_fCommitComplete( false )
    , m_fRollbackPossible( false )
    , m_lcid( LOCALE_SYSTEM_DEFAULT )
    , m_fCallbackSupported( false )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CBCAInterface::CBCAInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::~CBCAInterface
//
//  Description:
//      Destructor of the CBCAInterface class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBCAInterface::~CBCAInterface( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CBCAInterface::~CBCAInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CBCAInterface::S_HrCreateInstance
//
//  Description:
//      Creates a CBCAInterface instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    CBCAInterface * pbcaInterface = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    pbcaInterface = new CBCAInterface();
    if ( pbcaInterface == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pbcaInterface->QueryInterface(
                  IID_IUnknown
                , reinterpret_cast< void ** >( ppunkOut )
                )
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    if ( pbcaInterface != NULL )
    {
        pbcaInterface->Release();
    }

    HRETURN( hr );

} //*** CBCAInterface::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBCAInterface::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CBCAInterface::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBCAInterface::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    CRETURN( cRef );

} //*** CBCAInterface::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          If ppvOut is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::QueryInterface(
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgBaseCluster * >( this );
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgBaseCluster ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgBaseCluster, this, 0 );
    } // else if:
    else if ( IsEqualIID( riidIn, IID_IClusCfgInitialize ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
    } // else if:
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef( );
    } // if: success

Cleanup:

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CBCAInterface::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );

    HRESULT hrRetVal = S_OK;

    // Store the locale id in the member variable.
    m_lcid = lcidIn;

    // Indicate that SendStatusReports will not be supported unless a non-
    // NULL callback interface pointer was specified.  This is done in
    // the constructor as well, but is also done here since this method
    // could be called multiple times.
    SetCallbackSupported( false );

    if ( punkCallbackIn == NULL )
    {
        LogMsg( "[BC] No notifications will be sent." );
        goto Cleanup;
    }

    TraceFlow( "The callback pointer is not NULL." );

    // Try and get the "normal" callback interface.
    hrRetVal = THR( m_spcbCallback.HrQueryAndAssign( punkCallbackIn ) );

    if ( FAILED( hrRetVal ) )
    {
        LogMsg( "[BC] An error occurred (0x%#08x) trying to get a pointer to the callback interface. No notifications will be sent.", hrRetVal );
        goto Cleanup;
    } // if: we could not get the callback interface

    SetCallbackSupported( true );

    LogMsg( "[BC] Progress messages will be sent." );

Cleanup:

    HRETURN( hrRetVal );

} //*** CBCAInterface::Initialize


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SetCreate
//
//  Description:
//      Indicate that a cluster is to be created with this computer as the first node.
//
//  Arguments:
//      pcszClusterNameIn
//          Name of the cluster to be formed.
//
//      pcccServiceAccountIn
//          Information about the cluster service account.
//
//      dwClusterIPAddressIn
//      dwClusterIPSubnetMaskIn
//      pcszClusterIPNetworkIn
//          Information about the cluster IP address
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::SetCreate(
      const WCHAR *         pcszClusterNameIn
    , const WCHAR *         pcszClusterBindingStringIn
    , IClusCfgCredentials * pcccServiceAccountIn
    , const DWORD           dwClusterIPAddressIn
    , const DWORD           dwClusterIPSubnetMaskIn
    , const WCHAR *         pcszClusterIPNetworkIn
    )
{
    TraceFunc( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD sc = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        LogMsg( "[BC] Error 0x%#08x occurred trying to set the thread locale.", sc );

    } // if: SetThreadLocale() failed

    try
    {
        LogMsg( "[BC] Initializing a cluster create operation." );

        // Reset these state variables, to account for exceptions.
        SetRollbackPossible( false );

        // Setting this to true prevents Commit from being called while we are
        // in this routine or if this routine doesn't complete successfully.
        SetCommitCompleted( true );

        {
            // Create a CBaseClusterForm object and assign it to a smart pointer.
            SmartBCAPointer spbcaTemp(
                new CBaseClusterForm(
                      this
                    , pcszClusterNameIn
                    , pcszClusterBindingStringIn
                    , pcccServiceAccountIn
                    , dwClusterIPAddressIn
                    , dwClusterIPSubnetMaskIn
                    , pcszClusterIPNetworkIn
                    )
                );

            if ( spbcaTemp.FIsEmpty() )
            {
                LogMsg( "Could not initialize the cluster create operation. A memory allocation failure occurred." );
                THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_FORM_INIT );
            } // if: the memory allocation failed.

            //
            // If the creation succeeded store the pointer in a member variable for
            // use during commit.
            //
            m_spbcaCurrentAction = spbcaTemp;
        }

        LogMsg( "[BC] Initialization completed. A cluster will be created on commit." );

        // Indicate if rollback is possible.
        SetRollbackPossible( m_spbcaCurrentAction->FIsRollbackPossible() );

        // Indicate that this action has not been committed.
        SetCommitCompleted( false );

    } // try: to initialize a cluster create operation
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

    HRETURN( hrRetVal );

} //*** CBCAInterface::SetCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SetAdd
//
//  Description:
//      Indicate that this computer should be added to a cluster.
//
//  Arguments:
//      pcszClusterNameIn
//          Name of the cluster to add nodes to.
//
//      pcccServiceAccountIn
//          Information about the cluster service account.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::SetAdd(
      const WCHAR *         pcszClusterNameIn
    , const WCHAR *         pcszClusterBindingStringIn
    , IClusCfgCredentials * pcccServiceAccountIn
    )
{
    TraceFunc( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD sc = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        LogMsg( "[BC] Error 0x%#08x occurred trying to set the thread locale.", sc );

    } // if: SetThreadLocale() failed

    try
    {
        LogMsg( "[BC] Initializing add nodes to cluster." );

        // Reset these state variables, to account for exceptions.
        SetRollbackPossible( false );

        // Setting this to true prevents Commit from being called while we are
        // in this routine or if this routine doesn't complete successfully.
        SetCommitCompleted( true );

        {
            // Create a CBaseClusterJoin object and assign it to a smart pointer.
            SmartBCAPointer spbcaTemp(
                new CBaseClusterJoin(
                      this
                    , pcszClusterNameIn
                    , pcszClusterBindingStringIn
                    , pcccServiceAccountIn
                    )
                );

            if ( spbcaTemp.FIsEmpty() )
            {
                LogMsg( "[BC] Could not initialize cluster add nodes. A memory allocation failure occurred." );
                THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_JOIN_INIT );
            } // if: the memory allocation failed.

            //
            // If the creation succeeded store the pointer in a member variable for
            // use during commit.
            //
            m_spbcaCurrentAction = spbcaTemp;
        }

        LogMsg( "[BC] Initialization completed. This computer will be added to a cluster on commit." );

        // Indicate if rollback is possible.
        SetRollbackPossible( m_spbcaCurrentAction->FIsRollbackPossible() );

        // Indicate that this action has not been committed.
        SetCommitCompleted( false );

    } // try: to initialize for adding nodes to a cluster
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

    HRETURN( hrRetVal );

} //*** CBCAInterface::SetAdd


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SetCleanup
//
//  Description:
//      Indicate that this node needs to be cleaned up. The ClusSvc service
//      should not be running when this action is committed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::SetCleanup( void )
{
    TraceFunc( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD sc = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        LogMsg( "[BC] Error 0x%#08x occurred trying to set the thread locale.", sc );

    } // if: SetThreadLocale() failed

    try
    {
        LogMsg( "[BC] Initializing node clean up." );

        // Reset these state variables, to account for exceptions.
        SetRollbackPossible( false );

        // Setting this to true prevents Commit from being called while we are
        // in this routine or if this routine doesn't complete successfully.
        SetCommitCompleted( true );

        {
            // Create a CBaseClusterCleanup object and assign it to a smart pointer.
            SmartBCAPointer spbcaTemp( new CBaseClusterCleanup( this ) );

            if ( spbcaTemp.FIsEmpty() )
            {
                LogMsg( "[BC] Could not initialize node clean up. A memory allocation failure occurred. Throwing an exception" );
                THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSTER_CLEANUP_INIT );
            } // if: the memory allocation failed.

            //
            // If the creation succeeded store the pointer in a member variable for
            // use during commit.
            //
            m_spbcaCurrentAction = spbcaTemp;
        }

        LogMsg( "[BC] Initialization completed. This node will be cleaned up on commit." );

        // Indicate if rollback is possible.
        SetRollbackPossible( m_spbcaCurrentAction->FIsRollbackPossible() );

        // Indicate that this action has not been committed.
        SetCommitCompleted( false );

    } // try: to initialize node clean up
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

    HRETURN( hrRetVal );

} //*** CBCAInterface::SetCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::Commit
//
//  Description:
//      Perform the action indicated by a previous call to one of the SetXXX
//      routines.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      HRESULT_FROM_WIN32( ERROR_CLUSCFG_ALREADY_COMMITTED )
//          If this commit has already been performed.
//
//      E_INVALIDARG
//          If no action has been set using a SetXXX call.
//
//      Other HRESULTs
//          If the call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::Commit( void )
{
    TraceFunc( "[IClusCfgBaseCluster]" );

    HRESULT hrRetVal = S_OK;

    // Set the thread locale.
    if ( SetThreadLocale( m_lcid ) == FALSE )
    {
        DWORD sc = TW32( GetLastError() );

        // If SetThreadLocale() fails, do not abort. Just log the error.
        LogMsg( "[BC] Error 0x%#08x occurred trying to set the thread locale.", sc );

    } // if: SetThreadLocale() failed

    // Has this action already been committed?
    if ( FIsCommitComplete() )
    {
        SendStatusReport(   
                              TASKID_Major_Configure_Cluster_Services
                            , TASKID_Minor_Commit_Already_Complete
                            , 0
                            , 1
                            , 1
                            , HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ALREADY_COMMITTED ) )
                            , IDS_ERROR_COMMIT_ALREADY_COMPLETE
                            , true
                        );
 
        LogMsg( "[BC] The desired cluster configuration has already been performed." );
        hrRetVal = HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ALREADY_COMMITTED ) ); 
        goto Cleanup;
    } // if: already committed

    // Check if the arguments to commit have been set.
    if ( m_spbcaCurrentAction.FIsEmpty() )
    {
        LogMsg( "[BC] Commit was called when an operation has not been specified." );
        hrRetVal = THR( E_INVALIDARG );    // BUGBUG: 29-JAN-2001 DavidP  Replace E_INVALIDARG
        goto Cleanup;
    } // if: the pointer to the action to be committed is NULL

    LogMsg( "[BC] About to perform the desired cluster configuration." );

    // Commit the desired action.
    try
    {
        m_spbcaCurrentAction->Commit();
        LogMsg( "[BC] Cluster configuration completed successfully." );

        // If we are here, then everything has gone well.
        SetCommitCompleted( true );

    } // try: to commit the desired action.
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

Cleanup:

    HRETURN( hrRetVal );

} //*** CBCAInterface::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CBCAInterface::Rollback( void )
//
//  Description:
//      Rollback a committed configuration.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      E_PENDING
//          If this action has not yet been committed successfully.
//
//      HRESULT_FROM_WIN32( ERROR_CLUSCFG_ROLLBACK_FAILED )
//          If this action cannot be rolled back.
//
//      E_INVALIDARG
//          If no action has been set using a SetXXX call.
//
//      Other HRESULTs
//          If the call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBCAInterface::Rollback( void )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hrRetVal = S_OK;

    // Check if this action list has completed successfully.
    if ( ! FIsCommitComplete() )
    {
        // Cannot rollback an incomplete action.
        SendStatusReport(   
                              TASKID_Major_Configure_Cluster_Services
                            , TASKID_Minor_Rollback_Failed_Incomplete_Commit
                            , 0
                            , 1
                            , 1
                            , E_PENDING
                            , IDS_ERROR_ROLLBACK_FAILED_INCOMPLETE_COMMIT
                            , true
                        );

        LogMsg( "[BC] Cannot rollback - action not yet committed." );
        hrRetVal = THR( E_PENDING );
        goto Cleanup;

    } // if: this action was not completed successfully

    // Check if this action can be rolled back.
    if ( ! FIsRollbackPossible() )
    {
        // Cannot rollback an incompleted action.
        SendStatusReport(   
                              TASKID_Major_Configure_Cluster_Services
                            , TASKID_Minor_Rollback_Not_Possible
                            , 0
                            , 1
                            , 1
                            , HRESULT_FROM_WIN32( ERROR_CLUSCFG_ROLLBACK_FAILED )
                            , IDS_ERROR_ROLLBACK_NOT_POSSIBLE
                            , true
                        );

        LogMsg( "[BC] This action cannot be rolled back." ); // BUGBUG: 29-JAN-2001 DavidP  Why?
        hrRetVal = HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ROLLBACK_FAILED ) );
        goto Cleanup;

    } // if: this action was not completed successfully

    // Check if the arguments to rollback have been set.
    if ( m_spbcaCurrentAction.FIsEmpty() )
    {
        LogMsg( "[BC] Rollback was called when an operation has not been specified." );
        hrRetVal = THR( E_INVALIDARG );    // BUGBUG: 29-JAN-2001 DavidP  Replace E_INVALIDARG
        goto Cleanup;
    } // if: the pointer to the action to be committed is NULL


    LogMsg( "[BC] About to rollback the cluster configuration just committed." );

    // Commit the desired action.
    try
    {
        m_spbcaCurrentAction->Rollback();
        LogMsg( "[BC] Cluster configuration rolled back." );

        // If we are here, then everything has gone well.
        SetCommitCompleted( false );

    } // try: to rollback the desired action.
    catch( CAssert & raExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( raExceptionObject ) );

    } // catch( CAssert & )
    catch( CExceptionWithString & resExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( resExceptionObject ) );

    } // catch( CExceptionWithString & )
    catch( CException & reExceptionObject )
    {
        // Process the exception.
        hrRetVal = THR( HrProcessException( reExceptionObject ) );

    } // catch( CException &  )
    catch( ... )
    {
        // Catch everything. Do not let any exceptions pass out of this function.
        hrRetVal = THR( HrProcessException() );
    } // catch all

Cleanup:

    HRETURN( hrRetVal );

} //*** CBCAInterface::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SendStatusReport
//
//  Description:
//      Send a progress notification [ string id overload ].
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      uiDescriptionStringIdIn
//          String ID of the description of the notification.
//
//      fIsAbortAllowedIn
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAbortException
//          If the configuration was aborted.
//
//  Remarks:
//      In the current implementation, IClusCfgCallback::SendStatusReport
//      returns E_ABORT to indicate that the user wants to abort
//      the cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::SendStatusReport(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , ULONG           ulCurrentIn
    , HRESULT         hrStatusIn
    , UINT            uiDescriptionStringIdIn
    , bool            fIsAbortAllowedIn         // = true
    )
{
    TraceFunc( "uiDescriptionStringIdIn" );

    if ( FIsCallbackSupported() )
    {
        CStr strDescription;

        // Lookup the string using the string Id.
        strDescription.LoadString( g_hInstance, uiDescriptionStringIdIn );

        // Send progress notification ( call the overloaded function )
        SendStatusReport(
              clsidTaskMajorIn
            , clsidTaskMinorIn
            , ulMinIn
            , ulMaxIn
            , ulCurrentIn
            , hrStatusIn
            , strDescription.PszData()
            , fIsAbortAllowedIn
            );
    } // if: callbacks are supported
    else
    {
        LogMsg( "[BC] Callbacks are not supported. No status report will be sent." );
    } // else: callbacks are not supported

    TraceFuncExit();

} //*** CBCAInterface::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SendStatusReport
//
//  Description:
//      Send a progress notification [ string id & REF string id overload ].
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      uiDescriptionStringIdIn
//          String ID of the description of the notification.
//
//      uiDescriptionRefStringIdIn
//          REF String ID of the description of the notification.
//
//      fIsAbortAllowedIn
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAbortException
//          If the configuration was aborted.
//
//  Remarks:
//      In the current implementation, IClusCfgCallback::SendStatusReport
//      returns E_ABORT to indicate that the user wants to abort
//      the cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::SendStatusReport(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , ULONG           ulCurrentIn
    , HRESULT         hrStatusIn
    , UINT            uiDescriptionStringIdIn
    , UINT            uiDescriptionRefStringIdIn
    , bool            fIsAbortAllowedIn         // = true
    )
{
    TraceFunc( "uiDescriptionStringIdIn" );

    if ( FIsCallbackSupported() )
    {
        CStr strDescription;

        // Lookup the string using the string Id.
        strDescription.LoadString( g_hInstance, uiDescriptionStringIdIn );

        if ( uiDescriptionRefStringIdIn == 0 )
        {
            // Send progress notification ( call the overloaded function )
            SendStatusReport(
                  clsidTaskMajorIn
                , clsidTaskMinorIn
                , ulMinIn
                , ulMaxIn
                , ulCurrentIn
                , hrStatusIn
                , strDescription.PszData()
                , fIsAbortAllowedIn
                );
        }
        else
        {
            CStr strDescriptionRef;

            // Lookup the string using the Ref string Id.
            strDescriptionRef.LoadString( g_hInstance, uiDescriptionRefStringIdIn );

            // Send progress notification ( call the overloaded function )
            SendStatusReport(
                  clsidTaskMajorIn
                , clsidTaskMinorIn
                , ulMinIn
                , ulMaxIn
                , ulCurrentIn
                , hrStatusIn
                , strDescription.PszData()
                , strDescriptionRef.PszData()
                , fIsAbortAllowedIn
                );
        }

    } // if: callbacks are supported
    else
    {
        LogMsg( "[BC] Callbacks are not supported. No status report will be sent." );
    } // else: callbacks are not supported

    TraceFuncExit();

} //*** CBCAInterface::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SendStatusReport
//
//  Description:
//      Send a progress notification [ string overload ].
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      pcszDescriptionStringIn
//          String ID of the description of the notification.
//
//      fIsAbortAllowedIn
//          An optional parameter indicating if this configuration step can
//          be aborted or not. Default value is true.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAbortException
//          If the configuration was aborted.
//
//  Remarks:
//      In the current implementation, IClusCfgCallback::SendStatusReport
//      returns E_ABORT to indicate that the user wants to abort
//      the cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::SendStatusReport(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , ULONG           ulCurrentIn
    , HRESULT         hrStatusIn
    , const WCHAR *   pcszDescriptionStringIn
    , bool            fIsAbortAllowedIn         // = true
    )
{
    TraceFunc1( "pcszDescriptionStringIn = '%ws'", pcszDescriptionStringIn );

    HRESULT     hrRetVal = S_OK;
    FILETIME    ft;

    if ( !FIsCallbackSupported() )
    {
        // Nothing needs to be done.
        goto Cleanup;
    } // if: callbacks are not supported

    GetSystemTimeAsFileTime( &ft );

    // Send progress notification
    hrRetVal = THR(
        m_spcbCallback->SendStatusReport(
              NULL
            , clsidTaskMajorIn
            , clsidTaskMinorIn
            , ulMinIn
            , ulMaxIn
            , ulCurrentIn
            , hrStatusIn
            , pcszDescriptionStringIn
            , &ft
            , NULL
            )
        );

    // Has the user requested an abort?
    if ( hrRetVal == E_ABORT )
    {
        LogMsg( "[BC] A request to abort the configuration has been recieved." );
        if ( fIsAbortAllowedIn )
        {
            LogMsg( "[BC] Configuration will be aborted." );
            THROW_ABORT( E_ABORT, IDS_USER_ABORT );
        } // if: this operation can be aborted
        else
        {
            LogMsg( "[BC] This configuration operation cannot be aborted. Request will be ignored." );
        } // else: this operation cannot be aborted
    } // if: the user has indicated that that configuration should be aborted
    else
    {
        if ( FAILED( hrRetVal ) )
        {
            LogMsg( "[BC] Error 0x%#08x has occurred - no more status messages will be sent.", hrRetVal );

            // Disable all further callbacks.
            SetCallbackSupported( false );
        } // if: something went wrong trying to send a status report
    } // else: abort was not requested

Cleanup:

    if ( FAILED( hrRetVal ) )
    {
        LogMsg( "[BC] Error 0x%#08x occurred trying send a status message. Throwing an exception.", hrRetVal );
        THROW_RUNTIME_ERROR( hrRetVal, IDS_ERROR_SENDING_REPORT );
    } // if: an error occurred

    TraceFuncExit();

} //*** CBCAInterface::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::SendStatusReport
//
//  Description:
//      Send a progress notification [ string & REF string overload ].
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      pcszDescriptionStringIn
//          String ID of the description of the notification.
//
//      pcszDescriptionRefStringIn
//          REF String ID of the description of the notification.
//
//      fIsAbortAllowedIn
//          An optional parameter indicating if this configuration step can
//          be aborted or not. Default value is true.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      CAbortException
//          If the configuration was aborted.
//
//  Remarks:
//      In the current implementation, IClusCfgCallback::SendStatusReport
//      returns E_ABORT to indicate that the user wants to abort
//      the cluster configuration.
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::SendStatusReport(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , ULONG           ulCurrentIn
    , HRESULT         hrStatusIn
    , const WCHAR *   pcszDescriptionStringIn
    , const WCHAR *   pcszDescriptionRefStringIn
    , bool            fIsAbortAllowedIn         // = true
    )
{
    TraceFunc1( "pcszDescriptionRefStringIn = '%ws'", pcszDescriptionRefStringIn );

    HRESULT     hrRetVal = S_OK;
    FILETIME    ft;

    if ( !FIsCallbackSupported() )
    {
        // Nothing needs to be done.
        goto Cleanup;
    } // if: callbacks are not supported

    GetSystemTimeAsFileTime( &ft );

    // Send progress notification
    hrRetVal = THR(
        m_spcbCallback->SendStatusReport(
              NULL
            , clsidTaskMajorIn
            , clsidTaskMinorIn
            , ulMinIn
            , ulMaxIn
            , ulCurrentIn
            , hrStatusIn
            , pcszDescriptionStringIn
            , &ft
            , pcszDescriptionRefStringIn
            )
        );

    // Has the user requested an abort?
    if ( hrRetVal == E_ABORT )
    {
        LogMsg( "[BC] A request to abort the configuration has been recieved." );
        if ( fIsAbortAllowedIn )
        {
            LogMsg( "[BC] Configuration will be aborted." );
            THROW_ABORT( E_ABORT, IDS_USER_ABORT );
        } // if: this operation can be aborted
        else
        {
            LogMsg( "[BC] This configuration operation cannot be aborted. Request will be ignored." );
        } // else: this operation cannot be aborted
    } // if: the user has indicated that that configuration should be aborted
    else
    {
        if ( FAILED( hrRetVal ) )
        {
            LogMsg( "[BC] Error 0x%#08x has occurred - no more status messages will be sent.", hrRetVal );

            // Disable all further callbacks.
            SetCallbackSupported( false );
        } // if: something went wrong trying to send a status report
    } // else: abort was not requested

Cleanup:

    if ( FAILED( hrRetVal ) )
    {
        LogMsg( "[BC] Error 0x%#08x occurred trying send a status message. Throwing an exception.", hrRetVal );
        THROW_RUNTIME_ERROR( hrRetVal, IDS_ERROR_SENDING_REPORT );
    } // if: an error occurred

    TraceFuncExit();

} //*** CBCAInterface::SendStatusReport


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::QueueStatusReportCompletion
//
//  Description:
//      Queue a status report for sending when an exception is caught.
//
//  Arguments:
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUIDs identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//          Values that indicate the range of steps for this report.
//
//      uiDescriptionStringIdIn
//          String ID of the description of the notification.
//
//      uiReferenceStringIdIn
//          Reference string ID of the description of the notification.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any thrown by CList::Append()
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::QueueStatusReportCompletion(
      const CLSID &   clsidTaskMajorIn
    , const CLSID &   clsidTaskMinorIn
    , ULONG           ulMinIn
    , ULONG           ulMaxIn
    , UINT            uiDescriptionStringIdIn
    , UINT            uiReferenceStringIdIn
    )
{
    TraceFunc( "" );

    // Queue the status report only if callbacks are supported.
    if ( m_fCallbackSupported )
    {
        // Append this status report to the end of the pending list.
        m_prlPendingReportList.Append(
            SPendingStatusReport(
                  clsidTaskMajorIn
                , clsidTaskMinorIn
                , ulMinIn
                , ulMaxIn
                , uiDescriptionStringIdIn
                , uiReferenceStringIdIn
                )
            );
    }

    TraceFuncExit();

} //*** CBCAInterface::QueueStatusReportCompletion


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::CompletePendingStatusReports
//
//  Description:
//      Send all the status reports that were queued for sending when an
//      exception occurred. This function is meant to be called from an exception
//      handler when an exception is caught.
//
//  Arguments:
//      hrStatusIn
//          The error code to be sent with the pending status reports.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None, since this function is usually called in an exception handler.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CBCAInterface::CompletePendingStatusReports(
    HRESULT hrStatusIn
    ) throw()
{
    TraceFunc( "" );

    if ( m_fCallbackSupported )
    {
        try
        {
            PendingReportList::CIterator    ciCurrent   = m_prlPendingReportList.CiBegin();
            PendingReportList::CIterator    ciLast      = m_prlPendingReportList.CiEnd();

            // Iterate through the list of pending status reports and send each pending report.
            while ( ciCurrent != ciLast )
            {
                // Send the current status report.
                SendStatusReport(
                      ciCurrent->m_clsidTaskMajor
                    , ciCurrent->m_clsidTaskMinor
                    , ciCurrent->m_ulMin
                    , ciCurrent->m_ulMax
                    , ciCurrent->m_ulMax
                    , hrStatusIn
                    , ciCurrent->m_uiDescriptionStringId
                    , ciCurrent->m_uiReferenceStringId
                    , false
                    );

                // Move to the next one.
                m_prlPendingReportList.DeleteAndMoveToNext( ciCurrent );

            } // while: the pending status report list is not empty

        } // try: to send status report
        catch( ... )
        {
            THR( E_UNEXPECTED );

            // Nothing can be done here if the sending of the status report fails.
            LogMsg( "[BC] An unexpected error has occurred trying to complete pending status messages. It will not be propagated." );
        } // catch: all exceptions

    } // if: callbacks are supported

    // Empty the pending status report list.
    m_prlPendingReportList.Empty();

    TraceFuncExit();

} //*** CBCAInterface::CompletePendingStatusReports


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process an exception that should be shown to the user.
//
//  Arguments:
//      CExceptionWithString & resExceptionObjectInOut
//          The exception object that has been caught.
//
//  Return Value:
//      The error code stored in the exception object.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException(
    CExceptionWithString & resExceptionObjectInOut
    ) throw()
{
    TraceFunc( "resExceptionObjectInOut" );

    LogMsg(
          TEXT("[BC] A runtime error has occurred in file '%s', line %d. Error code is %#08x.") SZ_NEWLINE
          TEXT("  The error string is '%s'.")
        , resExceptionObjectInOut.PszGetThrowingFile()
        , resExceptionObjectInOut.UiGetThrowingLine()
        , resExceptionObjectInOut.HrGetErrorCode()
        , resExceptionObjectInOut.StrGetErrorString().PszData()
        );

    // If the user has not been notified
    if ( ! resExceptionObjectInOut.FHasUserBeenNotified() )
    {
        try
        {
            SendStatusReport(
                  TASKID_Major_Configure_Cluster_Services
                , TASKID_Minor_Rolling_Back_Cluster_Configuration
                , 1, 1, 1
                , resExceptionObjectInOut.HrGetErrorCode()
                , resExceptionObjectInOut.StrGetErrorString().PszData()
                , resExceptionObjectInOut.StrGetErrorRefString().PszData()
                , false                                     // fIsAbortAllowedIn
                );

            resExceptionObjectInOut.SetUserNotified();

        } // try: to send status report
        catch( ... )
        {
            THR( E_UNEXPECTED );

            // Nothing can be done here if the sending of the status report fails.
            LogMsg( "[BC] An unexpected error has occurred trying to send a progress notification. It will not be propagated." );
        } // catch: all exceptions
    } // if: the user has not been notified of this exception

    // Complete sending pending status reports.
    CompletePendingStatusReports( resExceptionObjectInOut.HrGetErrorCode() );

    HRETURN( resExceptionObjectInOut.HrGetErrorCode() );

} //*** CBCAInterface::HrProcessException


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process an assert exception.
//
//  Arguments:
//      const CAssert & rcaExceptionObjectIn
//          The exception object that has been caught.
//
//  Return Value:
//      The error code stored in the exception object.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException(
    const CAssert & rcaExceptionObjectIn
    ) throw()
{
    TraceFunc( "rcaExceptionObjectIn" );

    LogMsg(
          TEXT("[BC] An assertion has failed in file '%s', line %d. Error code is %#08x.") SZ_NEWLINE
          TEXT("  The error string is '%s'.")
        , rcaExceptionObjectIn.PszGetThrowingFile()
        , rcaExceptionObjectIn.UiGetThrowingLine()
        , rcaExceptionObjectIn.HrGetErrorCode()
        , rcaExceptionObjectIn.StrGetErrorString().PszData()
        );

    // Complete sending pending status reports.
    CompletePendingStatusReports( rcaExceptionObjectIn.HrGetErrorCode() );

    HRETURN( rcaExceptionObjectIn.HrGetErrorCode() );

} //*** CBCAInterface::HrProcessException


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process a general exception.
//
//  Arguments:
//      const CException & rceExceptionObjectIn
//          The exception object that has been caught.
//
//  Return Value:
//      The error code stored in the exception object.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException(
    const CException & rceExceptionObjectIn
    ) throw()
{
    TraceFunc( "roeExceptionObjectIn" );

    LogMsg(
          "[BC] An exception has occurred in file '%s', line %d. Error code is %#08x."
        , rceExceptionObjectIn.PszGetThrowingFile()
        , rceExceptionObjectIn.UiGetThrowingLine()
        , rceExceptionObjectIn.HrGetErrorCode()
        );

    // Complete sending pending status reports.
    CompletePendingStatusReports( rceExceptionObjectIn.HrGetErrorCode() );

    HRETURN( rceExceptionObjectIn.HrGetErrorCode() );

} //*** CBCAInterface::HrProcessException


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBCAInterface::HrProcessException
//
//  Description:
//      Process an unknown exception.
//
//  Arguments:
//      None.
//
//  Return Value:
//      E_UNEXPECTED
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBCAInterface::HrProcessException( void ) throw()
{
    TraceFunc( "void" );

    HRESULT hr = E_UNEXPECTED;

    LogMsg( "[BC] An unknown exception (for example, an access violation) has occurred." );

    // Complete sending pending status reports.
    CompletePendingStatusReports( hr );

    HRETURN( hr );

} //*** CBCAInterface::HrProcessException
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbcainterface.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CBCAInterface.h
//
//  Implementation Files:
//      CBCAInterface.cpp
//
//  Description:
//      This file contains the declaration of the CBCAInterface
//      class. This class implements the IClusCfgBaseCluster interface.
//
//  Maintained By:
//      David Potter    (DavidP)    19-JUN-2001
//      Vij Vasu        (VVasu)     07-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgBaseCluster
// For IClusCfgInitialize
// For IClusCfgCallback
#include "ClusCfgServer.h"
#include "ClusCfgPrivate.h"

// For CSmartIfacePtr
#include "SmartClasses.h"

// For the a few common types and definitions
#include "CommonDefs.h"

// For the CStr class
#include "CStr.h"

// For the CList class
#include "CList.h"


//////////////////////////////////////////////////////////////////////////
// Forward declarations.
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;
class CException;
class CExceptionWithString;
class CAssert;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBCAInterface
//
//  Description:
//      This class implements the IClusCfgBaseCluster interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBCAInterface
    : public IClusCfgBaseCluster
    , public IClusCfgInitialize
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riidIn, void ** ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgBaseCluster methods
    //////////////////////////////////////////////////////////////////////////

    // Indicate that a cluster is to be created.
    STDMETHOD( SetCreate )(
          const WCHAR *         pcszClusterNameIn
        , const WCHAR *         pcszClusterBindingStringIn
        , IClusCfgCredentials * pcccServiceAccountIn
        , const DWORD           dwClusterIPAddressIn
        , const DWORD           dwClusterIPSubnetMaskIn
        , const WCHAR *         pcszClusterIPNetworkIn
        );

    // Indicate that this node should be added to a cluster.
    STDMETHOD( SetAdd )(
          const WCHAR *         pcszClusterNameIn
        , const WCHAR *         pcszClusterBindingStringIn
        , IClusCfgCredentials * pcccServiceAccountIn
        );

    // Indicate that this node needs to be cleaned up.
    STDMETHOD( SetCleanup )( void );

    // Commit the action desired.
    STDMETHOD( Commit )( void );

    // Rollback the committed action.
    STDMETHOD( Rollback )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
          IUnknown *   punkCallbackIn
        , LCID         lcidIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    // Send progress notification [ string id overload ]
    void
        SendStatusReport(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , ULONG           ulCurrentIn
            , HRESULT         hrStatusIn
            , UINT            uiDescriptionStringIdIn
            , bool            fIsAbortAllowedIn = true
            );

    // Send progress notification [ string id & REF string id overload ]
    void
        SendStatusReport(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , ULONG           ulCurrentIn
            , HRESULT         hrStatusIn
            , UINT            uiDescriptionStringIdIn
            , UINT            uiReferenceStringIdIn
            , bool            fIsAbortAllowedIn = true
            );

    // Send progress notification [ string overload ]
    void
        SendStatusReport(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , ULONG           ulCurrentIn
            , HRESULT         hrStatusIn
            , const WCHAR *   pcszDescriptionStringIn
            , bool            fIsAbortAllowedIn = true
            );

    // Send progress notification [ string & REF string overload ]
    void
        SendStatusReport(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , ULONG           ulCurrentIn
            , HRESULT         hrStatusIn
            , const WCHAR *   pcszDescriptionStringIn
            , const WCHAR *   pcszReferenceStringIn
            , bool            fIsAbortAllowedIn = true
            );

    // Queue a status report to be sent when an exception is caught.
    void
        QueueStatusReportCompletion(
              const CLSID &   clsidTaskMajorIn
            , const CLSID &   clsidTaskMinorIn
            , ULONG           ulMinIn
            , ULONG           ulMaxIn
            , UINT            uiDescriptionStringIdIn
            , UINT            uiReferenceStringIdIn
            );

    // Process an exception that should be shown to the user.
    HRESULT
        HrProcessException( CExceptionWithString & resExceptionObjectInOut ) throw();

    // Process an assert exception.
    HRESULT
        HrProcessException( const CAssert & rcaExceptionObjectIn ) throw();

    // Process a general exception.
    HRESULT
        HrProcessException( const CException & rceExceptionObjectIn ) throw();

    // Process an unknown exception.
    HRESULT
        HrProcessException( void ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Public accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Has this action been successfully committed?
    bool
        FIsCommitComplete() const throw() { return m_fCommitComplete; }

    // Can this action be rolled back?
    bool
        FIsRollbackPossible() const throw() { return m_fRollbackPossible; }

    // Are callbacks supported?
    bool
        FIsCallbackSupported() const throw() { return m_fCallbackSupported; }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // Smart pointer to a base cluster action.
    typedef CSmartGenericPtr< CPtrTrait< CBaseClusterAction > > SmartBCAPointer;

    // Structure that holds the data required to send pending status reports.
    struct SPendingStatusReport
    {
        CLSID   m_clsidTaskMajor;
        CLSID   m_clsidTaskMinor;
        ULONG   m_ulMin;
        ULONG   m_ulMax;
        UINT    m_uiDescriptionStringId;
        UINT    m_uiReferenceStringId;

        // Constructor
        SPendingStatusReport(
              const CLSID & rclsidTaskMajorIn
            , const CLSID & rclsidTaskMinorIn
            , ULONG         ulMinIn
            , ULONG         ulMaxIn
            , UINT          uiDescriptionStringIdIn
            , UINT          uiReferenceStringIdIn
            )
            : m_clsidTaskMajor( rclsidTaskMajorIn )
            , m_clsidTaskMinor( rclsidTaskMinorIn )
            , m_ulMin( ulMinIn )
            , m_ulMax( ulMaxIn )
            , m_uiDescriptionStringId( uiDescriptionStringIdIn )
            , m_uiReferenceStringId( uiReferenceStringIdIn )
        {
        } //*** SPendingStatusReport

    }; // struct SPendingStatusReport

    // List of pending status reports
    typedef CList< SPendingStatusReport > PendingReportList;


    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CBCAInterface( void );

    // Destructor.
    ~CBCAInterface( void );

    // Copy constructor.
    CBCAInterface( const CBCAInterface & );

    // Assignment operator.
    CBCAInterface & operator =( const CBCAInterface & );


    //////////////////////////////////////////////////////////////////////////
    // Private accessor methods
    //////////////////////////////////////////////////////////////////////////

    // Set the commit status.
    void
        SetCommitCompleted( bool fComplete = true ) throw() { m_fCommitComplete = fComplete; }

    // Indicate if rollback is possible
    void
        SetRollbackPossible( bool fPossible = true ) throw() { m_fRollbackPossible = fPossible; }

    // Indicate if callbacks are supported or not.
    void
        SetCallbackSupported( bool fSupported = true ) throw() { m_fCallbackSupported = fSupported; }


    //////////////////////////////////////////////////////////////////////////
    //  Other private methods
    //////////////////////////////////////////////////////////////////////////

    // Send all those status reports that were supposed to be sent
    void
        CompletePendingStatusReports( HRESULT hrStatusIn ) throw();


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Indicates if this action has been successfully committed or not.
    bool                m_fCommitComplete;

    // Indicates if this action can be rolled back or not.
    bool                m_fRollbackPossible;

    // Indicates if callbacks are supported or not.
    bool                m_fCallbackSupported;

    // Reference count for this object.
    LONG                m_cRef;

    // The locale id.
    LCID                m_lcid;

    // Pointer to the action to be performed during Commit()
    SmartBCAPointer     m_spbcaCurrentAction;

    // Pointer to the synchronous callback interface.
    CSmartIfacePtr< IClusCfgCallback > m_spcbCallback;

    // List of status reports that need to be send when an exception is caught.
    PendingReportList   m_prlPendingReportList;

}; //*** class CBCAInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbstring.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CBString.cpp
//
//  Description:
//      Contains the definition of the BString class.
//
//  Maintained By:
//      John Franco    (jfranco)    17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"

#include "CBString.h"

// For the exceptions thrown by CBString
#include "CException.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBString::AllocateBuffer
//
//  Description:
//      Given a character count, make a BSTR sized to hold that many
//      characters (NOT including terminating null).
//      If the count is zero, return null.
//
//  Arguments:
//      cchIn
//          Character count.
//
//  Return Values:
//      Newly allocated BSTR, or null.
//
//  Exceptions Thrown:
//      CException
//          If the memory allocation fails.
//
//--
//////////////////////////////////////////////////////////////////////////////
BSTR
CBString::AllocateBuffer( UINT cchIn )
{
    TraceFunc1( "cchIn == %d", cchIn );

    BSTR bstr = NULL;

    if ( cchIn > 0 )
    {
        bstr = TraceSysAllocStringLen( NULL, cchIn );
        if ( bstr == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        }
    } // if: non-zero size specified

    RETURN( bstr );

} //*** CBString::AllocateBuffer



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBString::CopyString
//
//  Description:
//      Given a null-terminated unicode string, return a BSTR copy of it.
//      If the argument is null, return null.
//
//  Arguments:
//      pcwszIn - original string.
//
//  Return Value:
//      Newly allocated BSTR, or null.
//
//  Exceptions Thrown:
//      CException
//          If the memory allocation fails.
//
//--
//////////////////////////////////////////////////////////////////////////////
BSTR
CBString::CopyString( PCWSTR pcwszIn )
{
    TraceFunc1( "pcwszIn = '%ws'", pcwszIn == NULL ? L"<NULL>" : pcwszIn );

    BSTR bstr = NULL;

    if ( pcwszIn != NULL )
    {
        bstr = TraceSysAllocString( pcwszIn );
        if ( bstr == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        }
    } // if: non-NULL string pointer specified

    RETURN( bstr );

} //*** CBString::CopyString


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBString::CopyBSTR
//
//  Description:
//      Given a BSTR, return a BSTR copy of it.
//      If the argument is null, return null.
//
//  Arguments:
//      bstrIn - original string.
//
//  Return Value:
//      Newly allocated BSTR, or null.
//
//  Exceptions Thrown:
//      CException
//          If the memory allocation fails.
//
//--
//////////////////////////////////////////////////////////////////////////////
BSTR
CBString::CopyBSTR( BSTR bstrIn )
{
    TraceFunc1( "bstrIn = '%ws'", bstrIn == NULL ? L"<NULL>" : bstrIn );

    BSTR bstr = NULL;

    if ( bstrIn != NULL )
    {
        bstr = TraceSysAllocString( bstrIn );
        if ( bstr == NULL )
        {
            THROW_EXCEPTION( E_OUTOFMEMORY );
        }
    } // if: non-NULL BSTR specified

    RETURN( bstr );

} //*** CBString::CopyBSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBCleanup.h
//
//  Description:
//      Header file for CClusDBCleanup class.
//      The CClusDBCleanup class is an action that cleans up the cluster database.
//
//  Implementation Files:
//      CClusDBCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDB base class
#include "CClusDB.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDBCleanup
//
//  Description:
//      The CClusDBCleanup class is an action that clean up the cluster database.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDBCleanup : public CClusDB
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDBCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusDBCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusDB service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDB BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusDBCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdb.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDB.cpp
//
//  Description:
//      Contains the definition of the CClusDB class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDB.h"

// For the CBaseClusterAction class
#include "CBaseClusterAction.h"

// For g_GenericSetupQueueCallback and other global functions
#include "GlobalFuncs.h"

// For CEnableThreadPrivilege
#include "CEnableThreadPrivilege.h"

// For ConvertStringSecurityDescriptorToSecurityDescriptor
#include <sddl.h>

//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Section in the INF file that deals with cleaning up the cluster database
#define CLUSDB_CLEANUP_INF_SECTION_NAME     L"ClusDB_Cleanup"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDB::CClusDB()
//
//  Description:
//      Constructor of the CClusDB class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDB::CClusDB(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_pbcaParentAction( pbcaParentActionIn )
{

    TraceFunc( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        LogMsg( "[BC] Pointers to the parent action is NULL. Throwing an exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CClusDB::CClusDB() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

    TraceFuncExit();

} //*** CClusDB::CClusDB


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDB::~CClusDB
//
//  Description:
//      Destructor of the CClusDB class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDB::~CClusDB( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDB::~CClusDB


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDB::CreateHive
//
//  Description:
//      Creates the cluster cluster hive in the registry.
//
//  Arguments:
//      pbcaClusterActionIn
//          Pointer to the CBaseClusterAction object which contains this object.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDB::CreateHive( CBaseClusterAction * pbcaClusterActionIn )
{
    TraceFunc( "" );
    LogMsg( "[BC] Attempting to create the cluster hive in the registry." );

    OBJECT_ATTRIBUTES   oaClusterHiveKey;
    OBJECT_ATTRIBUTES   oaClusterHiveFile;

    HRESULT             hrStatus = STATUS_SUCCESS;

    CStr                strClusterHiveFileName( pbcaClusterActionIn->RStrGetClusterInstallDirectory() );
    UNICODE_STRING      ustrClusterHiveFileName;
    UNICODE_STRING      ustrClusterHiveKeyName;

    PSECURITY_DESCRIPTOR    psdHiveSecurityDescriptor = NULL;

    strClusterHiveFileName += L"\\" CLUSTER_DATABASE_NAME;

    LogMsg( "[BC] The cluster hive backing file is '%s'.", strClusterHiveFileName.PszData() );

    //
    // Enable the SE_RESTORE_PRIVILEGE.
    //
    // What we are doing here is that we are creating an object of
    // type CEnableThreadPrivilege. This object enables the privilege
    // in the constructor and restores it to its original state in the destructor.
    //
    CEnableThreadPrivilege etpAcquireRestorePrivilege( SE_RESTORE_NAME );

    //
    // Convert the DOS file name to NT file name.
    // WARNING: This function call allocates memory in the RTL heap and it is not being
    // assigned to a smart pointer. Make sure that we do not call any functions that
    // could throw an exception till this memory is freed.
    //

    if ( RtlDosPathNameToNtPathName_U( 
               strClusterHiveFileName.PszData()
             , &ustrClusterHiveFileName
             , NULL
             , NULL
             )
         == FALSE
       )
    {
        LogMsg( "[BC] RtlDosPathNameToNtPathName failed. Returning %#08x as the error code.", STATUS_OBJECT_PATH_INVALID );

        // Use the most appropriate error code.
        hrStatus = STATUS_OBJECT_PATH_INVALID;

        goto Cleanup;
    } // if: we could not convert from the dos file name to the nt file name

    InitializeObjectAttributes( 
          &oaClusterHiveFile
        , &ustrClusterHiveFileName
        , OBJ_CASE_INSENSITIVE
        , NULL
        , NULL
        );

    RtlInitUnicodeString( &ustrClusterHiveKeyName, L"\\Registry\\Machine\\" CLUSREG_KEYNAME_CLUSTER );

    InitializeObjectAttributes( 
          &oaClusterHiveKey
        , &ustrClusterHiveKeyName
        , OBJ_CASE_INSENSITIVE
        , NULL
        , NULL
        );

    //
    // This function creates an empty hive and the backing file and log. The calling thread must
    // have the SE_RESTORE_PRIVILEGE privilege enabled.
    //
    hrStatus = THR( NtLoadKey2( &oaClusterHiveKey, &oaClusterHiveFile, REG_NO_LAZY_FLUSH ) );

    // Free allocated memory before throwing exception.
    RtlFreeHeap( RtlProcessHeap(), 0, ustrClusterHiveFileName.Buffer );

    if ( NT_ERROR( hrStatus ) )
    {
        LogMsg( "[BC] NtLoadKey2 returned error code %#08x.", hrStatus );
        goto Cleanup;
    } // if: something went wrong with NtLoadKey2

    TraceFlow( "NtLoadKey2 was successful." );

    // Set the security descriptor on the hive.
    {
        DWORD                   sc;
        BOOL                    fSuccess;
        PACL                    paclDacl;
        BOOL                    fIsDaclPresent;
        BOOL                    fDefaultDaclPresent;

        // Open the cluster hive key.
        CRegistryKey rkClusterHive( HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_CLUSTER, WRITE_DAC );

        // construct a DACL that is protected (P) from inheriting ACEs from
        // its parent key (MACHINE). Add access allowed (A) ACEs for Local
        // Admin (BA) and LocalSystem (SY) granting them full control (KA) and
        // an ACE for NetworkService (NS), LocalService (LS), and
        // authenticated users (AU) granting read only access (KR). Each ACE
        // has container inherit (CI) set so subkeys will inherit the ACEs
        // from this security descriptor.
        fSuccess = ConvertStringSecurityDescriptorToSecurityDescriptor(
                         L"D:P(A;CI;KA;;;BA)(A;CI;KA;;;SY)(A;CI;KR;;;NS)(A;CI;KR;;;LS)(A;CI;KR;;;AU)"
                       , SDDL_REVISION_1
                       , &psdHiveSecurityDescriptor
                       , NULL
                       );

        if ( fSuccess == FALSE )
        {
            sc = TW32( GetLastError() );
            hrStatus = HRESULT_FROM_WIN32( sc );
            LogMsg( "[BC] Error %#08x occurred trying to compose the security descriptor for the cluster hive.", sc );
            goto Cleanup;
        }

        // get a pointer to the ACL in the SD and set the DACL on the root of
        // the cluster hive.
        fSuccess = GetSecurityDescriptorDacl(
                         psdHiveSecurityDescriptor
                       , &fIsDaclPresent
                       , &paclDacl
                       , &fDefaultDaclPresent
                       );

        if ( fSuccess == FALSE )
        {
            sc = TW32( GetLastError() );
            hrStatus = HRESULT_FROM_WIN32( sc );
            LogMsg( "[BC] Error %#08x occurred trying to obtain the discretionary ACL from the cluster security descriptor.", sc );
            goto Cleanup;
        }

        // This should always be the case since we just constructed the ACL in
        // the Convert API call.
        if ( fIsDaclPresent && !fDefaultDaclPresent )
        {
            sc = TW32( SetSecurityInfo(
                           rkClusterHive.HGetKey()
                         , SE_REGISTRY_KEY
                         , DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION
                         , NULL                         // Owner SID
                         , NULL                         // Group SID
                         , paclDacl
                         , NULL                         // SACL
                         ) );

            if ( sc != ERROR_SUCCESS )
            {
                hrStatus = HRESULT_FROM_WIN32( sc );
                LogMsg( "[BC] Error %#08x occurred trying to set the cluster hive security.", sc );
                goto Cleanup;
            } // if: ClRtlSetObjSecurityInfo failed
        }
        else
        {
            hrStatus = HRESULT_FROM_WIN32( ERROR_INVALID_SECURITY_DESCR );
            LogMsg( "[BC] Cluster Hive discretionary ACL not correctly formatted." );
            goto Cleanup;
        }

        // Flush the changes to the registry.
        RegFlushKey( rkClusterHive.HGetKey() );
    }

    // At this point, the cluster hive has been created.
    LogMsg( "[BC] The cluster hive has been created." );

Cleanup:

    if ( psdHiveSecurityDescriptor )
    {
        LocalFree( psdHiveSecurityDescriptor );
    }

    if ( NT_ERROR( hrStatus ) )
    {
        LogMsg( "[BC] Error %#08x occurred trying to create the cluster hive. Throwing an exception.", hrStatus );
        THROW_RUNTIME_ERROR(
              hrStatus
            , IDS_ERROR_CLUSDB_CREATE_HIVE
            );
    } // if: something went wrong.

    TraceFuncExit();

} //*** CClusDB::CreateHive


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDB::CleanupHive
//
//  Description:
//      Unload the cluster hive and delete the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDB::CleanupHive( void )
{
    TraceFunc( "" );

    DWORD   sc = ERROR_SUCCESS;
    HKEY    hTempKey;

    // Check if the cluster hive is loaded before attempting to unload it.
    if ( RegOpenKeyExW( 
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_CLUSTER
            , 0
            , KEY_READ
            , &hTempKey
            )
         == ERROR_SUCCESS
       )
    {
        RegCloseKey( hTempKey );

        //
        // Enable the SE_RESTORE_PRIVILEGE.
        //
        // What we are doing here is that we are creating an object of
        // type CEnableThreadPrivilege. This object enables the privilege
        // in the constructor and restores it to its original state in the destructor.
        //
        CEnableThreadPrivilege etpAcquireRestorePrivilege( SE_RESTORE_NAME );

        //
        // Unload the cluster hive, so that it can be deleted. Note, thread must
        // have SE_RESTORE_PRIVILEGE enabled.
        //
        sc = RegUnLoadKey(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_CLUSTER
            );

        // MUSTDO: Check if ERROR_FILE_NOT_FOUND is an acceptable return value.
        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred while trying to unload the cluster hive.", sc );
            goto Cleanup;
        } // if: the hive could not be unloaded.

        LogMsg( "[BC] The cluster hive has been unloaded." );

    } // if: the cluster hive is loaded
    else
    {
        LogMsg( "[BC] The cluster hive was not loaded." );
    } // else: the cluster hive is not loaded


    //
    // Process ClusDB cleanup section in the INF file.
    // This will delete the cluster database file and the log file.
    //
    if ( SetupInstallFromInfSection(
          NULL                                          // optional, handle of a parent window
        , m_pbcaParentAction->HGetMainInfFileHandle()   // handle to the INF file
        , CLUSDB_CLEANUP_INF_SECTION_NAME               // name of the Install section
        , SPINST_FILES                                  // which lines to install from section
        , NULL                                          // optional, key for registry installs
        , NULL                                          // optional, path for source files
        , 0                                             // optional, specifies copy behavior
        , g_GenericSetupQueueCallback                   // optional, specifies callback routine
        , NULL                                          // optional, callback routine context
        , NULL                                          // optional, device information set
        , NULL                                          // optional, device info structure
        ) == FALSE
       )
    {
        sc = GetLastError();
        LogMsg( "[BC] Error %#08x returned from SetupInstallFromInfSection() while trying to clean up the cluster database files.", sc );
        goto Cleanup;
    } // if: SetupInstallServicesFromInfSection failed

    LogMsg( "[BC] The cluster database files have been cleaned up." );

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred while trying to cleanup the cluster database. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDB_CLEANUP );
    }

    TraceFuncExit();

} //*** CClusDB::CleanupHive
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cbstring.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      CBString.h
//
//  Implementation File:
//      CBString.cpp
//
//  Description:
//      BString provides an exception-safe handler for BSTRs; it also wipes
//      clean its contents upon leaving scope, making it usable for short-lived
//      password storage.
//
//      This class is intended to be used instead of CComBSTR since the
//      use of ATL is prohibited in our project.
//
//  Maintained By:
//      John Franco (jfranco) 17-APR-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CBString
{
private:

    BSTR    m_bstr;

    static  BSTR    AllocateBuffer( UINT cchIn );
    static  BSTR    CopyString( PCWSTR pcwszIn );
    static  BSTR    CopyBSTR( BSTR bstrIn );
    
public:

    CBString( PCWSTR pcwszIn = NULL );
    CBString( UINT cchIn );
    CBString( const CBString & crbstrOtherIn );
    ~CBString( void );

    CBString &      operator=( const CBString & crbstrOtherIn );
    BSTR *          operator&( void );
    OLECHAR &       operator[]( size_t idxIn );
    const OLECHAR & operator[]( size_t idxIn ) const;
    operator        BSTR( void );
    operator        PCWSTR( void ) const;

    void    Attach( BSTR bstrIn );
    void    Detach( void );
    UINT    Length( void ) const;
    void    Erase( void );
    void    Swap( CBString & rbstrOtherInout );
    BOOL    IsEmpty( void ) const;

}; //*** class CBstring

inline
CBString::CBString( PCWSTR pcwszIn )
    : m_bstr( CopyString( pcwszIn ) )
{
    TraceFunc1( "pcwszIn = '%ws'", pcwszIn == NULL ? L"<NULL>" : pcwszIn );
    TraceFuncExit();

} //*** CBString::CBString( pcwszIn )

inline
CBString::CBString( UINT cchIn )
    : m_bstr( AllocateBuffer( cchIn ) )
{
    TraceFunc1( "cchIn = '%d'", cchIn );
    TraceFuncExit();

} //*** CBString::CBString( cchIn )

inline
CBString::CBString( const CBString & crbstrOtherIn )
    : m_bstr( CopyBSTR( crbstrOtherIn.m_bstr ) )
{
    TraceFunc1( "crbstrOtherIn = '%ws'", crbstrOtherIn );
    TraceFuncExit();

} //*** CBString::CBString( crbstrOtherIn )

inline
void
CBString::Erase( void )
{
    TraceFunc( "" );

    if ( m_bstr != NULL )
    {
        SecureZeroMemory( m_bstr, SysStringLen( m_bstr ) * sizeof( *m_bstr ) );
        TraceSysFreeString( m_bstr );
    }

    TraceFuncExit();

} //*** CBString::Erase

inline
void
CBString::Swap( CBString & rbstrOtherInout )
{
    TraceFunc1( "rbstrOtherInout = '%ws'", rbstrOtherInout );

    BSTR bstrStash = m_bstr;
    m_bstr = rbstrOtherInout.m_bstr;
    rbstrOtherInout.m_bstr = bstrStash;

    TraceFuncExit();

} //*** CBString::Swap

inline
CBString::~CBString( void )
{
    TraceFunc( "" );

    Erase();

    TraceFuncExit();

} //*** CBString::~CBString

inline
CBString &
CBString::operator=( const CBString & crbstrOtherIn )
{
    TraceFunc1( "crbstrOtherIn = '%ws'", crbstrOtherIn );

    if ( this != &crbstrOtherIn )
    {
        CBString bstrCopy( crbstrOtherIn );
        Swap( bstrCopy );
    }

    RETURN( *this );

} //*** CBString::operator=

inline
BSTR *
CBString::operator&( void )
{
    return &m_bstr;

} //*** CBString::operator&

inline
OLECHAR &
CBString::operator[]( size_t idxIn )
{
    return m_bstr[ idxIn ];

} //*** CBString::operator[]

inline
const OLECHAR &
CBString::operator[]( size_t idxIn ) const
{
    return m_bstr[ idxIn ];

} //*** CBString::operator[] const

inline
CBString::operator BSTR( void )
{
    return m_bstr;

} //*** CBString::operator BSTR

inline
CBString::operator PCWSTR( void ) const
{
    return m_bstr;

} //*** CBString::operator PCWSTR

inline
void
CBString::Attach( BSTR bstrIn )
{
    TraceFunc1( "bstrIn = '%ws'", bstrIn );

    if ( m_bstr != bstrIn )
    {
        Erase();
        m_bstr = bstrIn;
    }

    TraceFuncExit();

} //*** CBString::Attach

inline
void
CBString::Detach( void )
{
    TraceFunc( "" );

    m_bstr = NULL;

    TraceFuncExit();

} //*** CBString::Detach

inline
UINT
CBString::Length( void ) const
{
    return SysStringLen( m_bstr );

} //*** CBString::Length

inline
BOOL
CBString::IsEmpty( void ) const
{
    return ( m_bstr == NULL );

} //*** CBString::IsEmpty
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDBCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusDBCleanup class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDBCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBCleanup::CClusDBCleanup
//
//  Description:
//      Constructor of the CClusDBCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDBCleanup::CClusDBCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{
    TraceFunc( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

    TraceFuncExit();

} //*** CClusDBCleanup::CClusDBCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBCleanup::~CClusDBCleanup
//
//  Description:
//      Destructor of the CClusDBCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBCleanup::~CClusDBCleanup( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDBCleanup::~CClusDBCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBCleanup::Commit
//
//  Description:
//      Cleanup the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBCleanup::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the cluster database.
    CleanupHive();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusDBCleanup::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBCleanup::Rollback
//
//  Description:
//      Rollback the cleanup the database. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBCleanup::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusDBCleanup::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbform.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBForm.h
//
//  Description:
//      Header file for CClusDBForm class.
//      The CClusDBForm class is an action that creates the cluster database
//      during a cluster formation.
//
//  Implementation Files:
//      CClusDBForm.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDB base class
#include "CClusDB.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterForm;



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDBForm
//
//  Description:
//      The CClusDBForm class is an action that creates the cluster database
//      during a cluster formation.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDBForm : public CClusDB
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDBForm( CBaseClusterForm * pcfClusterFormIn );

    // Default destructor.
    ~CClusDBForm();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDB.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The three notifications are:
        // 1. Cleaning up any old cluster database files that may exist.
        // 2. Creating cluster database.
        // 3. Customizing cluster database.
        //
        return 3;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDB BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////

    // Create the cluster database.
    void Create();

    // Make the entries required by the cluster service in the hive.
    void PopulateHive( CBaseClusterForm * pcfClusterFormIn );

    // Customize the cluster group and the core resources.
    void CustomizeClusterGroup(
          CBaseClusterForm * pcfClusterFormIn
        , CRegistryKey &     rkClusterHiveRootIn
        );

}; //*** class CClusDBForm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDB.h
//
//  Description:
//      Header file for CClusDB class.
//      The CClusDB class performs operations that are common to many
//      configuration tasks of the cluster database.
//
//  Implementation Files:
//      CClusDB.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For SetupInstallFromInfSection
#include <setupapi.h>


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDB
//
//  Description:
//      The CClusDB class performs operations that are common to many
//      configuration tasks of the cluster database.
//
//      This class is intended to be used as the base class for other cluster
//      database related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDB : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDB(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusDB();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Cleanup and remove the hive.
    void
        CleanupHive();

    // Create the cluster hive in the registry.
    void
        CreateHive( CBaseClusterAction * pbcaClusterActionIn );

    
    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusDB( const CClusDB & );

    // Assignment operator
    const CClusDB & operator =( const CClusDB & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbjoin.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDBJoin.cpp
//
//  Description:
//      Contains the definition of the CClusDBJoin class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDBJoin.h"

// For the CBaseClusterJoin class.
#include "CBaseClusterJoin.h"

// For the CImpersonateUser class.
#include "CImpersonateUser.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::CClusDBJoin
//
//  Description:
//      Constructor of the CClusDBJoin class
//
//  Arguments:
//      m_pcjClusterJoinIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBJoin::CClusDBJoin( CBaseClusterJoin * pcjClusterJoinIn )
    : BaseClass( pcjClusterJoinIn )
    , m_pcjClusterJoin( pcjClusterJoinIn )
    , m_fHasNodeBeenAddedToSponsorDB( false )
{

    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CClusDBJoin::CClusDBJoin


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::~CClusDBJoin
//
//  Description:
//      Destructor of the CClusDBJoin class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBJoin::~CClusDBJoin( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDBJoin::~CClusDBJoin


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::Commit
//
//  Description:
//      Create the cluster database. If anything goes wrong with the creation,
//      cleanup the tasks already done.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    //
    // Perform a ClusDB cleanup just to make sure that we do not use some files left over
    // from a previous install, aborted uninstall, etc.
    //

    LogMsg( "[BC-ClusDB-Commit] Cleaning up old cluster database files that may already exist before starting creation." );

    {
        CStatusReport   srCleanDB(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Cleaning_Up_Cluster_Database
            , 0, 1
            , IDS_TASK_CLEANINGUP_CLUSDB
            );

        // Send the next step of this status report.
        srCleanDB.SendNextStep( S_OK );

        CleanupHive();

        // Send the last step of this status report.
        srCleanDB.SendNextStep( S_OK );
    }

    try
    {
        // Create the cluster database
        Create();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC-ClusDB-Commit] Caught exception during commit." );

        //
        // Cleanup anything that the failed add operation might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there
        // is no collided unwind.
        //
        try
        {
            // Cleanup the database.
            Cleanup();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC-ClusDB-Commit] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusDBJoin::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::Rollback
//
//  Description:
//      Unload the cluster hive and cleanup any associated files.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method.
    BaseClass::Rollback();

    // Undo the actions performed by.
    Cleanup();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusDBJoin::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::Create
//
//  Description:
//      Create the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Create( void )
{
    TraceFunc( "" );
    LogMsg( "[BC-ClusDB-Create] Attempting to create the cluster database required to add the node to a cluster." );

    DWORD               sc = ERROR_SUCCESS;
    SmartFileHandle     sfhClusDBFile;


    {
        //
        // Get the full path and name of the cluster database file.
        //
        CStr                strClusterHiveFileName( PbcaGetParent()->RStrGetClusterInstallDirectory() );
        strClusterHiveFileName += L"\\" CLUSTER_DATABASE_NAME;

        LogMsg( "[BC-ClusDB-Create] The cluster hive backing file is '%s'.", strClusterHiveFileName.PszData() );


        //
        // Create the cluster database file.
        //
        sfhClusDBFile.Assign(
            CreateFile(
                  strClusterHiveFileName.PszData()
                , GENERIC_READ | GENERIC_WRITE
                , 0
                , NULL
                , CREATE_ALWAYS
                , 0
                , NULL
                )
            );

        if ( sfhClusDBFile.FIsInvalid() )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC-ClusDB-Create] Error %#08x occurred trying to create the cluster database file. Throwing an exception.", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_JOIN_SYNC_DB );
        } // if: CreateFile() failed

        // Store the file handle just obtained in a member variable so that it can be used during Synchronize()
        // Note, this file is closed when sfhClusDBFile goes out of scope, so m_hClusDBFile should not be used
        // outside this function or any function that this function calls.
        m_hClusDBFile = sfhClusDBFile.HHandle();
    }


    //
    // In the scope below, the cluster service account is impersonated, so that we can communicate with the
    // sponsor cluster
    //
    {
        LogMsg( "[BC-ClusDB-Create] Attempting to impersonate the cluster service account." );

        // Impersonate the cluster service account, so that we can contact the sponsor cluster.
        // The impersonation is automatically ended when this object is destroyed.
        CImpersonateUser ciuImpersonateClusterServiceAccount( m_pcjClusterJoin->HGetClusterServiceAccountToken() );


        // Add this node to the sponsor cluster database
        do
        {
            DWORD dwSuiteType = ClRtlGetSuiteType();
            BOOL  bJoinerRunningWin64;
            SYSTEM_INFO SystemInfo;

            m_fHasNodeBeenAddedToSponsorDB = false;

            LogMsg(
                  "[BC-ClusDB-Create] Trying to add node '%s' (suite type %d) to the sponsor cluster database."
                , m_pcjClusterJoin->PszGetNodeName()
                , dwSuiteType
                );

            bJoinerRunningWin64 = ClRtlIsProcessRunningOnWin64(GetCurrentProcess());
            GetSystemInfo(&SystemInfo);

            sc = TW32( JoinAddNode4(
                                  m_pcjClusterJoin->RbhGetJoinBindingHandle()
                                , m_pcjClusterJoin->PszGetNodeName()
                                , m_pcjClusterJoin->DwGetNodeHighestVersion()
                                , m_pcjClusterJoin->DwGetNodeLowestVersion()
                                , dwSuiteType
                                , bJoinerRunningWin64
                                , SystemInfo.wProcessorArchitecture
                                ) );

            if (sc == RPC_S_PROCNUM_OUT_OF_RANGE)
            {
                LogMsg( "[BC-ClusDB-Create] Error %#08x returned from JoinAddNode4. Sponser must be Windows 2000.", sc );
                //this happens when the sponsorer is win2K
                sc = TW32( JoinAddNode3(
                                      m_pcjClusterJoin->RbhGetJoinBindingHandle()
                                    , m_pcjClusterJoin->PszGetNodeName()
                                    , m_pcjClusterJoin->DwGetNodeHighestVersion()
                                    , m_pcjClusterJoin->DwGetNodeLowestVersion()
                                    , dwSuiteType
                                    ) );
            }

            if ( sc != ERROR_SUCCESS )
            {
                LogMsg( "[BC-ClusDB-Create] Error %#08x returned from JoinAddNodeN.", sc );
                break;
            } // if: JoinAddNodeN() failed

            // Set the flag that indicates that the sponsor database has been modified, so that
            // we can undo this if we need to rollback or cleanup.
            m_fHasNodeBeenAddedToSponsorDB = true;
        }
        while( false ); // dummy do while loop to avoid gotos.

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC-ClusDB-Create] Error %#08x occurred trying to add this node to the sponsor cluster database. Throwing an exception.", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_JOINING_SPONSOR_DB );
        } // if: something has gone wrong

        LogMsg( "[BC-ClusDB-Create] This node has been successfully added to the sponsor cluster database." );

        // Get the node id of the newly formed node.
        do
        {
            // Smart handle to sponsor cluster
            SmartClusterHandle  schSponsorCluster;

            // Smart handle to this node
            SmartNodeHandle     snhThisNodeHandle;

            //
            // Get a handle to the sponsor cluster.
            //
            {
                LogMsg( "[BC-ClusDB-Create] Opening a cluster handle to the sponsor cluster with the '%ws' binding string.", m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );

                // Open a handle to the sponsor cluster.
                HCLUSTER hSponsorCluster = OpenCluster( m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );

                // Assign it to a smart handle for safe release.
                schSponsorCluster.Assign( hSponsorCluster );
            }

            // Did we succeed in opening a handle to the sponsor cluster?
            if ( schSponsorCluster.FIsInvalid() )
            {
                sc = TW32( GetLastError() );
                LogMsg(
                      "[BC-ClusDB-Create] Error %#08x occurred trying to open a cluster handle to the sponsor cluster with the '%ws' binding string."
                    , sc
                    , m_pcjClusterJoin->RStrGetClusterBindingString().PszData()
                    );
                break;
            } // if: OpenCluster() failed


            //
            // Get a handle to this node.
            //
            {
                LogMsg( "[BC-ClusDB-Create] Opening a cluster handle to the local node with the '%ws' binding string.", m_pcjClusterJoin->PszGetNodeName() );

                // Open a handle to this node.
                HNODE hThisNode = OpenClusterNode( schSponsorCluster.HHandle(), m_pcjClusterJoin->PszGetNodeName() );

                // Assign it to a smart handle for safe release.
                snhThisNodeHandle.Assign( hThisNode );
            }

            // Did we succeed in opening a handle to this node?
            if ( snhThisNodeHandle.FIsInvalid() )
            {
                sc = TW32( GetLastError() );
                LogMsg( "[BC-ClusDB-Create] Error %#08x occurred trying to open a cluster handle to the local node with the '%ws' binding string.", sc, m_pcjClusterJoin->PszGetNodeName() );
                break;
            } // if: OpenClusterNode() failed

            // Get the node id string.
            {
                DWORD       cchIdSize = 0;
                SmartSz     sszNodeId;

                sc = GetClusterNodeId(
                                  snhThisNodeHandle.HHandle()
                                , NULL
                                , &cchIdSize
                                );

                if ( ( sc != ERROR_SUCCESS ) && ( sc != ERROR_MORE_DATA ) )
                {
                    TW32( sc );
                    LogMsg( "[BC-ClusDB-Create] Error %#08x returned from GetClusterNodeId() trying to get the required length of the node id buffer.", sc );
                    break;
                } // if: GetClusterNodeId() failed

                // cchIdSize returned by the above call is the count of characters and does not include the space for
                // the terminating NULL.
                ++cchIdSize;

                sszNodeId.Assign( new WCHAR[ cchIdSize ] );
                if ( sszNodeId.FIsEmpty() )
                {
                    sc = TW32( ERROR_OUTOFMEMORY );
                    LogMsg( "[BC-ClusDB-Create] A memory allocation failure occurred trying to allocate %d characters.", cchIdSize );
                    break;
                } // if: memory allocation failed

                sc = TW32( GetClusterNodeId(
                                      snhThisNodeHandle.HHandle()
                                    , sszNodeId.PMem()
                                    , &cchIdSize
                                    ) );

                if ( sc != ERROR_SUCCESS )
                {
                    LogMsg( "Error %#08x returned from GetClusterNodeId() trying to get the node id of this node.", sc );
                    break;
                } // if: GetClusterNodeId() failed

                LogMsg( "[BC-ClusDB-Create] The node id of this node is '%s'.", sszNodeId.PMem() );

                // Set the node id for later use.
                m_pcjClusterJoin->SetNodeIdString( sszNodeId.PMem() );
            }

        }
        while( false ); // dummy do while loop to avoid gotos.

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC-ClusDB-Create] Error %#08x occurred trying to get the node id of this node. Throwing an exception.", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_GET_NEW_NODE_ID );
        } // if: something has gone wrong


        {
            CStatusReport   srSyncDB(
                  PbcaGetParent()->PBcaiGetInterfacePointer()
                , TASKID_Major_Configure_Cluster_Services
                , TASKID_Minor_Join_Sync_Cluster_Database
                , 0, 1
                , IDS_TASK_JOIN_SYNC_CLUSDB
                );

            // Send the next step of this status report.
            srSyncDB.SendNextStep( S_OK );

            // Synchronize the cluster database.
            Synchronize();

            // Send the last step of this status report.
            srSyncDB.SendNextStep( S_OK );
        }
    }

    LogMsg( "[BC-ClusDB-Create] The cluster database has been successfully created and synchronized with the sponsor cluster." );

    TraceFuncExit();

} //*** CClusDBJoin::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::Cleanup
//
//  Description:
//      Cleanup the effects of Create()
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Cleanup( void )
{
    TraceFunc( "" );
    LogMsg( "[BC-ClusDB-Cleanup] Attempting to cleanup the cluster database." );

    DWORD   sc = ERROR_SUCCESS;
    DWORD   cRetryCount = 0;

    //
    // Check if we added this node to the sponsor cluster database. If so, remove it from there.
    //
    if ( m_fHasNodeBeenAddedToSponsorDB )
    {
        LogMsg( "[BC-ClusDB-Cleanup] Attempting to impersonate the cluster service account." );

        // Impersonate the cluster service account, so that we can contact the sponsor cluster.
        // The impersonation is automatically ended when this object is destroyed.
        CImpersonateUser ciuImpersonateClusterServiceAccount( m_pcjClusterJoin->HGetClusterServiceAccountToken() );


        //
        // Remove this node from the sponsor cluster database
        //

        do
        {
            // Smart handle to sponsor cluster
            SmartClusterHandle  schSponsorCluster;

            // Smart handle to this node
            SmartNodeHandle     snhThisNodeHandle;

            //
            // Get a handle to the sponsor cluster.
            //
            {
                LogMsg( "[BC-ClusDB-Cleanup] Opening a clusterhandle to the sponsor cluster with the '%ws' binding string.", m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );

                // Open a handle to the sponsor cluster.
                HCLUSTER hSponsorCluster = OpenCluster( m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );

                // Assign it to a smart handle for safe release.
                schSponsorCluster.Assign( hSponsorCluster );
            }

            // Did we succeed in opening a handle to the sponsor cluster?
            if ( schSponsorCluster.FIsInvalid() )
            {
                sc = TW32( GetLastError() );
                LogMsg( "[BC-ClusDB-Cleanup] Error %#08x occurred trying to open a cluster handle to the sponsor cluster with the '%ws' binding string.", sc, m_pcjClusterJoin->RStrGetClusterBindingString().PszData() );
                break;
            } // if: OpenCluster() failed


            //
            // Get a handle to this node.
            //
            {
                LogMsg( "[BC-ClusDB-Cleanup] Open a clusterhandle to the local node with the '%ws' binding string.", m_pcjClusterJoin->PszGetNodeName() );

                // Open a handle to this node.
                HNODE hThisNode = OpenClusterNode( schSponsorCluster.HHandle(), m_pcjClusterJoin->PszGetNodeName() );

                if ( hThisNode == NULL )
                {
                    sc = TW32( GetLastError() );
                    LogMsg( "[BC-ClusDB-Cleanup] Error %#08x occurred trying to open a cluster handle to the local node with the '%ws' binding string.", sc, m_pcjClusterJoin->PszGetNodeName() );
                    break;
                } // if: OpenClusterNode() failed.

                // Assign it to a smart handle for safe release.
                snhThisNodeHandle.Assign( hThisNode );
            }

            //
            // If the cluster is still dealing with the join process we'll get ERROR_CLUSTER_JOIN_IN_PROGRESS.
            // After the join finishes/fails/stabilizes we'll be able to make the evict call without the
            // join process getting in the way.
            //
            cRetryCount = 1;
            sc = EvictClusterNode( snhThisNodeHandle.HHandle() );
            while( sc == ERROR_CLUSTER_JOIN_IN_PROGRESS && cRetryCount < 25 )  // Allow a two minute wait.  (24 * 5 seconds)
            {
                LogMsg( "[BC-ClusDB-Cleanup] EvictClusterNode returned ERROR_CLUSTER_JOIN_IN_PROGRESS. Retry attempt %d.", cRetryCount++ );

                // Sleep for a few seconds.
                Sleep( 5000 );

                // Try again.
                sc = EvictClusterNode( snhThisNodeHandle.HHandle() );
            }

            if ( sc != ERROR_SUCCESS )
            {
                TW32( sc );
                LogMsg( "[BC-ClusDB-Cleanup] Error %#08x occurred trying to evict this node from the sponsor cluster.", sc );
                break;
            } // if: EvictClusterNode() failed
        }
        while( false ); // dummy do while loop to avoid gotos.

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC-ClusDB-Cleanup] Error %#08x occurred trying to remove this node from the sponsor cluster database. Throwing exception.", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_EVICTING_NODE );
        } // if: something has gone wrong

        LogMsg( "[BC-ClusDB-Cleanup] This node has been successfully removed from the sponsor cluster database." );
    } // if: we had added this node to the sponsor cluster database

    // Cleanup  the cluster hive
    CleanupHive();

    TraceFuncExit();

} //*** CClusDBJoin::Cleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBJoin::Synchronize
//
//  Description:
//      Synchronize the cluster database with the sponsor cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::Synchronize( void )
{
    TraceFunc( "" );
    LogMsg( "[BC-ClusDB-Synchronize] Attempting to synchronize the cluster database with the sponsor cluster." );

    DWORD               sc = ERROR_SUCCESS;

    //
    // Initialize the byte pipe.
    //

    m_bpBytePipe.state = reinterpret_cast< char * >( this );
    m_bpBytePipe.alloc = S_BytePipeAlloc;
    m_bpBytePipe.push = S_BytePipePush;
    m_bpBytePipe.pull = S_BytePipePull;


    //
    // Synchronize the database
    //
    sc = TW32( DmSyncDatabase( m_pcjClusterJoin->RbhGetJoinBindingHandle(), m_bpBytePipe ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC-ClusDB-Synchronize] Error %#08x occurred trying to suck the database down from the sponsor cluster.", sc );
        goto Cleanup;
    } // if: DmSyncDatabase() failed

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC-ClusDB-Synchronize] Error %#08x occurred trying to synchronize the cluster database with the sponsor cluster. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_JOIN_SYNC_DB );
    } // if: something has gone wrong

    LogMsg( "[BC-ClusDB-Synchronize] The cluster database has been synchronized with the sponsor cluster." );

    TraceFuncExit();

} //*** CClusDBJoin::Synchronize


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusDBJoin::S_BytePipePush
//
//  Description:
//      Callback function used by RPC to push data.
//
//  Arguments:
//      pchStateIn
//          State of the byte pipe
//
//      pchBufferIn
//      ulBufferSizeIn
//          Buffer contained the pushed data and its size.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      RPC Exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::S_BytePipePush(
      char *                pchStateIn
    , unsigned char *       pchBufferIn
    , unsigned long         ulBufferSizeIn
    )
{
    TraceFunc( "" );

    CClusDBJoin * pThis = reinterpret_cast< CClusDBJoin * >( pchStateIn );

    if ( ulBufferSizeIn != 0 )
    {
        DWORD   dwBytesWritten;

        if (    WriteFile(
                      pThis->m_hClusDBFile
                    , pchBufferIn
                    , ulBufferSizeIn
                    , &dwBytesWritten
                    , NULL
                    )
             == 0
           )
        {
            DWORD   sc = TW32( GetLastError() );
            RpcRaiseException( sc );
        } // if: WriteFile() failed

        Assert( dwBytesWritten == ulBufferSizeIn );

    } // if: the buffer is non-empty

    TraceFuncExit();

} //*** CClusDBJoin::S_BytePipePush


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusDBJoin::S_BytePipePull
//
//  Description:
//      Callback function used by RPC to pull data.
//
//  Arguments:
//      pchStateIn
//          State of the byte pipe
//
//      pchBufferIn
//      ulBufferSizeIn
//          Buffer contained the pushed data and its size.
//
//      pulWrittenOut
//          Pointer to the number of bytes actually filled into the buffer.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      RPC Exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::S_BytePipePull(
      char *                pchStateIn
    , unsigned char *       pchBufferIn
    , unsigned long         ulBufferSizeIn
    , unsigned long *       pulWrittenOut
    )
{
    TraceFunc( "" );

    CClusDBJoin * pThis = reinterpret_cast< CClusDBJoin * >( pchStateIn );

    if ( ulBufferSizeIn != 0 )
    {
        if (    ReadFile(
                      pThis->m_hClusDBFile
                    , pchBufferIn
                    , ulBufferSizeIn
                    , pulWrittenOut
                    , NULL
                    )
             == 0
           )
        {
            DWORD   sc = TW32( GetLastError() );
            RpcRaiseException( sc );
        } // if: ReadFile() failed

        Assert( *pulWrittenOut <= ulBufferSizeIn );

    } // if:  the buffer is non-empty

    TraceFuncExit();

} //*** CClusDBJoin::S_BytePipePull


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusDBJoin::S_BytePipeAlloc
//
//  Description:
//      Callback function used by RPC to allocate a buffer.
//
//  Arguments:
//      pchStateIn
//          State of the file pipe
//
//      ulRequestedSizeIn
//          Requested size of the buffer
//
//      ppchBufferOut
//          Pointer to the buffer pointer
//
//      pulActualSizeOut
//          Pointer to the actual size of the allocated buffer
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBJoin::S_BytePipeAlloc(
      char *                pchStateIn
    , unsigned long         ulRequestedSizeIn
    , unsigned char **      ppchBufferOut
    , unsigned long  *      pulActualSizeOut
    )
{
    TraceFunc( "" );

    CClusDBJoin * pThis = reinterpret_cast< CClusDBJoin * >( pchStateIn );

    *ppchBufferOut = reinterpret_cast< unsigned char * >( pThis->m_rgbBytePipeBuffer );
    *pulActualSizeOut = ( ulRequestedSizeIn < pThis->ms_nFILE_PIPE_BUFFER_SIZE ) ? ulRequestedSizeIn : pThis->ms_nFILE_PIPE_BUFFER_SIZE;

    TraceFuncExit();

} //*** CClusDBJoin::S_BytePipeAlloc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbjoin.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDBJoin.h
//
//  Description:
//      Header file for CClusDBJoin class.
//      The CClusDBJoin class is an action that creates the cluster database
//      during a cluster join.
//
//  Implementation Files:
//      CClusDBJoin.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDB base class
#include "CClusDB.h"

// For HNODE
#include <ClusAPI.h>

// For BYTE_PIPE, JoinAddNode3() and DmSyncDatabase()
#include "ClusRPC.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterJoin;



//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDBJoin
//
//  Description:
//      The CClusDBJoin class is an action that creates the cluster database
//      during a cluster join.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDBJoin : public CClusDB
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDBJoin( CBaseClusterJoin * pcjClusterJoinIn );

    // Default destructor.
    ~CClusDBJoin();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDB.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        //
        // The three notifications are:
        // 1. Cleaning up any old cluster database files that may exist.
        // 2. Creating cluster database.
        // 3. Synchronizing cluster database.
        //
        return 3;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // The base class of this class.
    typedef CClusDB BaseClass;

    // Smart handle to a cluster node.
    typedef CSmartResource<
        CHandleTrait<
              HNODE
            , BOOL
            , CloseClusterNode
            , reinterpret_cast< HNODE >( NULL )
            >
        >
        SmartNodeHandle;
                    
    // Smart file handle
    typedef CSmartResource< CHandleTrait< HANDLE, BOOL, CloseHandle, INVALID_HANDLE_VALUE > > SmartFileHandle;


    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////

    // Create the cluster database
    void
        Create();

    // Cleanup the cluster database
    void
        Cleanup();

    // Synchronize the cluster database with the sponsor cluster.
    void Synchronize();


    // Callback function used by RPC to push data.
    static void
        S_BytePipePush(
              char *            pchStateIn
            , unsigned char *   pchBufferIn
            , unsigned long     ulBufferSizeIn
            );

    // Callback function used by RPC to pull data.
    static void
        S_BytePipePull(
              char *            pchStateIn
            , unsigned char *   pchBufferIn
            , unsigned long     ulBufferSizeIn
            , unsigned long *   pulWrittenOut
            );


    // Callback function used by RPC to allocate a buffer.
    static void
        S_BytePipeAlloc(
              char *            pchStateIn
            , unsigned long     ulRequestedSizeIn
            , unsigned char **  ppchBufferOut
            , unsigned long  *  pulActualSizeOut
            );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Size of the byte pipe buffer
    static const int    ms_nFILE_PIPE_BUFFER_SIZE = 4096;
    
    // Handle to the local cluster DB file.
    HANDLE              m_hClusDBFile;
    
    //  Indicates if this node has been added to the sponsor database or not.
    bool                m_fHasNodeBeenAddedToSponsorDB;

    // Pointer to the parent of this action.
    CBaseClusterJoin *  m_pcjClusterJoin;

    // Pipe used by RPC to get the sponsor cluster database across.
    BYTE_PIPE           m_bpBytePipe;

    // Buffer used by the byte pipe.
    BYTE                m_rgbBytePipeBuffer[ ms_nFILE_PIPE_BUFFER_SIZE ];

}; //*** class CClusDBJoin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdbform.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDBForm.cpp
//
//  Description:
//      Contains the definition of the CClusDBForm class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDBForm.h"

// For the CBaseClusterForm class.
#include "CBaseClusterForm.h"

// For UUID related utilities.
#include "CUuid.h"

// For CEnableThreadPrivilege
#include "CEnableThreadPrivilege.h"

// For the CStr class.
#include "CStr.h"

// For sending status reports.
#include "CStatusReport.h"

// For DwRemoveDirectory()
#include "Common.h"

// For inet_ntoa
#include <winsock2.h>


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// Section in the INF file that deals with populating the cluster hive.
#define CLUSDB_POPULATE_INF_SECTION_NAME                L"ClusDB_Form"

// A placeholder for the cluster group key name in the cluster registry.
#define CLUSREG_KEYNAME_CLUSTERGROUP_PLACEHOLDER        L"ClusterGroupGUIDPlaceholder"

// A placeholder for the cluster name resource key name in the cluster registry.
#define CLUSREG_KEYNAME_CLUSTERNAME_RES_PLACEHOLDER     L"ClusterNameResGUIDPlaceHolder"

// A placeholder for the cluster IP address resource key name in the cluster registry.
#define CLUSREG_KEYNAME_CLUSTERIP_RES_PLACEHOLDER       L"ClusterIPAddrResGUIDPlaceHolder"

// A placeholder for the local quorum resource key name in the cluster registry.
#define CLUSREG_KEYNAME_LOCALQUORUM_RES_PLACEHOLDER     L"LocalQuorumResGUIDPlaceHolder"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::CClusDBForm
//
//  Description:
//      Constructor of the CClusDBForm class
//
//  Arguments:
//      pfaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBForm::CClusDBForm( CBaseClusterForm * pfaParentActionIn )
    : BaseClass( pfaParentActionIn )
{

    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CClusDBForm::CClusDBForm


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::~CClusDBForm
//
//  Description:
//      Destructor of the CClusDBForm class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDBForm::~CClusDBForm( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDBForm::~CClusDBForm


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::Commit
//
//  Description:
//      Create the cluster database. If anything goes wrong with the creation,
//      cleanup the tasks already done.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    //
    // Perform a ClusDB cleanup just to make sure that we do not use some files left over
    // from a previous install, aborted uninstall, etc.
    //

    LogMsg( "[BC-ClusDB-Commit] Cleaning up old cluster database files that may already exist before starting creation." );

    {
        CStatusReport   srCleanDB(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Cleaning_Up_Cluster_Database
            , 0, 1
            , IDS_TASK_CLEANINGUP_CLUSDB
            );

        // Send the next step of this status report.
        srCleanDB.SendNextStep( S_OK );

        CleanupHive();

        // Send the last step of this status report.
        srCleanDB.SendNextStep( S_OK );
    }

    try
    {
        // Create the cluster database
        Create();
        
    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC-ClusDB-Commit] Caught exception during commit." );

        //
        // Cleanup anything that the failed create operation might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupHive();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //
            HRESULT_FROM_WIN32( TW32( ERROR_CLUSCFG_ROLLBACK_FAILED ) );

            LogMsg( "[BC-ClusDB-Commit] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );
        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusDBForm::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::Rollback
//
//  Description:
//      Unload the cluster hive and cleanup any associated files.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup the cluster database.
    CleanupHive();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusDBForm::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::Create
//
//  Description:
//      Create the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          The parent action of this action is not CBaseClusterForm
//
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::Create( void )
{
    TraceFunc( "" );
    LogMsg( "[BC-ClusDB-Create] Attempting to create the cluster database required to create a cluster." );

    DWORD               sc = ERROR_SUCCESS;

    // Get the parent action pointer.
    CBaseClusterForm *  pcfClusterForm = dynamic_cast< CBaseClusterForm *>( PbcaGetParent() );

    CStatusReport       srCustomizingDB(
          PbcaGetParent()->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Form_Customizing_Cluster_Database
        , 0, 1
        , IDS_TASK_FORM_CUSTOMIZING_CLUSDB
        );

    // If the parent action of this action is not CBaseClusterForm
    if ( pcfClusterForm == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterForm." );
    } // an invalid pointer was passed in.

    // Create the cluster hive.
    {
        CStatusReport   srCreatingDB(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Form_Creating_Cluster_Database
            , 0, 1
            , IDS_TASK_FORM_CREATING_CLUSDB
            );

        // Send the next step of this status report.
        srCreatingDB.SendNextStep( S_OK );

        // Create an empty cluster hive in the registry.
        CreateHive( pcfClusterForm );

        // Send the last step of this status report.
        srCreatingDB.SendNextStep( S_OK );
    }

    // Send the next step of this status report.
    srCustomizingDB.SendNextStep( S_OK );

    // Fill up the newly created hive.
    PopulateHive( pcfClusterForm );

    //
    // Create the quorum directory and set its security attributes.
    //
    do
    {
        HANDLE          hQuorumDirHandle;
        const WCHAR *   pcszQuorumDir = pcfClusterForm->RStrGetLocalQuorumDirectory().PszData();

        // First, remove the local quorum directory, if it exists.
        sc = TW32( DwRemoveDirectory( pcszQuorumDir ) );
        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC-ClusDB-Create] The local quorum directory '%s' already exists, but error %#08x occurred trying to remove it.\n", pcszQuorumDir, sc );
            break;
        } // if: we could not remove the local quorum directory

        if ( CreateDirectory( pcszQuorumDir, NULL ) == FALSE )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC-ClusDB-Create] Error %#08x trying to create directory '%ws'", sc, pcszQuorumDir );
            break;
        } // if: the localquorum directory could not be created

        //
        // Enable the SE_BACKUP_PRIVILEGE and SE_RESTORE_PRIVILEGE.
        //
        // What we are doing here is that we are creating an object of
        // type CEnableThreadPrivilege. This object enables the privilege
        // in the constructor and restores it to its original state in the destructor.
        //

        CEnableThreadPrivilege etpAcquireBackupPrivilege( SE_BACKUP_NAME );
        CEnableThreadPrivilege etpAcquireRestorePrivilege( SE_RESTORE_NAME );

        //
        // Open a handle to the quorum directory. The calling thread should have SE_BACKUP_PRIVILEGE and
        // SE_RESTORE_PRIVILEGE enabled.
        //
        hQuorumDirHandle = CreateFile(
                              pcszQuorumDir
                            , GENERIC_ALL
                            , FILE_SHARE_WRITE
                            , NULL
                            , OPEN_EXISTING
                            , FILE_FLAG_BACKUP_SEMANTICS
                            , NULL 
                            );

        if ( hQuorumDirHandle == INVALID_HANDLE_VALUE )
        {
            // The directory does not exist. This is an error.
            sc = TW32( GetLastError() );
            LogMsg( "[BC-ClusDB-Create] The directory '%ws' does not exist.", pcszQuorumDir );
            break;
        } // if: the quorum directory does not exist.

        // Set the security for this directory.
        sc = TW32( ClRtlSetObjSecurityInfo(
                              hQuorumDirHandle
                            , SE_FILE_OBJECT
                            , GENERIC_ALL
                            , GENERIC_ALL
                            , 0
                            ) );

        // First close the handle we opened.
        CloseHandle( hQuorumDirHandle );

        if ( sc != ERROR_SUCCESS )
        {
            // ClRtlSetObjSecurityInfo() failed.
            LogMsg( "[BC-ClusDB-Create] Error %#08x from ClRtlSetObjSecurityInfo().", sc );
            break;
        } // if: ClRtlSetObjSecurityInfo() failed
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC-ClusDB-Create] Error %#08x occurred while trying to create the local quorum directory. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_QUORUM_DIR_CREATE );
    } // if: something went wrong.

    // Send the last step of this status report.
    srCustomizingDB.SendNextStep( S_OK );

    TraceFuncExit();

} //*** CClusDBForm::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::PopulateHive
//
//  Description:
//      Make the entries required by the cluster service in the hive.
//
//  Arguments:
//      pcfClusterFormIn
//          Pointer to the CBaseClusterForm object which contains this object.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::PopulateHive( CBaseClusterForm * pcfClusterFormIn )
{
    TraceFunc( "" );
    LogMsg( "[BC] Populating the cluster hive." );

    DWORD sc = ERROR_SUCCESS;

    do
    {
        DWORD                   dwSDSize = 0;

        CRegistryKey rkClusterHiveRoot(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_CLUSTER
            , KEY_ALL_ACCESS
            );

        if ( SetupInstallFromInfSection(
              NULL                                          // optional, handle of a parent window
            , pcfClusterFormIn->HGetMainInfFileHandle()     // handle to the INF file
            , CLUSDB_POPULATE_INF_SECTION_NAME              // name of the Install section
            , SPINST_REGISTRY                               // which lines to install from section
            , rkClusterHiveRoot.HGetKey()                   // optional, key for registry installs
            , NULL                                          // optional, path for source files
            , 0                                             // optional, specifies copy behavior
            , NULL                                          // optional, specifies callback routine
            , NULL                                          // optional, callback routine context
            , NULL                                          // optional, device information set
            , NULL                                          // optional, device info structure
            ) == FALSE
           )
        {
            sc = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x returned from SetupInstallFromInfSection while trying to populate the cluster hive.", sc );
            break;
        } // if: SetupInstallServicesFromInfSection failed

        LogMsg( "[BC] Basic hive structure created." );

        // Set the cluster name.
        rkClusterHiveRoot.SetValue(
              CLUSREG_NAME_CLUS_NAME
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pcfClusterFormIn->RStrGetClusterNetBIOSName().PszData() )
            , ( pcfClusterFormIn->RStrGetClusterNetBIOSName().NGetLen() + 1 ) * sizeof( WCHAR )
            );

        //
        // Set the default cluster security descriptor.
        //
        {
            SECURITY_DESCRIPTOR *   psdSecurityDescriptor = NULL;

            // Build the security descriptor.
            sc = TW32( ClRtlBuildDefaultClusterSD(
                                  pcfClusterFormIn->PSidGetServiceAccountSID()
                                , reinterpret_cast< void ** >( &psdSecurityDescriptor )
                                , &dwSDSize
                                ) );

            // Assign it to a smart pointer for safe release.
            CSmartResource<
                CHandleTrait< 
                      HLOCAL
                    , HLOCAL
                    , LocalFree
                    >
                >
                smartSD( reinterpret_cast< HLOCAL >( psdSecurityDescriptor ) );

            if ( sc != ERROR_SUCCESS )
            {
                LogMsg( "[BC] Error %#08x returned from ClRtlBuildDefaultClusterSD().", sc );
                break;
            } // if: ClRtlBuildDefaultClusterSD() failed.

            // Set the security descriptor in the registry.
            rkClusterHiveRoot.SetValue(
                  CLUSREG_NAME_CLUS_SD
                , REG_BINARY
                , reinterpret_cast< const BYTE * >( psdSecurityDescriptor )
                , dwSDSize
                );

            // Set the NT4 version of the security descriptor in the registry.
            rkClusterHiveRoot.SetValue(
                  CLUSREG_NAME_CLUS_SECURITY
                , REG_BINARY
                , reinterpret_cast< const BYTE * >( psdSecurityDescriptor )
                , dwSDSize
                );
        }

        LogMsg( "[BC] Cluster common properties set." );

        //
        // Set the values under the HKLM\Cluster\Nodes key.
        //
        {
            DWORD   dwTemp;

            CRegistryKey rkNodesKey(
                  rkClusterHiveRoot.HGetKey()
                , CLUSREG_KEYNAME_NODES
                , KEY_WRITE
                );

            CRegistryKey rkThisNodeKey;

            // Create a subkey for this node.
            rkThisNodeKey.CreateKey(
                  rkNodesKey.HGetKey()
                , pcfClusterFormIn->PszGetNodeIdString()
                );

            // Set the node name.
            rkThisNodeKey.SetValue(
                  CLUSREG_NAME_NODE_NAME
                , REG_SZ
                , reinterpret_cast< const BYTE *>( pcfClusterFormIn->PszGetNodeName() )
                , ( pcfClusterFormIn->DwGetNodeNameLength() + 1 ) * sizeof( WCHAR )
                );

            // Set the node highest version.
            dwTemp = pcfClusterFormIn->DwGetNodeHighestVersion();
            rkThisNodeKey.SetValue(
                  CLUSREG_NAME_NODE_HIGHEST_VERSION
                , REG_DWORD
                , reinterpret_cast< const BYTE *>( &dwTemp )
                , sizeof( dwTemp )
                );

            // Set the node lowest version.
            dwTemp = pcfClusterFormIn->DwGetNodeLowestVersion();
            rkThisNodeKey.SetValue(
                  CLUSREG_NAME_NODE_LOWEST_VERSION
                , REG_DWORD
                , reinterpret_cast< const BYTE *>( &dwTemp )
                , sizeof( dwTemp )
                );
        }

        LogMsg( "[BC] Cluster node subtree customized." );

        // Customize the cluster group and the core resources.
        CustomizeClusterGroup( pcfClusterFormIn, rkClusterHiveRoot );

        // Flush the changes to the registry.
        RegFlushKey( rkClusterHiveRoot.HGetKey() );

        LogMsg( "[BC] Cluster hive successfully populated." );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred while trying to populate the cluster hive. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDB_POPULATE_HIVE );
    } // if: something went wrong.

    TraceFuncExit();

} //*** CClusDBForm::PopulateHive


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDBForm::CustomizeClusterGroup
//
//  Description:
//      Customize the cluster group and the core resources.
//
//  Arguments:
//      pcfClusterFormIn
//          Pointer to the CBaseClusterForm object which contains this object.
//
//      rkClusterHiveRootIn
//          A CRegistryKey object representing the  root of the cluster hive.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the called functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDBForm::CustomizeClusterGroup(
      CBaseClusterForm * pcfClusterFormIn
    , CRegistryKey &     rkClusterHiveRootIn
    )
{
    TraceFunc( "" );

    // UUIDs of the cluster group and core resources.
    CUuid           uuidClusterGroupUuid;
    CUuid           uuidClusterIPAddressResourceUuid;
    CUuid           uuidClusterNameResourceUuid;
    CUuid           uuidLocalQuorumResourceUuid;

    // The lengths of the string versions of the above UUIDs.
    UINT            uiIPUuidLen             = (UINT) wcslen( uuidClusterIPAddressResourceUuid.PszGetUuidString() );
    UINT            uiNameUuidLen           = (UINT) wcslen( uuidClusterNameResourceUuid.PszGetUuidString() );
    UINT            uiLocalQuorumUuidLen    = (UINT) wcslen( uuidLocalQuorumResourceUuid.PszGetUuidString() );

    UINT            uiUuidLen;

    // Length of the multisz string that can hold the above resource UUIDs.
    uiUuidLen = 
        ( ( uiIPUuidLen + 1 )
        + ( uiNameUuidLen + 1 )
        + ( uiLocalQuorumUuidLen + 1 )
        + 1
        );

    // Allocate a buffer for this multisz string.
    SmartSz  sszResourceUuids( new WCHAR[ uiUuidLen ] );

    // Was the memory successfully allocated?
    if ( sszResourceUuids.FIsEmpty() )
    {
        LogMsg( "[BC] Could not allocate %d character in memory. Throwing an exception.", uiUuidLen );
        THROW_RUNTIME_ERROR(
              E_OUTOFMEMORY
            , IDS_ERROR_CUSTOMIZE_CLUSTER_GROUP
            );
    } // if: memory allocation failed.

    //
    // Fill this buffer with the uuids of the core resources.
    //

    // Make sure that the IP address uuid is the first string in this multisz string.
    // This is buffer is reused during setting of the network name dependency on the 
    // IP address resource.
    CopyMemory( 
          sszResourceUuids.PMem()
        , uuidClusterIPAddressResourceUuid.PszGetUuidString()
        , ( uiIPUuidLen + 1 ) * sizeof( WCHAR )
        );

    CopyMemory( 
          sszResourceUuids.PMem() + uiIPUuidLen + 1
        , uuidClusterNameResourceUuid.PszGetUuidString()
        , ( uiNameUuidLen + 1 ) * sizeof( WCHAR )
        );

    CopyMemory( 
          sszResourceUuids.PMem() + uiIPUuidLen + uiNameUuidLen + 2 
        , uuidLocalQuorumResourceUuid.PszGetUuidString()
        , ( uiLocalQuorumUuidLen + 1 ) * sizeof( WCHAR )
        );

    ( sszResourceUuids.PMem() )[ uiUuidLen - 1 ] = L'\0';


    //
    // Customize the cluster group.
    //
    {
        CRegistryKey    rkClusterGroupKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_GROUPS L"\\" CLUSREG_KEYNAME_CLUSTERGROUP_PLACEHOLDER
            , KEY_WRITE
            );

        // Replace the placeholder for the cluster group key with an actual UUID.
        rkClusterGroupKey.RenameKey( uuidClusterGroupUuid.PszGetUuidString() );

        // Set the list of contained resources uuids.
        rkClusterGroupKey.SetValue(
              CLUSREG_NAME_GRP_CONTAINS
            , REG_MULTI_SZ
            , reinterpret_cast< const BYTE * >( sszResourceUuids.PMem() )
            , uiUuidLen * sizeof( WCHAR )
            );

        LogMsg( "[BC] Cluster group customized." );
    }

    //
    // Customize the localquorum resource and update the HKLM\Quorum key.
    //
    {
        CRegistryKey    rkLocalQuorumResourceKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_KEYNAME_LOCALQUORUM_RES_PLACEHOLDER
            , KEY_WRITE
            );

        CRegistryKey    rkQuorumKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_QUORUM
            , KEY_WRITE
            );

        // Replace the placeholder for the localquorum resource key with an actual UUID.
        rkLocalQuorumResourceKey.RenameKey( uuidLocalQuorumResourceUuid.PszGetUuidString() );

        // Set the uuid of the localquorum resource under the HKLM\Quorum key
        rkQuorumKey.SetValue(
              CLUSREG_NAME_QUORUM_RESOURCE
            , REG_SZ
            , reinterpret_cast< const BYTE * >( uuidLocalQuorumResourceUuid.PszGetUuidString() )
            , ( uiLocalQuorumUuidLen + 1 ) * sizeof( WCHAR )
            );

        LogMsg( "[BC] Localquorum resource customized." );
    }

    //
    // Set the cluster IP address resource private properties.
    //
    {
        CRegistryKey    rkClusterIPResourceKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_KEYNAME_CLUSTERIP_RES_PLACEHOLDER
            , KEY_WRITE
            );

        LPSTR           pszAddr;    // don't free!
        WCHAR           szIPBuffer[ 3 + 1 + 3 + 1 + 3 + 1 + 3 + 1 ]; // "xxx.xxx.xxx.xxx\0"
        DWORD           dwTemp;
        int             cchWideFormat = 0;

        // Replace the placeholder for the cluster IP address resource key with an actual UUID.
        rkClusterIPResourceKey.RenameKey( uuidClusterIPAddressResourceUuid.PszGetUuidString() );

        // Create the cluster IP address parameters registry key.
        CRegistryKey    rkIPResParams;
        
        rkIPResParams.CreateKey(
              rkClusterIPResourceKey.HGetKey()
            , CLUSREG_KEYNAME_PARAMETERS
            );

        // Format the cluster IP address into a dotted quad.
        dwTemp = pcfClusterFormIn->DwGetIPAddress();
        pszAddr = inet_ntoa( * (struct in_addr *) &dwTemp );
        if ( pszAddr == NULL )
        {
            LogMsg( "[BC] inet_ntoa() returned NULL. Mapping it to E_OUTOFMEMORY." );
            THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSDB_POPULATE_HIVE );
        }
        cchWideFormat = MultiByteToWideChar(
                              CP_ACP
                            , 0
                            , pszAddr
                            , -1
                            , szIPBuffer
                            , ARRAYSIZE( szIPBuffer )
                            );
        if ( cchWideFormat == 0 )
        {
            DWORD sc = TW32( GetLastError() );
            LogMsg( "[BC] MultiByteToWideChar failed with error %#08x .", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CUSTOMIZE_CLUSTER_GROUP );
        }
            
        // Write the IP address to the registry.
        rkIPResParams.SetValue(
              CLUSREG_NAME_IPADDR_ADDRESS
            , REG_SZ
            , reinterpret_cast< const BYTE * >( szIPBuffer )
            , ( (UINT) wcslen( szIPBuffer ) + 1 ) * sizeof(WCHAR)
            );

        // Format the cluster IP subnet mask into a dotted quad.
        dwTemp = pcfClusterFormIn->DwGetIPSubnetMask();
        pszAddr = inet_ntoa( * (struct in_addr *) &dwTemp );
        if ( pszAddr == NULL )
        {
            LogMsg( "[BC] inet_ntoa() returned NULL. Mapping it to E_OUTOFMEMORY." );
            THROW_RUNTIME_ERROR( E_OUTOFMEMORY, IDS_ERROR_CLUSDB_POPULATE_HIVE );
        }
        cchWideFormat = MultiByteToWideChar(
                              CP_ACP
                            , 0
                            , pszAddr
                            , -1
                            , szIPBuffer
                            , ARRAYSIZE( szIPBuffer )
                            );
        if ( cchWideFormat == 0 )
        {
            DWORD sc = TW32( GetLastError() );
            LogMsg( "[BC] MultiByteToWideChar failed with error %#08x .", sc );
            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CUSTOMIZE_CLUSTER_GROUP );
        }

        // Write the IP subnet mask to the registry.
        rkIPResParams.SetValue(
              CLUSREG_NAME_IPADDR_SUBNET_MASK
            , REG_SZ
            , reinterpret_cast< const BYTE * >( szIPBuffer )
            , ( (UINT) wcslen( szIPBuffer ) + 1 ) * sizeof(WCHAR)
            );

        // Write the IP address network to the registry.
        rkIPResParams.SetValue(
              CLUSREG_NAME_IPADDR_NETWORK
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pcfClusterFormIn->RStrGetClusterIPNetwork().PszData() )
            , ( pcfClusterFormIn->RStrGetClusterIPNetwork().NGetLen() + 1 ) * sizeof( WCHAR )
            );

        LogMsg( "[BC] IP address resource customized." );
    }

    //
    // Set the cluster network name resource private properties and dependencies.
    //
    {
        CRegistryKey    rkClusterNameResourceKey(
              rkClusterHiveRootIn.HGetKey()
            , CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_KEYNAME_CLUSTERNAME_RES_PLACEHOLDER
            , KEY_WRITE
            );

        // Replace the placeholder for the network name resource key with an actual UUID.
        rkClusterNameResourceKey.RenameKey( uuidClusterNameResourceUuid.PszGetUuidString() );

        //
        // Indicate that the network name resource depends on the IP address resource.
        //
        ( sszResourceUuids.PMem() )[ uiIPUuidLen + 1 ] = L'\0';

        rkClusterNameResourceKey.SetValue(
              CLUSREG_NAME_RES_DEPENDS_ON
            , REG_MULTI_SZ
            , reinterpret_cast< const BYTE * >( sszResourceUuids.PMem() )
            , ( uiIPUuidLen + 2 ) * sizeof( WCHAR )
            );

        //
        // Create the cluster name parameters registry key.
        //
        CRegistryKey    rkNetNameResParams;
        
        rkNetNameResParams.CreateKey(
              rkClusterNameResourceKey.HGetKey()
            , CLUSREG_KEYNAME_PARAMETERS
            );

        // Write the cluster name to the registry.
        rkNetNameResParams.SetValue(
              CLUSREG_NAME_NETNAME_NAME
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pcfClusterFormIn->RStrGetClusterNetBIOSName().PszData() )
            , ( pcfClusterFormIn->RStrGetClusterNetBIOSName().NGetLen() + 1 ) * sizeof( WCHAR )
            );

        // Store the UUID of the network name resource under HKLM\Cluster\ClusterNameResource.
        rkClusterHiveRootIn.SetValue(
              CLUSREG_NAME_CLUS_CLUSTER_NAME_RES
            , REG_SZ
            , reinterpret_cast< const BYTE * >( uuidClusterNameResourceUuid.PszGetUuidString() )
            , ( uiNameUuidLen + 1 ) * sizeof( WCHAR )
            );


        LogMsg( "[BC] Network name resource customized." );
    }

    LogMsg( "[BC] Cluster group and core resources customized." );

    TraceFuncExit();

} //*** CClusDBForm::CustomizeClusterGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskCleanup.h
//
//  Description:
//      Header file for CClusDiskCleanup class.
//      The CClusDiskCleanup class is an action that cleans up the ClusDisk service.
//
//  Implementation Files:
//      CClusDiskCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDisk base class
#include "CClusDisk.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDiskCleanup
//
//  Description:
//      The CClusDiskCleanup class is an action that clean up the ClusDisk service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDiskCleanup : public CClusDisk
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDiskCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusDiskCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusDisk service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDisk BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusDiskCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CClusDisk.cpp
//
//  Description:
//      Contains the definition of the CClusDisk class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDisk.h"

// Required by clusdisk.h
#include <ntddscsi.h>

// For IOCTL_DISK_CLUSTER_ATTACH and IOCTL_DISK_CLUSTER_DETACH
#include <clusdisk.h>


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// The name of the ClusDisk service
#define CLUSDISK_SERVICE_NAME           L"ClusDisk"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::CClusDisk
//
//  Description:
//      Constructor of the CClusDisk class. Opens a handle to the service.
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDisk::CClusDisk(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_cservClusDisk( CLUSDISK_SERVICE_NAME )
    , m_pbcaParentAction( pbcaParentActionIn )
{

    TraceFunc( "" );

    if ( m_pbcaParentAction == NULL)
    {
        LogMsg( "[BC] Pointers to the parent action is NULL. Throwing an exception." );
        THROW_ASSERT(
              E_INVALIDARG
            , "CClusDisk::CClusDisk() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

    //
    // The ClusDisk service has been created at the time the cluster binaries were
    // installed. So, get a handle to the ClusDisk service.
    //

    SmartSCMHandle  sscmhTempHandle(
        OpenService(
              pbcaParentActionIn->HGetSCMHandle()
            , CLUSDISK_SERVICE_NAME
            , SERVICE_ALL_ACCESS
            )
        );

    // Did we get a handle to the service?
    if ( sscmhTempHandle.FIsInvalid() )
    {
        DWORD   sc = TW32( GetLastError() );

        LogMsg( "[BC] Error %#08x occurred trying to open a handle to the ClusDisk service. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDISK_OPEN );
    } // if: OpenService failed

    // Initialize the member variable.
    m_sscmhServiceHandle = sscmhTempHandle;

    TraceFuncExit();

} //*** CClusDisk::CClusDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::~CClusDisk
//
//  Description:
//      Destructor of the CClusDisk class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDisk::~CClusDisk( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDisk::~CClusDisk


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::ConfigureService
//
//  Description:
//      This function enables and starts the ClusDisk service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::ConfigureService( void )
{
    TraceFunc( "" );
    LogMsg( "[BC] Configuring the ClusDisk service." );

    bool fIsRunning;

    {
        CStatusReport   srConfigClusDisk(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Configuring_ClusDisk_Service
            , 0, 1
            , IDS_TASK_CONFIG_CLUSDISK
            );

        // Send the next step of this status report.
        srConfigClusDisk.SendNextStep( S_OK );

        //
        // First, initialize the ClusDisk service to make sure that it does not retain
        // any state from another cluster that this node may have been a part of.
        //
        fIsRunning = FInitializeState();

        //
        // Enable the service.
        //
        if ( ChangeServiceConfig(
                  m_sscmhServiceHandle.HHandle()    // handle to service
                , SERVICE_NO_CHANGE                 // type of service
                , SERVICE_SYSTEM_START              // when to start service
                , SERVICE_NO_CHANGE                 // severity of start failure
                , NULL                              // service binary file name
                , NULL                              // load ordering group name
                , NULL                              // tag identifier
                , NULL                              // array of dependency names
                , NULL                              // account name
                , NULL                              // account password
                , NULL                              // display name
                )
             == FALSE
           )
        {
            DWORD sc = TW32( GetLastError() );

            LogMsg( "[BC] Could not enable the ClusDisk service. Error %#08x. Throwing an exception.", sc );

            THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDISK_CONFIGURE );
        } // if: we could not enable the service.

        // Send the last step of this status report.
        srConfigClusDisk.SendNextStep( S_OK );
    }

    LogMsg( "[BC] The ClusDisk service has been enabled." );

    {
        UINT    cQueryCount = 10;

        CStatusReport   srStartClusDisk(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Starting_ClusDisk_Service
            , 1, cQueryCount + 2    // we will send at most cQueryCount reports while waiting for the service to start (the two extra sends are below)
            , IDS_TASK_STARTING_CLUSDISK
            );

        // Send the next step of this status report.
        srStartClusDisk.SendNextStep( S_OK );

        // This call does not actually create the service - it creates the registry entries needed
        // by ClusDisk.
        m_cservClusDisk.Create( m_pbcaParentAction->HGetMainInfFileHandle() );

        // If the service was not already running, start the service.
        if ( ! fIsRunning )
        {
            m_cservClusDisk.Start(
                  m_pbcaParentAction->HGetSCMHandle()
                , true              // wait for the service to start
                , 500               // wait 500ms between queries for status.
                , cQueryCount       // query cQueryCount times.
                , &srStartClusDisk  // status report to be sent while waiting for the service to start
                );
        } // if: ClusDisk was not already running.
        else
        {
            // Nothing more need be done.
            LogMsg( "[BC] ClusDisk is already running." );
        } // else: ClusDisk is already running.

        LogMsg( "[BC] The ClusDisk service has been successfully configured and started." );

        // Send the last step of this status report.
        srStartClusDisk.SendLastStep( S_OK );
    }

    TraceFuncExit();

} //*** CClusDisk::ConfigureService


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::CleanupService
//
//  Description:
//      This function enables and starts the ClusDisk service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::CleanupService( void )
{
    TraceFunc( "" );
    LogMsg( "[BC] Cleaning up the ClusDisk service." );

    //
    // First, initialize the ClusDisk service to make sure that it does not retain
    // any state from this cluster.
    //
    FInitializeState();

    //
    // Disable the service.
    //
    if ( ChangeServiceConfig(
              m_sscmhServiceHandle.HHandle()    // handle to service
            , SERVICE_NO_CHANGE                 // type of service
            , SERVICE_DISABLED                  // when to start service
            , SERVICE_NO_CHANGE                 // severity of start failure
            , NULL                              // service binary file name
            , NULL                              // load ordering group name
            , NULL                              // tag identifier
            , NULL                              // array of dependency names
            , NULL                              // account name
            , NULL                              // account password
            , NULL                              // display name
            )
         == FALSE
       )
    {
        DWORD sc = TW32( GetLastError() );

        LogMsg( "[BC] Could not disable the ClusDisk service. Error %#08x. Throwing an exception.", sc );

        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDISK_CLEANUP );
    } // if: we could not enable the service.

    LogMsg( "[BC] The ClusDisk service has been successfully cleaned up and disabled." );

    TraceFuncExit();

} //*** CClusDisk::CleanupService


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::FInitializeState
//
//  Description:
//      This function initializes the ClusDisk service and brings it back to
//      its ground state.
//
//      If the service is running, then ClusDisk is asked to detach
//      itself from all the disks that it is currently attached to.
//
//      If the service is not running, then its parameters key is deleted
//      so as to prevent ClusDisk from reusing any keys leftover from a previous
//      cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Returns true is the service was running before the initialization began.
//      Returns false if it was not.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
bool
CClusDisk::FInitializeState( void )
{
    TraceFunc( "" );

    LogMsg( "[BC] Initializing ClusDisk service state.");

    bool            fIsRunning = false;   // Initially set to false: ClusDisk is not running, true: ClusDisk is running.
    DWORD           sc = ERROR_SUCCESS;

    SERVICE_STATUS  ssStatus;

    //
    // Check if the service is running.
    //
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );

    // Query the service for its status.
    if ( QueryServiceStatus(
            m_sscmhServiceHandle.HHandle()
            , &ssStatus
            )
         == 0
       )
    {
        sc = TW32( GetLastError() );
        LogMsg( "Error %#08x occurred while trying to query ClusDisk status. Throwing an exception.", sc );

        goto Cleanup;
    } // if: we could not query the service for its status.

    if ( ssStatus.dwCurrentState == SERVICE_RUNNING )
    {
        LogMsg( "[BC] The ClusDisk service is already running. It will be detached from all disks." );

        // ClusDisk is running.
        fIsRunning = true;

        // Make sure that it is not attached to any disks already.
        DetachFromAllDisks();
    } // if: the service is running.
    else
    {
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            LogMsg( "[BC] The ClusDisk service is not running. Its registry will be cleaned up." );

            // Call the cleanup routine of the embedded service object.
            m_cservClusDisk.Cleanup( m_pbcaParentAction->HGetMainInfFileHandle() );
        } // if: the service is stopped
        else
        {
            sc = TW32( ERROR_INVALID_HANDLE_STATE );
            LogMsg( "[BC] ClusDisk is in an incorrect state (%#08x).", ssStatus.dwCurrentState );
            goto Cleanup;
        } // else: the service is in some other state.
    } // else: ClusDisk is not running.

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying initialize the ClusDisk service state. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

    LogMsg( "[BC] The ClusDisk service state has been successfully initialized.");

    RETURN( fIsRunning );

} //*** CClusDisk::FInitializeState


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::DetachFromAllDisks
//
//  Description:
//      This function detaches ClusDisk from all the disks that it is currently
//      attached to. A prerequisite for calling this function is that the
//      ClusDisk service is running.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::DetachFromAllDisks( void )
{
    TraceFunc( "" );

    LONG                lError = ERROR_SUCCESS;

    LogMsg( "[BC] Detaching the ClusDisk service from all disks." );

    do
    {
        CRegistryKey        rkSignaturesKey;
        DWORD               dwSignatureCount = 0;
        DWORD               dwMaxSignatureNameLen = 0;
        DWORD               dwSignatureIndex = 0;

        // Try and open the ClusDisk signatures key.
        try
        {
            rkSignaturesKey.OpenKey(
                  HKEY_LOCAL_MACHINE
                , L"System\\CurrentControlSet\\Services\\ClusDisk\\Parameters\\Signatures"
                , KEY_ALL_ACCESS
                );
        } // try: to open the ClusDisk signatures key.
        catch( CRuntimeError & rteException )
        {
            //
            // If we are here, then OpenKey threw a CRuntimeError.Check if the
            // error was ERROR_FILE_NOT_FOUND. This means that the key does
            // not exist and we are done.
            //
            // Otherwise, some other error ocurred, so rethrow the exception.
            //

            if ( rteException.HrGetErrorCode() == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
            {
                // There is nothing else to do.
                break;
            } // if: the ClusDisk parameters key does not exist.

            // Some other error occurred.
            throw;
        } // catch( CRuntimeError & )

        //
        // Find out the number of signatures and the maximum length of the signature
        // key names.
        //
        lError = TW32( RegQueryInfoKeyW(
                          rkSignaturesKey.HGetKey()     // handle to key
                        , NULL                          // class buffer
                        , NULL                          // size of class buffer
                        , NULL                          // reserved
                        , &dwSignatureCount             // number of subkeys
                        , &dwMaxSignatureNameLen        // longest subkey name
                        , NULL                          // longest class string
                        , NULL                          // number of value entries
                        , NULL                          // longest value name
                        , NULL                          // longest value data
                        , NULL                          // descriptor length
                        , NULL                          // last write time
                        ) );

        if ( lError != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x from RegQueryInfoKeyW() querying the number of signatures.", lError );
            break;
        } // if: RegQueryInfoKeyW() failed.

        // Account for the terminating '\0'
        ++dwMaxSignatureNameLen;

        // Allocate the memory required to hold the signatures.
        CSmartGenericPtr< CArrayPtrTrait< DWORD > > rgdwSignatureArrayIn( new DWORD[ dwSignatureCount ] );
        if ( rgdwSignatureArrayIn.FIsEmpty() )
        {
            lError = TW32( ERROR_OUTOFMEMORY );
            LogMsg( "[BC] Erro allocating %d bytes required for the signature array.", dwSignatureCount );
            break;
        } // if:memory allocation failed.

        // Allocate the memory required for the signature string.
        SmartSz sszSignatureKeyName( new WCHAR[ dwMaxSignatureNameLen ] );
        if ( sszSignatureKeyName.FIsEmpty() )
        {
            lError = TW32( ERROR_OUTOFMEMORY );
            LogMsg( "[BC] Error allocating %d bytes required for the longest signature key name.", dwMaxSignatureNameLen );
            break;
        } // if:memory allocation failed.


        //
        // Iterate through the list of signatures that ClusDisk is currently attached
        // to and add each of them to the array of signatures. We cannot detach as
        // we enumerate since ClusDisk removes the signature key when it detaches from
        // a disk and RegEnumKeyEx requires that the key being enumerated not change
        // during an enumeration.
        //
        do
        {
            DWORD       dwTempSize = dwMaxSignatureNameLen;
            WCHAR *     pwcCharPtr;

            lError = RegEnumKeyExW(
                              rkSignaturesKey.HGetKey()
                            , dwSignatureIndex
                            , sszSignatureKeyName.PMem()
                            , &dwTempSize
                            , NULL
                            , NULL
                            , NULL
                            , NULL
                            );

            if ( lError != ERROR_SUCCESS )
            {
                if ( lError == ERROR_NO_MORE_ITEMS )
                {
                    lError = ERROR_SUCCESS;
                } // if: we are at the end of the enumeration
                else
                {
                    TW32( lError );
                    LogMsg( "[BC] Error %#08x from RegEnumKeyEx(). Index = %d.", lError, dwSignatureIndex );
                } // else: something else went wrong

                break;
            } // if: RegEnumKeyEx() did not succeed

            LogMsg( "[BC] Signature %d is '%s'.", dwSignatureIndex + 1, sszSignatureKeyName.PMem() );

            // Convert the key name to a hex number.
            ( rgdwSignatureArrayIn.PMem() )[ dwSignatureIndex ] =
                wcstoul( sszSignatureKeyName.PMem(), &pwcCharPtr, 16 );

            // Did the conversion succeed.
            if ( sszSignatureKeyName.PMem() == pwcCharPtr )
            {
                lError = TW32( ERROR_INVALID_PARAMETER );
                TraceFlow( "_wcstoul() failed." );
                break;
            } // if: the conversion of the signature string to a number failed.

            // Increment the index.
            ++dwSignatureIndex;
        }
        while( true ); // loop infinitely

        if ( lError != ERROR_SUCCESS )
        {
            break;
        } // if: something went wrong

        // Detach ClusDisks from all the disks we found it attached to.
        DetachFromDisks(
              rgdwSignatureArrayIn.PMem()
            , dwSignatureCount
            );

    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( lError != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying detach ClusDisk from all the disks. Throwing an exception.", lError );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( lError ), IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

    LogMsg( "[BC] The ClusDisk service has been successfully detached from all disks." );

    TraceFuncExit();

} //*** CClusDisk::DetachFromAllDisks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::DetachFromDisks
//
//  Description:
//      This function detaches ClusDisk from the disks specified
//      by a list of signatures. A prerequisite for calling this function is
//      that the ClusDisk service is running.
//
//  Arguments:
//      rgdwSignatureArrayIn
//          Array of signatures of disks to detach from.
//
//      uiArraySizeIn
//          Number of signatures in above array.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::DetachFromDisks(
      DWORD   rgdwSignatureArrayIn[]
    , UINT    uiArraySizeIn
    )
{
    TraceFunc( "" );

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    UNICODE_STRING      ustrClusDiskDeviceName;
    OBJECT_ATTRIBUTES   oaClusDiskAttrib;
    HANDLE              hClusDisk;
    IO_STATUS_BLOCK     iosbIoStatusBlock;
    DWORD               dwTempSize = 0;

    LogMsg( "[BC] Trying to detach from %d disks.", uiArraySizeIn );

    //
    //  If the list is empty then leave since there are no disks to detach
    //  from.
    //
    if ( ( uiArraySizeIn == 0 ) || ( rgdwSignatureArrayIn == NULL ) )
    {
        goto Cleanup;
    } // if:

    // Initialize the unicode string with the name of the ClusDisk device.
    RtlInitUnicodeString( &ustrClusDiskDeviceName, L"\\Device\\ClusDisk0" );

    InitializeObjectAttributes(
          &oaClusDiskAttrib
        , &ustrClusDiskDeviceName
        , OBJ_CASE_INSENSITIVE
        , NULL
        , NULL
        );

    LogMsg( "[BC] Trying to get a handle to the ClusDisk device." );

    // Get a handle to the ClusDisk device.
    ntStatus = THR( NtCreateFile(
                          &hClusDisk
                        , SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA
                        , &oaClusDiskAttrib
                        , &iosbIoStatusBlock
                        , NULL
                        , FILE_ATTRIBUTE_NORMAL
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , FILE_OPEN
                        , 0
                        , NULL
                        , 0
                        ) );
    if ( NT_SUCCESS( ntStatus ) == FALSE )
    {
        LogMsg( "[BC] Error %#08x trying to get a handle to the ClusDisk device.", ntStatus );
        goto Cleanup;
    } // if: NtCreateFile failed.

    {   // new block so that that the file handle is closed.
        // Assign the opened file handle to a smart handle for safe closing.
        CSmartResource<
            CHandleTrait<
                  HANDLE
                , NTSTATUS
                , NtClose
                >
            > snthClusDiskHandle( hClusDisk );

        // Detach ClusDisk from this disk.
        if ( DeviceIoControl(
                  hClusDisk
                , IOCTL_DISK_CLUSTER_DETACH_LIST
                , rgdwSignatureArrayIn
                , uiArraySizeIn * sizeof( rgdwSignatureArrayIn[ 0 ] )
                , NULL
                , 0
                , &dwTempSize
                , FALSE
                )
             == FALSE
            )
        {
            ntStatus = TW32( GetLastError() );
            LogMsg( "[BC] Error %#08x from DeviceIoControl() getting signature list.", ntStatus  );
            ntStatus = HRESULT_FROM_WIN32( ntStatus );
        } // if: DeviceIoControl() failed
    }

Cleanup:

    if ( ntStatus != STATUS_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to detach ClusDisk from a disk. Throwing an exception.", ntStatus );
        THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

    TraceFuncExit();

} //*** CClusDisk::DetachFromDisks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::AttachToDisks
//
//  Description:
//      This function attaches ClusDisk to the disks specified
//      by a list of signatures. A prerequisite for calling this function is
//      that the ClusDisk service is running.
//
//  Arguments:
//      rgdwSignatureArrayIn
//          Array of signatures of disks to attach to.
//
//      uiArraySizeIn
//          Number of signatures in above array.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDisk::AttachToDisks(
      DWORD   rgdwSignatureArrayIn[]
    , UINT    uiArraySizeIn
    )
{
    TraceFunc( "" );

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    UNICODE_STRING      ustrClusDiskDeviceName;
    OBJECT_ATTRIBUTES   oaClusDiskAttrib;
    HANDLE              hClusDisk;
    IO_STATUS_BLOCK     iosbIoStatusBlock;
    DWORD               dwTempSize = 0;

    LogMsg( "[BC] Trying to attach to %d disks.", uiArraySizeIn );

    //
    //  If the list is empty then leave since there are no disks to attach
    //  to.
    //
    if ( ( uiArraySizeIn == 0 ) || ( rgdwSignatureArrayIn == NULL ) )
    {
        goto Cleanup;
    } // if:

    // Initialize the unicode string with the name of the ClusDisk device.
    RtlInitUnicodeString( &ustrClusDiskDeviceName, L"\\Device\\ClusDisk0" );

    InitializeObjectAttributes(
          &oaClusDiskAttrib
        , &ustrClusDiskDeviceName
        , OBJ_CASE_INSENSITIVE
        , NULL
        , NULL
        );

    LogMsg( "[BC] Trying to get a handle to the ClusDisk device." );

    // Get a handle to the ClusDisk device.
    ntStatus = THR( NtCreateFile(
                          &hClusDisk
                        , SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA
                        , &oaClusDiskAttrib
                        , &iosbIoStatusBlock
                        , NULL
                        , FILE_ATTRIBUTE_NORMAL
                        , FILE_SHARE_READ | FILE_SHARE_WRITE
                        , FILE_OPEN
                        , 0
                        , NULL
                        , 0
                        ) );
    if ( NT_SUCCESS( ntStatus ) == FALSE )
    {
        LogMsg( "[BC] Error %#08x trying to get a handle to the ClusDisk device.", ntStatus );
        goto Cleanup;
    } // if: NtCreateFile failed.

    {   // new block so that that the file handle is closed.
        // Assign the opened file handle to a smart handle for safe closing.
        CSmartResource<
            CHandleTrait<
                  HANDLE
                , NTSTATUS
                , NtClose
                >
            > snthClusDiskHandle( hClusDisk );

        // Attach ClusDisk to this signature list.
        if ( DeviceIoControl(
                  hClusDisk
                , IOCTL_DISK_CLUSTER_ATTACH_LIST
                , rgdwSignatureArrayIn
                , uiArraySizeIn * sizeof( rgdwSignatureArrayIn[0] )
                , NULL
                , 0
                , &dwTempSize
                , FALSE
                )
             == FALSE
            )
        {
            ntStatus = GetLastError();
            LogMsg( "[BC] Error %#08x from DeviceIoControl() getting signature list.", ntStatus );
            ntStatus = HRESULT_FROM_WIN32( TW32( ntStatus ) );
        } // if: DeviceIoControl() failed
    }

Cleanup:

    if ( ntStatus != STATUS_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying attach ClusDisk to a disk. Throwing an exception.", ntStatus );
        THROW_RUNTIME_ERROR( ntStatus, IDS_ERROR_CLUSDISK_INITIALIZE );
    } // if: something has gone wrong

    TraceFuncExit();

} //*** CClusDisk::AttachToDisks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskform.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDiskForm.h
//
//  Description:
//      Header file for CClusDiskForm class.
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a form.
//
//  Implementation Files:
//      CClusDiskForm.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDisk base class
#include "CClusDisk.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterForm;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDiskForm
//
//  Description:
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a form.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDiskForm : public CClusDisk
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDiskForm(
          CBaseClusterForm * pbcfParentActionIn
        );

    // Default destructor.
    ~CClusDiskForm();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDisk service.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        return BaseClass::UiGetMaxProgressTicks();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusDisk BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusDiskForm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusDisk.h
//
//  Description:
//      Header file for CClusDisk class.
//      The CClusDisk class performs operations that are common to the 
//      configuration of the ClusDisk service.
//
//  Implementation Files:
//      CClusDisk.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the CService class
#include "CService.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDisk
//
//  Description:
//      The CClusDisk class performs operations that are common to many
//      configuration tasks of the ClusDisk service.
//
//      This class is intended to be used as the base class for other ClusDisk
//      related action classes.
//
//      NOTE: Currently, once started, the ClusDisk service cannot be stopped.
//      As a result, when a computer is evicted from a cluster, the ClusDisk
//      service is disabled and detached from all disks, but not stopped.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDisk : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDisk(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusDisk();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Enable and start service.
    void
        ConfigureService();

    // Disable and cleanup the service.
    void
        CleanupService();


    // Initialize the state of the service.
    bool
        FInitializeState();


    // Detach ClusDisk from all disks it is attached to.
    void
        DetachFromAllDisks();

    // Attach to specified disks.
    void
        AttachToDisks(
          DWORD   rgdwSignatureArrayIn[]
        , UINT    uiArraySizeIn
        );

    // Detach from specified disks.
    void
        DetachFromDisks(
          DWORD   rgdwSignatureArrayIn[]
        , UINT    uiArraySizeIn
        );

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // Two notifications are sent:
        // 1. When the service is created.
        // 2. When the service starts.
        return 2;
    }


    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the ClusDisk service object.
    CService &
        RcsGetService() throw()
    {
        return m_cservClusDisk;
    }

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }

    // Get the handle to the ClusDisk service.
    SC_HANDLE
        SchGetServiceHandle() const throw()
    {
        return m_sscmhServiceHandle.HHandle();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusDisk( const CClusDisk & );

    // Assignment operator
    const CClusDisk & operator =( const CClusDisk & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The CService object representing the ClusDisk service.
    CService                m_cservClusDisk;

    // A handle to this service.
    SmartSCMHandle          m_sscmhServiceHandle;

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusDisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDiskCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusDiskCleanup class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDiskCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskCleanup::CClusDiskCleanup
//
//  Description:
//      Constructor of the CClusDiskCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDiskCleanup::CClusDiskCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    TraceFunc( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

    TraceFuncExit();

} //*** CClusDiskCleanup::CClusDiskCleanup()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskCleanup::~CClusDiskCleanup
//
//  Description:
//      Destructor of the CClusDiskCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDiskCleanup::~CClusDiskCleanup( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDiskCleanup::~CClusDiskCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskCleanup::Commit
//
//  Description:
//      Clean up the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskCleanup::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the ClusDisk service.
    CleanupService();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusDiskCleanup::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskCleanup::Rollback
//
//  Description:
//      Rollback the cleanup the service. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskCleanup::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusDiskCleanup::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskjoin.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDiskJoin.cpp
//
//  Description:
//      Contains the definition of the CClusDiskJoin class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDiskJoin.h"

// For the CBaseClusterJoin class.
#include "CBaseClusterJoin.h"

// For the CImpersonateUser class.
#include "CImpersonateUser.h"


//////////////////////////////////////////////////////////////////////////////
// Macro definitions
//////////////////////////////////////////////////////////////////////////////

// Name of the private property of a physical disk resouce that has its signature.
#define PHYSICAL_DISK_SIGNATURE_PRIVPROP_NAME   L"Signature"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::CClusDiskJoin
//
//  Description:
//      Constructor of the CClusDiskJoin class
//
//  Arguments:
//      pbcjParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDiskJoin::CClusDiskJoin(
      CBaseClusterJoin *     pbcjParentActionIn
    )
    : BaseClass( pbcjParentActionIn )
    , m_nSignatureArraySize( 0 )
    , m_nSignatureCount( 0 )
{

    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CClusDiskJoin::CClusDiskJoin


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::~CClusDiskJoin
//
//  Description:
//      Destructor of the CClusDiskJoin class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDiskJoin::~CClusDiskJoin( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDiskJoin::~CClusDiskJoin


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::Commit
//
//  Description:
//      Configure and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskJoin::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Create and start the service.
        ConfigureService();

        // Try and attach to all the disks that the sponsor knows about.
        AttachToClusteredDisks();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC] Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there
        // is no collided unwind.
        //
        try
        {
            CleanupService();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusDiskJoin::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::Rollback
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskJoin::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method.
    BaseClass::Rollback();

    // Cleanup the service.
    CleanupService();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusDiskJoin::Rollback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::AttachToClusteredDisks
//
//  Description:
//      Get the signatures of all disks that have been clustered from the sponsor.
//      Attach to all these disks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskJoin::AttachToClusteredDisks( void )
{
    TraceFunc( "" );

    DWORD sc = ERROR_SUCCESS;

    // Get the parent action pointer.
    CBaseClusterJoin * pcjClusterJoin = dynamic_cast< CBaseClusterJoin *>( PbcaGetParent() );

    // If the parent action of this action is not CBaseClusterJoin
    if ( pcjClusterJoin == NULL )
    {
        THROW_ASSERT( E_POINTER, "The parent action of this action is not CBaseClusterJoin." );
    } // an invalid pointer was passed in.


    //
    // Connect to the sponsor cluster and get the signatures of all clustered disks.
    //

    // Smart handle to sponsor cluster
    SmartClusterHandle schSponsorCluster;

    LogMsg( "[BC] Attempting to impersonate the cluster service account." );

    // Impersonate the cluster service account, so that we can contact the sponsor cluster.
    // The impersonation is automatically ended when this object is destroyed.
    CImpersonateUser ciuImpersonateClusterServiceAccount( pcjClusterJoin->HGetClusterServiceAccountToken() );

    {
        LogMsg( "[BC] Opening a cluster handle to the sponsor cluster with the '%ws' binding string.", pcjClusterJoin->RStrGetClusterBindingString().PszData() );

        // Open a handle to the sponsor cluster.
        HCLUSTER hSponsorCluster = OpenCluster( pcjClusterJoin->RStrGetClusterBindingString().PszData() );

        // Assign it to a smart handle for safe release.
        schSponsorCluster.Assign( hSponsorCluster );
    }

    // Did we succeed in opening a handle to the sponsor cluster?
    if ( schSponsorCluster.FIsInvalid() )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Error %#08x occurred trying to open a cluster handle to the sponsor cluster with the '%ws' binding string.", sc, pcjClusterJoin->RStrGetClusterBindingString().PszData() );
        goto Cleanup;
    } // if: OpenCluster() failed

    LogMsg( "[BC] Enumerating all '%s' resources in the cluster.", CLUS_RESTYPE_NAME_PHYS_DISK );

    // Enumerate all the physical disk resouces in the cluster and get their signatures.
    sc = TW32( ResUtilEnumResourcesEx(
                          schSponsorCluster.HHandle()
                        , NULL
                        , CLUS_RESTYPE_NAME_PHYS_DISK
                        , S_ScResourceEnumCallback
                        , this
                        ) );

    if ( sc != ERROR_SUCCESS )
    {
        // Free the signature array.
        m_rgdwSignatureArray.PRelease();
        m_nSignatureArraySize = 0;
        m_nSignatureCount = 0;

        LogMsg( "[BC] An error occurred trying enumerate resources in the sponsor cluster." );
        goto Cleanup;
    } // if: ResUtilEnumResourcesEx() failed

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to attach to the disks in the sponsor cluster. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CLUSDISK_CONFIGURE );
    } // if: something has gone wrong
    else
    {
        LogMsg( "[BC] Attaching to the %d disks in the sponsor cluster.", m_nSignatureCount );

        AttachToDisks(
          m_rgdwSignatureArray.PMem()
        , m_nSignatureCount
        );
    } // else: everything has gone well so far

    TraceFuncExit();

} //*** CClusDiskJoin::AttachToClusteredDisks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskJoin::ScAddSignature
//
//  Description:
//      Add a signature to the array of signatures of disks that ClusDisk should
//      attach to. If the array is already full, grow the array.
//
//  Arguments:
//      dwSignatureIn
//          Signature to be added to the array.
//
//  Return Value:
//      ERROR_SUCCESS
//          If everything was ok.
//
//      Other Win32 error codes on failure.
//
//  Exceptions Thrown:
//      None. This function is called from a callback routine and therefore
//      cannot throw any exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusDiskJoin::ScAddSignature( DWORD dwSignatureIn ) throw()
{
    TraceFunc( "" );

    DWORD sc = ERROR_SUCCESS;

    // Is the capacity of the array reached?
    if ( m_nSignatureCount == m_nSignatureArraySize )
    {
        // Increase the array size by a random amount.
        const int nGrowSize = 256;

        TraceFlow2( "Signature count has reached array size ( %d ). Growing array by %d.", m_nSignatureArraySize, nGrowSize );

        m_nSignatureArraySize += nGrowSize;

        // Grow the array.
        DWORD * pdwNewArray = new DWORD[ m_nSignatureArraySize ];

        if ( pdwNewArray == NULL )
        {
            LogMsg( "[BC] Memory allocation failed trying to allocate %d DWORDs for signatures.", m_nSignatureArraySize );
            sc = TW32( ERROR_OUTOFMEMORY );
            goto Cleanup;
        } // if: memory allocation failed

        // Copy the old array into the new one.
        CopyMemory( pdwNewArray, m_rgdwSignatureArray.PMem(), m_nSignatureCount * sizeof( DWORD ) );

        // Free the old array and store the new one.
        m_rgdwSignatureArray.Assign( pdwNewArray );

    } // if: the array capacity has been reached

    // Store the new signature in next array location
    ( m_rgdwSignatureArray.PMem() )[ m_nSignatureCount ] = dwSignatureIn;

    ++m_nSignatureCount;

    TraceFlow2( "Signature %#08X added to array. There are now %d signature in the array.", dwSignatureIn, m_nSignatureCount );

Cleanup:

    W32RETURN( sc );

} //*** CClusDiskJoin::ScAddSignature


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusDiskJoin::S_ScResourceEnumCallback
//
//  Description:
//      This function is called back for every physical disk resouce by
//      ResUtilEnumResourcesEx() as a part of enumerating resources.
//      This function gets the signature of the current physical disk
//      resource and stores it in the object that initiated the enumeration
//      ( the pointer to the object is in parameter 4 ).
//
//  Arguments:
//      hClusterIn
//          Handle to the cluster whose resources are being enumerated.
//
//      hSelfIn
//          hSelfIn passed to ResUtilEnumResourcesEx(), if any.
//
//      hCurrentResourceIn
//          Handle to the current resource.
//
//      pvParamIn
//          Pointer to the object of this class that initiated this enumeration.
//
//  Return Value:
//      ERROR_SUCCESS
//          If everything was ok.
//
//      Other Win32 error codes on failure.
//          Returning an error code will terminate the enumeration.
//
//  Exceptions Thrown:
//      None. This function is called from a callback routine and therefore
//      cannot throw any exceptions.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CClusDiskJoin::S_ScResourceEnumCallback(
      HCLUSTER      hClusterIn
    , HRESOURCE     hSelfIn
    , HRESOURCE     hCurrentResourceIn
    , PVOID         pvParamIn
    )
{
    TraceFunc( "" );

    DWORD               sc = ERROR_SUCCESS;
    CClusDiskJoin *     pcdjThisObject = reinterpret_cast< CClusDiskJoin * >( pvParamIn );

    //
    // Get the 'Signature' private property of this physical disk.
    //

    SmartByteArray  sbaPropertyBuffer;
    DWORD           dwBytesReturned = 0;
    DWORD           dwBufferSize;
    DWORD           dwSignature = 0;

    LogMsg( "[BC] Trying to get the signature of the disk resource whose handle is %p.", hCurrentResourceIn );

    // Get the size of the buffer required to hold all the private properties of this resource.
    sc = ClusterResourceControl(
                      hCurrentResourceIn
                    , NULL
                    , CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                    , NULL
                    , 0
                    , NULL
                    , 0
                    , &dwBytesReturned
                    );

    if ( ( sc != ERROR_MORE_DATA ) && ( sc != ERROR_SUCCESS ) )
    {
        // Something went wrong.
        TW32( sc );
        LogMsg( "[BC] Error %#08x getting size of required buffer for private properties.", sc );
        goto Cleanup;
    } // if: the return value of ClusterResourceControl() was not ERROR_MORE_DATA

    dwBufferSize = dwBytesReturned;

    // Allocate the memory required for the property buffer.
    sbaPropertyBuffer.Assign( new BYTE[ dwBufferSize ] );
    if ( sbaPropertyBuffer.FIsEmpty() )
    {
        LogMsg( "[BC] Memory allocation failed trying to allocate %d bytes.", dwBufferSize );
        sc = TW32( ERROR_OUTOFMEMORY );
        goto Cleanup;
    } // if: memory allocation failed


    // Get the all the private properties of this resource.
    sc = TW32( ClusterResourceControl(
                          hCurrentResourceIn
                        , NULL
                        , CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                        , NULL
                        , 0
                        , sbaPropertyBuffer.PMem()
                        , dwBufferSize
                        , &dwBytesReturned
                        ) );

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x getting private properties.", sc );
        goto Cleanup;
    } // if: an error occurring trying to get the private properties.

    // Get the signature of this disk resource.
    sc = TW32( ResUtilFindDwordProperty(
                          sbaPropertyBuffer.PMem()
                        , dwBufferSize
                        , PHYSICAL_DISK_SIGNATURE_PRIVPROP_NAME
                        , &dwSignature
                        ) );

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to get the value of the '%ws' property from the private property list.", sc, PHYSICAL_DISK_SIGNATURE_PRIVPROP_NAME );
        goto Cleanup;
    } // if: we could not get the signature

    sc = TW32( pcdjThisObject->ScAddSignature( dwSignature ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying to add the signature to the signature array." );
        goto Cleanup;
    } // if: we could not store the signature

Cleanup:

    W32RETURN( sc );

} //*** CClusDiskJoin::S_ScResourceEnumCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskform.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDiskForm.cpp
//
//  Description:
//      Contains the definition of the CClusDiskForm class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusDiskForm.h"

// For the CBaseClusterForm class.
#include "CBaseClusterForm.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskForm::CClusDiskForm
//
//  Description:
//      Constructor of the CClusDiskForm class
//
//  Arguments:
//      pbcfParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusDiskForm::CClusDiskForm(
      CBaseClusterForm *     pbcfParentActionIn
    )
    : BaseClass( pbcfParentActionIn )
{

    TraceFunc( "" );

    SetRollbackPossible( true );

    TraceFuncExit();

} //*** CClusDiskForm::CClusDiskForm


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskForm::~CClusDiskForm
//
//  Description:
//      Destructor of the CClusDiskForm class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDiskForm::~CClusDiskForm( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusDiskForm::~CClusDiskForm


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskForm::Commit
//
//  Description:
//      Configure and start the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskForm::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    try
    {
        // Create and start the service.
        ConfigureService();

    } // try:
    catch( ... )
    {
        // If we are here, then something went wrong with the create.

        LogMsg( "[BC] Caught exception during commit." );

        //
        // Cleanup anything that the failed create might have done.
        // Catch any exceptions thrown during Cleanup to make sure that there 
        // is no collided unwind.
        //
        try
        {
            CleanupService();
        }
        catch( ... )
        {
            //
            // The rollback of the committed action has failed.
            // There is nothing that we can do.
            // We certainly cannot rethrow this exception, since
            // the exception that caused the rollback is more important.
            //

            TW32( ERROR_CLUSCFG_ROLLBACK_FAILED );

            LogMsg( "[BC] THIS COMPUTER MAY BE IN AN INVALID STATE. Caught an exception during cleanup." );

        } // catch: all

        // Rethrow the exception thrown by commit.
        throw;

    } // catch: all

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusDiskForm::Commit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDiskForm::Rollback
//
//  Description:
//      Cleanup the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusDiskForm::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. 
    BaseClass::Rollback();

    // Cleanup the service.
    CleanupService();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusDiskForm::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusdiskjoin.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CClusDiskJoin.h
//
//  Description:
//      Header file for CClusDiskJoin class.
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a join.
//
//  Maintained By:
//      David Potter    (DavidP)    20-JUN-2001
//      Vij Vasu        (Vvasu)     03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusDisk base class
#include "CClusDisk.h"

// For the cluster API functions and types
#include "ClusAPI.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterJoin;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusDiskJoin
//
//  Description:
//      The CClusDiskJoin class is an action that configures the ClusDisk
//      service during a join.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusDiskJoin : public CClusDisk
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusDiskJoin(
          CBaseClusterJoin * pbcjParentActionIn
        );

    // Default destructor.
    ~CClusDiskJoin();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Create the ClusDisk service.
    //
    void Commit();

    //
    // Rollback this creation.
    //
    void Rollback();


    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        return BaseClass::UiGetMaxProgressTicks();
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////

    // The base class of this class.
    typedef CClusDisk BaseClass;

    // Smart array of DWORDS
    typedef CSmartGenericPtr< CArrayPtrTrait< DWORD > > SmartDwordArray;


    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////

    // Attach to all the disks that the sponsor cluster cares about.
    void
        AttachToClusteredDisks();

    // Add a signature to the signature array.
    DWORD
        ScAddSignature( DWORD dwSignatureIn ) throw();


    // A function that is called back during resource enumeration.
    static DWORD 
        S_ScResourceEnumCallback(
              HCLUSTER      hClusterIn
            , HRESOURCE     hSelfIn
            , HRESOURCE     hCurrentResourceIn
            , PVOID         pvParamIn
            );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // An array of signatures of disk to which ClusDisk should attach.
    SmartDwordArray     m_rgdwSignatureArray;

    // Current size of the signature array.
    int                 m_nSignatureArraySize;

    // Number of signatures currently in the array.
    int                 m_nSignatureCount;

}; //*** class CClusDiskJoin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcleanup.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusNetCleanup.cpp
//
//  Description:
//      Contains the definition of the CClusNetCleanup class.
//
//  Maintained By:
//      David Potter    (DavidP)    15-JUN-2001
//      Vij Vasu        (Vvasu)     01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusNetCleanup.h"

// For the CBaseClusterCleanup class.
#include "CBaseClusterCleanup.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCleanup::CClusNetCleanup
//
//  Description:
//      Constructor of the CClusNetCleanup class
//
//  Arguments:
//      pbccParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusNetCleanup::CClusNetCleanup( CBaseClusterCleanup * pbccParentActionIn )
    : BaseClass( pbccParentActionIn )
{

    TraceFunc( "" );

    // It is currently not possible to rollback a cleanup.
    SetRollbackPossible( false );

    TraceFuncExit();

} //*** CClusNetCleanup::CClusNetCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCleanup::~CClusNetCleanup
//
//  Description:
//      Destructor of the CClusNetCleanup class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusNetCleanup::~CClusNetCleanup( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusNetCleanup::~CClusNetCleanup


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCleanup::Commit
//
//  Description:
//      Clean up the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the contained actions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCleanup::Commit( void )
{
    TraceFunc( "" );

    // Call the base class commit method.
    BaseClass::Commit();

    // Cleanup the ClusNet service.
    CleanupService();

    // If we are here, then everything went well.
    SetCommitCompleted( true );

    TraceFuncExit();

} //*** CClusNetCleanup::Commit()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetCleanup::Rollback
//
//  Description:
//      Rollback the cleanup the service. This is currently not supported.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNetCleanup::Rollback( void )
{
    TraceFunc( "" );

    // Call the base class rollback method. This will throw an exception since
    // SetRollbackPossible( false ) was called in the constructor.

    BaseClass::Rollback();

    SetCommitCompleted( false );

    TraceFuncExit();

} //*** CClusNetCleanup::Rollback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcleanup.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusNetCleanup.h
//
//  Description:
//      Header file for CClusNetCleanup class.
//      The CClusNetCleanup class is an action that cleans up the ClusNet service.
//
//  Implementation Files:
//      CClusNetCleanup.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 01-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusNet base class
#include "CClusNet.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterCleanup;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusNetCleanup
//
//  Description:
//      The CClusNetCleanup class is an action that clean up the ClusNet service.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusNetCleanup : public CClusNet
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusNetCleanup( CBaseClusterCleanup * pbccParentActionIn );

    // Default destructor.
    ~CClusNetCleanup();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Clean up the ClusNet service.
    //
    void Commit();

    //
    // Rollback this cleanup.
    //
    void Rollback();


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusNet BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

}; //*** class CClusNetCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnetcreate.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusNetCreate.h
//
//  Description:
//      Header file for CClusNetCreate class.
//
//      The CClusNetCreate class creates and configures the ClusNet service.
//      This class can be used during both form and join operations.
//
//  Implementation Files:
//      CClusNetCreate.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CClusNet base class
#include "CClusNet.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAddNode;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusNetCreate
//
//  Description:
//      The CClusNetCreate class performs operations that are common to many
//      configuration tasks.
//
//      This class is intended to be used as the base class for other ClusNet
//      related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusNetCreate : public CClusNet
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusNetCreate(
          CBaseClusterAddNode * pbcanParentActionIn
        );

    // Default destructor.
    ~CClusNetCreate();


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // Create the ClusNet service.
    void Commit();

    // Rollback this creation.
    void Rollback();

    // Returns the number of progress messages that this action will send.
    UINT
        UiGetMaxProgressTicks() const throw()
    {
        // Two notifications are sent:
        // 1. When the service is created.
        // 2. When the service starts.
        return 2;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusNet BaseClass;

}; //*** class CClusNetCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnet.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CClusNet.cpp
//
//  Description:
//      Contains the definition of the CClusNet class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusNet.h"

extern "C"
{
// Required by the winsock functions
#include <winsock2.h>

// For the winsock MigrateWinsockConfiguration function.
#include <wsasetup.h>

// For the winsock WSHGetWinsockMapping function.
#include <wsahelp.h>
}

// For the definition of SOCKADDR_CLUSTER
#include <wsclus.h>


//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// The name of the ClusNet service
#define CLUSNET_SERVICE_NAME L"ClusNet"

// Registry location of the ClusNet winsock entries key
#define CLUSNET_WINSOCK_KEY  L"System\\CurrentControlSet\\Services\\ClusNet\\Parameters\\Winsock"

// Name of the ClusNet winsock mapping registry value
#define CLUSNET_WINSOCK_MAPPING L"Mapping"

// Name of the ClusNet winsock minimum socket address length registry value
#define CLUSNET_WINSOCK_MINSOCKADDRLEN L"MinSockaddrLength"

// Name of the ClusNet winsock maximum socket address length registry value
#define CLUSNET_WINSOCK_MAXSOCKADDRLEN L"MaxSockaddrLength"

// Name of the DLL containing the WinSock cluster helper functions
#define WSHCLUS_DLL_NAME L"WSHClus.dll"

// Name of the winsock parameters key.
#define WINSOCK_PARAMS_KEY L"System\\CurrentControlSet\\Services\\WinSock\\Parameters"

// Name of the winsock transports registry key.
#define WINSOCK_PARAMS_TRANSPORT_VAL L"Transports"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNet::CClusNet
//
//  Description:
//      Constructor of the CClusNet class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusNet::CClusNet(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_cservClusNet( CLUSNET_SERVICE_NAME )
    , m_pbcaParentAction( pbcaParentActionIn )
{

    TraceFunc( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        LogMsg( "[BC] Pointers to the parent action is NULL. Throwing exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CClusNet::CClusNet() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

    TraceFuncExit();

} //*** CClusNet::CClusNet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNet::~CClusNet
//
//  Description:
//      Destructor of the CClusNet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusNet::~CClusNet( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusNet::~CClusNet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNet::ConfigureService
//
//  Description:
//      Installs the cluster network transport.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNet::ConfigureService( void )
{
    TraceFunc( "" );

    DWORD                   dwMappingSize = 0;
    DWORD                   dwSocketAddrLen = sizeof( SOCKADDR_CLUSTER );
    DWORD                   sc = ERROR_SUCCESS;
    WSA_SETUP_DISPOSITION   wsdDisposition;


    {
        CStatusReport   srCreatingClusNet(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Creating_ClusNet_Service
            , 0, 1
            , IDS_TASK_CREATING_CLUSNET
            );

        LogMsg( "[BC] Creating the Cluster Network Provider." );

        // Send the next step of this status report.
        srCreatingClusNet.SendNextStep( S_OK );

        // Create the clusnet service.
        m_cservClusNet.Create( m_pbcaParentAction->HGetMainInfFileHandle() );


        LogMsg( "[BC] Setting Cluster Network Provider service parameters." );

        CRegistryKey    regClusNetWinsockKey( 
              HKEY_LOCAL_MACHINE
            , CLUSNET_WINSOCK_KEY
            , KEY_ALL_ACCESS
            );

        //
        // Install the cluster network provider. A part of the required registry entries have
        // already been made when the service was created.
        //

        {
            //
            // The WSHClus DLL has to be loaded dynamically. Due to the decision to put the
            // code for the client side and the server side of ClusCfg in the same DLL, we
            // cannot implicitly link to any DLL that is not present on the client side even
            // if the functions in the DLL are called only on the server side.
            //

            typedef CSmartResource<
                CHandleTrait< 
                      HMODULE
                    , BOOL
                    , FreeLibrary
                    , reinterpret_cast< HMODULE >( NULL )
                    >
                > SmartModuleHandle;

            // Type of the WSHGetWinsockMapping function.
            typedef DWORD ( * WSHGetWinsockMappingFunctionType )( PWINSOCK_MAPPING, DWORD );

            // Pointer to the WSHGetWinsockMapping function.
            WSHGetWinsockMappingFunctionType pWSHGetWinsockMapping;

            // Get the full path the WSHClus DLL.
            CStr strWSHClusDllPath( m_pbcaParentAction->RStrGetClusterInstallDirectory() );
            strWSHClusDllPath += L"\\" WSHCLUS_DLL_NAME;

            // Load the library and store the handle in a smart  pointer for safe release.
            SmartModuleHandle smhWSHClusDll( LoadLibrary( strWSHClusDllPath.PszData() ) );


            if ( smhWSHClusDll.FIsInvalid() )
            {
                sc = TW32( GetLastError() );

                LogMsg( "[BC] LoadLibrary() retured error %#08x trying to load '%s'. Aborting (throwing an exception).", sc, strWSHClusDllPath.PszData() );
                THROW_RUNTIME_ERROR(
                      HRESULT_FROM_WIN32( sc )
                    , IDS_ERROR_CLUSNET_PROV_INSTALL
                    );
            } // if: LoadLibrary failed.

            pWSHGetWinsockMapping = reinterpret_cast< WSHGetWinsockMappingFunctionType >( 
                GetProcAddress( smhWSHClusDll.HHandle(), "WSHGetWinsockMapping" )
                );

            if ( pWSHGetWinsockMapping == NULL )
            {
                sc = TW32( GetLastError() );

                LogMsg( "[BC] GetProcAddress() retured error %#08x trying to get the address of 'WSHGetWinsockMapping'. Throwing an exception.", sc );
                THROW_RUNTIME_ERROR(
                      HRESULT_FROM_WIN32( sc )
                    , IDS_ERROR_CLUSNET_PROV_INSTALL
                    );
            } // if: GetProcAddress() failed

            // Get WinSock mapping data
            dwMappingSize = pWSHGetWinsockMapping( NULL, 0 );

            CSmartGenericPtr< CPtrTrait< WINSOCK_MAPPING > >
                swmWinSockMapping( reinterpret_cast< WINSOCK_MAPPING * >( new BYTE[ dwMappingSize ] ) );

            if ( swmWinSockMapping.FIsEmpty() )
            {
                LogMsg( "[BC] A memory allocation failure occurred (%d bytes) while setting Cluster Network Provider service parameters.", dwMappingSize );
                THROW_RUNTIME_ERROR(
                      E_OUTOFMEMORY
                    , IDS_ERROR_CLUSNET_PROV_INSTALL
                    );
            } // if: we could not allocate memory for the winsock mapping.


            // Get the winsock mapping.
            dwMappingSize = pWSHGetWinsockMapping( swmWinSockMapping.PMem(), dwMappingSize );

            // Write it to the registry.
            LogMsg( "[BC] Writing registry value HKLM\\%ws\\%ws.", CLUSNET_WINSOCK_KEY, CLUSNET_WINSOCK_MAPPING );
            regClusNetWinsockKey.SetValue( 
                  CLUSNET_WINSOCK_MAPPING
                , REG_BINARY
                , reinterpret_cast< const BYTE *>( swmWinSockMapping.PMem() )
                , dwMappingSize
                );
        }

        //
        // Write the minimum and maximum socket address length to the registry.
        //
        LogMsg( "[BC] Writing registry value HKLM\\%ws\\%ws.", CLUSNET_WINSOCK_KEY, CLUSNET_WINSOCK_MINSOCKADDRLEN );
        regClusNetWinsockKey.SetValue( 
              CLUSNET_WINSOCK_MINSOCKADDRLEN
            , REG_DWORD
            , reinterpret_cast< const BYTE *>( &dwSocketAddrLen )
            , sizeof( dwSocketAddrLen )
            );

        LogMsg( "[BC] Writing registry value HKLM\\%ws\\%ws.", CLUSNET_WINSOCK_KEY, CLUSNET_WINSOCK_MAXSOCKADDRLEN );
        regClusNetWinsockKey.SetValue( 
              CLUSNET_WINSOCK_MAXSOCKADDRLEN 
            , REG_DWORD
            , reinterpret_cast< const BYTE *>( &dwSocketAddrLen )
            , sizeof( dwSocketAddrLen )
            );

        //
        // Poke winsock to update the Winsock2 config
        //
        LogMsg( "[BC] About to migrate winsock configuration." );
        sc = TW32( MigrateWinsockConfiguration( &wsdDisposition, NULL, NULL ) );

        if ( sc != ERROR_SUCCESS )
        {
            LogMsg( "[BC] Error %#08x occurred while trying to migrate the Winsock Configuration. Throwing an exception.", sc );
            TraceFlow1( "MigrateWinsockConfiguration has returned error %#08x. Throwing exception.", sc );
            THROW_RUNTIME_ERROR(
                  HRESULT_FROM_WIN32( sc )
                , IDS_ERROR_CLUSNET_PROV_INSTALL
                );
        } // if: an error occurred poking winsock.

        // Send the last step of this status report.
        srCreatingClusNet.SendNextStep( S_OK );
    }

    {
        UINT    cQueryCount = 10;

        CStatusReport   srStartingClusNet(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Starting_ClusNet_Service
            , 0, cQueryCount + 2    // we will send at most cQueryCount reports while waiting for the service to start (the two extra sends are below)
            , IDS_TASK_STARTING_CLUSNET
            );

        // Send the next step of this status report.
        srStartingClusNet.SendNextStep( S_OK );

        // Start the service.
        m_cservClusNet.Start(
              m_pbcaParentAction->HGetSCMHandle()
            , true                  // wait for the service to start
            , 500                   // wait 500ms between queries for status.
            , cQueryCount           // query cQueryCount times.
            , &srStartingClusNet    // status report to be sent while waiting for the service to start
            );

        // Send the last step of this status report.
        srStartingClusNet.SendLastStep( S_OK );
    }

    TraceFuncExit();

} //*** CClusNet::ConfigureService


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNet::CleanupService
//
//  Description:
//      Remove ClusNet from the Winsock transports list. Delete the service.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusNet::CleanupService( void )
{
    TraceFunc( "" );

    DWORD                   sc = ERROR_SUCCESS;
    WCHAR *                 pmszTransportList = NULL;
    DWORD                   cbBufSize = 0;
    DWORD                   cbBufRemaining = 0;
    UINT                    uiClusNetNameLenPlusOne = ARRAYSIZE( CLUSNET_SERVICE_NAME );
    UINT                    cbClusNetNameSize = uiClusNetNameLenPlusOne * sizeof( WCHAR );
    WSA_SETUP_DISPOSITION   wsdDisposition;


    LogMsg( "[BC] Stopping the Cluster Network Provider service." );

    // Stop the service.
    m_cservClusNet.Stop(
          m_pbcaParentAction->HGetSCMHandle()
        , 500       // wait 500ms between queries for status.
        , 10        // query 10 times.
        );

    LogMsg( "[BC] Cleaning up the Cluster Network Provider service." );

    // Clean up the ClusNet service.
    m_cservClusNet.Cleanup( m_pbcaParentAction->HGetMainInfFileHandle() );

    // Open the winsock registry key.
    CRegistryKey    regWinsockKey( 
          HKEY_LOCAL_MACHINE
        , WINSOCK_PARAMS_KEY
        , KEY_ALL_ACCESS
        );

    //
    // Remove the cluster network provider from the Winsock transports list.
    //

    LogMsg( "[BC] Reading the Winsock transport list." );

    regWinsockKey.QueryValue(
          WINSOCK_PARAMS_TRANSPORT_VAL
        , reinterpret_cast< LPBYTE * >( &pmszTransportList )
        , &cbBufSize
        );

    //
    // Assign the pointer to the allocated buffer to a smart pointer for automatic
    // release.
    //
    SmartSz sszTransports( pmszTransportList );


    // Remove the string "ClusNet" from the multisz list.
    LogMsg( "[BC] Removing ClusNet from the Winsock transport list." );

    cbBufRemaining = cbBufSize;
    while ( *pmszTransportList != L'\0' )
    {
        UINT    uiCurStrLenPlusOne = (UINT) wcslen( pmszTransportList ) + 1;

        // If this string is ClusNet
        if (    ( uiCurStrLenPlusOne == uiClusNetNameLenPlusOne )
             && ( NStringCchCompareNoCase( pmszTransportList, uiCurStrLenPlusOne, CLUSNET_SERVICE_NAME, RTL_NUMBER_OF( CLUSNET_SERVICE_NAME ) ) == 0 )
           )
        {
            // Remove this string from the list
            cbBufSize -= cbClusNetNameSize;

            // Decrement the amount of buffer yet unparsed.
            cbBufRemaining -= cbClusNetNameSize;

            MoveMemory( 
                  pmszTransportList
                , pmszTransportList + uiClusNetNameLenPlusOne
                , cbBufRemaining
                );
        } // if: this string is "ClusNet"
        else
        {
            // Decrement the amount of buffer yet unparsed.
            cbBufRemaining -= uiCurStrLenPlusOne * sizeof( *pmszTransportList );

            // Move to the next string
            pmszTransportList += uiCurStrLenPlusOne;
        } // else: this string is not "ClusNet"

    } // while: the transport list has not been completely parsed.


    LogMsg( "[BC] Writing the Winsock transport list back to the registry." );

    // Write the new list back into the registry.
    regWinsockKey.SetValue(
          WINSOCK_PARAMS_TRANSPORT_VAL
        , REG_MULTI_SZ
        , reinterpret_cast< BYTE * >( sszTransports.PMem() )
        , cbBufSize
        );

    //
    // Poke winsock to update the Winsock2 config
    //
    LogMsg( "[BC] About to migrate winsock configuration." );
    sc = TW32( MigrateWinsockConfiguration( &wsdDisposition, NULL, NULL ) );

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred while trying to migrate the Winsock Configuration. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( sc )
            , IDS_ERROR_CLUSNET_PROV_INSTALL
            );
    } // if: an error occurred poking winsock.

    TraceFuncExit();

} //*** CClusNet::CleanupService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclusnet.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusNet.h
//
//  Description:
//      Header file for CClusNet class.
//      The CClusNet class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//  Implementation Files:
//      CClusNet.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For the CAction base class
#include "CAction.h"

// For the CService class
#include "CService.h"


//////////////////////////////////////////////////////////////////////////
// Forward declaration
//////////////////////////////////////////////////////////////////////////

class CBaseClusterAction;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusNet
//
//  Description:
//      The CClusNet class performs operations that are common to many
//      configuration tasks of the ClusSvc service.
//
//      This class is intended to be used as the base class for other ClusNet
//      related action classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusNet : public CAction
{
protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusNet(
          CBaseClusterAction * pbcaParentActionIn
        );

    // Default destructor.
    ~CClusNet();


    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Create and configure the service.
    void
        ConfigureService();

    // Cleanup and remove the service.
    void
        CleanupService();

    
    //////////////////////////////////////////////////////////////////////////
    // Protected accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the ClusNet service object.
    CService &
        RcsGetService() throw()
    {
        return m_cservClusNet;
    }

    // Get the parent action
    CBaseClusterAction *
        PbcaGetParent() throw()
    {
        return m_pbcaParentAction;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Copy constructor
    CClusNet( const CClusNet & );

    // Assignment operator
    const CClusNet & operator =( const CClusNet & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The CService object representing the ClusNet service.
    CService                m_cservClusNet;

    // Pointer to the base cluster action of which this action is a part.
    CBaseClusterAction *    m_pbcaParentAction;

}; //*** class CClusNet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\mgmt\cluscfg\basecluster\cclussvc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      CClusSvc.cpp
//
//  Description:
//      Contains the definition of the CClusSvc class.
//
//  Maintained By:
//      David Potter    (DavidP)    14-JUN-2001
//      Vij Vasu        (Vvasu)     08-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "Pch.h"

// The header for this file
#include "CClusSvc.h"

// For DwRemoveDirectory()
#include "Common.h"

// For IDS_ERROR_IP_ADDRESS_IN_USE_REF
#include <CommonStrings.h>

#define  SECURITY_WIN32  
#include <Security.h>

//////////////////////////////////////////////////////////////////////////////
// Macros
//////////////////////////////////////////////////////////////////////////////

// Name of the NodeId cluster service parameter registry value.
#define CLUSSVC_NODEID_VALUE   L"NodeId"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvc::CClusSvc
//
//  Description:
//      Constructor of the CClusSvc class
//
//  Arguments:
//      pbcaParentActionIn
//          Pointer to the base cluster action of which this action is a part.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CAssert
//          If the parameters are incorrect.
//
//      Any exceptions thrown by underlying functions
//
    //--
//////////////////////////////////////////////////////////////////////////////
CClusSvc::CClusSvc(
      CBaseClusterAction *  pbcaParentActionIn
    )
    : m_cservClusSvc( CLUSTER_SERVICE_NAME )
    , m_pbcaParentAction( pbcaParentActionIn )
{

    TraceFunc( "" );

    if ( m_pbcaParentAction == NULL) 
    {
        LogMsg( "[BC] Pointers to the parent action is NULL. Throwing an exception." );
        THROW_ASSERT( 
              E_INVALIDARG
            , "CClusSvc::CClusSvc() => Required input pointer in NULL"
            );
    } // if: the parent action pointer is NULL

    TraceFuncExit();

} //*** CClusSvc::CClusSvc


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvc::~CClusSvc
//
//  Description:
//      Destructor of the CClusSvc class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      Any exceptions thrown by underlying functions
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusSvc::~CClusSvc( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusSvc::~CClusSvc


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusSvc::ConfigureService
//
//  Description:
//      Create the service, set the failure actions and the service account.
//      Then start the service.
//
//  Arguments:
//      pszClusterDomainAccountNameIn
//      pszClusterAccountPwdIn
//          Information about the account to be used as the cluster service
//          account.
//
//      pszNodeIdString
//          String containing the Id of this node.
//
//      dwClusterIPAddress
//          IP address of the cluster
//
//  Return Value:
//      None. 
//
//  Exceptions Thrown:
//      CRuntimeError
//          If any of the APIs fail.
//
//      Any that are thrown by the underlying functions.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CClusSvc::ConfigureService(
      const WCHAR *     pszClusterDomainAccountNameIn
    , const WCHAR *     pszClusterAccountPwdIn
    , const WCHAR *     pszNodeIdStringIn
    , bool              fIsVersionCheckingDisabledIn
    , DWORD             dwClusterIPAddressIn
    )
{
    TraceFunc( "" );

    DWORD   sc = ERROR_SUCCESS;

    CStatusReport   srCreatingClusSvc(
          PbcaGetParent()->PBcaiGetInterfacePointer()
        , TASKID_Major_Configure_Cluster_Services
        , TASKID_Minor_Creating_Cluster_Service
        , 0, 2
        , IDS_TASK_CREATING_CLUSSVC
        );

    LogMsg( "[BC] Configuring the Cluster service." );

    // Send the next step of this status report.
    srCreatingClusSvc.SendNextStep( S_OK );

    // Create the cluster service.
    m_cservClusSvc.Create( m_pbcaParentAction->HGetMainInfFileHandle() );

    LogMsg( "[BC] Setting the Cluster service account information." );


    // Open a smart handle to the cluster service.
    SmartSCMHandle  sscmhClusSvcHandle(
        OpenService(
              m_pbcaParentAction->HGetSCMHandle()
            , CLUSTER_SERVICE_NAME
            , SERVICE_CHANGE_CONFIG
            )
        );

    if ( sscmhClusSvcHandle.FIsInvalid() )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Error %#08x opening the '%ws' service.", sc, CLUSTER_SERVICE_NAME );
        goto Cleanup;
    } // if: we could not open a handle to the cluster service.

    //
    // Set the service account information.
    //
    {
        if ( 
             ChangeServiceConfig(
                  sscmhClusSvcHandle
                , SERVICE_NO_CHANGE
                , SERVICE_NO_CHANGE
                , SERVICE_NO_CHANGE
                , NULL
                , NULL
                , NULL
                , NULL
                , pszClusterDomainAccountNameIn
                , pszClusterAccountPwdIn
                , NULL
                ) 
             == FALSE
           )
        {
            sc = TW32( GetLastError() );
            LogMsg( 
                  "[BC] Error %#08x setting the service account information. Account = '%ws'."
                , sc
                , pszClusterDomainAccountNameIn
                );
            goto Cleanup;
        } // if: we could not set the account information.
    }

    LogMsg( "[BC] Setting the Cluster service failure actions." );

    // Set the failure actions of the cluster service service.
    sc = TW32( ClRtlSetSCMFailureActions( NULL ) );
    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x setting the failure actions of the cluster service.", sc );
        goto Cleanup;
    } // if: the service failure actions couldn't be set

    LogMsg( "[BC] Setting the Cluster service parameters." );

    // Send the next step of this status report.
    srCreatingClusSvc.SendNextStep( S_OK );

    {
        CRegistryKey rkClusSvcParams;
        CRegistryKey rkClusterParams;
        UUID         guid;
        LPWSTR       pszClusterInstanceId = NULL;
        
        // Open the parameters key or create it if it does not exist.
        rkClusSvcParams.CreateKey(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_CLUSSVC_PARAMETERS
            , KEY_WRITE
            );

        // Set the NodeId string.
        rkClusSvcParams.SetValue(
              CLUSSVC_NODEID_VALUE
            , REG_SZ
            , reinterpret_cast< const BYTE * >( pszNodeIdStringIn )
            , ( (UINT) wcslen( pszNodeIdStringIn ) + 1 ) * sizeof( *pszNodeIdStringIn )
            );

        // If version checking has been disabled, set a flag in the service parameters
        // to indicate this.
        if ( fIsVersionCheckingDisabledIn )
        {
            DWORD   dwNoVersionCheck = 1;

            rkClusSvcParams.SetValue(
                  CLUSREG_NAME_SVC_PARAM_NOVER_CHECK
                , REG_DWORD
                , reinterpret_cast< const BYTE * >( &dwNoVersionCheck )
                , sizeof( dwNoVersionCheck )
                );

            LogMsg( "[BC] Cluster version checking has been disabled on this computer." );
        } // if: version checking has been disabled

        //
        // If we are creating a new cluster then create the cluster instance ID.
        //
        if ( m_pbcaParentAction->EbcaGetAction() == eCONFIG_ACTION_FORM )
        {
            // Generate a GUID for the cluster instance ID.
            sc = UuidCreate( &guid );
            if ( sc != RPC_S_OK ) 
            {
                LogMsg( "[BC] Error %#08x when creating a Uuid for the Cluster Instance ID.", sc );
                goto Cleanup;
            }

            sc = UuidToString( &guid, &pszClusterInstanceId );
            if ( sc != RPC_S_OK ) 
            {
                LogMsg( "[BC] Error %#08x when converting the uuid of the Cluster Instance ID to a string.", sc );
                goto Cleanup;
            }

            // Open the parameters key in the cluster database or create it if it does not exist.
            rkClusterParams.CreateKey(
                  HKEY_LOCAL_MACHINE
                , CLUSREG_KEYNAME_CLUSTER_PARAMETERS
                , KEY_WRITE
                );

            // Set the ClusterInstanceId string.
            rkClusterParams.SetValue(
                  CLUSREG_NAME_CLUS_CLUSTER_INSTANCE_ID
                , REG_SZ
                , reinterpret_cast< const BYTE * >( pszClusterInstanceId )
                , ( (UINT) wcslen( pszClusterInstanceId ) + 1 ) * sizeof( *pszClusterInstanceId )
                );
        } // if: creating a cluster
    }

    //
    // Set the cluster installation state.
    //
    if ( ClRtlSetClusterInstallState( eClusterInstallStateConfigured ) == FALSE )
    {
        sc = TW32( GetLastError() );
        LogMsg( "[BC] Could not set the cluster installation state. Throwing an exception." );

        goto Cleanup;
    } // ClRtlSetClusterInstallState() failed.

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LogMsg( "[BC] Error %#08x occurred trying configure the ClusSvc service. Throwing an exception.", sc );
        THROW_RUNTIME_ERROR(
              HRESULT_FROM_WIN32( sc )
            , IDS_ERROR_CLUSSVC_CONFIG
            );
    } // if; there was an error getting the handle.

    // Send the next step of this status report.
    srCreatingClusSvc.SendNextStep( S_OK );

    {
        UINT    cQueryCount = 100;

        CStatusReport   srStartingClusSvc(
              PbcaGetParent()->PBcaiGetInterfacePointer()
            , TASKID_Major_Configure_Cluster_Services
            , TASKID_Minor_Starting_Cluster_Service
            , 0, cQueryCount + 2    // we will send at most cQueryCount reports while waiting for the service to start (the two extra sends are below)
            , IDS_TASK_STARTING_CLUSSVC
            );

        // Send the next step of this status report.
        srStartingClusSvc.SendNextStep( S_OK );

        try 
        {
            //
            // Start the service.
            //
            m_cservClusSvc.Start(
                  m_pbcaParentAction->HGetSCMHandle()
                , true                  // wait for the service to start
                , 3000                  // wait 3 seconds between queries for status.
                , cQueryCount           // query cQueryCount times
                , &srStartingClusSvc    // status report to be sent while waiting for the service to start
                );
        }
        catch( ... )
        {
            //
            // If IP Address is not NULL we are creating a new cluster; otherwise we are adding node to a cluster.
            //
            if ( dwClusterIPAddressIn != 0 )
            {
                BOOL    fRet = FALSE;

                fRet = ClRtlIsDuplicateTcpipAddress( dwClusterIPAddressIn );
            
                //
                // IP address already in use 
                //
                if ( fRet == TRUE )
                {
                    LogMsg( "[BC] The IP address specified for this cluster is already in use. Throwing an exception.");

                    THROW_RUNTIME_ERROR_REF( HRESULT_FROM_WIN32( ERROR_CLUSTER_IPADDR_IN_USE ), IDS_ERROR_IP_ADDRESS_IN_USE, IDS_ERROR_IP_ADDRESS_IN_USE_REF );
                }
                else
                {
                    LogMsg( "[BC] Cluster Service Win32 Exit Code= %#08x", m_cservClusSvc.GetWin32ExitCode() );
                    LogMsg( "[BC] Cluster Service Specific Exit Code= %#08x", m_cservClusSvc.GetServiceExitCode() );

                    //
                    // Throw the error if we don't handle it.
                    //
                    throw;
                }
            } // if: cluster IP address was specified
            else
            {
                LogMsg( "[BC] Cluster Service Win32 Exit Code= %#08x", m_cservClusSvc.GetWin32ExitCode() );
                LogMsg( "[BC] Cluster Service Specific Exit Code= %#08x", m_cservClusSvc.GetServiceExitCode() );

                //
                // Throw the error if we don't handle it.
                //
                throw;
        