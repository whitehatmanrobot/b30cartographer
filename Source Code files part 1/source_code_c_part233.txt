RESULT CInstallReferenceEnum::Init(IAssemblyName *pName, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    _pInstallRefEnum = NEW(CInstallRefEnum(pName, FALSE));
    if (!_pInstallRefEnum)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    _cRef = 1;

    return hr;
}


// ---------------------------------------------------------------------------
// CInstallReferenceEnum::GetNextInstallReferenceItem
// ---------------------------------------------------------------------------
STDMETHODIMP 
CInstallReferenceEnum::GetNextInstallReferenceItem(IInstallReferenceItem **ppRefItem, 
                                                   DWORD dwFlags, LPVOID pvReserved)
{
    HRESULT              hr      = S_OK;
    WCHAR szValue[MAX_PATH+1];
    DWORD cchValue;
    WCHAR szData[MAX_PATH+1];
    DWORD cchData;
    GUID guid;
    PBYTE pData = NULL;
    DWORD cbSize = 0;
    LPWSTR szId, szNonCannonicalData;

    LPFUSION_INSTALL_REFERENCE pRefData;

    if(!ppRefItem)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    ASSERT(_pInstallRefEnum);

    cchValue = MAX_PATH;
    cchData  = MAX_PATH;

    *ppRefItem = NULL;

    szValue[0] = L'\0';
    szData[0]  = L'\0';

    hr = _pInstallRefEnum->GetNextReference(0, szValue, &cchValue, szData, &cchData, &guid, NULL);

    if(hr !=  S_OK)
        goto exit;

    cbSize = sizeof(FUSION_INSTALL_REFERENCE) + (lstrlen(szValue) + 1 + lstrlen(szData) + 1) * sizeof(WCHAR);

    pData = NEW(BYTE[cbSize]);

    if (!pData)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    memset(pData, 0, cbSize);

    pRefData = (LPFUSION_INSTALL_REFERENCE) pData;

    pRefData->cbSize = sizeof(FUSION_INSTALL_REFERENCE);

    szId = (LPWSTR) (pData + sizeof(FUSION_INSTALL_REFERENCE));
    StrCpy(szId, szValue);

    if(lstrlen(szData))
    {
        szNonCannonicalData = szId + lstrlen(szId) + 1;
        StrCpy(szNonCannonicalData, szData);
    }
    else
    {
        szNonCannonicalData = NULL;
    }

    pRefData->guidScheme = guid;
    pRefData->szIdentifier = szId;
    pRefData->szNonCannonicalData = szNonCannonicalData;


    hr = CreateInstallReferenceItem(ppRefItem, pRefData, 0, NULL);

exit:

    if(hr == S_FALSE)
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    if(hr != S_OK)
    {
        SAFEDELETEARRAY(pData);
        SAFERELEASE(*ppRefItem);
    }

    return hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CInstallReferenceEnum::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CInstallReferenceEnum::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IInstallReferenceEnum)
       )
    {
        *ppvObj = static_cast<CInstallReferenceEnum*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CInstallReferenceEnum::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CInstallReferenceEnum::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

// ---------------------------------------------------------------------------
// CInstallReferenceEnum::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CInstallReferenceEnum::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}


// ---------------------------------------------------------------------------
// CInstallReferenceItem ctor
// ---------------------------------------------------------------------------
CInstallReferenceItem::CInstallReferenceItem(LPFUSION_INSTALL_REFERENCE  pRefData)
{
    _cRef = 1;
    _pRefData    = pRefData;
}


// ---------------------------------------------------------------------------
// CInstallReferenceItem dtor
// ---------------------------------------------------------------------------
CInstallReferenceItem::~CInstallReferenceItem()
{
    SAFEDELETEARRAY (_pRefData);
}

// ---------------------------------------------------------------------------
// CInstallReferenceItem::GetReference
// ---------------------------------------------------------------------------
STDMETHODIMP 
CInstallReferenceItem::GetReference(LPFUSION_INSTALL_REFERENCE *ppRefData, DWORD dwFlags, LPVOID pvReserved)
{
    HRESULT              hr      = S_OK;

    ASSERT(_pRefData);

    *ppRefData = _pRefData;
    return hr;
}


// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CInstallReferenceItem::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CInstallReferenceItem::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IInstallReferenceItem)
       )
    {
        *ppvObj = static_cast<CInstallReferenceItem*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CInstallReferenceItem::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CInstallReferenceItem::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

// ---------------------------------------------------------------------------
// CInstallReferenceItem::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CInstallReferenceItem::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\appctx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <shlwapi.h>
#include "fusionp.h"
#include "naming.h"
#include "debmacro.h"
#include "appctx.h"
#include "list.h"
#include "actasm.h"
#include "policy.h"
#include "fusionheap.h"
#include "helpers.h"
#include "history.h"
#include "asm.h"
#include "nodefact.h"
#include "lock.h"
#include "sxs.h"
#include "wininet.h"

extern CRITICAL_SECTION g_csDownload;
extern CRITICAL_SECTION g_csInitClb;

HMODULE               g_hKernel32Sxs = 0;
PFNCREATEACTCTXW      g_pfnCreateActCtxW = NULL;
PFNADDREFACTCTX       g_pfnAddRefActCtx = NULL;
PFNRELEASEACTCTX      g_pfnReleaseActCtx = NULL;
PFNACTIVATEACTCTX     g_pfnActivateActCtx = NULL;
PFNDEACTIVATEACTCTX   g_pfnDeactivateActCtx = NULL;


// ---------------------------------------------------------------------------
// CApplicationContext::CreateEntry
// 
// Private func; Allocates and copies data input.
// ---------------------------------------------------------------------------
HRESULT CApplicationContext::CreateEntry(LPTSTR szName, LPVOID pvValue, 
    DWORD cbValue, DWORD dwFlags, Entry** ppEntry)
{
    HRESULT hr = S_OK;
    DWORD cbName;

    // Allocate the entry.
    Entry *pEntry = NEW(Entry);
    if (!pEntry)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // Copy name.
    cbName = (lstrlen(szName) + 1) * sizeof(TCHAR);
    pEntry->_szName = NEW(TCHAR[cbName]);
    if (!pEntry->_szName)
    {
        SAFEDELETE(pEntry);
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(pEntry->_szName, szName, cbName);

    // Allocate and copy data, don't free existing data.
    hr = CopyData(pEntry, pvValue, cbValue, dwFlags, FALSE);
    if (FAILED(hr)) {
        SAFEDELETE(pEntry);
        goto exit;
    }
    
    *ppEntry = pEntry;

exit:
    return hr;
}

CApplicationContext::Entry::Entry()
: _szName(NULL)
, _pbValue(NULL)
, _cbValue(0)
, _dwFlags(0)
{
    _dwSig = 'YTNE';
}

// ---------------------------------------------------------------------------
// CApplicationContext::Entry dtor
// ---------------------------------------------------------------------------
CApplicationContext::Entry::~Entry()
{
    if (_dwFlags & APP_CTX_FLAGS_INTERFACE)
        ((IUnknown*) _pbValue)->Release();       
    else
        SAFEDELETEARRAY(_pbValue);

    SAFEDELETEARRAY(_szName);
}



// ---------------------------------------------------------------------------
// CApplicationContext::CopyData
//
// Private func; used to create and update entries.
// ---------------------------------------------------------------------------
HRESULT CApplicationContext::CopyData(Entry *pEntry, LPVOID pvValue, 
    DWORD cbValue, DWORD dwFlags, BOOL fFree)
{
    HRESULT hr = S_OK;

    if (fFree)
    {
        // Cleanup if pre-existing.
        if (pEntry->_dwFlags & APP_CTX_FLAGS_INTERFACE)
            ((IUnknown*) pEntry->_pbValue)->Release();       
        else
            SAFEDELETEARRAY(pEntry->_pbValue);
    }

    // Input is straight blob.
    if (!(dwFlags & APP_CTX_FLAGS_INTERFACE))
    {
        pEntry->_pbValue = NEW(BYTE[cbValue]);
        if (!pEntry->_pbValue)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memcpy(pEntry->_pbValue, pvValue, cbValue);    
        pEntry->_cbValue = cbValue;
    }
    // Input is Interface ptr.
    else
    {
        pEntry->_pbValue = (LPBYTE) pvValue;
        pEntry->_cbValue = sizeof(IUnknown*);
        ((IUnknown*) pEntry->_pbValue)->AddRef();
    }

    pEntry->_dwFlags = dwFlags;

exit:
    return hr;
}


// ---------------------------------------------------------------------------
// CreateApplicationContext
// ---------------------------------------------------------------------------
STDAPI
CreateApplicationContext(
    IAssemblyName *pName,
    LPAPPLICATIONCONTEXT *ppCtx)
{
    HRESULT hr;
    CApplicationContext *pCtx = NULL;

    if (!ppCtx)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
 
    pCtx = NEW(CApplicationContext);
    if (!pCtx)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pCtx->Init(pName);

    if (FAILED(hr)) 
    {
        SAFERELEASE(pCtx);
        goto exit;
    }
    
    *ppCtx = pCtx;

exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CApplicationContext ctor
// ---------------------------------------------------------------------------
CApplicationContext::CApplicationContext()
{
    _dwSig = 'XTCA';
    memset(&_List, 0, sizeof(SERIALIZED_LIST));
    _pName = NULL;
    _cRef = 0;
    _bInitialized = FALSE;
}

// ---------------------------------------------------------------------------
// CApplicationContext dtor
// ---------------------------------------------------------------------------
CApplicationContext::~CApplicationContext()
{
    HRESULT                               hr;
    DWORD                                 dwSize;
    HANDLE                                hFile = NULL;
    HANDLE                                hActCtx = NULL;
    CRITICAL_SECTION                     *pcs = NULL;
    CBindHistory                         *pBindHistory = NULL;

    Entry *pEntry = NULL;

    if (_bInitialized) {
        DeleteCriticalSection(&_cs);
    }

    // Release SxS activation context, if any

    dwSize = sizeof(hActCtx);
    hr = Get(ACTAG_SXS_ACTIVATION_CONTEXT, &hActCtx, &dwSize, 0);
    if (hr == S_OK && hActCtx != INVALID_HANDLE_VALUE) {
        // Double release
        g_pfnReleaseActCtx(hActCtx);
        g_pfnReleaseActCtx(hActCtx);
    }
        
    // Release the config downloader crit sect

    dwSize = sizeof(CRITICAL_SECTION *);
    hr = Get(ACTAG_APP_CFG_DOWNLOAD_CS, &pcs, &dwSize, 0);
    if (hr == S_OK) {
        hr = Set(ACTAG_APP_CFG_DOWNLOAD_CS, NULL, 0, 0);
        ASSERT(hr == S_OK);

        DeleteCriticalSection(pcs);
        SAFEDELETE(pcs);
    }

    // Release lock on app.cfg

    dwSize = sizeof(HANDLE);
    hr = Get(ACTAG_APP_CFG_FILE_HANDLE, (void *)&hFile, &dwSize, 0);
    if (hr == S_OK && hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }


    // Delete bind history object

    dwSize = sizeof(CBindHistory *);
    hr = Get(ACTAG_APP_BIND_HISTORY, (void *)&pBindHistory, &dwSize, 0);
    if (hr == S_OK) {
        SAFEDELETE(pBindHistory);
    }

    // Release associated IAssemblyName*
    SAFERELEASE(_pName);

    // Destruct list, destruct entries.
    while (_List.ElementCount)
    {
        pEntry = (Entry*) HeadOfSerializedList(&_List);    
        RemoveFromSerializedList(&_List, pEntry);
        delete pEntry;
    }

    // Free up list resources.
    TerminateSerializedList(&_List);
    
}

// ---------------------------------------------------------------------------
// CApplicationContext::Init
// ---------------------------------------------------------------------------
HRESULT CApplicationContext::Init(LPASSEMBLYNAME pName)
{
    HRESULT                                      hr = S_OK;
    CLoadContext                                *pLoadCtxDefault = NULL;
    CLoadContext                                *pLoadCtxLoadFrom = NULL;

    __try {
        InitializeCriticalSection(&_cs);
        _bInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return E_OUTOFMEMORY;
    }

    // Init list. 
    InitializeSerializedList(&_List);

    // Set name if any.
    _pName = pName;

    if (_pName) {
        _pName->AddRef();
    }

    hr = CLoadContext::Create(&pLoadCtxDefault, LOADCTX_TYPE_DEFAULT);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = CLoadContext::Create(&pLoadCtxLoadFrom, LOADCTX_TYPE_LOADFROM);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = Set(ACTAG_LOAD_CONTEXT_DEFAULT, pLoadCtxDefault, sizeof(pLoadCtxDefault), APP_CTX_FLAGS_INTERFACE);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = Set(ACTAG_LOAD_CONTEXT_LOADFROM, pLoadCtxLoadFrom, sizeof(pLoadCtxLoadFrom), APP_CTX_FLAGS_INTERFACE);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Success

    _cRef = 1;
    
Exit:
    SAFERELEASE(pLoadCtxDefault);
    SAFERELEASE(pLoadCtxLoadFrom);

    return hr;
}


// ---------------------------------------------------------------------------
// CApplicationContext::SetContextNameObject
// ---------------------------------------------------------------------------
STDMETHODIMP
CApplicationContext::SetContextNameObject(LPASSEMBLYNAME pName)
{
    // Free existing name if any
    SAFERELEASE(_pName);

    // Set name.
    _pName = pName;
    if (_pName)
        _pName->AddRef();
    return S_OK;
}

// ---------------------------------------------------------------------------
// CApplicationContext::GetContextNameObject
// ---------------------------------------------------------------------------
STDMETHODIMP
CApplicationContext::GetContextNameObject(LPASSEMBLYNAME *ppName)
{
    if (!ppName)
        return E_INVALIDARG;

    *ppName = _pName;

    if (*ppName)
        (*ppName)->AddRef();

    return S_OK;
}

// ---------------------------------------------------------------------------
// CApplicationContext::Set
// ---------------------------------------------------------------------------
STDMETHODIMP
CApplicationContext::Set(LPCOLESTR szName, LPVOID pvValue, 
    DWORD cbValue, DWORD dwFlags)
{
    HRESULT                                     hr;
    BOOL                                        fUpdate = FALSE;
    Entry                                      *pEntry;
    LONG                                        i;
    
    if (!szName) {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (!FusionCompareString(ACTAG_SXS_ACTIVATION_CONTEXT, szName)) {
        HANDLE                hActCtx;
        DWORD                 dwSize;

        if (!InitSxsProcs()) {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
            goto exit;
        }

        // Don't set garbage in this param
        if (cbValue != sizeof(HANDLE) || !pvValue) {
            hr = E_INVALIDARG;
            goto exit;
        }

        __try {
            EnterCriticalSection(&_cs);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        hr = Get(ACTAG_SXS_ACTIVATION_CONTEXT, &hActCtx, &dwSize, 0);
        if (hr == S_OK && hActCtx != INVALID_HANDLE_VALUE && hActCtx != NULL) {
            // Previous activation context exists. Release it.
            // Release both the Get's AddRef and the AppCtx's

            g_pfnReleaseActCtx(hActCtx);
            g_pfnReleaseActCtx(hActCtx);
        }

        LeaveCriticalSection(&_cs);
    }

    // If a setting the app name or cache base (ie. anything that affects the
    // cache directory), then make sure the any previously cached CCache
    // objects are released (ie. so they get rebuilt with the right new
    // location on next use.

    if (!FusionCompareString(ACTAG_APP_NAME, szName) || !FusionCompareString(ACTAG_APP_CACHE_BASE, szName)) {
        hr = Set(ACTAG_APP_CACHE, 0, 0, 0);
        if (FAILED(hr)) {
            goto exit;
        }
    }
    
    // If interface ptr, byte count is optional.
    if (!cbValue && (dwFlags & APP_CTX_FLAGS_INTERFACE))
        cbValue = sizeof(IUnknown*);
        
    // Grab crit sect.
    LockSerializedList(&_List);

    // Validate input.
    if (!pvValue && cbValue)
    {
        ASSERT(FALSE);
        UnlockSerializedList(&_List);
        hr = E_INVALIDARG;
        goto exit;
    }

    // If not empty, check for pre-existing entry.
    if (!IsSerializedListEmpty(&_List))
    {
        pEntry = (Entry*) HeadOfSerializedList(&_List);
        for (i = 0; i < _List.ElementCount; i++)
        {
            if (!FusionCompareString(pEntry->_szName, szName))
            {
                // Found identically named entry.
                fUpdate = TRUE;
                break;
            }
            pEntry = (Entry*) pEntry->Flink;
        } 
    }
    
    // If updating a current entry.
    if (fUpdate)
    {
        if (cbValue)
        {
            // Copy data over, freeing previous.
            if (FAILED(hr = CopyData(pEntry, pvValue, cbValue, dwFlags, TRUE))) {
                UnlockSerializedList(&_List);
                goto exit;
            }
        }
        else
        {
            // 0 byte count means remove entry.
            
            RemoveFromSerializedList(&_List, pEntry);
            delete pEntry;
            UnlockSerializedList(&_List);
            hr = S_OK;
            goto exit;
        }
    }
    // otherwise allocate a new entry.
    else
    {
        if (cbValue) 
        {
            // Create new and push onto list.
            if (FAILED(hr = CreateEntry((LPOLESTR) szName, pvValue, 
                cbValue, dwFlags, &pEntry))) {
                UnlockSerializedList(&_List);
                goto exit;
            }
            InsertAtHeadOfSerializedList(&_List, pEntry);
        }
        else
        {
            // Trying to create a new entry, but no byte count.
            hr = S_FALSE;
            UnlockSerializedList(&_List);
            goto exit;
        }  
    }

    // Release crit sect.
    UnlockSerializedList(&_List);
        
exit:
    if (hr == S_OK && !FusionCompareString(szName, ACTAG_SXS_ACTIVATION_CONTEXT)) {
        HANDLE                 *phActCtx = (HANDLE *)pvValue;

        ASSERT(phActCtx);

        if (*phActCtx != INVALID_HANDLE_VALUE) {
            // Add ref the activation context
            (*g_pfnAddRefActCtx)(*phActCtx);
        }
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CApplicationContext::Get
// ---------------------------------------------------------------------------
STDMETHODIMP
CApplicationContext::Get(LPCOLESTR szName, LPVOID pvValue, 
    LPDWORD pcbValue, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    Entry *pEntry;
    BOOL fFound = FALSE;
    LONG i;
    
    // Validate input.
    if (!szName || !pcbValue || (!pvValue && *pcbValue))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // perfperf - readers locking out readers.
    LockSerializedList(&_List);

    // Cannot set SxS activation context on non-Whistler systems.

    if (!FusionCompareString(szName, ACTAG_SXS_ACTIVATION_CONTEXT) && !InitSxsProcs()) {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        UnlockSerializedList(&_List);
        goto exit;
    }

    if (IsSerializedListEmpty(&_List))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    if( hr == S_OK )
    {
    
        pEntry = (Entry*) HeadOfSerializedList(&_List);
        for (i = 0; i < _List.ElementCount; i++)
        {
            if (!FusionCompareString(pEntry->_szName, szName))
            {
                fFound = TRUE;
                break;
            }
            pEntry = (Entry*) pEntry->Flink;
        }                        
    }

    // Entry found.
    if (fFound)
    {
        // Insufficient buffer case.
        if (*pcbValue < pEntry->_cbValue)
        {        
            *pcbValue = pEntry->_cbValue;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            UnlockSerializedList(&_List);
            goto exit;
        }
        
        // If interface pointer addref and hand out.
        if (pEntry->_dwFlags & APP_CTX_FLAGS_INTERFACE)
        {
            *((IUnknown**) pvValue) = (IUnknown*) pEntry->_pbValue;
            ((IUnknown*) pEntry->_pbValue)->AddRef();
        }
        // Otherwise just copy blob.
        else    
            memcpy(pvValue, pEntry->_pbValue, pEntry->_cbValue);

        // Indicate byte count.
        *pcbValue = pEntry->_cbValue;
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    // AddRef act ctx

    if (hr == S_OK && !FusionCompareString(szName, ACTAG_SXS_ACTIVATION_CONTEXT)) {
        HANDLE               *phActCtx = (HANDLE *)pvValue;

        ASSERT(pvValue && *pcbValue == sizeof(HANDLE));

        if (*phActCtx != INVALID_HANDLE_VALUE && *phActCtx != NULL) {
            (*g_pfnAddRefActCtx)(*phActCtx);
        }
    }

    UnlockSerializedList(&_List);

exit:
    return hr;
}


// IUnknown methods

// ---------------------------------------------------------------------------
// CApplicationContext::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CApplicationContext::AddRef()
{
    return InterlockedIncrement((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CApplicationContext::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CApplicationContext::Release()
{
    if (InterlockedDecrement((LONG*) &_cRef) == 0) {
        delete this;
        return 0;
    }

    return _cRef;
}

// ---------------------------------------------------------------------------
// CApplicationContext::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CApplicationContext::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IApplicationContext || riid == IID_IUnknown)
        *ppv = (IApplicationContext *) this;

    if (*ppv == NULL)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;

} 

STDMETHODIMP CApplicationContext::GetDynamicDirectory(LPWSTR wzDynamicDir,
                                                      DWORD *pdwSize)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  wzDynamicBase = NULL;
    LPWSTR                                  wzAppName = NULL;
    LPWSTR                                  wzAppCtxDynamicDir = NULL;
    WCHAR                                   wzDir[MAX_PATH];
    DWORD                                   dwLen;

    wzDir[0] = L'\0';

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check if the dynamic directory has already been set.

    hr = ::AppCtxGetWrapper(this, ACTAG_APP_DYNAMIC_DIRECTORY, &wzAppCtxDynamicDir);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (wzAppCtxDynamicDir) {
        ASSERT(lstrlenW(wzAppCtxDynamicDir));

        dwLen = lstrlenW(wzAppCtxDynamicDir) + 1;
        if (!wzDynamicDir || *pdwSize < dwLen) {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            *pdwSize = dwLen;
            goto Exit;
        }

        *pdwSize = dwLen;

        lstrcpyW(wzDynamicDir, wzAppCtxDynamicDir);
        goto Exit;
    }

    // Dynamic directory not set. Calculate it.

    hr = ::AppCtxGetWrapper(this, ACTAG_APP_DYNAMIC_BASE, &wzDynamicBase);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ::AppCtxGetWrapper(this, ACTAG_APP_NAME, &wzAppName);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!wzAppName || !wzDynamicBase) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    PathRemoveBackslashW(wzDynamicBase);

    wnsprintfW(wzDir, MAX_PATH, L"%ws\\%ws", wzDynamicBase, wzAppName);
    dwLen = lstrlenW(wzDir) + 1;


    if (!wzDynamicDir || *pdwSize < dwLen) {
        *pdwSize = dwLen;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pdwSize = dwLen;
    lstrcpyW(wzDynamicDir, wzDir);

    // Cache this for future use.

    Set(ACTAG_APP_DYNAMIC_DIRECTORY, wzDynamicDir, dwLen * sizeof(WCHAR), 0);

Exit:
    SAFEDELETEARRAY(wzDynamicBase);
    SAFEDELETEARRAY(wzAppName);
    SAFEDELETEARRAY(wzAppCtxDynamicDir);

    return hr;
}

STDMETHODIMP CApplicationContext::GetAppCacheDirectory(LPWSTR wzCacheDir,
                                                       DWORD *pdwSize)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  wzCacheBase = NULL;
    LPWSTR                                  wzAppName = NULL;
    LPWSTR                                  wzAppCtxCacheDir = NULL;
    WCHAR                                   wzDir[MAX_PATH];
    DWORD                                   dwLen;

    wzDir[0] = L'\0';

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check if the cache directory has already been set.

    hr = ::AppCtxGetWrapper(this, ACTAG_APP_CACHE_DIRECTORY, &wzAppCtxCacheDir);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (wzAppCtxCacheDir) {
        ASSERT(lstrlenW(wzAppCtxCacheDir));

        dwLen = lstrlenW(wzAppCtxCacheDir) + 1;
        if (!wzCacheDir || *pdwSize < dwLen) {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            *pdwSize = dwLen;
            goto Exit;
        }

        *pdwSize = dwLen;

        lstrcpyW(wzCacheDir, wzAppCtxCacheDir);
        goto Exit;
    }


    // Always recalculate cache directory, so it can be changed on-demand

    hr = ::AppCtxGetWrapper(this, ACTAG_APP_CACHE_BASE, &wzCacheBase);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ::AppCtxGetWrapper(this, ACTAG_APP_NAME, &wzAppName);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!wzAppName || !wzCacheBase) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    PathRemoveBackslashW(wzCacheBase);

    wnsprintfW(wzDir, MAX_PATH, L"%ws\\%ws", wzCacheBase, wzAppName);
    dwLen = lstrlenW(wzDir) + 1;

    if (!wzCacheDir || *pdwSize < dwLen) {
        *pdwSize = dwLen;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    *pdwSize = dwLen;
    lstrcpyW(wzCacheDir, wzDir);

    // Cache this for future use.

    Set(ACTAG_APP_CACHE_DIRECTORY, wzCacheDir, dwLen * sizeof(WCHAR), 0);

Exit:
    SAFEDELETEARRAY(wzCacheBase);
    SAFEDELETEARRAY(wzAppName);
    SAFEDELETEARRAY(wzAppCtxCacheDir);

    return hr;
}

//
// RegisterKnownAssembly
//
// Params:
//
// [in]  pName      : IAssemblyName describing the known assembly
// [in]  pwzAsmURL  : Full URL to assembly described by pName
// [out] ppAsmOut   : Output IAssembly to be passed to BindToObject
//

STDMETHODIMP CApplicationContext::RegisterKnownAssembly(IAssemblyName *pName,
                                                        LPCWSTR pwzAsmURL,
                                                        IAssembly **ppAsmOut)
{
    HRESULT                               hr = S_OK;
    DWORD                                 dwSize = 0;
    CLoadContext                         *pLoadContext = NULL;
    CAssembly                            *pAsm = NULL;
    IAssembly                            *pAsmActivated = NULL;
    WCHAR                                 wzLocalPath[MAX_PATH];
    LPWSTR                                wzURLCanonicalized=NULL;
    CCriticalSection                      cs(&_cs);

    if (!pName || !pwzAsmURL || !ppAsmOut) {
        hr = E_INVALIDARG;
        return hr;
    }

    if (CAssemblyName::IsPartial(pName)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }
    
    dwSize = sizeof(pLoadContext);
    hr = Get(ACTAG_LOAD_CONTEXT_DEFAULT, &pLoadContext, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (FAILED(hr) || !pLoadContext) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // See if we know about this assembly already

    hr = pLoadContext->CheckActivated(pName, ppAsmOut);
    if (hr == S_OK) {
        // Something with this name is already registered!

        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        goto Exit;
    }

    // Create the activated assembly node, and load context.

    wzURLCanonicalized = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzURLCanonicalized)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_URL_LENGTH;
    hr = UrlCanonicalizeUnescape(pwzAsmURL, wzURLCanonicalized, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Create a bogus CAssembly just to hold the load context. Mark all
    // methods as disabled.

    pAsm = NEW(CAssembly);
    if (!pAsm) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_PATH;
    hr = PathCreateFromUrlWrap(wzURLCanonicalized, wzLocalPath, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pAsm->InitDisabled(pName, wzLocalPath);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Now add ourselves to the default load context

    hr = pLoadContext->AddActivation(pAsm, &pAsmActivated);
    if (FAILED(hr)) {
        goto Exit;
    }
    else if (hr == S_FALSE) {
        SAFERELEASE(pAsmActivated);
        SAFERELEASE(pAsm);
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        goto Exit;
    }

    // Hand out IAssembly

    (*ppAsmOut) = pAsm;
    (*ppAsmOut)->AddRef();

Exit:
    cs.Unlock();

    SAFEDELETEARRAY(wzURLCanonicalized);
    SAFERELEASE(pLoadContext);
    SAFERELEASE(pAsm);

    return hr;
}

//
// PrefetchAppConfigFile
//

STDMETHODIMP CApplicationContext::PrefetchAppConfigFile()
{
    HRESULT                               hr = S_OK;
    DWORD                                 dwSize;
    DWORD                                 dwLen;
    DWORD                                 cbLen;
    CNodeFactory                         *pNFAppCfg = NULL;
    CCriticalSection                      cs(&g_csDownload);
    WCHAR                                 wzCacheFileName[MAX_PATH];
    LPWSTR                                wzAppBase=NULL;
    LPWSTR                                wzCfgURL=NULL;
    LPWSTR                                pwzAppCfgFile = NULL;

    // Check if the node factory for the app.cfg exists. If so, then
    // we're already done.

    dwSize = sizeof(pNFAppCfg);
    hr = Get(ACTAG_APP_CFG_INFO, &pNFAppCfg, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (hr == S_OK) {
        // Already downloaded/parsed. Don't need to download.
        goto Exit;
    }

    // Get the URL to the cfg file:

    wzAppBase = NEW(WCHAR[MAX_URL_LENGTH*2+2]);
    if (!wzAppBase)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzCfgURL = wzAppBase + MAX_URL_LENGTH + 1;

    wzAppBase[0] = L'\0';

    cbLen = MAX_URL_LENGTH * sizeof(WCHAR);
    hr = Get(ACTAG_APP_BASE_URL, wzAppBase, &cbLen, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwLen = lstrlenW(wzAppBase);
    if (!dwLen) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (wzAppBase[dwLen - 1] != L'\0') {
        lstrcatW(wzAppBase, L"/");
    }
    
    hr = ::AppCtxGetWrapper(this, ACTAG_APP_CONFIG_FILE, &pwzAppCfgFile);
    if (FAILED(hr) || hr == S_FALSE) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = MAX_URL_LENGTH;
    hr = UrlCombineUnescape(wzAppBase, pwzAppCfgFile, wzCfgURL, &dwLen, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Ignore any async cfg download going on, and just do a
    // URLDownloadToCacheFile. After we have the CFG file, and it's parsed,
    // we can serialize storing the node factory into the appctx.

    // Download the file. URLDownloadToCacheFile returns immediately with
    // the source path, if the URL is file://

    hr = URLDownloadToCacheFile(NULL, wzCfgURL, wzCacheFileName,
                                MAX_PATH, 0, NULL);
    if (FAILED(hr)) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    // Lock download critical section so ApplyPolicy's logic to parse the
    // app.cfg file doesn't race with us.

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ReadConfigSettings(this, wzCacheFileName, NULL);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }

    hr = SetAppCfgFilePath(this, wzCacheFileName);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }

    cs.Unlock();

Exit:
    SAFERELEASE(pNFAppCfg);
    SAFEDELETEARRAY(pwzAppCfgFile);
    SAFEDELETEARRAY(wzAppBase);

    return hr;
}

STDMETHODIMP CApplicationContext::SxsActivateContext(ULONG_PTR *lpCookie)
{
    HRESULT                                     hr = S_OK;
    HANDLE                                      hActCtx = INVALID_HANDLE_VALUE;
    BOOL                                        bRet;
    DWORD                                       dwSize;
    CCriticalSection                            cs(&_cs);
    
    dwSize = sizeof(hActCtx);
    hr = Get(ACTAG_SXS_ACTIVATION_CONTEXT, &hActCtx, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }
    
        dwSize = sizeof(hActCtx);
        hr = Get(ACTAG_SXS_ACTIVATION_CONTEXT, &hActCtx, &dwSize, 0);
        if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
            hr = CreateActCtx(&hActCtx);
            if (FAILED(hr)) {
                // BUGBUG: Should we convert this to S_FALSE (for cases such
                // as manifest not existing?)
                cs.Unlock();
                goto Exit;
            }
        }
        else if (hr == S_OK && hActCtx == INVALID_HANDLE_VALUE) {
            // We failed previously.
    
            cs.Unlock();
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            goto Exit;
        }
        else if (FAILED(hr)) {
            cs.Unlock();
            goto Exit;
        }
    
        cs.Unlock();
    }
    else if (FAILED(hr)) {
        goto Exit;
    }

    // Now, we must have a valid hActCtx. Activate it.

    // No need to call InitSxsProcs because the only way to get a valid
    // hActCtx is for CreateActCtx to have previously succeeded.

    bRet = (*g_pfnActivateActCtx)(hActCtx, lpCookie); 
    if (!bRet) { 
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    if (hActCtx && hActCtx != INVALID_HANDLE_VALUE) {
        (*g_pfnReleaseActCtx)(hActCtx);
    }

    return hr;
}

STDMETHODIMP CApplicationContext::SxsDeactivateContext(ULONG_PTR ulCookie)
{
    HRESULT                                     hr = S_OK;
    DWORD                                       dwFlags = 0;
    BOOL                                        bRet;

    if (!InitSxsProcs()) {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto Exit;
    }

    __try {
        bRet = (*g_pfnDeactivateActCtx)(dwFlags, ulCookie);
        if (!bRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // No mapping between NT STATUS_ code for the exeception raised
        // and Win32 error code.

        hr = E_FAIL;
    }

Exit:
    return hr;
}

HRESULT CApplicationContext::CreateActCtx(HANDLE *phActCtx)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      wzAppBase = NULL;
    WCHAR                                       wzCfgFileName[MAX_PATH];
    WCHAR                                       wzSourcePath[MAX_PATH];
    LPWSTR                                      pwzSourceURL = NULL;
    DWORD                                       dwSize;
    DWORD                                       dwLen;
    ACTCTXW                                     actctx;
    LPWSTR                                      pwzExt;

    ASSERT(phActCtx);

    *phActCtx = NULL;

    if (!InitSxsProcs()) {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto Exit;
    }

    pwzSourceURL = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzSourceURL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzAppBase = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzSourceURL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzAppBase[0] = L'\0';
    memset(&actctx, 0, sizeof(actctx));

    // Get the appbase

    dwSize = MAX_URL_LENGTH * sizeof(WCHAR);
    hr = Get(ACTAG_APP_BASE_URL, wzAppBase, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    dwLen = lstrlenW(wzAppBase);
    if (dwLen >= MAX_URL_LENGTH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }
    else if (!dwLen) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    if (wzAppBase[dwLen - 1] != L'/' && wzAppBase[dwLen - 1] != L'\\') {
        lstrcatW(wzAppBase, L"/");
    }

    // Get the config file name
    // BUGBUG: Do we care if the extension was not ".config"?

    dwSize = MAX_PATH;
    hr = Get(ACTAG_APP_CONFIG_FILE, wzCfgFileName, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Build URL to app.cfg

    dwSize = MAX_URL_LENGTH;
    hr = UrlCombineUnescape(wzAppBase, wzCfgFileName, pwzSourceURL, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Only allow file:// URLs for config file path

    if (UrlIsW(pwzSourceURL, URLIS_FILEURL)) {
        // Strip off .config, and replace it with .manifest
    
        pwzExt = PathFindExtensionW(pwzSourceURL);
        *pwzExt = L'\0';
    
        if (lstrlenW(pwzSourceURL) + lstrlenW(FILE_EXT_MANIFEST) + 1 >= MAX_URL_LENGTH) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }
    
        lstrcatW(pwzSourceURL, FILE_EXT_MANIFEST);
    
        dwLen = MAX_PATH;
        hr = PathCreateFromUrlWrap(pwzSourceURL, wzSourcePath, &dwLen, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        // Check for file existence
    
        if (GetFileAttributes(wzSourcePath) == -1) {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Exit;
        }
    
        // Crate the activation context
    
        actctx.cbSize = sizeof(ACTCTXW);
        actctx.dwFlags = 0;
        actctx.lpSource = wzSourcePath;
    
        *phActCtx = (*g_pfnCreateActCtxW)(&actctx);
        if (*phActCtx == INVALID_HANDLE_VALUE) { 
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    // Cache activation context

    hr = Set(ACTAG_SXS_ACTIVATION_CONTEXT, phActCtx, sizeof(HANDLE), 0);
    if (FAILED(hr)) {
        if (*phActCtx) {
            (*g_pfnReleaseActCtx)(*phActCtx);
        }

        goto Exit;
    }

Exit:
    if (FAILED(hr)) {
        // Cache the fact that we tried to activate, and it failed.
        *phActCtx = INVALID_HANDLE_VALUE;
        Set(ACTAG_SXS_ACTIVATION_CONTEXT, phActCtx, sizeof(HANDLE), 0);
    }

    SAFEDELETEARRAY(pwzSourceURL);
    SAFEDELETEARRAY(wzAppBase);

    return hr;
}

HRESULT CApplicationContext::Lock()
{
    HRESULT                                      hr = S_OK;

    __try {
        EnterCriticalSection(&_cs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CApplicationContext::Unlock()
{
    LeaveCriticalSection(&_cs);

    return S_OK;
}
    
BOOL InitSxsProcs()
{
    BOOL                                           bRet = FALSE;
    HMODULE                                        hMod;
    static BOOL                                    bInitialized = FALSE;

    if (g_hKernel32Sxs != 0) {
        return TRUE;
    }

    if (bInitialized) {
        return g_hKernel32Sxs != 0;
    }

    hMod = WszGetModuleHandle(L"kernel32.dll");
    if (!hMod) {
        bInitialized = TRUE;
        return FALSE;
    }

    g_pfnCreateActCtxW = (PFNCREATEACTCTXW)GetProcAddress(hMod, "CreateActCtxW");
    g_pfnAddRefActCtx = (PFNADDREFACTCTX)GetProcAddress(hMod, "AddRefActCtx");
    g_pfnReleaseActCtx = (PFNRELEASEACTCTX)GetProcAddress(hMod, "ReleaseActCtx");
    g_pfnActivateActCtx = (PFNACTIVATEACTCTX)GetProcAddress(hMod, "ActivateActCtx");
    g_pfnDeactivateActCtx = (PFNDEACTIVATEACTCTX)GetProcAddress(hMod, "DeactivateActCtx");

    if (g_pfnCreateActCtxW && g_pfnAddRefActCtx && g_pfnReleaseActCtx &&
        g_pfnActivateActCtx && g_pfnDeactivateActCtx) {

        InterlockedExchangePointer(&g_hKernel32Sxs, hMod);
    }

    bInitialized = TRUE;

    return g_hKernel32Sxs != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\actasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "naming.h"
#include "asm.h"
#include "actasm.h"
#include "lock.h"

//
// Activated Assembly Node
//

CActivatedAssembly::CActivatedAssembly(IAssembly *pAsm, IAssemblyName *pName)
: _pAsm(pAsm)
, _pName(pName)
{
    ASSERT(pAsm && pName);

    _pAsm->AddRef();
    _pName->AddRef();
}

CActivatedAssembly::~CActivatedAssembly()
{
    SAFERELEASE(_pAsm);
    SAFERELEASE(_pName);
}

//
// Load Context
//

CLoadContext::CLoadContext(LOADCTX_TYPE ctxType)
: _ctxType(ctxType)
, _cRef(1)
{
}

CLoadContext::~CLoadContext()
{
    int                                i;
    LISTNODE                           pos;
    CActivatedAssembly                *pActAsmCur;

    for (i = 0; i < DEPENDENCY_HASH_TABLE_SIZE; i++) {
        pos = _hashDependencies[i].GetHeadPosition();

        while (pos) {
            pActAsmCur = _hashDependencies[i].GetNext(pos);
            ASSERT(pActAsmCur);

            SAFEDELETE(pActAsmCur);
        }

        _hashDependencies[i].RemoveAll();
    }

    DeleteCriticalSection(&_cs);
}

HRESULT CLoadContext::Init()
{
    HRESULT                              hr = S_OK;
    
    __try {
        InitializeCriticalSection(&_cs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CLoadContext::Lock()
{
    HRESULT                              hr = S_OK;
    
    __try {
        EnterCriticalSection(&_cs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CLoadContext::Unlock()
{
    LeaveCriticalSection(&_cs);

    return S_OK;
}

HRESULT CLoadContext::Create(CLoadContext **ppLoadContext, LOADCTX_TYPE ctxType)
{
    HRESULT                               hr = S_OK;
    CLoadContext                         *pLoadContext = NULL;

    if (!ppLoadContext) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppLoadContext = NULL;

    pLoadContext = NEW(CLoadContext(ctxType));
    if (!pLoadContext) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pLoadContext->Init();
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppLoadContext = pLoadContext;
    (*ppLoadContext)->AddRef();

Exit:
    SAFERELEASE(pLoadContext);

    return hr;
}

HRESULT CLoadContext::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) {
        *ppv = static_cast<IUnknown *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CLoadContext::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CLoadContext::Release()
{
    LONG              lRef = InterlockedDecrement((LONG *)&_cRef);

    if (!lRef) {
        delete this;
    }

    return lRef;
}

HRESULT CLoadContext::CheckActivated(IAssemblyName *pName, IAssembly **ppAsm)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      pwzAsmName = NULL;
    DWORD                                       dwSize;
    DWORD                                       dwHash;
    DWORD                                       dwDisplayFlags = ASM_DISPLAYF_CULTURE;
    LISTNODE                                    pos;
    CActivatedAssembly                         *pActAsm;
    CCriticalSection                            cs(&_cs);

    ASSERT(pName && ppAsm);
    ASSERT(!CAssemblyName::IsPartial(pName));

    *ppAsm = NULL;

    if (CCache::IsStronglyNamed(pName)) {
        dwDisplayFlags |= (ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_VERSION);
    }

    // Extract the display name

    dwSize = 0;
    hr = pName->GetDisplayName(NULL, &dwSize, dwDisplayFlags);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pwzAsmName = NEW(WCHAR[dwSize]);
    if (!pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pName->GetDisplayName(pwzAsmName, &dwSize, dwDisplayFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Hash the name, and lookup

    dwHash = HashString(pwzAsmName, DEPENDENCY_HASH_TABLE_SIZE, FALSE);

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    pos = _hashDependencies[dwHash].GetHeadPosition();
    while (pos) {
        CAssembly                 *pCAsm;
        
        pActAsm = _hashDependencies[dwHash].GetNext(pos);
        ASSERT(pActAsm);

        pCAsm = dynamic_cast<CAssembly *>(pActAsm->_pAsm);
        ASSERT(pCAsm);

        if ((pName->IsEqual(pActAsm->_pName, ASM_CMPF_DEFAULT) == S_OK) &&
             !pCAsm->IsPendingDelete()) {
            // Found activated assembly.
            
            *ppAsm = pActAsm->_pAsm;
            (*ppAsm)->AddRef();

            cs.Unlock();
            goto Exit;
        }
    }

    cs.Unlock();

    // Did not find matching activated assembly in this load context

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(pwzAsmName);

    return hr;
}

//
// CLoadContext::AddActivation tries to add pAsm into the given load context.
// In the event of a race, and the two assemblies being added are for the
// exact same name definition, then hr==S_FALSE will be returned, and
// ppAsmActivated will point to the already-activated assembly.
//

HRESULT CLoadContext::AddActivation(IAssembly *pAsm, IAssembly **ppAsmActivated)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      pwzAsmName = NULL;
    DWORD                                       dwSize;
    DWORD                                       dwHash;
    DWORD                                       dwDisplayFlags = ASM_DISPLAYF_CULTURE;
    CCriticalSection                            cs(&_cs);
    CActivatedAssembly                         *pActAsm;
    IAssemblyName                              *pName = NULL;
    CActivatedAssembly                         *pActAsmCur;
    CAssembly                                  *pCAsm = dynamic_cast<CAssembly *>(pAsm);
    LISTNODE                                    pos;

    ASSERT(pAsm && pCAsm);

    hr = pAsm->GetAssemblyNameDef(&pName);
    if (FAILED(hr)) {
        goto Exit;
    }

    ASSERT(!CAssemblyName::IsPartial(pName));

    if (CCache::IsStronglyNamed(pName)) {
        dwDisplayFlags |= (ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_VERSION);
    }
    
    // Extract the display name

    dwSize = 0;
    hr = pName->GetDisplayName(NULL, &dwSize, dwDisplayFlags);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pwzAsmName = NEW(WCHAR[dwSize]);
    if (!pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pName->GetDisplayName(pwzAsmName, &dwSize, dwDisplayFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Create activated assembly node, and put the node into the table

    pActAsm = NEW(CActivatedAssembly(pAsm, pName));
    if (!pActAsm) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    dwHash = HashString(pwzAsmName, DEPENDENCY_HASH_TABLE_SIZE, FALSE);

    hr = cs.Lock();
    if (FAILED(hr)) {
        SAFEDELETE(pActAsm);
        goto Exit;
    }

    // We should be able to just blindly add to the tail of this dependency
    // list, but just for sanity sake, make sure we don't already have
    // something with the same identity. If we do, then it means there must
    // have been two different downloads for the same name going on that didn't
    // get piggybacked into the same download object, before completion.

    pos = _hashDependencies[dwHash].GetHeadPosition();
    while (pos) {
        CAssembly                     *pCAsmCur;
        
        pActAsmCur = _hashDependencies[dwHash].GetNext(pos);
        ASSERT(pActAsmCur);
        pCAsmCur = dynamic_cast<CAssembly *>(pActAsmCur->_pAsm);
        
        if (pName->IsEqual(pActAsmCur->_pName, ASM_CMPF_DEFAULT) == S_OK &&
            !pCAsmCur->IsPendingDelete()) {
            // We must have hit a race adding to the load context. Return
            // the already-activated assembly.
            
            *ppAsmActivated = pActAsmCur->_pAsm;
            (*ppAsmActivated)->AddRef();

            SAFEDELETE(pActAsm);
            cs.Unlock();

            hr = S_FALSE;

            goto Exit;
        }
    }

    pCAsm->SetLoadContext(this);
    _hashDependencies[dwHash].AddTail(pActAsm);
    
    cs.Unlock();

Exit:
    SAFEDELETEARRAY(pwzAsmName);

    SAFERELEASE(pName);

    return hr;
}

HRESULT CLoadContext::RemoveActivation(IAssembly *pAsm)
{
    HRESULT                                     hr = S_OK;
    DWORD                                       dwSize;
    DWORD                                       dwDisplayFlags = ASM_DISPLAYF_CULTURE;
    LISTNODE                                    pos;
    LISTNODE                                    oldpos;
    CCriticalSection                            cs(&_cs);
    CActivatedAssembly                         *pActAsm;
    IAssemblyName                              *pName = NULL;
    LPWSTR                                      pwzAsmName = NULL;
    DWORD                                       dwHash;

    // By removing an activation, we may be losing the last ref count
    // on ourselves. Make sure the object is still alive, by doing a
    // manual addref/release around this block.

    AddRef(); 

    ASSERT(pAsm);

    hr = pAsm->GetAssemblyNameDef(&pName);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (CCache::IsStronglyNamed(pName)) {
        dwDisplayFlags |= (ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_VERSION);
    }

    // Extract the display name

    dwSize = 0;
    hr = pName->GetDisplayName(NULL, &dwSize, dwDisplayFlags);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pwzAsmName = NEW(WCHAR[dwSize]);
    if (!pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pName->GetDisplayName(pwzAsmName, &dwSize, dwDisplayFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Hash the name, and lookup

    dwHash = HashString(pwzAsmName, DEPENDENCY_HASH_TABLE_SIZE, FALSE);

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    pos = _hashDependencies[dwHash].GetHeadPosition();
    while (pos) {
        CAssembly               *pCAsm;
        
        oldpos = pos;
        pActAsm = _hashDependencies[dwHash].GetNext(pos);
        ASSERT(pActAsm);
        pCAsm = dynamic_cast<CAssembly *>(pActAsm->_pAsm);

        if (pName->IsEqual(pActAsm->_pName, ASM_CMPF_DEFAULT) == S_OK &&
            pCAsm->IsPendingDelete()) {

            if (pActAsm->_pAsm != pAsm) {
                continue;
            }

            // Found activated assembly.

            _hashDependencies[dwHash].RemoveAt(oldpos);

            // Leave critical section before deleting the activate
            // assembly node, because deleting the node causes the
            // pAssembly to be released, causing us to call the runtime
            // back to release the metadata import. This can't happen
            // while we hold a critical section, because we may deadlock
            // (issue with what GC mode we may be running in).

            cs.Unlock();
            SAFEDELETE(pActAsm);

            goto Exit;
        }
    }

    cs.Unlock();

    // Not found

    hr = S_FALSE;
    ASSERT(0);

Exit:
    SAFEDELETEARRAY(pwzAsmName);

    SAFERELEASE(pName);

    Release();

    return hr;
}

STDMETHODIMP_(LOADCTX_TYPE) CLoadContext::GetContextType()
{
    return _ctxType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\scavenger.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "scavenger.h"
#include "asmstrm.h"
#include "fusionheap.h"
#include "cache.h"
#include "naming.h"
#include "util.h"
#include "transprt.h"
#include "cacheUtils.h"
#include "enum.h"
#include "list.h"
#include "lock.h"

// global crit-sec for init dbs (reuse, defined at dllmain.cpp)
extern CRITICAL_SECTION g_csInitClb;

DWORD g_ScavengingThreadId=0;
HMODULE g_hFusionMod=0;

#define REG_VAL_FUSION_DOWNLOAD_CACHE_QUOTA_IN_KB           TEXT("DownloadCacheQuotaInKB")
DWORD g_DownloadCacheQuotaInKB;

#define REG_VAL_FUSION_DOWNLOAD_CACHE_USAGE     TEXT("DownloadCacheSize2")

extern BOOL g_bRunningOnNT;

HRESULT ScavengeDownloadCache();


class CScavengerNode
{
public:

    CScavengerNode();
    ~CScavengerNode();
    static LONG Compare(CScavengerNode *, CScavengerNode *);
    LPWSTR _pwzManifestPath;
    FILETIME _ftLastAccess;
    FILETIME _ftCreation;
    DWORD _dwAsmSize;
};

CScavengerNode::CScavengerNode()
{
    _pwzManifestPath=NULL;
    _dwAsmSize = 0;
    memset( &_ftLastAccess, 0, sizeof(FILETIME));
    memset( &_ftCreation,   0, sizeof(FILETIME));

}

CScavengerNode::~CScavengerNode()
{
    SAFEDELETEARRAY(_pwzManifestPath);
}

LONG CScavengerNode::Compare(CScavengerNode *pItem1, CScavengerNode *pItem2)
{
    return CompareFileTime( &(pItem1->_ftLastAccess), &(pItem2->_ftLastAccess));
}

//------------------- Cache Scavenging APIs ------------- --------------------



HRESULT CreateScavenger(IUnknown **ppAsmScavenger)
{
    HRESULT                       hr = S_OK;
    IAssemblyScavenger           *pScavenger = NULL;

    if (!ppAsmScavenger) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pScavenger = NEW(CScavenger);
    if (!pScavenger) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppAsmScavenger = pScavenger;
    (*ppAsmScavenger)->AddRef();

Exit:
    SAFERELEASE(pScavenger);

    return hr;
}

CScavenger::CScavenger()
{
    _cRef = 1;
}

CScavenger::~CScavenger()
{

}

HRESULT GetDownloadUsage(DWORD *pdwDownloadUsageInKB)
{
    HRESULT                         hr=S_OK;
    DWORD                           dwSize=0;
    DWORD                           dwType=0;
    DWORD                           lResult=0;
    HKEY                            hkey=0;
    DWORD                           dwDownloadUsage=0;

    if(g_bRunningOnNT)
    {
        lResult = RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    }
    else
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    }

    if(lResult == ERROR_SUCCESS) 
    {
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_DOWNLOAD_CACHE_USAGE, NULL,
                                          &dwType, (LPBYTE)&dwDownloadUsage, &dwSize);
        if (lResult == ERROR_SUCCESS) 
        {
            if(pdwDownloadUsageInKB)
                *pdwDownloadUsageInKB = dwDownloadUsage;
            goto exit;
        }
    }

    hr = FusionpHresultFromLastError();

exit:

    if (hkey) 
        RegCloseKey(hkey);

    return hr;
}

HRESULT SetDownLoadUsage(   /* [in] */ BOOL  bUpdate,
                            /* [in] */ int   dwDownloadUsage)
{
    HRESULT                         hr=S_OK;
    DWORD                           dwSize=0;
    DWORD                           dwType=0;
    DWORD                           lResult=0;
    HKEY                            hkey=0;
    DWORD                           dwDisposition=0;
    DWORD                           dwCurrDownloadCacheSize=0;

    if(g_bRunningOnNT)
    {
        lResult = RegCreateKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, 
                                  NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition );
    }
    else
    {
        lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, 
                                  NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition );
    }


    if(lResult != ERROR_SUCCESS) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    if(bUpdate)
    {
        hr = GetDownloadUsage(&dwCurrDownloadCacheSize);
        dwDownloadUsage += dwCurrDownloadCacheSize;
    }

    if(dwDownloadUsage < 0)
        dwDownloadUsage = 0;

    dwSize = sizeof(DWORD);
    lResult = RegSetValueEx(hkey, REG_VAL_FUSION_DOWNLOAD_CACHE_USAGE, NULL,
                                      REG_DWORD, (LPBYTE)&dwDownloadUsage, dwSize);
    if (lResult != ERROR_SUCCESS) 
    {
        hr = FusionpHresultFromLastError();
    }


exit :

    if (hkey)
        RegCloseKey(hkey);

    return hr;
}

DWORD GetDownloadTarget()
{
    HRESULT hr;
    DWORD dwCurrUsage = 0;

    hr = GetDownloadUsage(&dwCurrUsage);

    if(dwCurrUsage > g_DownloadCacheQuotaInKB)
        return g_DownloadCacheQuotaInKB/2 + 1;
    else
        return 0;

}

HRESULT GetScevengerQuotasFromReg(DWORD *pdwZapQuotaInGAC,
                                  DWORD *pdwDownloadQuotaAdmin,
                                  DWORD *pdwDownloadQuotaUser)
{
    HRESULT                         hr=S_OK;
    DWORD                           dwSize=0;
    DWORD                           dwType=0;
    DWORD                           lResult=0;
    HKEY                            hkey=0;
    HKEY                            hCUkey=0;
    DWORD                           dwDownloadLMQuota=0;
    DWORD                           dwDownloadCUQuota=0;


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if(lResult == ERROR_SUCCESS) 
    {
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_DOWNLOAD_CACHE_QUOTA_IN_KB, NULL,
                                         &dwType, (LPBYTE)&dwDownloadLMQuota, &dwSize);
        if (lResult != ERROR_SUCCESS) 
        {
            dwDownloadLMQuota = 0;
        }
    }

    if((RegOpenKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hCUkey) == ERROR_SUCCESS))
    {

        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hCUkey, REG_VAL_FUSION_DOWNLOAD_CACHE_QUOTA_IN_KB, NULL,
                                          &dwType, (LPBYTE)&dwDownloadCUQuota, &dwSize);
        if (lResult != ERROR_SUCCESS) 
        {
            dwDownloadCUQuota = 0;
        }
    }

    if(!dwDownloadLMQuota)
    {
        g_DownloadCacheQuotaInKB = 50000; // default Download Cache Quota
    }
    else
    {
        g_DownloadCacheQuotaInKB = dwDownloadLMQuota;
    }

    if(dwDownloadCUQuota)
    {
        g_DownloadCacheQuotaInKB = min(dwDownloadCUQuota, g_DownloadCacheQuotaInKB);
    }

    if(pdwZapQuotaInGAC)
         *pdwZapQuotaInGAC = 0;

    if(pdwDownloadQuotaAdmin)
         *pdwDownloadQuotaAdmin = g_DownloadCacheQuotaInKB;

    if(pdwDownloadQuotaUser)
         *pdwDownloadQuotaUser = g_DownloadCacheQuotaInKB;

    if (hkey) {
        RegCloseKey(hkey);
    }

    if (hCUkey) {
        RegCloseKey(hCUkey);
    }

    return hr;
}

HRESULT  CScavenger::GetCurrentCacheUsage( /* [in] */ DWORD *pdwZapUsage,
                                           /* [in] */ DWORD *pdwDownloadUsage)
{
    if(pdwZapUsage)
        *pdwZapUsage = 0;

    return GetDownloadUsage(pdwDownloadUsage);
}

HRESULT CScavenger::GetCacheDiskQuotas( /* [out] */ DWORD *pdwZapQuotaInGAC,
                                                /* [out] */ DWORD *pdwDownloadQuotaAdmin,
                                                /* [out] */ DWORD *pdwDownloadQuotaUser)
{
    return GetScevengerQuotasFromReg(pdwZapQuotaInGAC, pdwDownloadQuotaAdmin, pdwDownloadQuotaUser);
}

HRESULT CScavenger::SetCacheDiskQuotas(
                            /* [in] */ DWORD dwZapQuotaInGAC,
                            /* [in] */ DWORD dwDownloadQuotaAdmin,
                            /* [in] */ DWORD dwDownloadQuotaUser)
{
    HRESULT                         hr=S_OK;
    DWORD                           dwSize=0;
    DWORD                           dwType=0;
    DWORD                           lResult=0;
    HKEY                            hkey=0;
    DWORD                           dwDisposition=0;
    DWORD                           dwCurrDownloadQuotaAdmin=0;
    DWORD                           dwDownloadQuota=0;

    if(FAILED(CheckAccessPermissions()))
    {
        lResult = RegCreateKeyEx(HKEY_CURRENT_USER, REG_KEY_FUSION_SETTINGS, 0, 
                                  NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition );
        dwDownloadQuota = dwDownloadQuotaUser;
    }
    else
    {
        lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, 
                                  NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition );
        dwDownloadQuota = dwDownloadQuotaAdmin;
    }

    if(lResult != ERROR_SUCCESS) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegSetValueEx(hkey, REG_VAL_FUSION_DOWNLOAD_CACHE_QUOTA_IN_KB, NULL,
                                    REG_DWORD, (LPBYTE)&dwDownloadQuota, dwSize);
    if (lResult != ERROR_SUCCESS) 
    {
        hr = FusionpHresultFromLastError();
    }

    GetScevengerQuotasFromReg(NULL, NULL, NULL);

exit :

    if (hkey) {
        RegCloseKey(hkey);
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CScavenger::ScavengeAssemblyCache
// Flush private cache and if required, scavenge private cache based on LRU.
//---------------------------------------------------------------------------
HRESULT CScavenger::ScavengeAssemblyCache()
{
    return DoScavengingIfRequired( TRUE );
}


HRESULT MoveAllFilesFromDir(LPWSTR pszSrcDirPath, LPWSTR pszDestDirPath)
{
    HRESULT hr = S_OK;
    TCHAR szDestFilePath[MAX_PATH+1];
    TCHAR szBuf[MAX_PATH+1];
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    StrCpy(szBuf, pszSrcDirPath);
    StrCat(szBuf, TEXT("\\*"));

    if ((hf = FindFirstFile(szBuf, &fd)) == INVALID_HANDLE_VALUE) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    StrCpy(szBuf, pszSrcDirPath);

    do
    {
        if ( (FusionCompareStringI(fd.cFileName, TEXT(".")) == 0) ||
             (FusionCompareStringI(fd.cFileName, TEXT("..")) == 0))
            continue;

        wnsprintf(szBuf, MAX_PATH-1, TEXT("%s\\%s"), pszSrcDirPath, fd.cFileName);
        if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
        {
            wnsprintf(szDestFilePath, MAX_PATH-1, TEXT("%s\\%s"), pszDestDirPath, fd.cFileName);
            if(!MoveFile( szBuf, szDestFilePath))
            {
                hr = FusionpHresultFromLastError();
                if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
                       || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
                {
                    hr = S_OK;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            // BUGBUG: found dir in assembly should we delete this dir ??
        }

    } while (FindNextFile(hf, &fd));

    if ((hr == S_OK) && (GetLastError() != ERROR_NO_MORE_FILES))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    if (hf != INVALID_HANDLE_VALUE)
    {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    // after moving all files attempt to remove the source dir
    if (!RemoveDirectory(pszSrcDirPath)) 
    {
        hr = FusionpHresultFromLastError();
        if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
               || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
        {
            hr = S_OK;
        }
    }

exit :

    if (hf != INVALID_HANDLE_VALUE)
    {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    return hr;
}

HRESULT DeleteAssemblyFiles(DWORD dwCacheFlags, LPCWSTR pszCustomPath, LPWSTR pszManFilePath)
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp=NULL;
    LPWSTR pszManifestPath=pszManFilePath;
    TCHAR szPendDelDirPath[MAX_PATH+1];
    TCHAR szAsmDirPath[MAX_PATH+1];
#define TEMP_PEND_DIR 10

    DWORD dwLen = 0;

    if(!pszManifestPath)
    {
        hr = E_FAIL;
        goto exit;
    }

    dwLen = lstrlen(pszManifestPath);
    ASSERT(dwLen <= MAX_PATH);

    lstrcpy(szAsmDirPath, pszManifestPath);

    pszTemp = PathFindFileName(szAsmDirPath);

    if(pszTemp > szAsmDirPath)
    {
        *(pszTemp-1) = L'\0';
    }

    dwLen = MAX_PATH;
    hr = GetPendingDeletePath( pszCustomPath, dwCacheFlags, szPendDelDirPath, &dwLen);
    if (FAILED(hr)) {
        goto exit;
    }

    if(lstrlen(szPendDelDirPath) + TEMP_PEND_DIR + 1 >= MAX_PATH)
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    GetRandomFileName( szPendDelDirPath, TEMP_PEND_DIR);

    if(!MoveFile( szAsmDirPath, szPendDelDirPath))
    {
        hr = FusionpHresultFromLastError();
        if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
               || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
        {
            hr = S_OK;
            goto exit;
        }
    }
    else
    {
        hr = RemoveDirectoryAndChildren(szPendDelDirPath);
        hr = S_OK; // don't worry about passing back error here. its already in pend-del dir.
        goto exit;
    }

    // looks like there are some in-use files here.
    // move all the asm files to pend del dir.
    if(!CreateDirectory(szPendDelDirPath, NULL))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    hr = MoveAllFilesFromDir(szAsmDirPath, szPendDelDirPath);

    if(hr == S_OK)
    {
        // assembly deleted successfully delete/pend all temp files.
        hr = RemoveDirectoryAndChildren(szPendDelDirPath);
        hr = S_OK; // don't worry about passing back error here. its already in pend-del dir.
    }
    else
    {
        // could not delete assembly; restore all files back to original state.
        HRESULT hrTemp = MoveAllFilesFromDir(szPendDelDirPath, szAsmDirPath);
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
    }

exit :

    if(hr == S_OK)
    {
        pszTemp = PathFindFileName(szAsmDirPath);

        if(pszTemp > szAsmDirPath)
        {
            *(pszTemp-1) = L'\0';
        }

        // now that we have two levels of dirs...try to remove parent dir also
        // this succeeds only if it is empty, don't worry about return value.
        RemoveDirectory(szAsmDirPath);
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CScavenger::DeleteAssembly
//         Deletes the given TransCache entry after deleting bits.
// ---------------------------------------------------------------------------
HRESULT
CScavenger::DeleteAssembly( DWORD dwCacheFlags, LPCWSTR pszCustomPath, LPWSTR pszManFilePath, BOOL bForceDelete)
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp=NULL;
    TCHAR szPendDelDirPath[MAX_PATH+1];
    TCHAR szAsmDirPath[MAX_PATH+1];
#define TEMP_PEND_DIR 10
    DWORD dwLen = 0;
    LPWSTR pszManifestPath=pszManFilePath;

    ASSERT( pszManFilePath);

    if((g_bRunningOnNT) && bForceDelete)
        return DeleteAssemblyFiles( dwCacheFlags, pszCustomPath, pszManFilePath);

    dwLen = lstrlen(pszManifestPath);
    ASSERT(dwLen <= MAX_PATH);

    DWORD dwAttrib;

    if((dwAttrib = GetFileAttributes(pszManifestPath)) == -1)
    {
        if(bForceDelete)
        {
            return DeleteAssemblyFiles( dwCacheFlags, pszCustomPath, pszManFilePath);
        }

        hr = S_FALSE;
        goto exit;
    }

    StrCpy(szAsmDirPath, pszManifestPath);

    if(!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        // looks manifestFilePath is passed in. knock-off the filename.
        pszTemp = PathFindFileName(szAsmDirPath);

        if(pszTemp > szAsmDirPath)
        {
            *(pszTemp-1) = L'\0';
        }
    }

    dwLen = MAX_PATH;
    hr = GetPendingDeletePath( pszCustomPath, dwCacheFlags, szPendDelDirPath, &dwLen);
    if (FAILED(hr)) {
        goto exit;
    }

    if(lstrlen(szPendDelDirPath) + TEMP_PEND_DIR + 1 >= MAX_PATH)
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    GetRandomFileName( szPendDelDirPath, TEMP_PEND_DIR);

    if(!g_bRunningOnNT) // try to delete assembly file on Win9x.
    {
        if(!DeleteFile(pszManifestPath))
        {
            hr = FusionpHresultFromLastError();
            if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
                   || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
            {
                hr = S_OK;
            }
            else
            {
                goto exit;
            }
        }
    }

    if(!MoveFile( szAsmDirPath, szPendDelDirPath))
    {
        hr = FusionpHresultFromLastError();
        if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
               || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
        {
            hr = S_OK;
            goto exit;
        }
    }
    else
    {
        hr = RemoveDirectoryAndChildren(szPendDelDirPath);
        hr = S_OK; // don't worry about passing back error here. its already in pend-del dir.
        goto exit;
    }

exit :
    if( (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)) ||
           (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION)) )
    {
        // We cannot delete this as someone else has locked it...
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
    }

    if(hr == S_OK)
    {
        pszTemp = PathFindFileName(szAsmDirPath);

        if(pszTemp > szAsmDirPath)
        {
            *(pszTemp-1) = L'\0';
            RemoveDirectory(szAsmDirPath);
        }
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CScavenger::NukeDowloadedCache()
// scavenging interface
//---------------------------------------------------------------------------
HRESULT CScavenger::NukeDownloadedCache()
{
    HRESULT hr=S_OK;
    WCHAR szCachePath[MAX_PATH+1];
    LPWSTR pszCacheLoc = NULL;
    DWORD dwLen=MAX_PATH;

   hr = GetCacheLoc(ASM_CACHE_DOWNLOAD, &pszCacheLoc);
   if (FAILED(hr)) {
        goto exit;
   }

    if ((lstrlen(pszCacheLoc) + lstrlen(FUSION_CACHE_DIR_DOWNLOADED_SZ) + 1) >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto exit;
    }

    StrCpy(szCachePath, pszCacheLoc);
    PathRemoveBackslash(szCachePath);
    StrCat(szCachePath, FUSION_CACHE_DIR_DOWNLOADED_SZ);

    // remove the complete downloaded dir. tree
    hr = RemoveDirectoryAndChildren(szCachePath);

    if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
           || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
    {
        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        SetDownLoadUsage( FALSE, 0);
    }

exit :
    return hr;
}

//
// IUnknown boilerplate...
//

STDMETHODIMP
CScavenger::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
                || IsEqualIID(riid, IID_IAssemblyScavenger)
       )
    {
        *ppvObj = static_cast<IAssemblyScavenger*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CScavenger::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

STDMETHODIMP_(ULONG)
CScavenger::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

STDAPI NukeDownloadedCache()
{
    return CScavenger::NukeDownloadedCache();
}


HRESULT DeleteAssemblyBits(LPCTSTR pszManifestPath)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH+1];
    DWORD           dwLen = 0;

    if(!pszManifestPath)
        goto exit;

    dwLen = lstrlen(pszManifestPath);
    ASSERT(dwLen <= MAX_PATH);

    lstrcpy(szPath, pszManifestPath);

    // making c:\foo\a.dll -> c:\foo for RemoveDirectoryAndChd()
    while( szPath[dwLen] != '\\' && dwLen > 0 )
        dwLen--;

    if( szPath[dwLen] == '\\')
        szPath[dwLen] = '\0';

    // BUGBUG : check for root and WinDir...
    //  remove the disk file
    hr = RemoveDirectoryAndChildren(szPath);

    if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
            || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
    {
        // file is not there, this not an error.
        hr = S_OK;
        goto exit;
    }

    if(hr == S_OK)
    {
        // making c:\foo\a.dll -> c:\foo for RemoveDirectory();
        while( szPath[dwLen] != '\\' && dwLen > 0 )
            dwLen--;

        if( szPath[dwLen] == '\\')
            szPath[dwLen] = '\0';

        // now that we have two levels of dirs...try to remove parent dir also
        // this succeeds only if it is empty, don't worry about return value.
        RemoveDirectory(szPath);
    }

exit :
    return hr;
}


HRESULT StartScavenging(LPVOID pSynchronous)
{
    HRESULT            hr = S_OK;
    DWORD              dwFreedKBSize = 0;
    CCriticalSection   cs(&g_csInitClb);

    hr = ScavengeDownloadCache();

    if(FAILED(hr))
        goto exit;


exit:

    HRESULT hrRet = cs.Lock();
    if (FAILED(hrRet)) {
        return hrRet;
    }

    g_ScavengingThreadId=0;

    cs.Unlock();

    if (!pSynchronous)
        FreeLibraryAndExitThread( g_hFusionMod, hr);

    return S_OK;
}


HRESULT CreateScavengerThread(BOOL bSynchronous)
{
    HRESULT hr=S_OK;
    HRESULT hrCS=S_OK;
    HANDLE hThread=0;
    DWORD dwThreadId=0;
    HANDLE hThreadHandle=0;
    DWORD Error = 0;
    LPVOID  lpVoid=0;
    CCriticalSection cs(&g_csInitClb);

    hrCS = cs.Lock();
    if (FAILED(hrCS)) {
        return hrCS;
    }
    
    if(g_ScavengingThreadId)
    {
        /* Open Thread doesn't works only on Win2k, need to find somthing else here....
        // here we should also check if that thread is alive and actually working etc...
        if(hThreadHandle = OpenThread(STANDARD_RIGHTS_REQUIRED, 0, g_ScavengingThreadId) )
            goto exit;
        */
        hr = S_FALSE;
        goto exit;
    }

    if( bSynchronous )
    {
        g_ScavengingThreadId = GetCurrentThreadId();
        cs.Unlock();
        hr = StartScavenging( (LPVOID)TRUE );
        
        hrCS = cs.Lock();
        if (FAILED(hrCS)) {
            return hrCS;
        }

        g_ScavengingThreadId = 0;
    }
    else
    {
        g_hFusionMod = LoadLibrary(g_FusionDllPath);

        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) StartScavenging, (LPVOID)FALSE,  0, &dwThreadId);

        if (hThread == NULL)
        {
            Error = GetLastError();
            FreeLibrary(g_hFusionMod);
        }
        else
        {
            g_ScavengingThreadId = dwThreadId;
        }
    }

exit :

    cs.Unlock();

    if(hThread)
        CloseHandle(hThread);

    return hr;
}


HRESULT DoScavengingIfRequired(BOOL bSynchronous)
{
    HRESULT hr = S_OK;

    if(FAILED(hr = CreateCacheMutex()))
    {
        goto exit;
    }

    if(GetDownloadTarget())
        hr = CreateScavengerThread(bSynchronous);

exit:

    return hr;
}

HRESULT FlushOldAssembly(LPCWSTR pszCustomPath, LPWSTR pszAsmDirPath, LPWSTR pszManifestFileName, BOOL bForceDelete)
{
    HRESULT hr = S_OK;
    LPTSTR pszTemp=NULL, pszAsmDirName=NULL;
    TCHAR szParentDirPath[MAX_PATH+1];
    TCHAR szBuf[MAX_PATH+1];
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;

    ASSERT(pszAsmDirPath);

    lstrcpy(szParentDirPath, pszAsmDirPath);

    pszTemp = PathFindFileName(szParentDirPath);

    if(pszTemp > szParentDirPath)
    {
        *(pszTemp-1) = L'\0';
    }
    else
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pszAsmDirName = pszTemp;
    StrCpy(szBuf, szParentDirPath);
    StrCat(szBuf, TEXT("\\*"));

    if ((hf = FindFirstFile(szBuf, &fd)) == INVALID_HANDLE_VALUE) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    do
    {
        if ( (FusionCompareStringI(fd.cFileName, TEXT(".")) == 0) ||
             (FusionCompareStringI(fd.cFileName, TEXT("..")) == 0))
            continue;

        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
        {
            if(FusionCompareStringI(fd.cFileName, pszAsmDirName))
            {
                wnsprintf(szBuf, MAX_PATH, L"%s\\%s\\%s", szParentDirPath, fd.cFileName, pszManifestFileName);
                hr = CScavenger::DeleteAssembly(ASM_CACHE_DOWNLOAD, pszCustomPath, szBuf, bForceDelete);
                if(hr != S_OK)
                    goto exit;
            }
        }
        else
        {
            // BUGBUG: found file in parent dir; should we delete this ??
        }

    } while (FindNextFile(hf, &fd));

    if((hr == S_OK) && (GetLastError() != ERROR_NO_MORE_FILES))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

exit :

    if(hf != INVALID_HANDLE_VALUE)
    {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    return hr;
}

HRESULT CleanupTempDir(DWORD dwCacheFlags, LPCWSTR pszCustomPath)
{
    HRESULT hr = S_OK;
    TCHAR szPendDelDirPath[MAX_PATH+1];
    TCHAR szBuf[MAX_PATH+1];
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;

    DWORD dwLen = MAX_PATH;

    hr = GetPendingDeletePath( pszCustomPath, dwCacheFlags, szPendDelDirPath, &dwLen);
    if (FAILED(hr)) {
        goto exit;
    }

    StrCpy(szBuf, szPendDelDirPath);
    StrCat(szBuf, TEXT("\\*"));

    if((hf = FindFirstFile(szBuf, &fd)) == INVALID_HANDLE_VALUE) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    do
    {
        if ( (FusionCompareStringI(fd.cFileName, TEXT(".")) == 0) ||
             (FusionCompareStringI(fd.cFileName, TEXT("..")) == 0))
            continue;

        wnsprintf(szBuf, MAX_PATH-1, TEXT("%s\\%s"), szPendDelDirPath, fd.cFileName);

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            hr = RemoveDirectoryAndChildren(szBuf);
        }
        else
        {
            if(!DeleteFile(szBuf))
                hr = FusionpHresultFromLastError();

        }

    } while (FindNextFile(hf, &fd));

    if((hr == S_OK) && (GetLastError() != ERROR_NO_MORE_FILES))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

exit :

    if(hf != INVALID_HANDLE_VALUE)
    {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    return hr;
}

GetScavengerLock()
{
    /*
    if(!g_ScavengerMutex)
    {

    }
    */
    return 0;
}

ReleaseeScavengerLock()
{

    return 0;
}

HRESULT GetCurrTime(FILETIME *pftCurrTime, DWORD dwSeconds)
{
    FILETIME ftCurrTime;
    ULARGE_INTEGER uliTime;

    HRESULT hr = S_OK;
    TCHAR szTempFilePath[MAX_PATH+1];
    HANDLE hFile = INVALID_HANDLE_VALUE;
#define TEMP_FILE_LEN (15)

    memset(pftCurrTime, 0, sizeof(ULARGE_INTEGER));

    DWORD dwLen = MAX_PATH;
    hr = GetPendingDeletePath( NULL, ASM_CACHE_DOWNLOAD, szTempFilePath, &dwLen);
    if (FAILED(hr)) {
        goto exit;
    }

    dwLen = MAX_PATH - dwLen;

    dwLen = TEMP_FILE_LEN;
    if((dwLen + lstrlenW(szTempFilePath) + 1)>= MAX_PATH)
    {
        hr = E_FAIL;
        goto exit;
    }

    GetRandomFileName(szTempFilePath, dwLen);

    hFile = CreateFile(szTempFilePath, GENERIC_WRITE, 0 /* no sharing */,
                     NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if(!GetFileTime(hFile, &ftCurrTime, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

exit:

    if(FAILED(hr))
    {
        GetSystemTimeAsFileTime(&ftCurrTime);
        hr = S_OK;
    }

    memcpy( &uliTime, &ftCurrTime, sizeof(ULARGE_INTEGER));

    uliTime.QuadPart -= dwSeconds * 10000000;  // 1 second = 10 ** 7 units in SystemTime.
    memcpy(pftCurrTime, &uliTime, sizeof(ULARGE_INTEGER));

    if(hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        DeleteFile(szTempFilePath);
    }

    return hr;
}

EnumFileStore(DWORD dwFlags, DWORD *pdwSizeOfCacheInKB, List<CScavengerNode *> **ppNodeList )
{
    HRESULT         hr = NOERROR;
    CEnumCache*     pEnumR = NULL;
    CTransCache*    pTCQry = NULL;
    CTransCache*    pTCOut= NULL;
    DWORD           dwLen = 0;
    DWORD           dwTotalKBSize = 0;
    DWORD           dwAsmSize=0;
    List<CScavengerNode *>   *pNodeList=NEW(List<CScavengerNode *>);
    CScavengerNode  *pNode;

    ASSERT(ppNodeList);

    *ppNodeList = NULL;

    hr = CTransCache::Create(&pTCQry, dwFlags);
    if( hr != S_OK )
        goto exit;

    pEnumR = NEW(CEnumCache(TRUE, NULL));
    if(!pEnumR)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pEnumR->Init(pTCQry, 0);
    if (FAILED(hr))
       goto exit;

    while( NOERROR == hr )
    {
        // create temp object
        hr = CTransCache::Create(&pTCOut, dwFlags);

        if( hr != S_OK)
            break;

        hr = pEnumR->GetNextRecord(pTCOut);

        if( S_OK == hr )
        {
            pNode = NEW(CScavengerNode);
            if(!pNode)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            hr = GetAssemblyKBSize(pTCOut->_pInfo->pwzPath, &dwAsmSize, 
                        &(pNode->_ftLastAccess), &(pNode->_ftCreation));
            dwTotalKBSize += dwAsmSize;
            // build ascending order list.
            pNode->_dwAsmSize = dwAsmSize;
            pNode->_pwzManifestPath = pTCOut->_pInfo->pwzPath;
            pTCOut->_pInfo->pwzPath = NULL;
            pNodeList->AddSorted(pNode, CScavengerNode::Compare);
            // cleanup
            SAFERELEASE(pTCOut);
        } // nextRecord

    } // while

    if(pdwSizeOfCacheInKB)
        *pdwSizeOfCacheInKB = dwTotalKBSize;

    *ppNodeList = pNodeList;

exit:

    if(!(*ppNodeList))
    {
        SAFEDELETE(pNodeList); // this should call RemoveAll();
    }

    SAFEDELETE(pEnumR);
    SAFERELEASE(pTCOut);
    SAFERELEASE(pTCQry);

    return hr;
}

HRESULT ScavengeDownloadCache()
{
    HRESULT hr = S_OK;
    DWORD dwCacheSizeInKB=0;
    DWORD dwFreedInKB=0;
    List<CScavengerNode *>   *pNodeList=NULL;
    LISTNODE    pAsmList=NULL;
    int iAsmCount=0,i=0;
    CScavengerNode  *pTargetAsm;
    DWORD dwScavengeTo = 0;
    DWORD dwCurrentUsage = 0;
    CMutex  cCacheMutex(g_hCacheMutex);

    hr = CleanupTempDir(ASM_CACHE_DOWNLOAD, NULL);

    hr = EnumFileStore( TRANSPORT_CACHE_SIMPLENAME_IDX, &dwCacheSizeInKB,  &pNodeList);

    if(FAILED(hr = cCacheMutex.Lock()))
        goto exit;

    if(FAILED(hr = SetDownLoadUsage(FALSE, dwCacheSizeInKB)))
        goto exit;

    if(FAILED(hr = cCacheMutex.Unlock()))
    {
        goto exit;
    }

    pAsmList  = pNodeList->GetHeadPosition();
    iAsmCount = pNodeList->GetCount();

    if(!(dwScavengeTo = GetDownloadTarget()))
        goto exit;

    for(i=0; i<iAsmCount; i++)
    {
        if(FAILED(hr = GetDownloadUsage(&dwCurrentUsage)))
            goto exit;

        if(dwCurrentUsage <= dwScavengeTo)
            break;

        pTargetAsm = pNodeList->GetNext(pAsmList); // Element from list;

        if(FAILED(hr = cCacheMutex.Lock()))
            goto exit;

        hr = CScavenger::DeleteAssembly(ASM_CACHE_DOWNLOAD, NULL, pTargetAsm->_pwzManifestPath, FALSE);


        if(SUCCEEDED(hr))
        {
            dwFreedInKB += pTargetAsm->_dwAsmSize;
            SetDownLoadUsage(TRUE, - (int)pTargetAsm->_dwAsmSize);
        }

        if(FAILED(hr = cCacheMutex.Unlock()))
        {
            goto exit;
        }

    }

exit:
    // destroy list.
    if(pNodeList)
    {
        pAsmList  = pNodeList->GetHeadPosition();
        iAsmCount = pNodeList->GetCount();

        for(i=0; i<iAsmCount; i++)
        {
            pTargetAsm = pNodeList->GetNext(pAsmList); // Element from list;
            SAFEDELETE(pTargetAsm);
        }
        pNodeList->RemoveAll();
        SAFEDELETE(pNodeList); // this should call RemoveAll
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\transprt.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "transprt.h"
#include "util.h"
#include "cache.h"
#include "scavenger.h"
#include "cacheutils.h"
#include "enum.h"

#define HIGH_WORD_MASK 0xffff0000
#define LOW_WORD_MASK 0x0000ffff


HRESULT VerifySignatureHelper(CTransCache *pTC, DWORD dwVerifyFlags);

// global crit-sec for init dbs (reuse, defined at dllmain.cpp)
extern CRITICAL_SECTION g_csInitClb;


typedef HRESULT (__stdcall *PFSHFUSIONINITIALIZE) (LPWSTR, DWORD);

#define SHFUSIONFILENAME L"shfusion.dll"
#define SHFUSIONPATH     L"\\assembly\\shfusion.dll"
#define SHDESKTOPINIPATH L"\\desktop.ini"
#define SHFUSIONENTRY    "Initialize"

// BUGBUG: Should move these to a shfusion header file
// Flags for the shfusion.dll init routine
typedef enum 
{
    SH_INIT_FOR_GLOBAL, 
    SH_INIT_FOR_USER 
} SH_INIT_FLAGS;



// ---------------------------------------------------------------------------
// CTransCache  ctor
// ---------------------------------------------------------------------------
CTransCache::CTransCache(DWORD dwCacheId, CCache *pCache)
{
    LPWSTR                pwzCachePath = NULL;
    
    _cRef        = 1;
    _hr = S_OK;
    _dwSig = 'SNRT';
    _dwTableID = dwCacheId;
    _pCache = NULL;
    _pInfo = NULL;
    pwzCachePath = (pCache == NULL) ? NULL : (LPWSTR)pCache->GetCustomPath();
    
    // _hr set by base constructor; should be S_OK.
    if (FAILED(_hr))
        goto exit;

    _hr = InitShFusion( dwCacheId, pwzCachePath);
    if (FAILED(_hr)){
        goto exit;
    }

    // Allocate new TRANSCACHEINFO.
    // Zero out all fields.
    _pInfo = NEW(TRANSCACHEINFO);
    if (!_pInfo)
    {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }
    memset(_pInfo, 0, sizeof(TRANSCACHEINFO));

    if(SUCCEEDED(_hr) && pCache)
    {
        _pCache = pCache;
        pCache->AddRef();
    }

exit:

    return;
}

// ---------------------------------------------------------------------------
// CTransCache  dtor
//---------------------------------------------------------------------------
CTransCache::~CTransCache()
{
    if (_pInfo)
        CleanInfo(_pInfo);
    SAFEDELETE(_pInfo);

    SAFERELEASE(_pCache);

}

LONG CTransCache::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

LONG CTransCache::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

LPWSTR CTransCache::GetCustomPath()
{
    return (_pCache == NULL) ? NULL : (LPWSTR)_pCache->GetCustomPath();
}

DWORD CTransCache::GetCacheType()
{
    DWORD dwCacheType = (DWORD)-1;

    switch(_dwTableID)
    {
    case TRANSPORT_CACHE_SIMPLENAME_IDX:
        dwCacheType = ASM_CACHE_DOWNLOAD;
        break;

    case TRANSPORT_CACHE_ZAP_IDX:
        dwCacheType = ASM_CACHE_ZAP;
        break;

    case TRANSPORT_CACHE_GLOBAL_IDX:
        dwCacheType = ASM_CACHE_GAC;
        break;

    default :
        // ASSERT
        ASSERT(0);
        break;
    };

    return dwCacheType;
}

DWORD CTransCache::GetCacheIndex(DWORD dwCacheType)
{
    DWORD dwCacheIndex = -1;

    switch(dwCacheType)
    {
    case ASM_CACHE_DOWNLOAD: 
        dwCacheIndex = TRANSPORT_CACHE_SIMPLENAME_IDX;
        break;

    case ASM_CACHE_ZAP: 
        dwCacheIndex = TRANSPORT_CACHE_ZAP_IDX;
        break;

    case ASM_CACHE_GAC: 
        dwCacheIndex = TRANSPORT_CACHE_GLOBAL_IDX;
        break;

    default :
        // ASSERT
        break;
    };

    return dwCacheIndex;
}

// ---------------------------------------------------------------------------
// CTransCache::GetVersion
//---------------------------------------------------------------------------
ULONGLONG CTransCache::GetVersion()
{
    ULONGLONG ullVer = 0;
    ullVer = (((ULONGLONG) ((TRANSCACHEINFO*) _pInfo)->dwVerHigh) << sizeof(DWORD) * 8);
    ullVer |= (ULONGLONG)  ((TRANSCACHEINFO*) _pInfo)->dwVerLow;
    return ullVer;
}

// ---------------------------------------------------------------------------
// CTransCache::Create
//---------------------------------------------------------------------------
HRESULT CTransCache::Create(CTransCache **ppTransCache, DWORD dwCacheId)
{
    return CTransCache::Create(ppTransCache, dwCacheId, NULL);
}

// ---------------------------------------------------------------------------
// CTransCache::Create
//---------------------------------------------------------------------------
HRESULT CTransCache::Create(CTransCache **ppTransCache, DWORD dwCacheId, CCache *pCache)
{
    HRESULT hr=S_OK;
    CTransCache *pTransCache = NULL;

    pTransCache = NEW(CTransCache(dwCacheId, pCache));
    if (!pTransCache)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    hr = pTransCache->_hr;
    if (SUCCEEDED(hr))
    {
        *ppTransCache = pTransCache;
    }
    else
    {
        delete pTransCache;
        pTransCache = NULL;
    }

exit:

    return hr;
}

// ---------------------------------------------------------------------------
// CTransCache::Retrieve
//---------------------------------------------------------------------------
HRESULT CTransCache::Retrieve()
{
    return RetrieveFromFileStore(this);    
}


// ---------------------------------------------------------------------------
// CTransCache::Retrieve(CTransCache **, DWORD)
//---------------------------------------------------------------------------
HRESULT CTransCache::Retrieve(CTransCache **ppTransCache, DWORD dwCmpMask)
{
    HRESULT       hr;
    DWORD        dwQueryMask = 0;
    CTransCache  *pTC = NULL, *pTCMax = NULL;
    CEnumCache   enumR(FALSE, NULL);
    LPWSTR       pszName=((TRANSCACHEINFO*)_pInfo)->pwzName;
    
    // Map name mask to cache mask
    dwQueryMask = MapNameMaskToCacheMask(dwCmpMask);

    // Create an enumerator based on this entry.
    if (FAILED(hr = enumR.Init(this,  dwQueryMask)))
    {
        goto exit;
    }
    
    // Enum over cache.
    while(hr == S_OK)
    {
        // Create a transcache entry for output.
        if (FAILED(hr = Create(&pTC, _dwTableID, _pCache)))
            goto exit;

        // Enumerate next entry.
        hr = enumR.GetNextRecord(pTC);
                
        // If the version is greater, 
        // save off max.
        if (hr == S_OK && pTC->GetVersion() >= GetVersion())
        {
            SAFERELEASE(pTCMax);
            pTCMax = pTC;
        }
        else
        {
            // Otherwise, release allocated transcache.
            SAFERELEASE(pTC)
        }
    }

exit:
    if (SUCCEEDED(hr))
    {
        if (pTCMax)
        {
            *ppTransCache = pTCMax;
            hr = DB_S_FOUND;
        }
        else
        {
            hr = DB_S_NOTFOUND;
        }
    }
    return hr;
}


// ---------------------------------------------------------------------------
// CTransCache::CloneInfo
// Returns shallow copy of info pointer.
//---------------------------------------------------------------------------
TRANSCACHEINFO* CTransCache::CloneInfo()
{
    TRANSCACHEINFO *pClone = NULL;

    if (!_pInfo)
    {
        ASSERT(FALSE);
        goto exit;
    }
    
    pClone = NEW(TRANSCACHEINFO);
    if(!pClone)
        goto exit;
    memcpy(pClone, _pInfo, sizeof(TRANSCACHEINFO));

exit:
    return pClone;
}

// ---------------------------------------------------------------------------
// CTransCache::CleanInfo
// Deallocates TRANSCACHEINFO struct members.
//---------------------------------------------------------------------------
VOID CTransCache::CleanInfo(TRANSCACHEINFO *pInfoBase, BOOL fFree)
{
    TRANSCACHEINFO *pInfo = (TRANSCACHEINFO*) pInfoBase;
          
    if (fFree)
    {
        // Delete member ptrs.
        SAFEDELETEARRAY(pInfo->pwzName);
        SAFEDELETEARRAY(pInfo->blobPKT.pBlobData);
        SAFEDELETEARRAY(pInfo->blobCustom.pBlobData);
        SAFEDELETEARRAY(pInfo->blobSignature.pBlobData);
        SAFEDELETEARRAY(pInfo->blobMVID.pBlobData);
        SAFEDELETEARRAY(pInfo->pwzCodebaseURL);
        SAFEDELETEARRAY(pInfo->pwzPath);
        SAFEDELETEARRAY(pInfo->blobPK.pBlobData);
        SAFEDELETEARRAY(pInfo->blobOSInfo.pBlobData);
        SAFEDELETEARRAY(pInfo->blobCPUID.pBlobData);
        SAFEDELETEARRAY(pInfo->pwzCulture);
    }
    
    // Zero out entire struct.
    memset(pInfo, 0, sizeof(TRANSCACHEINFO));
}


// ---------------------------------------------------------------------------
// CTransCache::IsMatch
//---------------------------------------------------------------------------
BOOL CTransCache::IsMatch(CTransCache *pRec, DWORD dwCmpMaskIn, LPDWORD pdwCmpMaskOut)
{
    BOOL fRet = TRUE;
    DWORD dwCount = 0;
    DWORD dwVerifyFlags;
    TRANSCACHEINFO*    pSource = NULL;
    TRANSCACHEINFO*    pTarget = NULL;


    dwVerifyFlags = SN_INFLAG_USER_ACCESS;
    
    // invalid params
    if( !pRec || !pRec->_pInfo || !pdwCmpMaskOut )
    {
        fRet = FALSE;
        goto exit;
    }

    if(!dwCmpMaskIn) // match all
        goto exit;

    // BUGBUG: verify the object type 

    // compare source(this object) with target(incoming object) 
    pSource = (TRANSCACHEINFO*)_pInfo;
    pTarget = (TRANSCACHEINFO*)(pRec->_pInfo);

    if((TRANSPORT_CACHE_GLOBAL_IDX == _dwTableID) || (TRANSPORT_CACHE_ZAP_IDX == _dwTableID))
    {
        // Name
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_NAME)
        {
            if(pSource->pwzName && pTarget->pwzName
                && FusionCompareString(pSource->pwzName, pTarget->pwzName))
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_NAME;
        }

        // Culture
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_CULTURE)
        {
            if(pSource->pwzCulture && pTarget->pwzCulture
                && FusionCompareStringI(pSource->pwzCulture, pTarget->pwzCulture))
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_CULTURE;
        }        

        // PublicKeyToken
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_PUBLIC_KEY_TOKEN)
        {
            // Check if ptrs are different.
            if ((DWORD_PTR)(pSource->blobPKT.pBlobData) ^
                (DWORD_PTR)(pTarget->blobPKT.pBlobData))
            {
                // ptrs are different
                if (!((DWORD_PTR)pSource->blobPKT.pBlobData &&
                    (DWORD_PTR)pTarget->blobPKT.pBlobData) || // only one is NULL
                    ((pSource->blobPKT.cbSize != pTarget->blobPKT.cbSize) ||
                        (memcmp(pSource->blobPKT.pBlobData,
                            pTarget->blobPKT.pBlobData,
                            pSource->blobPKT.cbSize)))) // must both be non-NULL
                {
                    fRet = FALSE;
                    goto exit;
                }
                *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_PUBLIC_KEY_TOKEN;
            }            
        }

        // Custom
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_CUSTOM)
        {
            // Check if ptrs are different.
            if ((DWORD_PTR)(pSource->blobCustom.pBlobData) ^ 
                (DWORD_PTR)(pTarget->blobCustom.pBlobData))
            {
                // ptrs are different
                if (!((DWORD_PTR)pSource->blobCustom.pBlobData && 
                    (DWORD_PTR)pTarget->blobCustom.pBlobData) || // only one is NULL
                    ((pSource->blobCustom.cbSize != pTarget->blobCustom.cbSize) ||
                        (memcmp(pSource->blobCustom.pBlobData, 
                            pTarget->blobCustom.pBlobData, 
                            pSource->blobCustom.cbSize)))) // must both be non-NULL
                {
                    fRet = FALSE;
                    goto exit;
                }
                *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_CUSTOM;
            }            
        }

        // Major Version
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_MAJOR_VERSION)
        {
            if((pSource->dwVerHigh & HIGH_WORD_MASK) != (pTarget->dwVerHigh & HIGH_WORD_MASK)) 
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_MAJOR_VERSION;
        }            

        // Minor Version
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_MINOR_VERSION)
        {
            if((pSource->dwVerHigh & LOW_WORD_MASK) != (pTarget->dwVerHigh & LOW_WORD_MASK)) 
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_MINOR_VERSION;
        }            

        // Build number.
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_BUILD_NUMBER)
        {
            if((pSource->dwVerLow & HIGH_WORD_MASK) != (pTarget->dwVerLow & HIGH_WORD_MASK))
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_BUILD_NUMBER;
        }            

        // Revision number.
        if (dwCmpMaskIn & TCF_STRONG_PARTIAL_REVISION_NUMBER)
        {
            if((pSource->dwVerLow & LOW_WORD_MASK) != (pTarget->dwVerLow & LOW_WORD_MASK))
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_STRONG_PARTIAL_REVISION_NUMBER;
        }            

        // Last check - if delay-signed and user mode,
        if (pRec->_pInfo->dwType & ASM_DELAY_SIGNED 
            && ((TRANSCACHEINFO*)pRec->_pInfo)->pwzPath)
        {
            if(FAILED(VerifySignatureHelper((CTransCache*)pRec, dwVerifyFlags)))
            {
                fRet = FALSE;
                goto exit;
            }
        }
    }     
    else
    if(TRANSPORT_CACHE_SIMPLENAME_IDX == _dwTableID ) 
    {
        if (dwCmpMaskIn & TCF_SIMPLE_PARTIAL_CODEBASE_URL)
        {
            // column 1    
            if( FusionCompareStringI(pSource->pwzCodebaseURL, pTarget->pwzCodebaseURL) )
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_SIMPLE_PARTIAL_CODEBASE_URL;
        }            

        if (dwCmpMaskIn & TCF_SIMPLE_PARTIAL_CODEBASE_LAST_MODIFIED)
        {
            if(memcmp(&(pSource->ftLastModified), &(pTarget->ftLastModified), 
                  sizeof(FILETIME)))
            {
                fRet = FALSE;
                goto exit;
            }
            *pdwCmpMaskOut |= TCF_SIMPLE_PARTIAL_CODEBASE_LAST_MODIFIED;
        }
    }
    else
    {
        // invalid index
        goto exit;
    }


exit:
    return fRet;
}

// ---------------------------------------------------------------------------
// CTransCache::MapNameMaskToCacheMask
//---------------------------------------------------------------------------
DWORD CTransCache::MapNameMaskToCacheMask(DWORD dwNameMask)
{
    DWORD dwCacheMask = 0;
    if((TRANSPORT_CACHE_ZAP_IDX == _dwTableID)
            || (TRANSPORT_CACHE_GLOBAL_IDX == _dwTableID))
    {
        if (dwNameMask & ASM_CMPF_NAME)
            dwCacheMask |= TCF_STRONG_PARTIAL_NAME;
        if (dwNameMask & ASM_CMPF_CULTURE)
            dwCacheMask |= TCF_STRONG_PARTIAL_CULTURE;
        if (dwNameMask & ASM_CMPF_PUBLIC_KEY_TOKEN)
            dwCacheMask |= TCF_STRONG_PARTIAL_PUBLIC_KEY_TOKEN;
        if (dwNameMask & ASM_CMPF_MAJOR_VERSION)
            dwCacheMask |= TCF_STRONG_PARTIAL_MAJOR_VERSION;
        if (dwNameMask & ASM_CMPF_MINOR_VERSION)
            dwCacheMask |= TCF_STRONG_PARTIAL_MINOR_VERSION;
        if (dwNameMask & ASM_CMPF_REVISION_NUMBER)
            dwCacheMask |= TCF_STRONG_PARTIAL_REVISION_NUMBER;
        if (dwNameMask & ASM_CMPF_BUILD_NUMBER)
            dwCacheMask |= TCF_STRONG_PARTIAL_BUILD_NUMBER;
        if (dwNameMask & ASM_CMPF_CUSTOM)
            dwCacheMask |= TCF_STRONG_PARTIAL_CUSTOM;
    }
    else
    {
        // ASSERT(FALSE);
    }

    return dwCacheMask;
}
// ---------------------------------------------------------------------------
// CTransCache::MapCacheMaskToQueryCols
//---------------------------------------------------------------------------
DWORD CTransCache::MapCacheMaskToQueryCols(DWORD dwMask)
{
    DWORD rFlags[7] = {TCF_STRONG_PARTIAL_NAME, TCF_STRONG_PARTIAL_CULTURE,
        TCF_STRONG_PARTIAL_PUBLIC_KEY_TOKEN, TCF_STRONG_PARTIAL_MAJOR_VERSION,
        TCF_STRONG_PARTIAL_MINOR_VERSION, TCF_STRONG_PARTIAL_BUILD_NUMBER,
        TCF_STRONG_PARTIAL_REVISION_NUMBER};

    DWORD nCols = 0;

    if((TRANSPORT_CACHE_ZAP_IDX == _dwTableID)
            || (TRANSPORT_CACHE_GLOBAL_IDX == _dwTableID))
    {
        for (DWORD i = 0; i < sizeof(rFlags) / sizeof(rFlags[0]); i++)
        {
            if (dwMask & rFlags[i])
            {
                // Name, Loc, PKT
                if (i < 3)
                    nCols++;
                // VerMaj AND VerMin
                else if ((i == 3) && (dwMask & rFlags[4]))
                    nCols++;
                // RevNo AND BuildNo
                else if ((i == 5) && (dwMask & rFlags[6]))
                    nCols++;
            }
            else
                break;
        }
    }
    else if (TRANSPORT_CACHE_SIMPLENAME_IDX == _dwTableID)
    {
        if (dwMask & TCF_SIMPLE_PARTIAL_CODEBASE_URL)
        {
            nCols++;
            if (dwMask & TCF_SIMPLE_PARTIAL_CODEBASE_LAST_MODIFIED)
                nCols++;
        }
    }

    return nCols;
}

// ---------------------------------------------------------------------------
// CTransCache::InitShFusion
//---------------------------------------------------------------------------
HRESULT CTransCache::InitShFusion(DWORD dwCacheId, LPWSTR pwzCachePath)
{
    static BOOL     fInitAlreadyCalled = FALSE;
    HRESULT         hr = S_OK;

    CheckAccessPermissions();

    // Make sure we only initialize 1 time.
    if(fInitAlreadyCalled) {
        return S_OK;
    }

    fInitAlreadyCalled = TRUE;

    // BUGBUG: ignore, for now, user cache directories
    // BUGBUG: ignore per app asm cache directories?
    if (g_CurrUserPermissions != READ_ONLY && pwzCachePath == NULL)
    {
        WCHAR       wzPath[MAX_PATH+1];
        WCHAR       wzInUseCachePath[_MAX_PATH];
        DWORD       dwIniFileGFA;
        DWORD       dwAsmPathGFA;

        // Build up the right root path pointing to the cache
        if(g_CurrUserPermissions == READ_ONLY) {
            StrCpyNW(wzInUseCachePath, g_UserFusionCacheDir, lstrlenW(g_UserFusionCacheDir) + 1);
        }
        else {
            if (lstrlenW(g_szWindowsDir) + lstrlenW(FUSION_CACHE_DIR_ROOT_SZ) + 1 >= MAX_PATH) {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto Exit;
            }

            StrCpyNW(wzInUseCachePath, g_szWindowsDir, lstrlenW(g_szWindowsDir) + 1);
            PathRemoveBackslash(wzInUseCachePath);
            StrNCatW(wzInUseCachePath, FUSION_CACHE_DIR_ROOT_SZ, lstrlenW(FUSION_CACHE_DIR_ROOT_SZ) + 1);
        }

        // Check
        //  1. The assembly folder exists and has the system attribute set.
        //  2. The desktop.ini exists in the assembly folder.
        //
        //  Both of these conditions indicate that shfusion is hopefully initialized
        //  properly. This doesn't take into account possible hacking on the registry.

        // Check for "assembly" folder and get attributes
        StrCpyNW(wzPath, wzInUseCachePath, lstrlenW(wzInUseCachePath) + 1);
        dwAsmPathGFA = GetFileAttributes(wzPath);

        if (lstrlenW(wzInUseCachePath) + lstrlenW(SHDESKTOPINIPATH) + 1 > MAX_PATH) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }

        // Append from path above "desktop.ini" and check to see if its present,
        // this could also imply shfusion is installed properly
        StrNCatW(wzPath, SHDESKTOPINIPATH, lstrlenW(SHDESKTOPINIPATH) + 1);
        dwIniFileGFA = GetFileAttributes(wzPath);

        // Check folder attribute
        if(!(dwAsmPathGFA & FILE_ATTRIBUTE_SYSTEM)) {
            dwAsmPathGFA = -1;
        }

        if(dwAsmPathGFA == -1 || dwIniFileGFA == -1) {
            HMODULE     hmodShFusion = NULL;

            // Shfusion doesn't appear to be installed, Implement
            // tight binding to preserve versioning
            StrCpyNW(wzPath, g_FusionDllPath, lstrlenW(g_FusionDllPath) + 1);
            *(PathFindFileName(wzPath)) = L'\0';

            if (lstrlenW(SHFUSIONFILENAME) + lstrlenW(wzPath) + 1 >= MAX_PATH) {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto Exit;
            }
            
            StrNCatW(wzPath, SHFUSIONFILENAME, lstrlenW(SHFUSIONFILENAME) + 1);

            if( (hmodShFusion = LoadLibrary(wzPath)) != NULL) {

                PFSHFUSIONINITIALIZE  pfShFusionInitialize = 
                    (PFSHFUSIONINITIALIZE) ::GetProcAddress(hmodShFusion, SHFUSIONENTRY);

                if(pfShFusionInitialize) {
                    // Call shfusion for initialization assembly path and type flags
                    pfShFusionInitialize(wzInUseCachePath,
                        (g_CurrUserPermissions == READ_ONLY) ? SH_INIT_FOR_USER : SH_INIT_FOR_GLOBAL);
                }

#if 0
                // BUGBUG: Don't free shfusion, because it is statically
                // linked to comctl32. Loading/unloading comctl32 causes
                // resource leaks that eventually cause some winforms apps
                // to break (see ASURT 96262).

                FreeLibrary(hmodShFusion);
#endif
            }
        }
    }

    hr = S_OK;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\histnode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "histnode.h"
#include "util.h"

CHistoryInfoNode::CHistoryInfoNode()
{
    _dwSig = 'DONH';
    memset(&_bindHistoryInfo, 0, sizeof(_bindHistoryInfo));
}

CHistoryInfoNode::~CHistoryInfoNode()
{
}

HRESULT CHistoryInfoNode::Init(AsmBindHistoryInfo *pHistInfo)
{
    HRESULT                                      hr = S_OK;
    
    if (!pHistInfo) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    lstrcpyW(_bindHistoryInfo.wzAsmName, pHistInfo->wzAsmName);
    lstrcpyW(_bindHistoryInfo.wzPublicKeyToken, pHistInfo->wzPublicKeyToken);
    lstrcpyW(_bindHistoryInfo.wzCulture, pHistInfo->wzCulture);
    lstrcpyW(_bindHistoryInfo.wzVerReference, pHistInfo->wzVerReference);
    lstrcpyW(_bindHistoryInfo.wzVerAppCfg, pHistInfo->wzVerAppCfg);
    lstrcpyW(_bindHistoryInfo.wzVerPublisherCfg, pHistInfo->wzVerPublisherCfg);
    lstrcpyW(_bindHistoryInfo.wzVerAdminCfg, pHistInfo->wzVerAdminCfg);

Exit:
    return hr;
}

HRESULT CHistoryInfoNode::Create(AsmBindHistoryInfo *pHistInfo, CHistoryInfoNode **pphn)
{
    HRESULT                                     hr = S_OK;
    CHistoryInfoNode                               *pHList = NULL;
   
    if (!pHistInfo || !pphn) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pphn = NULL;

    pHList = NEW(CHistoryInfoNode);
    if (!pHList) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pHList->Init(pHistInfo);
    if (FAILED(hr)) {
        SAFEDELETE(pHList);
        goto Exit;
    }

    *pphn = pHList;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\history.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "history.h"
#include "iniwrite.h"
#include "iniread.h"
#include "dbglog.h"
#include "histnode.h"
#include "appctx.h"
#include "helpers.h"
#include "util.h"
#include "shlobj.h"
#include "lock.h"

extern WCHAR g_wzEXEPath[MAX_PATH+1];

CBindHistory::CBindHistory()
: _bFoundDifferent(FALSE)
, _pdbglog(NULL)
, _wzApplicationName(NULL)
, _bPolicyUnchanged(FALSE)
, _bInitCS(FALSE)
{
    _dwSig = 'TSIH';
    _wzFilePath[0] = L'\0';
    _wzActivationDateMRU[0] = L'\0';
    _wzActivationDateCurrent[0] = L'\0';
    _wzURTVersion[0] = L'\0';
    _wzInUseFile[0] = L'\0';
    _hFile = INVALID_HANDLE_VALUE;
}

CBindHistory::~CBindHistory()
{
    HRESULT                              hr;
    DWORD                                dwNumNodes;

    if (_hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(_hFile);
        DeleteFile(_wzInUseFile);
    }

    dwNumNodes = _listPendingHistory.GetCount();
    if ((GetFileAttributes(_wzFilePath) == -1) && dwNumNodes) {
        // File doesn't exist. Must add the header data first.

        _iniWriter.InsertHeaderData(g_wzEXEPath, _wzApplicationName);

        // Add the new snapshot

        _iniWriter.AddSnapShot(_wzActivationDateMRU, _wzURTVersion);

        FlushPendingHistory(_wzActivationDateMRU);
    }
    else if (_bPolicyUnchanged && dwNumNodes) {
        LISTNODE                              pos;
        POLICY_STATUS                         pstatus;
        BOOL                                  bDifferent;
        CHistoryInfoNode                     *pInfo;

        // If _bPolicyUnchanged is set, we detected that the INI file had
        // a later last modified time than any of app/pub/machine config
        // files, so we queued up all assembly binds. In some cases, old
        // config files may have been copied over (indicating new policy, but
        // the last mod time is older than the INI file time). Thus, in
        // this case, we need to double-check we made the right assumption
        // by checking each queued bind up against what MRU activation date.

        _bPolicyUnchanged = FALSE;
        bDifferent = FALSE;

        pos = _listPendingHistory.GetHeadPosition();
        while (pos) {
            pInfo = _listPendingHistory.GetNext(pos);
            ASSERT(pInfo);

            pstatus = GetAssemblyStatus(_wzActivationDateMRU, &(pInfo->_bindHistoryInfo));
            if (pstatus == POLICY_STATUS_DIFFERENT) {
                bDifferent = TRUE;
                break;
            }
        }

        if (bDifferent) {
            // Policy was different after all. Record a new snapshot and
            // flush the assemblies.

            hr = FlushPendingHistory(_wzActivationDateCurrent);
            if (SUCCEEDED(hr)) {
                // Persist information about new snapshot
                hr = _iniWriter.AddSnapShot(_wzActivationDateCurrent, _wzURTVersion);
            }
        }
        else {
            // Just flush the history to the MRU date
            FlushPendingHistory(_wzActivationDateMRU);
        }
    }
    else if (dwNumNodes) {
        // Just flush the pending nodes to the MRU date

        FlushPendingHistory(_wzActivationDateMRU);
    }

    if (_bInitCS) {
        DeleteCriticalSection(&_csHistory);
    }

    SAFEDELETEARRAY(_wzApplicationName);
    SAFERELEASE(_pdbglog);
}

HRESULT CBindHistory::Init(LPCWSTR wzApplicationName, LPCWSTR wzModulePath,
                           FILETIME *pftLastModConfig)
{
    HRESULT                                     hr = S_OK;
    WCHAR                                       wzHistPath[MAX_PATH + 1];
    DWORD                                       dwSize;
    FILETIME                                    ftLastMod;

    ASSERT(wzApplicationName && wzModulePath && pftLastModConfig);

    if (IsHosted()) {
        hr = E_FAIL;
        goto Exit;
    }

    __try {
        InitializeCriticalSection(&_csHistory);
        _bInitCS = TRUE;
    }
    __except ((GetExceptionCode() == STATUS_NO_MEMORY) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = sizeof(_wzURTVersion);
    hr = GetCORVersion(_wzURTVersion, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    _wzApplicationName = WSTRDupDynamic(wzApplicationName);
    if (!_wzApplicationName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_PATH;
    hr = GetHistoryFileDirectory(wzHistPath, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (GetFileAttributes(wzHistPath) == -1) {
        // Create directory

        if (!CreateDirectory(wzHistPath, NULL)) {
            hr = FusionpHresultFromLastError();
            goto Exit;
        }
    }

    dwSize = MAX_PATH;
    hr = GetHistoryFilePath(_wzApplicationName, wzModulePath, _wzFilePath, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = CreateInUseFile(_wzFilePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = _iniWriter.Init(_wzFilePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = InitActivationDates();
    if (FAILED(hr)) {
        goto Exit;
    }

    // Compare file time of INI file with file time of the configuration
    // files. If INI file is newer than last modification of a configuration
    // file, we do not need to aggressively read from the INI file
    // (GetAssemblyStatus), since policy should not have ever changed.

    if (FAILED(GetFileLastModified(_wzFilePath, &ftLastMod))) {
        _bPolicyUnchanged = TRUE;
        goto Exit;
    }

    if ((ftLastMod.dwHighDateTime > pftLastModConfig->dwHighDateTime) ||
        ((ftLastMod.dwHighDateTime == pftLastModConfig->dwHighDateTime) &&
         (ftLastMod.dwLowDateTime >= pftLastModConfig->dwLowDateTime))) {

        // Last modified time of the history file is more recent than the
        // last modified time of the configuration files. This means
        // policy should not have changed, and you should only get new
        // assembly binds (not different ones).

        _bPolicyUnchanged = TRUE;
    }

Exit:
    return hr;
}

HRESULT CBindHistory::CreateInUseFile(LPCWSTR pwzHistoryFile)
{
    HRESULT                                        hr = S_OK;

    ASSERT(pwzHistoryFile);

    wnsprintfW(_wzInUseFile, MAX_PATH, L"%ws.inuse", pwzHistoryFile);

    // If we can delete the existing file, it was leaked because of
    // previous unclean shutdown.
    
    _hFile = CreateFile(_wzInUseFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL);
    if (_hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CBindHistory::InitActivationDates()
{
    HRESULT                                     hr = S_OK;
    SYSTEMTIME                                  sysTime;
    FILETIME                                    ftMRU;
    FILETIME                                    ftTime;
    FILETIME                                    ftTimeLocal;
    BOOL                                        bRet;
    IHistoryReader                             *pReader = NULL;

    // Setup current activation time

    GetSystemTime(&sysTime);

    bRet = SystemTimeToFileTime(&sysTime, &ftTime);
    if (!bRet) {
        hr = FusionpHresultFromLastError();
        goto Exit;
    }

    bRet = FileTimeToLocalFileTime(&ftTime, &ftTimeLocal);
    if (!bRet) {
        hr = FusionpHresultFromLastError();
        goto Exit;
    }

    wnsprintfW(_wzActivationDateCurrent, MAX_ACTIVATION_DATE_LEN, L"%u.%u",
               ftTimeLocal.dwHighDateTime, ftTimeLocal.dwLowDateTime);

    // Setup MRU activation time

    hr = CreateHistoryReader(_wzFilePath, &pReader);
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
        // Activation date not specified (new history file).
        // MRU Activation date == Current activation date.

        lstrcpyW(_wzActivationDateMRU, _wzActivationDateCurrent);
        hr = S_OK;
        goto Exit;
    }
    else if (FAILED(hr)) {
        goto Exit;
    }
    
    // Get the MRU activation date
    hr = pReader->GetActivationDate(1, &ftMRU);
    if (FAILED(hr)) {
        goto Exit;
    }
    else if (hr == S_FALSE) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    wnsprintfW(_wzActivationDateMRU, MAX_ACTIVATION_DATE_LEN, L"%u.%u",
               ftMRU.dwHighDateTime, ftMRU.dwLowDateTime);

    
Exit:
    SAFERELEASE(pReader);

    return hr;
}               

HRESULT CBindHistory::Create(LPCWSTR wzApplicationName, LPCWSTR wzModulePath,
                             FILETIME *pftLastModConfig, CBindHistory **ppbh)
{
    HRESULT                                hr = S_OK;
    CBindHistory                          *pbh = NULL;
    
    if (!wzApplicationName || !pftLastModConfig || !wzModulePath || !ppbh) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppbh = NULL;

    pbh = NEW(CBindHistory);
    if (!pbh) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pbh->Init(wzApplicationName, wzModulePath, pftLastModConfig);
    if (FAILED(hr)) {
        SAFEDELETE(pbh);
        goto Exit;
    }

    *ppbh = pbh;

Exit:
    return hr;
}

POLICY_STATUS CBindHistory::GetAssemblyStatus(LPCWSTR wzActivationDate,
                                              AsmBindHistoryInfo *pHistInfo)
{
    HRESULT             hr = S_OK;
    POLICY_STATUS       pstatus = POLICY_STATUS_NEW;
    WCHAR               wzVerAdminCfg[MAX_VERSION_DISPLAY_SIZE + 1];
    IHistoryAssembly    *pHistoryAsm = NULL;
    BOOL                bIsDifferent;
    DWORD               dwSize;

    ASSERT(pHistInfo && pHistInfo->wzAsmName && pHistInfo->wzPublicKeyToken && pHistInfo->wzVerReference);

    if(_bPolicyUnchanged) {
        // It is either unchanged, or new. Just choose new to queue up the
        // binds, which gets flushed on shutdown.
        goto Exit;
    }

    hr = LookupHistoryAssemblyInternal(_wzFilePath, wzActivationDate,
                                       pHistInfo->wzAsmName, pHistInfo->wzPublicKeyToken,
                                       pHistInfo->wzCulture, pHistInfo->wzVerReference,
                                       &pHistoryAsm);

    if(hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        // Did not find previously recorded assembly info
        goto Exit;
    }
    else if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = MAX_VERSION_DISPLAY_SIZE;
    hr = pHistoryAsm->GetAdminCfgVersion(wzVerAdminCfg, &dwSize);
    if(FAILED(hr)) {
        goto Exit;
    }

    bIsDifferent = (FusionCompareString(wzVerAdminCfg, pHistInfo->wzVerAdminCfg) != 0);
    pstatus = (bIsDifferent) ? (POLICY_STATUS_DIFFERENT) : (POLICY_STATUS_UNCHANGED);

Exit:
    SAFERELEASE(pHistoryAsm);
    return pstatus;
}

HRESULT CBindHistory::PersistBindHistory(AsmBindHistoryInfo *pHistInfo)
{
    HRESULT                                      hr = S_OK;
    POLICY_STATUS                                pstatus = POLICY_STATUS_NEW;
    CHistoryInfoNode                            *pHistInfoNode;
    CCriticalSection                             cs(&_csHistory);


    if (!pHistInfo) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    if (_bFoundDifferent) {
        // We already know this is a new snapshot. Flush out the data.

        hr = _iniWriter.AddAssembly(_wzActivationDateCurrent, pHistInfo);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        // Haven't found anything different yet. 

        pstatus = GetAssemblyStatus(_wzActivationDateMRU, pHistInfo);

        switch (pstatus) {
            case POLICY_STATUS_UNCHANGED:

                // fall through and add to list...

            case POLICY_STATUS_NEW:
                hr = CHistoryInfoNode::Create(pHistInfo, &pHistInfoNode);
                if (FAILED(hr)) {
                    goto Exit;
                }

                hr = cs.Lock();
                if (FAILED(hr)) {
                    goto Exit;
                }
                
                _listPendingHistory.AddTail(pHistInfoNode);

                cs.Unlock();

                break;

            case POLICY_STATUS_DIFFERENT:
                _bFoundDifferent = TRUE;

                // Flush any pending histories
                
                hr = FlushPendingHistory(_wzActivationDateCurrent);
                if (FAILED(hr)) {
                    goto Exit;
                }

                // Persist information about new snapshot
                hr = _iniWriter.AddSnapShot(_wzActivationDateCurrent, _wzURTVersion);
                if (FAILED(hr)) {
                    goto Exit;
                }

                hr = _iniWriter.AddAssembly(_wzActivationDateCurrent, pHistInfo);
                if (FAILED(hr)) {
                    goto Exit;
                }

                break;
        }
    }

Exit:
    return hr;    
}

HRESULT CBindHistory::FlushPendingHistory(LPCWSTR wzActivationDate)
{
    HRESULT                               hr = S_OK;
    LISTNODE                              pos;
    CHistoryInfoNode                     *pHistInfoNode = NULL;
    CCriticalSection                      cs(&_csHistory);

    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }

    if (!wzActivationDate) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pos = _listPendingHistory.GetHeadPosition();

    while (pos) {
        pHistInfoNode = _listPendingHistory.GetNext(pos);
        ASSERT(pHistInfoNode);

        hr = _iniWriter.AddAssembly(wzActivationDate, &(pHistInfoNode->_bindHistoryInfo));
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // Now walk, and remove all entries from the list

    pos = _listPendingHistory.GetHeadPosition();

    while (pos) {
        pHistInfoNode = _listPendingHistory.GetNext(pos);
        SAFEDELETE(pHistInfoNode);
    }

    _listPendingHistory.RemoveAll();

Exit:
    cs.Unlock();
    
    return hr;
}

HRESULT PrepareBindHistory(IApplicationContext *pIAppCtx)
{
    HRESULT                                   hr = S_OK;
    WCHAR                                     wzAppName[MAX_PATH];
    LPWSTR                                    pwzFileName = NULL;
    DWORD                                     dwSize;
    FILETIME                                  ftLastModConfig;
    CBindHistory                             *pBindHistory = NULL;
    CApplicationContext                      *pAppCtx = dynamic_cast<CApplicationContext *>(pIAppCtx);

    wzAppName[0] = L'\0';

    ASSERT(pAppCtx);
    
    hr = pAppCtx->Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = 0;
    hr = pAppCtx->Get(ACTAG_APP_BIND_HISTORY, NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        hr = S_OK;
        pAppCtx->Unlock();
        goto Exit;
    }
    else if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        pAppCtx->Unlock();
        goto Exit;
    }

    dwSize = MAX_PATH;
    pAppCtx->Get(ACTAG_APP_NAME, wzAppName, &dwSize, 0);
    if (!lstrlenW(wzAppName)) {
        pwzFileName = PathFindFileName(g_wzEXEPath);
        lstrcpyW(wzAppName, pwzFileName);
    }

    hr = GetConfigLastModified(pAppCtx, &ftLastModConfig);
    if (FAILED(hr)) {
        pAppCtx->Unlock();
        goto Exit;
    }

    hr = CBindHistory::Create(wzAppName, g_wzEXEPath, &ftLastModConfig, &pBindHistory);
    if (FAILED(hr)) {
        pAppCtx->Unlock();
        goto Exit;
    }

    hr = pAppCtx->Set(ACTAG_APP_BIND_HISTORY, &pBindHistory, sizeof(pBindHistory), 0);
    if (FAILED(hr)) {
        delete pBindHistory;
        pAppCtx->Unlock();
        goto Exit;;
    }

    pAppCtx->Unlock();

Exit:
    return hr;
}
    
STDAPI GetHistoryFileDirectory(LPWSTR wzDir, DWORD *pdwSize)
{
    HRESULT                          hr = S_OK;
    WCHAR                            wzPath[MAX_PATH + 1];
    WCHAR                            wzUserDir[MAX_PATH + 1];
    DWORD                            dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    hr = FusionGetUserFolderPath(wzUserDir);
    if (FAILED(hr)) {
        goto Exit;
    }

    wnsprintfW(wzPath, MAX_PATH, L"%ws\\%ws", wzUserDir, FUSION_HISTORY_SUBDIR);

    dwLen = lstrlenW(wzPath) + 1;
    if (!wzDir || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzDir, wzPath);
    *pdwSize = dwLen;

Exit:
    return hr;
}        

HRESULT GetHistoryFilePath(LPCWSTR wzApplicationName, LPCWSTR wzModulePath,
                           LPWSTR wzFilePath, DWORD *pdwSize)
{
    HRESULT                              hr = S_OK;
    WCHAR                                wzHistoryDir[MAX_PATH + 1];
    WCHAR                                wzPath[MAX_PATH + 1];
    DWORD                                dwLen;
    DWORD                                dwHash;

    if (!wzApplicationName || !pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = MAX_PATH;
    hr = GetHistoryFileDirectory(wzHistoryDir, &dwLen);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwHash = HashString(wzModulePath, SIZE_MODULE_PATH_HASH, FALSE);

    // BUGBUG: Add a hash of the location to the filename, so you can
    // run different apps with the same name (and have different history files)

    wnsprintfW(wzPath, MAX_PATH, L"%ws\\%ws.%x.ini", wzHistoryDir, wzApplicationName, dwHash);

    dwLen = lstrlenW(wzPath) + 1;
    if (!wzFilePath || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzFilePath, wzPath);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT GetConfigLastModified(IApplicationContext *pAppCtx, FILETIME *pftLastModConfig)
{
    HRESULT                                  hr = S_OK;
    WCHAR                                    wzTimeStampFile[MAX_PATH];
    WCHAR                                    wzAppCfg[MAX_PATH];
    WCHAR                                    wzMachineCfg[MAX_PATH];
    FILETIME                                 ftLastModAppCfg;
    FILETIME                                 ftLastModMachineCfg;
    FILETIME                                 ftLastModPolicyCache;
    FILETIME                                 ftLastModLatest;
    DWORD                                    dwSize;

    ASSERT(pftLastModConfig && pAppCtx);

    memset(pftLastModConfig, 0, sizeof(FILETIME));
    memset(&ftLastModLatest, 0, sizeof(FILETIME));

    wzAppCfg[0] = L'\0';
    wzMachineCfg[0] = L'\0';
    wzTimeStampFile[0] = L'\0';

    // Get last modified of app.cfg

    dwSize = sizeof(wzAppCfg);
    if (FAILED(pAppCtx->Get(ACTAG_APP_CFG_LOCAL_FILEPATH, wzAppCfg, &dwSize, 0))) {
        memset(&ftLastModAppCfg, 0, sizeof(FILETIME));
    }
    else {
        if (FAILED(GetFileLastModified(wzAppCfg, &ftLastModAppCfg))) {
            memset(&ftLastModAppCfg, 0, sizeof(FILETIME));
        }
    }

    // Get last modified of machine.cfg

    dwSize = sizeof(wzMachineCfg);
    if (FAILED(pAppCtx->Get(ACTAG_MACHINE_CONFIG, wzMachineCfg, &dwSize, 0))) {
        memset(&ftLastModMachineCfg, 0, sizeof(FILETIME));
    }
    else {
        if (FAILED(GetFileLastModified(wzMachineCfg, &ftLastModMachineCfg))) {
            memset(&ftLastModMachineCfg, 0, sizeof(FILETIME));
        }
    }

    // Compare which is later

    if ((ftLastModAppCfg.dwHighDateTime > ftLastModMachineCfg.dwHighDateTime) ||
        ((ftLastModAppCfg.dwHighDateTime == ftLastModMachineCfg.dwHighDateTime) &&
         (ftLastModAppCfg.dwLowDateTime >= ftLastModMachineCfg.dwLowDateTime))) {

        memcpy(&ftLastModLatest, &ftLastModAppCfg, sizeof(FILETIME));
    }
    else {
        memcpy(&ftLastModLatest, &ftLastModMachineCfg, sizeof(FILETIME));
    }

    // Get last time publisher policy was installed

    dwSize = MAX_PATH;
    hr = GetCachePath(ASM_CACHE_GAC, wzTimeStampFile, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (lstrlenW(wzTimeStampFile) + lstrlen(FILENAME_PUBLISHER_PCY_TIMESTAMP) + 1 >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }

    PathRemoveBackslash(wzTimeStampFile);
    lstrcatW(wzTimeStampFile, FILENAME_PUBLISHER_PCY_TIMESTAMP);

    if (FAILED(GetFileLastModified(wzTimeStampFile, &ftLastModPolicyCache))) {
        memset(&ftLastModPolicyCache, 0, sizeof(FILETIME));
    }

    // Compare which is later

    if ((ftLastModPolicyCache.dwHighDateTime > ftLastModLatest.dwHighDateTime) ||
        ((ftLastModPolicyCache.dwHighDateTime == ftLastModLatest.dwHighDateTime) &&
         (ftLastModPolicyCache.dwLowDateTime > ftLastModLatest.dwLowDateTime))) {

        memcpy(&ftLastModLatest, &ftLastModPolicyCache, sizeof(FILETIME));
    }

    // Write back the result

    memcpy(pftLastModConfig, &ftLastModLatest, sizeof(FILETIME));

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\asm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <winerror.h>
#include <shlwapi.h>
#include "naming.h"
#include "debmacro.h"
#include "asmimprt.h"
#include "modimprt.h"
#include "asm.h"
#include "asmcache.h"
#include "dbglog.h"
#include "actasm.h"
#include "lock.h"
#include "scavenger.h"

extern CRITICAL_SECTION g_csInitClb;

// ---------------------------------------------------------------------------
// CreateAssemblyFromTransCacheEntry
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyFromTransCacheEntry(CTransCache *pTransCache, 
    IAssemblyManifestImport *pImport, LPASSEMBLY *ppAssembly)
{   
    HRESULT hr = S_OK;
    LPWSTR  szManifestFilePath=NULL, szCodebase;
    FILETIME *pftCodebase;
    CAssembly *pAsm                    = NULL;
    CAssemblyManifestImport *pCImport = NULL;
    BOOL fCreated = FALSE;
    TRANSCACHEINFO *pTCInfo = (TRANSCACHEINFO*) pTransCache->_pInfo;

    szManifestFilePath = pTransCache->_pInfo->pwzPath;

    szCodebase = pTCInfo->pwzCodebaseURL;
    pftCodebase = &(pTCInfo->ftLastModified);
    
    if (!szManifestFilePath || !ppAssembly) 
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (GetFileAttributes(szManifestFilePath) == -1) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    pAsm = NEW(CAssembly);
    if (!pAsm)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // If a manifest import interface is not provided,
    // create one from the file path.
    if (!pImport)
    {
        if (FAILED(hr = CreateAssemblyManifestImport((LPTSTR)szManifestFilePath,
                                                    &pImport))) {
            goto exit;
        }

        fCreated = TRUE;
    }
    // Otherwise if one is passed in, revise the manifest path
    // to match that held by the transcache entry.
    else
    {
        pCImport = dynamic_cast<CAssemblyManifestImport*>(pImport);
        ASSERT(pCImport);
        pCImport->SetManifestModulePath(szManifestFilePath);
    }
    
//     pTransCache->Lock();
    hr = pAsm->Init(pImport, pTransCache, szCodebase, pftCodebase);

    if (FAILED(hr)) 
    {        
        SAFERELEASE(pAsm);
//        pTransCache->Unlock();
        goto exit;
    }

    if (fCreated) {
        IAssemblyName *pNameDef = NULL;

        // Lock the file by retrieving the name def

        hr = pImport->GetAssemblyNameDef(&pNameDef);
        if (FAILED(hr)) {
            goto exit;
        }

        pNameDef->Release();
    }

    *ppAssembly = pAsm;
    (*ppAssembly)->AddRef();

exit:


    if (fCreated)
        SAFERELEASE(pImport);

    SAFERELEASE(pAsm);
    
    return hr;
}




// ---------------------------------------------------------------------------
// CreateAssemblyFromManifestFile
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyFromManifestFile(
    LPCOLESTR   szManifestFilePath,
    LPCOLESTR   szCodebase,
    FILETIME   *pftCodebase,
    LPASSEMBLY *ppAssembly)
{
    HRESULT hr = S_OK;
    LPASSEMBLY_MANIFEST_IMPORT pImport = NULL;
    CAssembly *pAsm                    = NULL;

    if (!szManifestFilePath || !ppAssembly) {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppAssembly = NULL;

    if (GetFileAttributes(szManifestFilePath) == -1) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    pAsm = NEW(CAssembly);
    if (!pAsm)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if FAILED(hr = CreateAssemblyManifestImport((LPTSTR)szManifestFilePath, &pImport))
        goto exit;
    
    hr = pAsm->Init(pImport, NULL, szCodebase, pftCodebase);

    if (FAILED(hr)) 
    {
        SAFERELEASE(pAsm);
        goto exit;
    }
    
    *ppAssembly = pAsm;
    (*ppAssembly)->AddRef();
    
exit:

    SAFERELEASE(pImport);
    SAFERELEASE(pAsm);

    return hr;
}

// ---------------------------------------------------------------------------
// CreateAssemblyFromManifestImport
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyFromManifestImport(IAssemblyManifestImport *pImport,
                                        LPCOLESTR szCodebase, FILETIME *pftCodebase,
                                        LPASSEMBLY *ppAssembly)
{
    HRESULT                                   hr = S_OK;
    CAssembly                                *pAsm = NULL;

    if (!pImport || !ppAssembly) {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppAssembly = NULL;

    pAsm = NEW(CAssembly);
    if (!pAsm) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pAsm->Init(pImport, NULL, szCodebase, pftCodebase);
    if (FAILED(hr)) {
        SAFERELEASE(pAsm);
        goto exit;
    }
    
    *ppAssembly = pAsm;
    (*ppAssembly)->AddRef();
    
exit:
    SAFERELEASE(pAsm);

    return hr;
}

// ---------------------------------------------------------------------------
// CreateAssemblyFromCacheLookup
// ---------------------------------------------------------------------------
HRESULT CreateAssemblyFromCacheLookup(IApplicationContext *pAppCtx,
                                      IAssemblyName *pNameRef,
                                      IAssembly **ppAsm, CDebugLog *pdbglog)
{
    HRESULT                              hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    CTransCache                         *pTransCache = NULL;
    CCache                              *pCache      = NULL;

    if (!pNameRef || !ppAsm) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    *ppAsm = NULL;
    if (FAILED(hr = CCache::Create(&pCache, pAppCtx)))
        goto Exit;
    
    ASSERT(CCache::IsStronglyNamed(pNameRef) || CCache::IsCustom(pNameRef));

    // Try to find assembly in the GAC.
    
    hr = pCache->RetrieveTransCacheEntry(pNameRef, 
            CCache::IsCustom(pNameRef) ? ASM_CACHE_ZAP : ASM_CACHE_GAC,
                                         &pTransCache);

    if (pTransCache) {
        // Found an assembly from one of the cache locations. Return it.

        hr = CreateAssemblyFromTransCacheEntry(pTransCache, NULL, ppAsm);
        if (FAILED(hr)) {
            DEBUGOUT(pdbglog, 1, ID_FUSLOG_ASSEMBLY_CREATION_FAILURE);
            goto Exit;
        }
    }
    else {
        DEBUGOUT(pdbglog, 1, ID_FUSLOG_ASSEMBLY_LOOKUP_FAILURE);
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

Exit:
    SAFERELEASE(pTransCache);
    SAFERELEASE(pCache);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssembly constructor
// ---------------------------------------------------------------------------
CAssembly::CAssembly()
{
    _pImport = NULL;
    _pName   = NULL;
    _pTransCache = NULL;
    _pwzCodebase = NULL;
    _dwAsmLoc = ASMLOC_UNKNOWN;
    _pLoadContext = NULL;
    _bDisabled = FALSE;
    _wzRegisteredAsmPath[0] = L'\0';
    _wzProbingBase[0] = L'\0';
    memset(&_ftCodebase, 0, sizeof(FILETIME));
    _hFile           = INVALID_HANDLE_VALUE;
    _bPendingDelete = FALSE;
    _cRef = 1;
}

// ---------------------------------------------------------------------------
// CAssembly destructor
// ---------------------------------------------------------------------------
CAssembly::~CAssembly()
{
    IAssemblyName                 *pName = NULL;

    SAFERELEASE(_pLoadContext);
        
    if (_pwzCodebase) {
        delete [] _pwzCodebase;
    }
    
    SAFERELEASE(_pImport);
    SAFERELEASE(_pName);

    if(_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(_hFile);

    /*
    if( _pTransCache && 
            (_pTransCache->_pInfo->blobPKT.cbSize == 0) &&
            (_pTransCache->GetCacheType() & ASM_CACHE_DOWNLOAD) &&
            (_pTransCache->GetCustomPath() == NULL))
    {
        HRESULT hr = CScavenger::DeleteAssembly(_pTransCache, NULL, FALSE);
    }
    */

    SAFERELEASE(_pTransCache);

}

// ---------------------------------------------------------------------------
// CAssembly::Init
// ---------------------------------------------------------------------------
HRESULT CAssembly::Init(LPASSEMBLY_MANIFEST_IMPORT pImport, 
    CTransCache *pTransCache, LPCOLESTR szCodebase, FILETIME *pftCodebase)
{
    HRESULT  hr = S_OK;
    int      iLen;

    _pImport = pImport;
    _pImport->AddRef();

    if (pTransCache)
    {
        _pTransCache = pTransCache;
        _pTransCache->AddRef();


    }
    
    if (szCodebase) {
        ASSERT(!_pwzCodebase);

        iLen = lstrlenW(szCodebase) + 1;
        _pwzCodebase = NEW(WCHAR[iLen]);
        if (!_pwzCodebase) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        StrCpyNW(_pwzCodebase, szCodebase, iLen);
    }

    if (pftCodebase)
        memcpy(&_ftCodebase, pftCodebase, sizeof(FILETIME));

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssembly::InitDisabled
// ---------------------------------------------------------------------------

HRESULT CAssembly::InitDisabled(IAssemblyName *pName, LPCWSTR pwzRegisteredAsmPath)
{
    HRESULT                          hr = S_OK;

    if (!pName || CAssemblyName::IsPartial(pName)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (pwzRegisteredAsmPath) {
        if (lstrlenW(pwzRegisteredAsmPath) >= MAX_PATH) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }
        
        lstrcpyW(_wzRegisteredAsmPath, pwzRegisteredAsmPath);
    }

    // Allows calling GetAssemblyNameDef() for diagnostic purposes.

    _pName = pName;
    _pName->AddRef();

    _bDisabled = TRUE;

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssembly::SetBindInfo
// ---------------------------------------------------------------------------
HRESULT CAssembly::SetBindInfo(LPASSEMBLYNAME pName) const
{
    HRESULT hr = S_OK;
    DWORD dwSize;
    
    // set url and last modified on name def if present.
    if (_pwzCodebase)
    {
        dwSize = 0;
        if (pName->GetProperty(ASM_NAME_CODEBASE_URL, NULL, &dwSize) != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            if (FAILED(hr = pName->SetProperty(ASM_NAME_CODEBASE_URL, 
                _pwzCodebase, (lstrlen(_pwzCodebase) + 1) * sizeof(WCHAR))))
                goto exit;
        }

        dwSize = 0;
        if (pName->GetProperty(ASM_NAME_CODEBASE_LASTMOD, NULL, &dwSize) != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            if (FAILED(hr = pName->SetProperty(ASM_NAME_CODEBASE_LASTMOD, 
                (void *)&_ftCodebase, sizeof(FILETIME))))
                goto exit;
        }
    }
    
    // set custom data if present.
    if (_pTransCache)
    {
        TRANSCACHEINFO* pTCInfo = (TRANSCACHEINFO*) _pTransCache->_pInfo;
        if (pTCInfo->blobCustom.cbSize)
        {
            dwSize = 0;
            if (pName->GetProperty(ASM_NAME_CUSTOM, NULL, &dwSize) != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                if (FAILED(hr = pName->SetProperty(ASM_NAME_CUSTOM, 
                    pTCInfo->blobCustom.pBlobData, pTCInfo->blobCustom.cbSize)))
                    goto exit;            
            }
        }
    }
exit:
    return hr;

}

// ---------------------------------------------------------------------------
// CAssembly::SetFileHandle
// ---------------------------------------------------------------------------
void CAssembly::SetFileHandle(HANDLE hFile)
{
    // enable this assert later.
    // ASSERT(_hFile == INVALID_HANDLE_VALUE);
    _hFile = hFile;
}

// ---------------------------------------------------------------------------
// CAssembly::GetManifestInterface
// ---------------------------------------------------------------------------
IAssemblyManifestImport *CAssembly::GetManifestInterface()
{
    if (_pImport)
        _pImport->AddRef();

    return _pImport;
}

// ---------------------------------------------------------------------------
// CAssembly::GetAssemblyNameDef
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssembly::GetAssemblyNameDef(LPASSEMBLYNAME *ppName)
{
    HRESULT hr = S_OK;
    FILETIME *pftCodeBase  = NULL;
    LPASSEMBLYNAME pName   = NULL;
    CCriticalSection cs(&g_csInitClb);

    if (!_pName)
    {
        hr = cs.Lock();
        if (FAILED(hr)) {
            return hr;
        }

        if (!_pName)
        {
            // Get read-only name definition from the import interface.
            if (FAILED(hr = _pImport->GetAssemblyNameDef(&pName))) {
                cs.Unlock();
                goto exit;
            }

            // Clone it.
            if (FAILED(hr = pName->Clone(&_pName))) {
                cs.Unlock();
                goto exit;
            }
        
            if (FAILED(hr = SetBindInfo(_pName))) {
                cs.Unlock();
                goto exit;
            }
        }        

        cs.Unlock();
    }

    _pName->AddRef();
    *ppName = _pName;
    
exit:
    SAFERELEASE(pName);
    return hr;
}

// ---------------------------------------------------------------------------
// CAssembly::GetNextAssemblyNameRef
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssembly::GetNextAssemblyNameRef(DWORD nIndex, LPASSEMBLYNAME *ppName)
{
    if (_bDisabled) {
        return E_NOTIMPL;
    }
    
    return _pImport->GetNextAssemblyNameRef(nIndex, ppName);
}

// ---------------------------------------------------------------------------
// CAssembly::GetNextAssemblyModule
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssembly::GetNextAssemblyModule(DWORD nIndex, LPASSEMBLY_MODULE_IMPORT *ppModImport)
{
    HRESULT hr = S_OK;

    if (_bDisabled) {
        return E_NOTIMPL;
    }

    LPASSEMBLYNAME pName = NULL;
    LPASSEMBLY_MODULE_IMPORT pModImport = NULL;
    CAssemblyModuleImport *pCModImport = NULL;
    
    // Get the ith module import interface.
    if (FAILED(hr = _pImport->GetNextAssemblyModule(nIndex, &pModImport)))
        goto exit;

    hr = PrepModImport(pModImport);
    if (FAILED(hr)) {
        goto exit;
    }

    // Hand out the interface.
    *ppModImport = pModImport;
exit:
    return hr;

}

// ---------------------------------------------------------------------------
// CAssembly::PrepModImport
// ---------------------------------------------------------------------------

HRESULT CAssembly::PrepModImport(IAssemblyModuleImport *pModImport) const
{
    HRESULT                                  hr = S_OK;
    CAssemblyModuleImport                   *pCModImport = NULL;
    IAssemblyName                           *pName = NULL;

    ASSERT(pModImport);

    pCModImport = dynamic_cast<CAssemblyModuleImport *>(pModImport);
    if (!pCModImport) {
        hr = E_FAIL;
        goto Exit;
    }

    // Obtain a pointer to the (writeable) name interface
    // owned by IAssemblyModuleImport. We will be setting
    // url + last-mod + custom data.
    
    hr = pCModImport->GetNameDef(&pName);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Set url + last-mod + custom data.
    hr = SetBindInfo(pName);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFERELEASE(pName);
    return hr;
}
        

// ---------------------------------------------------------------------------
// CAssembly::GetModuleByName
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssembly::GetModuleByName(LPCOLESTR pszModuleName, LPASSEMBLY_MODULE_IMPORT *ppModImport)
{
    HRESULT                                        hr = S_OK;
    IAssemblyModuleImport                         *pModImport = NULL;

    if (_bDisabled) {
        return E_NOTIMPL;
    }

    if (!pszModuleName || !ppModImport) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = _pImport->GetModuleByName(pszModuleName, &pModImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = PrepModImport(pModImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppModImport = pModImport;
    (*ppModImport)->AddRef();

Exit:
    SAFERELEASE(pModImport);
    return hr;
}

// ---------------------------------------------------------------------------
// CAssembly::GetManifestModulePath
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssembly::GetManifestModulePath(LPOLESTR pszModulePath, LPDWORD pccModulePath)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     dwLen;

    if (!pccModulePath) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (_bDisabled) {
        dwLen = lstrlenW(_wzRegisteredAsmPath);

        if (!dwLen) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if (!pszModulePath || *pccModulePath < dwLen + 1) {
            *pccModulePath = dwLen + 1;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        lstrcpyW(pszModulePath, _wzRegisteredAsmPath);
        *pccModulePath = dwLen + 1;
    }
    else {
        hr = _pImport->GetManifestModulePath(pszModulePath, pccModulePath);
    }

Exit:
    return hr;
}


// ---------------------------------------------------------------------------
// CAssembly::GetAssemblyPath
// ---------------------------------------------------------------------------
HRESULT CAssembly::GetAssemblyPath(LPOLESTR pStr, LPDWORD lpcwBuffer)
{
    HRESULT                           hr = S_OK;
    WCHAR                             wzBuf[MAX_PATH + 1];
    DWORD                             dwBuf = MAX_PATH + 1;
    DWORD                             dwLen = 0;
    LPWSTR                            pwzTmp = NULL;

    if (_bDisabled) {
        return E_NOTIMPL;
    }
    
    if (!lpcwBuffer) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    ASSERT(_pImport);
    
    hr = _pImport->GetManifestModulePath(wzBuf, &dwBuf);
    if (SUCCEEDED(hr)) {
        pwzTmp = PathFindFileName(wzBuf);
        if (!pwzTmp) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        *pwzTmp = L'\0';
        dwLen = lstrlenW(wzBuf) + 1;

        if (*lpcwBuffer < dwLen) {
            *lpcwBuffer = dwLen;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        lstrcpyW(pStr, wzBuf);
    }

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssembly::GetAssemblyLocation
// ---------------------------------------------------------------------------

STDMETHODIMP CAssembly::GetAssemblyLocation(DWORD *pdwAsmLocation)
{
    HRESULT                                  hr = S_OK;

    if (_bDisabled) {
        return E_NOTIMPL;
    }

    if (!pdwAsmLocation) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pdwAsmLocation = _dwAsmLoc;

Exit:
    return hr;
}

// IUnknown methods

// ---------------------------------------------------------------------------
// CAssembly::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssembly::AddRef()
{
    HRESULT                             hr;
    LONG                                lRef = -1;
    
    if (_pLoadContext) {
        hr = _pLoadContext->Lock();
        if (hr == S_OK) {
            lRef = InterlockedIncrement((LONG*) &_cRef);
            _pLoadContext->Unlock();
        }
    }
    else {
        lRef = InterlockedIncrement((LONG *)&_cRef);
    }

    return lRef;
}

// ---------------------------------------------------------------------------
// CAssembly::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssembly::Release()
{
    HRESULT                                   hr = S_OK;
    LONG                                      lRef = -1;

    if (_pLoadContext) {
        hr = _pLoadContext->Lock();
        if (hr == S_OK) {
            lRef = InterlockedDecrement((LONG *)&_cRef);
            if (lRef == 1) {
                _bPendingDelete = TRUE;
                _pLoadContext->Unlock();
                
                // There is a circular reference count between the load context and
                // the CAssembly (CAssembly holds back pointer to load context, and
                // load context holds on to activated node, which contains a ref to
                // the CAssembly). When release causes the ref count to go to 1, we
                // know the only ref count left is from the load context (as long as
                // nobody screwed up the ref counting). Thus, at this time, we need to
                // remove ourselves from the load context list, which will in turn,
                // cause a release of this object, so it is properly destroyed.

                SAFERELEASE(_pImport);
                _pLoadContext->RemoveActivation(this);
            }
            else if (!lRef) {
                _pLoadContext->Unlock();
                delete this;
                goto Exit;
            }
            else {
                _pLoadContext->Unlock();
            }
        }
        else {
            ASSERT(0);
            goto Exit;
        }
    }
    else {
        lRef = InterlockedDecrement((LONG *)&_cRef);
        if (!lRef) {
            delete this;
            goto Exit;
        }
    }


Exit:
    return lRef;
}

// ---------------------------------------------------------------------------
// CAssembly::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssembly::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IAssembly || riid == IID_IUnknown) {
        *ppv = (IAssembly *)this;
    }
    else if (riid == IID_IServiceProvider) {
        *ppv = (IServiceProvider *)this;
    }
    else {
        return E_NOINTERFACE;
    }

    ((IUnknown*)(*ppv))->AddRef();

    return S_OK;

} 

// ---------------------------------------------------------------------------
// CAssembly::QueryService
// ---------------------------------------------------------------------------

STDMETHODIMP CAssembly::QueryService(REFGUID rsid, REFIID riid, void **ppv)
{
    HRESULT                                 hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(rsid, IID_IAssemblyManifestImport) && IsEqualIID(riid, IID_IAssemblyManifestImport) && _pImport) {
        hr = _pImport->QueryInterface(IID_IAssemblyManifestImport, ppv);
    }
    else {
        hr = E_NOINTERFACE;
    }

    return hr;
}

HRESULT CAssembly::SetAssemblyLocation(DWORD dwAsmLoc)
{
    _dwAsmLoc = dwAsmLoc;

    return S_OK;
}

HRESULT CAssembly::GetLoadContext(CLoadContext **ppLoadContext)
{
    HRESULT                                    hr = S_OK;

    ASSERT(ppLoadContext);

    *ppLoadContext = _pLoadContext;
    (*ppLoadContext)->AddRef();

    return hr;
}

HRESULT CAssembly::SetLoadContext(CLoadContext *pLoadContext)
{
    ASSERT(!_pLoadContext);

    _pLoadContext = pLoadContext;
    _pLoadContext->AddRef();

    return S_OK;
}

HRESULT CAssembly::SetProbingBase(LPCWSTR pwzProbingBase)
{
    ASSERT(pwzProbingBase && lstrlen(pwzProbingBase) < MAX_URL_LENGTH);

    lstrcpyW(_wzProbingBase, pwzProbingBase);

    return S_OK;
}

HRESULT CAssembly::GetProbingBase(LPWSTR pwzProbingBase, DWORD *pccLength)
{
    HRESULT                                 hr = S_OK;
    DWORD                                   dwLen;

    if (!pccLength) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_wzProbingBase) + 1;

    if (!pwzProbingBase || *pccLength < dwLen) {
        *pccLength = dwLen;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    lstrcpyW(pwzProbingBase, _wzProbingBase);
    *pccLength = dwLen;

Exit:
    return hr;
}
    
HRESULT CAssembly::GetFusionLoadContext(IFusionLoadContext **ppLoadContext)
{
    HRESULT                                     hr = S_OK;
    
    if (!ppLoadContext) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppLoadContext = NULL;

    if (!_pLoadContext) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    *ppLoadContext = _pLoadContext;
    (*ppLoadContext)->AddRef();

Exit:
    return hr;
}
        
BOOL CAssembly::IsPendingDelete()
{
    return _bPendingDelete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\histasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "histasm.h"
#include "history.h"
#include "iniread.h"
#include "util.h"

CHistoryAssembly::CHistoryAssembly()
: _pwzAsmName(NULL)
, _pwzPublicKeyToken(NULL)
, _pwzCulture(NULL)
, _pwzVerReference(NULL)
, _pwzActivationDate(NULL)
, _cRef(1)
{
    _dwSig = 'MSAH';
    _wzFilePath[0] = L'\0';

    memset(&_bindInfo, 0, sizeof(_bindInfo));
}

CHistoryAssembly::~CHistoryAssembly()
{
    SAFEDELETEARRAY(_pwzAsmName);
    SAFEDELETEARRAY(_pwzPublicKeyToken);
    SAFEDELETEARRAY(_pwzCulture);
    SAFEDELETEARRAY(_pwzVerReference);
    SAFEDELETEARRAY(_pwzActivationDate);
}


HRESULT CHistoryAssembly::Create(LPCWSTR pwzFilePath, LPCWSTR pwzActivationDate,
                                 LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                                 LPCWSTR pwzCulture, LPCWSTR pwzVerRef,
                                 CHistoryAssembly **ppHistAsm)
{
    HRESULT                                        hr = S_OK;
    CHistoryAssembly                              *pHistAsm = NULL;
    
    if (!pwzFilePath || !pwzActivationDate || !pwzAsmName || !pwzPublicKeyToken || !pwzVerRef || !ppHistAsm || !pwzCulture) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pHistAsm = NEW(CHistoryAssembly);
    if (!pHistAsm) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pHistAsm->Init(pwzFilePath, pwzActivationDate, pwzAsmName, pwzPublicKeyToken, pwzCulture, pwzVerRef);
    if (FAILED(hr)) {
        SAFERELEASE(pHistAsm);
        goto Exit;
    }

    *ppHistAsm = pHistAsm;
    (*ppHistAsm)->AddRef();

Exit:
    SAFERELEASE(pHistAsm);

    return hr;
}


HRESULT CHistoryAssembly::Init(LPCWSTR pwzFilePath, LPCWSTR pwzActivationDate,
                               LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                               LPCWSTR pwzCulture, LPCWSTR pwzVerRef)
{
    HRESULT                                    hr = S_OK;
    BOOL                                       bExists;
    CIniReader                                 iniReader;

    ASSERT(pwzFilePath && pwzPublicKeyToken && pwzCulture && pwzVerRef && pwzActivationDate);

    if (GetFileAttributes(pwzFilePath) == -1) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    lstrcpyW(_wzFilePath, pwzFilePath);

    _pwzActivationDate = WSTRDupDynamic(pwzActivationDate);
    if (!_pwzActivationDate) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _pwzAsmName = WSTRDupDynamic(pwzAsmName);
    if (!_pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _pwzPublicKeyToken = WSTRDupDynamic(pwzPublicKeyToken);
    if (!_pwzPublicKeyToken) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _pwzCulture = WSTRDupDynamic(pwzCulture);
    if (!_pwzCulture) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _pwzVerReference = WSTRDupDynamic(pwzVerRef);
    if (!_pwzPublicKeyToken) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = iniReader.Init(_wzFilePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    bExists = iniReader.DoesExist(this);
    if (!bExists) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    // Figure out the bind info

    hr = iniReader.GetAssemblyInfo(_pwzActivationDate, _pwzAsmName, _pwzPublicKeyToken,
                                   _pwzCulture, _pwzVerReference, &_bindInfo);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    return hr;
}                                       

HRESULT CHistoryAssembly::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IHistoryAssembly)) {
        *ppv = static_cast<IHistoryAssembly *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CHistoryAssembly::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CHistoryAssembly::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);
    
    if (!ulRef) {
        delete this;
    }

    return ulRef;
}


HRESULT CHistoryAssembly::GetAssemblyName(LPWSTR wzAsmName, DWORD *pdwSize)
{
    HRESULT                                    hr = S_OK;
    DWORD                                      dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_pwzAsmName) + 1;
    if (!wzAsmName || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzAsmName, _pwzAsmName);
    *pdwSize = dwLen;

Exit:
    return hr;
}


HRESULT CHistoryAssembly::GetPublicKeyToken(LPWSTR wzPublicKeyToken, DWORD *pdwSize)
{
    HRESULT                                    hr = S_OK;
    DWORD                                      dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_pwzPublicKeyToken) + 1;
    if (!wzPublicKeyToken || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzPublicKeyToken, _pwzPublicKeyToken);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CHistoryAssembly::GetCulture(LPWSTR wzCulture, DWORD *pdwSize)
{
    HRESULT                                    hr = S_OK;
    DWORD                                      dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_pwzCulture) + 1;
    if (!wzCulture || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzCulture, _pwzCulture);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CHistoryAssembly::GetReferenceVersion(LPWSTR pwzVerRef, DWORD *pdwSize)
{
    HRESULT                                    hr = S_OK;
    DWORD                                      dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_pwzVerReference) + 1;
    if (!pwzVerRef || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(pwzVerRef, _pwzVerReference);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CHistoryAssembly::GetActivationDate(LPWSTR wzActivationDate, DWORD *pdwSize)
{
    HRESULT                                    hr = S_OK;
    DWORD                                      dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_pwzActivationDate) + 1;
    if (!wzActivationDate || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzActivationDate, _pwzActivationDate);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CHistoryAssembly::GetAppCfgVersion(LPWSTR pwzVerAppCfg, DWORD *pdwSize)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_bindInfo.wzVerAppCfg) + 1;
    if (!pwzVerAppCfg || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(pwzVerAppCfg, _bindInfo.wzVerAppCfg);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CHistoryAssembly::GetPublisherCfgVersion(LPWSTR pwzVerPublisherCfg,
                                                      DWORD *pdwSize)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_bindInfo.wzVerPublisherCfg) + 1;
    if (!pwzVerPublisherCfg || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(pwzVerPublisherCfg, _bindInfo.wzVerPublisherCfg);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CHistoryAssembly::GetAdminCfgVersion(LPWSTR pwzVerAdminCfg, DWORD *pdwSize)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = lstrlenW(_bindInfo.wzVerAdminCfg) + 1;
    if (!pwzVerAdminCfg || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(pwzVerAdminCfg, _bindInfo.wzVerAdminCfg);
    *pdwSize = dwLen;

Exit:
    return hr;
}


STDAPI LookupHistoryAssembly(LPCWSTR pwzFilePath, FILETIME *pftActivationDate,
                             LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                             LPCWSTR pwzCulture, LPCWSTR pwzVerRef,
                             IHistoryAssembly **ppHistAsm)
{
    HRESULT                                    hr = S_OK;
    WCHAR                                      wzActivationDate[MAX_ACTIVATION_DATE_LEN];

    if (!pwzFilePath || !pftActivationDate || !pwzAsmName || !pwzPublicKeyToken || !pwzVerRef || !ppHistAsm) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wnsprintfW(wzActivationDate, MAX_ACTIVATION_DATE_LEN, L"%u.%u",
               pftActivationDate->dwHighDateTime, pftActivationDate->dwLowDateTime);

    hr = LookupHistoryAssemblyInternal(pwzFilePath, wzActivationDate,
                                       pwzAsmName, pwzPublicKeyToken,
                                       pwzCulture, pwzVerRef, ppHistAsm);


Exit:
    return hr;
}

HRESULT LookupHistoryAssemblyInternal(LPCWSTR pwzFilePath, LPCWSTR pwzActivationDate,
                                      LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                                      LPCWSTR pwzCulture, LPCWSTR pwzVerRef,
                                      IHistoryAssembly **ppHistAsm)
{
    HRESULT                                          hr = S_OK;
    CHistoryAssembly                                *pHistAsm = NULL;

    hr = CHistoryAssembly::Create(pwzFilePath, pwzActivationDate, pwzAsmName,
                                  pwzPublicKeyToken, pwzCulture, pwzVerRef, &pHistAsm);
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppHistAsm = pHistAsm;
    (*ppHistAsm)->AddRef();

Exit:
    SAFERELEASE(pHistAsm);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\iniread.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "history.h"
#include "iniread.h"
#include "iniwrite.h"
#include "util.h"
#include "helpers.h"

extern DWORD g_dwMaxAppHistory;

CIniReader::CIniReader()
: _wzFilePath(NULL)
, _cRef(1)
{
    _dwSig = 'RINI';
}

CIniReader::~CIniReader()
{
    SAFEDELETEARRAY(_wzFilePath);
}

HRESULT CIniReader::Init(LPCWSTR wzFilePath)
{
    HRESULT                                     hr = S_OK;

    if (!wzFilePath) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    _wzFilePath = WSTRDupDynamic(wzFilePath);
    if (!_wzFilePath) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CIniReader::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IHistoryReader)) {
        *ppv = static_cast<IHistoryReader *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CIniReader::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CIniReader::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

HRESULT CIniReader::GetAssemblyInfo(LPCWSTR wzActivationDate,
                                    LPCWSTR wzAssemblyName,
                                    LPCWSTR wzPublicKeyToken,
                                    LPCWSTR wzCulture,
                                    LPCWSTR wzVerReference,
                                    AsmBindHistoryInfo *pBindInfo)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  wzBuffer = NULL;
    LPWSTR                                  wzTag = NULL;
    LPWSTR                                  wzActivationTag = NULL;
    LPWSTR                                  wzKey = NULL;
    LPWSTR                                  wzPropBuf = NULL;
    DWORD                                   dwRet;
    BOOL                                    bFound;
    DWORD                                   i;

    if (!wzActivationDate || !pBindInfo || !wzAssemblyName || !wzPublicKeyToken || !wzCulture || !wzVerReference) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzTag = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTag) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzKey = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzKey) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    memset(pBindInfo, 0, sizeof(AsmBindHistoryInfo));

    bFound = FALSE;

    for (i = 1; i <= g_dwMaxAppHistory; i++) {
        wnsprintfW(wzTag, MAX_INI_TAG_LENGTH, L"%ws_%d", FUSION_SNAPSHOT_PREFIX, i);

        dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER, wzTag,
                                           DEFAULT_INI_VALUE, &wzActivationTag,
                                           _wzFilePath);
        if (!wzActivationTag) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (!FusionCompareStringI(wzActivationTag, DEFAULT_INI_VALUE)) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if (!FusionCompareStringI(wzActivationTag, wzActivationDate)) {
            bFound = TRUE;
            break;
        }
    }

    if (bFound) {
        // Found activation history. Lookup assembly section.

        wnsprintfW(wzKey, MAX_INI_TAG_LENGTH, L"%ws%wc%ws%wc%ws%wc%ws", wzAssemblyName,
                   HISTORY_DELIMITER_CHAR, wzPublicKeyToken,
                   HISTORY_DELIMITER_CHAR, wzCulture,
                   HISTORY_DELIMITER_CHAR, wzVerReference);

        dwRet = GetPrivateProfileStringExW(wzActivationTag, wzKey, DEFAULT_INI_VALUE,
                                           &wzBuffer, _wzFilePath);
        if (!wzBuffer) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
            // Did not find assembly

            hr = S_FALSE;
            goto Exit;
        }

        // Populate the bind history information

        wnsprintf(pBindInfo->wzAsmName, MAX_INI_TAG_LENGTH, L"%ws", wzAssemblyName);
        wnsprintf(pBindInfo->wzPublicKeyToken, MAX_PUBLIC_KEY_TOKEN_LEN, L"%ws", wzPublicKeyToken);

        SAFEDELETEARRAY(wzPropBuf);
        dwRet = GetPrivateProfileStringExW(wzBuffer, ASSEMBLY_DATA_VER_REFERENCE,
                                           DEFAULT_INI_VALUE, &wzPropBuf,
                                           _wzFilePath);
        if (!wzPropBuf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        wnsprintf(pBindInfo->wzVerReference, MAX_VERSION_DISPLAY_SIZE, L"%ws", wzPropBuf);

        SAFEDELETEARRAY(wzPropBuf);
        dwRet = GetPrivateProfileStringExW(wzBuffer, ASSEMBLY_DATA_VER_APP_CFG,
                                           DEFAULT_INI_VALUE, &wzPropBuf,
                                           _wzFilePath);
        if (!wzPropBuf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        wnsprintf(pBindInfo->wzVerAppCfg, MAX_VERSION_DISPLAY_SIZE, L"%ws", wzPropBuf);

        SAFEDELETEARRAY(wzPropBuf);
        dwRet = GetPrivateProfileStringExW(wzBuffer, ASSEMBLY_DATA_VER_PUBLISHER_CFG,
                                           DEFAULT_INI_VALUE, &wzPropBuf,
                                           _wzFilePath);
        if (!wzPropBuf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        wnsprintf(pBindInfo->wzVerPublisherCfg, MAX_VERSION_DISPLAY_SIZE, L"%ws", wzPropBuf);

        SAFEDELETEARRAY(wzPropBuf);
        dwRet = GetPrivateProfileStringExW(wzBuffer, ASSEMBLY_DATA_VER_ADMIN_CFG,
                                           DEFAULT_INI_VALUE, &wzPropBuf,
                                           _wzFilePath);
        if (!wzPropBuf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        wnsprintf(pBindInfo->wzVerAdminCfg, MAX_VERSION_DISPLAY_SIZE, L"%ws", wzPropBuf);
    }
    else {
        // Assembly not found

        hr = S_FALSE;
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzBuffer);
    SAFEDELETEARRAY(wzActivationTag);
    SAFEDELETEARRAY(wzTag);
    SAFEDELETEARRAY(wzKey);
    SAFEDELETEARRAY(wzPropBuf);
    
    return hr;
}

HRESULT CIniReader::GetFilePath(LPWSTR wzFilePath, DWORD *pdwSize)
{
    HRESULT                                        hr = S_OK;
    DWORD                                          dwLen;

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    ASSERT(_wzFilePath);
    dwLen = lstrlenW(_wzFilePath) + 1;

    if (!wzFilePath || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzFilePath, _wzFilePath);
    *pdwSize = dwLen;

Exit:
    return hr;
}

HRESULT CIniReader::GetNumActivations(DWORD *pdwNumActivations)
{
    HRESULT                                     hr = S_OK;
    DWORD                                       dwRet;
    LPWSTR                                      wzBuffer = NULL;

    if (!pdwNumActivations) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER, HEADER_DATA_NUM_SECTIONS,
                                       DEFAULT_INI_VALUE, &wzBuffer,
                                       _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
        *pdwNumActivations = 0;
    }
    else {
        *pdwNumActivations = StrToIntW(wzBuffer);
    }

Exit:
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}

HRESULT CIniReader::GetActivationDate(DWORD dwIdx, FILETIME *pftDate)
{
    HRESULT                                       hr = S_OK;
    DWORD                                         dwRet;
    LPWSTR                                        wzPos;
    LPWSTR                                        wzTag = NULL;
    LPWSTR                                        wzBuffer = NULL;

    if (!pftDate) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzTag = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTag) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(wzTag, MAX_INI_TAG_LENGTH, L"%ws_%d", FUSION_SNAPSHOT_PREFIX, dwIdx);

    dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER, wzTag, DEFAULT_INI_VALUE,
                                       &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzPos = wzBuffer;
    while (*wzPos) {
        if (*wzPos == L'.') {
            break;
        }

        wzPos++;
    }

    if (!*wzPos) {
        // Malformed date string
        hr = E_UNEXPECTED;
        goto Exit;
    }

    *wzPos = L'\0';
    wzPos++;

    pftDate->dwHighDateTime = StrToIntW(wzBuffer);
    pftDate->dwLowDateTime = StrToIntW(wzPos);

Exit:
    SAFEDELETEARRAY(wzTag);
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}
    
HRESULT CIniReader::GetRunTimeVersion(FILETIME *pftActivationDate,
                                      LPWSTR wzRunTimeVersion, DWORD *pdwSize)
{
    HRESULT                                        hr = S_OK;
    DWORD                                          dwLen;
    DWORD                                          dwRet;
    LPWSTR                                         wzTag = NULL;
    LPWSTR                                         wzBuffer = NULL;

    if (!pftActivationDate || !pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    wzTag = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTag) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(wzTag, MAX_INI_TAG_LENGTH, L"%u.%u", pftActivationDate->dwHighDateTime,
               pftActivationDate->dwLowDateTime);

    dwRet = GetPrivateProfileStringExW(wzTag, SNAPSHOT_DATA_URT_VERSION, DEFAULT_INI_VALUE,
                                       &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    dwLen = lstrlenW(wzBuffer) + 1;

    if (!wzRunTimeVersion || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzRunTimeVersion, wzBuffer);
    *pdwSize = dwLen;
    
Exit:
    SAFEDELETEARRAY(wzTag);
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}


HRESULT CIniReader::GetApplicationName(LPWSTR wzAppName, DWORD *pdwSize)
{
    HRESULT                                   hr = S_OK;
    LPWSTR                                    wzBuffer = NULL;
    DWORD                                     dwRet;
    DWORD                                     dwLen;
    
    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER, HEADER_DATA_APP_NAME,
                                       DEFAULT_INI_VALUE, &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    dwLen = lstrlenW(wzBuffer) + 1;

    if (!wzAppName || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzAppName, wzBuffer);
    *pdwSize = dwLen;

Exit:
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}
    
HRESULT CIniReader::GetEXEModulePath(LPWSTR wzExePath, DWORD *pdwSize)
{
    HRESULT                                   hr = S_OK;
    LPWSTR                                    wzBuffer = NULL;
    DWORD                                     dwRet;
    DWORD                                     dwLen;
    

    if (!pdwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER, HEADER_DATA_EXE_PATH,
                                       DEFAULT_INI_VALUE, &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    dwLen = lstrlenW(wzBuffer) + 1;

    if (!wzExePath || *pdwSize < dwLen) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pdwSize = dwLen;
        goto Exit;
    }

    lstrcpyW(wzExePath, wzBuffer);
    *pdwSize = dwLen;

Exit:
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}

HRESULT CIniReader::GetNumAssemblies(FILETIME *pftActivationDate,
                                     DWORD *pdwNumAsms)
{
    HRESULT                                        hr = S_OK;
    LPWSTR                                         wzTag = NULL;
    LPWSTR                                         wzBuffer = NULL;
    LPWSTR                                         wzCurStr;
    DWORD                                          dwRet;
    DWORD                                          dwCurIdx;

    if (!pftActivationDate || !pdwNumAsms) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzTag = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTag) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *pdwNumAsms = 0;

    wnsprintfW(wzTag, MAX_INI_TAG_LENGTH, L"%u.%u", pftActivationDate->dwHighDateTime,
               pftActivationDate->dwLowDateTime);
               
    dwRet = GetPrivateProfileStringExW(wzTag, NULL, DEFAULT_INI_VALUE,
                                       &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    wzCurStr = wzBuffer;
    dwCurIdx = 0;

    while (lstrlenW(wzCurStr)) {
        if (!FusionCompareString(wzCurStr, SNAPSHOT_DATA_URT_VERSION)) {
            // Iterate over this (it's not an assembly).
            wzCurStr += (lstrlenW(wzCurStr) + 1);
            continue;
        }

        dwCurIdx++;
        wzCurStr += (lstrlenW(wzCurStr) + 1);
    }

    *pdwNumAsms = dwCurIdx;

Exit:
    SAFEDELETEARRAY(wzTag);
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}



HRESULT CIniReader::GetHistoryAssembly(FILETIME *pftActivationDate, DWORD dwIdx,
                                       IHistoryAssembly **ppHistAsm)
{
    HRESULT                                        hr = S_OK;
    DWORD                                          dwRet;
    DWORD                                          dwCurIdx;
    LPWSTR                                         wzCurStr;
    LPWSTR                                         wzAsmName = NULL;
    LPWSTR                                         wzAsmPublicKeyToken = NULL;
    LPWSTR                                         wzAsmCulture = NULL;
    LPWSTR                                         wzVerRef = NULL;
    LPWSTR                                         wzTag = NULL;
    LPWSTR                                         wzBuffer = NULL;
    BOOL                                           bFound = FALSE;

    if (!pftActivationDate) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzTag = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTag) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(wzTag, MAX_INI_TAG_LENGTH, L"%u.%u", pftActivationDate->dwHighDateTime,
               pftActivationDate->dwLowDateTime);

    dwRet = GetPrivateProfileStringExW(wzTag, NULL, DEFAULT_INI_VALUE,
                                       &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    wzCurStr = wzBuffer;
    dwCurIdx = 1;

    while (lstrlenW(wzCurStr)) {
        if (!FusionCompareString(wzCurStr, SNAPSHOT_DATA_URT_VERSION)) {
            // Iterate over this (it's not an assembly).
            wzCurStr += (lstrlenW(wzCurStr) + 1);
            continue;
        }

        if (dwCurIdx == dwIdx) {
            // wzCurStr is of the form: [AsmName].[PublicKeyToken].[Culture].[VerRef]
    
            hr = ExtractAssemblyInfo(wzCurStr, &wzAsmName, &wzAsmPublicKeyToken, &wzAsmCulture, &wzVerRef);
            if (FAILED(hr)) {
                goto Exit;
            }

            bFound = TRUE;
            break;
        }

        // Iterate

        dwCurIdx++;
        wzCurStr += (lstrlenW(wzCurStr) + 1);
    }

    if (!bFound) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto Exit;
    }

    hr = LookupHistoryAssemblyInternal(_wzFilePath, wzTag, wzAsmName, wzAsmPublicKeyToken,
                                       wzAsmCulture, wzVerRef, ppHistAsm);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzTag);
    SAFEDELETEARRAY(wzBuffer);

    return hr;
}


HRESULT CIniReader::ExtractAssemblyInfo(LPWSTR wzAsmStr, LPWSTR *ppwzAsmName,
                                        LPWSTR *ppwzAsmPublicKeyToken,
                                        LPWSTR *ppwzAsmCulture,
                                        LPWSTR *ppwzAsmVerRef)
{
    HRESULT                                        hr = S_OK;
    LPWSTR                                         wzPos;
    
    ASSERT(wzAsmStr && ppwzAsmName && ppwzAsmPublicKeyToken && ppwzAsmCulture && ppwzAsmVerRef);
        // Assembly Name

    *ppwzAsmName = wzAsmStr;
    wzPos = wzAsmStr;

    while (*wzPos) {
        if (*wzPos == HISTORY_DELIMITER_CHAR) {
            break;
        }

        wzPos++;
    }

    if (!wzPos) {
        // malformed string
        hr = E_UNEXPECTED;
        goto Exit;
    }

    *wzPos = L'\0';
    wzPos++;

    // Public Key Token

    *ppwzAsmPublicKeyToken = wzPos;
    
    while (*wzPos) {
        if (*wzPos == HISTORY_DELIMITER_CHAR) {
            break;
        }

        wzPos++;
    }

    if (!wzPos) {
        // malformed string
        hr = E_UNEXPECTED;
        goto Exit;
    }

    *wzPos = L'\0';
    wzPos++;

    // Culture

    *ppwzAsmCulture = wzPos;

    while (*wzPos) {
        if (*wzPos == HISTORY_DELIMITER_CHAR) {
            break;
        }

        wzPos++;
    }

    if (!wzPos) {
        //malformed string
        hr = E_UNEXPECTED;
        goto Exit;
    }

    *wzPos = L'\0';
    wzPos++;

    // Reference Version

    *ppwzAsmVerRef = wzPos;

    if (!*wzPos) {
        // malformed string
        hr = E_UNEXPECTED;
        goto Exit;
    }


Exit:
    if (FAILED(hr)) {
        *ppwzAsmName = NULL;
        *ppwzAsmPublicKeyToken = NULL;
        *ppwzAsmVerRef = NULL;
    }
    return hr;
}


STDMETHODIMP_(BOOL) CIniReader::DoesExist(IHistoryAssembly *pHistAsm)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      wzBuffer = NULL;
    WCHAR                                       wzAsmTag[MAX_INI_TAG_LENGTH];
    WCHAR                                       wzActivationDate[MAX_INI_TAG_LENGTH];
    WCHAR                                       wzAsmName[MAX_INI_TAG_LENGTH];
    WCHAR                                       wzAsmPublicKeyToken[MAX_INI_TAG_LENGTH];
    WCHAR                                       wzAsmCulture[MAX_INI_TAG_LENGTH];
    WCHAR                                       wzVerRef[MAX_INI_TAG_LENGTH];
    BOOL                                        bExists = FALSE;
    DWORD                                       dwSize;
    DWORD                                       dwRet;

    if (!pHistAsm) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSize = MAX_INI_TAG_LENGTH;
    hr = pHistAsm->GetActivationDate(wzActivationDate, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = MAX_INI_TAG_LENGTH;
    hr = pHistAsm->GetAssemblyName(wzAsmName, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = MAX_INI_TAG_LENGTH;
    hr = pHistAsm->GetPublicKeyToken(wzAsmPublicKeyToken, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = MAX_INI_TAG_LENGTH;
    hr = pHistAsm->GetCulture(wzAsmCulture, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = MAX_INI_TAG_LENGTH;
    hr = pHistAsm->GetReferenceVersion(wzVerRef, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    wnsprintfW(wzAsmTag, MAX_INI_TAG_LENGTH, L"%ws%wc%ws%wc%ws%wc%ws", wzAsmName,
               HISTORY_DELIMITER_CHAR, wzAsmPublicKeyToken,
               HISTORY_DELIMITER_CHAR, wzAsmCulture,
               HISTORY_DELIMITER_CHAR, wzVerRef);

    dwRet = GetPrivateProfileStringExW(wzActivationDate, wzAsmTag,
                                       DEFAULT_INI_VALUE, &wzBuffer, _wzFilePath);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (FusionCompareStringI(DEFAULT_INI_VALUE, wzBuffer)) {
        bExists = TRUE;
    }
    
Exit:
    SAFEDELETEARRAY(wzBuffer);

    return bExists;
}
    

STDAPI CreateHistoryReader(LPCWSTR wzFilePath, IHistoryReader **ppHistoryReader)
{
    HRESULT                                 hr = S_OK;
    CIniReader                             *pHistoryReader = NULL;

    if (!wzFilePath || !ppHistoryReader) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (GetFileAttributes(wzFilePath) == -1) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    pHistoryReader = NEW(CIniReader);
    if (!pHistoryReader) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pHistoryReader->Init(wzFilePath);
    if (FAILED(hr)) {
        SAFERELEASE(pHistoryReader);
        goto Exit;
    }

    *ppHistoryReader = pHistoryReader;
    (*ppHistoryReader)->AddRef();

Exit:
    SAFERELEASE(pHistoryReader);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\naming.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
 //
//  Naming Services
//

#include <windows.h>
#include <winerror.h>
#include "naming.h"
#include "debmacro.h"
#include "clbutils.h"
#include "asmcache.h"
#include "asm.h"
#include "asmimprt.h"
#include "fusionp.h"
#include "adl.h"
#include "cblist.h"
#include "helpers.h"
#include "appctx.h"
#include "actasm.h"
#include "parse.h"
#include "bsinkez.h"
#include "adlmgr.h"
#include "policy.h"
#include "dbglog.h"
#include "util.h"    
#include "cfgdl.h"
#include "pcycache.h"
#include "history.h"
#include "histinfo.h"
#include "cacheutils.h"
#include "lock.h"

#define VERSION_STRING_SEGMENTS                     4

PFNSTRONGNAMETOKENFROMPUBLICKEY      g_pfnStrongNameTokenFromPublicKey = NULL;
PFNSTRONGNAMEERRORINFO               g_pfnStrongNameErrorInfo = NULL;
PFNSTRONGNAMEFREEBUFFER              g_pfnStrongNameFreeBuffer = NULL;
PFNSTRONGNAMESIGNATUREVERIFICATION   g_pfnStrongNameSignatureVerification = NULL;

FusionTag(TagNaming, "Fusion", "Name Object");

extern WCHAR g_wszAdminCfg[];
extern CRITICAL_SECTION g_csInitClb;
extern WCHAR g_wzEXEPath[MAX_PATH+1];

#define DEVPATH_DIR_DELIMITER                   L';'

#ifdef LOG_CODEBASE
void LogCodebases(ICodebaseList *pList);
#endif

// ---------------------------------------------------------------------------
// CPropertyArray ctor
// ---------------------------------------------------------------------------
CPropertyArray::CPropertyArray()
{
    _dwSig = 'PORP';
    memset(&_rProp, 0, ASM_NAME_MAX_PARAMS * sizeof(Property));
}

// ---------------------------------------------------------------------------
// CPropertyArray dtor
// ---------------------------------------------------------------------------
CPropertyArray::~CPropertyArray()
{
    for (DWORD i = 0; i < ASM_NAME_MAX_PARAMS; i++)
    {
        if (_rProp[i].cb > sizeof(DWORD))
        {
            if (_rProp[i].pv != NULL)
            {
                FUSION_DELETE_ARRAY((LPBYTE) _rProp[i].pv);
                _rProp[i].pv = NULL;
            }
        }
    }
}


// ---------------------------------------------------------------------------
// CPropertyArray::Set
// ---------------------------------------------------------------------------
HRESULT CPropertyArray::Set(DWORD PropertyId, 
    LPVOID pvProperty, DWORD cbProperty)
{
    HRESULT hr = S_OK;
    Property *pItem = NULL;
        
    if (PropertyId >= ASM_NAME_MAX_PARAMS
        || (!pvProperty && cbProperty))
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        goto exit;
    }        

    pItem = &(_rProp[PropertyId]);

    if (!cbProperty && !pvProperty)
    {
        if (pItem->cb > sizeof(DWORD))
        {
            if (pItem->pv != NULL)
                FUSION_DELETE_ARRAY((LPBYTE) pItem->pv);
        }
        pItem->pv = NULL;
    }
    else if (cbProperty > sizeof(DWORD))
    {
        LPBYTE ptr = NEW(BYTE[cbProperty]);
        if (!ptr)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (pItem->cb > sizeof(DWORD))
            FUSION_DELETE_ARRAY((LPBYTE) pItem->pv);

        memcpy(ptr, pvProperty, cbProperty);        
        pItem->pv = ptr;
    }
    else
    {
        if (pItem->cb > sizeof(DWORD))
            FUSION_DELETE_ARRAY((LPBYTE) pItem->pv);

        memcpy(&(pItem->pv), pvProperty, cbProperty);
    }
    pItem->cb = cbProperty;

exit:
    return hr;
}     

// ---------------------------------------------------------------------------
// CPropertyArray::Get
// ---------------------------------------------------------------------------
HRESULT CPropertyArray::Get(DWORD PropertyId, 
    LPVOID pvProperty, LPDWORD pcbProperty)
{
    HRESULT hr = S_OK;
    Property *pItem;    

    ASSERT(pcbProperty);

    if (PropertyId >= ASM_NAME_MAX_PARAMS
        || (!pvProperty && *pcbProperty))
    {
        ASSERT(FALSE);
        hr = E_INVALIDARG;
        goto exit;
    }        

    pItem = &(_rProp[PropertyId]);

    if (pItem->cb > *pcbProperty)
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    else if (pItem->cb)
        memcpy(pvProperty, (pItem->cb > sizeof(DWORD) ? 
            pItem->pv : (LPBYTE) &(pItem->pv)), pItem->cb);

    *pcbProperty = pItem->cb;
        
exit:
    return hr;
}     

// ---------------------------------------------------------------------------
// CPropertyArray::operator []
// Wraps DWORD optimization test.
// ---------------------------------------------------------------------------
Property CPropertyArray::operator [] (DWORD PropertyId)
{
    Property Prop;

    Prop.pv = _rProp[PropertyId].cb > sizeof(DWORD) ?
        _rProp[PropertyId].pv : &(_rProp[PropertyId].pv);

    Prop.cb = _rProp[PropertyId].cb;

    return Prop;
}

// Creation funcs.


// ---------------------------------------------------------------------------
// CreateAssemblyNameObject
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyNameObject(
    LPASSEMBLYNAME    *ppAssemblyName,
    LPCOLESTR          szAssemblyName,
    DWORD              dwFlags,
    LPVOID             pvReserved)
{

    HRESULT hr = S_OK;
    CAssemblyName *pName = NULL;

    if (!ppAssemblyName)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    pName = NEW(CAssemblyName);
    if (!pName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (dwFlags & CANOF_PARSE_DISPLAY_NAME)
    {
        hr = pName->Init(NULL, NULL);
        if (FAILED(hr)) {
            goto exit;
        }

        hr = pName->Parse((LPWSTR)szAssemblyName);
    }
    else
    {
        hr = pName->Init(szAssemblyName, NULL);

        if (dwFlags & CANOF_SET_DEFAULT_VALUES)
        {
            hr = pName->SetDefaults();
        }
    }

    if (FAILED(hr)) 
    {
        SAFERELEASE(pName);
        goto exit;
    }

    *ppAssemblyName = pName;

exit:

    return hr;
}

// ---------------------------------------------------------------------------
// CreateAssemblyNameObjectFromMetaData
// ---------------------------------------------------------------------------

STDAPI
CreateAssemblyNameObjectFromMetaData(
    LPASSEMBLYNAME    *ppAssemblyName,
    LPCOLESTR          szAssemblyName,
    ASSEMBLYMETADATA  *pamd,
    LPVOID             pvReserved)
{

    HRESULT hr = S_OK;
    CAssemblyName *pName = NULL;

    pName = NEW(CAssemblyName);
    if (!pName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pName->Init(szAssemblyName, pamd);
        
    if (FAILED(hr)) 
    {
        SAFERELEASE(pName);
        goto exit;
    }

    *ppAssemblyName = pName;

exit:

    return hr;
}

// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyName::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyName::AddRef()
{
    return InterlockedIncrement((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyName::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyName::Release()
{
    if (InterlockedDecrement((LONG*) &_cRef) == 0) {
        delete this;
        return 0;
    }

    return _cRef;
}

// ---------------------------------------------------------------------------
// CAssemblyName::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::QueryInterface(REFIID riid, void** ppv)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyName)
       )
    {
        *ppv = static_cast<IAssemblyName*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyName::SetProperty
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::SetProperty(DWORD PropertyId, 
    LPVOID pvProperty, DWORD cbProperty)
{
    LPBYTE pbSN = NULL;
    DWORD  cbSN = 0, cbPtr = 0;
    HRESULT hr = S_OK;
    CCriticalSection cs(&_cs);

    // Fail if finalized.
    if (_fIsFinalized)
    {
        hr = E_UNEXPECTED;
        ASSERT(FALSE);
        return hr;
    }

    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }

    // BUGBUG - make this a switch statement.
    // Check if public key is being set and if so,
    // set the public key token if not already set.
    if (PropertyId == ASM_NAME_PUBLIC_KEY)
    {
        // If setting true public key, generate hash.
        if (pvProperty && cbProperty)
        {
            // Generate the public key token from the pk.
            if (FAILED(hr = GetPublicKeyTokenFromPKBlob((LPBYTE) pvProperty, cbProperty, &pbSN, &cbSN)))
                goto exit;

            // Set the public key token property.
            if (FAILED(hr = SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pbSN, cbSN)))
                goto exit;        
        }
        // Otherwise expect call to reset property.
        else if (!cbProperty)
        {
            if (FAILED(hr = SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pvProperty, cbProperty)))
                goto exit;
        }
            
    }
    // Setting NULL public key clears values in public key,
    // public key token and sets public key token flag.
    else if (PropertyId == ASM_NAME_NULL_PUBLIC_KEY)
    {
        pvProperty = NULL;
        cbProperty = 0;
        hr = SetProperty(ASM_NAME_NULL_PUBLIC_KEY_TOKEN, pvProperty, cbProperty);
        goto exit;
    }
    // Setting or clearing public key token.
    else if (PropertyId == ASM_NAME_PUBLIC_KEY_TOKEN)
    {
        if (pvProperty && cbProperty)
            _fPublicKeyToken = TRUE;
        else if (!cbProperty)
            _fPublicKeyToken = FALSE;
    }
    // Setting NULL public key token clears public key token and
    // sets public key token flag.
    else if (PropertyId == ASM_NAME_NULL_PUBLIC_KEY_TOKEN)
    {
        _fPublicKeyToken = TRUE;
        pvProperty = NULL;
        cbProperty = 0;
        PropertyId = ASM_NAME_PUBLIC_KEY_TOKEN;
    }
    else if (PropertyId == ASM_NAME_CUSTOM)
    {
        if (pvProperty && cbProperty)
            _fCustom = TRUE;
        else if (!cbProperty)
            _fCustom = FALSE;
    }
    else if (PropertyId == ASM_NAME_NULL_CUSTOM)
    {
        _fCustom = TRUE;
        pvProperty = NULL;
        cbProperty = 0;
        PropertyId = ASM_NAME_CUSTOM;
    }

    // Setting "netural" as the culture is the same as "" culture (meaning
    // culture-invariant).
    else if (PropertyId == ASM_NAME_CULTURE) {
        if (pvProperty && !FusionCompareStringI((LPWSTR)pvProperty, L"neutral")) {
            pvProperty = (void *)L"";
            cbProperty = sizeof(L"");
        }
    }

    // Set property on array.
    hr = _rProp.Set(PropertyId, pvProperty, cbProperty);

exit:
    // Free memory allocated by crypto wrapper.
    if (pbSN) {
        g_pfnStrongNameFreeBuffer(pbSN);
    }

    cs.Unlock();

    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyName::GetProperty
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetProperty(DWORD PropertyId, 
    LPVOID pvProperty, LPDWORD pcbProperty)
{
    HRESULT hr;
    CCriticalSection cs(&_cs);

    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }

    // Retrieve the property.
    switch(PropertyId)
    {
        case ASM_NAME_NULL_PUBLIC_KEY_TOKEN:
        case ASM_NAME_NULL_PUBLIC_KEY:
        {
            hr = (_fPublicKeyToken && !_rProp[PropertyId].cb) ? S_OK : S_FALSE;
            break;
        }
        case ASM_NAME_NULL_CUSTOM:
        {
            hr = (_fCustom && !_rProp[PropertyId].cb) ? S_OK : S_FALSE;
            break;
        }
        default:        
        {
            hr = _rProp.Get(PropertyId, pvProperty, pcbProperty);
            break;
        }
    }

    cs.Unlock();
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetName
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetName(
        /* [out][in] */ LPDWORD lpcwBuffer,
        /* [out] */     LPOLESTR pwzBuffer)
{
    DWORD cbBuffer = *lpcwBuffer * sizeof(TCHAR);
    HRESULT hr = GetProperty(ASM_NAME_NAME, pwzBuffer, &cbBuffer);
    *lpcwBuffer = cbBuffer / sizeof(TCHAR);
    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyName::GetVersion
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetVersion(
        /* [out] */ LPDWORD pdwVersionHi,
        /* [out] */ LPDWORD pdwVersionLow)
{
    // Get Assembly Version
    return GetVersion( ASM_NAME_MAJOR_VERSION, pdwVersionHi, pdwVersionLow);
}


// ---------------------------------------------------------------------------
// CAssemblyName::GetVersion
// ---------------------------------------------------------------------------
HRESULT
CAssemblyName::GetVersion(
        /* [in]  */ DWORD   dwMajorVersionEnumValue,
        /* [out] */ LPDWORD pdwVersionHi,
        /* [out] */ LPDWORD pdwVersionLow)
{
    DWORD cb = sizeof(WORD);
    WORD wVerMajor = 0, wVerMinor = 0, wRevNo = 0, wBldNo = 0;
    
    ASSERT(pdwVersionHi);
    ASSERT(pdwVersionLow);

    GetProperty(dwMajorVersionEnumValue,   &wVerMajor, &(cb = sizeof(WORD)));
    GetProperty(dwMajorVersionEnumValue+1,   &wVerMinor, &(cb = sizeof(WORD)));
    GetProperty(dwMajorVersionEnumValue+2,    &wBldNo,    &(cb = sizeof(WORD)));
    GetProperty(dwMajorVersionEnumValue+3, &wRevNo,    &(cb = sizeof(WORD)));

    *pdwVersionHi  = MAKELONG(wVerMinor, wVerMajor);
    *pdwVersionLow = MAKELONG(wRevNo, wBldNo);

    return S_OK;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetFileVersion
// ---------------------------------------------------------------------------
HRESULT
CAssemblyName::GetFileVersion(
        /* [out] */ LPDWORD pdwVersionHi,
        /* [out] */ LPDWORD pdwVersionLow)
{
    return GetVersion( ASM_NAME_FILE_MAJOR_VERSION, pdwVersionHi, pdwVersionLow);
}

// ---------------------------------------------------------------------------
// CAssemblyName::IsEqual
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::IsEqual(LPASSEMBLYNAME pName, DWORD dwCmpFlags)
{
    return IsEqualLogging(pName, dwCmpFlags, NULL);
}

STDMETHODIMP
CAssemblyName::IsEqualLogging(LPASSEMBLYNAME pName, DWORD dwCmpFlags, CDebugLog *pdbglog)
{
    HRESULT hr = S_OK;
    TCHAR szName[MAX_CLASS_NAME], *pszName;
    WCHAR szCulture[MAX_PATH];
    DWORD cbName = MAX_CLASS_NAME, cbWord = sizeof(WORD);
    WORD wMajor = 0, wMinor = 0, wRev = 0, wBuild = 0;
    BYTE bPublicKeyToken[MAX_PUBLIC_KEY_TOKEN_LEN];
    DWORD dwPublicKeyToken = MAX_PUBLIC_KEY_TOKEN_LEN;
    DWORD cbCulture = MAX_PATH;
    LPBYTE pbPublicKeyToken, pbCustom;
    DWORD dwPartialCmpMask = 0;
    BOOL  fIsPartial = FALSE;
    
    const DWORD SIMPLE_VERSION_MASK = 
        ASM_CMPF_MAJOR_VERSION
            | ASM_CMPF_MINOR_VERSION
            | ASM_CMPF_REVISION_NUMBER
            | ASM_CMPF_BUILD_NUMBER;

    Property *pPropName        = &(_rProp[ASM_NAME_NAME]);
    Property *pPropPublicKeyToken  = &(_rProp[ASM_NAME_PUBLIC_KEY_TOKEN]);
    Property *pPropMajor       = &(_rProp[ASM_NAME_MAJOR_VERSION]);
    Property *pPropMinor       = &(_rProp[ASM_NAME_MINOR_VERSION]);
    Property *pPropRev         = &(_rProp[ASM_NAME_REVISION_NUMBER]);
    Property *pPropBuild       = &(_rProp[ASM_NAME_BUILD_NUMBER]);
    Property *pPropCulture     = &(_rProp[ASM_NAME_CULTURE]);
    Property *pPropCustom      = &(_rProp[ASM_NAME_CUSTOM]);
    Property *pPropRetarget    = &(_rProp[ASM_NAME_RETARGET]);

    // Get the ref partial comparison mask, if any.    
    fIsPartial = CAssemblyName::IsPartial(this, &dwPartialCmpMask);

    // If default semantics are requested.
    if (dwCmpFlags == ASM_CMPF_DEFAULT) 
    {
        // Set all comparison flags.
        dwCmpFlags = ASM_CMPF_ALL;

        // we don't want to compare retarget flag by default
        dwCmpFlags &= ~ASM_CMPF_RETARGET;

        // Otherwise, if ref is simple (possibly partial)
        // we mask off all version bits.
        if (!CCache::IsStronglyNamed(this)) 
        {

            if (dwPartialCmpMask & ASM_CMPF_PUBLIC_KEY_TOKEN)
            {
                dwCmpFlags &= ~SIMPLE_VERSION_MASK;
            }
            // If neither of these two cases then public key token
            // is not set in ref , but def may be simple or strong.
            // The comparison mask is chosen based on def.
            else
            {
                if (!CCache::IsStronglyNamed(pName))
                    dwCmpFlags &= ~SIMPLE_VERSION_MASK;            
            }
        }
    }   

    // Mask off flags (either passed in or generated
    // by default flag with the comparison mask generated 
    // from the ref.
    if (fIsPartial)
        dwCmpFlags &= dwPartialCmpMask;

    
    // The individual name fields can now be compared..

    // Compare name

    if (dwCmpFlags & ASM_CMPF_NAME) {
        pszName = (LPTSTR) pPropName->pv;
            
        hr = pName->GetName(&cbName, szName);
    
        if (FAILED(hr)) {
            goto Exit;
        }

        cbName *= sizeof(TCHAR);

        if (cbName != pPropName->cb) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_NAME);
            hr = S_FALSE;
            goto Exit;
        }
    
        if (cbName && FusionCompareStringI(pszName, szName)) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_NAME);
            hr = S_FALSE;
            goto Exit;
        }
    }

    // Compare version

    if (dwCmpFlags & ASM_CMPF_MAJOR_VERSION) {
        if (FAILED(hr = pName->GetProperty(ASM_NAME_MAJOR_VERSION, &wMajor, &cbWord)))
        {
            goto Exit;
        }
    
        if (*((LPWORD) pPropMajor->pv) != wMajor)
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_VERSION_MAJOR);
            hr = S_FALSE;
            goto Exit;
        }
    }

    if (dwCmpFlags & ASM_CMPF_MINOR_VERSION) {
        if (FAILED(hr = pName->GetProperty(ASM_NAME_MINOR_VERSION, &wMinor, &cbWord)))
        {
            goto Exit;
        }
        if (*((LPWORD) pPropMinor->pv) != wMinor)
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_VERSION_MINOR);
            hr = S_FALSE;
            goto Exit;
        }
    }

    if (dwCmpFlags & ASM_CMPF_REVISION_NUMBER) {
        if (FAILED(hr = pName->GetProperty(ASM_NAME_REVISION_NUMBER, &wRev, &cbWord)))
        {
            goto Exit;
        }
            
        if (*((LPWORD) pPropRev->pv) != wRev)
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_VERSION_REVISION);
            hr = S_FALSE;
            goto Exit;
        }
    }

    if (dwCmpFlags & ASM_CMPF_BUILD_NUMBER) {
        if (FAILED(hr = pName->GetProperty(ASM_NAME_BUILD_NUMBER, &wBuild, &cbWord)))
        {
            goto Exit;
        }

        if (*((LPWORD) pPropBuild->pv) != wBuild)
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_VERSION_BUILD);
            hr = S_FALSE;
            goto Exit;
        }
    }


    // Compare public key token

    if (dwCmpFlags & ASM_CMPF_PUBLIC_KEY_TOKEN) {
        pbPublicKeyToken = (LPBYTE) pPropPublicKeyToken->pv;

    
        hr = pName->GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, (void *)bPublicKeyToken,
                                &dwPublicKeyToken);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        if (dwPublicKeyToken != pPropPublicKeyToken->cb) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_PUBLIC_KEY_TOKEN);
            hr = S_FALSE;
            goto Exit; 
        }

        if (memcmp((void *)bPublicKeyToken, pbPublicKeyToken, dwPublicKeyToken)) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_PUBLIC_KEY_TOKEN);
            hr = S_FALSE;
            goto Exit;
        }
    }

    // Compare Culture
    
    if (dwCmpFlags & ASM_CMPF_CULTURE)
    {
        LPWSTR szCultureThis;
        DWORD cbCultureThis;
        
        if (FAILED(hr = pName->GetProperty(ASM_NAME_CULTURE, szCulture, &cbCulture)))
            goto Exit;
            
        cbCultureThis = pPropCulture->cb;
        szCultureThis = (WCHAR*) (pPropCulture->pv);

        if (!(cbCultureThis && cbCulture)
            || (cbCultureThis != cbCulture)
            || (FusionCompareStringI(szCultureThis, szCulture)))
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_CULTURE);
            hr = S_FALSE;
            goto Exit;
        }
        
    }

    // Compare Custom attribute.

    if (dwCmpFlags & ASM_CMPF_CUSTOM) 
    {
        LPBYTE bCustom; bCustom = NULL;
        DWORD cbCustom; cbCustom = 0;
        
        pbCustom = (LPBYTE) pPropCustom->pv;

        hr = pName->GetProperty(ASM_NAME_CUSTOM, (void *)bCustom, &cbCustom);

        if (hr != S_OK && hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            goto Exit;
    
        if (cbCustom)
        {
            bCustom = NEW(BYTE[cbCustom]);
            if (!bCustom)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            if (FAILED(hr = pName->GetProperty(ASM_NAME_CUSTOM, (void *)bCustom, &cbCustom))) {
                SAFEDELETEARRAY(bCustom);
                goto Exit;
            }
        }
                
        if (cbCustom != pPropCustom->cb) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_CUSTOM);
            hr = S_FALSE;
            SAFEDELETEARRAY(bCustom);
            goto Exit; 
        }

        if (memcmp((void *)bCustom, pbCustom, cbCustom)) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_CUSTOM);
            SAFEDELETEARRAY(bCustom);
            hr = S_FALSE;
            goto Exit;
        }

        SAFEDELETEARRAY(bCustom);
    }

    // Compare Retarget flag
    if (dwCmpFlags & ASM_CMPF_RETARGET)
    {
        BOOL fRetarget = FALSE;
        DWORD cbRetarget = sizeof(BOOL);

        hr = pName->GetProperty(ASM_NAME_RETARGET, &fRetarget, &cbRetarget);
        if (FAILED(hr))
        {
            goto Exit;
        }

        if ( (cbRetarget != pPropRetarget->cb) 
           || (pPropRetarget->pv && *((LPBOOL)pPropRetarget->pv) != fRetarget))
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_ISEQUAL_DIFF_RETARGET);
            hr = S_FALSE;
            goto Exit;
        }
    }

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName constructor
// ---------------------------------------------------------------------------
CAssemblyName::CAssemblyName()
{
    _dwSig              = 'EMAN';
    _fIsFinalized       = FALSE;
    _fPublicKeyToken    = FALSE;
    _fCustom            = TRUE;
    _cRef               = 0;
    _fCSInitialized     = FALSE;
}

// ---------------------------------------------------------------------------
// CAssemblyName destructor
// ---------------------------------------------------------------------------
CAssemblyName::~CAssemblyName()
{
    if (_fCSInitialized) {
        DeleteCriticalSection(&_cs);
    }
}

// ---------------------------------------------------------------------------
// CAssemblyName::Init
// ---------------------------------------------------------------------------

HRESULT
CAssemblyName::Init(LPCTSTR pszAssemblyName, ASSEMBLYMETADATA *pamd)
{
    HRESULT hr = S_OK;

    __try {
        InitializeCriticalSection(&_cs);
        _fCSInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Name
    if (pszAssemblyName) 
    {
        hr = SetProperty(ASM_NAME_NAME, (LPTSTR) pszAssemblyName, 
            (lstrlen(pszAssemblyName)+1) * sizeof(TCHAR));

        if (FAILED(hr))
            goto exit;
    }
           
    if (pamd) {
            // Major version
        if (FAILED(hr = SetProperty(ASM_NAME_MAJOR_VERSION,
                &pamd->usMajorVersion, sizeof(WORD)))
    
            // Minor version
            || FAILED(hr = SetProperty(ASM_NAME_MINOR_VERSION, 
                &pamd->usMinorVersion, sizeof(WORD)))
    
            // Revision number
            || FAILED(hr = SetProperty(ASM_NAME_REVISION_NUMBER, 
                &pamd->usRevisionNumber, sizeof(WORD)))
    
            // Build number
            || FAILED(hr = SetProperty(ASM_NAME_BUILD_NUMBER, 
                &pamd->usBuildNumber, sizeof(WORD)))
    
            // Culture
            || FAILED(hr = SetProperty(ASM_NAME_CULTURE,
                pamd->szLocale, pamd->cbLocale * sizeof(WCHAR)))
    
            // Processor id array
            || FAILED(hr = SetProperty(ASM_NAME_PROCESSOR_ID_ARRAY, 
                pamd->rProcessor, pamd->ulProcessor * sizeof(DWORD)))
    
            // OSINFO array
            || FAILED (hr = SetProperty(ASM_NAME_OSINFO_ARRAY, 
                pamd->rOS, pamd->ulOS * sizeof(OSINFO)))
    
            )
            {
                goto exit;
            }
        
    }

exit:
    _cRef = 1;
    return hr;
}

HRESULT CAssemblyName::Clone(IAssemblyName **ppName)
{
    HRESULT         hr = S_OK;
    CAssemblyName*  pClone = NULL;
    DWORD           i = 0;
    LPVOID          pv = NULL;
    DWORD           dwSize = 0;

    if (!ppName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppName = NULL;

    pClone = NEW(CAssemblyName);
    if( !pClone ) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pClone->Init(NULL, NULL);
    if (FAILED(hr)) {
        goto Exit;
    }

    for( i = 0; i < ASM_NAME_MAX_PARAMS; i ++)
    {
        // get size
        if( (hr = GetProperty(i, NULL, &dwSize)) == 
                HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            // Allocate space 
            pv = NEW(BYTE[dwSize]);
            if (!pv ) {
                hr = E_OUTOFMEMORY;
                goto fail;
            }

            // Retrieve 
            if (FAILED(hr = GetProperty(i, pv, &dwSize)))
                goto fail;         

            // Set
            if (FAILED(hr = pClone->SetProperty(i, pv, dwSize)))
                goto fail;
        }
        else if (FAILED(hr))
        {
            goto fail;
        }

        // reinit for next property
        FUSION_DELETE_ARRAY((LPBYTE) pv);
        pv = NULL;
        dwSize = 0;
    }
    
    pClone->_fPublicKeyToken = _fPublicKeyToken;
    pClone->_fCustom = _fCustom;
    
    // done
    goto Exit; 

fail:
    // if we failed for whatever reason
    FUSION_DELETE_ARRAY((LPBYTE) pv);
    SAFERELEASE(pClone);

Exit:
    if (SUCCEEDED(hr))
    {
        *ppName = pClone;
        if (*ppName) 
        {
            (*ppName)->AddRef();
        }
    }

    SAFERELEASE(pClone);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::BindToObject
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::BindToObject(
        /* in      */  REFIID               refIID,
        /* in      */  IUnknown            *pUnkBindSink,
        /* in      */  IUnknown            *pUnkAppCtx,
        /* in      */  LPCOLESTR            szCodebaseIn,
        /* in      */  LONGLONG             llFlags,
        /* in      */  LPVOID               pvReserved,
        /* in      */  DWORD                cbReserved,
        /*     out */  VOID               **ppv)

{
    HRESULT                                    hr = S_OK;
    LPWSTR                                     szCodebaseDupe = NULL;
    LPWSTR                                     szCodebase = NULL;
    ICodebaseList                             *pCodebaseList = NULL;
    DWORD                                      dwSize = 0;
    CDebugLog                                 *pdbglog = NULL;
    IAssemblyBindSink                         *pAsmBindSink = NULL;
    IApplicationContext                       *pAppCtx = NULL;
    CAsmDownloadMgr                           *pDLMgr = NULL;
    CAssemblyDownload                         *padl = NULL;
    CApplicationContext                       *pCAppCtx = NULL;
    LPWSTR                                     pwzAsmName;

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
    AppCfgDownloadInfo                        *pdlinfo = NULL;
#endif

    if (!ppv || !pUnkAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (szCodebaseIn) {
        szCodebaseDupe = WSTRDupDynamic(szCodebaseIn);
        if (!szCodebaseDupe) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    hr = pUnkAppCtx->QueryInterface(IID_IApplicationContext, (void**)&pAppCtx);
    if (FAILED(hr)) {
        goto Exit;
    }

    pCAppCtx = dynamic_cast<CApplicationContext *>(pAppCtx);
    if (!pCAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = pUnkBindSink->QueryInterface(IID_IAssemblyBindSink, (void **)&pAsmBindSink);
    if (FAILED(hr)) {
        goto Exit;
    }

    pwzAsmName = (LPWSTR)(_rProp[ASM_NAME_NAME].pv);
    if (pwzAsmName) {
        LPWSTR                    pwzPart = NULL;

        if (lstrlenW(pwzAsmName) >= MAX_PATH) {
            // Name is too long.
            hr = FUSION_E_INVALID_NAME;
            goto Exit;
        }

        pwzPart = NEW(WCHAR[MAX_URL_LENGTH]);
        if (!pwzPart) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        dwSize = MAX_URL_LENGTH;
        hr = UrlGetPartW(pwzAsmName, pwzPart, &dwSize, URL_PART_SCHEME, 0);
        if (SUCCEEDED(hr) && lstrlenW(pwzPart)) {
            // The assembly name looks like a protocol (ie. it starts with
            // the form protocol:// ). Abort binds in this case.

            hr = FUSION_E_INVALID_NAME;
            SAFEDELETEARRAY(pwzPart);
            goto Exit;
        }

        SAFEDELETEARRAY(pwzPart);
    }

    if (szCodebaseDupe) {
        szCodebase = StripFilePrefix((LPWSTR)szCodebaseDupe);
    }

#ifdef FUSION_RETAIL_LOGGING
    {
        IAssemblyName      *pNameCalling = NULL;
        IAssembly          *pAsmCalling = NULL;
        LPWSTR              pwzCallingAsm = NULL;
        DWORD               dw;

        pwzCallingAsm = NEW(WCHAR[MAX_URL_LENGTH]);
        if (!pwzCallingAsm) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        lstrcpyW(pwzCallingAsm, L"(Unknown)");
    
        if (pvReserved && (llFlags & ASM_BINDF_PARENT_ASM_HINT)) {
            pAsmCalling = (IAssembly *)pvReserved;

            if (pAsmCalling->GetAssemblyNameDef(&pNameCalling) == S_OK) {
                dw = MAX_URL_LENGTH;
                pNameCalling->GetDisplayName(pwzCallingAsm, &dw, 0);
            }

            SAFERELEASE(pNameCalling);
        }

        CreateLogObject(&pdbglog, szCodebase, pAppCtx);
        DescribeBindInfo(pdbglog, pAppCtx, szCodebase, pwzCallingAsm);

        SAFEDELETEARRAY(pwzCallingAsm);
    }
#endif

    *ppv = NULL;

    // Handle dev-path special case

    if (!CCache::IsCustom(this)) {
        CAssembly            *pCAsmParent = NULL;

        if (pvReserved && (llFlags & ASM_BINDF_PARENT_ASM_HINT)) {
            IAssembly *pAsmParent = static_cast<IAssembly *>(pvReserved);
            pCAsmParent = dynamic_cast<CAssembly *>(pAsmParent);

            ASSERT(pCAsmParent);
        }

        hr = ProcessDevPath(pAppCtx, ppv, pCAsmParent, pdbglog);
        if (hr == S_OK) {
            // Found match in dev path. Succeed immediately.
            ASSERT(ppv);
            goto Exit;
        }
    }
    else {
        DEBUGOUT(pdbglog, 1, ID_FUSLOG_DEVPATH_NO_PREJIT);
    }

    // Setup policy cache in appctx

    hr = PreparePolicyCache(pAppCtx, NULL);
    if (FAILED(hr)) {
        DEBUGOUT(pdbglog, 1, ID_FUSLOG_POLICY_CACHE_FAILURE);
    }


    // Create download objects for the real assembly download
    hr = CAsmDownloadMgr::Create(&pDLMgr, this, pAppCtx, pCodebaseList,
                                 (szCodebase) ? (szCodebase) : (NULL),
                                 pdbglog, pvReserved, llFlags);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    hr = CAssemblyDownload::Create(&padl, pDLMgr, pDLMgr, pdbglog, llFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Download app.cfg if we don't already have it

    hr = pCAppCtx->Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = 0;
    hr = pAppCtx->Get(ACTAG_APP_CFG_DOWNLOAD_ATTEMPTED, NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
        // If we don't have the app.cfg, we either need to download it,
        // or it's already being downloaded, and we should piggyback

        dwSize = sizeof(AppCfgDownloadInfo *);
        hr = pAppCtx->Get(ACTAG_APP_CFG_DOWNLOAD_INFO, &pdlinfo, &dwSize, 0);
        if (hr == S_OK) {
            DEBUGOUT(pdbglog, 1, ID_FUSLOG_APP_CFG_PIGGYBACK);

            hr = padl->AddClient(pAsmBindSink, TRUE);
            if (FAILED(hr)) {
                pCAppCtx->Unlock();
                goto Exit;
            }

            hr = (pdlinfo->_pHook)->AddClient(padl);
            if (SUCCEEDED(hr)) {
                hr = E_PENDING;
            }
            else {
                pCAppCtx->Unlock();
                goto Exit;
            }
        }
        else {
#endif
            hr = CCache::IsCustom(this) ? S_FALSE : 
                DownloadAppCfg(pAppCtx, padl, pAsmBindSink, pdbglog, TRUE);
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
        }
#endif
    }
    else {
        hr = S_OK;
    }

    pCAppCtx->Unlock();

    // If hr==S_OK, then we either had an app.cfg already, or
    // it was on the local hard disk.
    //
    // If hr==S_FALSE, then no app.cfg exists, continue regular download
    //
    // If hr==E_PENDING, then went async.

    if (SUCCEEDED(hr)) {
        hr = padl->PreDownload(FALSE, ppv);

        if (hr == S_OK) {
            hr = padl->AddClient(pAsmBindSink, TRUE);
            if (FAILED(hr)) {
                ASSERT(0);
                SAFERELEASE(pDLMgr);
                SAFERELEASE(padl);
                goto Exit;
            }

            hr = padl->KickOffDownload(TRUE);
        }
        else if (hr == S_FALSE) {
            // Completed synchronously
            hr = S_OK;
        }

    }

Exit:
    if (hr != E_PENDING && (g_dwForceLog || (FAILED(hr) && pDLMgr && pDLMgr->LogResult() == S_OK))) {
        DUMPDEBUGLOG(pdbglog, g_dwLogLevel, hr);
    }

    SAFERELEASE(pDLMgr);
    SAFERELEASE(padl);
    SAFERELEASE(pdbglog);

    SAFERELEASE(pAsmBindSink);
    SAFERELEASE(pAppCtx);

    SAFEDELETEARRAY(szCodebaseDupe);

    return hr;
}

HRESULT CAssemblyName::CreateLogObject(CDebugLog **ppdbglog, LPCWSTR szCodebase,
                                       IApplicationContext *pAppCtx)
{
    HRESULT                                    hr = S_OK;
    LPWSTR                                     pwzAsmName = NULL;
    LPWSTR                                     wzBuf=NULL;
    DWORD                                      dwSize;
    
    dwSize = 0;
    hr = GetDisplayName(NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        pwzAsmName = NEW(WCHAR[dwSize]);
        if (!pwzAsmName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        hr = GetDisplayName(pwzAsmName, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    
    }
    else if (szCodebase) {
        // Can't get display name. Could be a where-ref bind. Use the URL.
        wzBuf = NEW(WCHAR[MAX_URL_LENGTH+1]);
        if (!wzBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        wzBuf[0] = L'\0';
        dwSize = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(szCodebase, wzBuf, &dwSize, 0);
        if (SUCCEEDED(hr)) {
            pwzAsmName = NEW(WCHAR[dwSize + 1]);
            if (!pwzAsmName) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            
            lstrcpyW(pwzAsmName, wzBuf);
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr)) {
        hr = CDebugLog::Create(pAppCtx, pwzAsmName, ppdbglog);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(pwzAsmName);
    SAFEDELETEARRAY(wzBuf);
    return hr;
}

HRESULT CAssemblyName::DescribeBindInfo(CDebugLog *pdbglog,
                                        IApplicationContext *pAppCtx,
                                        LPCWSTR wzCodebase,
                                        LPCWSTR pwzCallingAsm)
{
    HRESULT                                     hr = S_OK;
    DWORD                                       dwSize;
    LPWSTR                                      wzName = NULL;
    LPWSTR                                      wzAppName = NULL;
    LPWSTR                                      wzAppBase = NULL;
    LPWSTR                                      wzPrivatePath = NULL;
    LPWSTR                                      wzCacheBase = NULL;
    LPWSTR                                      wzDynamicBase = NULL;
    LPWSTR                                      wzDevPath = NULL;
    Property                                   *pPropName = &(_rProp[ASM_NAME_NAME]);

    if (!pdbglog || !pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    DEBUGOUT(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_START);

    if (pPropName->cb) {
        // This is not a where-ref bind.
        dwSize = 0;
        GetDisplayName(NULL, &dwSize, 0);

        wzName = NEW(WCHAR[dwSize + 1]);
        if (!wzName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = GetDisplayName(wzName, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }

        DEBUGOUT2(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_DISPLAY_NAME, wzName, (IsPartial(this, 0)) ? (L"Partial") : (L"Fully-specified"));
    }
    else {
        ASSERT(wzCodebase);

        DEBUGOUT1(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_WHERE_REF, wzCodebase);
    }

    // appbase

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_BASE_URL, &wzAppBase);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!wzAppBase) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto Exit;
    }

    DEBUGOUT1(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_APPBASE, wzAppBase);

    // devpath

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_DEV_PATH, &wzDevPath);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (wzDevPath) {
        DEBUGOUT1(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_DEVPATH, (wzDevPath) ? (wzDevPath) : (L"NULL"));
    }

    // private path

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_PRIVATE_BINPATH, &wzPrivatePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    DEBUGOUT1(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_PRIVATE_PATH, (wzPrivatePath) ? (wzPrivatePath) : (L"NULL"));

    // dynamic base

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_DYNAMIC_BASE, &wzDynamicBase);
    if (FAILED(hr)) {
        goto Exit;
    }

    DEBUGOUT1(pdbglog, 1, ID_FUSLOG_PREBIND_INFO_DYNAMIC_BASE, (wzDynamicBase) ? (wzDynamicBase) : (L"NULL"));

    // cache base

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_CACHE_BASE, &wzCacheBase);
    if (FAILED(hr)) {
        goto Exit;
    }

    DEBUGOUT1(pdbglog, 1, ID_FUSLOG_PREBIND_INFO_CACHE_BASE, (wzCacheBase) ? (wzCacheBase) : (L"NULL"));

    // App name

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_NAME, &wzAppName);
    if (FAILED(hr)) {
        goto Exit;
    }

    DEBUGOUT1(pdbglog, 1, ID_FUSLOG_PREBIND_INFO_APP_NAME, (wzAppName) ? (wzAppName) : (L"NULL"));

    // Calling assembly

    DEBUGOUT1(pdbglog, 0, ID_FUSLOG_CALLING_ASSEMBLY, ((pwzCallingAsm) ? (pwzCallingAsm) : L"(Unknown)"));

    // Output debug info trailer

    DEBUGOUT(pdbglog, 0, ID_FUSLOG_PREBIND_INFO_END);


Exit:
    SAFEDELETEARRAY(wzName);
    SAFEDELETEARRAY(wzAppBase);
    SAFEDELETEARRAY(wzPrivatePath);
    SAFEDELETEARRAY(wzDynamicBase);
    SAFEDELETEARRAY(wzCacheBase);
    SAFEDELETEARRAY(wzAppName);
    SAFEDELETEARRAY(wzDevPath);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::Finalize
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::Finalize()
{
    _fIsFinalized = TRUE;
    return S_OK;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetDisplayName
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetDisplayName(LPOLESTR szDisplayName, 
    LPDWORD pccDisplayName, DWORD dwDisplayFlags)
{
    HRESULT hr;

    WORD wVer;

    DWORD ccBuf, cbTmp, i, ccVersion, 
        cbCulture, ccCulture, ccProp;

    WCHAR *pszBuf = NULL, *pszName = NULL, *szProp = NULL,
        szVersion[MAX_VERSION_DISPLAY_SIZE + 1], *szCulture = NULL;

    LPBYTE pbProp = NULL;   

    if (!dwDisplayFlags)
        dwDisplayFlags = 
              ASM_DISPLAYF_VERSION 
            | ASM_DISPLAYF_CULTURE 
            | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
            | ASM_DISPLAYF_RETARGET
            ;

    // Reference internal name, strong name, public key and custom.
    Property *pPropName = &(_rProp[ASM_NAME_NAME]);
    Property *pPropSN   = &(_rProp[ASM_NAME_PUBLIC_KEY_TOKEN]);
    Property *pPropPK   = &(_rProp[ASM_NAME_PUBLIC_KEY]);
    Property *pPropCustom   = &(_rProp[ASM_NAME_CUSTOM]);

   Property *pPropRetarget = &(_rProp[ASM_NAME_RETARGET]);
    BOOL fRetarget = FALSE;

    // Validate input buffer.
    if (!pccDisplayName || (!szDisplayName && *pccDisplayName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pszBuf = szDisplayName;
    ccBuf = 0;

    // Name required
    if (!pPropName->cb)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Reference name.
    pszName = (LPWSTR) pPropName->pv;

    // Output name.
    if (FAILED(hr = CParseUtils::SetKey(pszBuf, &ccBuf, 
        pszName, *pccDisplayName, NULL)))
        goto exit;
    
    // Output version if extant.
    if (dwDisplayFlags & ASM_DISPLAYF_VERSION)
    {
        // Convert versions to a.b.c.d format.
        ccVersion = 0;
        for (i = 0; i < 4; i++)
        {
            // Get the version.
            if (FAILED(hr=GetProperty(ASM_NAME_MAJOR_VERSION + i, 
                &wVer, &(cbTmp = sizeof(WORD)))))
                goto exit;

            // No version -> we're done.
            if (!cbTmp)
                break;

            // Print to buf.        
            ccVersion += wnsprintf(szVersion + ccVersion, 
                MAX_VERSION_DISPLAY_SIZE - ccVersion + 1, L"%hu.", wVer);
        }
   
        // Output version.
        if (ccVersion)
        {
            // Remove last '.' printed in above loop.
            szVersion[ccVersion-1] = L'\0';
            if (FAILED(hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, L"Version",
                szVersion, *pccDisplayName, FLAG_DELIMIT)))
                goto exit;
        }
    }

    // Display culture
    if (dwDisplayFlags & ASM_DISPLAYF_CULTURE)
    {
        hr = GetProperty(ASM_NAME_CULTURE, NULL, &(cbCulture = 0));

        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            ccCulture = cbCulture / sizeof(WCHAR);
            szCulture = NEW(WCHAR[ccCulture]);
            if (!szCulture)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Retrieve the Culture.
            if (FAILED(hr = GetProperty(ASM_NAME_CULTURE, szCulture, &cbCulture)))
                goto exit;         

            // Output.
            if (FAILED(hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, L"Culture",
                (cbCulture && !*szCulture) ? L"neutral" : szCulture,
                *pccDisplayName, FLAG_DELIMIT)))
                goto exit;
        }
        else if (hr != S_OK) 
        {
            // Unexpected error.
            goto exit;
        }    
    }
    
    // Output public key and/or public key token
    for (i = 0; i < 2; i++)
    {
        if ((i == 0 && !(dwDisplayFlags & ASM_DISPLAYF_PUBLIC_KEY_TOKEN))
            || (i == 1 && !(dwDisplayFlags & ASM_DISPLAYF_PUBLIC_KEY)))
            continue;
            
        Property *pProp;
        pProp = (!i ? pPropSN : pPropPK);
    
        if (pProp->cb)
        {        
            // Reference the value
            pbProp = (LPBYTE) pProp->pv;

            // Encode to hex in unicode - string
            // is twice as long + null terminator.
            ccProp = 2 * pProp->cb; 
            szProp = NEW(WCHAR[ccProp+1]);
            if (!szProp)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Convert to unicode.
            CParseUtils::BinToUnicodeHex(pbProp, pProp->cb, szProp);
            szProp[ccProp] = L'\0';
        
            // Output property.
            if (FAILED(hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, 
                (!i ? L"PublicKeyToken" : L"PublicKey") , szProp, *pccDisplayName, FLAG_DELIMIT)))
                goto exit;

            SAFEDELETEARRAY(szProp);
        }
        else if (_fPublicKeyToken)
        {
            // Output property.
            if (FAILED(hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, 
                (!i ? L"PublicKeyToken" : L"PublicKey") , L"null", *pccDisplayName, FLAG_DELIMIT)))
                goto exit;
        }
            
        SAFEDELETEARRAY(szProp);
    }

    // Output custom property.
    if (dwDisplayFlags & ASM_DISPLAYF_CUSTOM)
    {
        if (pPropCustom->cb)
        {
            // Reference the value
            pbProp = (LPBYTE) pPropCustom->pv;
    
            // Encode to hex in unicode - string
            // is twice as long + null terminator.
            ccProp = 2 * pPropCustom->cb; 
            szProp = NEW(WCHAR[ccProp+1]);
            if (!szProp)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
    
            // Convert to unicode.
            CParseUtils::BinToUnicodeHex(pbProp, pPropCustom->cb, szProp);
            szProp[ccProp] = L'\0';
        
            // Output property.
            if (FAILED(hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, 
                L"Custom", szProp, *pccDisplayName, FLAG_DELIMIT)))
                goto exit;

            SAFEDELETEARRAY(szProp);
        }
        else if (_fCustom)
        {
            // Output property.
            if (FAILED(hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, 
                L"Custom", L"null", *pccDisplayName, FLAG_DELIMIT)))
                goto exit;
        }
    }

    // output retarget flag
    if (dwDisplayFlags & ASM_DISPLAYF_RETARGET)
    {
        if (pPropRetarget->cb)
        {
            ccProp = sizeof(BOOL);
            hr =  GetProperty(ASM_NAME_RETARGET, &fRetarget, &ccProp);
            if (FAILED(hr))
                goto exit;
            hr = CParseUtils::SetKeyValuePair(pszBuf, &ccBuf, L"Retargetable", 
                    fRetarget ? L"Yes" : L"No", *pccDisplayName, FLAG_DELIMIT);
            if (FAILED(hr))
                goto exit;
        }
    }
    
    // If we came in under buffer size null terminate.
    // otherwise ccBuf contains required buffer size.
    if (ccBuf < *pccDisplayName)
    {
        pszBuf[ccBuf] = L'\0';
        hr = S_OK;
    }
    // Indicate to caller.
    else
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        
    // In either case indicate required size.
    *pccDisplayName = ccBuf+1;

exit:

    SAFEDELETEARRAY(szProp);
    SAFEDELETEARRAY(szCulture);
        
    return hr;
}

// ---------------------- Private funcs --------------------------------------

//--------------------------------------------------------------------
// Parse
//   Parses ASSEMBLYMETADATA and text name from simple string rep.
//--------------------------------------------------------------------
HRESULT CAssemblyName::Parse(LPWSTR szDisplayName)
{
    HRESULT hr;
    
    WCHAR *szBuffer = NULL, *pszBuf, *pszToken, *pszKey, *pszValue, *pszProp,
        *pszName = NULL, *pszVersion = NULL, *pszFileVersion = NULL, *pszPK = NULL, *pszSN = NULL,
        *pszCulture = NULL, *pszRef = NULL, *pszDef = NULL, *pszCustom = NULL, *pszRetarget = NULL;

    DWORD ccBuffer, ccKey, ccValue, ccBuf, ccToken, ccProp,
        ccName = 0, ccVersion = 0, ccFileVersion = 0, ccPK = 0, ccSN = 0, 
        ccCulture = 0, ccRef = 0, ccDef = 0, ccCustom = 0, ccRetarget = 0;
        
    WORD wVer[4] = {0,0,0,0};
    WORD wFileVer[4] = {0,0,0,0};
    
    BOOL fRetarget = FALSE;
    DWORD i=0, dwCountOfAssemblyVers=0, dwCountOfFileVers = 0;
    
    DWORD cbProp;
    BYTE *pbProp = NULL;
    
    // Verify display name passed in.
    if (!(szDisplayName && *szDisplayName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Make local copy for parsing.
    ccBuffer = lstrlen(szDisplayName) + 1;
    szBuffer = NEW(WCHAR[ccBuffer]);
    if (!szBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(szBuffer, szDisplayName, ccBuffer * sizeof(WCHAR));

    // Begin parsing buffer.
    pszBuf = szBuffer;
    ccBuf = ccBuffer;
    
    // Get first comma or NULL delimited token.
    if (!CParseUtils::GetDelimitedToken(&pszBuf, &ccBuf, &pszToken, &ccToken, L','))
    {
        hr = FUSION_E_INVALID_NAME;
        goto exit;
    }
    
    // Point to name and 0 terminate.
    pszName = pszToken;
    ccName = ccToken;
    *(pszName + ccName) = L'\0';

    // Get additional params. 
    while (CParseUtils::GetDelimitedToken(&pszBuf, &ccBuf, &pszToken, &ccToken, L','))
    {
        // Parse key=vaue form
        if (CParseUtils::GetKeyValuePair(pszToken, ccToken, 
            &pszKey, &ccKey, &pszValue, &ccValue))
        {
            // Trim one pair of quotes.
            if (ccValue && (*pszValue == L'"'))
            {
                pszValue++;
                ccValue--;
            }
            if (ccValue && (*(pszValue + ccValue - 1) == L'"'))
                ccValue--;

            // Version
            if (ccValue && ccKey == (DWORD)lstrlenW(L"Version") &&
                !FusionCompareStringNI(pszKey, L"Version", ccKey))
            {
                // Record version, 0 terminate.
                pszVersion = pszValue;
                ccVersion  = ccValue;
                *(pszVersion + ccVersion) = L'\0';
            }

            // FileVersion
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"FileVersion") &&
                !FusionCompareStringNI(pszKey, L"FileVersion", ccKey))
            {
                // Record version, 0 terminate.
                pszFileVersion = pszValue;
                ccFileVersion  = ccValue;
                *(pszFileVersion + ccFileVersion) = L'\0';
            }

            // Public key
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"PublicKey") &&
                     !FusionCompareStringNI(pszKey, L"PublicKey", ccKey))
            {
                // PK, 0 terminate.
                pszPK = pszValue;
                ccPK  = ccValue;
                if(ccPK % 2) 
                {
                    hr = FUSION_E_INVALID_NAME;
                    goto exit;
                }
                *(pszPK + ccPK) = L'\0';
            }
            // Ref flags
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"fRef") &&
                     !FusionCompareStringNI(pszKey, L"fRef", ccKey))
            {
                pszRef = pszValue;
                ccRef = ccValue;
                *(pszRef + ccRef) = L'\0';
            }
            // Def flags
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"fDef") &&
                     !FusionCompareStringNI(pszKey, L"fDef", ccKey))
            {
                pszDef = pszValue;
                ccDef = ccValue;
                *(pszDef + ccDef) = L'\0';
            }
            // Strong name (SN or OR)
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"PublicKeyToken") &&
                     (!FusionCompareStringNI(pszKey, L"PublicKeyToken", ccKey)))
            {
                // SN, 0 terminate.
                pszSN = pszValue;
                ccSN  = ccValue;
                if(ccSN % 2) 
                {
                    hr = FUSION_E_INVALID_NAME;
                    goto exit;
                }
                *(pszSN + ccSN) = L'\0';
            }
            // Culture
            else if (pszValue && ccKey == (DWORD)lstrlenW(L"Culture") &&
                     (!FusionCompareStringNI(pszKey, L"Culture", ccKey)))
            {
                pszCulture = pszValue;
                ccCulture  = ccValue;
                *(pszCulture + ccCulture) = L'\0';
            }
            // Custom
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"Custom") &&
                     !FusionCompareStringNI(pszKey, L"Custom", ccKey))
            {
                // Custom, 0 terminate.
                pszCustom = pszValue;
                ccCustom  = ccValue;
                if (ccCustom % 2)
                {
                    hr = FUSION_E_INVALID_NAME;
                    goto exit;
                }                
                *(pszCustom + ccCustom) = L'\0';
            }
            // Retarget
            else if (ccValue && ccKey == (DWORD)lstrlenW(L"Retargetable") &&
                     !FusionCompareStringNI(pszKey, L"Retargetable", ccKey))
            {
                // Retarget, 0 terminate.
                pszRetarget = pszValue;
                ccRetarget = ccValue;
                *(pszRetarget + ccRetarget) = L'\0';
            }
        }
    }

    // If pszRetarget is set, make sure the name is fully specified.
    if (pszRetarget)
    {
        if (!pszVersion || !pszCulture || !pszSN)
        {
            hr = FUSION_E_INVALID_NAME;
            goto exit;
        }
    }

    // Parse major, minor, rev# and bld#
    // from version string if extant.
    if (pszVersion)
    {
        pszBuf = pszVersion;
        ccBuf  = ccVersion + 1;

        INT iVersion;
        dwCountOfAssemblyVers = 0;
        while (CParseUtils::GetDelimitedToken(&pszBuf, &ccBuf, &pszToken, &ccToken, L'.'))
        {                    
            if (dwCountOfAssemblyVers < VERSION_STRING_SEGMENTS) {
                iVersion = StrToInt(pszToken);
                if (iVersion > 0xffff)
                {
                    hr = FUSION_E_INVALID_NAME;
                    goto exit;
                }
                wVer[dwCountOfAssemblyVers++] = (WORD)iVersion;
            }
        }            
    }

    // Parse major, minor, rev# and bld#
    // from FILE version string if extant.
    if (pszFileVersion)
    {
        pszBuf = pszFileVersion;
        ccBuf  = ccVersion + 1;

        INT iVersion;
        dwCountOfFileVers = 0;
        while (CParseUtils::GetDelimitedToken(&pszBuf, &ccBuf, &pszToken, &ccToken, L'.'))
        {                    
            if (dwCountOfFileVers < VERSION_STRING_SEGMENTS) {
                iVersion = StrToInt(pszToken);
                if (iVersion > 0xffff)
                {
                    hr = FUSION_E_INVALID_NAME;
                    goto exit;
                }
                wFileVer[dwCountOfFileVers++] = (WORD)iVersion;
            }
        }            
    }
    
    // Set name.
    if (FAILED(hr = SetProperty(ASM_NAME_NAME, (LPWSTR) pszName, 
        (ccName + 1) * sizeof(WCHAR))))
        goto exit;
        
    // Set version info.
    for (i = 0; i < dwCountOfAssemblyVers; i++) {
        if (FAILED(hr = SetProperty(i + ASM_NAME_MAJOR_VERSION,
            &wVer[i], sizeof(WORD))))
            goto exit;
    }

    // Set FILE version info.
    for (i = 0; i < dwCountOfFileVers; i++) {
        if (FAILED(hr = SetProperty(i + ASM_NAME_FILE_MAJOR_VERSION,
            &wFileVer[i], sizeof(WORD))))
            goto exit;
    }

    // Set public key and/or public key token
    for (i = 0; i < 2; i++)
    {
        pszProp = (i ? pszSN : pszPK);
        ccProp  = (i ? ccSN  : ccPK);

        if (pszProp)
        {
            // SN=NULL/PK=NULL sets null property.
            if ((ccProp == (sizeof("NULL") - 1)) 
                && !(FusionCompareStringNI(pszProp, L"NULL", sizeof("NULL") - 1)))
            {
                if (FAILED(hr = SetProperty(ASM_NAME_NULL_PUBLIC_KEY + i, NULL, 0)))
                    goto exit;
            }
            // Otherwise setting public key or public key token.
            else
            {
                cbProp = ccProp / 2;
                pbProp = NEW(BYTE[cbProp]);
                if (!pbProp)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }                
                CParseUtils::UnicodeHexToBin(pszProp, ccProp, pbProp);
                if (FAILED(hr = SetProperty(ASM_NAME_PUBLIC_KEY + i, pbProp, cbProp)))
                    goto exit;
                SAFEDELETEARRAY(pbProp);
            }
        }
    }
    
    // Culture if any specified.
    if (pszCulture)
    {
        if (!ccCulture || !FusionCompareStringI(pszCulture, L"neutral"))
        {
            if (FAILED(hr = SetProperty(ASM_NAME_CULTURE, L"\0", sizeof(WCHAR))))
                goto exit;
        }
        else if (FAILED(hr = SetProperty(ASM_NAME_CULTURE, pszCulture,
            (ccCulture + 1) * sizeof(WCHAR))))
            goto exit;            
    }

    // Custom if any specified
    if (pszCustom)
    {
        // Custom=null sets null property
        if ((ccCustom == (sizeof("NULL") - 1)) 
            && !(FusionCompareStringNI(pszCustom, L"NULL", sizeof("NULL") - 1)))
        {
            if (FAILED(hr = SetProperty(ASM_NAME_NULL_CUSTOM, NULL, 0)))
                goto exit;
        }   
        // Otherwise wildcarding Custom, which is automatically set
        // in constructor to IL (_fCustom = TRUE)
        else if ((ccCustom == (sizeof("*") - 1)) 
            && !(FusionCompareStringNI(pszCustom, L"*", sizeof("*") - 1)))
        {
            if (FAILED(hr = SetProperty(ASM_NAME_CUSTOM, NULL, 0)))
                goto exit;
        }   
        // Otherwise setting custom blob.
        else
        {
            cbProp = ccCustom / 2;
            pbProp = NEW(BYTE[cbProp]);
            if (!pbProp)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }                
            CParseUtils::UnicodeHexToBin(pszCustom, ccCustom, pbProp);
            if (FAILED(hr = SetProperty(ASM_NAME_CUSTOM, pbProp, cbProp)))
                goto exit;
        }
    }        

    // set Retarget flag
    if (pszRetarget)
    {
        // retarget only accepts true or false
        if ((ccRetarget == (sizeof("Yes") - 1))
            && !(FusionCompareStringNI(pszRetarget, L"Yes", sizeof("Yes") - 1)))
        {
            fRetarget = TRUE;
        }
        else if ((ccRetarget == (sizeof("No") - 1))
            && !(FusionCompareStringNI(pszRetarget, L"No", sizeof("No") - 1)))
        {
            fRetarget = FALSE;
        }
        else 
        {
            hr = FUSION_E_INVALID_NAME;
            goto exit;
        }
       
        if (fRetarget)
        {
            if (FAILED(hr = SetProperty(ASM_NAME_RETARGET, &fRetarget, sizeof(BOOL))))
                goto exit;    
        }
    }

exit:
    
    SAFEDELETEARRAY(szBuffer);
    SAFEDELETEARRAY(pbProp);
    
    _cRef = 1;
        
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetPublicKeyTokenFromPKBlob
// ---------------------------------------------------------------------------
HRESULT CAssemblyName::GetPublicKeyTokenFromPKBlob(LPBYTE pbPublicKeyToken, DWORD cbPublicKeyToken,
    LPBYTE *ppbSN, LPDWORD pcbSN)
{    
    HRESULT hr = S_OK;

    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto Exit;
    }

    // Generate the hash of the public key.
    if (!g_pfnStrongNameTokenFromPublicKey(pbPublicKeyToken, cbPublicKeyToken, ppbSN, pcbSN))
    {
        hr = g_pfnStrongNameErrorInfo();
    }

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetPublicKeyToken
// ---------------------------------------------------------------------------
HRESULT CAssemblyName::GetPublicKeyToken(LPDWORD pcbBuf, LPBYTE pbBuf,
    BOOL fDisplay)
{    
    HRESULT hr;
    LPBYTE pbPublicKeyToken = NULL;
    DWORD cbPublicKeyToken = 0, cbRequired = 0;

    if (!pcbBuf) {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If display format is not required then call 
    // GetProperty directly on the provided buffer.
    if (!fDisplay)
    {
        hr = GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pbBuf, pcbBuf);
        goto exit;
    }

    // Otherwise, display format required.

    // Get the required public key token output buf size.
    hr = GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, NULL, &cbPublicKeyToken);

    // No public key token or unexpected error
    if (!cbPublicKeyToken || (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)))
    {
        *pcbBuf = cbPublicKeyToken;
        goto exit;
    }

    // We will convert binary format to hex encoded unicode - 
    // Calculated actual output buffer size in bytes - 
    // one byte maps to two unicode chars = 4 bytes/byte + null term.
    cbRequired = (2 * cbPublicKeyToken + 1) * sizeof(WCHAR);

    // Inform client if insufficient buffer
    if (*pcbBuf < cbRequired)
    {
        *pcbBuf = cbRequired;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto exit;
    }

    if (!pbBuf) {
        if (pcbBuf) {
            *pcbBuf = cbRequired;
        }

        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto exit;
    }

    // Allocate temp space for public key token
    pbPublicKeyToken = NEW(BYTE[cbPublicKeyToken]);
    if (!pbPublicKeyToken)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the public key token
    if (FAILED(hr = GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pbPublicKeyToken, &cbPublicKeyToken)))
        goto exit;

    // Convert to unicode.
    CParseUtils::BinToUnicodeHex(pbPublicKeyToken, cbPublicKeyToken, (LPWSTR) pbBuf);

    *pcbBuf = cbRequired;

exit:
    SAFEDELETEARRAY(pbPublicKeyToken);
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::SetDefaults
// ---------------------------------------------------------------------------
HRESULT CAssemblyName::SetDefaults()
{
    HRESULT                              hr = S_OK;
    DWORD                                dwProcessor;
    OSINFO                               osinfo;
    
    // Default values

    dwProcessor = DEFAULT_ARCHITECTURE;
    GetDefaultPlatform(&osinfo);

    hr = SetProperty(ASM_NAME_OSINFO_ARRAY, &osinfo, sizeof(OSINFO));

    if (SUCCEEDED(hr)) {
        hr = SetProperty(ASM_NAME_PROCESSOR_ID_ARRAY, &dwProcessor, sizeof(DWORD));
    }
    
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::IsPartial
// BUGBUG - we could make this much simpler by having equivalence between
// ASM_NAME_NAME, ... AND ASM_CMPF_NAME for name, loc, pkt, ver1 .. ver low
// ---------------------------------------------------------------------------
BOOL CAssemblyName::IsPartial(IAssemblyName *pIName, LPDWORD pdwCmpMask)
{
    DWORD dwCmpMask = 0;
    BOOL fPartial    = FALSE;

    ASM_NAME rNameFlags[] = {ASM_NAME_NAME, 
                             ASM_NAME_CULTURE,
                             ASM_NAME_PUBLIC_KEY_TOKEN, 
                             ASM_NAME_MAJOR_VERSION, 
                             ASM_NAME_MINOR_VERSION, 
                             ASM_NAME_BUILD_NUMBER, 
                             ASM_NAME_REVISION_NUMBER, 
                             ASM_NAME_CUSTOM
                             ,
                             ASM_NAME_RETARGET
                            };

    ASM_CMP_FLAGS rCmpFlags[] = {ASM_CMPF_NAME, 
                                 ASM_CMPF_CULTURE,
                                 ASM_CMPF_PUBLIC_KEY_TOKEN, 
                                 ASM_CMPF_MAJOR_VERSION, 
                                 ASM_CMPF_MINOR_VERSION,
                                 ASM_CMPF_BUILD_NUMBER, 
                                 ASM_CMPF_REVISION_NUMBER, 
                                 ASM_CMPF_CUSTOM
                                 ,
                                 ASM_CMPF_RETARGET
                                };

    CAssemblyName *pName = dynamic_cast<CAssemblyName*> (pIName);
    ASSERT(pName);
    
    DWORD iNumOfComparison = sizeof(rNameFlags) / sizeof(rNameFlags[0]);
    
    for (DWORD i = 0; i < iNumOfComparison; i++)
    {
        if (pName->_rProp[rNameFlags[i]].cb 
            || (rNameFlags[i] == ASM_NAME_PUBLIC_KEY_TOKEN
                && pName->_fPublicKeyToken)
            || (rNameFlags[i] == ASM_NAME_CUSTOM 
                && pName->_fCustom))
        {
            dwCmpMask |= rCmpFlags[i];            
        }
        else
        {
            // retarget flag is not counted to judge partialness
            if (rNameFlags[i] != ASM_NAME_RETARGET)
                fPartial = TRUE;
        }
    }

    if (pdwCmpMask)
        *pdwCmpMask = dwCmpMask;

    return fPartial;
}


// ---------------------------------------------------------------------------
// CAssemblyName::GetVersion
//---------------------------------------------------------------------------
ULONGLONG CAssemblyName::GetVersion(IAssemblyName *pName)
{
    ULONGLONG ullVer = 0;
    DWORD dwVerHigh = 0, dwVerLow = 0;
    pName->GetVersion(&dwVerHigh, &dwVerLow);
    ullVer = ((ULONGLONG) dwVerHigh) << sizeof(DWORD) * 8;
    ullVer |= (ULONGLONG) dwVerLow;
    return ullVer;
}

// ---------------------------------------------------------------------------
// CAssemblyName::ProcessDevPath
//---------------------------------------------------------------------------

HRESULT CAssemblyName::ProcessDevPath(IApplicationContext *pAppCtx, LPVOID *ppv,
                                      CAssembly *pCAsmParent, CDebugLog *pdbglog)
{
    HRESULT                                      hr = S_OK;
    WCHAR                                        wzAsmPath[MAX_PATH + 1];
    LPWSTR                                       pwzDevPath = NULL;
    LPWSTR                                       pwzDevPathBuf = NULL;
    LPWSTR                                       pwzCurPath = NULL;
    static const LPWSTR                          pwzExtDLL = L".DLL";
    static const LPWSTR                          pwzExtEXE = L".EXE";
    LISTNODE                                     pos = NULL;
    List<IAssembly *>                           *pDPList = NULL;
    IAssemblyManifestImport                     *pManImport = NULL;
    IAssemblyName                               *pNameDef = NULL;
    IAssemblyName                               *pNameDevPath = NULL;
    IAssembly                                   *pAsmDevPath = NULL;
    IAssembly                                   *pAsmActivated = NULL;
    IAssembly                                   *pCurAsm = NULL;
    Property                                    *pPropName = &(_rProp[ASM_NAME_NAME]);
    LPWSTR                                       pwzAsmName = (LPWSTR)pPropName->pv;
    FILETIME                                     ftLastModified;
    LPWSTR                                       wzURL=NULL;
    BOOL                                         bWasVerified = FALSE;
    DWORD                                        dwVerifyFlags = SN_INFLAG_USER_ACCESS;
    DWORD                                        dwLen;
    CAssembly                                   *pCAsmDevPath = NULL;
    CLoadContext                                *pLoadContextParent = NULL;
    CLoadContext                                *pLoadCtxDefault = NULL;
    LPWSTR                                       wzProbingBase=NULL;
    DWORD                                        dwCmpFlags = ASM_CMPF_NAME |
                                                              ASM_CMPF_PUBLIC_KEY_TOKEN |
                                                              ASM_CMPF_CULTURE;

    DEBUGOUT(pdbglog, 1, ID_FUSLOG_PROCESS_DEVPATH);

    if (!pAppCtx || !ppv) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    if (!pwzAsmName || !lstrlenW(pwzAsmName)) {
        // This is a where-ref bind (no name is set). Bypass dev path lookup.
        hr = S_FALSE;
        goto Exit;
    }

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_DEV_PATH, &pwzDevPathBuf);
    if (hr != S_OK) {
        // Dev path is not set. Fall through to regular bind.
        DEBUGOUT(pdbglog, 1, ID_FUSLOG_DEVPATH_UNSET);
        hr = S_FALSE;
        goto Exit;
    }

    // Extract parent assembly information

    wzProbingBase = NEW(WCHAR[MAX_URL_LENGTH*2+2]);
    if (!wzProbingBase)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzURL = wzProbingBase + MAX_URL_LENGTH + 1;

    wzProbingBase[0] = L'\0';

    if (pCAsmParent) {
        // We have a parent assembly, so set the load context and
        // probing base to that of the parent.

        hr = pCAsmParent->GetLoadContext(&pLoadContextParent);
        if (FAILED(hr)) {
            ASSERT(0);
            goto Exit;
        }

        dwLen = MAX_URL_LENGTH;
        hr = pCAsmParent->GetProbingBase(wzProbingBase, &dwLen);
        if (FAILED(hr)) {
            ASSERT(0);
            goto Exit;
        }
    }

    // Look for assembly in devpath

    ASSERT(pwzDevPathBuf);

    pwzDevPath = pwzDevPathBuf;

    while (pwzDevPath) {
        pwzCurPath = ::GetNextDelimitedString(&pwzDevPath, DEVPATH_DIR_DELIMITER);

        PathRemoveBackslash(pwzCurPath);
        wnsprintfW(wzAsmPath, MAX_PATH, L"%ws\\%ws%ws", pwzCurPath, pwzAsmName, pwzExtDLL);

        if (GetFileAttributes(wzAsmPath) == -1) {
            // File does not exist, try next path

            DEBUGOUT1(pdbglog, 1, ID_FUSLOG_DEVPATH_PROBE_MISS, wzAsmPath);

            wnsprintfW(wzAsmPath, MAX_PATH, L"%ws\\%ws%ws", pwzCurPath, pwzAsmName, pwzExtEXE);

            if (GetFileAttributes(wzAsmPath) == -1) {

                DEBUGOUT1(pdbglog, 1, ID_FUSLOG_DEVPATH_PROBE_MISS, wzAsmPath);
                continue;
            }
        }
    
        // File exists. Crack the manifest and do ref/def matching
        
        hr = CreateAssemblyManifestImport(wzAsmPath, &pManImport);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        // Get read-only name def from manifest.
        hr = pManImport->GetAssemblyNameDef(&pNameDef);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        hr = IsEqualLogging(pNameDef, dwCmpFlags, pdbglog);
        if (hr != S_OK) {
            // Found a file, but it is the wrong one. Try next path.

            DEBUGOUT1(pdbglog, 1, ID_FUSLOG_DEVPATH_REF_DEF_MISMATCH, wzAsmPath);
            continue;
        }

        // Verify signature
        if (CCache::IsStronglyNamed(pNameDef))
        {
            if (!VerifySignature(wzAsmPath, &bWasVerified, dwVerifyFlags)) {
                hr = FUSION_E_SIGNATURE_CHECK_FAILED;
                goto Exit;
            }
        }

        // Matching assembly found in dev path. Create the IAssembly.
    
        dwLen = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(wzAsmPath, wzURL, &dwLen, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        hr = GetFileLastModified(wzAsmPath, &ftLastModified);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = CreateAssemblyFromManifestImport(pManImport, wzURL, &ftLastModified,
                                              &pAsmDevPath);
        if (FAILED(hr)) {
            goto Exit;
        }

        // Check if the name def exists in the load context already.
        // If so, then use the already activated one, instead of the
        // devpath one.

        hr = pAsmDevPath->GetAssemblyNameDef(&pNameDevPath);
        if (FAILED(hr)) {
            goto Exit;
        }

        // Not found in parent load context. Continue to hand out this
        // assembly.

        // Set load context and probing base

        pCAsmDevPath = dynamic_cast<CAssembly *>(pAsmDevPath);
        ASSERT(pCAsmDevPath);

        if (pLoadContextParent) {
            if (lstrlenW(wzProbingBase)) {
                // BUGBUG: Should assert the context type is loadfrom (ie.
                // wzprobingbase will be used. In the "else" case, should
                // also assert we're not adding probing base because we
                // are in the default load context.
                
                pCAsmDevPath->SetProbingBase(wzProbingBase);
            }
    
            hr = pLoadContextParent->AddActivation(pAsmDevPath, &pAsmActivated);
            if (FAILED(hr)) {
                goto Exit;
            }
            else if (hr == S_FALSE) {
                *ppv = pAsmActivated;
                hr = S_OK;
                goto Exit;
            }
        }
        else {
            // We do not have a parent, so just set the load context to
            // the default load context.

            dwLen = sizeof(pLoadCtxDefault);
            hr = pAppCtx->Get(ACTAG_LOAD_CONTEXT_DEFAULT, &pLoadCtxDefault, &dwLen, APP_CTX_FLAGS_INTERFACE);
            if (FAILED(hr)) {
                ASSERT(0);
                return hr;
            }

            hr = pLoadCtxDefault->AddActivation(pAsmDevPath, &pAsmActivated);
            if (FAILED(hr)) {
                goto Exit;
            }
            else if (hr == S_FALSE) {
                *ppv = pAsmActivated;
                hr = S_OK;
                goto Exit;
            }
        }
    
        // Successful dev path lookup. AddRef out param and we're finished.
    
        *ppv = pAsmDevPath;
        pAsmDevPath->AddRef();

        DEBUGOUT1(pdbglog, 1, ID_FUSLOG_DEVPATH_FOUND, wzAsmPath);

        goto Exit;
    }

    // Didn't find the assembly. Fall through to regular bind.

    DEBUGOUT(pdbglog, 1, ID_FUSLOG_DEVPATH_NOT_FOUND);

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(pwzDevPathBuf);

    SAFERELEASE(pManImport);
    SAFERELEASE(pAsmDevPath);
    SAFERELEASE(pNameDef);
    SAFERELEASE(pAsmActivated);
    SAFERELEASE(pNameDevPath);
    SAFERELEASE(pLoadContextParent);
    SAFERELEASE(pLoadCtxDefault);

    SAFEDELETEARRAY(wzProbingBase);

    return hr;
}                                      
extern pfnGetCORVersion g_pfnGetCORVersion;

// PreBindAssemblyEx
// 
// Add an pwzRuntimeVersion parameter to control PreBindAssembly. 
//
// If pwzRuntimeVersion is same as RTM version, don't apply FxConfig in PreBindAssembly.
// If pwzRuntimeVersion is same as running version(Everett), apply FxConfig in PreBindAssembly.
// Null pwzRuntimeVersion means apply FxConfig.
// Other pwzRuntimeVersion(s) are considered as error.
// 
STDAPI PreBindAssemblyEx(
                IApplicationContext *pAppCtx, IAssemblyName *pName, 
                IAssembly *pAsmParent, LPCWSTR pwzRuntimeVersion,  
                IAssemblyName **ppNamePostPolicy, LPVOID pvReserved)
{
    HRESULT                               hr = S_OK;
    LPWSTR                                pwzDevPathBuf = NULL;
    LPWSTR                                pwzDevPath = NULL;
    LPWSTR                                pwzCurPath = NULL;
    LPWSTR                                pwzAppCfg = NULL;
    LPWSTR                                pwzHostCfg = NULL;
    LPWSTR                                pwzAsmName = NULL;
    WCHAR                                 wzAsmPath[MAX_PATH];
    DWORD                                 dwSize = 0;
    DWORD                                 dwCmpMask;
    BOOL                                  bDisallowAppBindingRedirects = FALSE;
    CPolicyCache                         *pPolicyCache = NULL;
    CCache                               *pCache = NULL;
    CLoadContext                         *pLoadContext = NULL;
    CTransCache                          *pTransCache = NULL;
    IAssemblyName                        *pNamePolicy = NULL;
    IAssemblyName                        *pNameRefPolicy = NULL;
    IAssembly                            *pAsm = NULL;
    AsmBindHistoryInfo                    bindHistory;
    BOOL                                  bUnifyFXAssemblies = TRUE;
    DWORD                                 cbValue;
    static const LPWSTR                   pwzExtDLL = L".DLL";
    static const LPWSTR                   pwzExtEXE = L".EXE";
    static const LPWSTR                   wzRTMCorVersion = L"v1.0.3705";
    // TODO: Made up. Need to change when Everett is final. 
    static const LPWSTR                   wzEverettCorVersion = L"v1.0.5000"; 
    LPWSTR                                pwzCorVersion = NULL;
    BOOL                                  bFxConfigSupported = TRUE;
    BOOL                                  bDisallowPublisherPolicy = FALSE;

    if (!pAppCtx || !pName || !ppNamePostPolicy) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // NULL pwzRuntimeVersion means please check FxConfig.
    if (pwzRuntimeVersion != NULL) {

        // TODO:
        // Following code is needed because Everett is not final, 
        // and the runtime version will keep changing. 
        // Once Everett reaches final, we should use the hardcored one above.

        // Initialize the shim before calling global
        // functions
        hr = InitializeEEShim();
        if(FAILED(hr)) {
            goto Exit;
        }

        hr = g_pfnGetCORVersion(pwzCorVersion, dwSize, &dwSize);
        if (SUCCEEDED(hr)) {
            hr = E_UNEXPECTED;
            goto Exit;
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            pwzCorVersion = NEW(WCHAR[dwSize]);
            if (!pwzCorVersion) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            hr = g_pfnGetCORVersion(pwzCorVersion, dwSize, &dwSize);
        }
        if (FAILED(hr))
            goto Exit;
   
        // TODO: When Everett reaches final, please change pwzRuntimeVersion
        //       to wzEverettCorVersion defined above.
        if (!FusionCompareStringI(pwzRuntimeVersion, pwzCorVersion)) {
            bFxConfigSupported = TRUE;
        }
        else if (!FusionCompareStringI(pwzRuntimeVersion, wzRTMCorVersion)) {
            bFxConfigSupported = FALSE;
        }
        else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto Exit;
        }
    }

    dwSize = 0;
    hr = pAppCtx->Get(ACTAG_APP_CFG_DOWNLOAD_ATTEMPTED, NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        hr = DownloadAppCfg(pAppCtx, NULL, NULL, NULL, FALSE);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    *ppNamePostPolicy = NULL;

    memset(&bindHistory, 0, sizeof(AsmBindHistoryInfo));

    hr = CCache::Create(&pCache, pAppCtx);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Name ref must be fully-specified

    if (CAssemblyName::IsPartial(pName, &dwCmpMask) || !CCache::IsStronglyNamed(pName)) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    // Get assembly name

    dwSize = 0;
    pName->GetName(&dwSize, NULL);

    if (!dwSize) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pwzAsmName = NEW(WCHAR[dwSize]);
    if (!pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pName->GetName(&dwSize, pwzAsmName);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Extract load context

    if (!pAsmParent) {
        dwSize = sizeof(pLoadContext);
        hr = pAppCtx->Get(ACTAG_LOAD_CONTEXT_DEFAULT, &pLoadContext, &dwSize, APP_CTX_FLAGS_INTERFACE);
        if (FAILED(hr) || !pLoadContext) {
            hr = E_UNEXPECTED;
            goto Exit;
        }
    }
    else {
        CAssembly *pCAsm = dynamic_cast<CAssembly *>(pAsmParent);
        ASSERT(pCAsm);

        hr = pCAsm->GetLoadContext(&pLoadContext);
        if (FAILED(hr)) {
            hr = E_UNEXPECTED;
            goto Exit;
        }
    }


    // Check devpath

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_DEV_PATH, &pwzDevPathBuf);
    if (hr == S_OK) {
        pwzDevPath = pwzDevPathBuf;
    
        while (pwzDevPath) {
            pwzCurPath = ::GetNextDelimitedString(&pwzDevPath, DEVPATH_DIR_DELIMITER);
    
            PathRemoveBackslash(pwzCurPath);
            wnsprintfW(wzAsmPath, MAX_PATH, L"%ws\\%ws%ws", pwzCurPath, pwzAsmName, pwzExtDLL);
    
            if (GetFileAttributes(wzAsmPath) != -1) {
                // DLL exists in DEVPATH. Fail.

                hr = FUSION_E_REF_DEF_MISMATCH;
                goto Exit;
            }

            wnsprintfW(wzAsmPath, MAX_PATH, L"%ws\\%ws%ws", pwzCurPath, pwzAsmName, pwzExtEXE);

            if (GetFileAttributes(wzAsmPath) != -1) {
                // EXE exists in DEVPATH. Fail.

                hr = FUSION_E_REF_DEF_MISMATCH;
                goto Exit;
            }
        }
    }

    // Check policy cache
    
    dwSize = sizeof(pPolicyCache);
    hr = pAppCtx->Get(ACTAG_APP_POLICY_CACHE, &pPolicyCache, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (hr == S_OK) {
        // Policy cache exists.

        hr = pPolicyCache->LookupPolicy(pName, &pNamePolicy, &bindHistory);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (hr == S_OK) {
            hr = pNamePolicy->Clone(ppNamePostPolicy);
            if (FAILED(hr)) {
                goto Exit;
            }
    
            if (pName->IsEqual(pNamePolicy, ASM_CMPF_DEFAULT) != S_OK) {
                // Policy resulted in a different ref. Fail.
    
                hr = FUSION_E_REF_DEF_MISMATCH;
                goto Exit;
            }
    
            // Return signature blob from activated assemblies list.

            hr = pLoadContext->CheckActivated(pNamePolicy, &pAsm);
            if (hr == S_OK) {
                IAssemblyName                  *pNameDef;

                hr = pAsm->GetAssemblyNameDef(&pNameDef);
                if (FAILED(hr)) {
                    goto Exit;
                }

                // Use post-policy def since it has the signature blob.

                SAFERELEASE(*ppNamePostPolicy);

                hr = pNameDef->Clone(ppNamePostPolicy);
                if (FAILED(hr)) {
                    goto Exit;
                }

                SAFERELEASE(pNameDef);
                goto Exit;
            }

            // If hr==S_FALSE, then we hit in the policy cache, but did not
            // find a hit in the activated asm list. Check the GAC. If it
            // doesn't exist in the GAC, then we don't know the signature blob.

            hr = pCache->RetrieveTransCacheEntry(pName, ASM_CACHE_GAC, &pTransCache);
            if (pTransCache) {
                TRANSCACHEINFO *pInfo = (TRANSCACHEINFO *)pTransCache->_pInfo;
        
                hr = GetFusionInfo(pTransCache, NULL);
                if (FAILED(hr)) {
                    goto Exit;
                }
                
                BOOL fPropWasSet = FALSE;
                
                if (pInfo->blobSignature.cbSize == SIGNATURE_BLOB_LENGTH_HASH) {

                    // Hit in cache. Copy off the signature blob.
                    hr = (*ppNamePostPolicy)->SetProperty(ASM_NAME_SIGNATURE_BLOB, (pInfo->blobSignature).pBlobData, SIGNATURE_BLOB_LENGTH_HASH);
                    if (FAILED(hr)) {
                        goto Exit;
                    }
                    fPropWasSet = TRUE;
                }
                if (pInfo->blobMVID.cbSize == MVID_LENGTH) {
                    hr = (*ppNamePostPolicy)->SetProperty(ASM_NAME_MVID, (pInfo->blobMVID).pBlobData, MVID_LENGTH);
                    if (FAILED(hr)) {
                        goto Exit;
                    }
                    fPropWasSet = TRUE;
                }
                if (!fPropWasSet) {
                    hr = S_FALSE;
                        goto Exit;
                    }

                hr = S_OK;
                goto Exit;
            }
            else {
                // Don't know the signature blob, but policy guaranteed to not be applied.
                hr = S_FALSE;
                goto Exit;
            }
        }

        // Missed in policy cache. Fall through to apply policy.
    }
    else {
        // Policy cache didn't exist in this context.

        hr = PreparePolicyCache(pAppCtx, &pPolicyCache);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // Apply Policy

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_CFG_LOCAL_FILEPATH, &pwzAppCfg);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_HOST_CONFIG_FILE, &pwzHostCfg);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (bFxConfigSupported) {
        cbValue = 0;
        hr = pAppCtx->Get(ACTAG_DISABLE_FX_ASM_UNIFICATION, NULL, &cbValue, 0);
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            bUnifyFXAssemblies = FALSE;
        }
        else if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
            goto Exit;
        }
    }
    else  {
        bUnifyFXAssemblies = FALSE;
    }

    dwSize = 0;
    hr = pAppCtx->Get(ACTAG_DISALLOW_APP_BINDING_REDIRECTS, NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        bDisallowAppBindingRedirects = TRUE;
    }

    dwSize = 0;
    hr = pAppCtx->Get(ACTAG_DISALLOW_APPLYPUBLISHERPOLICY, NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        bDisallowPublisherPolicy = TRUE;
    }

    hr = ApplyPolicy(pwzHostCfg, pwzAppCfg, pName, &pNameRefPolicy, NULL,
                     pAppCtx, &bindHistory, bDisallowPublisherPolicy, bDisallowAppBindingRedirects, bUnifyFXAssemblies, NULL);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNameRefPolicy->Clone(ppNamePostPolicy);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Record resolution in policy cache

    hr = pPolicyCache->InsertPolicy(pName, pNameRefPolicy, &bindHistory);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (pName->IsEqual(pNameRefPolicy, ASM_CMPF_DEFAULT) != S_OK) {
        // Policy resulted in a different ref. Fail.

        hr = FUSION_E_REF_DEF_MISMATCH;
        goto Exit;
    }

    // Try to find assembly in the GAC.
    
    hr = pCache->RetrieveTransCacheEntry(pName, ASM_CACHE_GAC, &pTransCache);
    if (pTransCache) {
        TRANSCACHEINFO *pInfo = (TRANSCACHEINFO *)pTransCache->_pInfo;

        hr = GetFusionInfo(pTransCache, NULL);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        BOOL fPropWasSet = FALSE;
        if (pInfo->blobSignature.cbSize == SIGNATURE_BLOB_LENGTH_HASH) {

            // Hit in cache. Copy off the signature blob.
            hr = (*ppNamePostPolicy)->SetProperty(ASM_NAME_SIGNATURE_BLOB, (pInfo->blobSignature).pBlobData, SIGNATURE_BLOB_LENGTH_HASH);
            if (FAILED(hr)) {
                goto Exit;
            }
            fPropWasSet = TRUE;
        }
        if (pInfo->blobMVID.cbSize == MVID_LENGTH) {
            hr = (*ppNamePostPolicy)->SetProperty(ASM_NAME_MVID, (pInfo->blobMVID).pBlobData, MVID_LENGTH);
            if (FAILED(hr)) {
                goto Exit;
            }
            fPropWasSet = TRUE;
        }
        if (!fPropWasSet) {
            hr = S_FALSE;
                goto Exit;
        }

        // done

        goto Exit;
    }

    // Assembly not found in cache, but we can guarantee that there won't
    // be policy. We don't know the signature blob, because we can only find this
    // assembly via probing.

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(pwzCorVersion);
    SAFEDELETEARRAY(pwzDevPathBuf);
    SAFEDELETEARRAY(pwzAppCfg);
    SAFEDELETEARRAY(pwzHostCfg);
    SAFEDELETEARRAY(pwzAsmName);

    SAFERELEASE(pPolicyCache);
    SAFERELEASE(pNamePolicy);
    SAFERELEASE(pNameRefPolicy);
    SAFERELEASE(pCache);
    SAFERELEASE(pTransCache);
    SAFERELEASE(pLoadContext);
    SAFERELEASE(pAsm);

    return hr;
   
}

//
// PreBindAssembly
//
// Returns:
//    FUSION_E_REF_DEF_MISMATCH: Policy will be applied to the pName, and
//                               will result in a different def.
//
//    S_OK: Policy will not affect the pName. 
//
//    S_FALSE: Policy will not affect the pName, but we do not know the signature blob.
//

STDAPI PreBindAssembly(IApplicationContext *pAppCtx, IAssemblyName *pName,
                       IAssembly *pAsmParent, IAssemblyName **ppNamePostPolicy,
                       LPVOID pvReserved)
{
    return PreBindAssemblyEx(pAppCtx, pName, pAsmParent, NULL, ppNamePostPolicy, pvReserved);
}

static HRESULT DownloadAppCfg(IApplicationContext *pAppCtx,
                       CAssemblyDownload *padl,
                       IAssemblyBindSink *pbindsink,
                       CDebugLog *pdbglog,
                       BOOL bAsyncAllowed)
{
    HRESULT                                hr = S_OK;
    HRESULT                                hrRet = S_OK;
    DWORD                                  dwLen;
    DWORD                                  dwFileAttr;
    LPWSTR                                 wszURL=NULL;
    WCHAR                                  wszAppCfg[MAX_PATH];
    LPWSTR                                 wszAppBase=NULL;
    LPWSTR                                 wszAppBaseStr = NULL;
    LPWSTR                                 wszAppCfgFile = NULL;
    BOOL                                   bIsFileUrl = FALSE;

    if (!pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    DEBUGOUT(pdbglog, 1, ID_FUSLOG_APP_CFG_DOWNLOAD);

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_BASE_URL, &wszAppBaseStr);
    if (FAILED(hr) || hr == S_FALSE) {
        goto Exit;
    }

    ASSERT(lstrlenW(wszAppBaseStr));

    if (!wszAppBaseStr || !lstrlenW(wszAppBaseStr)) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    wszAppBase = NEW(WCHAR[MAX_URL_LENGTH*2+2]);
    if (!wszAppBase)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wszURL = wszAppBase + MAX_URL_LENGTH + 1;

    lstrcpyW(wszAppBase, wszAppBaseStr);

    dwLen = lstrlenW(wszAppBase) - 1;
    if (wszAppBase[dwLen] != L'/' && wszAppBase[dwLen] != L'\\') {
        if (dwLen + 1 >= MAX_URL_LENGTH) {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
        StrCatW(wszAppBase, L"/");
    }

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_CONFIG_FILE, &wszAppCfgFile);
    if (FAILED(hr) || hr == S_FALSE) {
        goto Exit;
    }

    dwLen = MAX_URL_LENGTH;
    hr = UrlCombineUnescape(wszAppBase, wszAppCfgFile, wszURL, &dwLen, 0);
    if (hr == S_OK) {
        DEBUGOUT1(pdbglog, 1, ID_FUSLOG_APP_CFG_DOWNLOAD_LOCATION, wszURL);

        bIsFileUrl = UrlIsW(wszURL, URLIS_FILEURL);
        if (bIsFileUrl) {
            dwLen = MAX_PATH;
            hr = PathCreateFromUrlWrap(wszURL, wszAppCfg, &dwLen, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            // Indicate that we've already searched for app.cfg

            pAppCtx->Set(ACTAG_APP_CFG_DOWNLOAD_ATTEMPTED, (void *)L"", sizeof(L""), 0);

            dwFileAttr = GetFileAttributes(wszAppCfg);
            if (dwFileAttr == -1 || (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)) {
                // App.cfg does not exist (or user incorrectly specified a
                // directory!).
                PrepareBindHistory(pAppCtx);
                DEBUGOUT(pdbglog, 0, ID_FUSLOG_APP_CFG_NOT_EXIST);
                hr = S_FALSE;
                goto Exit;
            }
            else {
                // Add app.cfg filepath to appctx
                DEBUGOUT1(pdbglog, 0, ID_FUSLOG_APP_CFG_FOUND, wszAppCfg);
                hr = SetAppCfgFilePath(pAppCtx, wszAppCfg);
                ASSERT(hr == S_OK);
                PrepareBindHistory(pAppCtx);
            }
        }
        else {
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
            if (bAsyncAllowed) {
    
                // Really must download async
    
                hrRet = padl->AddClient(pbindsink, TRUE);
                ASSERT(hrRet == S_OK);
    
                hr = DownloadAppCfgAsync(pAppCtx, padl, wszURL, pdbglog);
            }
            else {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }
#else
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto Exit;
#endif
        }
    }

Exit:
    if (wszAppBase) {
        delete [] wszAppBaseStr;
    }

    if (wszAppCfg) {
        delete [] wszAppCfgFile;
    }

    SAFEDELETEARRAY(wszAppBase);
    return hr;
}

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
static HRESULT DownloadAppCfgAsync(IApplicationContext *pAppCtx,
                            CAssemblyDownload *padl,
                            LPCWSTR wszURL,
                            CDebugLog *pdbglog)
{
    HRESULT                                hr = S_OK;
    DWORD                                  dwSize;
    AppCfgDownloadInfo                    *pdlinfo = NULL;
    IOInetProtocolSink                    *pSink = NULL;
    IOInetBindInfo                        *pBindInfo = NULL;
    CApplicationContext                   *pCAppCtx = dynamic_cast<CApplicationContext *>(pAppCtx);

    ASSERT(pCAppCtx);

    if (!pAppCtx || !wszURL) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pdlinfo = NEW(AppCfgDownloadInfo);
    if (!pdlinfo) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = CoInternetGetSession(0, &(pdlinfo->_pSession), 0);
    if (hr == NOERROR) {
        hr = (pdlinfo->_pSession)->CreateBinding(
            NULL,             // [in ] BindCtx, always NULL 
            wszURL,          // [in ] url
            NULL,             // [in ] IUnknown for Aggregration
            NULL,             // [out] IUNknown for Aggregration
            &(pdlinfo->_pProt),          // [out] return pProt pointer
            PI_LOADAPPDIRECT | PI_PREFERDEFAULTHANDLER// [in ] bind options
        );
    }

    // Create a protocolHook (sink) and Start the async operation
    if (hr == NOERROR) {
        hr = CCfgProtocolHook::Create(&(pdlinfo->_pHook), pAppCtx, padl,
                                      pdlinfo->_pProt, pdbglog);
        
        if (SUCCEEDED(hr)) {
            (pdlinfo->_pHook)->QueryInterface(IID_IOInetProtocolSink, (void**)&pSink);
            (pdlinfo->_pHook)->QueryInterface(IID_IOInetBindInfo, (void**)&pBindInfo);
        }

        if (pdlinfo->_pProt && pSink && pBindInfo) {
            hr = (pdlinfo->_pProt)->Start(wszURL, pSink, pBindInfo, PI_FORCE_ASYNC, 0);
            pSink->Release();
            pBindInfo->Release();

            if (hr == E_PENDING) {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr)) {
            // Check if Start succeeded synchronously. We know that ReportResult
            // was called during pProt->Start if the app.cfg filename is set
            // now.
            
            
            hr = pCAppCtx->Lock();
            if (FAILED(hr)) {
                goto Exit;
            }

            dwSize = 0;
            hr = pAppCtx->Get(ACTAG_APP_CFG_LOCAL_FILEPATH, NULL, &dwSize, 0);
            
            if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
                // Download of app.cfg went async (ReportResult hasn't been called)
                // Set the download info in the appctx
                
                hr = pAppCtx->Set(ACTAG_APP_CFG_DOWNLOAD_INFO, &pdlinfo, sizeof(AppCfgDownloadInfo *), 0);
                ASSERT(hr == S_OK);
            }
            else {
                // Download of app.cfg is actually already done. ReportResult
                // was already called. Need to release protocol pointers.
                (pdlinfo->_pProt)->Terminate(0);
                (pdlinfo->_pSession)->Release();
                (pdlinfo->_pProt)->Release();
                (pdlinfo->_pHook)->Release();

                SAFEDELETE(pdlinfo);
                hr = S_OK;
            }

            pCAppCtx->Unlock();
        }
    }

    if (SUCCEEDED(hr)) {
        hr = E_PENDING;
    }
    else {
        SAFERELEASE(pdlinfo->_pSession);
        SAFERELEASE(pdlinfo->_pHook);
        SAFERELEASE(pdlinfo->_pProt);
        SAFEDELETE(pdlinfo);
    }

Exit:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\nodefact.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "xmlparser.h"
#include "list.h"
#include "cfgdata.h"
#include "nodefact.h"
#include "util.h"
#include "dbglog.h"
#include "policy.h"
#include "helpers.h"
#include "naming.h"
#include "parse.h"

CNodeFactory::CNodeFactory(CDebugLog *pdbglog)
: _cRef(1)
, _dwCurDepth(0)
, _dwState(PSTATE_LOOKUP_CONFIGURATION)
, _pwzPrivatePath(NULL)
, _pAsmInfo(NULL)
, _pdbglog(pdbglog)
, _bGlobalSafeMode(FALSE)
, _bCorVersionMatch(TRUE)
, _bHonorAppliesTo(TRUE)
{
    _dwSig = 'TCAF';

    if (_pdbglog) {
        _pdbglog->AddRef();
    }
}

CNodeFactory::~CNodeFactory()
{
    LISTNODE                           pos = NULL;
    CAsmBindingInfo                   *pAsmInfo = NULL;
    CQualifyAssembly                  *pqa = NULL;

    SAFEDELETEARRAY(_pwzPrivatePath);
    SAFERELEASE(_pdbglog);

    pos = _listAsmInfo.GetHeadPosition();
    while (pos) {
        pAsmInfo = _listAsmInfo.GetNext(pos);
        SAFEDELETE(pAsmInfo);
    }

    _listAsmInfo.RemoveAll();

#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
    pos = _listQualifyAssembly.GetHeadPosition();
    while (pos) {
        pqa = _listQualifyAssembly.GetNext(pos);
        SAFEDELETE(pqa);
    }

    _listQualifyAssembly.RemoveAll();
#endif

    SAFEDELETE(_pAsmInfo);
}

HRESULT CNodeFactory::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IXMLNodeFactory)) {
        *ppv = static_cast<IXMLNodeFactory *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CNodeFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CNodeFactory::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

VOID CNodeFactory::DisableAppliesTo()
{
    _bHonorAppliesTo = FALSE;
}

HRESULT CNodeFactory::NotifyEvent(IXMLNodeSource *pSource,
                                  XML_NODEFACTORY_EVENT iEvt)
{
    return S_OK;
}

HRESULT CNodeFactory::BeginChildren(IXMLNodeSource *pSource,
                                    XML_NODE_INFO *pNodeInfo)
{
    return S_OK;
}

HRESULT CNodeFactory::EndChildren(IXMLNodeSource *pSource, BOOL fEmpty,
                                  XML_NODE_INFO *pNodeInfo)
{
    if (pNodeInfo->dwType == XML_ELEMENT) {
        _dwCurDepth--;
    }

    _nsmgr.OnEndChildren();

    // Unwind state

    if (_dwState == PSTATE_CONFIGURATION && _dwCurDepth < XML_CONFIGURATION_DEPTH) {
        _dwState = PSTATE_LOOKUP_CONFIGURATION;
    }
    else if (_dwState == PSTATE_RUNTIME && _dwCurDepth < XML_RUNTIME_DEPTH) {
        _dwState = PSTATE_CONFIGURATION;
    }
    else if (_dwState == PSTATE_ASSEMBLYBINDING && _dwCurDepth < XML_ASSEMBLYBINDING_DEPTH) {
        _dwState = PSTATE_RUNTIME;
    }
    else if (_dwState == PSTATE_DEPENDENTASSEMBLY && _dwCurDepth < XML_DEPENDENTASSEMBLY_DEPTH) {
        _dwState = PSTATE_ASSEMBLYBINDING;

        if (_bCorVersionMatch) {
            ASSERT(_pAsmInfo);

            // Add assembly information if valid

            if (_pAsmInfo->_pwzName) {
                if (!_pAsmInfo->_pwzPublicKeyToken && (_pAsmInfo->_listBindingRedir).GetCount()) {
                    LISTNODE                              pos;
                    CBindingRedir                        *pRedir;

                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_PRIVATE_ASM_REDIRECT);
                
                    pos = (_pAsmInfo->_listBindingRedir).GetHeadPosition();
                    while (pos) {
                        pRedir = (_pAsmInfo->_listBindingRedir).GetNext(pos);
                        SAFEDELETE(pRedir);
                    }
                
                    (_pAsmInfo->_listBindingRedir).RemoveAll();
                }

                _listAsmInfo.AddTail(_pAsmInfo);
                _pAsmInfo = NULL;
            }
            else {
                SAFEDELETE(_pAsmInfo);
            }
        }
        else {
            SAFEDELETE(_pAsmInfo);
        }
    }

    return S_OK;
}

HRESULT CNodeFactory::Error(IXMLNodeSource *pSource, HRESULT hrErrorCode,
                            USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
    DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_XML_PARSE_ERROR_CODE, hrErrorCode);

    _nsmgr.Error(hrErrorCode);

    return S_OK;
}

HRESULT CNodeFactory::CreateNode(IXMLNodeSource __RPC_FAR *pSource,
                                 PVOID pNodeParent, USHORT cNumRecs,
                                 XML_NODE_INFO __RPC_FAR **aNodeInfo)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  pwzElementNameNS = NULL;
    CCodebaseHint                          *pCodebaseInfo = NULL;
    CBindingRedir                          *pRedirInfo = NULL;
    CBindingRetarget                       *pRetargetInfo = NULL;

    hr = _nsmgr.OnCreateNode(pSource, pNodeParent, cNumRecs, aNodeInfo);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (aNodeInfo[0]->dwType == XML_ELEMENT) {
        _dwCurDepth++;

        hr = ApplyNamespace(aNodeInfo[0], &pwzElementNameNS, XMLNS_FLAGS_APPLY_DEFAULT_NAMESPACE);
        if (FAILED(hr)) {
            goto Exit;
        }

        switch (_dwState) {
            case PSTATE_LOOKUP_CONFIGURATION:
                // Still looking for <configuration> tag

                if ((_dwCurDepth == XML_CONFIGURATION_DEPTH) &&
                    (!FusionCompareString(pwzElementNameNS, POLICY_TAG_CONFIGURATION))) {

                    _dwState = PSTATE_CONFIGURATION;
                }

                break;

           case PSTATE_CONFIGURATION:
                // In <configuration> tag, and looking for <runtime> tag

                if ((_dwCurDepth == XML_RUNTIME_DEPTH) &&
                    (!FusionCompareString(pwzElementNameNS, POLICY_TAG_RUNTIME))) {

                    _dwState = PSTATE_RUNTIME;
                }

                break;

            case PSTATE_RUNTIME:
                 // In <runtime> tag, and looking for <assemblyBinding> tag

                 if ((_dwCurDepth == XML_ASSEMBLYBINDING_DEPTH) &&
                     (!FusionCompareString(pwzElementNameNS, POLICY_TAG_ASSEMBLYBINDING))) {

                     if (_bHonorAppliesTo) {
                         hr = ProcessAssemblyBindingTag(aNodeInfo, cNumRecs);
                         if (FAILED(hr)) {
                             goto Exit;
                         }
                     }

                     _dwState = PSTATE_ASSEMBLYBINDING;
                 }

                 break;

             case PSTATE_ASSEMBLYBINDING:
                 // In <assemblyBinding> tag.
                 if (_bCorVersionMatch) {
                     if ((_dwCurDepth == XML_PROBING_DEPTH) &&
                         (!FusionCompareString(pwzElementNameNS, POLICY_TAG_PROBING))) {

                         hr = ProcessProbingTag(aNodeInfo, cNumRecs);
                         if (FAILED(hr)) {
                             goto Exit;
                         }
                     }
#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
                     else if ((_dwCurDepth == XML_QUALIFYASSEMBLY_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_QUALIFYASSEMBLY))) {
                         hr = ProcessQualifyAssemblyTag(aNodeInfo, cNumRecs);
                         if (FAILED(hr)) {
                             goto Exit;
                         }
                     }
#endif
                     else if ((_dwCurDepth == XML_GLOBAL_PUBLISHERPOLICY_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_PUBLISHERPOLICY))) {

                         hr = ProcessPublisherPolicyTag(aNodeInfo, cNumRecs, TRUE);
                         if (FAILED(hr)) {
                             goto Exit;
                         }
                     }
                     else if ((_dwCurDepth == XML_DEPENDENTASSEMBLY_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_DEPENDENTASSEMBLY))) {

                         // Create new assembly info struct

                         ASSERT(!_pAsmInfo);
    
                         _pAsmInfo = NEW(CAsmBindingInfo);
                         if (!_pAsmInfo) {
                             hr = E_OUTOFMEMORY;
                             goto Exit;
                         }

                         // Transition state
    
                         _dwState = PSTATE_DEPENDENTASSEMBLY;
                     }
                }
                break;

             case PSTATE_DEPENDENTASSEMBLY:
                 // In <dependentAssembly> tag.
                if (_bCorVersionMatch) {
                     if ((_dwCurDepth == XML_ASSEMBLYIDENTITY_DEPTH) &&
                         (!FusionCompareString(pwzElementNameNS, POLICY_TAG_ASSEMBLYIDENTITY))) {

                         hr = ProcessAssemblyIdentityTag(aNodeInfo, cNumRecs);
                         if (hr == HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT)) {
                             DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_ASSEMBLYIDENTITY_MISSING_NAME);
                             hr = S_OK;
                         }
                         else if (FAILED(hr)) {
                             goto Exit;
                         }
                     }
                     else if ((_dwCurDepth == XML_BINDINGREDIRECT_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_BINDINGREDIRECT))) {

                         pRedirInfo = NEW(CBindingRedir);
                         if (!pRedirInfo) {
                             hr = E_OUTOFMEMORY;
                             goto Exit;
                         }
                    
                         hr = ProcessBindingRedirectTag(aNodeInfo, cNumRecs, pRedirInfo);
                         if (hr == S_OK) {
                             (_pAsmInfo->_listBindingRedir).AddTail(pRedirInfo);
                             pRedirInfo = NULL;
                         }
                         else if (hr == HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT)) {
                             SAFEDELETE(pRedirInfo);
                             DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_BINDINGREDIRECT_INSUFFICIENT_DATA);
                             hr = S_OK;
                         }
                         else if (FAILED(hr)) {
                             SAFEDELETE(pRedirInfo);
                             goto Exit;
                         }
                     }
                     else if ((_dwCurDepth == XML_BINDINGRETARGET_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_BINDINGRETARGET))) {
                         pRetargetInfo = NEW(CBindingRetarget);
                         if (!pRetargetInfo) {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                         }

                         hr = ProcessBindingRetargetTag(aNodeInfo, cNumRecs, pRetargetInfo);
                         if (hr == S_OK) {
                             (_pAsmInfo->_listBindingRetarget).AddTail(pRetargetInfo);
                             pRetargetInfo = NULL;
                         }
                         else if (hr == HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT)) {
                             SAFEDELETE(pRetargetInfo);
                             DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_BINDINGRETARGET_INSUFFICIENT_DATA);
                             hr = S_OK;
                         }
                         else if (FAILED(hr)) {
                             SAFEDELETE(pRetargetInfo);
                             goto Exit;
                        }
                     }
                     else if ((_dwCurDepth == XML_CODEBASE_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_CODEBASE))) {

                         pCodebaseInfo = NEW(CCodebaseHint);
                         if (!pCodebaseInfo) {
                             hr = E_OUTOFMEMORY;
                             goto Exit;
                         }

                         hr = ProcessCodebaseTag(aNodeInfo, cNumRecs, pCodebaseInfo);
                         if (hr == S_OK) {
                             (_pAsmInfo->_listCodebase).AddTail(pCodebaseInfo);
                             pCodebaseInfo = NULL;
                         }
                         else if (hr == HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT)) {
                             DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_CODEBASE_HREF_MISSING);
                             SAFEDELETE(pCodebaseInfo);
                             hr = S_OK;
                         }
                         else if (FAILED(hr)) {
                             SAFEDELETE(pCodebaseInfo);
                             goto Exit;
                         }
                     }
                     else if ((_dwCurDepth == XML_PUBLISHERPOLICY_DEPTH) &&
                              (!FusionCompareString(pwzElementNameNS, POLICY_TAG_PUBLISHERPOLICY))) {

                         hr = ProcessPublisherPolicyTag(aNodeInfo, cNumRecs, FALSE);
                         if (FAILED(hr)) {
                             goto Exit;
                         }
                     }
                 }
                 break;

           default:
                // Unknown state!

                ASSERT(0);
                
                hr = E_UNEXPECTED;
                break;
        }
    }

Exit:
    SAFEDELETEARRAY(pwzElementNameNS);

    return hr;
}

extern pfnGetCORVersion g_pfnGetCORVersion; 

HRESULT CNodeFactory::ProcessAssemblyBindingTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
    HRESULT     hr = S_OK;
    USHORT      idx = 1;
    LPWSTR      pwzAttributeNS = NULL;
    // list of runtimes this config applies to
    LPWSTR      pwzAppliesList = NULL;
    LPWSTR      pwzCorVersion = NULL;
    DWORD       dwSize = 0;
    LPWSTR      pwzBuf = NULL;
    DWORD       cchBuf = 0;
    LPWSTR      pwzVer = NULL;
    DWORD       cchVer = 0;
 
    ASSERT(aNodeInfo && cNumRecs);
    _bCorVersionMatch = TRUE;

    while (idx < cNumRecs) 
    {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) 
        {
            // Found an attribute. Find out which one, and extract the data.
            // Node: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) 
                goto Exit;

            if (hr == S_FALSE) 
            {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_APPLIESTO)) 
            {
                SAFEDELETEARRAY(pwzAttributeNS);

                _bCorVersionMatch = FALSE;
                
                hr = ::ExtractXMLAttribute(&pwzAppliesList, aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) 
                    goto Exit;

                // nothing in appliesTo, treat it like it does not exist.
                if (!pwzAppliesList || !lstrlenW(pwzAppliesList)) {
                    goto Exit;
                }


                ASSERT(g_pfnGetCORVersion != NULL);
                hr = g_pfnGetCORVersion(pwzCorVersion, dwSize, &dwSize);
                if (SUCCEEDED(hr))
                {
                    hr = E_UNEXPECTED;
                    goto Exit;
                }
                else if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                {
                    pwzCorVersion = NEW(WCHAR[dwSize]);
                    if (!pwzCorVersion)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    hr = g_pfnGetCORVersion(pwzCorVersion, dwSize, &dwSize);
                }
                if (FAILED(hr))
                    goto Exit;
               
                pwzBuf = pwzAppliesList;
                cchBuf = lstrlenW(pwzAppliesList)+1;
                
                // Now we have something in the list, 
                // Let us compare. 
                while(CParseUtils::GetDelimitedToken(&pwzBuf, &cchBuf, &pwzVer, &cchVer, L';'))
                {
                    *(pwzVer + cchVer) = L'\0';
                    if(!FusionCompareStringI(pwzCorVersion, pwzVer))
                    {
                        _bCorVersionMatch = TRUE;
                        goto Exit;
                    }
                }
                goto Exit;
            }
            else 
            {
                SAFEDELETEARRAY(pwzAttributeNS);
                idx++;
            }
        }
        else 
        {
            idx++;
        }
    }

Exit:  
    SAFEDELETEARRAY(pwzAppliesList);
    SAFEDELETEARRAY(pwzCorVersion);
    return hr;
}

HRESULT CNodeFactory::ProcessProbingTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
    HRESULT                                            hr = S_OK;
    USHORT                                             idx = 1;
    LPWSTR                                             pwzAttribute = NULL;
    LPWSTR                                             pwzAttributeNS = NULL;

    ASSERT(aNodeInfo && cNumRecs);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Node: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_PRIVATEPATH)) {
                SAFEDELETEARRAY(pwzAttributeNS);
                
                if (_pwzPrivatePath) {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_PRIVATE_PATH_DUPLICATE);
                    idx++;
                }
                else {
                    hr = ::ExtractXMLAttribute(&_pwzPrivatePath, aNodeInfo, &idx, cNumRecs);
                    if (FAILED(hr)) {
                        goto Exit;
                    }
                }
            }
            else {
                SAFEDELETEARRAY(pwzAttributeNS);
                idx++;
            }
        }
        else {
            idx++;
        }
    }

Exit:
    return hr;
}

#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
HRESULT CNodeFactory::ProcessQualifyAssemblyTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs)
{
    HRESULT                                            hr = S_OK;
    USHORT                                             idx = 1;
    LPWSTR                                             pwzAttribute = NULL;
    LPWSTR                                             pwzAttributeNS = NULL;
    LPWSTR                                             pwzPartialName = NULL;
    LPWSTR                                             pwzFullName = NULL;
    CQualifyAssembly                                  *pqa = NULL;
    IAssemblyName                                     *pNameFull = NULL;
    IAssemblyName                                     *pNamePartial = NULL;
    IAssemblyName                                     *pNameQualified = NULL;
    LPWSTR                                             wzCanonicalDisplayName=NULL;

    ASSERT(aNodeInfo && cNumRecs);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Node: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_PARTIALNAME)) {
                SAFEDELETEARRAY(pwzAttributeNS);

                if (pwzPartialName) {
                    // Ignore duplicate attribute
                    idx++;
                }
                else {
                    hr = ::ExtractXMLAttribute(&pwzPartialName, aNodeInfo, &idx, cNumRecs);
                    if (FAILED(hr)) {
                        goto Exit;
                    }
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_FULLNAME)) {
                SAFEDELETEARRAY(pwzAttributeNS);

                if (pwzFullName) {
                    // Ignore duplicate attribute
                    idx++;
                }
                else {
                    hr = ::ExtractXMLAttribute(&pwzFullName, aNodeInfo, &idx, cNumRecs);
                    if (FAILED(hr)) {
                        goto Exit;
                    }
                }

            }
            else {
                SAFEDELETEARRAY(pwzAttributeNS);
                idx++;
            }
        }
        else {
            idx++;
        }
    }

    if (pwzPartialName && pwzFullName) {
        DWORD                               dwSize;
        DWORD                               adwProperties[] = { ASM_NAME_NAME,
                                                                ASM_NAME_MAJOR_VERSION,
                                                                ASM_NAME_MINOR_VERSION,
                                                                ASM_NAME_BUILD_NUMBER,
                                                                ASM_NAME_REVISION_NUMBER,
                                                                ASM_NAME_CULTURE,
                                                                ASM_NAME_PUBLIC_KEY_TOKEN
                                                                ,
                                                                ASM_NAME_RETARGET
                                                                };
        DWORD                               adwCmpFlags[] = {   ASM_CMPF_NAME,
                                                                ASM_CMPF_MAJOR_VERSION,
                                                                ASM_CMPF_MINOR_VERSION,
                                                                ASM_CMPF_BUILD_NUMBER,
                                                                ASM_CMPF_REVISION_NUMBER,
                                                                ASM_CMPF_CULTURE,
                                                                ASM_CMPF_PUBLIC_KEY_TOKEN
                                                                ,
                                                                ASM_CMPF_RETARGET
                                                                };
        DWORD                               dwNumProps = sizeof(adwProperties) / sizeof(adwProperties[0]);

        if (FAILED(hr = CreateAssemblyNameObject(&pNameFull, pwzFullName,
                                            CANOF_PARSE_DISPLAY_NAME, 0))) {
            goto Exit;
        }

        if (FAILED(hr = CreateAssemblyNameObject(&pNamePartial, pwzPartialName,
                                            CANOF_PARSE_DISPLAY_NAME, 0))) {
            goto Exit;
        }

        // Check validity of qualification

        if (CAssemblyName::IsPartial(pNameFull) || !CAssemblyName::IsPartial(pNamePartial)) {
            goto Exit;
        }

        if (FAILED(hr = pNamePartial->Clone(&pNameQualified))) {
            goto Exit;
        }

        for (DWORD i = 0; i < dwNumProps; i++) {
            dwSize = 0;
            if (pNamePartial->GetProperty(adwProperties[i], NULL, &dwSize) != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                // Partial on this field. Set pNameQualified's corresponding
                // property to whatever is in pNameFull.

                dwSize = 0;
                pNameFull->GetProperty(adwProperties[i], NULL, &dwSize);
                if (!dwSize) {
                    if (adwProperties[i] == ASM_NAME_RETARGET) {
                            continue;
                    }
                    else {
                            hr = E_UNEXPECTED;
                            goto Exit;
                    }
                }
                else {
                    BYTE                       *pBuf;

                    pBuf = NEW(BYTE[dwSize]);
                    if (!pBuf) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    if (FAILED(hr = pNameFull->GetProperty(adwProperties[i], pBuf, &dwSize))) {
                        SAFEDELETEARRAY(pBuf);
                        goto Exit;
                    }

                    if (FAILED(hr = pNameQualified->SetProperty(adwProperties[i], pBuf, dwSize))) {
                        SAFEDELETEARRAY(pBuf);
                        goto Exit;
                    }

                    SAFEDELETEARRAY(pBuf);
                }
            }
            else {
                // Full-specified on this field. Make sure it matches the full ref specified.

                if ((hr = pNamePartial->IsEqual(pNameFull, adwCmpFlags[i])) != S_OK) {
                    goto Exit;
                }
            }
        }

        if (CAssemblyName::IsPartial(pNameQualified)) {
            goto Exit;
        }

        // Get canonical display name format

        wzCanonicalDisplayName = NEW(WCHAR[MAX_URL_LENGTH+1]);
        if (!wzCanonicalDisplayName)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        dwSize = MAX_URL_LENGTH;
        if (FAILED(hr = pNamePartial->GetDisplayName(wzCanonicalDisplayName, &dwSize, 0))) {
            goto Exit;
        }

        // Add qualified assembly entry to list

        pqa = new CQualifyAssembly;
        if (!pqa) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pqa->_pwzPartialName = WSTRDupDynamic(wzCanonicalDisplayName);
        if (!pqa->_pwzPartialName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pqa->_pNameFull = pNameQualified;
        pNameQualified->AddRef();

        _listQualifyAssembly.AddTail(pqa);
    }

Exit:
    SAFEDELETEARRAY(pwzPartialName);
    SAFEDELETEARRAY(pwzFullName);

    SAFERELEASE(pNameFull);
    SAFERELEASE(pNamePartial);
    SAFERELEASE(pNameQualified);

    SAFEDELETEARRAY(wzCanonicalDisplayName);
    return hr;
}
#endif


HRESULT CNodeFactory::ProcessBindingRedirectTag(XML_NODE_INFO **aNodeInfo,
                                                USHORT cNumRecs,
                                                CBindingRedir *pRedir)
{
    HRESULT                                            hr = S_OK;
    LPWSTR                                             pwzAttributeNS = NULL;
    USHORT                                             idx = 1;

    ASSERT(aNodeInfo && cNumRecs && pRedir);
    ASSERT(!pRedir->_pwzVersionOld && !pRedir->_pwzVersionNew);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Note: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_OLDVERSION)) {

                hr = ::ExtractXMLAttribute(&(pRedir->_pwzVersionOld), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_NEWVERSION)) {

                hr = ::ExtractXMLAttribute(&(pRedir->_pwzVersionNew), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else {
                idx++;
            }
            
            SAFEDELETEARRAY(pwzAttributeNS);
        }
        else {
            idx++;
        }
    }

    if (!pRedir->_pwzVersionOld || !pRedir->_pwzVersionNew) {
        // Data was incomplete. These are required fields.

        hr = HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT);
        goto Exit;
    }

Exit:
    return hr;    
}

HRESULT CNodeFactory::ProcessBindingRetargetTag(XML_NODE_INFO **aNodeInfo,
                                                USHORT cNumRecs,
                                                CBindingRetarget *pRetarget)
{
    HRESULT                                            hr = S_OK;
    LPWSTR                                             pwzAttributeNS = NULL;
    USHORT                                             idx = 1;

    ASSERT(aNodeInfo && cNumRecs && pRetarget);
    ASSERT(!pRetarget->_pwzVersionOld && !pRetarget->_pwzVersionNew&&!pRetarget->_pwzPublicKeyTokenNew);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Note: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_OLDVERSION)) {

                hr = ::ExtractXMLAttribute(&(pRetarget->_pwzVersionOld), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_NEWVERSION)) {

                hr = ::ExtractXMLAttribute(&(pRetarget->_pwzVersionNew), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_NEWPUBLICKEYTOKEN)) {

                hr = ::ExtractXMLAttribute(&(pRetarget->_pwzPublicKeyTokenNew), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_NEWNAME)) {

                hr = ::ExtractXMLAttribute(&(pRetarget->_pwzNameNew), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else {
                idx++;
            }
            
            SAFEDELETEARRAY(pwzAttributeNS);
        }
        else {
            idx++;
        }
    }

    if (!pRetarget->_pwzVersionOld || !pRetarget->_pwzVersionNew|| !pRetarget->_pwzPublicKeyTokenNew) {
        // Data was incomplete. These are required fields.

        hr = HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT);
        goto Exit;
    }

Exit:
    return hr;    
}

HRESULT CNodeFactory::ProcessCodebaseTag(XML_NODE_INFO **aNodeInfo,
                                         USHORT cNumRecs,
                                         CCodebaseHint *pCB)
{
    HRESULT                                            hr = S_OK;
    LPWSTR                                             pwzAttributeNS = NULL;
    USHORT                                             idx = 1;

    ASSERT(aNodeInfo && cNumRecs && pCB);
    ASSERT(!pCB->_pwzVersion && !pCB->_pwzCodebase);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Note: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_VERSION)) {

                hr = ::ExtractXMLAttribute(&(pCB->_pwzVersion), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_HREF)) {

                hr = ::ExtractXMLAttribute(&(pCB->_pwzCodebase), aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }
            }
            else {
                idx++;
            }

            SAFEDELETEARRAY(pwzAttributeNS);
        }
        else {
            idx++;
        }
    }

    if (!pCB->_pwzCodebase) {
        // Data was incomplete. 

        hr = HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT);
        goto Exit;
    }

Exit:
    return hr;    
}

HRESULT CNodeFactory::ProcessPublisherPolicyTag(XML_NODE_INFO **aNodeInfo,
                                                USHORT cNumRecs,
                                                BOOL bGlobal)
{
    HRESULT                                            hr = S_OK;
    LPWSTR                                             pwzAttributeNS = NULL;
    LPWSTR                                             pwzTmp = NULL;
    USHORT                                             idx = 1;

    ASSERT(aNodeInfo && cNumRecs);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Node: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_APPLY)) {
                hr = ::ExtractXMLAttribute(&pwzTmp, aNodeInfo, &idx, cNumRecs);
                if (FAILED(hr)) {
                    SAFEDELETEARRAY(pwzAttributeNS);
                    goto Exit;
                }

                if (pwzTmp && !FusionCompareString(pwzTmp, L"no")) {
                    if (bGlobal) {
                        _bGlobalSafeMode = TRUE;
                    }
                    else {
                        _pAsmInfo->_bApplyPublisherPolicy = FALSE;
                    }
                }

                SAFEDELETEARRAY(pwzTmp);
            }
            else {
                idx++;
            }

            SAFEDELETEARRAY(pwzAttributeNS);
        }
        else {
            idx++;
        }
    }

Exit:
    return hr;
}

HRESULT CNodeFactory::ProcessAssemblyIdentityTag(XML_NODE_INFO **aNodeInfo,
                                                 USHORT cNumRecs)
{
    HRESULT                                            hr = S_OK;
    LPWSTR                                             pwzAttributeNS = NULL;
    USHORT                                             idx = 1;

    ASSERT(aNodeInfo && cNumRecs && _pAsmInfo);

    while (idx < cNumRecs) {
        if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE) {
            // Found an attribute. Find out which one, and extract the data.
            // Note: ::ExtractXMLAttribute increments idx.

            hr = ApplyNamespace(aNodeInfo[idx], &pwzAttributeNS, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (hr == S_FALSE) {
                // encountered xmlns attribute. pwzAttributeNS will be NULL
                ASSERT(!pwzAttributeNS);
                idx++;
                hr = S_OK;
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_NAME)) {

                if (!_pAsmInfo->_pwzName) {
                    hr = ::ExtractXMLAttribute(&(_pAsmInfo->_pwzName), aNodeInfo, &idx, cNumRecs);
                    if (FAILED(hr)) {
                        SAFEDELETEARRAY(pwzAttributeNS);
                        goto Exit;
                    }
                }
                else {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_MULTIPLE_IDENTITIES);
                    hr = E_FAIL;
                    goto Exit;
                }
            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_PUBLICKEYTOKEN)) {
                if (!_pAsmInfo->_pwzPublicKeyToken) {
                    hr = ::ExtractXMLAttribute(&(_pAsmInfo->_pwzPublicKeyToken), aNodeInfo, &idx, cNumRecs);
                    if (FAILED(hr)) {
                        SAFEDELETEARRAY(pwzAttributeNS);
                        goto Exit;
                    }
                }
                else {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_MULTIPLE_IDENTITIES);
                    hr = E_FAIL;
                    goto Exit;
                }

            }
            else if (!FusionCompareString(pwzAttributeNS, XML_ATTRIBUTE_CULTURE)) {
                if (!_pAsmInfo->_pwzCulture) {
                    hr = ::ExtractXMLAttribute(&(_pAsmInfo->_pwzCulture), aNodeInfo, &idx, cNumRecs);
                    if (FAILED(hr)) {
                        SAFEDELETEARRAY(pwzAttributeNS);
                        goto Exit;
                    }

                    // Change all synonyms for culture=neutral/"" to unset

                    if (_pAsmInfo->_pwzCulture && (!lstrlenW(_pAsmInfo->_pwzCulture) || !FusionCompareStringI(_pAsmInfo->_pwzCulture, CFG_CULTURE_NEUTRAL))) {
                        SAFEDELETEARRAY(_pAsmInfo->_pwzCulture);
                    }
                }
                else {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_XML_MULTIPLE_IDENTITIES);
                    hr = E_FAIL;
                    goto Exit;
                }
            }
            else {
                idx++;
            }

            SAFEDELETEARRAY(pwzAttributeNS);
        }
        else {
            idx++;
        }
    }

    if (!_pAsmInfo->_pwzName) {

        // Data was incomplete. 

        hr = HRESULT_FROM_WIN32(ERROR_TAG_NOT_PRESENT);
        goto Exit;
    }

Exit:
    return hr;    
}

HRESULT CNodeFactory::GetSharedPath(LPWSTR *ppwzSharedPath)
{
    HRESULT                                     hr = S_OK;

    // BUGBUG: get rid of this

    if (!ppwzSharedPath) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppwzSharedPath = NULL;

    hr = S_FALSE;

Exit:
    return hr;
}

HRESULT CNodeFactory::GetPrivatePath(LPWSTR *ppwzPrivatePath)
{
    HRESULT                                     hr = S_OK;

    if (!ppwzPrivatePath) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppwzPrivatePath = NULL;

    if (!_pwzPrivatePath) {
        hr = S_FALSE;
        goto Exit;
    }
    
    *ppwzPrivatePath = WSTRDupDynamic(_pwzPrivatePath);
    if (!*ppwzPrivatePath) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}

        
HRESULT CNodeFactory::GetPolicyVersion(LPCWSTR wzAssemblyName,
                                       LPCWSTR wzPublicKeyToken,
                                       LPCWSTR wzCulture,
                                       LPCWSTR wzVersionIn,
                                       LPWSTR *ppwzVersionOut)
{
    HRESULT                                hr = S_OK;
    LISTNODE                               pos = NULL;
    LISTNODE                               posVer = NULL;
    LPCWSTR                                pwzCultureFormatted = NULL;
    CBindingRedir                         *pRedir = NULL;
    CAsmBindingInfo                       *pAsmInfo = NULL;

    if (!wzAssemblyName || !wzPublicKeyToken || !wzVersionIn || !ppwzVersionOut) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (wzCulture && (!FusionCompareStringI(wzCulture, CFG_CULTURE_NEUTRAL) || !lstrlenW(wzCulture))) {
        pwzCultureFormatted = NULL;
    }
    else {
        pwzCultureFormatted = wzCulture;
    }

    *ppwzVersionOut = NULL;

    pos = _listAsmInfo.GetHeadPosition();
    while (pos) {
        pAsmInfo = _listAsmInfo.GetNext(pos);
        ASSERT(pAsmInfo);

        if ((!FusionCompareStringI(wzAssemblyName, pAsmInfo->_pwzName) &&
            (pAsmInfo->_pwzPublicKeyToken && !FusionCompareStringI(wzPublicKeyToken, pAsmInfo->_pwzPublicKeyToken)) &&
            ((pwzCultureFormatted && pAsmInfo->_pwzCulture && !FusionCompareStringI(pwzCultureFormatted, pAsmInfo->_pwzCulture)) ||
             (!pwzCultureFormatted && !pAsmInfo->_pwzCulture)))) {

            // Match found. 

            // Look for matching version.

            posVer = (pAsmInfo->_listBindingRedir).GetHeadPosition();
            while (posVer) {
                pRedir = (pAsmInfo->_listBindingRedir).GetNext(posVer);

                if (IsMatchingVersion(pRedir->_pwzVersionOld, wzVersionIn)) {

                    // Match found

                    *ppwzVersionOut = WSTRDupDynamic(pRedir->_pwzVersionNew);
                    if (!*ppwzVersionOut) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    goto Exit;
                }
            }

            // We could break out of the loop here, but this prevents
            // multiple matches (ie. XML had many identical <dependentAssembly>
            // tags...
        }
    }

    // If we got here, we didn't find a match. Input Version == Output Version

    *ppwzVersionOut = WSTRDupDynamic(wzVersionIn);
    if (!*ppwzVersionOut) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = S_FALSE;
    
Exit:
    return hr;
}

HRESULT CNodeFactory::GetRetargetedAssembly(LPCWSTR wzAssemblyNameIn,    LPCWSTR wzPublicKeyTokenIn, LPCWSTR wzCulture, LPCWSTR wzVersionIn,
                                            LPWSTR *ppwzAssemblyNameOut, LPWSTR *ppwzPublicKeyTokenOut, LPWSTR *ppwzVersionOut)
{
    HRESULT                                hr = S_OK;
    LISTNODE                               pos = NULL;
    LISTNODE                               posVer = NULL;
    LPCWSTR                                pwzCultureFormatted = NULL;
    CBindingRetarget                      *pRetarget = NULL;
    CAsmBindingInfo                       *pAsmInfo = NULL;

    if (!wzAssemblyNameIn || !wzPublicKeyTokenIn || !wzVersionIn || !ppwzVersionOut || !ppwzPublicKeyTokenOut) 
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (wzCulture && (!FusionCompareStringI(wzCulture, CFG_CULTURE_NEUTRAL) || !lstrlenW(wzCulture))) {
        pwzCultureFormatted = NULL;
    }
    else {
        pwzCultureFormatted = wzCulture;
    }

    *ppwzPublicKeyTokenOut = NULL;
    *ppwzVersionOut = NULL;
    if (ppwzAssemblyNameOut)
        *ppwzAssemblyNameOut = NULL;

    pos = _listAsmInfo.GetHeadPosition();
    while (pos) {
        pAsmInfo = _listAsmInfo.GetNext(pos);
        ASSERT(pAsmInfo);

        if ((!FusionCompareStringI(wzAssemblyNameIn, pAsmInfo->_pwzName) &&
            (pAsmInfo->_pwzPublicKeyToken && !FusionCompareStringI(wzPublicKeyTokenIn, pAsmInfo->_pwzPublicKeyToken)) &&
            ((pwzCultureFormatted && pAsmInfo->_pwzCulture && !FusionCompareStringI(pwzCultureFormatted, pAsmInfo->_pwzCulture)) ||
             (!pwzCultureFormatted && !pAsmInfo->_pwzCulture)))) {

            // Match found. 

            // Look for matching version.

            posVer = (pAsmInfo->_listBindingRetarget).GetHeadPosition();
            while (posVer) {
                pRetarget = (pAsmInfo->_listBindingRetarget).GetNext(posVer);

                if (IsMatchingVersion(pRetarget->_pwzVersionOld, wzVersionIn)) {

                    // Match found

                    *ppwzVersionOut = WSTRDupDynamic(pRetarget->_pwzVersionNew);
                    if (!*ppwzVersionOut) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    *ppwzPublicKeyTokenOut = WSTRDupDynamic(pRetarget->_pwzPublicKeyTokenNew);
                    if (!*ppwzPublicKeyTokenOut) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    if (ppwzAssemblyNameOut) {
                        if (pRetarget->_pwzNameNew) {
                            *ppwzAssemblyNameOut = WSTRDupDynamic(pRetarget->_pwzNameNew);
                        }
                        else {
                            *ppwzAssemblyNameOut = WSTRDupDynamic(wzAssemblyNameIn);
                        }

                        if (!*ppwzAssemblyNameOut) {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }
                    }
                        
                    goto Exit;
                }
            }

            // We could break out of the loop here, but this prevents
            // multiple matches (ie. XML had many identical <dependentAssembly>
            // tags...
        }
    }

    // If we got here, we didn't find a match. For retarget, this is a fatal error.
    hr = FUSION_E_INVALID_NAME;
    
Exit:
    if (FAILED(hr))
    {
        SAFEDELETEARRAY(*ppwzVersionOut);
        SAFEDELETEARRAY(*ppwzPublicKeyTokenOut);
        if (ppwzAssemblyNameOut)
            SAFEDELETEARRAY(*ppwzAssemblyNameOut);
    }
    return hr;
}

HRESULT CNodeFactory::GetSafeMode(LPCWSTR wzAssemblyName, LPCWSTR wzPublicKeyToken,
                                  LPCWSTR wzCulture, LPCWSTR wzVersionIn,
                                  BOOL *pbSafeMode)
{
    HRESULT                                hr = S_OK;
    LISTNODE                               pos = NULL;
    LISTNODE                               posVer = NULL;
    LPCWSTR                                pwzCultureFormatted = NULL;
    CBindingRedir                         *pRedir = NULL;
    CAsmBindingInfo                       *pAsmInfo = NULL;

    if (!wzAssemblyName || !wzPublicKeyToken || !wzVersionIn || !pbSafeMode) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (wzCulture && (!FusionCompareStringI(wzCulture, CFG_CULTURE_NEUTRAL) || !lstrlenW(wzCulture))) {
        pwzCultureFormatted = NULL;
    }
    else {
        pwzCultureFormatted = wzCulture;
    }
    
    if (_bGlobalSafeMode) {
        // Global safe mode is set

        *pbSafeMode = TRUE;
        goto Exit;
    }

    *pbSafeMode = FALSE;

    // Look for per-assembly safemode. If safe mode is set in any matching
    // section, then safe mode is enabled.

    pos = _listAsmInfo.GetHeadPosition();
    while (pos) {
        pAsmInfo = _listAsmInfo.GetNext(pos);
        ASSERT(pAsmInfo);

        if ((!FusionCompareStringI(wzAssemblyName, pAsmInfo->_pwzName) &&
            (pAsmInfo->_pwzPublicKeyToken && !FusionCompareStringI(wzPublicKeyToken, pAsmInfo->_pwzPublicKeyToken)) &&
            ((pwzCultureFormatted && pAsmInfo->_pwzCulture && !FusionCompareStringI(pwzCultureFormatted, pAsmInfo->_pwzCulture)) ||
             (!pwzCultureFormatted && !pAsmInfo->_pwzCulture)))) {

            // Match found. 

            if (!*pbSafeMode) {
                *pbSafeMode = (pAsmInfo->_bApplyPublisherPolicy == FALSE);
            }
        }
    }

Exit:
    return hr;
}

HRESULT CNodeFactory::GetCodebaseHint(LPCWSTR pwzAsmName, LPCWSTR pwzVersion,
                                      LPCWSTR pwzPublicKeyToken, LPCWSTR pwzCulture,
                                      LPCWSTR pwzAppBase, LPWSTR *ppwzCodebase)
{
    HRESULT                                   hr = S_OK;
    LISTNODE                                  pos = NULL;
    LISTNODE                                  posCB = NULL;
    LPCWSTR                                   pwzCultureFormatted;
    LPWSTR                                    wzCombined=NULL;
    LPWSTR                                    pwzAppBaseCombine=NULL;
    DWORD                                     dwSize;
    DWORD                                     dwLen;
    CAsmBindingInfo                          *pAsmInfo = NULL;
    CCodebaseHint                            *pCodebase = NULL;

    if (!pwzAsmName || (pwzPublicKeyToken && !pwzVersion) || !ppwzCodebase || !pwzAppBase) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    if (pwzCulture && (!FusionCompareStringI(pwzCulture, CFG_CULTURE_NEUTRAL) || !lstrlenW(pwzCulture))) {
        pwzCultureFormatted = NULL;
    }
    else {
        pwzCultureFormatted = pwzCulture;
    }

    *ppwzCodebase = NULL;

    wzCombined = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzCombined)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwLen = lstrlenW(pwzAppBase); 
    if (!dwLen) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pwzAppBaseCombine = NEW(WCHAR[dwLen + 2]); // Allocate room for potential trailing '/'
    if (!pwzAppBaseCombine) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(pwzAppBaseCombine, dwLen + 2, L"%ws%ws", pwzAppBase,
               (pwzAppBase[dwLen - 1] == L'\\' || pwzAppBase[dwLen - 1] == L'/') ? (L"") : (L"/"));

    pos = _listAsmInfo.GetHeadPosition();
    while (pos) {
        pAsmInfo = _listAsmInfo.GetNext(pos);
        ASSERT(pAsmInfo);

        if ((!FusionCompareStringI(pwzAsmName, pAsmInfo->_pwzName)) &&
            ((pwzPublicKeyToken && pAsmInfo->_pwzPublicKeyToken && !FusionCompareStringI(pwzPublicKeyToken, pAsmInfo->_pwzPublicKeyToken))
             || (!pwzPublicKeyToken && !pAsmInfo->_pwzPublicKeyToken)) &&
            ((pwzCultureFormatted && pAsmInfo->_pwzCulture && !FusionCompareStringI(pwzCultureFormatted, pAsmInfo->_pwzCulture))
             || (!pwzCultureFormatted && !pAsmInfo->_pwzCulture))) {

             // Match found.

            posCB = (pAsmInfo->_listCodebase).GetHeadPosition();
            while (posCB) {
                pCodebase = (pAsmInfo->_listCodebase).GetNext(posCB);
                ASSERT(pCodebase);

                if (!pwzPublicKeyToken) {
                    // No PublicKeyToken, take the first codebase (version ignored).

                    dwSize = MAX_URL_LENGTH;
                    hr = UrlCombineUnescape(pwzAppBaseCombine, pCodebase->_pwzCodebase,
                                            wzCombined, &dwSize, 0);
                    if (FAILED(hr)) {
                        goto Exit;
                    }

                    *ppwzCodebase = WSTRDupDynamic(wzCombined);
                    if (!*ppwzCodebase) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    goto Exit;
                }
                else {
                    // Match version.

                    if (pCodebase->_pwzVersion && !FusionCompareStringI(pwzVersion, pCodebase->_pwzVersion)) {
                        // Match found.

                        dwSize = MAX_URL_LENGTH;
                        hr = UrlCombineUnescape(pwzAppBaseCombine, pCodebase->_pwzCodebase,
                                                wzCombined, &dwSize, 0);
                        if (FAILED(hr)) {
                            goto Exit;
                        }                                                

                        *ppwzCodebase = WSTRDupDynamic(wzCombined);
                        if (!*ppwzCodebase) {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                        }

                        goto Exit;
                    }
                }
            }
        }
    }

    // Did not find codebase hint.

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(wzCombined);
    SAFEDELETEARRAY(pwzAppBaseCombine);

    return hr;
}

HRESULT CNodeFactory::ApplyNamespace(XML_NODE_INFO *pNodeInfo, LPWSTR *ppwzTokenNS,
                                     DWORD dwFlags) 
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   pwzToken = NULL;

    ASSERT(pNodeInfo && ppwzTokenNS);

    if (!FusionCompareStringN(pNodeInfo->pwcText, XML_NAMESPACE_TAG, XML_NAMESPACE_TAG_LEN)) {
        hr = S_FALSE;
        goto Exit;
    }

    pwzToken = NEW(WCHAR[pNodeInfo->ulLen + 1]);
    if (!pwzToken) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    StrCpyNW(pwzToken, pNodeInfo->pwcText, pNodeInfo->ulLen + 1);

    hr = _nsmgr.Map(pwzToken, ppwzTokenNS, dwFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(pwzToken);

    return hr;
}

#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
HRESULT CNodeFactory::QualifyAssembly(LPCWSTR pwzDisplayName, IAssemblyName **ppNameQualified, CDebugLog *pdbglog)
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   wzDispName=NULL;
    DWORD                                    dwSize;
    CQualifyAssembly                        *pqa;
    LISTNODE                                 pos;

    wzDispName = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzDispName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pos = _listQualifyAssembly.GetHeadPosition();
    while (pos) {
        pqa = _listQualifyAssembly.GetNext(pos);
        if (!FusionCompareString(pwzDisplayName, pqa->_pwzPartialName)) {
            // Found match

            *ppNameQualified = pqa->_pNameFull;
            (*ppNameQualified)->AddRef();

            dwSize = MAX_URL_LENGTH;
            if ((*ppNameQualified)->GetDisplayName(wzDispName, &dwSize, 0) == S_OK) {
                DEBUGOUT1(pdbglog, 0, ID_FUSLOG_QUALIFIED_ASSEMBLY, wzDispName);
            }

            goto Exit;
        }
    }

    // No match found

    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

Exit:
    SAFEDELETEARRAY(wzDispName);
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\iniwrite.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "iniwrite.h"
#include "history.h"
#include "util.h"
#include "helpers.h"

extern DWORD g_dwMaxAppHistory;

CIniWriter::CIniWriter()
: _pwzFileName(NULL)
{
    _dwSig = 'WINI';
}

CIniWriter::~CIniWriter()
{
    SAFEDELETEARRAY(_pwzFileName);
}

HRESULT CIniWriter::Init(LPCWSTR pwzFileName)
{
    HRESULT                                     hr = S_OK;

    if (!pwzFileName) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    _pwzFileName = WSTRDupDynamic(pwzFileName);
    if (!_pwzFileName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CIniWriter::AddSnapShot(LPCWSTR wzActivationDate, LPCWSTR wzURTVersion)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      wzBuffer = NULL;
    LPWSTR                                      wzTagOld = NULL;
    LPWSTR                                      wzTagNew = NULL;
    DWORD                                       dwRet;
    DWORD                                       dwNumSnapShots;
    DWORD                                       idx;
    BOOL                                        bRet;

    if (!wzActivationDate) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzTagOld = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTagOld) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzTagNew = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzTagNew) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER, HEADER_DATA_NUM_SECTIONS,
                                       DEFAULT_INI_VALUE, &wzBuffer, _pwzFileName);
    if (!wzBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwNumSnapShots = StrToIntW(wzBuffer);

    for (idx = dwNumSnapShots; idx >= 1; idx--) {
        wnsprintfW(wzTagOld, MAX_INI_TAG_LENGTH, L"%ws_%d", FUSION_SNAPSHOT_PREFIX, idx);
        wnsprintfW(wzTagNew, MAX_INI_TAG_LENGTH, L"%ws_%d", FUSION_SNAPSHOT_PREFIX, idx + 1);

        SAFEDELETEARRAY(wzBuffer);
        dwRet = GetPrivateProfileStringExW(HISTORY_SECTION_HEADER,
                                           wzTagOld, DEFAULT_INI_VALUE,
                                           &wzBuffer, _pwzFileName);
        if (!wzBuffer) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (!FusionCompareStringI(wzBuffer, DEFAULT_INI_VALUE)) {
            // Expected old value to exist
            hr = E_UNEXPECTED;
        }

        if (idx >= g_dwMaxAppHistory) {
            // Delete this section.
            hr = DeleteSnapShot(wzBuffer);
            if (FAILED(hr)) {
                goto Exit;
            }

            // Delete the entry from the header
            bRet = WritePrivateProfileStringW(HISTORY_SECTION_HEADER, wzTagOld,
                                              NULL, _pwzFileName);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
        else {
            bRet = WritePrivateProfileStringW(HISTORY_SECTION_HEADER, wzTagNew,
                                              wzBuffer, _pwzFileName);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }                                              


    // Update number of entries

    if (dwNumSnapShots < g_dwMaxAppHistory) {
        dwNumSnapShots++;
    }
    else {
        dwNumSnapShots = g_dwMaxAppHistory;
    }

    wnsprintfW(wzTagNew, MAX_INI_TAG_LENGTH, L"%d", dwNumSnapShots);
    bRet = WritePrivateProfileStringW(HISTORY_SECTION_HEADER,
                                      HEADER_DATA_NUM_SECTIONS,
                                      wzTagNew, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Write new MRU snapshot in the header.
    
    wnsprintfW(wzTagNew, MAX_INI_TAG_LENGTH, L"%ws_%d", FUSION_SNAPSHOT_PREFIX, 1);

    bRet = WritePrivateProfileStringW(HISTORY_SECTION_HEADER, wzTagNew,
                                      wzActivationDate, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Create the new section

    bRet = WritePrivateProfileStringW(wzActivationDate, SNAPSHOT_DATA_URT_VERSION,
                                      wzURTVersion, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzBuffer);
    SAFEDELETEARRAY(wzTagOld);
    SAFEDELETEARRAY(wzTagNew);

    return hr;
}

HRESULT CIniWriter::DeleteSnapShot(LPCWSTR wzActivationDate)
{
    HRESULT                               hr = S_OK;
    LPWSTR                                wzBigBuffer = NULL;
    LPWSTR                                wzSection = NULL;
    DWORD                                 dwRet;
    BOOL                                  bRet;
    LPWSTR                                wzCurStr;

    dwRet = GetPrivateProfileStringExW(wzActivationDate, NULL, DEFAULT_INI_VALUE,
                                       &wzBigBuffer, _pwzFileName);
    if (!wzBigBuffer) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzCurStr = wzBigBuffer;
    while (lstrlen(wzCurStr)) {

        SAFEDELETEARRAY(wzSection);
        dwRet = GetPrivateProfileStringExW(wzActivationDate, wzCurStr, DEFAULT_INI_VALUE,
                                           &wzSection, _pwzFileName);
        if (!wzSection) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Delete the dependent section
        bRet = WritePrivateProfileStringW(wzSection, NULL, NULL, _pwzFileName);
        if (!bRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        // Iterate

        wzCurStr += (lstrlenW(wzCurStr) + 1);
    }

    // Delete the section itself

    bRet = WritePrivateProfileStringW(wzActivationDate, NULL, NULL, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzBigBuffer);
    SAFEDELETEARRAY(wzSection);

    return hr;
}
        
HRESULT CIniWriter::AddAssembly(LPCWSTR wzActivationDate, AsmBindHistoryInfo *pHistInfo)
{
    HRESULT                                  hr = S_OK;
    BOOL                                     bRet;
    LPWSTR                                   wzAsmTag = NULL;
    LPWSTR                                   wzSectionName = NULL;

    if (!wzActivationDate || !pHistInfo) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzAsmTag = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzAsmTag) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzSectionName = NEW(WCHAR[MAX_INI_TAG_LENGTH]);
    if (!wzSectionName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(wzAsmTag, MAX_INI_TAG_LENGTH, L"%ws%wc%ws%wc%ws%wc%ws", pHistInfo->wzAsmName,
               HISTORY_DELIMITER_CHAR, pHistInfo->wzPublicKeyToken,
               HISTORY_DELIMITER_CHAR, pHistInfo->wzCulture,
               HISTORY_DELIMITER_CHAR, pHistInfo->wzVerReference);
    wnsprintfW(wzSectionName, MAX_INI_TAG_LENGTH, L"%ws%wc%ws", wzActivationDate,
               HISTORY_DELIMITER_CHAR, wzAsmTag);

    // Create the section link to the asm version information
    
    bRet = WritePrivateProfileStringW(wzActivationDate, wzAsmTag, wzSectionName,
                                     _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Record version information in the assembly section

    bRet = WritePrivateProfileStringW(wzSectionName, ASSEMBLY_DATA_VER_REFERENCE,
                                      pHistInfo->wzVerReference, _pwzFileName);


    bRet = WritePrivateProfileStringW(wzSectionName, ASSEMBLY_DATA_VER_APP_CFG,
                                      pHistInfo->wzVerAppCfg, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    bRet = WritePrivateProfileStringW(wzSectionName, ASSEMBLY_DATA_VER_PUBLISHER_CFG,
                                      pHistInfo->wzVerPublisherCfg, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    bRet = WritePrivateProfileStringW(wzSectionName, ASSEMBLY_DATA_VER_ADMIN_CFG,
                                      pHistInfo->wzVerAdminCfg, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
                                                                                                               
Exit:
    SAFEDELETEARRAY(wzSectionName);
    SAFEDELETEARRAY(wzAsmTag);

    return hr;
}

HRESULT CIniWriter::InsertHeaderData(LPCWSTR wzExePath, LPCWSTR wzAppName)
{
    HRESULT                                     hr = S_OK;
    BOOL                                        bRet;

    if (!wzExePath || !wzAppName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    bRet = WritePrivateProfileStringW(HISTORY_SECTION_HEADER, HEADER_DATA_EXE_PATH,
                                      wzExePath, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    bRet = WritePrivateProfileStringW(HISTORY_SECTION_HEADER, HEADER_DATA_APP_NAME,
                                      wzAppName, _pwzFileName);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\pcycache.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "pcycache.h"
#include "helpers.h"
#include "appctx.h"
#include "lock.h"
#include "histinfo.h"

extern CRITICAL_SECTION g_csDownload;

//
// CPolicyMapping 
//

CPolicyMapping::CPolicyMapping(IAssemblyName *pNameSource, IAssemblyName *pNamePolicy,
                               AsmBindHistoryInfo *pBindHistory)
: _pNameRefSource(pNameSource)
, _pNameRefPolicy(pNamePolicy)
{
    if (_pNameRefSource) {
        _pNameRefSource->AddRef();
    }

    if (_pNameRefPolicy) {
        _pNameRefPolicy->AddRef();
    }

    memcpy(&_bindHistory, pBindHistory, sizeof(AsmBindHistoryInfo));
}

CPolicyMapping::~CPolicyMapping()
{
    SAFERELEASE(_pNameRefSource);
    SAFERELEASE(_pNameRefPolicy);
}

HRESULT CPolicyMapping::Create(IAssemblyName *pNameRefSource, IAssemblyName *pNameRefPolicy,
                               AsmBindHistoryInfo *pBindHistory, CPolicyMapping **ppMapping)
{
    HRESULT                                  hr = S_OK;
    IAssemblyName                           *pNameSource = NULL;
    IAssemblyName                           *pNamePolicy = NULL;
    CPolicyMapping                          *pMapping = NULL;


    if (!pNameRefSource || !pNameRefPolicy || !pBindHistory || !ppMapping) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppMapping = NULL;

    hr = pNameRefSource->Clone(&pNameSource);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNameRefPolicy->Clone(&pNamePolicy);
    if (FAILED(hr)) {
        goto Exit;
    }

    pMapping = NEW(CPolicyMapping(pNameSource, pNamePolicy, pBindHistory));
    if (!pMapping) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppMapping = pMapping;

Exit:
    SAFERELEASE(pNameSource);
    SAFERELEASE(pNamePolicy);

    return hr;
}

//
// CPolicyCache
//

CPolicyCache::CPolicyCache()
: _cRef(1)
, _bInitialized(FALSE)
{
}

CPolicyCache::~CPolicyCache()
{
    LISTNODE                                  pos = NULL;
    CPolicyMapping                           *pMapping = NULL;
    int                                       i;

    for (i = 0; i < POLICY_CACHE_SIZE; i++) {
        pos = _listMappings[i].GetHeadPosition();

        while (pos) {
            pMapping = _listMappings[i].GetNext(pos);
            SAFEDELETE(pMapping);
        }

        _listMappings[i].RemoveAll();
    }

    if (_bInitialized) {
        DeleteCriticalSection(&_cs);
    }
}

HRESULT CPolicyCache::Init()
{
    HRESULT                          hr = S_OK;

    __try {
        InitializeCriticalSection(&_cs);
        _bInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CPolicyCache::Create(CPolicyCache **ppPolicyCache)
{
    HRESULT                                   hr = S_OK;
    CPolicyCache                             *pPolicyCache = NULL;

    pPolicyCache = NEW(CPolicyCache);
    if (!pPolicyCache) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pPolicyCache->Init();
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppPolicyCache = pPolicyCache;
    (*ppPolicyCache)->AddRef();

Exit:
    SAFERELEASE(pPolicyCache);
    return hr;
}

HRESULT CPolicyCache::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) {
        *ppv = static_cast<IUnknown *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CPolicyCache::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CPolicyCache::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

HRESULT CPolicyCache::LookupPolicy(IAssemblyName *pNameRefSource,
                                   IAssemblyName **ppNameRefPolicy,
                                   AsmBindHistoryInfo *pBindHistory)
{
    HRESULT                                    hr = S_OK;
    CPolicyMapping                            *pMapping = NULL;
    LISTNODE                                   pos = NULL;
    LPWSTR                                     wzDisplayNameSource = NULL;
    DWORD                                      dwSize;
    DWORD                                      dwHash;
    CCriticalSection                           cs(&_cs);
    DWORD                                      dwFlags = 0;

    if (!pNameRefSource || !ppNameRefPolicy || !pBindHistory) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppNameRefPolicy = NULL;
    memset(pBindHistory, 0, sizeof(AsmBindHistoryInfo));
    
    // Get the source display name

    dwSize = 0;
    pNameRefSource->GetDisplayName(NULL, &dwSize, dwFlags);
    if (!dwSize) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    wzDisplayNameSource = NEW(WCHAR[dwSize]);
    if (!wzDisplayNameSource) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pNameRefSource->GetDisplayName(wzDisplayNameSource, &dwSize, dwFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Calculate the hash

    dwHash = HashString(wzDisplayNameSource, POLICY_CACHE_SIZE);

    // Lookup the assembly

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    pos = _listMappings[dwHash].GetHeadPosition();
    while (pos) {
        pMapping = _listMappings[dwHash].GetNext(pos);
        ASSERT(pMapping);

        if (pNameRefSource->IsEqual(pMapping->_pNameRefSource, ASM_CMPF_DEFAULT) == S_OK) {
            *ppNameRefPolicy = pMapping->_pNameRefPolicy;
            (*ppNameRefPolicy)->AddRef();
            memcpy(pBindHistory, &(pMapping->_bindHistory), sizeof(AsmBindHistoryInfo));
            cs.Unlock();
            goto Exit;
        }
    }

    cs.Unlock();

    // Missed in policy cache

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(wzDisplayNameSource);

    return hr;
}                                   

HRESULT CPolicyCache::InsertPolicy(IAssemblyName *pNameRefSource,
                                   IAssemblyName *pNameRefPolicy,
                                   AsmBindHistoryInfo *pBindHistory)
{
    HRESULT                                     hr = S_OK;
    CPolicyMapping                             *pMapping = NULL;
    LPWSTR                                      wzDisplayNameSource = NULL;
    DWORD                                       dwSize;
    DWORD                                       dwHash;
    CCriticalSection                            cs(&_cs);
    DWORD                                       dwFlags = 0;

    if (!pNameRefSource || !pNameRefPolicy || !pBindHistory) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Get the source display name

    dwSize = 0;
    pNameRefSource->GetDisplayName(NULL, &dwSize, dwFlags);
    if (!dwSize) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    wzDisplayNameSource = NEW(WCHAR[dwSize]);
    if (!wzDisplayNameSource) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pNameRefSource->GetDisplayName(wzDisplayNameSource, &dwSize, dwFlags);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Hash the string

    dwHash = HashString(wzDisplayNameSource, POLICY_CACHE_SIZE);

    // Clone off the name mappings and add it to the hash table

    hr = CPolicyMapping::Create(pNameRefSource, pNameRefPolicy, pBindHistory, &pMapping);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }
    
    _listMappings[dwHash].AddTail(pMapping);

    cs.Unlock();

Exit:
    SAFEDELETEARRAY(wzDisplayNameSource);

    return hr;
}



//
// PreparePolicyCache
//

HRESULT PreparePolicyCache(IApplicationContext *pAppCtx, CPolicyCache **ppPolicyCache)
{
    HRESULT                               hr = S_OK;
    DWORD                                 dwSize;
    CPolicyCache                         *pPolicyCache = NULL;
    CCriticalSection                      cs(&g_csDownload);

    if (!pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = 0;
    hr = pAppCtx->Get(ACTAG_APP_POLICY_CACHE, NULL, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        // Already setup
        hr = S_OK;
        cs.Unlock();
        goto Exit;
    }

    hr = CPolicyCache::Create(&pPolicyCache);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }

    hr = pAppCtx->Set(ACTAG_APP_POLICY_CACHE, pPolicyCache, sizeof(pPolicyCache),
                      APP_CTX_FLAGS_INTERFACE);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }

    if (ppPolicyCache) {
        *ppPolicyCache = pPolicyCache;
        (*ppPolicyCache)->AddRef();
    }

    cs.Unlock();

Exit:
    SAFERELEASE(pPolicyCache);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Danpo Zhang

!ENDIF

MAJORCOMP=fusion
MINORCOMP=binder

TARGETNAME=urtbind
TARGETTYPE=LIBRARY
TARGETPATHLIB=$(FUSION_LIB_DEST)

SOURCES= \
    actasm.cpp \
    appctx.cpp \
    asm.cpp    \
    naming.cpp \
    parse.cpp  \
    policy.cpp \
    history.cpp \
    iniwrite.cpp \
    iniread.cpp \
    histnode.cpp \
    histasm.cpp \
    pcycache.cpp \
    nodefact.cpp 

SOURCES_USED=sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\parse.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <fusionp.h>
#include "parse.h"
#include "helpers.h"

//--------------------------------------------------------------------
// CParseUtils::TrimWhiteSpace
//   Inplace trim of leading and trailing whitespace.
//--------------------------------------------------------------------
VOID CParseUtils::TrimWhiteSpace(LPWSTR *psz, LPDWORD pcc)
{
    DWORD cc = *pcc;
    WCHAR* beg = *psz;
    WCHAR* end = beg + cc - 1;

    while ((cc != 0) && ((*beg == ' ') || (*beg == L'\t')))
    {
        beg++;
        cc--;
    }

    while ((cc != 0) && ((*end == ' ') || (*end == L'\t')))
    {
        end--;
        cc--;
    }

    *psz = beg;
    *pcc = cc;
}

//--------------------------------------------------------------------
// CParseUtils::GetDelimitedToken
// Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
// BUGBUG - ppszs
//--------------------------------------------------------------------
BOOL CParseUtils::GetDelimitedToken(LPWSTR* pszBuf,   LPDWORD pccBuf,
    LPWSTR* pszTok,   LPDWORD pccTok, WCHAR   cDelim)
{
    WCHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pccTok = 0;
    *pszTok = *pszBuf;

    pEnd = *pszBuf + *pccBuf - 1;

    while (*pccBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (**pszBuf == L'\0'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pccBuf)--;
    }

    if (fRet)
    {
        *pccBuf = (DWORD)(pEnd - *pszBuf);
        *pccTok = (DWORD)(*pszBuf - *pszTok);

        if (**pszBuf == cDelim)
            (*pszBuf)++;
    }

    return fRet;
}


//--------------------------------------------------------------------
// CParseUtils::GetKeyValuePair
// Inplace retrieval of key and value from a buffer of form key = <">value<">
//--------------------------------------------------------------------
BOOL CParseUtils::GetKeyValuePair(LPWSTR  szB,    DWORD ccB,
    LPWSTR* pszK,   LPDWORD pccK, LPWSTR* pszV,   LPDWORD pccV)
{
    if (GetDelimitedToken(&szB, &ccB, pszK, pccK, '='))
    {
        TrimWhiteSpace(pszK, pccK);

        if (ccB)
        {
            *pszV = szB;
            *pccV = ccB;
            TrimWhiteSpace(pszV, pccV);
        }
        else
        {
            *pszV = NULL;
            *pccV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pccK  = *pccV = 0;
    }
    return FALSE;
}

//--------------------------------------------------------------------
// SetKeyValuePair
//--------------------------------------------------------------------
HRESULT CParseUtils::SetKeyValuePair(LPWSTR szBuffer, LPDWORD pccBuffer, 
        PCWSTR szKey, PCWSTR szValue,  DWORD ccAlloced, DWORD dwFlags)
{
    DWORD ccKey, ccValue, ccRequired;
    BOOL fSpeculate = FALSE;

    ccKey = lstrlen(szKey);
    ccValue = lstrlen(szValue);

    // Total required size.
    ccRequired = *pccBuffer 
        + (dwFlags & FLAG_DELIMIT ? CTSTRLEN(L", ") : 0)
        + ccKey +  CTSTRLEN(L"=") + ccValue  
        + (dwFlags & FLAG_QUOTE ? 2 * CTSTRLEN(L"\"") : 0);

    // Check for sufficient buffer space. 
    if (!ccAlloced || (ccRequired >= ccAlloced))
        fSpeculate = TRUE;

    // <", ">
    if (dwFlags & FLAG_DELIMIT)
    {
        if (!fSpeculate)
            memcpy(szBuffer + *pccBuffer, L", ", 
                CTSTRLEN(L", ") * sizeof(WCHAR));

        (*pccBuffer) += CTSTRLEN(L", ");
    }
    
    // <", ">Key
    if (!fSpeculate)
        memcpy(szBuffer + *pccBuffer, szKey, 
            ccKey * sizeof(WCHAR));

    (*pccBuffer) += ccKey;

    // <", ">Key=
    if (!fSpeculate)
        memcpy(szBuffer + *pccBuffer, L"=", 
            CTSTRLEN(L"=") * sizeof(WCHAR));

    (*pccBuffer) += CTSTRLEN(L"=");

    // <", ">Key=<">
    if (dwFlags & FLAG_QUOTE)
    {
        if (!fSpeculate)
            memcpy(szBuffer + *pccBuffer, L"\"", 
                CTSTRLEN(L"\"") * sizeof(WCHAR));

        (*pccBuffer) += CTSTRLEN(L"\"");
    }

    // <", ">Key=<">Value
    if (!fSpeculate)
        memcpy(szBuffer + *pccBuffer, szValue, 
            ccValue * sizeof(WCHAR));

    (*pccBuffer) += ccValue;

    // <", ">Key=<">Value<">
    if (dwFlags & FLAG_QUOTE)
    {
        if (!fSpeculate)
            memcpy(szBuffer + *pccBuffer, L"\"", 
                CTSTRLEN(L"\"") * sizeof(WCHAR));

        (*pccBuffer) += CTSTRLEN(L"\"");
    }


    return S_OK;
}

//--------------------------------------------------------------------
// CParseUtils::SetKey
//--------------------------------------------------------------------
HRESULT CParseUtils::SetKey(LPWSTR szBuffer, LPDWORD pccBuffer, 
        PCWSTR szKey, DWORD ccAlloced, DWORD dwFlags)
{
    DWORD ccKey, ccRequired;
    BOOL fSpeculate = FALSE;
    
    // Total required size.
    ccKey = lstrlen(szKey);
    ccRequired = *pccBuffer  
        + (dwFlags & FLAG_DELIMIT ? CTSTRLEN(L", ") : 0)
        + ccKey;

    // Check for sufficient buffer space. 
    if (!ccAlloced || (ccRequired >= ccAlloced))
        fSpeculate = TRUE;

    // <", ">
    if (dwFlags & FLAG_DELIMIT)
    {
        if (!fSpeculate)
            memcpy(szBuffer + *pccBuffer, L", ", 
                CTSTRLEN(L", ") * sizeof(WCHAR));
        (*pccBuffer) += CTSTRLEN(L", ");
    }

    // <", ">Key
    if (!fSpeculate)
        memcpy(szBuffer + *pccBuffer, szKey, ccKey * sizeof(WCHAR));
    (*pccBuffer) += ccKey;

    return S_OK;
}


//--------------------------------------------------------------------
// CParseUtils::BinToUnicodeHex
//--------------------------------------------------------------------
VOID CParseUtils::BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst)
{
    UINT x;
    UINT y;

#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))

    for ( x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );  
        v = pSrc[x] & 0x0f;                 
        pDst[y++] = TOHEX( v ); 
    }                                    
    pDst[y] = '\0';
}

//--------------------------------------------------------------------
// CParseUtils::UnicodeHexToBin
//--------------------------------------------------------------------
VOID CParseUtils::UnicodeHexToBin(LPCWSTR pSrc, UINT cSrc, LPBYTE pDest)
{
    BYTE v;
    LPBYTE pd = pDest;
    LPCWSTR ps = pSrc;

    for (UINT i = 0; i < cSrc-1; i+=2)
    {
        v =  FROMHEX(TOLOWER(ps[i])) << 4;
        v |= FROMHEX(TOLOWER(ps[i+1]));
       *(pd++) = v;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\binder\policy.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  Policy Services
//

#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include "naming.h"
#include "debmacro.h"
#include "policy.h"
#include "fusionp.h"
#include "helpers.h"
#include "parse.h"
#include "dbglog.h"
#include "util.h"
#include "asm.h"
#include "adlmgr.h"
#include "xmlparser.h"
#include "nodefact.h"
#include "fstream.h"
#include "helpers.h"
#include "clbutils.h"
#include "lock.h"
#include "mstream.h"

extern CRITICAL_SECTION g_csDownload;
extern CNodeFactory *g_pNFRetargetCfg;
extern CNodeFactory *g_pNFFxConfig;

pfnGetXMLObject g_pfnGetXMLObject;

#define PUBLICKEYTOKEN_LEN_BYTES                 8

// TODO: Make this function return an HRESULT
// to track failures
void GetDefaultPlatform(OSINFO *pOS)
{
    if(pOS) {
        OSVERSIONINFO   VersionInformation;

        memset(pOS, 0, sizeof(OSINFO));

        VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if(GetVersionEx(&VersionInformation)) {
            pOS->dwOSPlatformId = VersionInformation.dwPlatformId; 
            pOS->dwOSMajorVersion = VersionInformation.dwMajorVersion;
            pOS->dwOSMinorVersion = VersionInformation.dwMinorVersion;
        }
    }
}

HRESULT PrepQueryMatchData(IAssemblyName *pName,
                           LPWSTR *ppwzAsmName,
                           LPWSTR *ppwzAsmVersion,
                           LPWSTR *ppwzPublicKeyToken,
                           LPWSTR *ppwzCulture)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      pwzAsmName = NULL;
    DWORD                                       dwSize;
    DWORD                                       dwVerHigh;
    DWORD                                       dwVerLow;
    CAssemblyName                              *pCName = NULL;

    ASSERT(pName && ppwzAsmName && ppwzAsmVersion && ppwzPublicKeyToken && ppwzCulture);

    *ppwzAsmName = NULL;
    *ppwzAsmVersion = NULL;
    *ppwzPublicKeyToken = NULL;
    *ppwzCulture = NULL;

    // Assembly Name
    
    dwSize = 0;
    hr = pName->GetName(&dwSize, NULL);
    if (!dwSize) {
        // No name--shouldn't have gotten here!
        hr = E_UNEXPECTED;
        goto Exit;
    }

    *ppwzAsmName = NEW(WCHAR[dwSize]);
    if (!*ppwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pName->GetName(&dwSize, *ppwzAsmName);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Assembly Version

    hr = pName->GetVersion(&dwVerHigh, &dwVerLow);
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppwzAsmVersion = NEW(WCHAR[MAX_VERSION_DISPLAY_SIZE + 1]);
    if (!*ppwzAsmVersion) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(*ppwzAsmVersion, MAX_VERSION_DISPLAY_SIZE + 1, L"%d.%d.%d.%d",
               HIWORD(dwVerHigh), LOWORD(dwVerHigh),
               HIWORD(dwVerLow), LOWORD(dwVerLow));

    // Assembly Public Key Token

    pCName = dynamic_cast<CAssemblyName*>(pName);
    ASSERT(pCName);
    
    dwSize = 0;
    hr = pCName->GetPublicKeyToken(&dwSize, NULL, TRUE);
    if (!dwSize) {
        *ppwzPublicKeyToken = NULL;
    }
    else {
        *ppwzPublicKeyToken = NEW(WCHAR[dwSize]);
        if (!*ppwzPublicKeyToken) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        hr = pCName->GetPublicKeyToken(&dwSize, (BYTE *)(*ppwzPublicKeyToken), TRUE);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // Assembly Language

    dwSize = 0;
    pName->GetProperty(ASM_NAME_CULTURE, NULL, &dwSize);

    if (dwSize > sizeof(L"")) {
        *ppwzCulture = NEW(WCHAR[dwSize / sizeof(WCHAR)]);
        if (!*ppwzCulture) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        hr = pName->GetProperty(ASM_NAME_CULTURE, *ppwzCulture, &dwSize);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

Exit:
    if (FAILED(hr)) {
        SAFEDELETEARRAY(*ppwzAsmName);
        SAFEDELETEARRAY(*ppwzAsmVersion);
        SAFEDELETEARRAY(*ppwzPublicKeyToken);
        SAFEDELETEARRAY(*ppwzCulture);
    }
    
    return hr;    
}


HRESULT GetPublisherPolicyFilePath(LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                                   LPCWSTR pwzCulture, WORD wVerMajor,
                                   WORD wVerMinor, LPWSTR *ppwzPublisherCfg)
{
    HRESULT                                   hr = S_OK;
    WCHAR                                     wzModPath[MAX_PATH];
    DWORD                                     dwLen = 0;
    WCHAR                                     wzPolicyAsmName[MAX_PATH];
    UINT                                      uiSize;
    BYTE                                      abProp[PUBLICKEYTOKEN_LEN_BYTES];
    IAssemblyName                            *pName = NULL;
    IAssemblyName                            *pNameGlobal = NULL;
    CTransCache                              *pTransCache = NULL;
    TRANSCACHEINFO                           *pInfo = NULL;
    IAssembly                                *pAsm = NULL;
    IAssemblyModuleImport                    *pModImport = NULL;
    LPWSTR pszManifestPath=NULL;
    

    if (!pwzAsmName || !pwzPublicKeyToken || !ppwzPublisherCfg) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppwzPublisherCfg = NULL;

    // Build name of policy assembly

    wnsprintfW(wzPolicyAsmName, MAX_PATH, L"%ws%d.%d.%ws", POLICY_ASSEMBLY_PREFIX,
               wVerMajor, wVerMinor, pwzAsmName);

    // Create policy name reference object

    hr = CreateAssemblyNameObject(&pName, wzPolicyAsmName, 0, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    uiSize = PUBLICKEYTOKEN_LEN_BYTES;
    CParseUtils::UnicodeHexToBin(pwzPublicKeyToken, uiSize * sizeof(WCHAR), abProp);

    hr = pName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, abProp, uiSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (pwzCulture) {
        uiSize = (lstrlenW(pwzCulture) + 1) * sizeof(WCHAR);

        hr = pName->SetProperty(ASM_NAME_CULTURE, (void *)pwzCulture, uiSize);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        hr = pName->SetProperty(ASM_NAME_CULTURE, L"", sizeof(L""));
        if (FAILED(hr)) {
            goto Exit;
        }
    }
   
    hr = CCache::GetGlobalMax(pName, &pNameGlobal, &pTransCache);
    if (FAILED(hr) || hr == DB_S_NOTFOUND) {
        hr = S_FALSE;
        goto Exit;
    }

    pInfo = (TRANSCACHEINFO *)pTransCache->_pInfo;
    ASSERT(pInfo);

    pszManifestPath = pTransCache->_pInfo->pwzPath;

    hr = CreateAssemblyFromManifestFile(pszManifestPath, NULL, NULL, &pAsm);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pAsm->GetNextAssemblyModule(0, &pModImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwLen = MAX_PATH;
    hr = pModImport->GetModulePath(wzModPath, &dwLen);
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppwzPublisherCfg = WSTRDupDynamic(wzModPath);
    if (!*ppwzPublisherCfg) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    SAFEDELETE(pTransCache);

    SAFERELEASE(pName);
    SAFERELEASE(pNameGlobal);
    SAFERELEASE(pAsm);
    SAFERELEASE(pModImport);

    return hr;
}

HRESULT ApplyPolicy(LPCWSTR wzHostCfg, LPCWSTR wzAppCfg, IAssemblyName *pNameSource,
                    IAssemblyName **ppNamePolicy, LPWSTR *ppwzPolicyCodebase,
                    IApplicationContext *pAppCtx, AsmBindHistoryInfo *pHistInfo,
                    BOOL bDisallowApplyPubPolicy, BOOL bDisallowAppBindingRedirects,
                    BOOL bBehaviorEverett, CDebugLog *pdbglog)
{
    HRESULT                              hr = S_OK;
    IAssemblyName                       *pNamePolicy = NULL;
    LPWSTR                               pwzAsmName = NULL;
    LPWSTR                               pwzAsmVersion = NULL;
    LPWSTR                               pwzPublicKeyToken = NULL;
    LPWSTR                               pwzCulture = NULL;
    LPWSTR                               pwzPublisherCfg = NULL;
    LPWSTR                               pwzVerHostCfg = NULL;
    LPWSTR                               pwzVerAppCfg = NULL;
    LPWSTR                               pwzVerFxCfg = NULL;
    LPWSTR                               pwzVerPublisherCfg = NULL;
    LPWSTR                               pwzVerAdminCfg = NULL;
    LPCWSTR                              pwzCodebaseCfgFile = NULL;
    BOOL                                 bSafeMode = FALSE;
    WORD                                 wVerMajor;
    WORD                                 wVerMinor;
    WORD                                 wVerRev;
    WORD                                 wVerBld;
    DWORD                                dwSize;
    CNodeFactory                        *pNFHostCfg = NULL;
    CNodeFactory                        *pNFAppCfg = NULL;
    CNodeFactory                        *pNFPublisherCfg = NULL;
    CNodeFactory                        *pNFAdminCfg = NULL;
    CNodeFactory                        *pNFCodebase = NULL;
    LPWSTR                               pwzMachineCfg = NULL;
    LPWSTR                               pwzDispName = NULL;
    LPWSTR                               wzAppBase=NULL;

    LPWSTR                               pwzNameRetargetCfg = NULL;
    LPWSTR                               pwzPktRetargetCfg = NULL;
    LPWSTR                               pwzVerRetargetCfg = NULL;
    BYTE                                 abProp[PUBLICKEYTOKEN_LEN_BYTES];
    UINT                                 uiSize;
    BOOL                                 bRetarget = FALSE;
    BOOL                                 bAppliedInAppCfg = FALSE;

    
    if (!pNameSource || !ppNamePolicy || !pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppNamePolicy = NULL;

    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNameSource->Clone(&pNamePolicy);
    if (FAILED(hr)) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!CCache::IsStronglyNamed(pNameSource) || CCache::IsCustom(pNameSource)
        || CAssemblyName::IsPartial(pNameSource)) {
        DEBUGOUT(pdbglog, 0, ID_FUSLOG_POLICY_NOT_APPLIED);

        *ppNamePolicy = pNamePolicy;
        (*ppNamePolicy)->AddRef();

        goto Exit;
    }

    hr = PrepQueryMatchData(pNameSource, &pwzAsmName, &pwzAsmVersion,
                            &pwzPublicKeyToken, &pwzCulture);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = (DWORD)sizeof(BOOL);
    if (FAILED(hr = pNameSource->GetProperty(ASM_NAME_RETARGET, &bRetarget, &dwSize)))
    {
        goto Exit;
    }
    // ASM_NAME_RETARGET is not set. Treat it as FALSE
    if (dwSize == 0)
        bRetarget = FALSE;
                                                
    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_MACHINE_CONFIG, &pwzMachineCfg);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Get retarget policy
    if (bRetarget) 
    {
        // pNameSource->Clone(pNamePolicy) accidentally copies the retarget
        // flag to pNamePolicy. pNamePolicy should not carry that flag
        // since it contains the "retargeted" reference. Clean it here.
        pNamePolicy->SetProperty(ASM_NAME_RETARGET, NULL, 0);
        
        hr = InitFusionRetargetPolicy();
        if (FAILED(hr))
        {
            goto Exit;
        }

       // GetPolicyVersionAndPublicKeyToken from retarget policy
        if (g_pNFRetargetCfg != NULL)
        {
            hr = g_pNFRetargetCfg->GetRetargetedAssembly(pwzAsmName, pwzPublicKeyToken, pwzCulture, pwzAsmVersion, 
                                                        &pwzNameRetargetCfg, &pwzPktRetargetCfg, &pwzVerRetargetCfg);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }
        else 
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_RETARGET_CFG_MISSING);
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if (FusionCompareStringI(pwzNameRetargetCfg, pwzAsmName)) {
            DEBUGOUT2(pdbglog, 0, ID_FUSLOG_RETARGET_CFG_NAME_REDIRECT, pwzAsmName, pwzNameRetargetCfg);
            hr = pNamePolicy->SetProperty(ASM_NAME_NAME, pwzNameRetargetCfg, (lstrlenW(pwzNameRetargetCfg)+1)*sizeof(WCHAR));
            if (FAILED(hr)) {
                goto Exit;
            }
        }

        if (FusionCompareStringI(pwzPktRetargetCfg, pwzPublicKeyToken)) {
            DEBUGOUT2(pdbglog, 0, ID_FUSLOG_RETARGET_CFG_PKT_REDIRECT, pwzPublicKeyToken, pwzPktRetargetCfg);
            // Set post-policy publicKeyToken
            uiSize = PUBLICKEYTOKEN_LEN_BYTES;
            CParseUtils::UnicodeHexToBin(pwzPktRetargetCfg, uiSize * sizeof(WCHAR), abProp);

            hr = pNamePolicy->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, abProp, uiSize);
            if (FAILED(hr)) {
                goto Exit;
            }
        }

        if (FusionCompareStringI(pwzVerRetargetCfg, pwzAsmVersion)) {
            DEBUGOUT2(pdbglog, 0, ID_FUSLOG_RETARGET_CFG_VER_REDIRECT, pwzAsmVersion, pwzVerRetargetCfg);
        }
    }
    else
    {
        pwzPktRetargetCfg = WSTRDupDynamic(pwzPublicKeyToken);
        if (!pwzPktRetargetCfg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
                
        pwzVerRetargetCfg = WSTRDupDynamic(pwzAsmVersion);
        if (!pwzVerRetargetCfg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pwzNameRetargetCfg = WSTRDupDynamic(pwzAsmName);
        if (!pwzNameRetargetCfg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }


    // Get app.cfg policy

    dwSize = sizeof(pNFAppCfg);
    hr = pAppCtx->Get(ACTAG_APP_CFG_INFO, &pNFAppCfg, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (SUCCEEDED(hr)) {
        // We've parsed the app.cfg before.

        if (bDisallowAppBindingRedirects) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_DISALLOW_APP_BINDING_REDIRECTS);

            pwzVerAppCfg = WSTRDupDynamic(pwzVerRetargetCfg);
            if (!pwzVerAppCfg) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
        else {
            hr = pNFAppCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                             pwzCulture, pwzVerRetargetCfg,
                                             &pwzVerAppCfg);
            if (FAILED(hr)) {
                goto Exit;
            }
            
            if (hr == S_OK) {
                bAppliedInAppCfg = TRUE; 
            }
    
            hr = pNFAppCfg->GetSafeMode(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                        pwzCulture, pwzVerRetargetCfg,
                                        &bSafeMode);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
    }
    else {
        // First time we've read app.cfg. Need to parse the file.

        if (wzAppCfg) {
            hr = ParseXML(&pNFAppCfg, wzAppCfg, bBehaviorEverett, pdbglog);
            if (FAILED(hr)) {
                goto Exit;
            }
    
            if (bDisallowAppBindingRedirects) {
                DEBUGOUT(pdbglog, 0, ID_FUSLOG_DISALLOW_APP_BINDING_REDIRECTS);

                pwzVerAppCfg = WSTRDupDynamic(pwzVerRetargetCfg);
                if (!pwzVerAppCfg) {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }
            else {
                hr = pNFAppCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                                 pwzCulture, pwzVerRetargetCfg,
                                                 &pwzVerAppCfg);
                if (FAILED(hr)) {
                    goto Exit;
                }
    
                if (hr == S_OK) {
                    bAppliedInAppCfg = TRUE; 
                }
    
                hr = pNFAppCfg->GetSafeMode(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                            pwzCulture, pwzVerRetargetCfg,
                                            &bSafeMode);
                if (FAILED(hr)) {
                    goto Exit;
                }
            }
    
            // Put app.cfg node factory in appctx so downloader can get at
            // codebase hint information
    
            hr = pAppCtx->Set(ACTAG_APP_CFG_INFO, pNFAppCfg, sizeof(pNFAppCfg), APP_CTX_FLAGS_INTERFACE);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        else {
            pwzVerAppCfg = WSTRDupDynamic(pwzVerRetargetCfg);
            if (!pwzVerAppCfg) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
    }

    if (FusionCompareStringI(pwzVerRetargetCfg, pwzVerAppCfg)) {
        DEBUGOUT2(pdbglog, 0, ID_FUSLOG_APP_CFG_REDIRECT, pwzVerRetargetCfg, pwzVerAppCfg);

        // Record that redirection happens in app cfg. 
        bAppliedInAppCfg = TRUE; 
        SAFERELEASE(pNFCodebase);
        pNFCodebase = pNFAppCfg;
        pNFCodebase->AddRef();
    }

    if (bDisallowApplyPubPolicy) {
        DEBUGOUT(pdbglog, 0, ID_FUSLOG_DISALLOW_APPLY_PUB_POLICY);
        bSafeMode = FALSE;
    }

    // Apply Framework Config here
   
    // Anything redirected in app.cfg is final for FxConfig
    if (bBehaviorEverett && !bAppliedInAppCfg)
    {
        hr = InitFusionFxConfigPolicy();
        if (FAILED(hr))
        {
            goto Exit;
        }

        // GetPolicyVersion from FxConfig policy
        if (g_pNFFxConfig != NULL)
        {
            hr = g_pNFFxConfig->GetPolicyVersion(pwzNameRetargetCfg, 
                                pwzPktRetargetCfg, pwzCulture, 
                                pwzVerAppCfg, &pwzVerFxCfg);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }
        else 
        {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_FX_CFG_MISSING);
            hr = E_UNEXPECTED;
            goto Exit;
        }

        if (FusionCompareStringI(pwzVerFxCfg, pwzVerAppCfg)) 
        {
            DEBUGOUT2(pdbglog, 0, ID_FUSLOG_FX_CFG_VER_REDIRECT, pwzVerAppCfg, pwzVerFxCfg);
        }
    }
    else
    {
        pwzVerFxCfg = WSTRDupDynamic(pwzVerAppCfg);
        if (!pwzVerFxCfg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
                
    }

    if (bSafeMode) {
        DEBUGOUT(pdbglog, 0, ID_FUSLOG_APP_CFG_SAFE_MODE);

        // We are in safe mode, so treat this like there is no publisher.cfg

        pwzVerPublisherCfg = WSTRDupDynamic(pwzVerFxCfg);
        if (!pwzVerPublisherCfg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else {
        WORD                      wMajor = 0;
        WORD                      wMinor = 0;
        WORD                      wRev = 0;
        WORD                      wBld = 0;

        // Extract version

        hr = VersionFromString(pwzVerFxCfg, &wMajor, &wMinor, &wRev, &wBld);
        if (FAILED(hr)) {
            goto Exit;
        }

        // Find publisher policy file
    
        hr = GetPublisherPolicyFilePath(pwzNameRetargetCfg, pwzPktRetargetCfg, pwzCulture,
                                        wMajor, wMinor, &pwzPublisherCfg);
        if (FAILED(hr)) {
            goto Exit;
        }


        if (hr == S_FALSE) {
            // No publisher policy file

            DEBUGOUT(pdbglog, 0, ID_FUSLOG_PUB_CFG_MISSING);

            pwzVerPublisherCfg = WSTRDupDynamic(pwzVerFxCfg);
            if (!pwzVerPublisherCfg) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
        else {
            DEBUGOUT1(pdbglog, 0, ID_FUSLOG_PUB_CFG_FOUND, pwzPublisherCfg);

            hr = ParseXML(&pNFPublisherCfg, pwzPublisherCfg, bBehaviorEverett, pdbglog);
            if (FAILED(hr)) {
                goto Exit;
            }
    
            hr = pNFPublisherCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                                   pwzCulture, pwzVerFxCfg,
                                                   &pwzVerPublisherCfg);
            if (FAILED(hr)) {
                goto Exit;
            }
        
            if (FusionCompareStringI(pwzVerFxCfg, pwzVerPublisherCfg)) {
                DEBUGOUT2(pdbglog, 0, ID_FUSLOG_PUB_CFG_REDIRECT, pwzVerFxCfg, pwzVerPublisherCfg);

                SAFERELEASE(pNFCodebase);
                pNFCodebase = pNFPublisherCfg;
                pNFCodebase->AddRef();
            }
        }
    }
    
    // Get host config policy
    
    dwSize = sizeof(pNFHostCfg);
    hr = pAppCtx->Get(ACTAG_HOST_CFG_INFO, &pNFHostCfg, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (SUCCEEDED(hr)) {
        hr = pNFHostCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg, pwzCulture,
                                          pwzVerPublisherCfg, &pwzVerHostCfg);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        // This is the first time we've read the host config file

        if (wzHostCfg && GetFileAttributes(wzHostCfg) != -1) {
            DEBUGOUT1(pdbglog, 0, ID_FUSLOG_HOST_CONFIG_FILE, wzHostCfg);

            hr = ParseXML(&pNFHostCfg, wzHostCfg, bBehaviorEverett, pdbglog);
            if (FAILED(hr)) {
                goto Exit;
            }

            hr = pNFHostCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg, pwzCulture,
                                              pwzVerPublisherCfg, &pwzVerHostCfg);
            if (FAILED(hr)) {
                goto Exit;
            }
            
            hr = pAppCtx->Set(ACTAG_HOST_CFG_INFO, pNFHostCfg, sizeof(pNFHostCfg), APP_CTX_FLAGS_INTERFACE);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        else {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_HOST_CONFIG_FILE_MISSING);
            
            pwzVerHostCfg = WSTRDupDynamic(pwzVerPublisherCfg);
            if (!pwzVerHostCfg) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
    }
    
    if (FusionCompareStringI(pwzVerPublisherCfg, pwzVerHostCfg)) {
        DEBUGOUT3(pdbglog, 0, ID_FUSLOG_HOST_CFG_REDIRECT, wzHostCfg, pwzAsmVersion, pwzVerHostCfg)
        
        SAFERELEASE(pNFCodebase);
        pNFCodebase = pNFHostCfg;
        pNFCodebase->AddRef();
    }
    else {
        if (wzHostCfg) {
            DEBUGOUT1(pdbglog, 0, ID_FUSLOG_HOST_CFG_NO_REDIRECT, wzHostCfg);
        }
    }

    // Apply admin policy

    if (!pwzMachineCfg || GetFileAttributes(pwzMachineCfg) == -1) {
        if (pwzMachineCfg) {
            DEBUGOUT1(pdbglog, 0, ID_FUSLOG_MACHINE_CFG_MISSING, pwzMachineCfg);
        }

        pwzVerAdminCfg = WSTRDupDynamic(pwzVerHostCfg);
        if (!pwzVerAdminCfg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else {
        DEBUGOUT1(pdbglog, 0, ID_FUSLOG_MACHINE_CFG_FOUND, pwzMachineCfg);

        dwSize = sizeof(pNFAppCfg);
        hr = pAppCtx->Get(ACTAG_ADMIN_CFG_INFO, &pNFAdminCfg, &dwSize, APP_CTX_FLAGS_INTERFACE);
        if (SUCCEEDED(hr)) {
            // We've read admin.cfg before

            hr = pNFAdminCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                               pwzCulture, pwzVerHostCfg,
                                               &pwzVerAdminCfg);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        else {
            // This is the first time we've read admin.cfg

            hr = ParseXML(&pNFAdminCfg, pwzMachineCfg, bBehaviorEverett, pdbglog);
            if (FAILED(hr)) {
                goto Exit;
            }
        
            hr = pNFAdminCfg->GetPolicyVersion(pwzNameRetargetCfg, pwzPktRetargetCfg,
                                               pwzCulture, pwzVerHostCfg,
                                               &pwzVerAdminCfg);
            if (FAILED(hr)) {
                goto Exit;
            }
    
            hr = pAppCtx->Set(ACTAG_ADMIN_CFG_INFO, pNFAdminCfg, sizeof(pNFAdminCfg), APP_CTX_FLAGS_INTERFACE);
            if (FAILED(hr)) {
                goto Exit;
            }
        }

        if (FusionCompareStringI(pwzVerHostCfg, pwzVerAdminCfg)) {
            DEBUGOUT2(pdbglog, 0, ID_FUSLOG_MACHINE_CFG_REDIRECT, pwzVerPublisherCfg, pwzVerAdminCfg);

            SAFERELEASE(pNFCodebase);
            pNFCodebase = pNFAdminCfg;
            pNFCodebase->AddRef();
        }
    }

    // Set the post-policy version

    hr = VersionFromString(pwzVerAdminCfg, &wVerMajor, &wVerMinor, &wVerBld, &wVerRev);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNamePolicy->SetProperty(ASM_NAME_MAJOR_VERSION, &wVerMajor, sizeof(WORD));
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNamePolicy->SetProperty(ASM_NAME_MINOR_VERSION, &wVerMinor, sizeof(WORD)); 
    if (FAILED(hr)) {
        goto Exit;
    }
    
    hr = pNamePolicy->SetProperty(ASM_NAME_REVISION_NUMBER, &wVerRev, sizeof(WORD));
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNamePolicy->SetProperty(ASM_NAME_BUILD_NUMBER, &wVerBld, sizeof(WORD));
    if (FAILED(hr)) {
        goto Exit;
    }

    // Get the codebase hint from the right cfg file

    if (pNFCodebase && ppwzPolicyCodebase) {
        // There was a redirect, and pwzCodebaseCfgFile contains the cfg
        // file that did the final redirect.

        wzAppBase = NEW(WCHAR[MAX_URL_LENGTH+1]);
        if (!wzAppBase)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        dwSize = MAX_URL_LENGTH * sizeof(WCHAR);
        hr = pAppCtx->Get(ACTAG_APP_BASE_URL, wzAppBase, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        hr = pNFCodebase->GetCodebaseHint(pwzNameRetargetCfg, pwzVerAdminCfg,
                                          pwzPublicKeyToken, pwzCulture,
                                          wzAppBase, ppwzPolicyCodebase);
        if (FAILED(hr)) {
            DEBUGOUT(pdbglog, 0, ID_FUSLOG_REDIRECT_NO_CODEBASE);
            goto Exit;
        }
        else if (*ppwzPolicyCodebase) {
            DEBUGOUT1(pdbglog, 0, ID_FUSLOG_POLICY_CODEBASE, *ppwzPolicyCodebase);
        }
    }

    // Populate the bind history

    if (pHistInfo) {
        if ((lstrlenW(pwzVerAppCfg) <= MAX_VERSION_DISPLAY_SIZE) &&
             (lstrlenW(pwzVerPublisherCfg) <= MAX_VERSION_DISPLAY_SIZE) &&
             (lstrlenW(pwzVerAdminCfg) <= MAX_VERSION_DISPLAY_SIZE) &&
             (lstrlenW(pwzAsmVersion) <= MAX_VERSION_DISPLAY_SIZE) &&
             (lstrlenW(pwzNameRetargetCfg) <= MAX_INI_TAG_LENGTH) &&
             (lstrlenW(pwzPktRetargetCfg) <= MAX_PUBLIC_KEY_TOKEN_LEN)){

            lstrcpyW(pHistInfo->wzVerReference, pwzAsmVersion);
            lstrcpyW(pHistInfo->wzVerAppCfg, pwzVerAppCfg);
            lstrcpyW(pHistInfo->wzVerPublisherCfg, pwzVerPublisherCfg);
            lstrcpyW(pHistInfo->wzVerAdminCfg, pwzVerAdminCfg);
    
            lstrcpyW(pHistInfo->wzAsmName, pwzNameRetargetCfg);
            lstrcpyW(pHistInfo->wzPublicKeyToken, pwzPktRetargetCfg);
    
            if (pwzCulture) {
                lstrcpyW(pHistInfo->wzCulture, pwzCulture);
            }
            else {
                lstrcpyW(pHistInfo->wzCulture, L"NULL");
            }
        }
    }

    // Done. Return policy reference.

    *ppNamePolicy = pNamePolicy;
    (*ppNamePolicy)->AddRef();


Exit:
    SAFEDELETEARRAY(pwzVerFxCfg);
    SAFEDELETEARRAY(pwzPktRetargetCfg);
    SAFEDELETEARRAY(pwzVerRetargetCfg);
    SAFEDELETEARRAY(pwzNameRetargetCfg);

    SAFEDELETEARRAY(pwzMachineCfg);
    SAFEDELETEARRAY(pwzAsmName);
    SAFEDELETEARRAY(pwzAsmVersion);
    SAFEDELETEARRAY(pwzPublicKeyToken);
    SAFEDELETEARRAY(pwzPublisherCfg);
    SAFEDELETEARRAY(pwzCulture);

    SAFEDELETEARRAY(pwzVerHostCfg);
    SAFEDELETEARRAY(pwzVerAppCfg);
    SAFEDELETEARRAY(pwzVerPublisherCfg);
    SAFEDELETEARRAY(pwzVerAdminCfg);    

    SAFERELEASE(pNFCodebase);
    SAFERELEASE(pNFHostCfg);
    SAFERELEASE(pNFAppCfg);
    SAFERELEASE(pNFPublisherCfg);
    SAFERELEASE(pNFAdminCfg);

    if (SUCCEEDED(hr)) {

        ASSERT(pNamePolicy);

        // Log the post-policy reference

        HRESULT                  hrLocal = S_OK;
    
        dwSize = 0;
        hrLocal = pNamePolicy->GetDisplayName(NULL, &dwSize, 0);
        if (hrLocal == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            pwzDispName = NEW(WCHAR[dwSize]);
            if (!pwzDispName) {
                hr = E_OUTOFMEMORY;
                goto Exit2;
            }
        
            hrLocal = pNamePolicy->GetDisplayName(pwzDispName, &dwSize, 0);
            if (FAILED(hrLocal)) {
                goto Exit2;
            }

            DEBUGOUT1(pdbglog, 0, ID_FUSLOG_POST_POLICY_REFERENCE, pwzDispName);
        }
    }
    else {
        DEBUGOUT1(pdbglog, 1, ID_FUSLOG_APPLY_POLICY_FAILED, hr);
    }

Exit2:
    SAFEDELETEARRAY(pwzDispName);
    SAFERELEASE(pNamePolicy);

    SAFEDELETEARRAY(wzAppBase);
    return hr;
}

HRESULT ReadConfigSettings(IApplicationContext *pAppCtx, LPCWSTR wzAppCfg,
                           CDebugLog *pdbglog)
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   pwzSharedPath = NULL;
    LPWSTR                                   pwzPrivatePath = NULL;
    LPSTR                                    szTmp = NULL;
    BOOL                                     bShadowCopy = FALSE;
    DWORD                                    dwSize;
    CNodeFactory                            *pNodeFact = NULL;

    if (!pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = sizeof(pNodeFact);
    hr = pAppCtx->Get(ACTAG_APP_CFG_INFO, &pNodeFact, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        // No cfg info object. Parse app.cfg if available.

        if (wzAppCfg) {
            hr = ParseXML(&pNodeFact, wzAppCfg, TRUE, pdbglog);
            if (FAILED(hr)) {
                goto Exit;
            }
    
            // Put app.cfg node factory in appctx so downloader can get at
            // codebase hint information
    
            hr = pAppCtx->Set(ACTAG_APP_CFG_INFO, pNodeFact, sizeof(pNodeFact), APP_CTX_FLAGS_INTERFACE);
            if (FAILED(hr)) {
                goto Exit;
            }

            ASSERT(pNodeFact);

            // Fall through
        }
        else {
            hr = S_FALSE;
            goto Exit;
        }
    }
    else if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNodeFact->GetPrivatePath(&pwzPrivatePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (pwzPrivatePath) {
        hr = pAppCtx->Set(ACTAG_APP_CFG_PRIVATE_BINPATH, pwzPrivatePath,
                          (lstrlenW(pwzPrivatePath) + 1) * sizeof(WCHAR), 0);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        DEBUGOUT1(pdbglog, 0, ID_FUSLOG_CFG_PRIVATE_PATH, pwzPrivatePath);
    }

Exit:
    SAFEDELETEARRAY(pwzPrivatePath);

    SAFERELEASE(pNodeFact);

    return hr;
}
                           
HRESULT ParseXML(CNodeFactory **ppNodeFactory, LPCWSTR wzFileName, BOOL bBehaviorEverett, CDebugLog *pdbglog)
{
    HRESULT                                  hr = S_OK;
    CFileStream                             *pStream = NULL;
    CNodeFactory                            *pNF = NULL;
    IXMLParser                              *pXMLParser = NULL;

    if (!ppNodeFactory || !wzFileName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!g_pfnGetXMLObject) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    hr = (*g_pfnGetXMLObject)((void **)&pXMLParser);
    if (FAILED(hr)) {
        goto Exit;
    }

    pStream = new CFileStream;
    if (!pStream) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pStream->OpenForRead(wzFileName);
    if (FAILED(hr)) {
        goto Exit;
    }

    pNF = NEW(CNodeFactory(pdbglog));
    if (!pNF) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!bBehaviorEverett) {
        pNF->DisableAppliesTo();
    }
      
    hr = pXMLParser->SetFactory(pNF);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pXMLParser->SetInput(pStream);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pXMLParser->Run(-1);
    if (FAILED(hr)) {
        DEBUGOUT1(pdbglog, 0, ID_FUSLOG_XML_PARSE_ERROR_FILE, wzFileName);

        // Delete the old node factory (ie. all traces of anything that did
        // get parsed), and create a empty node factory.

        SAFERELEASE(pNF);

        pNF = NEW(CNodeFactory(pdbglog));
        if (!pNF) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        hr = S_FALSE;

        // Fall through, and hand back the empty node factory.
    }

    *ppNodeFactory = pNF;
    (*ppNodeFactory)->AddRef();

Exit:
    SAFERELEASE(pStream);
    SAFERELEASE(pNF);
    SAFERELEASE(pXMLParser);

    return hr;
}

HRESULT ParseXML(CNodeFactory **ppNodeFactory, LPVOID lpMemory, ULONG cbSize, BOOL bBehaviorEverett, CDebugLog *pdbglog)
{
    HRESULT                                  hr = S_OK;
    CMemoryStream                           *pStream = NULL;
    CNodeFactory                            *pNF = NULL;
    IXMLParser                              *pXMLParser = NULL;

    if (!ppNodeFactory || !lpMemory) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppNodeFactory = NULL;

    if (!g_pfnGetXMLObject) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    hr = (*g_pfnGetXMLObject)((void **)&pXMLParser);
    if (FAILED(hr)) {
        goto Exit;
    }

    pStream = NEW(CMemoryStream);
    if (!pStream) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // CMemoryStream::Init(LPVOID lpStart, ULONG cbSize, BOOL bReadOnly)
    hr = pStream->Init(lpMemory, cbSize, TRUE);
    if (FAILED(hr)) {
        goto Exit;
    }

    pNF = NEW(CNodeFactory(pdbglog));
    if (!pNF) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    if (!bBehaviorEverett) {
        pNF->DisableAppliesTo();
    }

    hr = pXMLParser->SetFactory(pNF);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pXMLParser->SetInput(pStream);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pXMLParser->Run(-1);
    if (FAILED(hr)) {
        DEBUGOUT(pdbglog, 0, ID_FUSLOG_XML_PARSE_ERROR_MEMORY);
        goto Exit;
    }

    *ppNodeFactory = pNF;
    (*ppNodeFactory)->AddRef();

Exit:
    SAFERELEASE(pStream);
    SAFERELEASE(pNF);
    SAFERELEASE(pXMLParser);

    return hr;
}

BOOL IsMatchingVersion(LPCWSTR wzVerCfg, LPCWSTR wzVerSource)
{
    HRESULT                         hr = S_OK;
    BOOL                            bMatch = FALSE;
    BOOL                            bAnchor = FALSE;
    LPWSTR                          wzVer = NULL;
    LPWSTR                          wzPos = NULL;
    ULONGLONG                       ullVer = 0;
    ULONGLONG                       ullVerLow = 0;
    ULONGLONG                       ullVerHigh = 0;

    ASSERT(wzVerCfg && wzVerSource);

    if (!FusionCompareString(wzVerCfg, wzVerSource)) {
        // Exact match
        bMatch = TRUE;
        goto Exit;
    }

    // See if wzVerCfg contains a range

    wzVer = WSTRDupDynamic(wzVerCfg);
    if (!wzVer) {
        goto Exit;
    }

    wzPos = wzVer;

    while (*wzPos) {
        // Anchor null the first time we find a space
        if (*wzPos == L'-' || *wzVer == L' ') {
            *wzPos++ = L'\0';
            bAnchor = TRUE;
            break;
        }

        wzPos++;
    }

    if (!bAnchor) {
        goto Exit;
    }

    hr = GetVersionFromString(wzVer, &ullVerLow);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Skip the spaces

    while (*wzPos) {
        if (*wzPos == L' ') {
            wzPos++;
            continue;
        }

        break;
    }
        
    if (!*wzPos) {
        goto Exit;
    }

    hr = GetVersionFromString(wzPos, &ullVerHigh);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = GetVersionFromString(wzVerSource, &ullVer);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (ullVer >= ullVerLow && ullVer <= ullVerHigh) {
        bMatch = TRUE;
    }

Exit:
    SAFEDELETEARRAY(wzVer);

    return bMatch;
}

HRESULT GetVersionFromString(LPCWSTR wzVersionIn, ULONGLONG *pullVer)
{
    HRESULT                            hr = S_OK;
    LPWSTR                             wzVersion = NULL;
    LPWSTR                             wzStart = NULL;
    LPWSTR                             wzCur = NULL;
    int                                i;
    WORD                               wVerMajor = 0;
    WORD                               wVerMinor = 0;
    WORD                               wVerRev = 0;
    WORD                               wVerBld = 0;
    DWORD                              dwVerHigh;
    DWORD                              dwVerLow;
    WORD                              *pawVersion[4] = { &wVerMajor, &wVerMinor,
                                                         &wVerBld, &wVerRev };
    WORD                               cVersions = sizeof(pawVersion) / sizeof(pawVersion[0]);


    ASSERT(wzVersionIn && pullVer);

    wzVersion = WSTRDupDynamic(wzVersionIn);
    if (!wzVersion) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzStart = wzVersion;
    wzCur = wzVersion;

    for (i = 0; i < cVersions; i++) {
        while (*wzCur && *wzCur != L'.') {
            wzCur++;
        }
    
        if (!wzCur && cVersions != 4) {
            // malformed version string
            hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
            goto Exit;
        }

        *wzCur++ = L'\0';
        *(pawVersion[i]) = (WORD)StrToInt(wzStart);

        wzStart = wzCur;
    }

    dwVerHigh = (((DWORD)wVerMajor << 16) & 0xFFFF0000);
    dwVerHigh |= ((DWORD)(wVerMinor) & 0x0000FFFF);

    dwVerLow = (((DWORD)wVerBld << 16) & 0xFFFF0000);
    dwVerLow |= ((DWORD)(wVerRev) & 0x0000FFFF);

    *pullVer = (((ULONGLONG)dwVerHigh << 32) & 0xFFFFFFFF00000000) | (dwVerLow & 0xFFFFFFFF);

Exit:
    SAFEDELETEARRAY(wzVersion);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\dll\makefile.inc ===
localgac:
        copy fusion.localgac $(URTTARGET)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\dll\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "FUSION.DLL"
#define VER_FILEDESCRIPTION_STR "Assembly manager\0"
#define VER_ORIGFILENAME_STR    "fusion.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\adl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "debmacro.h"
#include <windows.h>
#include <wincrypt.h>
#include "fusionp.h"
#include "list.h"
#include "adl.h"
#include "cor.h"
#include "asmimprt.h"
#include "asm.h"
#include "cblist.h"
#include "asmint.h"
#include "helpers.h"
#include "appctx.h"
#include "actasm.h"
#include "naming.h"
#include "dbglog.h"
#include "lock.h"

extern List<CAssemblyDownload *>              *g_pDownloadList;
extern CRITICAL_SECTION                        g_csDownload;

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
extern BOOL g_bFoundUrlmon;
#endif

FusionTag(TagADL, "Fusion", "Downloader");

HRESULT CAssemblyDownload::Create(CAssemblyDownload **ppadl,
                                  IDownloadMgr *pDLMgr,
                                  ICodebaseList *pCodebaseList,
                                  CDebugLog *pdbglog,
                                  LONGLONG llFlags)
{
    HRESULT                    hr = S_OK;
    HRESULT                    hrRet = S_OK;
    CAssemblyDownload         *padl = NULL;
    DWORD                      cbBuf = 0;
    DWORD                      dwNumCodebase = 0;
    LPWSTR                     pwzBuf = NULL;
    int                        iRet = 0;
        
    if (!ppadl || !pCodebaseList) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Create download object

    padl = NEW(CAssemblyDownload(pCodebaseList, pDLMgr, pdbglog, llFlags));
    if (!padl) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = padl->Init();
    if (FAILED(hr)) {
        SAFEDELETE(padl);
        goto Exit;
    }

    // Done. Give back the pointer to the newly created download object.

    *ppadl = padl;
    padl->AddRef();

Exit:
    return hr;
}

CAssemblyDownload::CAssemblyDownload(ICodebaseList *pCodebaseList,
                                     IDownloadMgr *pDLMgr,
                                     CDebugLog *pdbglog,
                                     LONGLONG llFlags)
: _state(ADLSTATE_INITIALIZE)
, _cRef(0)
, _hrResult(S_OK)
, _pwzUrl(NULL)
, _pCodebaseList(pCodebaseList)
, _pDLMgr(pDLMgr)
, _llFlags(llFlags)
, _pdbglog(pdbglog)
, _bInitCS(FALSE)
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
, _pProt(NULL)
, _pHook(NULL)
, _pSession(NULL)
#endif
{
    _dwSig = 'DMSA';

    if (_pCodebaseList) {
        _pCodebaseList->AddRef();
    }

    if (_pDLMgr) {
        _pDLMgr->AddRef();
    }

    if (_pdbglog) {
        _pdbglog->AddRef();
    }
}

CAssemblyDownload::~CAssemblyDownload()
{
    LISTNODE                      listnode = NULL;
    LISTNODE                      pos = NULL;
    CClientBinding               *pclient = NULL;

    if (_pwzUrl) {
        delete [] _pwzUrl;
    }

    if (_pCodebaseList) {
        _pCodebaseList->Release();
    }

    if (_pDLMgr) {
        _pDLMgr->Release();
    }

    if (_pdbglog) {
        _pdbglog->Release();
    }

    pos = _clientList.GetHeadPosition();
    // If we still have client's we're in trouble. Not only would we be
    // leaking them, these clients were not removed from the list by
    // CompleteAll, so they'll never get the DONE notification.
    ASSERT(!pos); 

    if (_bInitCS) {
        DeleteCriticalSection(&_cs);
    }
}

HRESULT CAssemblyDownload::Init()
{
    HRESULT                         hr = S_OK;
    
    __try {
        InitializeCriticalSection(&_cs);
        _bInitCS = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}


STDMETHODIMP_(ULONG) CAssemblyDownload::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CAssemblyDownload::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }
    
    return ulRef;
}

HRESULT CAssemblyDownload::SetUrl(LPCWSTR pwzUrl)
{
    HRESULT                           hr = S_OK;
    CCriticalSection                  cs(&_cs);
    int                               iLen;

    hr = cs.Lock();
    if (FAILED(hr)) {
        return hr;
    }

    if (pwzUrl) {
        if (_pwzUrl) {
            delete [] _pwzUrl;
            _pwzUrl = NULL;
        }

        iLen = lstrlen(pwzUrl) + 1;

        _pwzUrl = NEW(WCHAR[iLen]);
        if (!_pwzUrl) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        lstrcpynW(_pwzUrl, pwzUrl, iLen);
    }
    else {
        hr = E_INVALIDARG;
    }

Exit:
    cs.Unlock();
    return hr;
}

HRESULT CAssemblyDownload::AddClient(IAssemblyBindSink *pAsmBindSink, 
                                     BOOL bCallStartBinding)
{
    HRESULT                             hr = S_OK;
    CClientBinding                     *pclient = NULL;

    if (!pAsmBindSink) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Ref count released during CompleteAll
    pclient = NEW(CClientBinding(this, pAsmBindSink));
    if (!pclient) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = AddClient(pclient, bCallStartBinding);
    if (FAILED(hr)) {
        // We failed, so we never got added to the client list.
        SAFERELEASE(pclient);
    }

Exit:
    return hr;
}

HRESULT CAssemblyDownload::AddClient(CClientBinding *pclient, BOOL bCallStartBinding)
{
    HRESULT                         hr = S_OK;
    CCriticalSection                cs(&_cs);

    if (!pclient) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Cannot add new client in these states
    // ADLSTATE_COMPLETE_ALL is okay because we will just
    // call OnStopBinding on the next message receipt.

    hr = cs.Lock(); // ensure state is correct
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_state == ADLSTATE_DONE) {
        
        // We are trying to piggyback on a download that is already finished.
        if (SUCCEEDED(_hrResult)) {
            // A download just finished, and installation worked.
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
        else {
            // The download/installation didn't succeed. The client must
            // initiate a new download altogether.
            hr = _hrResult;
        }
            
        goto LeaveCSExit;
    }
    else if (_state == ADLSTATE_ABORT) {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        goto LeaveCSExit;
    }

    // Critical section protects us here too
    _clientList.AddTail(pclient);

    cs.Unlock();

    if (bCallStartBinding) {
        pclient->CallStartBinding();
    }

    goto Exit;

LeaveCSExit:
    cs.Unlock();

Exit:
    return hr;    
}

HRESULT CAssemblyDownload::KickOffDownload(BOOL bFirstDownload)
{
    HRESULT                        hr = S_OK;
    LPWSTR                         pwzUrl = NULL;
    WCHAR                          wzFilePath[MAX_PATH];
    BOOL                           bIsFileUrl = FALSE;
    BOOL                           bEnabled = FALSE;
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
    IOInetProtocolSink            *pSink = NULL;
    IOInetBindInfo                *pBindInfo = NULL;
    DWORD                          dwBindingFlags = PI_LOADAPPDIRECT | PI_PREFERDEFAULTHANDLER;
    DWORD                          dw;
#endif
    CCriticalSection               cs(&_cs);
    CCriticalSection               csDownload(&g_csDownload);

    wzFilePath[0] = L'\0';

    // If we're aborted, or done, we can't do anything here
    
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_state == ADLSTATE_DONE) {
        hr = S_FALSE;
        goto Exit;
    }

    // Dupe detection. If we end up hitting a dupe, then the CClientBinding
    // that was keeping a refcount on us, releases us, and adds itself as
    // a client to the duped download. In this case, we'll come back, and
    // this download object could be destroyed--that's why we AddRef/Release
    // around the dupe checking code.

    if (bFirstDownload) {
        // This is a top-level download (ie. not a probe download called from
        // DownloadNextCodebase

        AddRef();
        hr = CheckDuplicate();
        if (hr == E_PENDING) {
            cs.Unlock();
            Release();
            goto Exit;
        }
        Release();
    
        // Not a duplicate. Add ourselves to the global download list.
        
        hr = csDownload.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        AddRef();
        g_pDownloadList->AddTail(this);

        csDownload.Unlock();
    
    }

    // BUGBUG: Should we extend the range of the crit sect, so nobody
    // can abort while we are kicking off the download?
    // Careful! PrepNextDownload/CompleteAll call the client back!
    cs.Unlock();

    hr = GetNextCodebase(&bIsFileUrl, wzFilePath, MAX_PATH);
    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        // This must have been a case where all remaining probing URLs were file://,
        // and none of them existed. That is, we never get here (KickOffDownload)
        // unless the codebase list is non-empty, so this return result
        // from GetNextCodebase could only have resulted because we rejected
        // all remaining URLs.

        hr = DownloadComplete(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), NULL, NULL, FALSE);

        // Not really pending, just tell client the result is reported via
        // bind sink.

        if (SUCCEEDED(hr)) {
            hr = E_PENDING;
        }
        
        goto Exit;
    }
    else if (FAILED(hr)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_CODEBASE_RETRIEVE_FAILURE, hr);
        goto Exit;
    }

    DEBUGOUT1(_pdbglog, 0, ID_FUSLOG_ATTEMPT_NEW_DOWNLOAD, _pwzUrl);

    if (bIsFileUrl) {
        hr = DownloadComplete(S_OK, wzFilePath, NULL, FALSE);

        // We're not really pending, but E_PENDING means that the client
        // will get the IAssembly via the bind sink (not the ppv returned
        // in the call to BindToObject).

        if (SUCCEEDED(hr)) {
            hr = E_PENDING; 
        }
        goto Exit;
    }
#ifndef FUSION_CODE_DOWNLOAD_ENABLED
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        goto Exit;
    }
#else

    if (!g_bFoundUrlmon) {
       DEBUGOUT(_pdbglog, 1, ID_FUSLOG_URLMON_MISSING);
       hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
       goto Exit;
    }

    hr = _pDLMgr->DownloadEnabled(&bEnabled);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!bEnabled) {
        hr = FUSION_E_CODE_DOWNLOAD_DISABLED;
        goto Exit;
    }

    pwzUrl = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzUrl) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dw = MAX_URL_LENGTH;
    hr = UrlEscapeW(_pwzUrl, pwzUrl, &dw, URL_ESCAPE_PERCENT);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Really must do a download

    hr = CoInternetGetSession(0, &_pSession, 0);
    if (hr == NOERROR) {
        hr = _pSession->CreateBinding(
            NULL,             // [in ] BindCtx, always NULL
            pwzUrl,           // [in ] url
            NULL,             // [in ] IUnknown for Aggregration
            NULL,             // [out] IUNknown for Aggregration
            &_pProt,          // [out] return pProt pointer
            dwBindingFlags
        );
    }

    // Create a protocolHook (sink) and Start the async operation
    if (hr == NOERROR) {
        ASSERT(_pHook == NULL);

        hr = COInetProtocolHook::Create(&_pHook, this, _pProt, pwzUrl, _pdbglog);
        
        if (SUCCEEDED(hr)) {
            _pHook->QueryInterface(IID_IOInetProtocolSink, (void**)&pSink);
            _pHook->QueryInterface(IID_IOInetBindInfo, (void**)&pBindInfo);
        }

        if (_pProt && pSink && pBindInfo) {
            IOInetProtocol *pProt;

            CCriticalSection csLocal(&_cs);

            hr = csLocal.Lock();
            if (FAILED(hr)) {
                goto Exit;
            }

            _state = ADLSTATE_DOWNLOADING;

            csLocal.Unlock();

            // _pProt->Start may call us back synchronously on the stack.
            // If this is a failure, we will attempt the next codebase,
            // causing a release of _pProt while on the stack. When URLMON
            // unwinds, the object will be released already. Thus, we need
            // to keep the pProt alive here, by addref'ing it locally in
            // this stack frame.

            pProt = _pProt;
            pProt->AddRef();
            
            hr = _pProt->Start(pwzUrl, pSink, pBindInfo, PI_FORCE_ASYNC, 0);

            pProt->Release();
            pSink->Release();
            pBindInfo->Release();
        }
    }

    if (_state == ADLSTATE_DONE) {
        // Could have completed everything within _pProt->Start 
        // return E_PENDING because this indicates the pUnk will be returned
        // via the bindsink
        hr = E_PENDING;
        goto Exit;
    }
    
    // Changing state requires sempahore

    if (SUCCEEDED(hr)) {
        hr = E_PENDING; // Urlmon bug. Start always returns S_OK.
    }
    else if (hr != E_PENDING) {
        // Download did not start properly
        
        _hrResult = hr;
    }
#endif

Exit:
    SAFEDELETEARRAY(pwzUrl);

    if (FAILED(hr) && hr != E_PENDING) {
        LISTNODE         listnode;
        CCriticalSection csDL(&g_csDownload);

        _hrResult = hr;

        // Fatal error!
        
        // If we added ourselves to the download list, we should remove
        // ourselves immediately!

        HRESULT hrLock = csDL.Lock();
        if (FAILED(hrLock)) {
            return hrLock;
        }

        listnode = g_pDownloadList->Find(this);
        if (listnode) {
            g_pDownloadList->RemoveAt(listnode);
            // release ourselves since we are removing from the global dl list
            Release();
        }

        csDL.Unlock();
    }

    return hr;
}

HRESULT CAssemblyDownload::GetNextCodebase(BOOL *pbIsFileUrl, LPWSTR wzFilePath,
                                           DWORD cbLen)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  wzNextCodebase = NULL;
    DWORD                                   cbCodebase;
    DWORD                                   dwSize;
    BOOL                                    bIsFileUrl = FALSE;
    DWORD                                   dwFlags = 0;
    CCriticalSection                        cs(&_cs);

    ASSERT(pbIsFileUrl && wzFilePath);

    *pbIsFileUrl = FALSE;

    for (;;) {

        cbCodebase = 0;
        hr = _pCodebaseList->GetCodebase(0, &dwFlags, NULL, &cbCodebase);
        if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            // could not get codebase
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto Exit;
        }
    
        wzNextCodebase = NEW(WCHAR[cbCodebase]);
        if (!wzNextCodebase) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        hr = _pCodebaseList->GetCodebase(0, &dwFlags, wzNextCodebase, &cbCodebase);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        hr = _pCodebaseList->RemoveCodebase(0);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        // Check if we are a UNC or file:// URL. If we are, we don't have
        // to do a download, and can call setup right away.
    
        bIsFileUrl = UrlIsW(wzNextCodebase, URLIS_FILEURL);
        if (bIsFileUrl) {
            dwSize = cbLen;
            if (FAILED(PathCreateFromUrlWrap(wzNextCodebase, wzFilePath, &dwSize, 0))) {
                wzFilePath[0] = L'\0';
            }
    
            if (GetFileAttributes(wzFilePath) == -1) {
                // File doesn't exist. Try the next URL.
                DEBUGOUT1(_pdbglog, 0, ID_FUSLOG_ATTEMPT_NEW_DOWNLOAD, wzNextCodebase);

                ReportProgress(dwFlags, 0, 0, ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE,
                              (LPCWSTR)wzNextCodebase, _hrResult);

                // Re-check state. 

                if (FAILED(cs.Lock())) {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
                
                if (_state == ADLSTATE_DONE) {
                    // We could get here if we were aborted.

                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    cs.Unlock();
                    goto Exit;
                }

                cs.Unlock();

                _hrResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

                SAFEDELETEARRAY(wzNextCodebase);
                continue;
            }
        }
#ifndef FUSION_CODE_DOWNLOAD_ENABLED
        else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto Exit;
        }
#endif

        break;
    }

    *pbIsFileUrl = bIsFileUrl;
    hr = PrepNextDownload(wzNextCodebase, dwFlags);

    
Exit:
    SAFEDELETEARRAY(wzNextCodebase);

    return hr;
}

HRESULT CAssemblyDownload::DownloadComplete(HRESULT hrResult,
                                            LPOLESTR pwzFileName,
                                            const FILETIME *pftLastMod,
                                            BOOL bTerminate)
{
    CCriticalSection           cs(&_cs);
    int                        iLen = 0;

    // Terminate the protocol

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
    if (_pProt && bTerminate) {
        _pProt->Terminate(0);
    }
#endif

    _hrResult = cs.Lock();
    if (FAILED(_hrResult)) {
        goto Exit;
    }
    
    if (_state == ADLSTATE_DONE) {
        _hrResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        cs.Unlock();
        goto Exit;
    }
    else if (_state == ADLSTATE_ABORT) {
        // Only happens from the fatal abort case
        _hrResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    else {
        _state = ADLSTATE_DOWNLOAD_COMPLETE;
        _hrResult = hrResult;
    }

    cs.Unlock();

    if (SUCCEEDED(hrResult)) {
        // Download successful, change to next state.
        ASSERT(pwzFileName);

        _hrResult = cs.Lock();
        if (FAILED(_hrResult)) {
            goto Exit;
        }

        if (_state != ADLSTATE_ABORT) {
            _state = ADLSTATE_SETUP;
        }

        cs.Unlock();

        hrResult = DoSetup(pwzFileName, pftLastMod);
        if (hrResult == S_FALSE) {
            hrResult = DownloadNextCodebase();
        }
    }
    else {
        // Failed Download. 
        if (_hrResult != HRESULT_FROM_WIN32(ERROR_CANCELLED)) {
            hrResult = DownloadNextCodebase();
        }
        else {
            // This is the fatal abort case
            CompleteAll(NULL);
        }
    }

Exit:
    return hrResult;
}

HRESULT CAssemblyDownload::DownloadNextCodebase()
{
    HRESULT                 hr = S_OK;
    LPWSTR                  wzNextCodebase = NULL;
    DWORD                   dwNumCodebase;

    _pCodebaseList->GetCount(&dwNumCodebase);

    if (dwNumCodebase) {
        // Try next codebase

        hr = KickOffDownload(FALSE);
    }
    else {
        IUnknown                            *pUnk = NULL;

        // No more codebases remaining
        
        if (_pDLMgr) {
            hr = _pDLMgr->ProbeFailed(&pUnk);
            if (hr == S_OK) {
                if (pUnk) {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_PROBE_FAIL_BUT_ASM_FOUND);
                }
                _hrResult = S_OK;
            }
            else if (hr == S_FALSE) {
                // Probing failed, but we were redirected to a new codebase.

                _pCodebaseList->GetCount(&dwNumCodebase);
                ASSERT(dwNumCodebase);

                hr = KickOffDownload(FALSE);

                goto Exit;
            }
            else {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                _hrResult = hr;
            }
        }

        CompleteAll(pUnk);
        SAFERELEASE(pUnk);
    }

Exit:
    return hr;
}

HRESULT CAssemblyDownload::PrepNextDownload(LPWSTR pwzNextCodebase, DWORD dwFlags)
{
    HRESULT                                  hr = S_OK;
    CClientBinding                          *pclient = NULL;
    CCriticalSection                         cs(&_cs);

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
    // Clean up CAssemblyDownload for next download
    
    if (_pHook) {
        _pHook->Release();
        _pHook = NULL;
    }

    if (_pSession) {
        _pSession->Release();
        _pSession = NULL;
    }

    if (_pProt) {
        _pProt->Release();
        _pProt = NULL;
    }
#endif

    // Set the new URL
    
    SetUrl((LPCWSTR)pwzNextCodebase);

    // Notify all clients that we are trying the next codebase

    ReportProgress(dwFlags, 0, 0, ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE,
                   (LPCWSTR)_pwzUrl, _hrResult);


    // Re-initialize our state
    
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_state == ADLSTATE_DONE) {
        // We could get here if we were aborted.

        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        cs.Unlock();
        goto Exit;
    }

    _state = ADLSTATE_INITIALIZE;

    cs.Unlock();

Exit:
    return hr;
}

HRESULT CAssemblyDownload::DoSetup(LPOLESTR pwzFileName, const FILETIME *pftLastMod)
{
    HRESULT                            hr = S_OK;
    IAssemblyModuleImport             *pModImport = NULL;
    IAssembly                         *pAssembly = NULL;
    IUnknown                          *pUnk = NULL;
    CCriticalSection                   cs(&_cs);


    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_state == ADLSTATE_ABORT) {
        _hrResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        hr = _hrResult;

        cs.Unlock();
        CompleteAll(NULL);
        goto Exit;
    }
    cs.Unlock();

    if (_pDLMgr) {
        _hrResult = _pDLMgr->DoSetup(_pwzUrl, pwzFileName, pftLastMod, &pUnk);
        if (_hrResult == S_FALSE) {
            hr = cs.Lock();
            if (FAILED(hr)) {
                goto Exit;
            }

            _state = ADLSTATE_DOWNLOADING;

            cs.Unlock();

            hr = S_FALSE;
            goto Exit;
        }
    }
    else {
        _hrResult = S_OK;
    }

    if (FAILED(_hrResult)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_ASM_SETUP_FAILURE, _hrResult);
        _pCodebaseList->RemoveAll();
    }

    // Store _hrResult, since it is possible that after CompleteAll, this
    // object may be destroyed. See note in CompleteAll code.

    hr = _hrResult;

    CompleteAll(pUnk);

    if (pUnk) {
        pUnk->Release();
    }

Exit:
    return hr;
}

HRESULT CAssemblyDownload::CompleteAll(IUnknown *pUnk)
{
    HRESULT                       hr = S_OK;
    LISTNODE                      pos = 0;
    CClientBinding               *pclient = NULL;
    LISTNODE                      listnode;
    CCriticalSection              cs(&_cs);
    CCriticalSection              csDownload(&g_csDownload);

    // Remove ourselves from the global download list
    hr = csDownload.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }
    
    listnode = g_pDownloadList->Find(this);
    if (listnode) {
        g_pDownloadList->RemoveAt(listnode);
        // release ourselves since we are removing from the global dl list
        Release();
    }
    
    csDownload.Unlock();

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_state == ADLSTATE_DONE) {
        hr = _hrResult;
        cs.Unlock();
        goto Exit;
    }

    _state = ADLSTATE_COMPLETE_ALL;
    cs.Unlock();

    // AddRef ourselves because this object may be destroyed after the
    // following loop. We send the DONE notification to the client, who
    // will probably release the IBinding. This decreases the ref count on
    // the CClientBinding to 1, and we will then immediately release the
    // remaining count on the CClientBinding. This causes us to Release
    // this CAssemblyDownload.
    //
    // It is possible that the only ref count left on the CAssemblyDownload
    // after this block is held by the download protocol hook
    // (COInetProtocolHook). If he has already been released, this object
    // will be gone!
    //
    // Under normal circumstances, it seems that this doesn't usually happen.
    // That is, the COInetProtocolHook usually is released well after this
    // point, so this object is kept alive, however, better safe than sorry.
    //
    // Also, if this is file://, it's ok because BTO is still on the stack
    // and BTO has a ref count on this obj until BTO retruns (ie. this
    // small scenario won't happen in file:// binds).
    //
    // Need to be careful when we unwind the stack here that we don't
    // touch any member vars.
    
    AddRef();

    for (;;) {
        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        pos = _clientList.GetHeadPosition();
        if (!pos) {
            _state = ADLSTATE_DONE;
            cs.Unlock();
            break;
        }
        pclient = _clientList.GetAt(pos);

        ASSERT(pclient);
        ASSERT(pclient->GetBindSink());

        _clientList.RemoveAt(pos);

        cs.Unlock();

        // Report bind log available

        pclient->GetBindSink()->OnProgress(ASM_NOTIFICATION_BIND_LOG,
                                           S_OK, NULL, 0, 0, _pdbglog);
        
        // Report done notificaton

        pclient->GetBindSink()->OnProgress(ASM_NOTIFICATION_DONE,
                                           _hrResult, NULL, 0, 0,
                                           pUnk);
        pclient->Release();
    }

#ifdef FUSION_PARTIAL_BIND_DEBUG
    if (g_dwForceLog || (_pDLMgr->LogResult() == S_OK && FAILED(_hrResult)) ||
        _pDLMgr->LogResult() == E_FAIL) {
#else
    if (g_dwForceLog || (_pDLMgr->LogResult() == S_OK && FAILED(_hrResult))) {
#endif
        if (_pdbglog) {
            _pdbglog->SetResultCode(_hrResult);
        }

        DUMPDEBUGLOG(_pdbglog, g_dwLogLevel, _hrResult);
    }
    
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    _state = ADLSTATE_DONE;
    cs.Unlock();

    
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
    if (_pHook) {
        _pHook->Release();
        _pHook = NULL;
    }

    if (_pSession) {
        _pSession->Release();
        _pSession = NULL;
    }

    if (_pProt) {
        _pProt->Release();
        _pProt = NULL;
    }
#endif

    // It is possible that we're going to be destroyed here. See note
    // above.

    Release();

Exit:
    return hr;
}

HRESULT CAssemblyDownload::FatalAbort(HRESULT hrResult)
{
    HRESULT                       hr = S_OK;

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
    CCriticalSection              cs(&_cs);

    if (_pProt) {
        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        _state = ADLSTATE_ABORT;
        cs.Unlock();
    
        hr = _pProt->Abort(hrResult, 0);
    }
Exit:
#endif

    return hr;
}

HRESULT CAssemblyDownload::RealAbort(CClientBinding *pclient)
{
    HRESULT                     hr = S_OK;
    LISTNODE                    pos = 0;
    int                         iNum = 0;
    CCriticalSection            cs(&_cs);
    
    // Critical section ensures integrity of list, and ensures the
    // state variable is correct.

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_state >= ADLSTATE_COMPLETE_ALL) {
        hr = E_PENDING;  // OnStopBinding is pending. Can't really abort.
        goto LeaveCSExit;
    }

    iNum = _clientList.GetCount();

    if (iNum == 1) {
        // This is the last client interested in the download.
        // We must really do an abort (or try at least).

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
        if (!_pProt) {
#endif
            // We don't even have a pProt yet (abort was called on the
            // stack).
            _state = ADLSTATE_ABORT;
            _hrResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            cs.Unlock();

            CompleteAll(NULL);

            goto Exit;
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
        }
        else {
            if (_state >= ADLSTATE_DOWNLOAD_COMPLETE) {
                hr = E_PENDING;
                _state = ADLSTATE_ABORT;
                cs.Unlock();
            }
            else {
                _state = ADLSTATE_ABORT;
    
                cs.Unlock();
    
                // When we get back from Abort, the CAssemblyDownload
                // may be toasted
                hr = _pProt->Abort(HRESULT_FROM_WIN32(ERROR_CANCELLED), 0); 
    
                if (hr == INET_E_RESULT_DISPATCHED) {
                    hr = E_PENDING;
                }
    
            }

            goto Exit;
        }
#endif
    }
    else {
        // There is more than one client interested in this download
        // but this particular one wants to abort. Just remove him from
        // the notification list, and call the OnStopBinding. 

        ASSERT((iNum > 1) && "We have no clients!");
        pos = _clientList.Find(pclient);

        ASSERT(pos && "Can't find client binding in CAssemblyDownload client list");
        _clientList.RemoveAt(pos);


        ASSERT(pclient->GetBindSink());

        cs.Unlock();

        pclient->GetBindSink()->OnProgress(ASM_NOTIFICATION_DONE,
                                           HRESULT_FROM_WIN32(ERROR_CANCELLED),
                                           NULL, 0, 0, NULL);
        pclient->Release();

        goto Exit;
    }

LeaveCSExit:
    cs.Unlock();
    
Exit:
    return hr;
}

HRESULT CAssemblyDownload::ReportProgress(ULONG ulStatusCode,
                                          ULONG ulProgress,
                                          ULONG ulProgressMax,
                                          DWORD dwNotification,
                                          LPCWSTR wzNotification,
                                          HRESULT hrNotification)
{
    HRESULT                               hr = S_OK;
    LISTNODE                              pos = NULL;
    LISTNODE                              posCur = NULL;
    CClientBinding                       *pclient = NULL;
    CClientBinding                       *pNext = NULL;
    IAssemblyBindSink                    *pbindsink = NULL;
    CCriticalSection                      cs(&_cs);

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }
    
    pos = _clientList.GetHeadPosition();
    pclient = _clientList.GetAt(pos);
    pclient->Lock();

    cs.Unlock();

    if (ulStatusCode == ASMLOC_CODEBASE_HINT) {
        ulProgress = -1;
        ulProgressMax = -1;
    }

    while (pos) {
        posCur = pos;
        pbindsink = pclient->GetBindSink();
        ASSERT(pbindsink);
        pbindsink->OnProgress(dwNotification, hrNotification, wzNotification,
                              ulProgress, ulProgressMax, NULL);

        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        _clientList.GetNext(pos);
        if (pos) {
            pNext = _clientList.GetAt(pos);
            pNext->Lock();
        }
        else {
            pNext = NULL;
        }

        pclient->UnLock();

        if (pclient->IsPendingDelete()) {
            cs.Unlock();
            RealAbort(pclient);
        }
        else {
            cs.Unlock();
        }

        pclient = pNext;
    }

Exit:
    return hr;
}
                
HRESULT CAssemblyDownload::ClientAbort(CClientBinding *pclient)
{
    HRESULT                          hr = S_OK;
    CCriticalSection                 cs(&_cs);

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }
    
    if (!pclient->LockCount()) {
        cs.Unlock();
        hr = RealAbort(pclient);
    }
    else {
        pclient->SetPendingDelete(TRUE);
        hr = E_PENDING;
        cs.Unlock();
    }

Exit:
    return hr;
}

HRESULT CAssemblyDownload::PreDownload(BOOL bCallCompleteAll, void **ppv)
{
    HRESULT                                       hr = S_OK;
    IAssembly                                    *pAssembly = NULL;
    CCriticalSection                              cs(&_cs);

    if ((!bCallCompleteAll && !ppv)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure we're not in abort state
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    // If someone aborted, then we would have already reported the abort
    // back to the client. If it was the last client, we would have already
    // transitioned to the DONE state as well. In this case, there's nothing
    // to do.

    if (_state == ADLSTATE_DONE) {
        hr = _hrResult;
        cs.Unlock();
        goto Exit;
    }

    // Do a lookup in the cache and return an IAssembly object if found.

    hr = _pDLMgr->PreDownloadCheck((void **)&pAssembly);
    if (hr == S_OK) {
        // We hit in doing the cache lookup
        ASSERT(pAssembly);

        cs.Unlock();
        if (bCallCompleteAll) {
            _hrResult = S_OK;
            CompleteAll(pAssembly);
        }
        else {
            *ppv = pAssembly;
            pAssembly->AddRef();
        }

        pAssembly->Release();

        hr = S_FALSE;
        goto Exit;
    }
    else if (FAILED(hr)) {
        // Catastrophic error doing predownload check
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_PREDOWNLOAD_FAILURE, hr);
        cs.Unlock();
        goto Exit;
    }

    hr = S_OK;
    
    cs.Unlock();

Exit:
    if (FAILED(hr) && hr != E_PENDING) {
        _hrResult = hr;
    }

    return hr;
}

HRESULT CAssemblyDownload::CheckDuplicate()
{
    HRESULT                             hr = S_OK;
    LISTNODE                            listnode = NULL;
    LISTNODE                            pos = NULL;
    CAssemblyDownload                  *padlCur = NULL;
    CClientBinding                     *pbinding = NULL;
    IDownloadMgr                       *pDLMgrCur = NULL;
    CCriticalSection                    csDownload(&g_csDownload);
    int                                 i;
    int                                 iCount;

    ASSERT(_pDLMgr);

    hr = csDownload.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    listnode = g_pDownloadList->GetHeadPosition();
    iCount = g_pDownloadList->GetCount();
    
    for (i = 0; i < iCount; i++) {
        padlCur = g_pDownloadList->GetNext(listnode);
        ASSERT(padlCur);

        hr = padlCur->GetDownloadMgr(&pDLMgrCur);
        ASSERT(hr == S_OK);

        hr = pDLMgrCur->IsDuplicate(_pDLMgr);
        if (hr == S_OK) {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_DOWNLOAD_PIGGYBACK);

            pos = _clientList.GetHeadPosition();
            
            // There should only ever be one client because we only check
            // dupes before we start a real asm download, and this CAsmDownload
            // hasn't been added to the global download list yet.
            
            ASSERT(pos && _clientList.GetCount() == 1);

            pbinding = _clientList.GetAt(pos);
            ASSERT(pbinding);

            pbinding->SwitchDownloader(padlCur);
            padlCur->AddClient(pbinding, FALSE);
            _clientList.RemoveAll();

            SAFERELEASE(pDLMgrCur);

            csDownload.Unlock();
            hr = E_PENDING;

            goto Exit;
        }

        SAFERELEASE(pDLMgrCur);
    }

    csDownload.Unlock();

Exit:
    
    return hr;
}

HRESULT CAssemblyDownload::GetDownloadMgr(IDownloadMgr **ppDLMgr)
{
    HRESULT                                     hr = S_OK;

    if (!ppDLMgr) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppDLMgr = _pDLMgr;
    ASSERT(*ppDLMgr);

    (*ppDLMgr)->AddRef();

Exit:
    return hr;
}

HRESULT CAssemblyDownload::SetResult(HRESULT hrResult)
{
    _hrResult = hrResult;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\dll\guids.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       guids.c
//
//  Contents:   Helium guids 
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------

#define INITGUID
#include <guiddef.h>

DEFINE_GUID( IID_IAssembly,
0xff08d7d4,0x04c2,0x11d3,0x94,0xaa,0x00,0xc0,0x4f,0xc3,0x08,0xff);

DEFINE_GUID( IID_IAssemblyName,             
0xCD193BC0,0xB4BC,0x11d2,0x98,0x33,0x0,0xC0,0x4F,0xC3,0x1D,0x2E);

DEFINE_GUID( IID_IApplicationContext,
0x7c23ff90,0x33af,0x11d3,0x95, 0xda,0x00,0xa0,0x24,0xa8,0x5b,0x51);

DEFINE_GUID( IID_IAssemblyBindSink,
0xaf0bc960,0x0b9a,0x11d3,0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51);

DEFINE_GUID( IID_IAssemblyBinding,
0xcfe52a80,0x12bd,0x11d3,0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51);

DEFINE_GUID( IID_IFusionBindLog,
0x67e9f87d,0x8b8a,0x4a90,0x9d, 0x3e, 0x85, 0xed, 0x5b, 0x2d, 0xcc, 0x83);

DEFINE_GUID( IID_IAssemblyManifestImport,
0xde9a68ba,0x0fa2,0x11d3,0x94, 0xaa, 0x00, 0xc0, 0x4f, 0xc3, 0x08, 0xff);

DEFINE_GUID( IID_IAssemblyModuleImport,
0xda0cd4b0,0x1117,0x11d3,0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51);

DEFINE_GUID( IID_IAssemblyCacheItem,
0x9e3aaeb4,0xd1cd,0x11d2,0xba,0xb9,0x0,0xc0,0x4f,0x8e,0xce,0xae);

DEFINE_GUID( IID_IAssemblyScavenger,
0x21b8916c,0xf28e,0x11d2,0xa4,0x73,0x00,0xcc,0xff,0x8e,0xf4,0x48);

DEFINE_GUID( IID_IAssemblyCache,
0xe707dcde,0xd1cd,0x11d2,0xba,0xb9,0x0,0xc0,0x4f,0x8e,0xce,0xae);

DEFINE_GUID( IID_IAssemblyEnum,
0x21b8916c,0xf28e,0x11d2,0xa4,0x73,0x00,0xc0,0x4f,0x8e,0xf4,0x48);

DEFINE_GUID( IID_ICodebaseList,
0xd8fb9bd6,0x3969,0x11D3,0xb4,0xaf,0x00,0xc0,0x4f,0x8e,0xcb,0x26);

DEFINE_GUID( IID_IDownloadMgr,
0x0A6F16F8,0xACD7,0x11d3,0xB4,0xED,0x00,0xC0,0x4F,0x8E,0xCB,0x26);


DEFINE_GUID( IID_IHistoryAssembly,
0xe6096a07,0xe188,0x4a49,0x8d,0x50,0x2a,0x01,0x72,0xa0,0xd2,0x05);

DEFINE_GUID( IID_IHistoryReader,
0x1d23df4d,0xa1e2,0x4b8b,0x93,0xd6,0x6e,0xa3,0xdc,0x28,0x5a,0x54);

DEFINE_GUID( IID_IMetaDataAssemblyImportControl,
0xcc8529d9,0xf336,0x471b,0xb6,0x0a,0xc7,0xc8,0xee,0x9b,0x84,0x92);

DEFINE_GUID( IID_IFusionLoadContext,
0x022AB2BA,0x7367,0x49fc,0xA1,0xC5,0x0E,0x7C,0xC0,0x37,0xCA,0xAB);

DEFINE_GUID(IID_IInstallReferenceItem,
0x582dac66,0xe678,0x449f,0xab, 0xa6, 0x6f, 0xaa, 0xec, 0x8a, 0x93, 0x94);

DEFINE_GUID( IID_IInstallReferenceEnum,
0x56b1a988,0x7c0c,0x4aa2,0x86, 0x39, 0xc3, 0xeb, 0x5a, 0x90, 0x22, 0x6f);

DEFINE_GUID(
        CLSID_MIITEMTABLE,
    0x2a6175d6,
    0x0b94,
    0x4460,
    0xa5, 0xed, 0xa2, 0x80, 0xe6, 0x2f, 0x51, 0x09);

DEFINE_GUID(
        CLSID_PROGIDTABLE,
    0xc4036ce8,
    0xba82,
    0x444d,
    0x9b, 0x77, 0x8a, 0x5b, 0x20, 0xd3, 0x5c, 0xf3);

DEFINE_GUID(
        CLSID_CATEGORYTABLE,
    0x1f9c65dc,
    0xac87,
    0x4d13,
    0xa7, 0x26, 0xdd, 0x04, 0x5f, 0xdb, 0x73, 0xec);

DEFINE_GUID(
        CLSID_CATCLASSTABLE,
    0x46582f67,
    0xe7b1,
    0x4a57,
    0xa5, 0x63, 0x5f, 0x0d, 0x12, 0x2a, 0xe0, 0xd4);

DEFINE_GUID(
        CLSID_COMCLASSTABLE,
    0x2907c59a,
    0x5a72,
    0x4f2d,
    0x99, 0x7c, 0x9f, 0x61, 0xe8, 0x46, 0x09, 0x17);

DEFINE_GUID(
        CLSID_MIDEPENDENCYGROUPTABLE,
    0xf17db45b,
    0xec53,
    0x4168,
    0x8e, 0x1a, 0xcf, 0x6a, 0x38, 0x5a, 0xd2, 0x9f);

DEFINE_GUID(
        CLSID_MIDEPASSEMBLYTABLE,
    0x654a222c,
    0x6490,
    0x4aac,
    0x94, 0x02, 0xba, 0xc7, 0x0c, 0x02, 0xf8, 0x6b);

DEFINE_GUID(
        CLSID_MIDEPASSYVERSIONTABLE,
    0x4a26d401,
    0x2f3c,
    0x4ffd,
    0xa5, 0xca, 0xe0, 0x81, 0x53, 0x8d, 0xa1, 0x9f);

DEFINE_GUID(
    FMTID_ManifestInformation,
    0x41ebbe29,
    0xe07a,
    0x4bd4,
    0x80, 0x66, 0x03, 0x7c, 0x9a, 0x64, 0x76, 0xc1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\dll\dllmain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//  Helium library of Naming, Binding and Manifest Services
//

#include "fusionp.h"
#include "list.h"
#include "debmacro.h"
#include "clbutils.h"
#include "helpers.h"
#include "dbglog.h"
#include "fusionheap.h"
#include "msi.h"
#include "delayimp.h"
#include "histinfo.h"
#include "cacheutils.h"
#include "actasm.h"

FusionTag(TagDll, "Fusion", "DllMain Log");


HANDLE BaseDllHandle;
LCID g_lcid;


HRESULT GetScevengerQuotasFromReg(DWORD *pdwZapQuotaInGAC,
                                  DWORD *pdwDownloadQuotaAdmin,
                                  DWORD *pdwDownloadQuotaUser);

UserAccessMode g_GAC_AccessMode = READ_ONLY;

UserAccessMode g_DownloadCache_AccessMode = READ_WRITE;

UserAccessMode g_CurrUserPermissions = READ_ONLY;

#define LOCAL_SETTINGS TEXT("\\Local Settings")

WCHAR g_UserFusionCacheDir[MAX_PATH+1];
WCHAR g_szWindowsDir[MAX_PATH+1];
WCHAR g_wzEXEPath[MAX_PATH+1];

HINSTANCE g_hInst = NULL;
LONG      g_cRef=0;

WCHAR g_FusionDllPath[MAX_PATH+1];


// Clean-up state
BOOL g_bCleanUpDone = FALSE;
HMODULE g_hMSCorEE = NULL;

typedef void (*RELEASEFUSIONINTERFACES)(HMODULE hmod);

// needed for directdb's code
SYSTEM_INFO         g_SystemInfo={0};


CRITICAL_SECTION g_csInitClb = {0};

// Downloader critical section
CRITICAL_SECTION g_csDownload; 

#ifdef FUSION_CODE_DOWNLOAD_ENABLED
BOOL g_bFoundUrlmon;
#endif

// Debug log
CRITICAL_SECTION g_csBindLog;

// Max app binding history snapshots
DWORD g_dwMaxAppHistory;

DWORD g_dwDisableMSIPeek;

extern "C" int __cdecl main(void) {return 0;}

extern int SetOsFlag(void) ;

extern BOOL OnUnicodeSystem(void);

BOOL InitFusionCriticalSections();


#define CHECKHRWIN32(x) do { HRESULT __hr = (x); if (FAILED(__hr)) { ulResult = ::FusionMapHRESULTToWin32(__hr); goto Exit; } } while (0)

DWORD g_dwDisableLog;
DWORD g_dwLogLevel;
DWORD g_dwForceLog;
DWORD g_dwLogFailures;
DWORD g_dwLogResourceBinds;

typedef HRESULT (*pfnMsiProvideAssemblyW)(LPCWSTR wzAssemblyName, LPCWSTR szAppContext,
                                          DWORD dwInstallMode, DWORD dwUnused,
                                          LPWSTR lpPathBuf, DWORD *pcchPathBuf);
typedef INSTALLUILEVEL (*pfnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND *phWnd);
typedef UINT (*pfnMsiInstallProductW)(LPCWSTR wzPackagePath, LPCWSTR wzCmdLine);

pfnMsiProvideAssemblyW     g_pfnMsiProvideAssemblyW;
pfnMsiSetInternalUI        g_pfnMsiSetInternalUI;
pfnMsiInstallProductW      g_pfnMsiInstallProductW;
BOOL                       g_bCheckedMSIPresent;
HMODULE                    g_hModMSI;

List<CAssemblyDownload *>               *g_pDownloadList;


//----------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{
    DWORD                           dwSize;
    DWORD                           dwType;
    DWORD                           lResult;
    HKEY                            hkey=0;
    HKEY                            hDkey=0;
    RELEASEFUSIONINTERFACES         pfnReleaseFusionInterfaces = NULL;
    OSVERSIONINFOA                  osi;
        
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
#ifndef USE_FUSWRAPPERS
            OnUnicodeSystem();
#endif

            BaseDllHandle = hInst;
            g_hInst = hInst;
            GetModuleFileName(g_hInst, g_FusionDllPath, MAX_PATH);

            memset(&osi, 0, sizeof(osi));
            osi.dwOSVersionInfoSize = sizeof(osi);
            if (!GetVersionExA(&osi)) {
                return FALSE;
            }

            // On XP and above, the lcid used for string comparisons should
            // be locale invariant. Other platforms should use US English.

            if (osi.dwMajorVersion >= 5 && osi.dwMinorVersion >= 1 && osi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                g_lcid = MAKELCID(LOCALE_INVARIANT, SORT_DEFAULT);
            }
            else {
                g_lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
            }

            if (!::FusionpInitializeHeap(hInst))
                return FALSE;

            FusionLog(TagDll, NULL, "+FUSION DLL_PROCESS_ATTACH");
            if (!InitFusionCriticalSections()) {
                return FALSE;
            }

            GetSystemInfo(&g_SystemInfo);

            DisableThreadLibraryCalls(hInst);
            SetOsFlag();
            SetCurrentUserPermissions();

            GetScevengerQuotasFromReg(NULL, NULL, NULL);

            if (!GetModuleFileNameW(NULL, g_wzEXEPath, MAX_PATH)) {
                lstrcpyW(g_wzEXEPath, L"Unknown");
            }
    
            FusionLog(TagDll, NULL, "-FUSION DLL_PROCESS_ATTACH");
            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
            if(lResult == ERROR_SUCCESS) {
                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_DISABLE, NULL,
                                          &dwType, (LPBYTE)&g_dwDisableLog, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwDisableLog = 0;
                }

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_LEVEL, NULL,
                                          &dwType, (LPBYTE)&g_dwLogLevel, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwLogLevel = 1;
                }

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_FORCE, NULL,
                                          &dwType, (LPBYTE)&g_dwForceLog, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwForceLog = 0;
                }

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_FAILURES, NULL,
                                          &dwType, (LPBYTE)&g_dwLogFailures, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwLogFailures = 0;
                }

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_RESOURCE_BINDS, NULL,
                                          &dwType, (LPBYTE)&g_dwLogResourceBinds, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwLogResourceBinds = 0;
                }

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_MAX_APP_HISTORY, NULL,
                                          &dwType, (LPBYTE)&g_dwMaxAppHistory, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwMaxAppHistory = MAX_PERSISTED_ACTIVATIONS_DEFAULT;
                }

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, L"DisableMSIPeek", NULL,
                                          &dwType, (LPBYTE)&g_dwDisableMSIPeek, &dwSize);
                if (lResult != ERROR_SUCCESS) {
                    g_dwDisableMSIPeek = FALSE;
                }

                RegCloseKey(hkey);
            }
            else {
                g_dwDisableLog = 0;
                g_dwLogLevel = 1;
                g_dwLogFailures = 0;
                g_dwForceLog = 0;
                g_dwMaxAppHistory = MAX_PERSISTED_ACTIVATIONS_DEFAULT;
                g_dwDisableMSIPeek = FALSE;
            }
            
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
            TCHAR                           szUrlmonPath[MAX_PATH];
            TCHAR                          *szFileName;

            if (SearchPath(NULL, TEXT("URLMON.DLL"), NULL, MAX_PATH, szUrlmonPath,
                           &szFileName)) {
                g_bFoundUrlmon = TRUE;
            }
            else {
                g_bFoundUrlmon = FALSE;
            }
#endif

            g_pfnMsiProvideAssemblyW = NULL;
            g_pfnMsiSetInternalUI = NULL;
            g_pfnMsiInstallProductW = NULL;
            g_bCheckedMSIPresent = FALSE;
            g_hModMSI = 0;
            
            g_pDownloadList = new List<CAssemblyDownload *>;
            if (!g_pDownloadList) {
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
             FusionLog(TagDll, NULL, "+FUSION DLL_PROCESS_DETACH");
             
#if 0
             if (pvReserved == NULL) // FreeLibrary, not ExitProcess
             {
                 // the comments say you can pass NULL to __FUnloadDelayLoadedDLL, but
                 // it doesn't look like that is implemented
                 //
                 // Further, there is __FUnloadDelayLoadedDLL2, looks necessary
                 // for Win64, but I haven't found it.
                 PCSTR dll;
                 for (dll = DELAYLOAD; *dll ; dll += strlen(dll) + 1)
                 {
//     #if DELAYLOAD_VERSION >= 0x200
                     __FUnloadDelayLoadedDLL2(dll);
//     #else
                     __FUnloadDelayLoadedDLL(dll);
//     #endif
                }
             }
#endif
             if (!g_bCleanUpDone) {
                 // The URT has not called our cleanup code. This means
                 // we are the first ones to be unloaded. Call the URT
                 // to tell them we are going away, and this is their
                 // last chance to release Fusion interface pointers.

                 if (!g_hMSCorEE) {
                     g_hMSCorEE = GetModuleHandleA("mscoree.dll");
                 }

                 if (g_hMSCorEE) {
                     pfnReleaseFusionInterfaces = (RELEASEFUSIONINTERFACES)GetProcAddress(g_hMSCorEE, "ReleaseFusionInterfaces");

                     if (pfnReleaseFusionInterfaces) {
                         (*pfnReleaseFusionInterfaces)(g_hInst);
                     }
                 }
             }

             DeleteCriticalSection(&g_csInitClb);
             DeleteCriticalSection(&g_csDownload);
             DeleteCriticalSection(&g_csBindLog);

             SAFEDELETE(g_pDownloadList);

             FusionLog(TagDll, NULL, "-FUSION DLL_PROCESS_DETACH");

             // Let's see what's left allocated...
#if FUSION_DEBUG_HEAP
             if (g_dwLeakTrack) {
                 ::FusionpDumpHeap("");
             }
#endif
             ::FusionpUninitializeHeap();
             
             break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            ASSERT(FALSE); // we disabled these, right?
            break;
    }
    return TRUE;
}

void ReleaseURTInterfaces()
{
    // If this function is called, it means the URT is being unloaded
    // before Fusion. We need to set a state variable to make sure when
    // we reach DLL_PROCESS_DETACH, we don't call the URT back to
    // release our interfaces.

    // The URT is responsible for releasing all Fusion interface pointers
    // during their cleanup. Since they are going away first, it's okay
    // for them to call release on our objects. If they release their
    // outstanding IAssembly ptrs, we'll release their IMetaDataAssemblyImport
    // so it'll just work. 
    //
    // Thus no explicit cleanup work needs to be done here, except to set the
    // state variable.

    g_bCleanUpDone = TRUE;
}

BOOL InitFusionCriticalSections()
{
    __try {
        InitializeCriticalSection(&g_csInitClb);

        // downloader init
        InitializeCriticalSection(&g_csDownload);

        InitializeCriticalSection(&g_csBindLog);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
   return TRUE;
}


STDAPI DllUnregisterServer(void)
{
    return TRUE;
}


// ----------------------------------------------------------------------------
// DllAddRef
// ----------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// ----------------------------------------------------------------------------
// DllRelease
// ----------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}


EXTERN_C
BOOL
FusionpInitializeHeap(
    HINSTANCE hInstance
    )
{
    return TRUE;
}

EXTERN_C
VOID
FusionpUninitializeHeap()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\cblist.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "fuspriv.h"
#include "debmacro.h"
#include "cblist.h"

// CCodebaseEntry

CCodebaseEntry::CCodebaseEntry()
: _dwFlags(0)
, _pwzCodebase(NULL)
{
}

CCodebaseEntry::~CCodebaseEntry()
{
    SAFEDELETEARRAY(_pwzCodebase);
}

// CCodebaseList

CCodebaseList::CCodebaseList()
: _cRef(1)
{
    _dwSig = ' LBC';
}

CCodebaseList::~CCodebaseList()
{
    RemoveAll();
}

STDMETHODIMP_(ULONG) CCodebaseList::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CCodebaseList::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }
    
    return ulRef;
}

HRESULT CCodebaseList::QueryInterface(REFIID iid, void **ppvObj)
{
    HRESULT hr = NOERROR;
    *ppvObj = NULL;

    if (iid == IID_IUnknown  || iid == IID_ICodebaseList) {
        *ppvObj = static_cast<ICodebaseList *>(this);
    } 
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppvObj) {
        AddRef();
    }

    return hr;
}    


HRESULT CCodebaseList::AddCodebase(LPCWSTR wzCodebase, DWORD dwFlags)
{
    HRESULT                            hr = S_OK;
    DWORD                              dwLen;
    CCodebaseEntry                    *pEntry = NULL;
    
    if (!wzCodebase) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pEntry = NEW(CCodebaseEntry);
    if (!pEntry) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    dwLen = lstrlenW(wzCodebase) + 1;

    pEntry->_pwzCodebase = NEW(WCHAR[dwLen]);
    if (!pEntry->_pwzCodebase) {
        hr = E_OUTOFMEMORY;
        SAFEDELETE(pEntry);
        goto Exit;
    }

    lstrcpyW(pEntry->_pwzCodebase, wzCodebase);
    pEntry->_dwFlags = dwFlags;

    _listCodebase.AddTail(pEntry);

Exit:
    return hr;
}

HRESULT CCodebaseList::RemoveCodebase(DWORD dwIndex)
{
    HRESULT                              hr = S_OK;
    LISTNODE                             pos = NULL;
    LISTNODE                             oldpos = NULL;
    CCodebaseEntry                      *pEntry = NULL;
    LPWSTR                               wzCodebase = NULL;
    DWORD                                dwNumCodebases = 0;
    DWORD                                i;
    

    dwNumCodebases = _listCodebase.GetCount();

    if (dwIndex > dwNumCodebases) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    if (!dwNumCodebases) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto Exit;
    }
    
    pos = _listCodebase.GetHeadPosition();

    ASSERT(pos);

    for (i = 0; i < dwNumCodebases; i++) {
        oldpos = pos;
        pEntry = _listCodebase.GetNext(pos);
        ASSERT(pEntry);

        if (i == dwIndex) {
            SAFEDELETE(pEntry);
            _listCodebase.RemoveAt(oldpos);
            break;
        }
    }
        
Exit:
    return hr;
}

HRESULT CCodebaseList::GetCodebase(DWORD dwIndex, DWORD *pdwFlags, LPWSTR wzCodebase,
                                   DWORD *pcbCodebase)
{
    HRESULT                              hr = E_UNEXPECTED;
    LISTNODE                             pos = NULL;
    LISTNODE                             oldpos = NULL;
    CCodebaseEntry                      *pEntry = NULL;
    DWORD                                dwNumCodebases;
    DWORD                                i;
    DWORD                                dwCodebaseLen;

    dwNumCodebases = _listCodebase.GetCount();

    if (dwIndex > dwNumCodebases || !pcbCodebase || !pdwFlags) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!dwNumCodebases) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto Exit;
    }

    pos = _listCodebase.GetHeadPosition();

    ASSERT(pos);

    for (i = 0; i < dwNumCodebases; i++) {
        oldpos = pos;
        pEntry = _listCodebase.GetNext(pos);
        ASSERT(pEntry);

        if (i == dwIndex) {
            *pdwFlags = pEntry->_dwFlags;
            
            dwCodebaseLen = lstrlenW(pEntry->_pwzCodebase) + 1;

            if (!wzCodebase || (*pcbCodebase < dwCodebaseLen)) {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            else {
                lstrcpyW(wzCodebase, pEntry->_pwzCodebase);
                hr = S_OK;
            }

            *pcbCodebase = dwCodebaseLen;
            break;
        }
    }

Exit:
    return hr;
}

HRESULT CCodebaseList::RemoveAll()
{
    LISTNODE                      pos = NULL;
    CCodebaseEntry               *pEntry = NULL;

    pos = _listCodebase.GetHeadPosition();

    while (pos) {
        pEntry = _listCodebase.GetNext(pos);
        ASSERT(pEntry);

        SAFEDELETE(pEntry);
    }

    _listCodebase.RemoveAll();

    return S_OK;
}

HRESULT CCodebaseList::GetCount(DWORD *pdwCount)
{
    HRESULT                           hr = S_OK;

    if (!pdwCount) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pdwCount = _listCodebase.GetCount();

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\adlmgr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "fuspriv.h"
#include "adlmgr.h"
#include "naming.h"
#include "asm.h"
#include "appctx.h"
#include "asmint.h"
#include "actasm.h"
#include "asmcache.h"
#include "asmimprt.h"
#include "asmitem.h"
#include "cblist.h"
#include "policy.h"
#include "helpers.h"
#include "util.h"
#include "mdlmgr.h"
#include "hashnode.h"
#include "msi.h"
#include "parse.h"
#include "history.h"
#include "xmlparser.h"
#include "nodefact.h"
#include "pcycache.h"
#include "cache.h"
#include "transprt.h"
#include "fdi.h"
#include "enum.h"
#include "nodefact.h"
#include "fusionpriv.h"
#include "lock.h"

extern DWORD g_dwMaxAppHistory;
extern DWORD g_dwDisableMSIPeek;
extern WCHAR g_wzEXEPath[MAX_PATH+1];

#define REG_KEY_MSI_APP_DEPLOYMENT_GLOBAL                        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed\\%ws\\Installer\\Assemblies\\Global"
#define REG_KEY_MSI_APP_DEPLOYMENT_PRIVATE                       L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed\\%ws\\Installer\\Assemblies\\%ws"
#define REG_KEY_MSI_USER_INSTALLED_GLOBAL                        L"Software\\Microsoft\\Installer\\Assemblies\\Global"
#define REG_KEY_MSI_USER_INSTALLED_PRIVATE                       L"Software\\Microsoft\\Installer\\Assemblies\\%ws"
#define REG_KEY_MSI_MACHINE_INSTALLED_GLOBAL                     L"SOFTWARE\\Classes\\Installer\\Assemblies\\Global"
#define REG_KEY_MSI_MACHINE_INSTALLED_PRIVATE                    L"SOFTWARE\\Classes\\Installer\\Assemblies\\%ws"

HRESULT VerifySignatureHelper(CTransCache *pTC, DWORD dwVerifyFlags);

typedef enum tagIdxVars {
    IDX_VAR_NAME = 0,
    IDX_VAR_CULTURE,
    NUM_VARS
} IdxVars;

// Order of g_pwzVars must follow the enum order above.

const WCHAR *g_pwzVars[] = {
    L"%NAME%",
    L"%CULTURE%",
};

const WCHAR *g_pwzRetailHeuristics[] = {
    L"%CULTURE%/%NAME%",
    L"%CULTURE%/%NAME%/%NAME%",
};

const LPWSTR g_wzDLLProbeExtension = L".DLL";
const LPWSTR g_wzEXEProbeExtension = L".EXE";

const WCHAR *g_pwzProbeExts[] = {
    g_wzDLLProbeExtension,
    g_wzEXEProbeExtension
};

const unsigned int g_uiNumRetailHeuristics = sizeof(g_pwzRetailHeuristics) / sizeof(g_pwzRetailHeuristics[0]);
const unsigned int g_uiNumProbeExtensions = sizeof(g_pwzProbeExts) / sizeof(g_pwzProbeExts[0]);

const unsigned int MAX_VERSION_LENGTH = 12; // 65536 is max length == 5 digits
                                            // 5 * 2 = 10 (4 version fields)
                                            // 10 + 2 = 12 (delimiters + NULL)

#define MAX_HASH_TABLE_SIZE                    127

typedef enum tagEXTENSION_TYPE {
    EXT_UNKNOWN,
    EXT_CAB,
    EXT_MSI
} EXTENSION_TYPE;

typedef HRESULT (*pfnMsiProvideAssemblyW)(LPCWSTR wzAssemblyName, LPCWSTR szAppContext,
                                          DWORD dwInstallMode, DWORD dwUnused,
                                          LPWSTR lpPathBuf, DWORD *pcchPathBuf);
typedef INSTALLUILEVEL (*pfnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND *phWnd);
typedef UINT (*pfnMsiInstallProductW)(LPCWSTR wzPackagePath, LPCWSTR wzCmdLine);

extern BOOL g_bCheckedMSIPresent;
extern pfnMsiProvideAssemblyW g_pfnMsiProvideAssemblyW;
extern pfnMsiInstallProductW g_pfnMsiInstallProductW;
extern pfnMsiSetInternalUI g_pfnMsiSetInternalUI;
extern HMODULE g_hModMSI;
extern CRITICAL_SECTION g_csDownload;

extern DWORD g_dwLogResourceBinds;
extern DWORD g_dwForceLog;

HRESULT CAsmDownloadMgr::Create(CAsmDownloadMgr **ppadm,
                                IAssemblyName *pNameRefSource,
                                IApplicationContext *pAppCtx,
                                ICodebaseList *pCodebaseList,
                                LPCWSTR wzBTOCodebase,
                                CDebugLog *pdbglog,
                                void *pvReserved,
                                LONGLONG llFlags)
{
    HRESULT                             hr = S_OK;
    DWORD                               cbBuf = 0;
    DWORD                               dwCount = 0;
    CAsmDownloadMgr                    *padm = NULL;
    CPolicyCache                       *pPolicyCache = NULL;
    DWORD                               dwSize;

    if (!ppadm || !pNameRefSource || !pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppadm = NULL;

    // Process flag overrides passed in via app context

    cbBuf = 0;
    hr = pAppCtx->Get(ACTAG_BINPATH_PROBE_ONLY, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        llFlags |= ASM_BINDF_BINPATH_PROBE_ONLY;
    }

    cbBuf = 0;
    hr = pAppCtx->Get(ACTAG_DISALLOW_APPLYPUBLISHERPOLICY, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        llFlags |= ASM_BINDF_DISALLOW_APPLYPUBLISHERPOLICY;
    }

    cbBuf = 0;
    hr = pAppCtx->Get(ACTAG_DISALLOW_APP_BINDING_REDIRECTS, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        llFlags |= ASM_BINDF_DISALLOW_APPBINDINGREDIRECTS;
    }

    cbBuf = 0;
    hr = pAppCtx->Get(ACTAG_FORCE_CACHE_INSTALL, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        llFlags |= ASM_BINDF_FORCE_CACHE_INSTALL;
    }

    cbBuf = 0;
    hr = pAppCtx->Get(ACTAG_RFS_INTEGRITY_CHECK, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        llFlags |= ASM_BINDF_RFS_INTEGRITY_CHECK;
    }

    cbBuf = 0;
    hr = pAppCtx->Get(ACTAG_RFS_MODULE_CHECK, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        llFlags |= ASM_BINDF_RFS_MODULE_CHECK;
    }

    dwSize = sizeof(pPolicyCache);
    pAppCtx->Get(ACTAG_APP_POLICY_CACHE, &pPolicyCache, &dwSize, APP_CTX_FLAGS_INTERFACE);

    // Create download object

    padm = NEW(CAsmDownloadMgr(pNameRefSource, pAppCtx, pCodebaseList,
                               pPolicyCache, pdbglog, llFlags));
    if (!padm) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = padm->Init(wzBTOCodebase, pvReserved);
    if (FAILED(hr)) {
        SAFEDELETE(padm);
        goto Exit;
    }

    *ppadm = padm;

Exit:
    SAFERELEASE(pPolicyCache);

    return hr;
}

CAsmDownloadMgr::CAsmDownloadMgr(IAssemblyName *pNameRefSource,
                                 IApplicationContext *pAppCtx,
                                 ICodebaseList *pCodebaseList,
                                 CPolicyCache *pPolicyCache,
                                 CDebugLog *pdbglog,
                                 LONGLONG llFlags)
: _cRef(1)
, _pNameRefSource(pNameRefSource)
, _pNameRefPolicy(NULL)
, _pAppCtx(pAppCtx)
, _llFlags(llFlags)
, _pAsm(NULL)
, _pCodebaseList(pCodebaseList)
, _pdbglog(pdbglog)
, _wzBTOCodebase(NULL)
, _wzSharedPathHint(NULL)
, _bCodebaseHintUsed(FALSE)
, _bReadCfgSettings(FALSE)
, _pPolicyCache(pPolicyCache)
, _pLoadContext(NULL)
, _pwzProbingBase(NULL)
#ifdef FUSION_PARTIAL_BIND_DEBUG
, _bGACPartial(FALSE)
#endif
{
    _dwSig = 'MMSA';
    
    if (_pNameRefSource) {
        _pNameRefSource->AddRef();
    }

    if (_pCodebaseList) {
        _pCodebaseList->AddRef();
    }

    if (_pAppCtx) {
        _pAppCtx->AddRef();
    }

    if (_pdbglog) {
        _pdbglog->AddRef();
    }

    if (_pPolicyCache) {
        _pPolicyCache->AddRef();
    }

#ifdef FUSION_PARTIAL_BIND_DEBUG
    lstrcpyW(_wzParentName, L"(Unknown)");
#endif

    memset(&_bindHistory, 0, sizeof(_bindHistory));
}

CAsmDownloadMgr::~CAsmDownloadMgr()
{
    SAFERELEASE(_pNameRefSource);
    SAFERELEASE(_pNameRefPolicy);
    SAFERELEASE(_pCodebaseList);
    SAFERELEASE(_pAppCtx);
    SAFERELEASE(_pAsm);
    SAFERELEASE(_pdbglog);
    SAFERELEASE(_pPolicyCache);
    SAFERELEASE(_pLoadContext);

    SAFEDELETEARRAY(_wzBTOCodebase);
    SAFEDELETEARRAY(_wzSharedPathHint);
    SAFEDELETEARRAY(_pwzProbingBase);
}

HRESULT CAsmDownloadMgr::Init(LPCWSTR wzBTOCodebase, void *pvReserved)
{
    HRESULT                             hr = S_OK;
    LPWSTR                              wzHint = NULL;
    DWORD                               dwLen;
    BOOL                                bWhereRefBind = FALSE;
    LPWSTR                              wzProbingBase=NULL;

    ASSERT(_pNameRefSource);
    
    dwLen = 0;
    if (_pNameRefSource->GetName(&dwLen, NULL) != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        bWhereRefBind = TRUE;
    }

    if (bWhereRefBind) {
        dwLen = sizeof(_pLoadContext);
        hr = _pAppCtx->Get(ACTAG_LOAD_CONTEXT_LOADFROM, &_pLoadContext, &dwLen, APP_CTX_FLAGS_INTERFACE);

        if (FAILED(hr) || !_pLoadContext) {
            hr = E_UNEXPECTED;
            goto Exit;
        }
    }

    if (wzBTOCodebase) {
        dwLen = lstrlenW(wzBTOCodebase) + 1;
        _wzBTOCodebase = NEW(WCHAR[dwLen]);
        if (!_wzBTOCodebase) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        lstrcpyW(_wzBTOCodebase, wzBTOCodebase);
    }

    if (pvReserved && (_llFlags & ASM_BINDF_SHARED_BINPATH_HINT)) {
        wzHint = (WCHAR *)pvReserved;
        dwLen = lstrlenW(wzHint) + 1;
        
        _wzSharedPathHint = NEW(WCHAR[dwLen]);
        if (!_wzSharedPathHint) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        lstrcpyW(_wzSharedPathHint, wzHint);
    }
    else if (pvReserved && (_llFlags & ASM_BINDF_PARENT_ASM_HINT) && !bWhereRefBind) {
        IAssembly              *pAsm = (IAssembly *)pvReserved;
        CAssembly              *pCAsm = dynamic_cast<CAssembly *>(pAsm);

        ASSERT(pCAsm);

#ifdef FUSION_PARTIAL_BIND_DEBUG
        {
            IAssemblyName *pNameDef = NULL;
            DWORD          dwSize = MAX_URL_LENGTH;

            pCAsm->GetAssemblyNameDef(&pNameDef);
            if (pNameDef) {
                pNameDef->GetDisplayName(_wzParentName, &dwSize, 0);
                SAFERELEASE(pNameDef);
            }
        }
#endif

        pCAsm->GetLoadContext(&_pLoadContext);

        // If parent is not the default context, then extract the parent
        // asm URL for probing base. If parent was in the LoadFrom context,
        // then it *must* mean that the asm was not located in the GAC,
        // and cannot be found via regular appbase probing. This is because
        // the runtime guarantees this by issuing Loads after each LoadFrom,
        // and discarding the LoadFrom IAssembly if it can be found through
        // Assembly.Load. Thus, the IAssembly we have now *must* have a
        // valid codebase.

        if (_pLoadContext && _pLoadContext->GetContextType() == LOADCTX_TYPE_LOADFROM) {
            DWORD               dwSize;

            wzProbingBase = NEW(WCHAR[MAX_URL_LENGTH+1]);
            if (!wzProbingBase)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            wzProbingBase[0] = L'\0';

            dwSize = MAX_URL_LENGTH;
            hr = pCAsm->GetProbingBase(wzProbingBase, &dwSize);
            if (FAILED(hr)) {
                goto Exit;
            }

            ASSERT(lstrlenW(wzProbingBase));

            _pwzProbingBase = WSTRDupDynamic(wzProbingBase);
            if (!_pwzProbingBase) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
    }

    if (!_pLoadContext) {
        // Use default load context

        dwLen = sizeof(_pLoadContext);
        hr = _pAppCtx->Get(ACTAG_LOAD_CONTEXT_DEFAULT, &_pLoadContext,
                           &dwLen, APP_CTX_FLAGS_INTERFACE);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(wzProbingBase);
    return hr;
}

//
// IUnknown Methods
//

HRESULT CAsmDownloadMgr::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDownloadMgr)) {
        *ppv = static_cast<IDownloadMgr *>(this);
    }
    else if (IsEqualIID(riid, IID_ICodebaseList)) {
        *ppv = static_cast<ICodebaseList *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CAsmDownloadMgr::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CAsmDownloadMgr::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

//
// IDownloadMgr methods
//

HRESULT CAsmDownloadMgr::DoSetup(LPCWSTR wzSourceUrl, LPCWSTR wzFilePath,
                                 const FILETIME *pftLastMod, IUnknown **ppUnk)
{
    HRESULT                            hr = S_OK;
    FILETIME                           ftLastModified;
    LPWSTR                             pwzRFS = NULL;
    LPWSTR                             pwzExt = NULL;
    BOOL                               bWhereRefBind = FALSE;
    DWORD                              dwSize = 0;
    DWORD                              dwFlag = 0;
    DWORD                              dwLen = 0;
    BOOL                               bIsFileUrl = FALSE;
    BOOL                               bRunFromSource = FALSE;
    BOOL                               bIsUNC = FALSE;
    BOOL                               bCopyModules = FALSE;
    IAssembly                         *pAsmCtx = NULL;
    EXTENSION_TYPE                     ext = EXT_UNKNOWN;
    BOOL                               bBindRecorded = FALSE;
    LPWSTR                             wzProbingBase=NULL;

    if (!wzSourceUrl || !wzFilePath) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Remove ? from http source URLs, so cache code doesn't
    // try to construct a dir containing ? (which will fail).

    if (!UrlIsW(wzSourceUrl, URLIS_FILEURL)) {
        LPWSTR               pwzArgument = StrChr(wzSourceUrl, L'?');

        if (pwzArgument) {
            *pwzArgument = L'\0';
        }
    }

    DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_DOWNLOAD_SUCCESS, wzFilePath);

    if (ppUnk) {
        *ppUnk = NULL;
    }

    pwzExt = PathFindExtension(wzFilePath);
    ASSERT(pwzExt);

    if (!FusionCompareStringI(pwzExt, L".CAB")) {
        ext = EXT_CAB;
    }
    else if (!FusionCompareStringI(pwzExt, L".MSI")) {
        ext = EXT_MSI;
    }

    dwSize = 0;
    hr = _pNameRefPolicy->GetName(&dwSize, NULL);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        bWhereRefBind = TRUE;
    }

    if (!pftLastMod) {
        hr = ::GetFileLastModified(wzFilePath, &ftLastModified);
        if (FAILED(hr)) {
            DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_LAST_MOD_FAILURE, wzFilePath);
            goto Exit;
        }
    }
    else {
        memcpy(&ftLastModified, pftLastMod, sizeof(FILETIME));
    }

    bIsFileUrl = UrlIsW(wzSourceUrl, URLIS_FILEURL);
    if (bIsFileUrl) {
        dwLen = MAX_PATH;
        hr = PathCreateFromUrlWrap((LPWSTR)wzSourceUrl, (LPWSTR)wzFilePath, &dwLen, 0);
        if (FAILED(hr)) {
            goto Exit;
        }

        // This is a file:// URL, so let's see if we can run from source.

        hr = CheckRunFromSource(wzSourceUrl, &bRunFromSource);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (!bRunFromSource) {
            // This is a shadow copy scenario. Copy the modules.
            bCopyModules = TRUE;
        }
    }

    // We never do RFS for CABs or MSIs.

    if (ext == EXT_CAB || ext == EXT_MSI) {
        bRunFromSource = FALSE;
        bCopyModules = FALSE;
    }

    // Setup the assemblies
    if (bRunFromSource) {
        hr = DoSetupRFS(wzFilePath, &ftLastModified, wzSourceUrl, bWhereRefBind, TRUE, &bBindRecorded);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        if (ext == EXT_CAB) {
            // Setup assembly from CAB file
            hr = SetupCAB(wzFilePath, wzSourceUrl, bWhereRefBind, &bBindRecorded);
        }
        else if (ext == EXT_MSI) {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_MSI_CODEBASE_UNSUPPORTED);
            hr = HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE);
            // hr = SetupMSI(wzFilePath);
        }
        else {
            // Not compressed. Push to cache.
            hr = DoSetupPushToCache(wzFilePath, wzSourceUrl, &ftLastModified,
                                    bWhereRefBind, bCopyModules, TRUE, &bBindRecorded);
        }

        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // If this is an assembly bind, and we succeeded, add the IAssembly to
    // the list of activated assemblies.

    if (hr == S_OK) {
        if (bWhereRefBind) {
            IAssembly          *pAsmActivated = NULL;
            CAssembly          *pCAsm = dynamic_cast<CAssembly *>(_pAsm);
            LPWSTR              pwzFileName;

            ASSERT(pCAsm && lstrlenW(wzSourceUrl) < MAX_URL_LENGTH);

            // Add activation to load context

            // Set the probing base to be equal to the codebase.

            wzProbingBase = NEW(WCHAR[MAX_URL_LENGTH+1]);
            if (!wzProbingBase)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            lstrcpyW(wzProbingBase, wzSourceUrl);
            pwzFileName = PathFindFileName(wzProbingBase);

            ASSERT(pwzFileName);

            *pwzFileName = L'\0';

            hr = pCAsm->SetProbingBase(wzProbingBase);
            if (FAILED(hr)) {
                goto Exit;
            }

            hr = _pLoadContext->AddActivation(_pAsm, &pAsmActivated);
            if (hr == S_FALSE) {
                SAFERELEASE(_pAsm);
                _pAsm = pAsmActivated;
                hr = S_OK;
            }
        }
        else if (!bBindRecorded) {
            // Binds will have been recorded already if this was a partial
            // assembly name bind, and when we entered CreateAssembly, we
            // found a match already in the activated assemblies list, or in
            // the cache (CreateAssembly takes uses the def to turn a partial
            // into a full-ref, after which, it applies policy, and calls
            // PreDownloadCheck again).

            if (_pwzProbingBase) {
                // We must be a child of a LoadFrom, so let's set the probing base
                CAssembly   *pCAsm = dynamic_cast<CAssembly *>(_pAsm);
                ASSERT(pCAsm);
        
                pCAsm->SetProbingBase(_pwzProbingBase);
            }

            RecordInfo();
        }

        // This download manager object will keep a ref count on the IAssembly
        // until it is destroyed. We are only destroyed after we call back
        // the client (inside CAssemblyDownload), so at the time we call
        // the client back, the IAssembly is good (and they can either addref
        // it or not, as they choose).

        *ppUnk = _pAsm;
        _pAsm->AddRef();
    }

Exit:
    SAFERELEASE(pAsmCtx);

    SAFEDELETEARRAY(pwzRFS);
    SAFEDELETEARRAY(wzProbingBase);
    return hr;    
}

HRESULT CAsmDownloadMgr::CheckRunFromSource(LPCWSTR wzSourceUrl,
                                            BOOL *pbRunFromSource)
{
    HRESULT                                 hr = S_OK;
    BOOL                                    bFCI = FALSE;
    DWORD                                   dwSize;

    if (!wzSourceUrl || !pbRunFromSource) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    ASSERT(UrlIsW(wzSourceUrl, URLIS_FILEURL));

    *pbRunFromSource = TRUE;

    // Default policy is to rfs all file:// URLs. The only exception is
    // to set FORCE_CACHE_INSTALL (ie. Shadow Copy), which can be done
    // through: bind flags, app ctx, or app.cfg file.
    
    dwSize = 0;
    hr = _pAppCtx->Get(ACTAG_FORCE_CACHE_INSTALL, NULL, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        _llFlags |= ASM_BINDF_FORCE_CACHE_INSTALL;
    }

    if (_llFlags & ASM_BINDF_FORCE_CACHE_INSTALL) {
        // We're in shadow copy mode

        // Disable FORCE_CACHE_INSTALL (shadow copy) if it's not
        // part of a list of designated shadow copy dirs.

        hr = ShadowCopyDirCheck(wzSourceUrl);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (hr == S_OK) {
            *pbRunFromSource = FALSE;
        }

    }

    hr = S_OK;

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::ProbeFailed(IUnknown **ppUnk)
{
    HRESULT                                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    IAssembly                             *pAsm = NULL;
    DWORD                                  dwSize;
    DWORD                                  dwCmpMask;
    BOOL                                   fIsPartial;
    BOOL                                   fIsStronglyNamed;

    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_FAILED_PROBING);

    if (!ppUnk) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppUnk = NULL;

    dwSize = 0;
    if (_pNameRefPolicy->GetName(&dwSize, NULL) != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        // This is a where-ref bind. Do not look in global cache.
        goto Exit;
    }
    
    fIsPartial = CAssemblyName::IsPartial(_pNameRefPolicy, &dwCmpMask);
    fIsStronglyNamed = CCache::IsStronglyNamed(_pNameRefPolicy);

    if (fIsPartial) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }
    else {
        // Probing failed for a fully-specified assembly reference. Check
        // If WindowsInstaller can install the assembly.

        hr = CheckMSIInstallAvailable(_pNameRefPolicy, _pAppCtx);
        if (hr == S_OK) {
            WCHAR                         wzAppCfg[MAX_PATH];
            
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_MSI_INSTALL_ATTEMPT);

            dwSize = sizeof(wzAppCfg);
            if (_pAppCtx->Get(ACTAG_APP_CFG_LOCAL_FILEPATH, wzAppCfg, &dwSize, 0) != S_OK) {
                lstrcpyW(wzAppCfg, g_wzEXEPath);
            }
        
            hr = MSIInstallAssembly(wzAppCfg, &pAsm);
            if (SUCCEEDED(hr)) {
                *ppUnk = pAsm;
                DEBUGOUT(_pdbglog, 1, ID_FUSLOG_MSI_ASM_INSTALL_SUCCESS);
                goto Exit;
            }
    
            // Asm not in GAC, and WI cannot provide a privatized asm. Check if WI
            // can provide asm into the global context (if assigned to the user).
        
            if (fIsStronglyNamed) {
                hr = MSIInstallAssembly(NULL, &pAsm);
                if (SUCCEEDED(hr)) {
                    *ppUnk = pAsm;
                }
            }
        }
    }

Exit:
    return hr;
}

HRESULT CheckMSIInstallAvailable(IAssemblyName *pName, IApplicationContext *pAppCtx)
{
    HRESULT                                hr = S_OK;
    CCriticalSection                       cs(&g_csDownload);

    // If we are given a name, then check whether MSI has a chance of
    // providing the assembly before LoadLibrary'ing it.
    
    if (pName && !g_dwDisableMSIPeek) {
        if (MSIProvideAssemblyPeek(pName, pAppCtx) != S_OK) {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            goto Exit;
        }
    }
        
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!g_bCheckedMSIPresent) {
        ASSERT(!g_hModMSI);

        g_hModMSI = LoadLibrary(TEXT("msi.dll"));
        if (g_hModMSI) {
            g_pfnMsiProvideAssemblyW = (pfnMsiProvideAssemblyW)GetProcAddress(g_hModMSI, "MsiProvideAssemblyW");
        }

        if (g_hModMSI) {
            g_pfnMsiSetInternalUI = (pfnMsiSetInternalUI)GetProcAddress(g_hModMSI, "MsiSetInternalUI");
        }

        if (g_hModMSI) {
            g_pfnMsiInstallProductW = (pfnMsiInstallProductW)GetProcAddress(g_hModMSI, "MsiInstallProductW");
        }

        g_bCheckedMSIPresent = TRUE;
    }
    
    cs.Unlock();

    if (!g_pfnMsiProvideAssemblyW || !g_pfnMsiSetInternalUI || !g_pfnMsiInstallProductW) {

        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::MSIInstallAssembly(LPCWSTR wzContext,
                                            IAssembly **ppAsm)
{
    HRESULT                                hr = S_OK;
    LPWSTR                                 wzDisplayName = NULL;
    LPWSTR                                 wzSourceUrl=NULL;
    WCHAR                                  wzInstalledPath[MAX_PATH];
    DWORD                                  dwLen;
    FILETIME                               ftLastModified;
    IAssemblyName                         *pNameDef = NULL;
    CAssemblyName                         *pCNameRefPolicy = NULL;
    UINT                                   lResult;
    BOOL                                   bBindRecorded = FALSE;

    ASSERT(ppAsm && g_pfnMsiProvideAssemblyW && g_pfnMsiSetInternalUI);
    
    wzInstalledPath[0] = L'\0';

    dwLen = 0;
    _pNameRefPolicy->GetDisplayName(NULL, &dwLen, 0);

    wzDisplayName = NEW(WCHAR[dwLen]);
    if (!wzDisplayName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = _pNameRefPolicy->GetDisplayName(wzDisplayName, &dwLen, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Set up for silent install

    (*g_pfnMsiSetInternalUI)(INSTALLUILEVEL_NONE, NULL);
    
    dwLen = MAX_PATH;
    lResult = (*g_pfnMsiProvideAssemblyW)(wzDisplayName, wzContext,
                                     INSTALLMODE_DEFAULT, 0, wzInstalledPath,
                                     &dwLen);
    if (lResult != ERROR_SUCCESS || !lstrlenW(wzInstalledPath)) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    wzSourceUrl = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzSourceUrl)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwLen = MAX_URL_LENGTH;
    hr = UrlCanonicalizeUnescape(wzInstalledPath, wzSourceUrl, &dwLen, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (wzContext) {
        // Privatized assembly install. Treat as a RFS bind now.

        hr = GetFileLastModified(wzInstalledPath, &ftLastModified);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        // Pass false for bWhereRefBind because we do not allow where-ref binds
        // to MSI files.
        hr = DoSetupRFS(wzInstalledPath, &ftLastModified, wzSourceUrl, FALSE, FALSE, &bBindRecorded);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        ASSERT(_pAsm);

        if (hr == S_OK) {
            SetAsmLocation(_pAsm, ASMLOC_RUN_FROM_SOURCE);
            hr = RecordInfo();
            if (FAILED(hr)) {
                goto Exit;
            }

            *ppAsm = _pAsm;
            (*ppAsm)->AddRef();
            hr = S_OK;
        }
        else {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_MSI_SUCCESS_FUSION_SETUP_FAIL);

            SAFERELEASE(_pAsm);
            goto Exit;
        }
    
    }
    else {
        // Global assembly install. Lookup in GAC.

        hr = CreateAssemblyFromCacheLookup(_pAppCtx, _pNameRefPolicy, &_pAsm, _pdbglog);
        if (hr == S_OK) {
            SetAsmLocation(_pAsm, ASMLOC_GAC);
            hr = RecordInfo();
            if (FAILED(hr)) {
                goto Exit;
            }

            *ppAsm = _pAsm;
            (*ppAsm)->AddRef();
            hr = S_OK;
        }
    }

Exit:
    SAFEDELETEARRAY(wzDisplayName);
    SAFERELEASE(pNameDef);

    SAFEDELETEARRAY(wzSourceUrl);
    return hr;
}

HRESULT CAsmDownloadMgr::DoSetupRFS(LPCWSTR wzFilePath, FILETIME *pftLastModified,
                                    LPCWSTR wzSourceUrl, BOOL bWhereRefBind,
                                    BOOL bPrivateAsmVerify, BOOL *pbBindRecorded)
{
    HRESULT                                   hr = S_OK;
    IAssembly                                *pAsm = NULL;
    IAssemblyModuleImport                    *pCurModImport = NULL;
    BOOL                                      bAsmOK = TRUE;
    BYTE                                      abCurHash[MAX_HASH_LEN];
    BYTE                                      abFileHash[MAX_HASH_LEN];
    DWORD                                     cbModHash;
    DWORD                                     cbFileHash;
    DWORD                                     dwAlgId;
    WCHAR                                     wzModPath[MAX_PATH];
    DWORD                                     cbModPath;
    int                                       idx = 0;

    ASSERT(pbBindRecorded);

    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_SETUP_RUN_FROM_SOURCE);

    // Run from source

    hr = CreateAssembly(wzFilePath, wzSourceUrl, pftLastModified, TRUE, bWhereRefBind,
                        bPrivateAsmVerify, FALSE, pbBindRecorded, &pAsm);
    if (FAILED(hr) || hr == S_FALSE) {
        goto Exit;
    }

    // Integrity checking
    // Walk all modules to make sure they are there (and are valid)

    if (_llFlags & ASM_BINDF_RFS_MODULE_CHECK) {

        while (SUCCEEDED(pAsm->GetNextAssemblyModule(idx++, &pCurModImport))) {
            if (!pCurModImport->IsAvailable()) {
                bAsmOK = FALSE;
                SAFERELEASE(pCurModImport);
                break;
            }
    
            if (_llFlags & ASM_BINDF_RFS_INTEGRITY_CHECK) {
    
                // Get the hash of this module from manifest
                hr = pCurModImport->GetHashAlgId(&dwAlgId);
                if (FAILED(hr)) {
                    break;
                }
    
                cbModHash = MAX_HASH_LEN; 
                hr = pCurModImport->GetHashValue(abCurHash, &cbModHash);
                if (FAILED(hr)) {
                    break;
                }
    
                // Get the hash of the file itself
                cbModPath = MAX_PATH;
                hr = pCurModImport->GetModulePath(wzModPath, &cbModPath);
                if (FAILED(hr)) {
                    break;
                }
    
                cbFileHash = MAX_HASH_LEN;
                // BUGBUG: Assumes TCHAR==WCHAR
                hr = GetHash(wzModPath, (ALG_ID)dwAlgId, abFileHash, &cbFileHash);
                if (FAILED(hr)) {
                    break;
                }
    
                if (!CompareHashs(cbModHash, abCurHash, abFileHash)) {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_MODULE_INTEGRITY_CHECK_FAILURE);
                    bAsmOK = FALSE;
                    SAFERELEASE(pCurModImport);
                    break;
                }
            }
    
            SAFERELEASE(pCurModImport);
        }
    
        if (FAILED(hr)) {
            SAFERELEASE(pCurModImport);
            goto Exit;
        }
    }

    if (bAsmOK) {
        ASSERT(pAsm);

        _pAsm = pAsm;
        _pAsm->AddRef();

        if (!*pbBindRecorded) {
            SetAsmLocation(_pAsm, ASMLOC_RUN_FROM_SOURCE);
        }
    }
    else {
        // At least one module is missing (or hash invalid), and client
        // requested we check for this condition..
        // Cannot run from source.

        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

Exit:
    SAFERELEASE(pAsm);

    return hr;
}

HRESULT CAsmDownloadMgr::DoSetupPushToCache(LPCWSTR wzFilePath,
                                            LPCWSTR wzSourceUrl,
                                            FILETIME *pftLastModified,
                                            BOOL bWhereRefBind,
                                            BOOL bCopyModules,
                                            BOOL bPrivateAsmVerify,
                                            BOOL *pbBindRecorded)
{
    HRESULT                             hr = S_OK;
    IAssemblyManifestImport            *pManImport = NULL;
    
    ASSERT(pbBindRecorded);

    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_SETUP_DOWNLOAD_CACHE);

    // Install to assembly cache

    // Create the assembly - here, pNameRefSource is the original (golden)
    // manifest ref; can be null, simple or strong. pNameRefPolicy is 
    // post-policy name ref if pName is strong only, null otherwise.
    hr = CreateAssembly(wzFilePath, wzSourceUrl, pftLastModified, FALSE, bWhereRefBind,
                        bPrivateAsmVerify, bCopyModules, pbBindRecorded, &_pAsm);

    if (FAILED(hr)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_SETUP_FAILURE, hr);
    }

    if (hr == S_OK && !*pbBindRecorded) {
        SetAsmLocation(_pAsm, ASMLOC_DOWNLOAD_CACHE);
    }

    return hr;
}

//
// ICodebaseList Methods.
//
// Here, we just delegate the calls to either the object passed in by the
// bind client, or our own CCodebaseList (which is created if we probe).
//

HRESULT CAsmDownloadMgr::AddCodebase(LPCWSTR wzCodebase, DWORD dwFlags)
{
    HRESULT                               hr = S_OK;

    if (!_pCodebaseList) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = _pCodebaseList->AddCodebase(wzCodebase, dwFlags);

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::RemoveCodebase(DWORD dwIndex)
{
    HRESULT                              hr = S_OK;

    if (!_pCodebaseList) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = _pCodebaseList->RemoveCodebase(dwIndex);
        
Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::GetCodebase(DWORD dwIndex, DWORD *pdwFlags, LPWSTR wzCodebase,
                                     DWORD *pcbCodebase)
{
    HRESULT                              hr = S_OK;

    if (!_pCodebaseList) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = _pCodebaseList->GetCodebase(dwIndex, pdwFlags, wzCodebase, pcbCodebase);

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::RemoveAll()
{
    HRESULT                              hr = S_OK;
    
    if (!_pCodebaseList) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = _pCodebaseList->RemoveAll();

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::GetCount(DWORD *pdwCount)
{
    HRESULT                              hr = S_OK;

    if (!_pCodebaseList) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = _pCodebaseList->GetCount(pdwCount);

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::ConstructCodebaseList(LPCWSTR wzPolicyCodebase)
{
    HRESULT                                   hr = S_OK;
    LPWSTR                                    wzAppBase = NULL;
    LPWSTR                                    pwzAppBaseClean = NULL;
    BOOL                                      bGenerateProbeURLs = TRUE;
    LPWSTR                                    wzCodebaseHint = NULL;
    LPWSTR                                    pwzFullCodebase = NULL;
    DWORD                                     cbLen;
    DWORD                                     dwLen;
    DWORD                                     dwCount;
    DWORD                                     dwExtendedAppBaseFlags = APPBASE_CHECK_DYNAMIC_DIRECTORY |
                                                                       APPBASE_CHECK_PARENT_URL |
                                                                       APPBASE_CHECK_SHARED_PATH_HINT;

    pwzFullCodebase = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzFullCodebase) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // If we were passed a pCodebaseList at construction time, we do not
    // have to build probing URLs, as long as there is at least one URL in
    // the codebase list.

    if (_pCodebaseList) {
        hr = _pCodebaseList->GetCount(&dwCount);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (hr == S_OK && dwCount) {
            bGenerateProbeURLs = FALSE;
        }
    }
    else {
        _pCodebaseList = NEW(CCodebaseList);
        if (!_pCodebaseList) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Get and canonicalize the appbase directory

    wzAppBase = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!wzAppBase) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwLen = MAX_URL_LENGTH * sizeof(WCHAR);
    hr = _pAppCtx->Get(ACTAG_APP_BASE_URL, wzAppBase, &dwLen, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    ASSERT(lstrlenW(wzAppBase));

    dwLen = lstrlenW(wzAppBase);
    ASSERT(dwLen);
    
    if (dwLen + 2 >= MAX_URL_LENGTH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }

    if (wzAppBase[dwLen - 1] != L'/' && wzAppBase[dwLen - 1] != L'\\') {
        lstrcatW(wzAppBase, L"/");
    }

    pwzAppBaseClean = StripFilePrefix(wzAppBase);
    
    // Always add the codebase from BTO to the codebase list, if policy
    // was not applied.

    if (_wzBTOCodebase && _pNameRefPolicy->IsEqual(_pNameRefSource, ASM_CMPF_DEFAULT) == S_OK) {

        // Combine codebase with appbase. If codebase is fully-qualified
        // urlcombine will just return the codebase (canonicalized form).
    
        cbLen = MAX_URL_LENGTH;
        hr = UrlCombineUnescape(pwzAppBaseClean, _wzBTOCodebase, pwzFullCodebase, &cbLen, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        _pCodebaseList->AddCodebase(pwzFullCodebase, 0);
    }
    
    // If there was a policy redirect, and codebase attached to it,
    // add this URL.

    if (wzPolicyCodebase && lstrlenW(wzPolicyCodebase)) {
        cbLen = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(wzPolicyCodebase, pwzFullCodebase, &cbLen, 0);
        if (FAILED(hr)) {
            goto Exit;
        }

        _pCodebaseList->AddCodebase(pwzFullCodebase, ASMLOC_CODEBASE_HINT);

        // It better exist at the location specified; only add this URL to
        // the probe list

        _bCodebaseHintUsed = TRUE;
        goto Exit;
    }

    if (!bGenerateProbeURLs) {
        // If we were provided a codebase list, we just needed to add the
        // binding URL to the list, and then we're done.
        goto Exit;
    }

    // Add any codebase hints from app.cfg, if we didn't get one already
    // because of policy.

    hr = GetAppCfgCodebaseHint(pwzAppBaseClean, &wzCodebaseHint);
    if (hr == S_OK) {
        _pCodebaseList->AddCodebase(wzCodebaseHint, ASMLOC_CODEBASE_HINT);
        _bCodebaseHintUsed = TRUE;
        goto Exit;
    }

    // Add probing URLs

    hr = SetupDefaultProbeList(pwzAppBaseClean, NULL, _pCodebaseList, FALSE);

Exit:
    SAFEDELETEARRAY(pwzFullCodebase);

    SAFEDELETEARRAY(wzCodebaseHint);
    SAFEDELETEARRAY(wzAppBase);
    return hr;    
}

HRESULT CAsmDownloadMgr::SetupDefaultProbeList(LPCWSTR wzAppBase,
                                               LPCWSTR wzProbeFileName,
                                               ICodebaseList *pCodebaseList,
                                               BOOL bCABProbe)
{
    HRESULT                   hr = S_OK;
    WCHAR                    *pwzValues[NUM_VARS];
    LPWSTR                    wzBinPathList = NULL;
    unsigned int              i;
    DWORD                     dwAppBaseFlags = 0;

    memset(pwzValues, 0, sizeof(pwzValues));

    if (!_pAppCtx || !pCodebaseList || !wzAppBase) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Grab data from app context and name reference

    hr = ExtractSubstitutionVars(pwzValues);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (wzProbeFileName) {
        // Over-ride for probing filename specified
        SAFEDELETEARRAY(pwzValues[IDX_VAR_NAME]);
        pwzValues[IDX_VAR_NAME] = WSTRDupDynamic(wzProbeFileName);
    }

    // If there is no name, we can't probe.

    if (!pwzValues[IDX_VAR_NAME]) {
        hr = S_FALSE;
        goto Exit;
    }

    // Prepare binpaths

    hr = PrepBinPaths(&wzBinPathList);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Probe for each of the listed extensions

    DWORD dwProbeExt;
    dwProbeExt = g_uiNumProbeExtensions;

    // Set appbase check flags

    if (!bCABProbe) {
        dwAppBaseFlags = APPBASE_CHECK_DYNAMIC_DIRECTORY | APPBASE_CHECK_SHARED_PATH_HINT;
    }

    for (i = 0; i < dwProbeExt; i++) {
        hr = GenerateProbeUrls(wzBinPathList, wzAppBase,
                               g_pwzProbeExts[i], pwzValues,
                               pCodebaseList, dwAppBaseFlags, _llFlags);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // If this is a dependency of an assembly loaded through a where-ref
    // (ie. Assembly.LoadFrom) bind, then probe the parent assembly location
    // and the end. Do not probe binpaths, or dynamic dir in this case.

    if (!bCABProbe && _pwzProbingBase) {
        // Set appbase check flags
    
        dwAppBaseFlags = APPBASE_CHECK_PARENT_URL;

        for (i = 0; i < dwProbeExt; i++) {
            hr = GenerateProbeUrls(NULL, _pwzProbingBase,
                                   g_pwzProbeExts[i], pwzValues,
                                   pCodebaseList, dwAppBaseFlags, (_llFlags & ~ASM_BINDF_BINPATH_PROBE_ONLY));
            if (FAILED(hr)) {
                goto Exit;
            }
        }
    }
    
Exit:
    // Free memory allocated by extract vars, now that the codebase list
    // has been constructed.

    for (i = 0; i < NUM_VARS; i++) {
        SAFEDELETEARRAY(pwzValues[i]);
    }

    SAFEDELETEARRAY(wzBinPathList);

    return hr;    
}

HRESULT CAsmDownloadMgr::GenerateProbeUrls(LPCWSTR wzBinPathList,
                                           LPCWSTR wzAppBase,
                                           LPCWSTR wzExt, LPWSTR pwzValues[],
                                           ICodebaseList *pCodebaseList,
                                           DWORD dwExtendedAppBaseFlags,
                                           LONGLONG dwProbingFlags)
{
    HRESULT                              hr = S_OK;
    LPWSTR                               wzBinPathCopy = NULL;
    LPWSTR                               wzCurBinPath = NULL;
    LPWSTR                               wzCurPos = NULL;
    DWORD                                cbLen = 0;
    DWORD                                dwSize = 0;
    DWORD                                dwLen = 0;
    LPWSTR                               wzPrefix = NULL;
    LPWSTR                               wzPrefixTmp = NULL;
    WCHAR                                wzDynamicDir[MAX_PATH];
    LPWSTR                               wzAppBaseCanonicalized = NULL;
    List<CHashNode *>                    aHashList[MAX_HASH_TABLE_SIZE];
    LISTNODE                             pos = NULL;
    CHashNode                           *pHashNode = NULL;
    unsigned int                         i;

    wzAppBaseCanonicalized = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!wzAppBaseCanonicalized) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzPrefix = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!wzPrefix) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzPrefixTmp = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!wzPrefix) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_URL_LENGTH;
    hr = UrlCanonicalizeUnescape(wzAppBase, wzAppBaseCanonicalized, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Probe the appbase first

    if (!(dwProbingFlags & ASM_BINDF_BINPATH_PROBE_ONLY)) {
        hr = ApplyHeuristics(g_pwzRetailHeuristics, g_uiNumRetailHeuristics,
                             pwzValues, wzAppBase, wzExt,
                             wzAppBaseCanonicalized, pCodebaseList, aHashList,
                             dwExtendedAppBaseFlags);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    
    if (dwExtendedAppBaseFlags & APPBASE_CHECK_DYNAMIC_DIRECTORY) {
        // Add dynamic directory to the mix.
        
        cbLen = MAX_PATH;
        hr = _pAppCtx->GetDynamicDirectory(wzDynamicDir, &cbLen);
        if (SUCCEEDED(hr)) {
            hr = PathAddBackslashWrap(wzDynamicDir, MAX_PATH);
            if (FAILED(hr)) {
                goto Exit;
            }

            hr = ApplyHeuristics(g_pwzRetailHeuristics, g_uiNumRetailHeuristics,
                                 pwzValues, wzDynamicDir, wzExt, wzAppBaseCanonicalized,
                                 pCodebaseList, aHashList, dwExtendedAppBaseFlags);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        else {
            // Ignore if dynamic dir is not set.
            hr = S_OK;
        }
    }

    if (!wzBinPathList) {
        // No binpaths, we're done.
        goto Exit;
    }

    // Now probe the binpaths
         
    wzBinPathCopy = WSTRDupDynamic(wzBinPathList);
    if (!wzBinPathCopy) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzCurPos = wzBinPathCopy;
    while (wzCurPos) {
        wzCurBinPath = ::GetNextDelimitedString(&wzCurPos, BINPATH_LIST_DELIMITER);

        // "." is not a valid binpath! Ignore this.
        
        if (!FusionCompareString(wzCurBinPath, L".")) {
            continue;
        }

        // Build the prefix (canonicalization of appbase and binpath)

        // UrlCombineW will return the 'relative' URL part if it is an
        // absolute URL. However, the returned URL is in the canonicalized
        // form. To tell if the binpath was actually full-qualified (disallowed
        // for private probing), we canonicalize the binpath first, can
        // compare this with the combined form afterwards (if equal, then it
        // is absolute).

        // The function that calls us guarantees that if the appbase is
        // file://, the file:// will be stripped off (ie. we either have
        // an URL, or raw filepath).

        if (!PathIsURLW(wzAppBase) && !PathIsURLW(wzCurBinPath)) {
            cbLen = MAX_URL_LENGTH;
            hr = UrlCombineUnescape(wzAppBase, wzCurBinPath, wzPrefixTmp, &cbLen, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            // Get the literal file path back, to pass into ApplyHeuristics.

            cbLen = MAX_URL_LENGTH;
            hr = PathCreateFromUrlWrap(wzPrefixTmp, wzPrefix, &cbLen, 0);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        else {
            // This is http:// so no special treatment necessary. Just
            // UrlCombine, and we're golden.

            cbLen = MAX_URL_LENGTH;
            hr = UrlCombineW(wzAppBase, wzCurBinPath, wzPrefix, &cbLen, 0);
            if (FAILED(hr)) {
                goto Exit;
            }
        }

        dwLen = lstrlenW(wzPrefix);
        ASSERT(wzPrefix);

        if (wzPrefix[dwLen - 1] != L'/' && wzPrefix[dwLen - 1] != L'\\') {
            lstrcatW(wzPrefix, L"/");
        }

        // Now we have built a prefix. Apply the heuristics.

        hr = ApplyHeuristics(g_pwzRetailHeuristics, g_uiNumRetailHeuristics,
                             pwzValues, wzPrefix, wzExt, wzAppBaseCanonicalized,
                             pCodebaseList, aHashList, dwExtendedAppBaseFlags);

        if (FAILED(hr)) {
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(wzBinPathCopy);
    
    // Clear dupe check hash table

    for (i = 0; i < MAX_HASH_TABLE_SIZE; i++) {
        if (aHashList[i].GetCount()) {
            pos = aHashList[i].GetHeadPosition();
            ASSERT(pos);

            while (pos) {
                pHashNode = aHashList[i].GetNext(pos);
                SAFEDELETE(pHashNode);
            }
        }
    }

    SAFEDELETEARRAY(wzPrefix);
    SAFEDELETEARRAY(wzPrefixTmp);
    SAFEDELETEARRAY(wzAppBaseCanonicalized);

    return hr;    
}

//
// ApplyHeuristics takes a prefix, and will perform an UrlCombineUnescape
// to build the actual probe URL. This means that the prefix coming in
// needs to be escaped file:// URL (the UrlCombine won't touch the
// already-escaped characters), or a simple file path (the combine will
// escape the characters, which will subsequently get unescaped inside
// UrlCombineUnescape). If you pass in an *unescaped* file:// URL, then
// you will get double-unescaping (the already unescaped URL will pass
// through untouched by the UrlCombine, but will get hit by the explict
// UrlUnescape).
//
// For http:// URLs, as long as everything is always unescaped, we don't
// do explicit unescaping in our wrappers for UrlCombine/UrlCanonicalize
// so we can just pass these through.
//

HRESULT CAsmDownloadMgr::ApplyHeuristics(const WCHAR *pwzHeuristics[],
                                         const unsigned int uiNumHeuristics,
                                         WCHAR *pwzValues[],
                                         LPCWSTR wzPrefix,
                                         LPCWSTR wzExtension,
                                         LPCWSTR wzAppBaseCanonicalized,
                                         ICodebaseList *pCodebaseList,
                                         List<CHashNode *> aHashList[],
                                         DWORD dwExtendedAppBaseFlags)
{
    HRESULT                         hr = S_OK;
    DWORD                           dwSize = 0;
    BOOL                            bUnderAppBase;
    LPWSTR                          pwzBuf=NULL;
    LPWSTR                          pwzNewCodebase=NULL;
    LPWSTR                          pwzCanonicalizedDir=NULL;
    unsigned int                    i;
    
    if (!pwzHeuristics || !uiNumHeuristics || !pwzValues || !pCodebaseList || !wzAppBaseCanonicalized) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pwzBuf = NEW(WCHAR[MAX_URL_LENGTH*3+3]);
    if (!pwzBuf)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pwzNewCodebase = pwzBuf + MAX_URL_LENGTH +1;
    pwzCanonicalizedDir = pwzNewCodebase + MAX_URL_LENGTH +1;

    pwzBuf[0] = L'\0';
    pwzCanonicalizedDir[0] = L'\0';

    for (i = 0; i < uiNumHeuristics; i++) {
        hr = ExpandVariables(pwzHeuristics[i], pwzValues, pwzBuf, MAX_URL_LENGTH);
        if (FAILED(hr)) {
            goto Exit;
        }

        wnsprintfW(pwzNewCodebase, MAX_URL_LENGTH, L"%ws%ws%ws", wzPrefix,
                   pwzBuf, wzExtension);


        dwSize = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(pwzNewCodebase, pwzCanonicalizedDir, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = CheckProbeUrlDupe(aHashList, pwzCanonicalizedDir);
        if (SUCCEEDED(hr)) {
            bUnderAppBase = (IsUnderAppBase(_pAppCtx, wzAppBaseCanonicalized,
                                            _pwzProbingBase, _wzSharedPathHint, pwzCanonicalizedDir,
                                            dwExtendedAppBaseFlags) == S_OK);

            if (bUnderAppBase) {
                hr = pCodebaseList->AddCodebase(pwzCanonicalizedDir, 0);
            }
            else {
                DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_IGNORE_INVALID_PROBE, pwzCanonicalizedDir);
            }
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) {
            hr = S_OK;
            continue;
        }
        else {
            // Fatal error
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(pwzBuf);
    return hr;
}                                       

HRESULT CAsmDownloadMgr::ExtractSubstitutionVars(WCHAR *pwzValues[])
{
    HRESULT                         hr = S_OK;
    DWORD                           cbBuf = 0;
    LPWSTR                          wzBuf = NULL;
    unsigned int                    i;

    if (!pwzValues) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    for (i = 0; i < NUM_VARS; i++) {
        pwzValues[i] = NULL;
    }

    // The following properties are retrieved from the name object itself

    // Assembly Name
    cbBuf = 0;
    hr = _pNameRefPolicy->GetName(&cbBuf, wzBuf);

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        wzBuf = NEW(WCHAR[cbBuf]);
        if (!wzBuf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        hr = _pNameRefPolicy->GetName(&cbBuf, wzBuf);
        if (FAILED(hr)) {
            delete [] wzBuf;
            goto Exit;
        }
        else {
            pwzValues[IDX_VAR_NAME] = wzBuf;
        }
    }
    else {
        pwzValues[IDX_VAR_NAME] = NULL;
    }

    // Culture

    cbBuf = 0;
    hr = _pNameRefPolicy->GetProperty(ASM_NAME_CULTURE, NULL, &cbBuf);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        pwzValues[IDX_VAR_CULTURE] = NEW(WCHAR[cbBuf / sizeof(WCHAR)]);
    
        if (!pwzValues) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = _pNameRefPolicy->GetProperty(ASM_NAME_CULTURE,
                                          pwzValues[IDX_VAR_CULTURE], &cbBuf);
        if (FAILED(hr)) {
            goto Exit;
        }

        // If we have "\0" as Culture (default Culture), this is the same as
        // no Culture.

        if (!lstrlenW(pwzValues[IDX_VAR_CULTURE])) {
            SAFEDELETEARRAY(pwzValues[IDX_VAR_CULTURE]);
        }
    }
    
Exit:
    if (FAILED(hr) && pwzValues) {
        // reset everything to NULL and free memory

        for (i = 0; i < NUM_VARS; i++) {
            if (pwzValues[i]) {
                delete [] pwzValues[i];
            }

            pwzValues[i] = NULL;
        }
    }

    return hr;
}


HRESULT CAsmDownloadMgr::ExpandVariables(LPCWSTR pwzHeuristic, WCHAR *pwzValues[],
                                         LPWSTR wzBuf, int iMaxLen)
{
    HRESULT                         hr = S_OK;
    BOOL                            bCmp;
    LPCWSTR                         pwzCurPos = NULL;
    LPCWSTR                         pwzVarHead = NULL;
    unsigned int                    i;

    if (!pwzHeuristic || !wzBuf || !iMaxLen) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wzBuf[0] = L'\0';

    pwzCurPos = pwzHeuristic;
    pwzVarHead = NULL;

    while (*pwzCurPos) {
        if (*pwzCurPos == L'%') {
            if (pwzVarHead) {
                // This % is the trailing delimiter of a variable

                for (i = 0; i < NUM_VARS; i++) {
                    bCmp = FusionCompareStringNI(pwzVarHead, g_pwzVars[i], lstrlenW(g_pwzVars[i]));
                    if (!bCmp) {
                        if (pwzValues[i]) {
                            StrCatW(wzBuf, pwzValues[i]);
                            break;
                        }
                        else {
                            // No value specified. If next character
                            // is a backslash, don't bother concatenating
                            // it.
                            if (*(pwzCurPos + 1) == L'/') {
                                pwzCurPos++;
                                break;
                            }
                        }
                    }
                }
                        
                // Reset head
                pwzVarHead = NULL;
            }
            else {
                // This is the leading % for a variable

                pwzVarHead = pwzCurPos;
            }
        }
        else if (!pwzVarHead) {
            // Not in the middle of a substituion variable, concatenate
            // this as a literal. NB: StrNCatW's last param includes
            // NULL terminator (ie. the even though we pass "2", it
            // only concatenates 1 character).
       
            StrNCatW(wzBuf, pwzCurPos, 2);
        }

        pwzCurPos++;
    }

    // BUGBUG: No real buffer overrun checking
    ASSERT(lstrlenW(wzBuf) < iMaxLen);

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::PreDownloadCheck(void **ppv)
{
    HRESULT                                  hr = S_FALSE;
    BOOL                                     bWhereRefBind = FALSE;
    BOOL                                     bIsCustom = FALSE;
    BOOL                                     bIsStronglyNamed = FALSE;
    BOOL                                     bIsPartial = FALSE;
    BOOL                                     bApplyPolicy = TRUE;
    DWORD                                    dwCount = 0;
    DWORD                                    dwSize;
    DWORD                                    dwCmpMask;
    LPWSTR                                   pwzAppCfg = NULL;
    LPWSTR                                   pwzHostCfg = NULL;
    LPWSTR                                   wzPolicyCodebase = NULL;
    IAssembly                               *pAsm = NULL;
    IAssemblyName                           *pName = NULL;

    if (!ppv) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppv = NULL;
    
    dwSize = 0;
    hr = _pNameRefSource->GetName(&dwSize, NULL);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        // This is a where-ref bind. Can't lookup in cache, or actasm list.
        bWhereRefBind = TRUE;
    }
    else {
        // Not where-ref. It might be custom, and/or strongly named
        bIsCustom = CCache::IsCustom(_pNameRefSource);        
        bIsStronglyNamed = CCache::IsStronglyNamed(_pNameRefSource);
        bIsPartial = CAssemblyName::IsPartial(_pNameRefSource, &dwCmpMask);
    }

    // Read any setings from the app.cfg file, if we haven't done so already
    
    hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_APP_CFG_LOCAL_FILEPATH, &pwzAppCfg);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (!_bReadCfgSettings) {
        CCriticalSection                         cs(&g_csDownload);

        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }
        
        hr = ReadConfigSettings(_pAppCtx, pwzAppCfg, _pdbglog);
        if (FAILED(hr)) {
            cs.Unlock();
            goto Exit;
        }

        cs.Unlock();
    
        _bReadCfgSettings = TRUE;
    }

#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
    if (bIsPartial) {
        IAssemblyName                    *pNameQualified;

        if (QualifyAssembly(&pNameQualified) == S_OK) {
            SAFERELEASE(_pNameRefSource);
            _pNameRefSource = pNameQualified;

            bIsCustom = CCache::IsCustom(_pNameRefSource);        
            bIsStronglyNamed = CCache::IsStronglyNamed(_pNameRefSource);
            bIsPartial = CAssemblyName::IsPartial(_pNameRefSource, &dwCmpMask);
        }
    }
#endif

    // Only check policy cache if _pNameRefPolicy == NULL. If _pNameRefPolicy
    // is non-NULL, it means we're entering the predownload check a second
    // time (probably from a partial bind, being re-initiated). In this case,
    // ApplyPolicy is going to reset the policy ref.

    if (_pPolicyCache && !_pNameRefPolicy && !bIsPartial && !bIsCustom) {
        hr = _pPolicyCache->LookupPolicy(_pNameRefSource, &_pNameRefPolicy, &_bindHistory);
        if (hr == S_OK) {
            bApplyPolicy = FALSE;
        }
    }

    if (bApplyPolicy) {
        // Apply policy and check if we can succeed the bind immediately.
        // This is only necessary if we didn't hit in the policy cache above.
    
        CCriticalSection                         cs(&g_csDownload);
        BOOL                                     bUnifyFXAssemblies = TRUE;
        DWORD                                    cbValue;

        hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_HOST_CONFIG_FILE, &pwzHostCfg);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        SAFERELEASE(_pNameRefPolicy);

        cbValue = 0;
        hr = _pAppCtx->Get(ACTAG_DISABLE_FX_ASM_UNIFICATION, NULL, &cbValue, 0);
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            bUnifyFXAssemblies = FALSE;
        }
        else if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
            cs.Unlock();
            goto Exit;
        }
        
        hr = ApplyPolicy(pwzHostCfg, pwzAppCfg, _pNameRefSource, &_pNameRefPolicy, &wzPolicyCodebase,
                         _pAppCtx, &_bindHistory, (_llFlags & ASM_BINDF_DISALLOW_APPLYPUBLISHERPOLICY) != 0,
                         (_llFlags & ASM_BINDF_DISALLOW_APPBINDINGREDIRECTS) != 0,
                         bUnifyFXAssemblies, _pdbglog);
        if (FAILED(hr)) {
            cs.Unlock();
            goto Exit;
        }

        cs.Unlock();
    }

    // If we have a fully-specified ref, now _pNameRefPolicy points to
    // exactly what we are looking for. Check the activated assemblies list.

    if (!bWhereRefBind && !bIsPartial) {
        hr = _pLoadContext->CheckActivated(_pNameRefPolicy, &pAsm);
        if (hr == S_OK) {
            WCHAR                              wzManifestPath[MAX_PATH];
            DWORD                              dwPathSize = MAX_PATH;

            *ppv = pAsm;

            if (SUCCEEDED(pAsm->GetManifestModulePath(wzManifestPath, &dwPathSize))) {
                DEBUGOUT1(_pdbglog, 0, ID_FUSLOG_LOADCTX_HIT, wzManifestPath);
            }

            RecordBindHistory();

            goto Exit;
        }
    }

    // Missed in activated assemblies list. Try looking up in the cache.
        
    if ((!bWhereRefBind && !bIsPartial) && (bIsStronglyNamed || bIsCustom)) {
        // Create the assembly

        hr = CreateAssemblyFromCacheLookup(_pAppCtx, _pNameRefPolicy, &pAsm, _pdbglog);
        if (hr == S_OK) {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_CACHE_LOOKUP_SUCCESS);
            
            if (_pwzProbingBase) {
                // We must be a child of a LoadFrom, so let's set the probing base
                CAssembly   *pCAsm = dynamic_cast<CAssembly *>(pAsm);
                ASSERT(pCAsm);
        
                pCAsm->SetProbingBase(_pwzProbingBase);
            }

            SAFERELEASE(_pAsm);
            _pAsm = pAsm;

            SetAsmLocation(_pAsm, ASMLOC_GAC);
            hr = RecordInfo();
            if (FAILED(hr)) {
                goto Exit;
            }

            hr = S_OK;
            *ppv = _pAsm;
            _pAsm->AddRef();

            goto Exit;
        }

        if (bIsCustom) {
            // If we're here, it's because we couldn't find the asm in
            // the cache. Custom assemblies *must* be in the cache, or we
            // will fail the bind (can't probe for custom asms);

            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_PREJIT_NOT_FOUND);
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Exit;
        }
    }
    
    // Couldn't find asm in activated asm list, or cache. Must probe.

    hr = ConstructCodebaseList(wzPolicyCodebase);
    if (FAILED(hr)) {
        DEBUGOUT(_pdbglog, 1, ID_FUSLOG_CODEBASE_CONSTRUCTION_FAILURE);
        goto Exit;
    }
    else {
        // Make sure we have at least one codebase
        hr = GetCount(&dwCount);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (!dwCount) {
            // No codebases in codebase list (either client provided empty
            // codebase list, or we couldn't generate any).
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_CODEBASE_UNAVAILABLE);
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Exit;
        }
    }

    // If strongly-named, then look in download cache.

    if (bIsStronglyNamed && !bIsPartial && !IsHosted()) {
        hr = LookupDownloadCacheAsm(&pAsm);
        if (hr == S_OK) {
            WCHAR                    wzPath[MAX_PATH];
            DWORD                    dw = MAX_PATH;
            DWORD                    dwVerifyFlags = SN_INFLAG_USER_ACCESS;
            BOOL                     bWasVerified = FALSE;

            if (_pwzProbingBase) {
                // We must be a child of a LoadFrom, so let's set the probing base
                CAssembly   *pCAsm = dynamic_cast<CAssembly *>(pAsm);
                ASSERT(pCAsm);
        
                pCAsm->SetProbingBase(_pwzProbingBase);
            }

            wzPath[0] = L'\0';

            hr = pAsm->GetManifestModulePath(wzPath, &dw);
            if (FAILED(hr)) {
                goto Exit;
            }
            
            // Lookup in download cache successful. Verify signature.

            if (!VerifySignature(wzPath, &bWasVerified, dwVerifyFlags)) {
                hr = FUSION_E_SIGNATURE_CHECK_FAILED;
                goto Exit;
            }
    
            // Success!

            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_DOWNLOAD_CACHE_LOOKUP_SUCCESS);
            
            SAFERELEASE(_pAsm);
            _pAsm = pAsm;
    
            SetAsmLocation(pAsm, ASMLOC_DOWNLOAD_CACHE);
            hr = RecordInfo();
            if (FAILED(hr)) {
                goto Exit;
            }

            hr = S_OK;
            *ppv = _pAsm;
            _pAsm->AddRef();
    
            goto Exit;
        }
    }
  
    // Indicate ready to being probing.
    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(pwzAppCfg);
    SAFEDELETEARRAY(pwzHostCfg);
    SAFEDELETEARRAY(wzPolicyCodebase);

    return hr;
}

HRESULT CAsmDownloadMgr::GetDownloadIdentifier(DWORD *pdwDownloadType,
                                               LPWSTR *ppwzID)
{
    HRESULT                                      hr = S_OK;
    LPWSTR                                       pwzDisplayName = NULL;
    DWORD                                        dwSize;

    ASSERT(pdwDownloadType && ppwzID);

    dwSize = 0;
    hr = _pNameRefPolicy->GetName(&dwSize, NULL);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        // Where-ref bind.
        // Identifier is the URL we are binding to.
        *pdwDownloadType = DLTYPE_WHERE_REF;

        ASSERT(_wzBTOCodebase);

        *ppwzID = WSTRDupDynamic(_wzBTOCodebase);
        if (!*ppwzID) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = S_OK;
    }
    else {
        // Not where-ref (could be partial, though).
        // Identifier is the display-name for the name being bound-to.

        *pdwDownloadType = DLTYPE_QUALIFIED_REF;

        dwSize = 0;
        _pNameRefPolicy->GetDisplayName(NULL, &dwSize, 0);
        if (!dwSize) {
            hr = E_UNEXPECTED;
            goto Exit;
        }
    
        pwzDisplayName = NEW(WCHAR[dwSize]);
        if (!pwzDisplayName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        hr = _pNameRefPolicy->GetDisplayName(pwzDisplayName, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }

        *ppwzID = pwzDisplayName;
        hr = S_OK;
    }

Exit:
    if (FAILED(hr)) {
        SAFEDELETEARRAY(pwzDisplayName);
    }

    return hr;
}                                               

HRESULT CAsmDownloadMgr::IsDuplicate(IDownloadMgr *pIDLMgr)
{
    HRESULT                                    hr = S_FALSE;
    IApplicationContext                       *pAppCtxCur = NULL;
    CAsmDownloadMgr                           *pCDLMgr = NULL;
    LPWSTR                                     pwzIDSelf = NULL;
    LPWSTR                                     pwzIDCur = NULL;
    DWORD                                      dwTypeSelf;
    DWORD                                      dwTypeCur;

    if (!pIDLMgr) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // IsDuplicate is called from CAsmDownload::CheckDuplicate(), which is
    // under the g_csDownload crit sect. Thus, there is synchronization
    // between this code and the PreDownloadCheck code, where _pNameRefPolicy
    // may be released, and re-created.

    ASSERT(_pNameRefPolicy);
    
    pCDLMgr = dynamic_cast<CAsmDownloadMgr *>(pIDLMgr);
    if (!pCDLMgr) {
        hr = E_FAIL;
        goto Exit;
    }

    // Check if app ctx's are equal

    hr = pCDLMgr->GetAppCtx(&pAppCtxCur);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (_pAppCtx != pAppCtxCur) {
        hr = S_FALSE;
        goto Exit;
    }

    // Check if identifiers are equal (same display name, or same URL)

    hr = GetDownloadIdentifier(&dwTypeSelf, &pwzIDSelf);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pCDLMgr->GetDownloadIdentifier(&dwTypeCur, &pwzIDCur);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Comapre types and identifiers

    if (dwTypeSelf != dwTypeCur) {
        hr = S_FALSE;
        goto Exit;
    } 

    hr = FusionCompareString(pwzIDCur, pwzIDSelf) ? (S_FALSE) : (S_OK);
    
Exit:
    SAFERELEASE(pAppCtxCur);

    SAFEDELETEARRAY(pwzIDCur);
    SAFEDELETEARRAY(pwzIDSelf);
    
    return hr;
}

#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
HRESULT CAsmDownloadMgr::QualifyAssembly(IAssemblyName **ppNameQualified)
{
    HRESULT                                  hr = S_FALSE;;
    LPWSTR                                   wzDisplayName=NULL;
    DWORD                                    dwSize;
    CNodeFactory                            *pNodeFact = NULL;
    
    dwSize = sizeof(pNodeFact);
    hr = _pAppCtx->Get(ACTAG_APP_CFG_INFO, &pNodeFact, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (FAILED(hr)) {
        goto Exit;
    }

    wzDisplayName = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzDisplayName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_URL_LENGTH;
    hr = _pNameRefSource->GetDisplayName(wzDisplayName, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pNodeFact->QualifyAssembly(wzDisplayName, ppNameQualified, _pdbglog);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFERELEASE(pNodeFact);
    SAFEDELETEARRAY(wzDisplayName);
    return hr;
}
#endif

HRESULT CAsmDownloadMgr::GetAppCfgCodebaseHint(LPCWSTR pwzAppBase, LPWSTR *ppwzCodebaseHint)
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   wzName = NULL;
    LPWSTR                                   wzPublicKeyToken = NULL;
    LPWSTR                                   wzLanguage = NULL;
    WCHAR                                    wzVersion[MAX_VERSION_DISPLAY_SIZE + 1];
    DWORD                                    dwVerHigh = 0;
    DWORD                                    dwVerLow = 0;
    DWORD                                    dwSize;
    CAssemblyName                           *pCNameRefPolicy = NULL;
    CNodeFactory                            *pNodeFact = NULL;

    if (!ppwzCodebaseHint) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pCNameRefPolicy = dynamic_cast<CAssemblyName *>(_pNameRefPolicy);
    ASSERT(pCNameRefPolicy);

    dwSize = sizeof(pNodeFact);
    hr = _pAppCtx->Get(ACTAG_APP_CFG_INFO, &pNodeFact, &dwSize, APP_CTX_FLAGS_INTERFACE);
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        hr = S_FALSE;
        goto Exit;
    }
    if (FAILED(hr)) {
        goto Exit;
    }
    
    dwSize = 0;
    _pNameRefPolicy->GetName(&dwSize, NULL);
    if (!dwSize) {
        // Where-ref bind. No hint possible
        hr = S_FALSE;
        goto Exit;
    }

    wzName = NEW(WCHAR[dwSize]);
    if (!wzName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = _pNameRefPolicy->GetName(&dwSize, wzName);
    if (FAILED(hr)) {
        goto Exit;
    }

    pCNameRefPolicy->GetPublicKeyToken(&dwSize, 0, TRUE);
    if (dwSize) {
        wzPublicKeyToken = NEW(WCHAR[dwSize]);
        if (!wzPublicKeyToken) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = pCNameRefPolicy->GetPublicKeyToken(&dwSize, (LPBYTE)wzPublicKeyToken, TRUE);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    hr = _pNameRefPolicy->GetVersion(&dwVerHigh, &dwVerLow);
    if (FAILED(hr)) {
        goto Exit;
    }

    wnsprintfW(wzVersion, MAX_VERSION_DISPLAY_SIZE + 1, L"%d.%d.%d.%d",
               HIWORD(dwVerHigh), LOWORD(dwVerHigh), HIWORD(dwVerLow),
               LOWORD(dwVerLow));


    dwSize = 0;
    _pNameRefPolicy->GetProperty(ASM_NAME_CULTURE, NULL, &dwSize);

    if (dwSize) {
        wzLanguage = NEW(WCHAR[dwSize / sizeof(WCHAR)]);
        if (!wzLanguage) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        hr = _pNameRefPolicy->GetProperty(ASM_NAME_CULTURE, wzLanguage, &dwSize);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    hr = pNodeFact->GetCodebaseHint(wzName, wzVersion, wzPublicKeyToken,
                                    wzLanguage, pwzAppBase, ppwzCodebaseHint);
    if (FAILED(hr)) {
        goto Exit;
    }                                    

Exit:
    SAFEDELETEARRAY(wzName);
    SAFEDELETEARRAY(wzPublicKeyToken);
    SAFEDELETEARRAY(wzLanguage);

    SAFERELEASE(pNodeFact);

    return hr;
}

HRESULT CAsmDownloadMgr::SetupMSI(LPCWSTR wzFilePath)
{
    HRESULT                                     hr = S_OK;
    UINT                                        lResult;

    hr = CheckMSIInstallAvailable(NULL, NULL);
    if (hr != S_OK) {
        goto Exit;
    }

    ASSERT(g_pfnMsiInstallProductW);

    lResult = (*g_pfnMsiInstallProductW)(wzFilePath, NULL);
    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    // Assume MSI must have installed into the GAC

    // BUGBUG: Should it look only in the system download cache
    // instead of the per app asm download cache?
    // if so, pass NULL instead of _pAppCtx as the 1st arg
    hr = CreateAssemblyFromCacheLookup(_pAppCtx, _pNameRefPolicy, &_pAsm, _pdbglog);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::SetupCAB(LPCWSTR wzFilePath, LPCWSTR wzSourceUrl,
                                  BOOL bWhereRefBind, BOOL *pbBindRecorded)
{
    HRESULT                                     hr = S_OK;
    DWORD                                       dwRet = 0;
    DWORD                                       dwSize = 0;
    DWORD                                       dwCount = 0;
    DWORD                                       dwIdx = 0;
    DWORD                                       dwFlags;
    LPWSTR                                      wzAsmName = NULL;
    LPWSTR                                      wzFileName = NULL;
    LPWSTR                                      wzExt = NULL;
    LPWSTR                                      wzURL=NULL;
    WCHAR                                       wzPath[MAX_PATH];
    BOOL                                        bFoundAsm = FALSE;
    FILETIME                                    ftLastMod;
    CCodebaseList                              *pCodebaseList = NULL;
    WCHAR                                       wzUniquePath[MAX_PATH];
    LPWSTR                                      wzUniquePathUrl=NULL;
    WCHAR                                       wzTempPath[MAX_PATH];
    char                                       *szFilePath = NULL;

    wzUniquePath[0] = L'\0';

    if (!wzFilePath || !wzSourceUrl) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_SETUP_CAB);

    // Build a unique temporary directory
    
    dwRet = GetTempPathW(MAX_PATH, wzTempPath);
    if (!dwRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (wzTempPath[dwRet - 1] != '\\') {
        lstrcatW(wzTempPath, L"\\");
    }

    hr = MakeUniqueTempDirectory(wzTempPath, wzUniquePath, MAX_PATH);
    if (FAILED(hr)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_TEMP_DIR_CREATE_FAILURE, hr);
        goto Exit;
    }

    wzURL = NEW(WCHAR[MAX_URL_LENGTH*2+2]);
    if (!wzURL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wzUniquePathUrl = wzURL + MAX_URL_LENGTH + 1;

    dwSize = MAX_URL_LENGTH;
    hr = UrlCanonicalizeUnescape(wzUniquePath, wzUniquePathUrl, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Extract the CAB

    hr = ::Unicode2Ansi(wzFilePath, &szFilePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = Extract(szFilePath, wzUniquePath);
    if (FAILED(hr)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_CAB_EXTRACT_FAILURE, hr);
        goto Exit;
    }

    // Build up the codebase list for probing in the temp dir

    pCodebaseList = NEW(CCodebaseList);
    if (!pCodebaseList) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = 0;
    _pNameRefPolicy->GetName(&dwSize, NULL);

    if (dwSize) {
        // Not a where-ref bind. Name of the assembly is the name of the
        // file we are looking for.

        wzAsmName = NEW(WCHAR[dwSize]);
        if (!wzAsmName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = _pNameRefPolicy->GetName(&dwSize, wzAsmName);
        if (FAILED(hr)) {
            goto Exit;
        }

        ASSERT(wzAsmName);

        hr = SetupDefaultProbeList(wzUniquePathUrl, NULL, pCodebaseList, TRUE);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        // Where-ref bind. Look for manifest file with the same name
        // as the CAB file.

        wzFileName = PathFindFileName(wzSourceUrl);
        wzAsmName = WSTRDupDynamic(wzFileName);

        ASSERT(wzAsmName);

        // Replace ".CAB" with ".DLL"

        wzExt = PathFindExtension(wzAsmName);
        ASSERT(wzExt); // We'd better have found .CAB!

        // Remove the extension
        *wzExt = L'\0'; 
        
        hr = SetupDefaultProbeList(wzUniquePathUrl, wzAsmName, pCodebaseList, TRUE);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // Probe for the assembly in the temp dir

    hr = pCodebaseList->GetCount(&dwCount);
    if (FAILED(hr)) {
        goto Exit;
    }

    for (dwIdx = 0; dwIdx < dwCount; dwIdx++) {
        dwSize = MAX_URL_LENGTH;
        hr = pCodebaseList->GetCodebase(dwIdx, &dwFlags, wzURL, &dwSize);

        if (hr == S_OK && UrlIsW(wzURL, URLIS_FILEURL)) {
            dwSize = MAX_PATH;
            hr = PathCreateFromUrlWrap(wzURL, wzPath, &dwSize, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            // Assert that SetupDefaultProbeList didn't give us any
            // URLs outside the temp dir

            ASSERT(!FusionCompareStringN(wzPath, wzUniquePath, lstrlenW(wzUniquePath)));

            if (GetFileAttributes(wzPath) != -1) {
                // Found the file we were looking for
                DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_CAB_ASM_FOUND, wzPath);

                hr = GetFileLastModified(wzPath, &ftLastMod);
                if (FAILED(hr)) {
                    break;
                }
                
                hr = DoSetupPushToCache(wzPath, wzSourceUrl, &ftLastMod,
                                        bWhereRefBind, TRUE, FALSE, pbBindRecorded);

                if (SUCCEEDED(hr)) {
                    DEBUGOUT(_pdbglog, 1, ID_FUSLOG_CAB_EXTRACT_SUCCESS);
                    bFoundAsm = TRUE;
                }
                else {
                    DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_DOWNLOAD_CACHE_CREATE_FAILURE, hr);
                }

                break;
            }
            else {
                DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_CAB_ASM_NOT_FOUND_EXTRACTED, wzPath);
            }
        }
    }

    if (!bFoundAsm) {
        DEBUGOUT(_pdbglog, 1, ID_FUSLOG_CAB_ASM_NOT_FOUND);
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

Exit:
    // Remove the temp directory + files
    if (lstrlenW(wzUniquePath)) {
        DWORD dwLen = lstrlenW(wzUniquePath);

        ASSERT(dwLen && dwLen < MAX_PATH);

        // RemoveDirectoryAndChildren doesn't like trailing slashes

        PathRemoveBackslash(wzUniquePath);

        if (FAILED(RemoveDirectoryAndChildren(wzUniquePath))) {
            DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_TEMP_DIR_REMOVE_FAILURE, wzUniquePath);
        }
    }

    SAFEDELETEARRAY(szFilePath);
    SAFEDELETEARRAY(wzAsmName);

    SAFERELEASE(pCodebaseList);

    SAFEDELETEARRAY(wzURL);

    return hr;
}

HRESULT CAsmDownloadMgr::PrepBinPaths(LPWSTR *ppwzUserBinPathList)
{
    HRESULT                                  hr = S_OK;
    LPWSTR                                   wzPrivate = NULL;

    if (!ppwzUserBinPathList) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = PrepPrivateBinPath(&wzPrivate);
    if (FAILED(hr)) {
        goto Exit;
    }

    // BUGBUG: Should we append _wzSharedPathHint first? If the runtime is
    // *always* passing the _wzSharedPathHint, then probing this first is bad,
    // because it will introduce unnecessary misses for the majority of cases
    // (shared path hint is only useful for web scenario)

    hr = ConcatenateBinPaths(wzPrivate, _wzSharedPathHint, ppwzUserBinPathList);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(wzPrivate);

    return hr;
}

HRESULT CAsmDownloadMgr::PrepPrivateBinPath(LPWSTR *ppwzPrivateBinPath)
{
    HRESULT                                     hr = S_OK;
    LPWSTR                                      wzPrivatePath = NULL;
    LPWSTR                                      wzCfgPrivatePath = NULL;

    ASSERT(ppwzPrivateBinPath);

    hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_APP_PRIVATE_BINPATH, &wzPrivatePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_APP_CFG_PRIVATE_BINPATH, &wzCfgPrivatePath);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ConcatenateBinPaths(wzPrivatePath, wzCfgPrivatePath, ppwzPrivateBinPath);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Private binpath is always probed (considered path of the appbase).

Exit:
    SAFEDELETEARRAY(wzPrivatePath);
    SAFEDELETEARRAY(wzCfgPrivatePath);

    return hr;
}

HRESULT CAsmDownloadMgr::ConcatenateBinPaths(LPCWSTR pwzPath1, LPCWSTR pwzPath2,
                                             LPWSTR *ppwzOut)
{
    HRESULT                                 hr = S_OK;
    DWORD                                   dwLen = 0;

    if (!ppwzOut) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (pwzPath1 && pwzPath2) {
        // +1 for delimiter, +1 for NULL;
        dwLen = lstrlenW(pwzPath1) + lstrlenW(pwzPath2) + 2;

        *ppwzOut = NEW(WCHAR[dwLen]);
        if (!*ppwzOut) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        wnsprintfW(*ppwzOut, dwLen, L"%ws%wc%ws", pwzPath1, BINPATH_LIST_DELIMITER,
                   pwzPath2);
    }
    else if (pwzPath1) {
        *ppwzOut = WSTRDupDynamic(pwzPath1);
    }
    else if (pwzPath2) {
        *ppwzOut = WSTRDupDynamic(pwzPath2);
    }
    else {
        *ppwzOut = NULL;
    }

Exit:
    return hr;
}                                          

HRESULT CAsmDownloadMgr::ShadowCopyDirCheck(LPCWSTR wzSourceURL)
{
    HRESULT                                hr = S_OK;
    WCHAR                                  wzCurDirBuf[MAX_PATH];
    WCHAR                                  wzCurURLBuf[MAX_URL_LENGTH];
    WCHAR                                  wzCurDirClean[MAX_PATH];
    WCHAR                                  wzFilePath[MAX_PATH];
    LPWSTR                                 pwzDirs = NULL;
    LPWSTR                                 pwzDirsCopy = NULL;
    LPWSTR                                 pwzCurDir = NULL;
    DWORD                                  cbLen = 0;
    DWORD                                  dwSize = 0;
    BOOL                                   bFound = FALSE;

    if (!wzSourceURL || !UrlIsW(wzSourceURL, URLIS_FILEURL)) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSize = MAX_PATH;
    hr = PathCreateFromUrlWrap(wzSourceURL, wzFilePath, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_APP_SHADOW_COPY_DIRS, &pwzDirs);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (hr == S_FALSE) {
        // No list of shadow copy dirs specified. Assume all dirs are ok.
        hr = S_OK;
        goto Exit;
    }

    ASSERT(pwzDirs);
    pwzDirsCopy = pwzDirs;

    while (pwzDirs) {
        pwzCurDir = ::GetNextDelimitedString(&pwzDirs, SHADOW_COPY_DIR_DELIMITER);

        if (lstrlenW(pwzCurDir) >= MAX_PATH || !lstrlenW(pwzCurDir)) {
            // Path too long. Disallow shadow copying for this path.
            continue;
        }

        lstrcpyW(wzCurDirBuf, pwzCurDir);
        hr = PathAddBackslashWrap(wzCurDirBuf, MAX_PATH);
        if (FAILED(hr)) {
            continue;
        }

        // Canonicalize and uncanonicalze it to clean up the path

        dwSize = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(wzCurDirBuf, wzCurURLBuf, &dwSize, 0);
        if (FAILED(hr)) {
            continue;
        }

        dwSize = MAX_PATH;
        hr = PathCreateFromUrlWrap(wzCurURLBuf, wzCurDirClean, &dwSize, 0);
        if (FAILED(hr)) {
            continue;
        }

        if (SUCCEEDED(hr) && !FusionCompareStringNI(wzCurDirClean, wzFilePath, lstrlenW(wzCurDirClean))) {
            bFound = TRUE;
            break;
        }
    }

    hr = (bFound) ? (S_OK) : (S_FALSE);

Exit:
   SAFEDELETEARRAY(pwzDirsCopy);
   
   return hr;
}

HRESULT CAsmDownloadMgr::CheckProbeUrlDupe(List<CHashNode *> paHashList[],
                                           LPCWSTR pwzSource) const
{
    HRESULT                                    hr = S_OK;
    DWORD                                      dwHash;
    DWORD                                      dwCount;
    LISTNODE                                   pos = NULL;
    CHashNode                                 *pHashNode = NULL;
    CHashNode                                 *pHashNodeCur = NULL;

    if (!pwzSource || !paHashList) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwHash = HashString(pwzSource, MAX_HASH_TABLE_SIZE, FALSE);
    dwCount = paHashList[dwHash].GetCount();

    if (!dwCount) {
        // Empty hash cell. This one is definitely unique.

        hr = CHashNode::Create(pwzSource, &pHashNode);
        if (FAILED(hr)) {
            goto Exit;
        }

        paHashList[dwHash].AddTail(pHashNode);
    }
    else {
        // Encountered hash table collision.

        // Check if we hit a duplicate, or if this was just a cell collision.

        pos = paHashList[dwHash].GetHeadPosition();
        ASSERT(pos);

        while (pos) {
            pHashNodeCur = paHashList[dwHash].GetNext(pos);
            ASSERT(pHashNodeCur);

            if (pHashNodeCur->IsDuplicate(pwzSource)) {
                // Duplicate found!
                
                hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                goto Exit;
            }
        }

        // If we get here, there was no duplicate (and we just had a
        // cell collision). Insert the new node.

        hr = CHashNode::Create(pwzSource, &pHashNode);
        if (FAILED(hr)) {
            goto Exit;
        }

        paHashList[dwHash].AddTail(pHashNode);
    }

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::LogResult()
{
    HRESULT                            hr = S_OK;
    DWORD                              dwSize = MAX_PATH;
    WCHAR                              wzBuf[MAX_PATH];

    wzBuf[0] = L'\0';

#ifdef FUSION_PARTIAL_BIND_DEBUG
    if (_bGACPartial) {
        return E_FAIL;
    }
#endif

    if (g_dwLogResourceBinds) {
        goto Exit;
    }

    if (_pNameRefPolicy) {
        _pNameRefPolicy->GetProperty(ASM_NAME_CULTURE, wzBuf, &dwSize);

        if ((dwSize > MAX_PATH) || (lstrlenW(wzBuf) && FusionCompareStringI(wzBuf, CFG_CULTURE_NEUTRAL))) {
            // A culture must be set (that is not "neutral").
            hr = S_FALSE;
        }
    }

Exit:
    return hr;
}
        
HRESULT CAsmDownloadMgr::CreateAssembly(LPCWSTR szPath, LPCWSTR pszURL,
                                        FILETIME *pftLastModTime,
                                        BOOL bRunFromSource,
                                        BOOL bWhereRef,
                                        BOOL bPrivateAsmVerify,
                                        BOOL bCopyModules,
                                        BOOL *pbBindRecorded,
                                        IAssembly **ppAsmOut)
{
    HRESULT                              hr = S_OK;
    CAssemblyCacheItem                  *pAsmItem = NULL;
    IAssemblyManifestImport             *pManImport = NULL;
    IAssemblyName                       *pNameDef = NULL;
    CAssemblyName                       *pCNameRefPolicy = NULL;    
    DWORD                                dwCmpMask = 0;
    DWORD                                dwSize = 0;
    BOOL                                 fIsPartial = FALSE;
    LPWSTR                               pwzDispName = NULL;
    HANDLE                               hFile = INVALID_HANDLE_VALUE;
    DWORD                                dwIdx = 0;
    DWORD                                dwLen;
    WCHAR                                wzDir[MAX_PATH+1];
    WCHAR                                wzModPath[MAX_PATH+1];
    WCHAR                                wzModName[MAX_PATH+1];
    LPWSTR                               pwzTmp = NULL;
    IAssemblyModuleImport               *pModImport = NULL;
    BOOL                                 bExists;
    
    if (!szPath || !pszURL || !ppAsmOut || !pftLastModTime || !pbBindRecorded) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pbBindRecorded = FALSE;

    // Get the manifest import and name def interfaces. 
    // This is done for all cases (where, simple and strong).
    hr = CreateAssemblyManifestImport(szPath, &pManImport);
    if (FAILED(hr)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_MANIFEST_EXTRACT_FAILURE, hr);
        goto Exit;
    }

    // Get read-only name def from manifest.
    hr = pManImport->GetAssemblyNameDef(&pNameDef);
    if (FAILED(hr)) {
        DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_NAME_DEF_EXTRACT_FAILURE, hr);
        goto Exit;
    }

    // Check to make sure that all private assemblies were located under
    // the appdir (or else fail).

    if (bPrivateAsmVerify && !bWhereRef) {
        hr = CheckValidAsmLocation(pNameDef, pszURL, _pAppCtx, _pwzProbingBase, _wzSharedPathHint, _pdbglog);
        if (FAILED(hr)) {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_INVALID_PRIVATE_ASM_LOCATION);
            goto Exit;
        }
    }
    
    // Determine if def matches ref using default
    // matching (no ver check for simple names, 
    // ver excluding rev/build for fully specified
    // strong names, also excluding any non-specified
    // values in the ref if partial.
    
    // Get the ref partial comparison mask if any.

    fIsPartial = CAssemblyName::IsPartial(_pNameRefPolicy, &dwCmpMask);
    
    pCNameRefPolicy = dynamic_cast<CAssemblyName*>(_pNameRefPolicy);
    ASSERT(pCNameRefPolicy);

    hr = pCNameRefPolicy->IsEqualLogging(pNameDef, ASM_CMPF_DEFAULT, _pdbglog);
    if (hr != S_OK) {
        // Ref-def mismatch

        dwSize = 0;
        hr = pNameDef->GetDisplayName(NULL, &dwSize, 0);
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            pwzDispName = NEW(WCHAR[dwSize]);
            if (!pwzDispName) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        
            hr = pNameDef->GetDisplayName(pwzDispName, &dwSize, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_REF_DEF_MISMATCH);
        }

        hr = FUSION_E_REF_DEF_MISMATCH;

        goto Exit;
    }

    if (fIsPartial && !bWhereRef) {
        // If the original ref was partial, then we need to apply policy now
        // to the def that we found. This may involve a reprobe(!) for the
        // actual eventual assembly.
        //
        // BUGBUG: If we want, we should also be able to apply policy to
        // where ref binds here, simply by altering the "if" check.

        SAFERELEASE(_pNameRefSource);
        SAFERELEASE(_pCodebaseList);

        hr = pNameDef->Clone(&_pNameRefSource);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        DEBUGOUT(_pdbglog, 1, ID_FUSLOG_PARTIAL_ASM_IN_APP_DIR);

        hr = PreDownloadCheck((void **)ppAsmOut);
        if (hr == S_OK) {
            // We applied policy and were able to locate the post-policy
            // assembly somewhere (cache or actasm list). Return this
            // assembly to the caller.
            //
            // Also, we must tell the caller that PreDownloadCheck already
            // added to the activated asm list, etc.

            ASSERT(ppAsmOut);

            *pbBindRecorded = TRUE;

            goto Exit;
        }
        else if (hr == S_FALSE) {
            if (_pNameRefSource->IsEqual(_pNameRefPolicy, ASM_CMPF_DEFAULT) == S_FALSE) {
                DEBUGOUT(_pdbglog, 1, ID_FUSLOG_REPROBE_REQUIRED);
                goto Exit;
            }
        }
        else if (FAILED(hr)) {
            goto Exit;
        }
    }

    if (bRunFromSource) {
        hr = CreateAssemblyFromManifestImport(pManImport, pszURL, pftLastModTime, ppAsmOut);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else {
        hr = CAssemblyCacheItem::Create(_pAppCtx, NULL, (LPWSTR)pszURL, pftLastModTime,
                                        ASM_CACHE_DOWNLOAD,
                                        pManImport, NULL, (IAssemblyCacheItem**)&pAsmItem);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = CopyAssemblyFile(pAsmItem, szPath, STREAM_FORMAT_COMPLIB_MANIFEST);
        if (FAILED(hr)) {
            goto Exit;
        }
        
        if (bCopyModules) {
            if (lstrlen(szPath) >= MAX_PATH) {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto Exit;
            }

            lstrcpyW(wzDir, szPath);
            pwzTmp = PathFindFileName(wzDir);
            *pwzTmp = L'\0';

            // copy modules
            dwIdx = 0;
            while (SUCCEEDED(hr = pManImport->GetNextAssemblyModule(dwIdx++, &pModImport))) {
                dwLen = MAX_PATH;
                hr = pModImport->GetModuleName(wzModName, &dwLen);

                if (FAILED(hr))
                {
                    goto Exit;
                }

                wnsprintfW(wzModPath, MAX_PATH, L"%s%s", wzDir, wzModName);
                hr = CheckFileExistence(wzModPath, &bExists);
                if (FAILED(hr)) {
                    goto Exit;
                }
                else if (!bExists) {
                    // if module not found, it is ok in this case.
                    // just continue
                    SAFERELEASE(pModImport);
                    continue;
                }

                // Copy to cache.
                if (FAILED(hr = CopyAssemblyFile (pAsmItem, wzModPath, 0)))
                    goto Exit;

                SAFERELEASE(pModImport);
            }
        }
               
        // Commit the assembly. This inserts into the transport cache.

        hr = pAsmItem->Commit(0, NULL);
        if (FAILED(hr)) {

            // Dups are allowed, the asm item's trans cache entry
            // will be the existing entry if found.
            if (hr != DB_E_DUPLICATE) {
                goto Exit;
            }

            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_DUPLICATE_ASM_COMMIT);

            // Check to see if the manifest file has been deleted. If so,
            // then copy these bits to the cache to restore cache integrity.

            if(!pAsmItem->IsManifestFileLocked()) {
                hr = RecoverDeletedBits(pAsmItem, (LPWSTR)szPath, _pdbglog);
            }
            else hr = S_OK;
        }

        LPWSTR pszManifestFilePath = pAsmItem->GetManifestPath();

        hFile = pAsmItem->GetFileHandle();
        if(hFile==INVALID_HANDLE_VALUE)
        {
            if(FAILED(hr = GetManifestFileLock(pszManifestFilePath, &hFile)))
                goto Exit;
        }

        /*
        // Create and hand out the IAssembly object - this function locks the
        // associated cache entry.
        hr = CreateAssemblyFromTransCacheEntry(pTransCache, NULL, ppAsmOut);
        if (FAILED(hr)) {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_ASSEMBLY_CREATION_FAILURE);
            goto Exit;
        }
        */
        hr = CreateAssemblyFromManifestFile(pszManifestFilePath, pszURL, pftLastModTime, ppAsmOut);
        if (FAILED(hr)) {
            goto Exit;
        }

    }

    if((*ppAsmOut) && (pAsmItem))
    {
        CAssembly   *pCAsm = dynamic_cast<CAssembly *>(*ppAsmOut);
        pCAsm->SetFileHandle(hFile);
    }

Exit:
    SAFERELEASE(pAsmItem);
    SAFERELEASE(pManImport);
    SAFERELEASE(pNameDef);
    SAFERELEASE(pModImport);

    SAFEDELETEARRAY(pwzDispName);

    return hr;
}

    
HRESULT RecoverDeletedBits(CAssemblyCacheItem *pAsmItem, LPWSTR szPath,
                           CDebugLog *pdbglog)
{
    HRESULT                          hr = S_OK;
    LPWSTR                           pszManifestPath=NULL;


    ASSERT(pAsmItem);

    pszManifestPath = pAsmItem->GetManifestPath();

    if (GetFileAttributes(pszManifestPath) != -1) {
        goto Exit;
    }

    CreateFilePathHierarchy(pszManifestPath);

    if (GetFileAttributes(pszManifestPath) == -1) {
        CopyFile(szPath, pszManifestPath, TRUE);
    }

Exit:

    return hr;
}

HRESULT CAsmDownloadMgr::LookupPartialFromGlobalCache(LPASSEMBLY *ppAsmOut,
                                                      DWORD dwCmpMask)
{    
    HRESULT                                     hr = E_FAIL;
    LPWSTR                                      pwzAppCfg = NULL;
    DWORD                                       dwVerifyFlags = SN_INFLAG_ADMIN_ACCESS;
    IAssemblyName                              *pNameGlobal = NULL;
    CTransCache                                *pTransCache = NULL;
    CTransCache                                *pTransCacheMax = NULL;
    CCache                                     *pCache = NULL;

    ASSERT(ppAsmOut);

    if (FAILED(hr = CCache::Create(&pCache, _pAppCtx))) {
        goto Exit;
    }

    hr = pCache->TransCacheEntryFromName(_pNameRefPolicy, ASM_CACHE_GAC,
                                         &pTransCache);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pTransCache->Retrieve(&pTransCacheMax, dwCmpMask);
    if (FAILED(hr) || hr == DB_S_NOTFOUND) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    if (pTransCacheMax->_pInfo->dwType & ASM_DELAY_SIGNED) {
        if(FAILED(VerifySignatureHelper(pTransCacheMax, dwVerifyFlags))) {
            hr = FUSION_E_SIGNATURE_CHECK_FAILED;
            goto Exit;
        }
    }

    hr = CCache::NameFromTransCacheEntry(pTransCacheMax, &pNameGlobal);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Start over with the name def now aquired.

    SAFERELEASE(_pNameRefSource);
    SAFERELEASE(_pCodebaseList);

    _pNameRefSource = pNameGlobal;
    _pNameRefSource->AddRef();
    
    hr = PreDownloadCheck((void **)ppAsmOut);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(pwzAppCfg);

    SAFERELEASE(pNameGlobal);
    SAFERELEASE(pTransCache);
    SAFERELEASE(pTransCacheMax);
    SAFERELEASE(pCache);

    return hr;
}

HRESULT CAsmDownloadMgr::RecordInfo()
{
    HRESULT                               hr = S_OK;
    IAssembly                            *pAsmActivated = NULL;

    // Insert info into policy cache
    
    if (_pPolicyCache && CCache::IsStronglyNamed(_pNameRefPolicy)) {
        hr = _pPolicyCache->InsertPolicy(_pNameRefSource, _pNameRefPolicy, &_bindHistory);
        if (FAILED(hr)) {
            DEBUGOUT(_pdbglog, 1, ID_FUSLOG_POLICY_CACHE_INSERT_FAILURE);
        }
    }

    // Record history logging information

    RecordBindHistory();
    
    // Add activation to load context

    hr = _pLoadContext->AddActivation(_pAsm, &pAsmActivated);
    if (FAILED(hr)) {
        goto Exit;
    }
    else if (hr == S_FALSE) {
        SAFERELEASE(_pAsm);
        _pAsm = pAsmActivated;
        hr = S_OK;
    }

Exit:
    return hr;
}

HRESULT CAsmDownloadMgr::RecordBindHistory()
{
    HRESULT                                    hr = S_OK;
    CBindHistory                              *pBindHistory = NULL;
    DWORD                                      dwSize = 0;
    LPWSTR                                     wzAppBase = NULL;
    LPWSTR                                     pwzAppCfgFile = NULL;
    LPWSTR                                     pwzFileName = NULL;
    LPWSTR                                     wzFullAppBase=NULL;
    WCHAR                                      wzAppBaseDir[MAX_PATH];
    WCHAR                                      wzEXEPath[MAX_PATH];
    WCHAR                                      wzCfgName[MAX_PATH];
    BOOL                                       bIsFileUrl;
    BOOL                                       bBindHistory = TRUE;

    hr = _pAppCtx->Get(ACTAG_RECORD_BIND_HISTORY, &bBindHistory, &dwSize, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_APP_BASE_URL, &wzAppBase);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        wzFullAppBase = NEW(WCHAR[MAX_URL_LENGTH+1]);
        if (!wzFullAppBase)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        dwSize = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(wzAppBase, wzFullAppBase, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        bIsFileUrl = UrlIsW(wzFullAppBase, URLIS_FILEURL);
        if (!bIsFileUrl) {
            bBindHistory = FALSE;
        }
        else {
            // Only record bind history for app contexts (appdomains), whose
            // appbase is the same as where the EXE was launched from, and the
            // config file name is appname.exe.config
        
            dwSize = MAX_PATH;
            hr = PathCreateFromUrlWrap(wzFullAppBase, wzAppBaseDir, &dwSize, 0);
            if (FAILED(hr)) {
                goto Exit;
            }
        
            hr = PathAddBackslashWrap(wzAppBaseDir, MAX_PATH);
            if (FAILED(hr)) {
                goto Exit;
            }
        
            lstrcpyW(wzEXEPath, g_wzEXEPath);
            pwzFileName = PathFindFileName(wzEXEPath);
            wnsprintfW(wzCfgName, MAX_PATH, L"%ws.config", pwzFileName);
            *pwzFileName = L'\0';
        
            if (FusionCompareStringI(wzAppBaseDir, wzEXEPath)) {
                bBindHistory = FALSE;
            }
            else {
                hr = ::AppCtxGetWrapper(_pAppCtx, ACTAG_APP_CONFIG_FILE, &pwzAppCfgFile);
                if (FAILED(hr) || hr == S_FALSE) {
                    bBindHistory = FALSE;
                }
                else if (FusionCompareStringI(pwzAppCfgFile, wzCfgName)) {
                    bBindHistory = FALSE;
                }
            }
        }

        dwSize = sizeof(bBindHistory);
        hr = _pAppCtx->Set(ACTAG_RECORD_BIND_HISTORY, &bBindHistory, dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    if (bBindHistory && (!g_dwMaxAppHistory || CCache::IsCustom(_pNameRefPolicy) ||
                         _pLoadContext->GetContextType() == LOADCTX_TYPE_LOADFROM ||
                         !CCache::IsStronglyNamed(_pNameRefPolicy) ||
                         IsHosted())) {

        // Do not record bind history

        bBindHistory = FALSE;
    }

    if (bBindHistory) {
        // Passes all the checks. Record the bind history.
    
        dwSize = sizeof(pBindHistory);
        hr = _pAppCtx->Get(ACTAG_APP_BIND_HISTORY, &pBindHistory, &dwSize, 0);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        ASSERT(pBindHistory);
    
        hr = pBindHistory->PersistBindHistory(&_bindHistory);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

Exit:
    SAFEDELETEARRAY(wzAppBase);
    SAFEDELETEARRAY(pwzAppCfgFile);
    SAFEDELETEARRAY(wzFullAppBase);

    return hr;
}

HRESULT CAsmDownloadMgr::LookupDownloadCacheAsm(IAssembly **ppAsm)
{
    HRESULT                                       hr = S_OK;
    LPWSTR                                        wzCodebase=NULL;
    DWORD                                         dwSize;
    DWORD                                         dwFlags;
    DWORD                                         dwCount;
    DWORD                                         i;

    ASSERT(ppAsm);

    hr = _pCodebaseList->GetCount(&dwCount);
    if (FAILED(hr)) {
        hr = S_FALSE;
        goto Exit;
    }

    wzCodebase = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzCodebase)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for (i = 0; i < dwCount; i++) {
        dwSize = MAX_URL_LENGTH;
        hr = _pCodebaseList->GetCodebase(i, &dwFlags, wzCodebase, &dwSize);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = GetMRUDownloadCacheAsm(wzCodebase, ppAsm);
        if (hr == S_OK) {
            ASSERT(ppAsm);
            goto Exit;
        }
    }

    // Missed in download cache.

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(wzCodebase);

    return hr;
}

HRESULT CAsmDownloadMgr::GetMRUDownloadCacheAsm(LPCWSTR pwzURL, IAssembly **ppAsm)
{
    HRESULT                                     hr = S_OK;
    IAssemblyName                              *pName = NULL;
    CCache                                     *pCache = NULL;
    CEnumCache                                 *pEnumR = NULL;
    CTransCache                                *pTransCache = NULL;
    CTransCache                                *pTC = NULL;
    CTransCache                                *pTCMax = NULL;
    TRANSCACHEINFO                             *pInfo = NULL;
    TRANSCACHEINFO                             *pInfoMax = NULL;
    IAssemblyManifestImport                    *pManifestImport=NULL;

    ASSERT(pwzURL && ppAsm);

    pEnumR = NEW(CEnumCache(FALSE, NULL));
    if (!pEnumR) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = CCache::Create(&pCache, NULL);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pCache->CreateTransCacheEntry(TRANSPORT_CACHE_SIMPLENAME_IDX, &pTransCache);
    if (FAILED(hr)) {
        goto Exit;
    }

    pInfo = (TRANSCACHEINFO *)pTransCache->_pInfo;
    pInfo->pwzCodebaseURL = WSTRDupDynamic(pwzURL);
    if (!pInfo->pwzCodebaseURL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if(FAILED(hr = CreateCacheMutex()))
        goto Exit;

    hr = pEnumR->Init(pTransCache, CTransCache::TCF_SIMPLE_PARTIAL_CODEBASE_URL);
    if (FAILED(hr)) {
        goto Exit;
    }
    else if (hr == DB_S_NOTFOUND) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    while (1) {
        hr = pCache->CreateTransCacheEntry(TRANSPORT_CACHE_SIMPLENAME_IDX, &pTC);
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = pEnumR->GetNextRecord(pTC);
        if (FAILED(hr)) {
            SAFERELEASE(pTC);
            goto Exit;
        }
        else if (hr == S_FALSE) {
            // Done iterating
            SAFERELEASE(pTC);
            break;
        }

        if (!pTCMax) {
            pTCMax = pTC;
        }
        else {
            pInfoMax = (TRANSCACHEINFO *)pTCMax->_pInfo;
            pInfo = (TRANSCACHEINFO *)pTC->_pInfo;

            if ((pInfoMax->ftLastModified.dwHighDateTime < pInfo->ftLastModified.dwHighDateTime) ||
                ((pInfoMax->ftLastModified.dwHighDateTime == pInfo->ftLastModified.dwHighDateTime) &&
                 (pInfoMax->ftLastModified.dwLowDateTime < pInfo->ftLastModified.dwLowDateTime))) {

               // New maximum found

               ASSERT(pTCMax);

               SAFERELEASE(pTCMax);
               pTCMax = pTC;
            }
            else {
                // Old maximum is fine. Release current, and continue iterating.
                SAFERELEASE(pTC);
            }
        }
    }

    if (pTCMax) {
        if (FAILED(hr = CreateAssemblyManifestImport(pTCMax->_pInfo->pwzPath, &pManifestImport)))
            goto Exit;

        ASSERT(pManifestImport);

        if (FAILED(hr = pManifestImport->GetAssemblyNameDef(&pName)))
            goto Exit;

        ASSERT(pName);

        if (pName->IsEqual(_pNameRefPolicy, ASM_CMPF_DEFAULT) == S_OK) {
            // Match found!

            hr = CreateAssemblyFromTransCacheEntry(pTCMax, NULL, ppAsm);
            if (FAILED(hr)) {
                goto Exit;
            }

            hr = S_OK;
        }
        else {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

Exit:

    SAFERELEASE(pTransCache);
    SAFERELEASE(pCache);
    SAFERELEASE(pTCMax);
    SAFERELEASE(pName);
    SAFERELEASE(pManifestImport);

    SAFEDELETE(pEnumR);

    return hr;
}

HRESULT CAsmDownloadMgr::SetAsmLocation(IAssembly *pAsm, DWORD dwAsmLoc)
{
    HRESULT                             hr = S_OK;
    CAssembly                          *pCAsm = dynamic_cast<CAssembly *>(pAsm);

    ASSERT(pAsm && pCAsm);

    if (_bCodebaseHintUsed) {
        dwAsmLoc |= ASMLOC_CODEBASE_HINT;
    }

    hr = pCAsm->SetAssemblyLocation(dwAsmLoc);

    return hr;
}

HRESULT CAsmDownloadMgr::GetAppCtx(IApplicationContext **ppAppCtx)
{
    ASSERT(ppAppCtx && _pAppCtx);

    *ppAppCtx = _pAppCtx;
    (*ppAppCtx)->AddRef();

    return S_OK;
}

HRESULT CAsmDownloadMgr::DownloadEnabled(BOOL *pbEnabled)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     cbBuf = 0;

    if (!pbEnabled) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = _pAppCtx->Get(ACTAG_CODE_DOWNLOAD_DISABLED, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        *pbEnabled = FALSE;
        hr = S_OK;
        goto Exit;
    }

    hr = S_OK;
    *pbEnabled = TRUE;

Exit:
    return hr;
}

HRESULT CheckValidAsmLocation(IAssemblyName *pNameDef, LPCWSTR wzSourceUrl,
                              IApplicationContext *pAppCtx,
                              LPCWSTR pwzParentURL,
                              LPCWSTR pwzSharedPathHint,
                              CDebugLog *pdbglog)
{
    HRESULT                             hr = S_OK;
    DWORD                               dwSize;
    LPWSTR                              pwzAppBase = NULL;
    LPWSTR                              wzAppBaseCanonicalized=NULL;
    BOOL                                bUnderAppBase;
    DWORD                               dwAppBaseFlags = APPBASE_CHECK_DYNAMIC_DIRECTORY |
                                                         APPBASE_CHECK_PARENT_URL |
                                                         APPBASE_CHECK_SHARED_PATH_HINT;

    if (!wzSourceUrl || !pNameDef) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    // If you're strongly named, you can be found anywhere, so just succeed.

    if (CCache::IsStronglyNamed(pNameDef)) {
        goto Exit;
    }

    // Get appbase

    ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_BASE_URL, &pwzAppBase);
    if (!pwzAppBase) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    wzAppBaseCanonicalized = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzAppBaseCanonicalized)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwSize = MAX_URL_LENGTH;
    hr = UrlCanonicalizeUnescape(pwzAppBase, wzAppBaseCanonicalized, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    // BUGBUG: Get rid of shared path hint

    bUnderAppBase = (IsUnderAppBase(pAppCtx, wzAppBaseCanonicalized, pwzParentURL, pwzSharedPathHint,
                     wzSourceUrl, dwAppBaseFlags) == S_OK);


    if (!bUnderAppBase) {
        DEBUGOUT1(pdbglog, 1, ID_FUSLOG_INVALID_LOCATION_INFO, wzSourceUrl);

        hr = FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(pwzAppBase);
    SAFEDELETEARRAY(wzAppBaseCanonicalized);
    return hr;
}


HRESULT IsUnderAppBase(IApplicationContext *pAppCtx, LPCWSTR pwzAppBaseCanonicalized,
                       LPCWSTR pwzParentURLCanonicalized,
                       LPCWSTR pwzSharedPathHint, LPCWSTR pwzSourceCanonicalized,
                       DWORD dwExtendedAppBaseFlags)
{
    HRESULT                                 hr = S_OK;
    LPWSTR                                  pwzSharedPathHintCanonicalized = NULL;
    LPWSTR                                  pwzDynamicDirCanonicalized = NULL;
    WCHAR                                   wzDynamicDir[MAX_PATH];
    LPWSTR                                  wzAppBase = NULL;
    BOOL                                    bUnderAppBase = FALSE;
    DWORD                                   cbLen;

    if (!pAppCtx || !pwzAppBaseCanonicalized || !pwzSourceCanonicalized) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pwzDynamicDirCanonicalized = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzDynamicDirCanonicalized) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pwzSharedPathHintCanonicalized = NEW(WCHAR[MAX_URL_LENGTH]);
    if (!pwzSharedPathHintCanonicalized) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Check if URL is really under appbase

    bUnderAppBase = (!FusionCompareStringNI(pwzSourceCanonicalized, pwzAppBaseCanonicalized, lstrlenW(pwzAppBaseCanonicalized)) != 0);
    
    if (dwExtendedAppBaseFlags & APPBASE_CHECK_DYNAMIC_DIRECTORY) {
        // Check dynamic directory
    
        if (!bUnderAppBase) {
            cbLen = MAX_PATH;
            hr = pAppCtx->GetDynamicDirectory(wzDynamicDir, &cbLen);
            if (SUCCEEDED(hr)) {
                cbLen = MAX_URL_LENGTH;
                hr = UrlCanonicalizeUnescape(wzDynamicDir, pwzDynamicDirCanonicalized, &cbLen, 0);
                if (FAILED(hr)) {
                    goto Exit;
                }
        
                bUnderAppBase = (!FusionCompareStringNI(pwzSourceCanonicalized, pwzDynamicDirCanonicalized, lstrlenW(pwzDynamicDirCanonicalized)) != 0);
            }
        }
    
    }

    if (pwzParentURLCanonicalized && (dwExtendedAppBaseFlags & APPBASE_CHECK_PARENT_URL)) {
        // Check parent URL

        if (!bUnderAppBase) {
            bUnderAppBase = (!FusionCompareStringNI(pwzSourceCanonicalized, pwzParentURLCanonicalized, lstrlenW(pwzParentURLCanonicalized)) != 0);
        }
    }

    if (pwzSharedPathHint && (dwExtendedAppBaseFlags & APPBASE_CHECK_SHARED_PATH_HINT)) {
        // BUGBUG: Get rid of this when we lose shared path hint
        // Check if it is under the shared path hint location
    
        if (!bUnderAppBase) {
            cbLen = MAX_URL_LENGTH;
            hr = UrlCanonicalizeUnescape(pwzSharedPathHint, pwzSharedPathHintCanonicalized, &cbLen, 0);
            if (FAILED(hr)) {
                goto Exit;
            }
    
            bUnderAppBase = (!FusionCompareStringNI(pwzSourceCanonicalized, pwzSharedPathHintCanonicalized, lstrlenW(pwzSharedPathHintCanonicalized)) != 0);
        }
    }

    hr = (bUnderAppBase) ? (S_OK) : (S_FALSE);

Exit:
    SAFEDELETEARRAY(pwzSharedPathHintCanonicalized);
    SAFEDELETEARRAY(pwzDynamicDirCanonicalized);

    return hr;
}

HRESULT MSIProvideAssemblyPeek(IAssemblyName *pNamePeek, IApplicationContext *pAppCtx)
{
    HRESULT                                        hr = S_OK;
    WCHAR                                          wzSID[MAX_SID_LEN];

    // See if package is deployed via app deployment.

    if (FAILED(GetCurrentUserSID(wzSID))) {
        goto Exit;
    }

    if (pAppCtx) {
        hr = MSIProvideAssemblyPrivatePeek(pNamePeek, pAppCtx, wzSID);
        if (hr == S_OK) {
            goto Exit;
        }
    }

    hr = MSIProvideAssemblyGlobalPeek(pNamePeek, wzSID);
    if (hr == S_OK) {
        goto Exit;
    }

    // Not found.

    hr = S_FALSE;

Exit:
    return hr;
}

HRESULT MSIProvideAssemblyPrivatePeek(IAssemblyName *pNamePeek, IApplicationContext *pAppCtx,
                                      LPCWSTR wzSID)
{
    HRESULT                               hr = S_FALSE;
    WCHAR                                 wzAppCfg[MAX_PATH];
    LPWSTR                                wzKey=NULL;
    LPWSTR                                pwzCur = NULL;
    DWORD                                 dwSize;

    ASSERT(pNamePeek && pAppCtx);

    // Use app config file path if available. Otherwise, just use the EXE
    // path.

    wzAppCfg[0] = L'\0';
    dwSize = sizeof(wzAppCfg);
    if (pAppCtx->Get(ACTAG_APP_CFG_LOCAL_FILEPATH, wzAppCfg, &dwSize, 0) != S_OK) {
        lstrcpyW(wzAppCfg, g_wzEXEPath);
    }

    // Replace all "\" with "|"

    pwzCur = wzAppCfg;
    while (*pwzCur) {
        if (*pwzCur == L'\\') {
            *pwzCur = L'|';
        }

        pwzCur++;
    }

    // See if package is deployed via app deployment

    wzKey = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzKey)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintfW(wzKey, MAX_URL_LENGTH, REG_KEY_MSI_APP_DEPLOYMENT_PRIVATE,
               wzSID, wzAppCfg);
    hr = MSIProvideAssemblyPeekEnum(pNamePeek, HKEY_LOCAL_MACHINE, wzKey);
    if (hr == S_OK) {
        goto Exit;
    }

    // See if package was user installed

    wnsprintfW(wzKey, MAX_URL_LENGTH, REG_KEY_MSI_USER_INSTALLED_PRIVATE, wzAppCfg);
    hr = MSIProvideAssemblyPeekEnum(pNamePeek, HKEY_CURRENT_USER, wzKey);
    if (hr == S_OK) {
        goto Exit;
    }

    // See if package was machine installed (ALLUSERS=1 on msiexec cmd line, or
    // inside package)


    wnsprintfW(wzKey, MAX_URL_LENGTH, REG_KEY_MSI_MACHINE_INSTALLED_PRIVATE, wzAppCfg);
    hr = MSIProvideAssemblyPeekEnum(pNamePeek, HKEY_LOCAL_MACHINE, wzKey);
    if (hr == S_OK) {
        goto Exit;
    }

    // Not found

    hr = S_FALSE;

Exit:
    SAFEDELETEARRAY(wzKey);
    return hr;
}

HRESULT MSIProvideAssemblyGlobalPeek(IAssemblyName *pNamePeek, LPCWSTR wzSID)
{
    HRESULT                                        hr = S_FALSE;
    LPWSTR                                         wzKey=NULL;

    ASSERT(pNamePeek);

    wzKey = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzKey)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    // See if package is deployed via app deployment.

    wnsprintfW(wzKey, MAX_URL_LENGTH, REG_KEY_MSI_APP_DEPLOYMENT_GLOBAL, wzSID);
    hr = MSIProvideAssemblyPeekEnum(pNamePeek, HKEY_LOCAL_MACHINE, wzKey);
    if (hr == S_OK) {
        goto Exit;
    }
    
    // See if package was user installed

    hr = MSIProvideAssemblyPeekEnum(pNamePeek, HKEY_CURRENT_USER,
                                    REG_KEY_MSI_USER_INSTALLED_GLOBAL);
    if (hr == S_OK) {
        goto Exit;
    }                                    

    // See if package was machine installed (ALLUSERS=1 on msiexec cmd line, or
    // inside package)

    hr = MSIProvideAssemblyPeekEnum(pNamePeek, HKEY_LOCAL_MACHINE,
                                    REG_KEY_MSI_MACHINE_INSTALLED_GLOBAL);
    if (hr == S_OK) {
        goto Exit;
    }

    // Not found

    hr = S_FALSE;                                    

Exit:
    SAFEDELETEARRAY(wzKey);
    return hr;
}

HRESULT MSIProvideAssemblyPeekEnum(IAssemblyName *pNamePeek, HKEY hkeyOpen,
                                   LPCWSTR wzSubKey)
{
    HRESULT                                        hr = S_FALSE;
    DWORD                                          dwIdx = 0;
    DWORD                                          dwType;
    DWORD                                          dwSize;
    LONG                                           lResult;
    HKEY                                           hkey = 0;
    IAssemblyName                                 *pName = NULL;
    LPWSTR                                         wzValueName=NULL;

    ASSERT(hkeyOpen && pNamePeek && wzSubKey);

    wzValueName = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzValueName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lResult = RegOpenKeyEx(hkeyOpen, wzSubKey, 0, KEY_READ, &hkey);

    while (lResult == ERROR_SUCCESS) {
        // BUGBUG: Somewhat arbitrary choice of MAX_URL_LENGTH for value size

        dwSize = MAX_URL_LENGTH;
        lResult = RegEnumValue(hkey, dwIdx++, wzValueName, &dwSize, NULL,
                               &dwType, NULL, NULL);
        if (lResult == ERROR_SUCCESS) {
            if (SUCCEEDED(CreateAssemblyNameObject(&pName, wzValueName,
                                                   CANOF_PARSE_DISPLAY_NAME, 0))) {
                if (pNamePeek->IsEqual(pName, ASM_CMPF_DEFAULT) == S_OK) {
                    // Match found!
                    hr = S_OK;
                    SAFERELEASE(pName);
                    goto Exit;
                }
        
                SAFERELEASE(pName);
            }
        }
    }

Exit:
    if (hkey != 0) {
        RegCloseKey(hkey);
    }

    SAFEDELETEARRAY(wzValueName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\cfgdl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <urlmon.h>
#include <string.h>
#include "adl.h"
#include "helpers.h"
#include "dl.h"
#include "list.h"
#include "cfgdl.h"
#include "appctx.h"
#include "history.h"

CCfgProtocolHook::Create(CCfgProtocolHook **ppHook,
                         IApplicationContext *pAppCtx,
                         CAssemblyDownload *padl,
                         IOInetProtocol *pProt,
                         CDebugLog *pdbglog)
{
    HRESULT                         hr = S_OK;
    DWORD                           cbBuf = 0;
    CCfgProtocolHook               *pHook = NULL;

    if (!ppHook || !padl || !pProt || !pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }                           
    
    hr = pAppCtx->Get(ACTAG_CODE_DOWNLOAD_DISABLED, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        hr = FUSION_E_CODE_DOWNLOAD_DISABLED;
        goto Exit;
    }

    pHook = NEW(CCfgProtocolHook(pProt, pAppCtx, pdbglog));
    if (!pHook) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pHook->Init(padl);
    if (FAILED(hr)) {
        SAFEDELETE(pHook);
        *ppHook = NULL;
        goto Exit;
    }

    *ppHook = pHook;

Exit:
    return hr;
}

CCfgProtocolHook::CCfgProtocolHook(IOInetProtocol *pProt, IApplicationContext *pAppCtx,
                                   CDebugLog *pdbglog)
: _pProt(pProt)
, _cRefs(1)
, _pwzFileName(NULL)
, _pAppCtx(pAppCtx)
, _hrResult(E_FAIL)
, _pdbglog(pdbglog)
{

    _dwSig = 'KOOH';
    
    // BUGBUG: It is NOT a bug that the _pProt is not addrefed (this is
    // also the case in DL.CPP). There is a bug in URLMON that results in
    // a circular ref count if we addref here.

    if (_pAppCtx) {
        _pAppCtx->AddRef();
    }

    if (_pdbglog) {
        _pdbglog->AddRef();
    }
}

CCfgProtocolHook::~CCfgProtocolHook() 
{
    HRESULT                                 hr;
    LISTNODE                                pos = NULL;
    CAssemblyDownload                      *padlCur = NULL;
    CApplicationContext                    *pAppCtx = dynamic_cast<CApplicationContext *>(_pAppCtx);

    ASSERT(pAppCtx);

    // Clean up the list (in most cases, should always be clean by now)
    hr = pAppCtx->Lock();
    if (hr == S_OK) {
        pos = _listQueuedBinds.GetHeadPosition();
        while (pos) {
            padlCur = _listQueuedBinds.GetAt(pos);
            ASSERT(padlCur);
    
            padlCur->Release();
            _listQueuedBinds.RemoveAt(pos);
    
            pos = _listQueuedBinds.GetHeadPosition();
        }

        pAppCtx->Unlock();
    }

    // Release ref counts and free memory

    SAFERELEASE(_pAppCtx);
    SAFERELEASE(_pdbglog);

    SAFEDELETEARRAY(_pwzFileName);
}

HRESULT CCfgProtocolHook::Init(CAssemblyDownload *padl)
{
    HRESULT                               hr = S_OK;

    hr = AddClient(padl);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT CCfgProtocolHook::AddClient(CAssemblyDownload *padl)
{
    HRESULT                              hr = S_OK;
    CApplicationContext                 *pAppCtx = dynamic_cast<CApplicationContext *>(_pAppCtx);

    ASSERT(pAppCtx);

    if (!padl) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    padl->AddRef();

    hr = pAppCtx->Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    _listQueuedBinds.AddTail(padl);
    pAppCtx->Unlock();

Exit:
    return hr;
}

HRESULT CCfgProtocolHook::QueryInterface(REFIID iid, void **ppvObj)
{
    HRESULT hr = NOERROR;
    *ppvObj = NULL;

    if (iid == IID_IUnknown  || iid == IID_IOInetProtocolSink) {
        *ppvObj = static_cast<IOInetProtocolSink *>(this);
    } 
    else if (iid == IID_IOInetBindInfo) {
        *ppvObj = static_cast<IOInetBindInfo *>(this);
    }
    else if (iid == IID_IServiceProvider) {
        *ppvObj = static_cast<IServiceProvider *>(this);
    }
    else if (iid == IID_IHttpNegotiate) {
        *ppvObj = static_cast<IHttpNegotiate *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppvObj) {
        AddRef();
    }

    return hr;
}    

ULONG CCfgProtocolHook::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRefs);
}

ULONG CCfgProtocolHook::Release(void)
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRefs);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

HRESULT CCfgProtocolHook::Switch(PROTOCOLDATA *pStateInfo)
{
    return _pProt->Continue(pStateInfo);
}


HRESULT CCfgProtocolHook::ReportProgress(ULONG ulStatusCode,
                                         LPCWSTR szStatusText)
{
    HRESULT                          hr = S_OK;
    int                              iLen;

    switch (ulStatusCode)
    {
        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
            ASSERT(!_pwzFileName && szStatusText);

            iLen = lstrlenW(szStatusText) + 1;

            _pwzFileName = NEW(WCHAR[iLen]);
            if (!_pwzFileName) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            lstrcpynW(_pwzFileName, szStatusText, iLen);

            break;

        case BINDSTATUS_FINDINGRESOURCE:
        case BINDSTATUS_CONNECTING:
        case BINDSTATUS_SENDINGREQUEST:
        case BINDSTATUS_MIMETYPEAVAILABLE:
        case BINDSTATUS_REDIRECTING:
            break;

        default:
            break;
    }

Exit:
    return hr;
}

HRESULT CCfgProtocolHook::ReportData(DWORD grfBSCF, ULONG ulProgress, 
                                       ULONG ulProgressMax)
{
    HRESULT                               hr = S_OK;
    char                                  pBuf[MAX_READ_BUFFER_SIZE];
    DWORD                                 cbRead;

    AddRef();

    // Pull data via pProt->Read(), here are the possible returned 
    // HRESULT values and how we should act upon: 
    // 
    // if E_PENDING is returned:  
    //    client already get all the data in buffer, there is nothing
    //    can be done here, client should walk away and wait for the  
    //    next chuck of data, which will be notified via ReportData()
    //    callback.
    // 
    // if S_FALSE is returned:
    //    this is EOF, everything is done, however, client must wait
    //    for ReportResult() callback to indicate that the pluggable 
    //    protocol is ready to shutdown.
    // 
    // if S_OK is returned:
    //    keep on reading, until you hit E_PENDING/S_FALSE/ERROR, the deal 
    //    is that the client is supposed to pull ALL the available
    //    data in the buffer
    // 
    // if none of the above is returning:
    //    Error occured, client should decide how to handle it, most
    //    commonly, client will call pProt->Abort() to abort the download
 

    while (hr == S_OK) {
        cbRead = 0;
    
        // pull data
        hr = _pProt->Read((void*)pBuf, MAX_READ_BUFFER_SIZE, &cbRead);
    }


    if (hr == S_FALSE) {
        // EOF reached
        goto Exit;
    }
    else if (hr != E_PENDING) {
        // Error in pProtocol->Read(). 
    }
    


Exit:
    Release();
    return hr;
}

HRESULT CCfgProtocolHook::ReportResult(HRESULT hrResult, DWORD dwError,
                                       LPCWSTR wzResult)
{
    HRESULT                                 hr = S_OK;
    LISTNODE                                pos = NULL;
    DWORD                                   dwSize = 0;
    CAssemblyDownload                      *padlCur = NULL;
    CApplicationContext                    *pAppCtx = dynamic_cast<CApplicationContext *>(_pAppCtx);
    AppCfgDownloadInfo                     *pdlinfo = NULL;
    HANDLE                                  hFile = INVALID_HANDLE_VALUE;

    ASSERT(pAppCtx);

    if (FAILED(hrResult)) {
        _hrResult = hrResult;
    }

    if (!_pwzFileName) {
        _hrResult = E_FAIL;
    }

    AddRef();

    hr = pAppCtx->Lock();
    if (FAILED(hr)) {
        return hr;
    }

    // Indicate that we have already attempted a download of app.cfg

    _pAppCtx->Set(ACTAG_APP_CFG_DOWNLOAD_ATTEMPTED, (void *)L"", sizeof(L""), 0);

    // Lock the cache file

    if (_pwzFileName) {
        hFile = CreateFile(_pwzFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_ASYNC_CFG_DOWNLOAD_SUCCESS, _pwzFileName);
            
            _pAppCtx->Set(ACTAG_APP_CFG_FILE_HANDLE, (void *)&hFile,
                          sizeof(HANDLE), 0);
        }
    }
    else {
        DEBUGOUT(_pdbglog, 1, ID_FUSLOG_ASYNC_CFG_DOWNLOAD_FAILURE);
    }

    // Set the app.cfg in the context

    if (SUCCEEDED(_hrResult)) {
        DEBUGOUT1(_pdbglog, 0, ID_FUSLOG_APP_CFG_FOUND, _pwzFileName);
        SetAppCfgFilePath(_pAppCtx, _pwzFileName);
        PrepareBindHistory(_pAppCtx);
    }

    // Kick off queued downloads

    pos = _listQueuedBinds.GetHeadPosition();

    while (pos) {
        padlCur = _listQueuedBinds.GetAt(pos);
        ASSERT(padlCur);

        // Do pre-download. That is, see now that we have the app.cfg,
        // see if it exists in the cache. If it does, then the padl needs
        // to 

        pAppCtx->Unlock();
        hr = padlCur->PreDownload(TRUE, NULL); // may report back synchronously
        if (FAILED(pAppCtx->Lock())) {
            return E_OUTOFMEMORY;
        }

        if (hr == S_OK) {
            hr = padlCur->KickOffDownload(TRUE);
        }

        // Failure in PreDownload or KickOffDownload phase
        if (FAILED(hr) && hr != E_PENDING) {
            pAppCtx->Unlock();
            padlCur->CompleteAll(NULL);
            if (FAILED(pAppCtx->Lock())) {
                return E_OUTOFMEMORY;
            }
        }

        // Clean up. We don't need this CAssemblyDownload anymore
        padlCur->Release();
        _listQueuedBinds.RemoveAt(pos);

        // iterate
        pos = _listQueuedBinds.GetHeadPosition();
    }

    dwSize = sizeof(AppCfgDownloadInfo *);
    hr = _pAppCtx->Get(ACTAG_APP_CFG_DOWNLOAD_INFO, &pdlinfo, &dwSize, 0);
    if (hr == S_OK) {
        // The async app.cfg download completed asynchronously (that is,
        // the calling code in DownloadAppCfg returned already, and this
        // is a callback from URLMON after the download). If hr != S_OK,
        // this means that URLMON called us back synchronously (but on a
        // different thread). That is, the pProt->Start is being executed
        // right now. The protocol pointers need to be released inside
        // DownloadAppCfgAsync in this case.

        // Release protocol pointers
    
        (pdlinfo->_pProt)->Terminate(0);
        (pdlinfo->_pSession)->Release();
        (pdlinfo->_pProt)->Release();
        (pdlinfo->_pHook)->Release();
        SAFEDELETE(pdlinfo);

        hr = _pAppCtx->Set(ACTAG_APP_CFG_DOWNLOAD_INFO, NULL, 0, 0);
        ASSERT(hr == S_OK);
    }
    
    pAppCtx->Unlock();

    Release();

    return NOERROR;
}

HRESULT
CCfgProtocolHook::GetBindInfo(
    DWORD *grfBINDF,
    BINDINFO * pbindinfo
)
{
    HRESULT hr = NOERROR;
    *grfBINDF = BINDF_DIRECT_READ | BINDF_ASYNCHRONOUS | BINDF_PULLDATA;// | BINDF_GETNEWESTVERSION;
    *grfBINDF &= ~BINDF_NO_UI;
    *grfBINDF &= ~BINDF_SILENTOPERATION;
    // *grfBINDF |= BINDF_FWD_BACK; // Use this to test synch case

    // for HTTP GET,  VERB is the only field we interested
    // for HTTP POST, BINDINFO will point to Storage structure which 
    //                contains data
    BINDINFO bInfo;
    ZeroMemory(&bInfo, sizeof(BINDINFO));

    // all we need is size and verb field
    bInfo.cbSize = sizeof(BINDINFO);
    bInfo.dwBindVerb = BINDVERB_GET;

    // src -> dest 
    hr = CopyBindInfo(&bInfo, pbindinfo );

    return hr;
}


HRESULT
CCfgProtocolHook::GetBindString(
    ULONG ulStringType,
    LPOLESTR *ppwzStr,
    ULONG cEl,
    ULONG *pcElFetched
)
{

    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    switch (ulStringType)
    {
    case BINDSTRING_HEADERS     :
    case BINDSTRING_EXTRA_URL   :
    case BINDSTRING_LANGUAGE    :
    case BINDSTRING_USERNAME    :
    case BINDSTRING_PASSWORD    :
    case BINDSTRING_ACCEPT_ENCODINGS:
    case BINDSTRING_URL:
    case BINDSTRING_USER_AGENT  :
    case BINDSTRING_POST_COOKIE :
    case BINDSTRING_POST_DATA_MIME:
        break;

    default:
        break; 
    }

    return hr;
}


HRESULT
CCfgProtocolHook::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void    **ppvObj 
)
{
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = NULL;
    if (guidService == IID_IHttpNegotiate ) {
        *ppvObj = static_cast<IHttpNegotiate*>(this);
    }
    else if (guidService == IID_IAuthenticate) {
        *ppvObj = static_cast<IAuthenticate *>(this);
    }
   
    if( *ppvObj )
    {
        AddRef();
        hr = NOERROR;
    } 
    
    
    return hr;
}


HRESULT
CCfgProtocolHook::BeginningTransaction(
    LPCWSTR szURL,
    LPCWSTR szHeaders,
    DWORD   dwReserved,
    LPWSTR  *pszAdditionalHeaders
)
{
    *pszAdditionalHeaders = NULL;
    return NOERROR;
}

HRESULT
CCfgProtocolHook::OnResponse(
    DWORD    dwResponseCode,
    LPCWSTR  szResponseHeaders,
    LPCWSTR  szRequestHeaders,
    LPWSTR   *pszAdditionalHeaders
)
{
    HRESULT                      hr = S_OK;

    _hrResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    switch (dwResponseCode) {
        case HTTP_RESPONSE_OK:
            _hrResult = S_OK;
            break;

        case HTTP_RESPONSE_UNAUTHORIZED:
        case HTTP_RESPONSE_FORBIDDEN:
            _hrResult = E_ACCESSDENIED;
            hr = E_ABORT;
            break;
            
        case HTTP_RESPONSE_FILE_NOT_FOUND:
            hr = E_ABORT;
            break;
    }
    
    return hr;
}


HRESULT CCfgProtocolHook::Authenticate(HWND *phwnd, LPWSTR *ppwzUsername,
                                       LPWSTR *ppwzPassword)
{
    // BUGBUG: In the future, we should delegate the QueryService back to
    // the caller, so they can do the authentication.

    *phwnd = GetDesktopWindow();
    *ppwzUsername = NULL;
    *ppwzPassword = NULL;

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\clbind.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "adl.h"
#include "clbind.h"

CClientBinding::CClientBinding(CAssemblyDownload *pad,
                               IAssemblyBindSink *pbindsink)
: _padl(pad)
, _pbindsink(pbindsink)
, _cRef(1)
, _cLocks(0)
, _bPendingDelete(FALSE)
{
    _dwSig = 'DNBC';
    if (_padl) {
        _padl->AddRef();
    }

    if (_pbindsink) {
        _pbindsink->AddRef();
    }
}

CClientBinding::~CClientBinding()
{
    if (_padl) {
        _padl->Release();
    }

    if (_pbindsink) {
        _pbindsink->Release();
    }
}

STDMETHODIMP CClientBinding::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT            hr = S_OK;

    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IAssemblyBinding) {
        *ppv = static_cast<IAssemblyBinding *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}  

STDMETHODIMP_(ULONG) CClientBinding::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CClientBinding::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }
    
    return ulRef;
}

IAssemblyBindSink *CClientBinding::GetBindSink()
{
    return _pbindsink;
}

STDMETHODIMP CClientBinding::Control(HRESULT hrControl)
{
    HRESULT                           hr = S_OK;

    switch (hrControl) {
        case E_ABORT:
            hr = _padl->ClientAbort(this);
            break;
        default:
            hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CClientBinding::DoDefaultUI(HWND hWnd, DWORD dwFlags)
{
    return E_NOTIMPL;
}

void CClientBinding::SetPendingDelete(BOOL bPending)
{
    _bPendingDelete = bPending;
}

int CClientBinding::LockCount()
{
    return _cLocks;
}

int CClientBinding::Lock()
{
    return InterlockedIncrement((LONG *)&_cLocks);
}

int CClientBinding::UnLock()
{
    return InterlockedDecrement((LONG *)&_cLocks);
}

BOOL CClientBinding::IsPendingDelete()
{
    return _bPendingDelete;
}

HRESULT CClientBinding::SwitchDownloader(CAssemblyDownload *padl)
{
    HRESULT                               hr = S_OK;

    if (!padl) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    SAFERELEASE(_padl);
    _padl = padl;
    _padl->AddRef();

Exit:
    return hr;
}

HRESULT CClientBinding::CallStartBinding()
{
    HRESULT                                    hr = S_OK;

    ASSERT(_pbindsink);

    _pbindsink->OnProgress(ASM_NOTIFICATION_START, S_OK, NULL, 0, 0, this);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\hashnode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "util.h"
#include "hashnode.h"
#include "helpers.h"

HRESULT CHashNode::Create(LPCWSTR pwzSource, CHashNode **ppHashNode)
{
    HRESULT                               hr = S_OK;
    CHashNode                            *pHashNode = NULL;

    if (!pwzSource || !ppHashNode) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppHashNode = NULL;

    pHashNode = new CHashNode();
    if (!pHashNode) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pHashNode->Init(pwzSource);
    if (FAILED(hr)) {
        delete pHashNode;
        goto Exit;
    }

    *ppHashNode = pHashNode;

Exit:
    return hr;
}

CHashNode::CHashNode()
: _pwzSource(NULL)
{
}

CHashNode::~CHashNode()
{
    if (_pwzSource) {
        delete [] _pwzSource;
    }
}

HRESULT CHashNode::Init(LPCWSTR pwzSource)
{
    HRESULT                           hr = S_OK;
    
    _pwzSource = WSTRDupDynamic(pwzSource);
    if (!_pwzSource) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}

BOOL CHashNode::IsDuplicate(LPCWSTR pwzStr) const
{
   BOOL                                 bRet = FALSE;

   if (!pwzStr) {
       goto Exit;
   }

   // BUGBUG: Technically, we should be doing a case-sensitive comparison
   // here because this is an URL, but to cut down code churn, leave the
   // comparison the same as before.

   if (!FusionCompareStringI(_pwzSource, pwzStr)) {
       bRet = TRUE;
   }

Exit:
   return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\mdlmgr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "fusionp.h"
#include "fuspriv.h"
#include "mdlmgr.h"
#include "naming.h"
#include "appctx.h"
#include "cblist.h"
#include "asmcache.h"
#include "asmimprt.h"
#include "asmitem.h"
#include "helpers.h"

HRESULT CModDownloadMgr::Create(CModDownloadMgr **ppDLMgr, IAssemblyName *pName,
                                IAssemblyManifestImport *pManImport, 
                                IApplicationContext *pAppCtx,
                                LPCWSTR pwzCodebase, LPCWSTR pwzModuleName,
                                CDebugLog *pdbglog)
{
    HRESULT                             hr = S_OK;
    CModDownloadMgr                    *pDLMgr = NULL;
        
    if (!ppDLMgr || !pName || !pAppCtx || !pwzModuleName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppDLMgr = NULL;

    pDLMgr = NEW(CModDownloadMgr(pName, pManImport, pAppCtx, pdbglog));
    if (!pDLMgr) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pDLMgr->Init(pwzCodebase, pwzModuleName);
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppDLMgr = pDLMgr;

Exit:
    return hr;
}


CModDownloadMgr::CModDownloadMgr(IAssemblyName *pName,
                                 IAssemblyManifestImport *pManImport,
                                 IApplicationContext *pAppCtx,
                                 CDebugLog *pdbglog)
: _cRef(1)
, _pName(pName)
, _pManImport(pManImport)
, _pAppCtx(pAppCtx)
, _pwzCodebase(NULL)
, _pwzModuleName(NULL)
, _dwNumCodebases(1)
, _pdbglog(pdbglog)
{
    _dwSig = 'RGMD';
    
    if (_pName) {
        _pName->AddRef();
    }

    if (_pManImport) {
        _pManImport->AddRef();
    }

    if (_pAppCtx) {
        _pAppCtx->AddRef();
    }

    if (_pdbglog) {
        _pdbglog->AddRef();
    }
}

CModDownloadMgr::~CModDownloadMgr()
{
    SAFERELEASE(_pName);
    SAFERELEASE(_pAppCtx);
    SAFERELEASE(_pdbglog);
    SAFERELEASE(_pManImport);
    SAFEDELETEARRAY(_pwzModuleName);
    SAFEDELETEARRAY(_pwzCodebase);
}

HRESULT CModDownloadMgr::Init(LPCWSTR pwzCodebase, LPCWSTR pwzModuleName)
{
    HRESULT                             hr = S_OK;
    int                                 iLen;

    ASSERT(!_pwzModuleName && pwzModuleName && !_pwzCodebase && pwzCodebase);

    iLen = lstrlenW(pwzModuleName) + 1;
    _pwzModuleName = NEW(WCHAR[iLen]);
    if (!_pwzModuleName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcpyW(_pwzModuleName, pwzModuleName);

    iLen = lstrlenW(pwzCodebase) + 1;
    _pwzCodebase = NEW(WCHAR[iLen]);
    if (!_pwzCodebase) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcpyW(_pwzCodebase, pwzCodebase);

Exit:
    return hr;
}

//
// IUnknown Methods
//

HRESULT CModDownloadMgr::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                    hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDownloadMgr)) {
        *ppv = static_cast<IDownloadMgr *>(this);
    }
    else if (IsEqualIID(riid, IID_ICodebaseList)) {
        *ppv = static_cast<ICodebaseList *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CModDownloadMgr::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CModDownloadMgr::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

//
// IDownloadMgr methods
//

HRESULT CModDownloadMgr::DoSetup(LPCWSTR wzSourceUrl, LPCWSTR wzFilePath,
                                 const FILETIME *pftLastMod, IUnknown **ppUnk)
{
    HRESULT                                    hr = S_OK;
    FILETIME                                   ftLastModified;
    IAssemblyModuleImport                     *pModImport = NULL;

    if (!wzFilePath || !ppUnk) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppUnk = NULL;
    
    // Get last modified time of file.
    if (!pftLastMod) {
        hr = ::GetFileLastModified(wzFilePath, &ftLastModified);
        if (FAILED(hr)) {
            DEBUGOUT1(_pdbglog, 1, ID_FUSLOG_LAST_MOD_FAILURE, wzFilePath);
            goto Exit;
        }
    }
    else {
        memcpy(&ftLastModified, pftLastMod, sizeof(FILETIME));
    }

    // Add module to assembly, returning associated mod import interface.
    hr = AddModuleToAssembly(_pAppCtx, _pName, wzSourceUrl, &ftLastModified, wzFilePath,
                             _pwzModuleName, _pManImport, _pdbglog, &pModImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    *ppUnk = pModImport;

Exit:
    return hr;
}

HRESULT CModDownloadMgr::ProbeFailed(IUnknown **ppUnk)
{
    *ppUnk = NULL;
    return E_NOTIMPL;
}

HRESULT CModDownloadMgr::PreDownloadCheck(void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

//
// ICodebaseList Methods.
//

HRESULT CModDownloadMgr::AddCodebase(LPCWSTR wzCodebase, DWORD dwFlags)
{
    // Not supported. We only have one codebase for modules (ie. we don't
    // probe).
    return E_NOTIMPL;
}

HRESULT CModDownloadMgr::RemoveCodebase(DWORD dwIndex)
{
    HRESULT                                  hr = S_OK;

    if (dwIndex > 1) {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    if (!_dwNumCodebases) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto Exit;
    }

    _dwNumCodebases = 0;

Exit:
    return hr;
}

HRESULT CModDownloadMgr::GetCodebase(DWORD dwIndex, DWORD *pdwFlags, LPWSTR wzCodebase,
                                     DWORD *pcbCodebase)
{
    HRESULT                              hr = S_OK;
    DWORD                                dwLen;

    if (dwIndex > 1 || !pcbCodebase || !pdwFlags) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (!_dwNumCodebases) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto Exit;
    }

    *pdwFlags = 0;

    dwLen = lstrlenW(_pwzCodebase) + 1;
    if (*pcbCodebase < dwLen) {
        *pcbCodebase = dwLen;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    lstrcpyW(wzCodebase, _pwzCodebase);
    *pcbCodebase = dwLen;

Exit:
    return hr;
}

HRESULT CModDownloadMgr::RemoveAll()
{
    _dwNumCodebases = 0;

    return S_OK;
}

HRESULT CModDownloadMgr::GetCount(DWORD *pdwCount)
{
    HRESULT                              hr = S_OK;

    if (!pdwCount) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pdwCount = _dwNumCodebases;

Exit:
    return hr;
}

HRESULT CModDownloadMgr::IsDuplicate(IDownloadMgr *pDLMgr)
{
    return E_NOTIMPL;
}

HRESULT CModDownloadMgr::LogResult()
{
    return S_OK;
}

HRESULT CModDownloadMgr::DownloadEnabled(BOOL *pbEnabled)
{
    HRESULT                                   hr = S_OK;
    DWORD                                     cbBuf = 0;

    if (!pbEnabled) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = _pAppCtx->Get(ACTAG_CODE_DOWNLOAD_DISABLED, NULL, &cbBuf, 0);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        *pbEnabled = FALSE;
        hr = S_OK;
        goto Exit;
    }

    hr = S_OK;
    *pbEnabled = TRUE;

Exit:
    return hr;
}

//
// AddModuleToAssembly
//

HRESULT AddModuleToAssembly(IApplicationContext *pAppCtx,
                            IAssemblyName *pName, LPCOLESTR pszURL,
                            FILETIME *pftLastModTime, LPCOLESTR szPath,
                            LPCWSTR pwzModuleName, 
                            IAssemblyManifestImport *pManImport,
                            CDebugLog *pdbglog,
                            IAssemblyModuleImport **ppModImport)
{    
    HRESULT                              hr = S_OK;
    CAssemblyCacheItem                  *pAsmItem = NULL;
    BOOL fManifestCreated = FALSE;

    // Create an assembly cache item from an existing entry.
    hr = CAssemblyCacheItem::Create(pAppCtx, pName, (LPTSTR)pszURL, pftLastModTime,
                                    ASM_CACHE_DOWNLOAD,
                                    pManImport, NULL, (IAssemblyCacheItem **)&pAsmItem);
    if (FAILED(hr)) {
        DEBUGOUT1(pdbglog, 1, ID_FUSLOG_CACHE_ITEM_CREATE_FAILURE, hr);
        goto Exit;
    }

    // Copy the file to the assembly cache.
    hr = CopyAssemblyFile(pAsmItem, szPath, STREAM_FORMAT_COMPLIB_MODULE);
    if (FAILED(hr)) {
        DEBUGOUT(pdbglog, 1, ID_FUSLOG_COPY_FILE_FAILURE);
        goto Exit;
    }

    // Commit to transport cache.
    hr = pAsmItem->Commit(0, NULL);
    if (FAILED(hr)) {
        DEBUGOUT1(pdbglog, 1, ID_FUSLOG_CACHE_ITEM_COMMIT_FAILURE, hr);
        goto Exit;
    }

    // Check if a mod import interface is required.
    if (pwzModuleName && ppModImport)
    {
        // We will return an IAssemblyModule interface. To do this we need to 
        // first construct an IAssemblyManifestImport interface and generate
        // the module import interface from that.
    
        // Create the manifest import interface from manifest file path.
        if (!pManImport)
        {
            hr = CreateAssemblyManifestImport(pAsmItem->GetManifestPath(), &pManImport);
            if (FAILED(hr)) {
                DEBUGOUT1(pdbglog, 1, ID_FUSLOG_MANIFEST_EXTRACT_FAILURE, hr);
                goto Exit;
            }
            fManifestCreated = TRUE;
        }

        // Get module interface for name passed in.
        hr = pManImport->GetModuleByName(pwzModuleName, ppModImport);
        if (FAILED(hr)) {
            goto Exit;
        }
    }            

Exit:
    if (fManifestCreated)
        SAFERELEASE(pManImport);
    SAFERELEASE(pAsmItem);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\extract.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *  EXTRACT.C based on code copied from IE code download
 *
 *  Author:
 *      Alan Shi
 *
 *  History:
 *      08-Feb-2000 AlanShi copied/modified for Fusion
 *
 */

#undef UNICODE

#include <windows.h>
#include <io.h>
#include <stdio.h>
#include <fcntl.h>
#include "fdi_d.h"
#include "debmacro.h"
#include "fusionp.h"
#include "lock.h"
#include "utf8.h"

#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

CFdiDll g_fdi(FALSE);

void PathConvertSlash(WCHAR *pszPath)
{
    LPWSTR                        psz = pszPath;
    
    ASSERT(pszPath);

    while (*psz) {
        if (*psz == L'/') {
            *psz = L'\\';
        }

        psz++;
    }
}

// single theaded access to the FDI lib
extern CRITICAL_SECTION g_csDownload;

/*
 * W i n 3 2 O p e n ( )
 *
 * Routine:     Win32Open()
 *
 * Purpose:     Translate a C-Runtime _open() call into appropriate Win32
 *              CreateFile()
 *
 * Returns:     Handle to file              on success
 *              INVALID_HANDLE_VALUE        on failure
 *
 *
 * BUGBUG: Doesn't fully implement C-Runtime _open() capability but it
 * BUGBUG: currently supports all callbacks that FDI will give us
 */

HANDLE Win32Open(WCHAR *pwzFile, int oflag, int pmode)
{
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    BOOL    fExists     = FALSE;
    DWORD   fAccess;
    DWORD   fCreate;


    ASSERT( pwzFile );

        // BUGBUG: No Append Mode Support
    if (oflag & _O_APPEND)
        return( INVALID_HANDLE_VALUE );

        // Set Read-Write Access
    if ((oflag & _O_RDWR) || (oflag & _O_WRONLY))
        fAccess = GENERIC_WRITE;
    else
        fAccess = GENERIC_READ;

        // Set Create Flags
    if (oflag & _O_CREAT)  {
        if (oflag & _O_EXCL)
            fCreate = CREATE_NEW;
        else if (oflag & _O_TRUNC)
            fCreate = CREATE_ALWAYS;
        else
            fCreate = OPEN_ALWAYS;
    } else {
        if (oflag & _O_TRUNC)
            fCreate = TRUNCATE_EXISTING;
        else
            fCreate = OPEN_EXISTING;
    }

    //BUGBUG: seterrormode to no crit errors and then catch sharing violations
    // and access denied

    // Call Win32
    FileHandle = CreateFileW(
                        pwzFile, fAccess, FILE_SHARE_READ, NULL, fCreate,
                        FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE
                       );

    if (FileHandle == INVALID_HANDLE_VALUE &&
        WszSetFileAttributes(pwzFile, FILE_ATTRIBUTE_NORMAL))
        FileHandle = CreateFileW(
                            pwzFile, fAccess, FILE_SHARE_READ, NULL, fCreate,
                            FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE
                           );
    return( FileHandle );
}

/*
 * O p e n F u n c ( )
 *
 * Routine:     OpenFunc()
 *
 * Purpose:     Open File Callback from FDI
 *
 * Returns:     File Handle (small integer index into file table)
 *              -1 on failure
 *
 */

int FAR DIAMONDAPI openfuncw(WCHAR FAR *pwzFile, int oflag, int pmode )
{
    int     rc;
    HANDLE hf;

    ASSERT( pwzFile );

    hf = Win32Open(pwzFile, oflag, pmode );
    if (hf != INVALID_HANDLE_VALUE)  {
        // SUNDOWN: typecast problem
        rc = PtrToLong(hf);
    } else {
        rc = -1;
    }

    return( rc );
}

int FAR DIAMONDAPI openfunc(char FAR *pszFile, int oflag, int pmode )
{
    WCHAR                      wzFileName[MAX_PATH];

    if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                             pszFile, -1, wzFileName, MAX_PATH)) {
        return -1;
    }

    return openfuncw(wzFileName, oflag, pmode);
}


/*
 * R E A D F U N C ( )
 *
 * Routine:     readfunc()
 *
 * Purpose:     FDI read() callback
 *
 */

UINT FAR DIAMONDAPI readfunc(int hf, void FAR *pv, UINT cb)
{
    int     rc;


    ASSERT( pv );

    if (! ReadFile(LongToHandle(hf), pv, cb, (DWORD *) &cb, NULL))
        rc = -1;
    else
        rc = cb;

    return( rc );
}

/*
 *  W r i t e F u n c ( )
 *
 * Routine:     WriteFunc()
 *
 * Purpose:     FDI Write() callback
 *
 */

UINT FAR DIAMONDAPI writefunc(int hf, void FAR *pv, UINT cb)
{
    int rc;

    ASSERT( pv );

    if (! WriteFile(LongToHandle(hf), pv, cb, (DWORD *) &cb, NULL))
        rc = -1;
    else
        rc = cb;


    // BUGBUG: implement OnProgress notification

    return( rc );
}

/*
 * C l o s e F u n c ( )
 *
 * Routine:     CloseFunc()
 *
 * Purpose:     FDI Close File Callback
 *
 */

int FAR DIAMONDAPI closefunc( int hf )
{
    int rc;


    if (CloseHandle( LongToHandle(hf) ))  {
        rc = 0;
    } else {
        rc = -1;
    }

    return( rc );
}

/*
 * S e e k F u n c ( )
 *
 * Routine:     seekfunc()
 *
 * Purpose:     FDI Seek Callback
 */

long FAR DIAMONDAPI seekfunc( int hf, long dist, int seektype )
{
    long    rc;
    DWORD   W32seektype;


        switch (seektype) {
            case SEEK_SET:
                W32seektype = FILE_BEGIN;
                break;
            case SEEK_CUR:
                W32seektype = FILE_CURRENT;
                break;
            case SEEK_END:
                W32seektype = FILE_END;
                break;
            default:
                ASSERT(0);
                return -1;
        }

        rc = SetFilePointer(LongToHandle(hf), dist, NULL, W32seektype);
        if (rc == 0xffffffff)
            rc = -1;

    return( rc );
}

/*
 * A l l o c F u n c ( )
 *
 * FDI Memory Allocation Callback
 */

FNALLOC(allocfunc)
{
    void *pv;

    pv = (void *) HeapAlloc( GetProcessHeap(), 0, cb );
    return( pv );
}

/*
 * F r e e F u n c ( )
 *
 * FDI Memory Deallocation Callback
 *      XXX Return Value?
 */

FNFREE(freefunc)
{
    ASSERT(pv);

    HeapFree( GetProcessHeap(), 0, pv );
}

/*
 * A d j u s t F i l e T i m e ( )
 *
 * Routine:     AdjustFileTime()
 *
 * Purpose:     Change the time info for a file
 */

BOOL AdjustFileTime(int hf, USHORT date, USHORT time )
{
    FILETIME    ft;
    FILETIME    ftUTC;


    if (! DosDateTimeToFileTime( date, time, &ft ))
        return( FALSE );

    if (! LocalFileTimeToFileTime(&ft, &ftUTC))
        return( FALSE );

    if (! SetFileTime(LongToHandle(hf),&ftUTC,&ftUTC,&ftUTC))
        return( FALSE );

    return( TRUE );
}



/*
 * A t t r 3 2 F r o m A t t r F A T ( )
 *
 * Translate FAT attributes to Win32 Attributes
 */

DWORD Attr32FromAttrFAT(WORD attrMSDOS)
{
    //** Quick out for normal file special case
    if (attrMSDOS == _A_NORMAL) {
        return FILE_ATTRIBUTE_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!
    //
    return attrMSDOS & ~(_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}


/*
 * f d i N o t i f y  E x t r a c t()
 *
 * Routine:     fdiNotifyExtract()
 *
 * Purpose:     Principle FDI Callback in file extraction
 *
 *
 */

// In parameters: FDINOTIFICATIONTYPE fdint
//                PFDNOTIFICATION pfdin
// Return values: -1 == ERROR. Anything else == success.

FNFDINOTIFY(fdiNotifyExtract)
{
    int                             fh = 0;
    WCHAR                           wzFileName[MAX_PATH];
    WCHAR                           wzPath[MAX_PATH];
    WCHAR                           wzChildDir[MAX_PATH];
    WCHAR                           wzTempDirCanonicalized[MAX_PATH];
    WCHAR                           wzPathCanonicalized[MAX_PATH];
    WCHAR                          *pwzFileName;
    BOOL                            bRet;

    wzFileName[0] = L'\0';

    if (fdint == fdintCOPY_FILE || fdint == fdintCLOSE_FILE_INFO) {
        if (pfdin->psz1 && pfdin->attribs & _A_NAME_IS_UTF) {
            if (!Dns_Utf8ToUnicode(pfdin->psz1, lstrlenA(pfdin->psz1), wzFileName, MAX_PATH)) {
                return -1;
            }
        }
        else {
            if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                     pfdin->psz1, -1, wzFileName, MAX_PATH)) {
                return -1;
            }
        }
    }

    switch (fdint)  {
        case fdintCABINET_INFO:
            return 0;

        case fdintCOPY_FILE:
            wnsprintfW(wzPath, MAX_PATH, L"%ws%ws", (WCHAR *)pfdin->pv, wzFileName);
            PathConvertSlash(wzPath);

            PathCanonicalizeW(wzTempDirCanonicalized, (WCHAR *)pfdin->pv);
            PathCanonicalizeW(wzPathCanonicalized, wzPath);

            if (FusionCompareStringNI(wzTempDirCanonicalized, wzPathCanonicalized, lstrlenW(wzTempDirCanonicalized))) {
                // Extraction is outside temp directory! Fail.
                return -1;
            }

            if (StrStrW(wzFileName, L"\\")) {
                // If the file in the CAB has a path, make sure the directory
                // has been created in our temp extract location.

                lstrcpyW(wzChildDir, wzPathCanonicalized);
                pwzFileName = PathFindFileNameW(wzChildDir);
                *pwzFileName = L'\0';

                if (GetFileAttributesW(wzChildDir) == -1) {
                    bRet = CreateDirectoryW(wzChildDir, NULL);
                    if (!bRet) {
                        // failed
                        return -1;
                    }
                }
            }

            fh = openfuncw(wzPathCanonicalized, _O_BINARY | _O_EXCL | _O_RDWR | _O_CREAT, 0);

            return(fh); // -1 if error on open

        case fdintCLOSE_FILE_INFO:
            if (!AdjustFileTime(pfdin->hf, pfdin->date, pfdin->time))  {
                // FDI.H lies! If you return -1 here, it will call you
                // to close the handle
                return -1;
            }

            wnsprintfW(wzPath, MAX_PATH, L"%ws%ws", pfdin->pv, wzFileName);

            if (!WszSetFileAttributes(wzPath, Attr32FromAttrFAT(pfdin->attribs))) {
                return -1;
            }

            closefunc(pfdin->hf);

            return TRUE;

        case fdintPARTIAL_FILE:
            return -1; // Not supported

        case fdintNEXT_CABINET:
            return -1; // Not supported

        default:
            //ASSERT(0); // Unknown callback type
            break;
    }

    return 0;
}

/*
 * E X T R A C T ( )
 *
 * Routine: Extract()
 *
 * Parameters:
 *
 *      PSESSION ps = session information tied to this extract session
 *
 *          IN params
 *              ps->pFilesToExtract = linked list of PFNAMEs that point to
 *                                    upper case filenames that need extraction
 *
 *              ps->flags SESSION_FLAG_ENUMERATE = whether need to enumerate
 *                                  files in CAB (ie. create a pFileList
 *              ps->flags SESSION_FLAG_EXTRACTALL =  all
 *
 *          OUT params
 *              ps->pFileList = global alloced list of files in CAB
 *                              caller needs to call DeleteExtractedFiles
 *                              to free memory and temp files
 *
 *
 *      LPCSTR lpCabName = name of cab file
 *
 *
 * Returns:
 *          S_OK: sucesss
 *
 *
 */

HRESULT Extract(LPCSTR lpCabName, LPCWSTR lpUniquePath)
{
    HRESULT                                  hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    HFDI                                     hfdi;
    ERF                                      erf;
    BOOL                                     fExtractResult = FALSE;
    CCriticalSection                         cs(&g_csDownload);

    ASSERT(lpCabName && lpUniquePath);

    memset(&erf, 0, sizeof(ERF));

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    // Extract the files
    hfdi = g_fdi.FDICreate(allocfunc, freefunc, openfunc, readfunc, writefunc,
                           closefunc, seekfunc, cpu80386, &erf);
    if (hfdi == NULL)  {
        // Error value will be retrieved from erf
        hr = STG_E_UNKNOWN;
        cs.Unlock();
        goto Exit;
    }

    fExtractResult = g_fdi.FDICopy(hfdi, (char FAR *)lpCabName, "", 0,
                                   fdiNotifyExtract, NULL, (void *)lpUniquePath);

    if (g_fdi.FDIDestroy(hfdi) == FALSE)  {
        hr = STG_E_UNKNOWN;
        cs.Unlock();
        goto Exit;
    }

    if (fExtractResult && (!erf.fError)) {
        hr = S_OK;
    }

    cs.Unlock();

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\dl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <urlmon.h>
#include <wininet.h>
#include <string.h>
#include "adl.h"
#include "helpers.h"
#include "dl.h"
#include "util.h"

COInetProtocolHook::Create(COInetProtocolHook **ppHook,
                           CAssemblyDownload *padl,
                           IOInetProtocol *pProt,
                           LPCWSTR pwzUrlOriginal,
                           CDebugLog *pdbglog)
{
    HRESULT                         hr = S_OK;
    COInetProtocolHook             *pHook = NULL;

    if (ppHook) {
        *ppHook = NULL;
    }

    if (!padl || !pProt || !ppHook || !pwzUrlOriginal) {
        hr = E_INVALIDARG;
        goto Exit;
    }                           

    pHook = NEW(COInetProtocolHook(padl, pProt, pdbglog));
    if (!pHook) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pHook->Init(pwzUrlOriginal);
    if (FAILED(hr)) {
        SAFEDELETE(pHook);
        goto Exit;
    }

    *ppHook = pHook;

Exit:
    return hr;
}

COInetProtocolHook::COInetProtocolHook(CAssemblyDownload *padl,
                                       IOInetProtocol *pProt,
                                       CDebugLog *pdbglog)
: _padl(padl)
, _pProt(pProt)
, _pwzFileName(NULL)
, _cRefs(1)
, _bReportBeginDownload(FALSE)
, _hrResult(S_OK)
, _cbTotal(0)
, _bSelfAborted(FALSE)
, _pwzUrlOriginal(NULL)
, _pSecurityManager(NULL)
, _pdbglog(pdbglog)
, _bCrossSiteRedirect(FALSE)
{
    _dwSig = 'KHIO';

    memset(&_ftHttpLastMod, 0, sizeof(_ftHttpLastMod));

    if (_padl) {
        _padl->AddRef();
    }

    if (_pdbglog) {
        _pdbglog->AddRef();
    }

#if 0   
    if (_pProt) {
        _pProt->AddRef();
    }
#endif
}

COInetProtocolHook::~COInetProtocolHook() 
{
    if (_padl) {
        _padl->Release();
    }

#if 0
    if (_pProt) {
        _pProt->Release();
    }
#endif

    if (_pwzFileName) {
        delete [] _pwzFileName;
    }

    SAFEDELETEARRAY(_pwzUrlOriginal);

    SAFERELEASE(_pdbglog);
    SAFERELEASE(_pSecurityManager);
}

HRESULT COInetProtocolHook::Init(LPCWSTR pwzUrlOriginal)
{
    HRESULT                                 hr = S_OK;

    hr = CoInternetCreateSecurityManager(NULL, &_pSecurityManager, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    memset(_abSecurityId, 0, sizeof(_abSecurityId));
    _cbSecurityId = sizeof(_abSecurityId);

    hr = _pSecurityManager->GetSecurityId(pwzUrlOriginal, _abSecurityId,
                                          &_cbSecurityId, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    _pwzUrlOriginal = WSTRDupDynamic(pwzUrlOriginal);
    if (!_pwzUrlOriginal) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}

HRESULT COInetProtocolHook::QueryInterface(REFIID iid, void **ppvObj)
{
    HRESULT hr = NOERROR;
    *ppvObj = NULL;

    if (iid == IID_IUnknown  || iid == IID_IOInetProtocolSink) {
        *ppvObj = static_cast<IOInetProtocolSink *>(this);
    } 
    else if (iid == IID_IOInetBindInfo) {
        *ppvObj = static_cast<IOInetBindInfo *>(this);
    }
    else if (iid == IID_IServiceProvider) {
        *ppvObj = static_cast<IServiceProvider *>(this);
    }
    else if (iid == IID_IHttpNegotiate) {
        *ppvObj = static_cast<IHttpNegotiate *>(this);
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppvObj) {
        AddRef();
    }

    return hr;
}    

ULONG COInetProtocolHook::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRefs);
}

ULONG COInetProtocolHook::Release(void)
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRefs);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

HRESULT COInetProtocolHook::Switch(PROTOCOLDATA *pStateInfo)
{
    return _pProt->Continue(pStateInfo);
}


HRESULT COInetProtocolHook::ReportProgress(ULONG ulStatusCode,
                                           LPCWSTR szStatusText)
{
    HRESULT                          hr = S_OK;
    int                              iLen;

    switch (ulStatusCode)
    {
        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
            ASSERT(!_pwzFileName && szStatusText);

            iLen = lstrlenW(szStatusText) + 1;

            _pwzFileName = NEW(WCHAR[iLen]);
            if (!_pwzFileName) {
                hr = E_OUTOFMEMORY;
                _padl->FatalAbort(hr);
                goto Exit;
            }

            lstrcpynW(_pwzFileName, szStatusText, iLen);

            break;

        case BINDSTATUS_FINDINGRESOURCE:
        case BINDSTATUS_CONNECTING:
        case BINDSTATUS_SENDINGREQUEST:
        case BINDSTATUS_MIMETYPEAVAILABLE:
            break;

        case BINDSTATUS_REDIRECTING:
            BYTE                abSecurityId[MAX_SIZE_SECURITY_ID];
            DWORD               cbSecurityId;

            memset(abSecurityId, 0, sizeof(abSecurityId));
            cbSecurityId = sizeof(abSecurityId);
            
            hr = _pSecurityManager->GetSecurityId(szStatusText, abSecurityId,
                                                  &cbSecurityId, 0);
            if (FAILED(hr)) {
                goto Exit;
            }

            if (cbSecurityId != _cbSecurityId || memcmp(abSecurityId, _abSecurityId, cbSecurityId)) {
                // Redirecting across sites. Error out.

                DEBUGOUT2(_pdbglog, 0, ID_FUSLOG_CROSS_SITE_REDIRECT, _pwzUrlOriginal, szStatusText);

                _bCrossSiteRedirect = TRUE;
                // hr = _pProt->Abort(HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), 0);
                goto Exit;

            }
                
            break;

        default:
            break;
    }

Exit:
    return hr;
}

HRESULT COInetProtocolHook::ReportData(DWORD grfBSCF, ULONG ulProgress, 
                                       ULONG ulProgressMax)
{
    HRESULT                               hr = S_OK;
    char                                  pBuf[MAX_READ_BUFFER_SIZE];
    DWORD                                 cbRead;

    AddRef();

    // Pull data via pProt->Read(), here are the possible returned 
    // HRESULT values and how we should act upon: 
    // 
    // if E_PENDING is returned:  
    //    client already get all the data in buffer, there is nothing
    //    can be done here, client should walk away and wait for the  
    //    next chuck of data, which will be notified via ReportData()
    //    callback.
    // 
    // if S_FALSE is returned:
    //    this is EOF, everything is done, however, client must wait
    //    for ReportResult() callback to indicate that the pluggable 
    //    protocol is ready to shutdown.
    // 
    // if S_OK is returned:
    //    keep on reading, until you hit E_PENDING/S_FALSE/ERROR, the deal 
    //    is that the client is supposed to pull ALL the available
    //    data in the buffer
    // 
    // if none of the above is returning:
    //    Error occured, client should decide how to handle it, most
    //    commonly, client will call pProt->Abort() to abort the download
 

    while (hr == S_OK) {
        cbRead = 0;
    
        if (ulProgress > _cbTotal) {
            _padl->ReportProgress(BINDSTATUS_BEGINDOWNLOADCOMPONENTS,
                                  ulProgress,
                                  ulProgressMax,
                                  ASM_NOTIFICATION_PROGRESS,
                                  NULL, S_OK);
        }

        // pull data
        hr = _pProt->Read((void*)pBuf, MAX_READ_BUFFER_SIZE, &cbRead);
        _cbTotal += cbRead;
    }


    if (hr == S_FALSE) {
        // EOF reached
        goto Exit;
    }
    else if (hr != E_PENDING) {
        // Error in pProtocol->Read(). Abort download
        _padl->FatalAbort(hr);
    }
    


Exit:
    Release();
    return hr;
}

HRESULT COInetProtocolHook::ReportResult(HRESULT hrResult, DWORD dwError,
                                         LPCWSTR wzResult)
{
    // Tell CAssemblyDownload that the download is complete. This may
    // (READ: probably will) occur on a different thread than the one that
    // originally started the download.

    ASSERT(_padl);

    // If we self-aborted, the _hrResult is already set.
    if (FAILED(hrResult) && !_bSelfAborted) {
        _hrResult = hrResult;
    }

    if (SUCCEEDED(_hrResult) && !_pwzFileName) {
        _hrResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (_bCrossSiteRedirect) {
        _hrResult = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    _padl->DownloadComplete(_hrResult, _pwzFileName, &_ftHttpLastMod, TRUE);

    return NOERROR;
}

HRESULT
COInetProtocolHook::GetBindInfo(
    DWORD *grfBINDF,
    BINDINFO * pbindinfo
)
{
    HRESULT hr = NOERROR;
    *grfBINDF = BINDF_DIRECT_READ | BINDF_ASYNCHRONOUS | BINDF_PULLDATA;
    // *grfBINDF |= BINDF_FWD_BACK; // Use this to test synch case
    // *grfBINDF |= BINDF_OFFLINEOPERATION;

    // for HTTP GET,  VERB is the only field we interested
    // for HTTP POST, BINDINFO will point to Storage structure which 
    //                contains data
    BINDINFO bInfo;
    ZeroMemory(&bInfo, sizeof(BINDINFO));

    // all we need is size and verb field
    bInfo.cbSize = sizeof(BINDINFO);
    bInfo.dwBindVerb = BINDVERB_GET;

    // src -> dest 
    hr = CopyBindInfo(&bInfo, pbindinfo );

    return hr;
}


HRESULT
COInetProtocolHook::GetBindString(
    ULONG ulStringType,
    LPOLESTR *ppwzStr,
    ULONG cEl,
    ULONG *pcElFetched
)
{

    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    switch (ulStringType)
    {
    case BINDSTRING_HEADERS     :
    case BINDSTRING_EXTRA_URL   :
    case BINDSTRING_LANGUAGE    :
    case BINDSTRING_USERNAME    :
    case BINDSTRING_PASSWORD    :
    case BINDSTRING_ACCEPT_ENCODINGS:
    case BINDSTRING_URL:
    case BINDSTRING_USER_AGENT  :
    case BINDSTRING_POST_COOKIE :
    case BINDSTRING_POST_DATA_MIME:
        break;

    default:
        break; 
    }

    return hr;
}


HRESULT
COInetProtocolHook::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void    **ppvObj 
)
{
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = NULL;

    if (guidService == IID_IHttpNegotiate) {
        *ppvObj = static_cast<IHttpNegotiate *>(this);
    }
    else if (guidService == IID_IAuthenticate) {
        *ppvObj = static_cast<IAuthenticate *>(this);
    }
   
    if( *ppvObj )
    {
        AddRef();
        hr = NOERROR;
    } 
    
    
    return hr;
}


HRESULT
COInetProtocolHook::BeginningTransaction(
    LPCWSTR szURL,
    LPCWSTR szHeaders,
    DWORD   dwReserved,
    LPWSTR  *pszAdditionalHeaders
)
{
    *pszAdditionalHeaders = NULL;
    return NOERROR;
}

HRESULT
COInetProtocolHook::OnResponse(
    DWORD    dwResponseCode,
    LPCWSTR  szResponseHeaders,
    LPCWSTR  szRequestHeaders,
    LPWSTR   *pszAdditionalHeaders
)
{
    HRESULT                      hr = S_OK;
    IWinInetHttpInfo            *pHttpInfo = NULL;

    _hrResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);


    switch (dwResponseCode) {
        case HTTP_RESPONSE_OK:
            if (_pProt->QueryInterface(IID_IWinInetHttpInfo, (void **)&pHttpInfo) == S_OK) {
                char          szHttpDate[INTERNET_RFC1123_BUFSIZE + 1];
                SYSTEMTIME    sysTime;
                DWORD         cbLen;

                cbLen = INTERNET_RFC1123_BUFSIZE + 1;
                if (pHttpInfo->QueryInfo(HTTP_QUERY_LAST_MODIFIED, (LPVOID)szHttpDate,
                                         &cbLen, NULL, 0) == S_OK) {
                    if (InternetTimeToSystemTimeA(szHttpDate, &sysTime, 0)) {
                        SystemTimeToFileTime(&sysTime, &_ftHttpLastMod);
                    }
                }

                SAFERELEASE(pHttpInfo);
            }

            _hrResult = S_OK;
            break;

        case HTTP_RESPONSE_UNAUTHORIZED:
        case HTTP_RESPONSE_FORBIDDEN:
            _hrResult = E_ACCESSDENIED;
            _bSelfAborted = TRUE;
            hr = E_ABORT;
            break;
            
        case HTTP_RESPONSE_FILE_NOT_FOUND:
            _bSelfAborted = TRUE;
            hr = E_ABORT;
            break;
    }
    
    return hr;
}

HRESULT COInetProtocolHook::Authenticate(HWND *phwnd, LPWSTR *ppwzUsername,
                                         LPWSTR *ppwzPassword)
{
    // BUGBUG: In the future, we should delegate the QueryService back to
    // the caller, so they can do the authentication.

    *phwnd = GetDesktopWindow();
    *ppwzUsername = NULL;
    *ppwzPassword = NULL;

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\download\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Danpo Zhang

!ENDIF

MAJORCOMP=fusion
MINORCOMP=download

TARGETNAME=urtdl

TARGETTYPE=LIBRARY
TARGETPATHLIB=$(FUSION_LIB_DEST)

SOURCES= \
    adl.cpp     \
    adlmgr.cpp  \
    mdlmgr.cpp  \
    cblist.cpp  \
    clbind.cpp  \
    cfgdl.cpp   \
    dl.cpp \
    extract.cpp \
    hashnode.cpp

SOURCES_USED=sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\external\inc\urlmon.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef FUSION_CODE_DOWNLOAD_ENABLED

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for urlmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlmon_h__
#define __urlmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistMoniker_FWD_DEFINED__
#define __IPersistMoniker_FWD_DEFINED__
typedef interface IPersistMoniker IPersistMoniker;
#endif  /* __IPersistMoniker_FWD_DEFINED__ */


#ifndef __IMonikerProp_FWD_DEFINED__
#define __IMonikerProp_FWD_DEFINED__
typedef interface IMonikerProp IMonikerProp;
#endif  /* __IMonikerProp_FWD_DEFINED__ */


#ifndef __IBindProtocol_FWD_DEFINED__
#define __IBindProtocol_FWD_DEFINED__
typedef interface IBindProtocol IBindProtocol;
#endif  /* __IBindProtocol_FWD_DEFINED__ */


#ifndef __IBinding_FWD_DEFINED__
#define __IBinding_FWD_DEFINED__
typedef interface IBinding IBinding;
#endif  /* __IBinding_FWD_DEFINED__ */


#ifndef __IBindStatusCallback_FWD_DEFINED__
#define __IBindStatusCallback_FWD_DEFINED__
typedef interface IBindStatusCallback IBindStatusCallback;
#endif  /* __IBindStatusCallback_FWD_DEFINED__ */


#ifndef __IAuthenticate_FWD_DEFINED__
#define __IAuthenticate_FWD_DEFINED__
typedef interface IAuthenticate IAuthenticate;
#endif  /* __IAuthenticate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate_FWD_DEFINED__
#define __IHttpNegotiate_FWD_DEFINED__
typedef interface IHttpNegotiate IHttpNegotiate;
#endif  /* __IHttpNegotiate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate2_FWD_DEFINED__
#define __IHttpNegotiate2_FWD_DEFINED__
typedef interface IHttpNegotiate2 IHttpNegotiate2;
#endif  /* __IHttpNegotiate2_FWD_DEFINED__ */


#ifndef __IWindowForBindingUI_FWD_DEFINED__
#define __IWindowForBindingUI_FWD_DEFINED__
typedef interface IWindowForBindingUI IWindowForBindingUI;
#endif  /* __IWindowForBindingUI_FWD_DEFINED__ */


#ifndef __ICodeInstall_FWD_DEFINED__
#define __ICodeInstall_FWD_DEFINED__
typedef interface ICodeInstall ICodeInstall;
#endif  /* __ICodeInstall_FWD_DEFINED__ */


#ifndef __IWinInetInfo_FWD_DEFINED__
#define __IWinInetInfo_FWD_DEFINED__
typedef interface IWinInetInfo IWinInetInfo;
#endif  /* __IWinInetInfo_FWD_DEFINED__ */


#ifndef __IHttpSecurity_FWD_DEFINED__
#define __IHttpSecurity_FWD_DEFINED__
typedef interface IHttpSecurity IHttpSecurity;
#endif  /* __IHttpSecurity_FWD_DEFINED__ */


#ifndef __IWinInetHttpInfo_FWD_DEFINED__
#define __IWinInetHttpInfo_FWD_DEFINED__
typedef interface IWinInetHttpInfo IWinInetHttpInfo;
#endif  /* __IWinInetHttpInfo_FWD_DEFINED__ */


#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif  /* __IBindHost_FWD_DEFINED__ */


#ifndef __IInternet_FWD_DEFINED__
#define __IInternet_FWD_DEFINED__
typedef interface IInternet IInternet;
#endif  /* __IInternet_FWD_DEFINED__ */


#ifndef __IInternetBindInfo_FWD_DEFINED__
#define __IInternetBindInfo_FWD_DEFINED__
typedef interface IInternetBindInfo IInternetBindInfo;
#endif  /* __IInternetBindInfo_FWD_DEFINED__ */


#ifndef __IInternetProtocolRoot_FWD_DEFINED__
#define __IInternetProtocolRoot_FWD_DEFINED__
typedef interface IInternetProtocolRoot IInternetProtocolRoot;
#endif  /* __IInternetProtocolRoot_FWD_DEFINED__ */


#ifndef __IInternetProtocol_FWD_DEFINED__
#define __IInternetProtocol_FWD_DEFINED__
typedef interface IInternetProtocol IInternetProtocol;
#endif  /* __IInternetProtocol_FWD_DEFINED__ */


#ifndef __IInternetProtocolSink_FWD_DEFINED__
#define __IInternetProtocolSink_FWD_DEFINED__
typedef interface IInternetProtocolSink IInternetProtocolSink;
#endif  /* __IInternetProtocolSink_FWD_DEFINED__ */


#ifndef __IInternetProtocolSinkStackable_FWD_DEFINED__
#define __IInternetProtocolSinkStackable_FWD_DEFINED__
typedef interface IInternetProtocolSinkStackable IInternetProtocolSinkStackable;
#endif  /* __IInternetProtocolSinkStackable_FWD_DEFINED__ */


#ifndef __IInternetSession_FWD_DEFINED__
#define __IInternetSession_FWD_DEFINED__
typedef interface IInternetSession IInternetSession;
#endif  /* __IInternetSession_FWD_DEFINED__ */


#ifndef __IInternetThreadSwitch_FWD_DEFINED__
#define __IInternetThreadSwitch_FWD_DEFINED__
typedef interface IInternetThreadSwitch IInternetThreadSwitch;
#endif  /* __IInternetThreadSwitch_FWD_DEFINED__ */


#ifndef __IInternetPriority_FWD_DEFINED__
#define __IInternetPriority_FWD_DEFINED__
typedef interface IInternetPriority IInternetPriority;
#endif  /* __IInternetPriority_FWD_DEFINED__ */


#ifndef __IInternetProtocolInfo_FWD_DEFINED__
#define __IInternetProtocolInfo_FWD_DEFINED__
typedef interface IInternetProtocolInfo IInternetProtocolInfo;
#endif  /* __IInternetProtocolInfo_FWD_DEFINED__ */


#ifndef __IInternetSecurityMgrSite_FWD_DEFINED__
#define __IInternetSecurityMgrSite_FWD_DEFINED__
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
#endif  /* __IInternetSecurityMgrSite_FWD_DEFINED__ */


#ifndef __IInternetSecurityManager_FWD_DEFINED__
#define __IInternetSecurityManager_FWD_DEFINED__
typedef interface IInternetSecurityManager IInternetSecurityManager;
#endif  /* __IInternetSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetHostSecurityManager_FWD_DEFINED__
#define __IInternetHostSecurityManager_FWD_DEFINED__
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif  /* __IInternetHostSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManager_FWD_DEFINED__
#define __IInternetZoneManager_FWD_DEFINED__
typedef interface IInternetZoneManager IInternetZoneManager;
#endif  /* __IInternetZoneManager_FWD_DEFINED__ */


#ifndef __ISoftDistExt_FWD_DEFINED__
#define __ISoftDistExt_FWD_DEFINED__
typedef interface ISoftDistExt ISoftDistExt;
#endif  /* __ISoftDistExt_FWD_DEFINED__ */


#ifndef __ICatalogFileInfo_FWD_DEFINED__
#define __ICatalogFileInfo_FWD_DEFINED__
typedef interface ICatalogFileInfo ICatalogFileInfo;
#endif  /* __ICatalogFileInfo_FWD_DEFINED__ */


#ifndef __IDataFilter_FWD_DEFINED__
#define __IDataFilter_FWD_DEFINED__
typedef interface IDataFilter IDataFilter;
#endif  /* __IDataFilter_FWD_DEFINED__ */


#ifndef __IEncodingFilterFactory_FWD_DEFINED__
#define __IEncodingFilterFactory_FWD_DEFINED__
typedef interface IEncodingFilterFactory IEncodingFilterFactory;
#endif  /* __IEncodingFilterFactory_FWD_DEFINED__ */


#ifndef __IWrappedProtocol_FWD_DEFINED__
#define __IWrappedProtocol_FWD_DEFINED__
typedef interface IWrappedProtocol IWrappedProtocol;
#endif  /* __IWrappedProtocol_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "servprov.h"
#include "msxml.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_urlmon_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// UrlMon.h
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// URL Moniker Interfaces.











// Side-by-Side clsid
EXTERN_C const IID CLSID_SBS_StdURLMoniker;  
EXTERN_C const IID CLSID_SBS_HttpProtocol;   
EXTERN_C const IID CLSID_SBS_FtpProtocol;    
EXTERN_C const IID CLSID_SBS_GopherProtocol; 
EXTERN_C const IID CLSID_SBS_HttpSProtocol;  
EXTERN_C const IID CLSID_SBS_FileProtocol;   
EXTERN_C const IID CLSID_SBS_MkProtocol;     
EXTERN_C const IID CLSID_SBS_UrlMkBindCtx;   
EXTERN_C const IID CLSID_SBS_SoftDistExt;  
EXTERN_C const IID CLSID_SBS_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_SBS_DeCompMimeFilter;     
EXTERN_C const IID CLSID_SBS_CdlProtocol;          
EXTERN_C const IID CLSID_SBS_ClassInstallFilter;   
EXTERN_C const IID CLSID_SBS_InternetSecurityManager;  
EXTERN_C const IID CLSID_SBS_InternetZoneManager;  
// END Side-by-Side clsid
// These are for backwards compatibility with previous URLMON versions
#define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION
#define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE
#define BINDF_NOCOPYDATA BINDF_PULLDATA
#define INVALID_P_ROOT_SECURITY_ID ((BYTE*)-1)
#define PI_DOCFILECLSIDLOOKUP PI_CLSIDLOOKUP
EXTERN_C const IID IID_IAsyncMoniker;    
EXTERN_C const IID CLSID_StdURLMoniker;  
EXTERN_C const IID CLSID_HttpProtocol;   
EXTERN_C const IID CLSID_FtpProtocol;    
EXTERN_C const IID CLSID_GopherProtocol; 
EXTERN_C const IID CLSID_HttpSProtocol;  
EXTERN_C const IID CLSID_FileProtocol;   
EXTERN_C const IID CLSID_MkProtocol;     
EXTERN_C const IID CLSID_StdURLProtocol; 
EXTERN_C const IID CLSID_UrlMkBindCtx;   
EXTERN_C const IID CLSID_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_DeCompMimeFilter;     
EXTERN_C const IID CLSID_CdlProtocol;          
EXTERN_C const IID CLSID_ClassInstallFilter;   
EXTERN_C const IID IID_IAsyncBindCtx;    
 
#define SZ_URLCONTEXT           OLESTR("URL Context")
#define SZ_ASYNC_CALLEE         OLESTR("AsyncCallee")
#define MKSYS_URLMONIKER         6            
#define URL_MK_LEGACY            0            
#define URL_MK_UNIFORM           1            
#define URL_MK_NO_CANONICALIZE   2            
 
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
STDAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk, DWORD dwFlags);             
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID);                                           
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved);                                                     
STDAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk);                                           
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);                      
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid); 
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);                               
STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv);
STDAPI FaultInIEFeature( HWND hWnd,
            uCLSSPEC *pClassSpec,
            QUERYCONTEXT *pQuery, DWORD dwFlags);                                           
STDAPI GetComponentIDFromCLSSPEC(uCLSSPEC *pClassspec,
             LPSTR * ppszComponentID);                                                      
// flags for FaultInIEFeature
#define FIEF_FLAG_FORCE_JITUI               0x1     // force JIT ui even if
                                                 // previoulsy rejected by 
                                                 // user in this session or
                                                 // marked as Never Ask Again
#define FIEF_FLAG_PEEK                      0x2     // just peek, don't faultin
#define FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK        0x4     // force JIT without checking local version
 
//helper apis                                                                               
STDAPI IsAsyncMoniker(IMoniker* pmk);                                                       
STDAPI CreateURLBinding(LPCWSTR lpszUrl, IBindCtx *pbc, IBinding **ppBdg);                  
 
STDAPI RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);            
STDAPI FindMediaType(LPCSTR rgszTypes, CLIPFORMAT* rgcfTypes);                                       
STDAPI CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc); 
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc);                            
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved);    
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID *pclsID, DWORD reserved);                          
STDAPI UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved);       
STDAPI UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD *pdwBufferLength, DWORD dwReserved);       
STDAPI FindMimeFromData(                                                                                                                  
                        LPBC pBC,                           // bind context - can be NULL                                                 
                        LPCWSTR pwzUrl,                     // url - can be null                                                          
                        LPVOID pBuffer,                     // buffer with data to sniff - can be null (pwzUrl must be valid)             
                        DWORD cbSize,                       // size of buffer                                                             
                        LPCWSTR pwzMimeProposed,            // proposed mime if - can be null                                             
                        DWORD dwMimeFlags,                  // will be defined                                                            
                        LPWSTR *ppwzMimeOut,                // the suggested mime                                                         
                        DWORD dwReserved);                  // must be 0                                                                  
#define     FMFD_DEFAULT        0x00000000 
#define     FMFD_URLASFILENAME  0x00000001 
STDAPI ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize);       
STDAPI CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved);    
 
// URLMON-specific defines for UrlMkSetSessionOption() above
#define URLMON_OPTION_USERAGENT  0x10000001
#define URLMON_OPTION_USERAGENT_REFRESH  0x10000002
#define URLMON_OPTION_URL_ENCODING       0x10000004
 
#define CF_NULL                 0                                  
#define CFSTR_MIME_NULL         NULL                               
#define CFSTR_MIME_TEXT         (TEXT("text/plain"))             
#define CFSTR_MIME_RICHTEXT     (TEXT("text/richtext"))          
#define CFSTR_MIME_X_BITMAP     (TEXT("image/x-xbitmap"))        
#define CFSTR_MIME_POSTSCRIPT   (TEXT("application/postscript")) 
#define CFSTR_MIME_AIFF         (TEXT("audio/aiff"))             
#define CFSTR_MIME_BASICAUDIO   (TEXT("audio/basic"))            
#define CFSTR_MIME_WAV          (TEXT("audio/wav"))              
#define CFSTR_MIME_X_WAV        (TEXT("audio/x-wav"))            
#define CFSTR_MIME_GIF          (TEXT("image/gif"))              
#define CFSTR_MIME_PJPEG        (TEXT("image/pjpeg"))            
#define CFSTR_MIME_JPEG         (TEXT("image/jpeg"))             
#define CFSTR_MIME_TIFF         (TEXT("image/tiff"))             
#define CFSTR_MIME_X_PNG        (TEXT("image/x-png"))            
#define CFSTR_MIME_BMP          (TEXT("image/bmp"))              
#define CFSTR_MIME_X_ART        (TEXT("image/x-jg"))             
#define CFSTR_MIME_X_EMF        (TEXT("image/x-emf"))            
#define CFSTR_MIME_X_WMF        (TEXT("image/x-wmf"))            
#define CFSTR_MIME_AVI          (TEXT("video/avi"))              
#define CFSTR_MIME_MPEG         (TEXT("video/mpeg"))             
#define CFSTR_MIME_FRACTALS     (TEXT("application/fractals"))   
#define CFSTR_MIME_RAWDATA      (TEXT("application/octet-stream"))
#define CFSTR_MIME_RAWDATASTRM  (TEXT("application/octet-stream"))
#define CFSTR_MIME_PDF          (TEXT("application/pdf"))        
#define CFSTR_MIME_HTA          (TEXT("application/hta"))        
#define CFSTR_MIME_X_AIFF       (TEXT("audio/x-aiff"))           
#define CFSTR_MIME_X_REALAUDIO  (TEXT("audio/x-pn-realaudio"))   
#define CFSTR_MIME_XBM          (TEXT("image/xbm"))              
#define CFSTR_MIME_QUICKTIME    (TEXT("video/quicktime"))        
#define CFSTR_MIME_X_MSVIDEO    (TEXT("video/x-msvideo"))        
#define CFSTR_MIME_X_SGI_MOVIE  (TEXT("video/x-sgi-movie"))      
#define CFSTR_MIME_HTML         (TEXT("text/html"))              
#define CFSTR_MIME_XML          (TEXT("text/xml"))               
 
// MessageId: MK_S_ASYNCHRONOUS                                              
// MessageText: Operation is successful, but will complete asynchronously.   
//                                                                           
#define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                  
#ifndef S_ASYNCHRONOUS                                                       
#define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                               
#endif                                                                       
                                                                             
#ifndef E_PENDING                                                            
#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                             
#endif                                                                       
                                                                             
//                                                                           
//                                                                           
// WinINet and protocol specific errors are mapped to one of the following   
// error which are returned in IBSC::OnStopBinding                           
//                                                                           
//                                                                           
// Note: FACILITY C is split into ranges of 1k                               
// C0000 - C03FF  INET_E_ (URLMON's original hresult)                        
// C0400 - C07FF  INET_E_CLIENT_xxx                                          
// C0800 - C0BFF  INET_E_SERVER_xxx                                          
// C0C00 - C0FFF  INET_E_????                                                
// C1000 - C13FF  INET_E_AGENT_xxx (info delivery agents)                    
#define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)      
#define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)      
#define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)      
#define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)      
#define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)      
#define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)      
#define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)      
#define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)      
#define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)      
#define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)      
#define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)      
#define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)      
#define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)      
#define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)      
#define INET_E_REDIRECT_FAILED           _HRESULT_TYPEDEF_(0x800C0014L)      
#define INET_E_REDIRECT_TO_DIR           _HRESULT_TYPEDEF_(0x800C0015L)      
#define INET_E_CANNOT_LOCK_REQUEST       _HRESULT_TYPEDEF_(0x800C0016L)      
#define INET_E_USE_EXTEND_BINDING        _HRESULT_TYPEDEF_(0x800C0017L)      
#define INET_E_TERMINATED_BIND           _HRESULT_TYPEDEF_(0x800C0018L)      
#define INET_E_ERROR_FIRST               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_ERROR_LAST                INET_E_USE_EXTEND_BINDING
#define INET_E_CODE_DOWNLOAD_DECLINED    _HRESULT_TYPEDEF_(0x800C0100L)      
#define INET_E_RESULT_DISPATCHED         _HRESULT_TYPEDEF_(0x800C0200L)      
#define INET_E_CANNOT_REPLACE_SFP_FILE   _HRESULT_TYPEDEF_(0x800C0300L)      
#ifndef _LPPERSISTMONIKER_DEFINED
#define _LPPERSISTMONIKER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_v0_0_s_ifspec;

#ifndef __IPersistMoniker_INTERFACE_DEFINED__
#define __IPersistMoniker_INTERFACE_DEFINED__

/* interface IPersistMoniker */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPersistMoniker *LPPERSISTMONIKER;


EXTERN_C const IID IID_IPersistMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c9-baf9-11ce-8c82-00aa004ba90b")
    IPersistMoniker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ CLSID *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pbc,
            /* [in] */ BOOL fRemember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCompleted( 
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurMoniker( 
            /* [out] */ IMoniker **ppimkName) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IPersistMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistMoniker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistMoniker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistMoniker * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistMoniker * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistMoniker * This,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pbc,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( STDMETHODCALLTYPE *SaveCompleted )( 
            IPersistMoniker * This,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurMoniker )( 
            IPersistMoniker * This,
            /* [out] */ IMoniker **ppimkName);
        
        END_INTERFACE
    } IPersistMonikerVtbl;

    interface IPersistMoniker
    {
        CONST_VTBL struct IPersistMonikerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMoniker_QueryInterface(This,riid,ppvObject)     \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistMoniker_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPersistMoniker_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPersistMoniker_GetClassID(This,pClassID)       \
    (This)->lpVtbl -> GetClassID(This,pClassID)

#define IPersistMoniker_IsDirty(This)   \
    (This)->lpVtbl -> IsDirty(This)

#define IPersistMoniker_Load(This,fFullyAvailable,pimkName,pibc,grfMode)        \
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IPersistMoniker_Save(This,pimkName,pbc,fRemember)       \
    (This)->lpVtbl -> Save(This,pimkName,pbc,fRemember)

#define IPersistMoniker_SaveCompleted(This,pimkName,pibc)       \
    (This)->lpVtbl -> SaveCompleted(This,pimkName,pibc)

#define IPersistMoniker_GetCurMoniker(This,ppimkName)   \
    (This)->lpVtbl -> GetCurMoniker(This,ppimkName)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPersistMoniker_GetClassID_Proxy( 
    IPersistMoniker * This,
    /* [out] */ CLSID *pClassID);


void __RPC_STUB IPersistMoniker_GetClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_IsDirty_Proxy( 
    IPersistMoniker * This);


void __RPC_STUB IPersistMoniker_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_Load_Proxy( 
    IPersistMoniker * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IPersistMoniker_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_Save_Proxy( 
    IPersistMoniker * This,
    /* [in] */ IMoniker *pimkName,
    /* [in] */ LPBC pbc,
    /* [in] */ BOOL fRemember);


void __RPC_STUB IPersistMoniker_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_SaveCompleted_Proxy( 
    IPersistMoniker * This,
    /* [in] */ IMoniker *pimkName,
    /* [in] */ LPBC pibc);


void __RPC_STUB IPersistMoniker_SaveCompleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistMoniker_GetCurMoniker_Proxy( 
    IPersistMoniker * This,
    /* [out] */ IMoniker **ppimkName);


void __RPC_STUB IPersistMoniker_GetCurMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPersistMoniker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0171 */
/* [local] */ 

#endif
#ifndef _LPMONIKERPROP_DEFINED
#define _LPMONIKERPROP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0171_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0171_v0_0_s_ifspec;

#ifndef __IMonikerProp_INTERFACE_DEFINED__
#define __IMonikerProp_INTERFACE_DEFINED__

/* interface IMonikerProp */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IMonikerProp *LPMONIKERPROP;

typedef /* [public][public] */ 
enum __MIDL_IMonikerProp_0001
    {   MIMETYPEPROP    = 0
    }   MONIKERPROPERTY;


EXTERN_C const IID IID_IMonikerProp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a5ca5f7f-1847-4d87-9c5b-918509f7511d")
    IMonikerProp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ LPCWSTR val) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IMonikerPropVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMonikerProp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMonikerProp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMonikerProp * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutProperty )( 
            IMonikerProp * This,
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ LPCWSTR val);
        
        END_INTERFACE
    } IMonikerPropVtbl;

    interface IMonikerProp
    {
        CONST_VTBL struct IMonikerPropVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonikerProp_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMonikerProp_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define IMonikerProp_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define IMonikerProp_PutProperty(This,mkp,val)  \
    (This)->lpVtbl -> PutProperty(This,mkp,val)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IMonikerProp_PutProperty_Proxy( 
    IMonikerProp * This,
    /* [in] */ MONIKERPROPERTY mkp,
    /* [in] */ LPCWSTR val);


void __RPC_STUB IMonikerProp_PutProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IMonikerProp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0172 */
/* [local] */ 

#endif
#ifndef _LPBINDPROTOCOL_DEFINED
#define _LPBINDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0172_v0_0_s_ifspec;

#ifndef __IBindProtocol_INTERFACE_DEFINED__
#define __IBindProtocol_INTERFACE_DEFINED__

/* interface IBindProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IBindProtocol *LPBINDPROTOCOL;


EXTERN_C const IID IID_IBindProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9cd-baf9-11ce-8c82-00aa004ba90b")
    IBindProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IBindProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IBindProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb);
        
        END_INTERFACE
    } IBindProtocolVtbl;

    interface IBindProtocol
    {
        CONST_VTBL struct IBindProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindProtocol_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindProtocol_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IBindProtocol_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IBindProtocol_CreateBinding(This,szUrl,pbc,ppb) \
    (This)->lpVtbl -> CreateBinding(This,szUrl,pbc,ppb)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IBindProtocol_CreateBinding_Proxy( 
    IBindProtocol * This,
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IBindCtx *pbc,
    /* [out] */ IBinding **ppb);


void __RPC_STUB IBindProtocol_CreateBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IBindProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0173 */
/* [local] */ 

#endif
#ifndef _LPBINDING_DEFINED
#define _LPBINDING_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0173_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0173_v0_0_s_ifspec;

#ifndef __IBinding_INTERFACE_DEFINED__
#define __IBinding_INTERFACE_DEFINED__

/* interface IBinding */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBinding *LPBINDING;


EXTERN_C const IID IID_IBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c0-baf9-11ce-8c82-00aa004ba90b")
    IBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindResult( 
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [out] */ LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IBinding * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBinding * This,
            /* [out] */ LONG *pnPriority);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindResult )( 
            IBinding * This,
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [out] */ LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IBindingVtbl;

    interface IBinding
    {
        CONST_VTBL struct IBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBinding_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBinding_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IBinding_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IBinding_Abort(This)    \
    (This)->lpVtbl -> Abort(This)

#define IBinding_Suspend(This)  \
    (This)->lpVtbl -> Suspend(This)

#define IBinding_Resume(This)   \
    (This)->lpVtbl -> Resume(This)

#define IBinding_SetPriority(This,nPriority)    \
    (This)->lpVtbl -> SetPriority(This,nPriority)

#define IBinding_GetPriority(This,pnPriority)   \
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#define IBinding_GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)     \
    (This)->lpVtbl -> GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IBinding_Abort_Proxy( 
    IBinding * This);


void __RPC_STUB IBinding_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_Suspend_Proxy( 
    IBinding * This);


void __RPC_STUB IBinding_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_Resume_Proxy( 
    IBinding * This);


void __RPC_STUB IBinding_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_SetPriority_Proxy( 
    IBinding * This,
    /* [in] */ LONG nPriority);


void __RPC_STUB IBinding_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBinding_GetPriority_Proxy( 
    IBinding * This,
    /* [out] */ LONG *pnPriority);


void __RPC_STUB IBinding_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_RemoteGetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IBinding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0174 */
/* [local] */ 

#endif
#ifndef _LPBINDSTATUSCALLBACK_DEFINED
#define _LPBINDSTATUSCALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0174_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0174_v0_0_s_ifspec;

#ifndef __IBindStatusCallback_INTERFACE_DEFINED__
#define __IBindStatusCallback_INTERFACE_DEFINED__

/* interface IBindStatusCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBindStatusCallback *LPBINDSTATUSCALLBACK;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0001
    {   BINDVERB_GET    = 0,
        BINDVERB_POST   = 0x1,
        BINDVERB_PUT    = 0x2,
        BINDVERB_CUSTOM = 0x3
    }   BINDVERB;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0002
    {   BINDINFOF_URLENCODESTGMEDDATA   = 0x1,
        BINDINFOF_URLENCODEDEXTRAINFO   = 0x2
    }   BINDINFOF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0003
    {   BINDF_ASYNCHRONOUS      = 0x1,
        BINDF_ASYNCSTORAGE      = 0x2,
        BINDF_NOPROGRESSIVERENDERING    = 0x4,
        BINDF_OFFLINEOPERATION  = 0x8,
        BINDF_GETNEWESTVERSION  = 0x10,
        BINDF_NOWRITECACHE      = 0x20,
        BINDF_NEEDFILE  = 0x40,
        BINDF_PULLDATA  = 0x80,
        BINDF_IGNORESECURITYPROBLEM     = 0x100,
        BINDF_RESYNCHRONIZE     = 0x200,
        BINDF_HYPERLINK = 0x400,
        BINDF_NO_UI     = 0x800,
        BINDF_SILENTOPERATION   = 0x1000,
        BINDF_PRAGMA_NO_CACHE   = 0x2000,
        BINDF_GETCLASSOBJECT    = 0x4000,
        BINDF_RESERVED_1        = 0x8000,
        BINDF_FREE_THREADED     = 0x10000,
        BINDF_DIRECT_READ       = 0x20000,
        BINDF_FORMS_SUBMIT      = 0x40000,
        BINDF_GETFROMCACHE_IF_NET_FAIL  = 0x80000,
        BINDF_FROMURLMON        = 0x100000,
        BINDF_FWD_BACK  = 0x200000,
        BINDF_PREFERDEFAULTHANDLER      = 0x400000,
        BINDF_ENFORCERESTRICTED = 0x800000
    }   BINDF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0004
    {   URL_ENCODING_NONE       = 0,
        URL_ENCODING_ENABLE_UTF8        = 0x10000000,
        URL_ENCODING_DISABLE_UTF8       = 0x20000000
    }   URL_ENCODING;

typedef struct _tagBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    }   BINDINFO;

typedef struct _REMSECURITY_ATTRIBUTES
    {
    DWORD nLength;
    DWORD lpSecurityDescriptor;
    BOOL bInheritHandle;
    }   REMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *PREMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *LPREMSECURITY_ATTRIBUTES;

typedef struct _tagRemBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    REMSECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    }   RemBINDINFO;

typedef struct tagRemFORMATETC
    {
    DWORD cfFormat;
    DWORD ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    }   RemFORMATETC;

typedef struct tagRemFORMATETC *LPREMFORMATETC;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0005
    {   BINDINFO_OPTIONS_WININETFLAG    = 0x10000,
        BINDINFO_OPTIONS_ENABLE_UTF8    = 0x20000,
        BINDINFO_OPTIONS_DISABLE_UTF8   = 0x40000,
        BINDINFO_OPTIONS_USE_IE_ENCODING        = 0x80000,
        BINDINFO_OPTIONS_BINDTOOBJECT   = 0x100000
    }   BINDINFO_OPTIONS;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0006
    {   BSCF_FIRSTDATANOTIFICATION      = 0x1,
        BSCF_INTERMEDIATEDATANOTIFICATION       = 0x2,
        BSCF_LASTDATANOTIFICATION       = 0x4,
        BSCF_DATAFULLYAVAILABLE = 0x8,
        BSCF_AVAILABLEDATASIZEUNKNOWN   = 0x10
    }   BSCF;

typedef 
enum tagBINDSTATUS
    {   BINDSTATUS_FINDINGRESOURCE      = 1,
        BINDSTATUS_CONNECTING   = BINDSTATUS_FINDINGRESOURCE + 1,
        BINDSTATUS_REDIRECTING  = BINDSTATUS_CONNECTING + 1,
        BINDSTATUS_BEGINDOWNLOADDATA    = BINDSTATUS_REDIRECTING + 1,
        BINDSTATUS_DOWNLOADINGDATA      = BINDSTATUS_BEGINDOWNLOADDATA + 1,
        BINDSTATUS_ENDDOWNLOADDATA      = BINDSTATUS_DOWNLOADINGDATA + 1,
        BINDSTATUS_BEGINDOWNLOADCOMPONENTS      = BINDSTATUS_ENDDOWNLOADDATA + 1,
        BINDSTATUS_INSTALLINGCOMPONENTS = BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1,
        BINDSTATUS_ENDDOWNLOADCOMPONENTS        = BINDSTATUS_INSTALLINGCOMPONENTS + 1,
        BINDSTATUS_USINGCACHEDCOPY      = BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1,
        BINDSTATUS_SENDINGREQUEST       = BINDSTATUS_USINGCACHEDCOPY + 1,
        BINDSTATUS_CLASSIDAVAILABLE     = BINDSTATUS_SENDINGREQUEST + 1,
        BINDSTATUS_MIMETYPEAVAILABLE    = BINDSTATUS_CLASSIDAVAILABLE + 1,
        BINDSTATUS_CACHEFILENAMEAVAILABLE       = BINDSTATUS_MIMETYPEAVAILABLE + 1,
        BINDSTATUS_BEGINSYNCOPERATION   = BINDSTATUS_CACHEFILENAMEAVAILABLE + 1,
        BINDSTATUS_ENDSYNCOPERATION     = BINDSTATUS_BEGINSYNCOPERATION + 1,
        BINDSTATUS_BEGINUPLOADDATA      = BINDSTATUS_ENDSYNCOPERATION + 1,
        BINDSTATUS_UPLOADINGDATA        = BINDSTATUS_BEGINUPLOADDATA + 1,
        BINDSTATUS_ENDUPLOADDATA        = BINDSTATUS_UPLOADINGDATA + 1,
        BINDSTATUS_PROTOCOLCLASSID      = BINDSTATUS_ENDUPLOADDATA + 1,
        BINDSTATUS_ENCODING     = BINDSTATUS_PROTOCOLCLASSID + 1,
        BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE    = BINDSTATUS_ENCODING + 1,
        BINDSTATUS_CLASSINSTALLLOCATION = BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE + 1,
        BINDSTATUS_DECODING     = BINDSTATUS_CLASSINSTALLLOCATION + 1,
        BINDSTATUS_LOADINGMIMEHANDLER   = BINDSTATUS_DECODING + 1,
        BINDSTATUS_CONTENTDISPOSITIONATTACH     = BINDSTATUS_LOADINGMIMEHANDLER + 1,
        BINDSTATUS_FILTERREPORTMIMETYPE = BINDSTATUS_CONTENTDISPOSITIONATTACH + 1,
        BINDSTATUS_CLSIDCANINSTANTIATE  = BINDSTATUS_FILTERREPORTMIMETYPE + 1,
        BINDSTATUS_IUNKNOWNAVAILABLE    = BINDSTATUS_CLSIDCANINSTANTIATE + 1,
        BINDSTATUS_DIRECTBIND   = BINDSTATUS_IUNKNOWNAVAILABLE + 1,
        BINDSTATUS_RAWMIMETYPE  = BINDSTATUS_DIRECTBIND + 1,
        BINDSTATUS_PROXYDETECTING       = BINDSTATUS_RAWMIMETYPE + 1,
        BINDSTATUS_ACCEPTRANGES = BINDSTATUS_PROXYDETECTING + 1,
        BINDSTATUS_COOKIE_SENT  = BINDSTATUS_ACCEPTRANGES + 1,
        BINDSTATUS_COOKIE_RECEIVED      = BINDSTATUS_COOKIE_SENT + 1,
        BINDSTATUS_COOKIE_SUPPRESSED    = BINDSTATUS_COOKIE_RECEIVED + 1,
        BINDSTATUS_COOKIE_STATE_UNKNOWN = BINDSTATUS_COOKIE_SUPPRESSED + 1,
        BINDSTATUS_COOKIE_STATE_ACCEPT  = BINDSTATUS_COOKIE_STATE_UNKNOWN + 1,
        BINDSTATUS_COOKIE_STATE_REJECT  = BINDSTATUS_COOKIE_STATE_ACCEPT + 1,
        BINDSTATUS_COOKIE_STATE_PROMPT  = BINDSTATUS_COOKIE_STATE_REJECT + 1,
        BINDSTATUS_COOKIE_STATE_LEASH   = BINDSTATUS_COOKIE_STATE_PROMPT + 1,
        BINDSTATUS_COOKIE_STATE_DOWNGRADE       = BINDSTATUS_COOKIE_STATE_LEASH + 1,
        BINDSTATUS_PRIVACY_IMPACTED     = BINDSTATUS_COOKIE_STATE_DOWNGRADE + 1,
        BINDSTATUS_POLICY_HREF  = BINDSTATUS_PRIVACY_IMPACTED + 1,
        BINDSTATUS_COOKIE_STATE_NO_POLICY       = BINDSTATUS_POLICY_HREF + 1,
        BINDSTATUS_COOKIE_STATE_POLICY_ERROR    = BINDSTATUS_COOKIE_STATE_NO_POLICY + 1,
        BINDSTATUS_COOKIE_STATE_EVAL_ERROR      = BINDSTATUS_COOKIE_STATE_POLICY_ERROR + 1
    }   BINDSTATUS;


EXTERN_C const IID IID_IBindStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c1-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartBinding( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding *pib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DWORD reserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStopBinding( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnDataAvailable( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectAvailable( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IBindStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartBinding )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding *pib);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IBindStatusCallback * This,
            /* [out] */ LONG *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE *OnLowResource )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IBindStatusCallback * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *OnStopBinding )( 
            IBindStatusCallback * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IBindStatusCallback * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OnDataAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);
        
        END_INTERFACE
    } IBindStatusCallbackVtbl;

    interface IBindStatusCallback
    {
        CONST_VTBL struct IBindStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallback_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindStatusCallback_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IBindStatusCallback_Release(This)       \
    (This)->lpVtbl -> Release(This)


#define IBindStatusCallback_OnStartBinding(This,dwReserved,pib) \
    (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib)

#define IBindStatusCallback_GetPriority(This,pnPriority)        \
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#define IBindStatusCallback_OnLowResource(This,reserved)        \
    (This)->lpVtbl -> OnLowResource(This,reserved)

#define IBindStatusCallback_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText) \
    (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)

#define IBindStatusCallback_OnStopBinding(This,hresult,szError) \
    (This)->lpVtbl -> OnStopBinding(This,hresult,szError)

#define IBindStatusCallback_GetBindInfo(This,grfBINDF,pbindinfo)        \
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IBindStatusCallback_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)     \
    (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)

#define IBindStatusCallback_OnObjectAvailable(This,riid,punk)   \
    (This)->lpVtbl -> OnObjectAvailable(This,riid,punk)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnStartBinding_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD dwReserved,
    /* [in] */ IBinding *pib);


void __RPC_STUB IBindStatusCallback_OnStartBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetPriority_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ LONG *pnPriority);


void __RPC_STUB IBindStatusCallback_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnLowResource_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD reserved);


void __RPC_STUB IBindStatusCallback_OnLowResource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnProgress_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText);


void __RPC_STUB IBindStatusCallback_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnStopBinding_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ HRESULT hresult,
    /* [unique][in] */ LPCWSTR szError);


void __RPC_STUB IBindStatusCallback_OnStopBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteGetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteGetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteOnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC *pformatetc,
    /* [in] */ RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteOnDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnObjectAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk);


void __RPC_STUB IBindStatusCallback_OnObjectAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IBindStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0175 */
/* [local] */ 

#endif
#ifndef _LPAUTHENTICATION_DEFINED
#define _LPAUTHENTICATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0175_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0175_v0_0_s_ifspec;

#ifndef __IAuthenticate_INTERFACE_DEFINED__
#define __IAuthenticate_INTERFACE_DEFINED__

/* interface IAuthenticate */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IAuthenticate *LPAUTHENTICATION;


EXTERN_C const IID IID_IAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d0-baf9-11ce-8c82-00aa004ba90b")
    IAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [out] */ HWND *phwnd,
            /* [out] */ LPWSTR *pszUsername,
            /* [out] */ LPWSTR *pszPassword) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAuthenticate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAuthenticate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAuthenticate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            IAuthenticate * This,
            /* [out] */ HWND *phwnd,
            /* [out] */ LPWSTR *pszUsername,
            /* [out] */ LPWSTR *pszPassword);
        
        END_INTERFACE
    } IAuthenticateVtbl;

    interface IAuthenticate
    {
        CONST_VTBL struct IAuthenticateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticate_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticate_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticate_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IAuthenticate_Authenticate(This,phwnd,pszUsername,pszPassword)  \
    (This)->lpVtbl -> Authenticate(This,phwnd,pszUsername,pszPassword)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticate_Authenticate_Proxy( 
    IAuthenticate * This,
    /* [out] */ HWND *phwnd,
    /* [out] */ LPWSTR *pszUsername,
    /* [out] */ LPWSTR *pszPassword);


void __RPC_STUB IAuthenticate_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAuthenticate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0176 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE_DEFINED
#define _LPHTTPNEGOTIATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0176_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0176_v0_0_s_ifspec;

#ifndef __IHttpNegotiate_INTERFACE_DEFINED__
#define __IHttpNegotiate_INTERFACE_DEFINED__

/* interface IHttpNegotiate */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IHttpNegotiate *LPHTTPNEGOTIATE;


EXTERN_C const IID IID_IHttpNegotiate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d2-baf9-11ce-8c82-00aa004ba90b")
    IHttpNegotiate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginningTransaction( 
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR *pszAdditionalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR *pszAdditionalRequestHeaders) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IHttpNegotiateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpNegotiate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpNegotiate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpNegotiate * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            IHttpNegotiate * This,
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            IHttpNegotiate * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR *pszAdditionalRequestHeaders);
        
        END_INTERFACE
    } IHttpNegotiateVtbl;

    interface IHttpNegotiate
    {
        CONST_VTBL struct IHttpNegotiateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate_QueryInterface(This,riid,ppvObject)      \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpNegotiate_AddRef(This)     \
    (This)->lpVtbl -> AddRef(This)

#define IHttpNegotiate_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IHttpNegotiate_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)       \
    (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)

#define IHttpNegotiate_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)   \
    (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IHttpNegotiate_BeginningTransaction_Proxy( 
    IHttpNegotiate * This,
    /* [in] */ LPCWSTR szURL,
    /* [unique][in] */ LPCWSTR szHeaders,
    /* [in] */ DWORD dwReserved,
    /* [out] */ LPWSTR *pszAdditionalHeaders);


void __RPC_STUB IHttpNegotiate_BeginningTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHttpNegotiate_OnResponse_Proxy( 
    IHttpNegotiate * This,
    /* [in] */ DWORD dwResponseCode,
    /* [unique][in] */ LPCWSTR szResponseHeaders,
    /* [unique][in] */ LPCWSTR szRequestHeaders,
    /* [out] */ LPWSTR *pszAdditionalRequestHeaders);


void __RPC_STUB IHttpNegotiate_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IHttpNegotiate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0177 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE2_DEFINED
#define _LPHTTPNEGOTIATE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0177_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0177_v0_0_s_ifspec;

#ifndef __IHttpNegotiate2_INTERFACE_DEFINED__
#define __IHttpNegotiate2_INTERFACE_DEFINED__

/* interface IHttpNegotiate2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IHttpNegotiate2 *LPHTTPNEGOTIATE2;


EXTERN_C const IID IID_IHttpNegotiate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4")
    IHttpNegotiate2 : public IHttpNegotiate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRootSecurityId( 
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IHttpNegotiate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpNegotiate2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpNegotiate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpNegotiate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            IHttpNegotiate2 * This,
            /* [in] */ LPCWSTR szURL,
            /* [unique][in] */ LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            IHttpNegotiate2 * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ LPCWSTR szResponseHeaders,
            /* [unique][in] */ LPCWSTR szRequestHeaders,
            /* [out] */ LPWSTR *pszAdditionalRequestHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootSecurityId )( 
            IHttpNegotiate2 * This,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IHttpNegotiate2Vtbl;

    interface IHttpNegotiate2
    {
        CONST_VTBL struct IHttpNegotiate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate2_QueryInterface(This,riid,ppvObject)     \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpNegotiate2_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IHttpNegotiate2_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IHttpNegotiate2_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)      \
    (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)

#define IHttpNegotiate2_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)  \
    (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)


#define IHttpNegotiate2_GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)   \
    (This)->lpVtbl -> GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IHttpNegotiate2_GetRootSecurityId_Proxy( 
    IHttpNegotiate2 * This,
    /* [size_is][out] */ BYTE *pbSecurityId,
    /* [out][in] */ DWORD *pcbSecurityId,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IHttpNegotiate2_GetRootSecurityId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IHttpNegotiate2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0178 */
/* [local] */ 

#endif
#ifndef _LPWINDOWFORBINDINGUI_DEFINED
#define _LPWINDOWFORBINDINGUI_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0178_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0178_v0_0_s_ifspec;

#ifndef __IWindowForBindingUI_INTERFACE_DEFINED__
#define __IWindowForBindingUI_INTERFACE_DEFINED__

/* interface IWindowForBindingUI */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWindowForBindingUI *LPWINDOWFORBINDINGUI;


EXTERN_C const IID IID_IWindowForBindingUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d5-bafa-11ce-8c82-00aa004ba90b")
    IWindowForBindingUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IWindowForBindingUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowForBindingUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowForBindingUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowForBindingUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IWindowForBindingUI * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } IWindowForBindingUIVtbl;

    interface IWindowForBindingUI
    {
        CONST_VTBL struct IWindowForBindingUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowForBindingUI_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWindowForBindingUI_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IWindowForBindingUI_Release(This)       \
    (This)->lpVtbl -> Release(This)


#define IWindowForBindingUI_GetWindow(This,rguidReason,phwnd)   \
    (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IWindowForBindingUI_GetWindow_Proxy( 
    IWindowForBindingUI * This,
    /* [in] */ REFGUID rguidReason,
    /* [out] */ HWND *phwnd);


void __RPC_STUB IWindowForBindingUI_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IWindowForBindingUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0179 */
/* [local] */ 

#endif
#ifndef _LPCODEINSTALL_DEFINED
#define _LPCODEINSTALL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0179_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0179_v0_0_s_ifspec;

#ifndef __ICodeInstall_INTERFACE_DEFINED__
#define __ICodeInstall_INTERFACE_DEFINED__

/* interface ICodeInstall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICodeInstall *LPCODEINSTALL;

typedef /* [public] */ 
enum __MIDL_ICodeInstall_0001
    {   CIP_DISK_FULL   = 0,
        CIP_ACCESS_DENIED       = CIP_DISK_FULL + 1,
        CIP_NEWER_VERSION_EXISTS        = CIP_ACCESS_DENIED + 1,
        CIP_OLDER_VERSION_EXISTS        = CIP_NEWER_VERSION_EXISTS + 1,
        CIP_NAME_CONFLICT       = CIP_OLDER_VERSION_EXISTS + 1,
        CIP_TRUST_VERIFICATION_COMPONENT_MISSING        = CIP_NAME_CONFLICT + 1,
        CIP_EXE_SELF_REGISTERATION_TIMEOUT      = CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1,
        CIP_UNSAFE_TO_ABORT     = CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1,
        CIP_NEED_REBOOT = CIP_UNSAFE_TO_ABORT + 1
    }   CIP_STATUS;


EXTERN_C const IID IID_ICodeInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d1-baf9-11ce-8c82-00aa004ba90b")
    ICodeInstall : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCodeInstallProblem( 
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ICodeInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeInstall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeInstall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeInstall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            ICodeInstall * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnCodeInstallProblem )( 
            ICodeInstall * This,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } ICodeInstallVtbl;

    interface ICodeInstall
    {
        CONST_VTBL struct ICodeInstallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeInstall_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeInstall_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define ICodeInstall_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define ICodeInstall_GetWindow(This,rguidReason,phwnd)  \
    (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd)


#define ICodeInstall_OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)  \
    (This)->lpVtbl -> OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE ICodeInstall_OnCodeInstallProblem_Proxy( 
    ICodeInstall * This,
    /* [in] */ ULONG ulStatusCode,
    /* [unique][in] */ LPCWSTR szDestination,
    /* [unique][in] */ LPCWSTR szSource,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB ICodeInstall_OnCodeInstallProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICodeInstall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0180 */
/* [local] */ 

#endif
#ifndef _LPWININETINFO_DEFINED
#define _LPWININETINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0180_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0180_v0_0_s_ifspec;

#ifndef __IWinInetInfo_INTERFACE_DEFINED__
#define __IWinInetInfo_INTERFACE_DEFINED__

/* interface IWinInetInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IWinInetInfo *LPWININETINFO;


EXTERN_C const IID IID_IWinInetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d6-bafa-11ce-8c82-00aa004ba90b")
    IWinInetInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryOption( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IWinInetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        END_INTERFACE
    } IWinInetInfoVtbl;

    interface IWinInetInfo
    {
        CONST_VTBL struct IWinInetInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetInfo_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinInetInfo_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define IWinInetInfo_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define IWinInetInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)  \
    (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_RemoteQueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


void __RPC_STUB IWinInetInfo_RemoteQueryOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IWinInetInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0181 */
/* [local] */ 

#endif
#define WININETINFO_OPTION_LOCK_HANDLE 65534
#ifndef _LPHTTPSECURITY_DEFINED
#define _LPHTTPSECURITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0181_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0181_v0_0_s_ifspec;

#ifndef __IHttpSecurity_INTERFACE_DEFINED__
#define __IHttpSecurity_INTERFACE_DEFINED__

/* interface IHttpSecurity */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IHttpSecurity *LPHTTPSECURITY;


EXTERN_C const IID IID_IHttpSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d7-bafa-11ce-8c82-00aa004ba90b")
    IHttpSecurity : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSecurityProblem( 
            /* [in] */ DWORD dwProblem) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IHttpSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpSecurity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpSecurity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpSecurity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IHttpSecurity * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSecurityProblem )( 
            IHttpSecurity * This,
            /* [in] */ DWORD dwProblem);
        
        END_INTERFACE
    } IHttpSecurityVtbl;

    interface IHttpSecurity
    {
        CONST_VTBL struct IHttpSecurityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpSecurity_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpSecurity_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IHttpSecurity_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IHttpSecurity_GetWindow(This,rguidReason,phwnd) \
    (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd)


#define IHttpSecurity_OnSecurityProblem(This,dwProblem) \
    (This)->lpVtbl -> OnSecurityProblem(This,dwProblem)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IHttpSecurity_OnSecurityProblem_Proxy( 
    IHttpSecurity * This,
    /* [in] */ DWORD dwProblem);


void __RPC_STUB IHttpSecurity_OnSecurityProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IHttpSecurity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0182 */
/* [local] */ 

#endif
#ifndef _LPWININETHTTPINFO_DEFINED
#define _LPWININETHTTPINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0182_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0182_v0_0_s_ifspec;

#ifndef __IWinInetHttpInfo_INTERFACE_DEFINED__
#define __IWinInetHttpInfo_INTERFACE_DEFINED__

/* interface IWinInetHttpInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IWinInetHttpInfo *LPWININETHTTPINFO;


EXTERN_C const IID IID_IWinInetHttpInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d8-bafa-11ce-8c82-00aa004ba90b")
    IWinInetHttpInfo : public IWinInetInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IWinInetHttpInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetHttpInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetHttpInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetHttpInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetHttpInfoVtbl;

    interface IWinInetHttpInfo
    {
        CONST_VTBL struct IWinInetHttpInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetHttpInfo_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinInetHttpInfo_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IWinInetHttpInfo_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IWinInetHttpInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)      \
    (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf)


#define IWinInetHttpInfo_QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)   \
    (This)->lpVtbl -> QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_RemoteQueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


void __RPC_STUB IWinInetHttpInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IWinInetHttpInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0183 */
/* [local] */ 

#endif
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0183_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0183_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/* interface IBindHost */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBindHost *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc4801a1-2ba9-11cf-a229-00aa003d7352")
    IBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMoniker( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx *pBC,
            /* [out] */ IMoniker **ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToStorage( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToObject( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMoniker )( 
            IBindHost * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ IBindCtx *pBC,
            /* [out] */ IMoniker **ppmk,
            /* [in] */ DWORD dwReserved);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToStorage )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToObject )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        END_INTERFACE
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindHost_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IBindHost_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)        \
    (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved)

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)   \
    (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)    \
    (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IBindHost_CreateMoniker_Proxy( 
    IBindHost * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ IBindCtx *pBC,
    /* [out] */ IMoniker **ppmk,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBindHost_CreateMoniker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0184 */
/* [local] */ 

#endif
                                                                                                           
// These are for backwards compatibility with previous URLMON versions
// Flags for the UrlDownloadToCacheFile                                                                    
#define URLOSTRM_USECACHEDCOPY_ONLY             0x1      // Only get from cache                            
#define URLOSTRM_USECACHEDCOPY                  0x2      // Get from cache if available else download      
#define URLOSTRM_GETNEWESTVERSION               0x3      // Get new version only. But put it in cache too  
                                                                                                           
                                                                                                           
struct IBindStatusCallback;                                                                                
STDAPI HlinkSimpleNavigateToString(                                                                        
    /* [in] */ LPCWSTR szTarget,         // required - target document - null if local jump w/in doc       
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI HlinkSimpleNavigateToMoniker(                                                                       
    /* [in] */ IMoniker *pmkTarget,      // required - target document - (may be null                      
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                        
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                       
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                    
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                   
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                             
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                           
STDAPI URLDownloadToCacheFileA(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);                  
STDAPI URLDownloadToCacheFileW(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);                 
STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                      
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                     
                                                                                                           
#ifdef UNICODE                                                                                             
#define URLOpenStream            URLOpenStreamW                                                            
#define URLOpenPullStream        URLOpenPullStreamW                                                        
#define URLDownloadToFile        URLDownloadToFileW                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileW                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamW                                                    
#else                                                                                                      
#define URLOpenStream            URLOpenStreamA                                                            
#define URLOpenPullStream        URLOpenPullStreamA                                                        
#define URLDownloadToFile        URLDownloadToFileA                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileA                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamA                                                    
#endif // !UNICODE                                                                                         
                                                                                                           
                                                                                                           
STDAPI HlinkGoBack(IUnknown *pUnk);                                                                        
STDAPI HlinkGoForward(IUnknown *pUnk);                                                                     
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);                                              
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);                                          
                                                                                                           
#ifndef  _URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_   








#ifndef _LPIINTERNET
#define _LPIINTERNET


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0184_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0184_v0_0_s_ifspec;

#ifndef __IInternet_INTERFACE_DEFINED__
#define __IInternet_INTERFACE_DEFINED__

/* interface IInternet */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternet *LPIINTERNET;


EXTERN_C const IID IID_IInternet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e0-baf9-11ce-8c82-00aa004ba90b")
    IInternet : public IUnknown
    {
    public:
    };
    
#else   /* C style interface */

    typedef struct IInternetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternet * This);
        
        END_INTERFACE
    } IInternetVtbl;

    interface IInternet
    {
        CONST_VTBL struct IInternetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternet_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternet_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IInternet_Release(This) \
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif  /* C style interface */




#endif  /* __IInternet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0185 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETBINDINFO
#define _LPIINTERNETBINDINFO


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0185_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0185_v0_0_s_ifspec;

#ifndef __IInternetBindInfo_INTERFACE_DEFINED__
#define __IInternetBindInfo_INTERFACE_DEFINED__

/* interface IInternetBindInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetBindInfo *LPIINTERNETBINDINFO;

typedef 
enum tagBINDSTRING
    {   BINDSTRING_HEADERS      = 1,
        BINDSTRING_ACCEPT_MIMES = BINDSTRING_HEADERS + 1,
        BINDSTRING_EXTRA_URL    = BINDSTRING_ACCEPT_MIMES + 1,
        BINDSTRING_LANGUAGE     = BINDSTRING_EXTRA_URL + 1,
        BINDSTRING_USERNAME     = BINDSTRING_LANGUAGE + 1,
        BINDSTRING_PASSWORD     = BINDSTRING_USERNAME + 1,
        BINDSTRING_UA_PIXELS    = BINDSTRING_PASSWORD + 1,
        BINDSTRING_UA_COLOR     = BINDSTRING_UA_PIXELS + 1,
        BINDSTRING_OS   = BINDSTRING_UA_COLOR + 1,
        BINDSTRING_USER_AGENT   = BINDSTRING_OS + 1,
        BINDSTRING_ACCEPT_ENCODINGS     = BINDSTRING_USER_AGENT + 1,
        BINDSTRING_POST_COOKIE  = BINDSTRING_ACCEPT_ENCODINGS + 1,
        BINDSTRING_POST_DATA_MIME       = BINDSTRING_POST_COOKIE + 1,
        BINDSTRING_URL  = BINDSTRING_POST_DATA_MIME + 1,
        BINDSTRING_IID  = BINDSTRING_URL + 1,
        BINDSTRING_FLAG_BIND_TO_OBJECT  = BINDSTRING_IID + 1,
        BINDSTRING_PTR_BIND_CONTEXT     = BINDSTRING_FLAG_BIND_TO_OBJECT + 1
    }   BINDSTRING;


EXTERN_C const IID IID_IInternetBindInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e1-baf9-11ce-8c82-00aa004ba90b")
    IInternetBindInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindString( 
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetBindInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetBindInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetBindInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetBindInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IInternetBindInfo * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindString )( 
            IInternetBindInfo * This,
            /* [in] */ ULONG ulStringType,
            /* [out][in] */ LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched);
        
        END_INTERFACE
    } IInternetBindInfoVtbl;

    interface IInternetBindInfo
    {
        CONST_VTBL struct IInternetBindInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetBindInfo_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetBindInfo_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IInternetBindInfo_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IInternetBindInfo_GetBindInfo(This,grfBINDF,pbindinfo)  \
    (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo)

#define IInternetBindInfo_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)      \
    (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetBindInfo_GetBindInfo_Proxy( 
    IInternetBindInfo * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo);


void __RPC_STUB IInternetBindInfo_GetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetBindInfo_GetBindString_Proxy( 
    IInternetBindInfo * This,
    /* [in] */ ULONG ulStringType,
    /* [out][in] */ LPOLESTR *ppwzStr,
    /* [in] */ ULONG cEl,
    /* [out][in] */ ULONG *pcElFetched);


void __RPC_STUB IInternetBindInfo_GetBindString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetBindInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0186 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLROOT_DEFINED
#define _LPIINTERNETPROTOCOLROOT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0186_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0186_v0_0_s_ifspec;

#ifndef __IInternetProtocolRoot_INTERFACE_DEFINED__
#define __IInternetProtocolRoot_INTERFACE_DEFINED__

/* interface IInternetProtocolRoot */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolRoot *LPIINTERNETPROTOCOLROOT;

typedef 
enum _tagPI_FLAGS
    {   PI_PARSE_URL    = 0x1,
        PI_FILTER_MODE  = 0x2,
        PI_FORCE_ASYNC  = 0x4,
        PI_USE_WORKERTHREAD     = 0x8,
        PI_MIMEVERIFICATION     = 0x10,
        PI_CLSIDLOOKUP  = 0x20,
        PI_DATAPROGRESS = 0x40,
        PI_SYNCHRONOUS  = 0x80,
        PI_APARTMENTTHREADED    = 0x100,
        PI_CLASSINSTALL = 0x200,
        PI_PASSONBINDCTX        = 0x2000,
        PI_NOMIMEHANDLER        = 0x8000,
        PI_LOADAPPDIRECT        = 0x4000,
        PD_FORCE_SWITCH = 0x10000,
        PI_PREFERDEFAULTHANDLER = 0x20000
    }   PI_FLAGS;

typedef struct _tagPROTOCOLDATA
    {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
    }   PROTOCOLDATA;

typedef struct _tagStartParam
    {
    IID iid;
    IBindCtx *pIBindCtx;
    IUnknown *pItf;
    }   StartParam;


EXTERN_C const IID IID_IInternetProtocolRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e3-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetProtocolRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolRoot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolRoot * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolRoot * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolRoot * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolRoot * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolRoot * This);
        
        END_INTERFACE
    } IInternetProtocolRootVtbl;

    interface IInternetProtocolRoot
    {
        CONST_VTBL struct IInternetProtocolRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolRoot_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetProtocolRoot_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IInternetProtocolRoot_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IInternetProtocolRoot_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)        \
    (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)

#define IInternetProtocolRoot_Continue(This,pProtocolData)      \
    (This)->lpVtbl -> Continue(This,pProtocolData)

#define IInternetProtocolRoot_Abort(This,hrReason,dwOptions)    \
    (This)->lpVtbl -> Abort(This,hrReason,dwOptions)

#define IInternetProtocolRoot_Terminate(This,dwOptions) \
    (This)->lpVtbl -> Terminate(This,dwOptions)

#define IInternetProtocolRoot_Suspend(This)     \
    (This)->lpVtbl -> Suspend(This)

#define IInternetProtocolRoot_Resume(This)      \
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetProtocolRoot_Start_Proxy( 
    IInternetProtocolRoot * This,
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IInternetProtocolSink *pOIProtSink,
    /* [in] */ IInternetBindInfo *pOIBindInfo,
    /* [in] */ DWORD grfPI,
    /* [in] */ HANDLE_PTR dwReserved);


void __RPC_STUB IInternetProtocolRoot_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolRoot_Continue_Proxy( 
    IInternetProtocolRoot * This,
    /* [in] */ PROTOCOLDATA *pProtocolData);


void __RPC_STUB IInternetProtocolRoot_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolRoot_Abort_Proxy( 
    IInternetProtocolRoot * This,
    /* [in] */ HRESULT hrReason,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IInternetProtocolRoot_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolRoot_Terminate_Proxy( 
    IInternetProtocolRoot * This,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IInternetProtocolRoot_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolRoot_Suspend_Proxy( 
    IInternetProtocolRoot * This);


void __RPC_STUB IInternetProtocolRoot_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolRoot_Resume_Proxy( 
    IInternetProtocolRoot * This);


void __RPC_STUB IInternetProtocolRoot_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetProtocolRoot_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0187 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOL_DEFINED
#define _LPIINTERNETPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0187_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0187_v0_0_s_ifspec;

#ifndef __IInternetProtocol_INTERFACE_DEFINED__
#define __IInternetProtocol_INTERFACE_DEFINED__

/* interface IInternetProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocol *LPIINTERNETPROTOCOL;


EXTERN_C const IID IID_IInternetProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e4-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocol : public IInternetProtocolRoot
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockRequest( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocol * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocol * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocol * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocol * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocol * This);
        
        END_INTERFACE
    } IInternetProtocolVtbl;

    interface IInternetProtocol
    {
        CONST_VTBL struct IInternetProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocol_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetProtocol_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IInternetProtocol_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IInternetProtocol_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)    \
    (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)

#define IInternetProtocol_Continue(This,pProtocolData)  \
    (This)->lpVtbl -> Continue(This,pProtocolData)

#define IInternetProtocol_Abort(This,hrReason,dwOptions)        \
    (This)->lpVtbl -> Abort(This,hrReason,dwOptions)

#define IInternetProtocol_Terminate(This,dwOptions)     \
    (This)->lpVtbl -> Terminate(This,dwOptions)

#define IInternetProtocol_Suspend(This) \
    (This)->lpVtbl -> Suspend(This)

#define IInternetProtocol_Resume(This)  \
    (This)->lpVtbl -> Resume(This)


#define IInternetProtocol_Read(This,pv,cb,pcbRead)      \
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IInternetProtocol_Seek(This,dlibMove,dwOrigin,plibNewPosition)  \
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IInternetProtocol_LockRequest(This,dwOptions)   \
    (This)->lpVtbl -> LockRequest(This,dwOptions)

#define IInternetProtocol_UnlockRequest(This)   \
    (This)->lpVtbl -> UnlockRequest(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetProtocol_Read_Proxy( 
    IInternetProtocol * This,
    /* [length_is][size_is][out][in] */ void *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbRead);


void __RPC_STUB IInternetProtocol_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocol_Seek_Proxy( 
    IInternetProtocol * This,
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER *plibNewPosition);


void __RPC_STUB IInternetProtocol_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocol_LockRequest_Proxy( 
    IInternetProtocol * This,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IInternetProtocol_LockRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocol_UnlockRequest_Proxy( 
    IInternetProtocol * This);


void __RPC_STUB IInternetProtocol_UnlockRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0188 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLSINK_DEFINED
#define _LPIINTERNETPROTOCOLSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0188_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0188_v0_0_s_ifspec;

#ifndef __IInternetProtocolSink_INTERFACE_DEFINED__
#define __IInternetProtocolSink_INTERFACE_DEFINED__

/* interface IInternetProtocolSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSink *LPIINTERNETPROTOCOLSINK;


EXTERN_C const IID IID_IInternetProtocolSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e5-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Switch( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportData( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportResult( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetProtocolSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Switch )( 
            IInternetProtocolSink * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *ReportProgress )( 
            IInternetProtocolSink * This,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *ReportData )( 
            IInternetProtocolSink * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax);
        
        HRESULT ( STDMETHODCALLTYPE *ReportResult )( 
            IInternetProtocolSink * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult);
        
        END_INTERFACE
    } IInternetProtocolSinkVtbl;

    interface IInternetProtocolSink
    {
        CONST_VTBL struct IInternetProtocolSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSink_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetProtocolSink_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IInternetProtocolSink_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IInternetProtocolSink_Switch(This,pProtocolData)        \
    (This)->lpVtbl -> Switch(This,pProtocolData)

#define IInternetProtocolSink_ReportProgress(This,ulStatusCode,szStatusText)    \
    (This)->lpVtbl -> ReportProgress(This,ulStatusCode,szStatusText)

#define IInternetProtocolSink_ReportData(This,grfBSCF,ulProgress,ulProgressMax) \
    (This)->lpVtbl -> ReportData(This,grfBSCF,ulProgress,ulProgressMax)

#define IInternetProtocolSink_ReportResult(This,hrResult,dwError,szResult)      \
    (This)->lpVtbl -> ReportResult(This,hrResult,dwError,szResult)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetProtocolSink_Switch_Proxy( 
    IInternetProtocolSink * This,
    /* [in] */ PROTOCOLDATA *pProtocolData);


void __RPC_STUB IInternetProtocolSink_Switch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolSink_ReportProgress_Proxy( 
    IInternetProtocolSink * This,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText);


void __RPC_STUB IInternetProtocolSink_ReportProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolSink_ReportData_Proxy( 
    IInternetProtocolSink * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax);


void __RPC_STUB IInternetProtocolSink_ReportData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolSink_ReportResult_Proxy( 
    IInternetProtocolSink * This,
    /* [in] */ HRESULT hrResult,
    /* [in] */ DWORD dwError,
    /* [in] */ LPCWSTR szResult);


void __RPC_STUB IInternetProtocolSink_ReportResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetProtocolSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0189 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED
#define _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0189_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0189_v0_0_s_ifspec;

#ifndef __IInternetProtocolSinkStackable_INTERFACE_DEFINED__
#define __IInternetProtocolSinkStackable_INTERFACE_DEFINED__

/* interface IInternetProtocolSinkStackable */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSinkStackable *LPIINTERNETPROTOCOLSINKStackable;


EXTERN_C const IID IID_IInternetProtocolSinkStackable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9f0-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSinkStackable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SwitchSink( 
            /* [in] */ IInternetProtocolSink *pOIProtSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitSwitch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RollbackSwitch( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetProtocolSinkStackableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSinkStackable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchSink )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ IInternetProtocolSink *pOIProtSink);
        
        HRESULT ( STDMETHODCALLTYPE *CommitSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *RollbackSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        END_INTERFACE
    } IInternetProtocolSinkStackableVtbl;

    interface IInternetProtocolSinkStackable
    {
        CONST_VTBL struct IInternetProtocolSinkStackableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSinkStackable_QueryInterface(This,riid,ppvObject)      \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetProtocolSinkStackable_AddRef(This)     \
    (This)->lpVtbl -> AddRef(This)

#define IInternetProtocolSinkStackable_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IInternetProtocolSinkStackable_SwitchSink(This,pOIProtSink)     \
    (This)->lpVtbl -> SwitchSink(This,pOIProtSink)

#define IInternetProtocolSinkStackable_CommitSwitch(This)       \
    (This)->lpVtbl -> CommitSwitch(This)

#define IInternetProtocolSinkStackable_RollbackSwitch(This)     \
    (This)->lpVtbl -> RollbackSwitch(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetProtocolSinkStackable_SwitchSink_Proxy( 
    IInternetProtocolSinkStackable * This,
    /* [in] */ IInternetProtocolSink *pOIProtSink);


void __RPC_STUB IInternetProtocolSinkStackable_SwitchSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolSinkStackable_CommitSwitch_Proxy( 
    IInternetProtocolSinkStackable * This);


void __RPC_STUB IInternetProtocolSinkStackable_CommitSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolSinkStackable_RollbackSwitch_Proxy( 
    IInternetProtocolSinkStackable * This);


void __RPC_STUB IInternetProtocolSinkStackable_RollbackSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetProtocolSinkStackable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0190 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETSESSION_DEFINED
#define _LPIINTERNETSESSION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0190_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0190_v0_0_s_ifspec;

#ifndef __IInternetSession_INTERFACE_DEFINED__
#define __IInternetSession_INTERFACE_DEFINED__

/* interface IInternetSession */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetSession *LPIINTERNETSESSION;

typedef 
enum _tagOIBDG_FLAGS
    {   OIBDG_APARTMENTTHREADED = 0x100,
        OIBDG_DATAONLY  = 0x1000
    }   OIBDG_FLAGS;


EXTERN_C const IID IID_IInternetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e7-baf9-11ce-8c82-00aa004ba90b")
    IInternetSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IInternetSession * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetSessionVtbl;

    interface IInternetSession
    {
        CONST_VTBL struct IInternetSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSession_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetSession_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IInternetSession_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IInternetSession_RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)       \
    (This)->lpVtbl -> RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)

#define IInternetSession_UnregisterNameSpace(This,pCF,pszProtocol)      \
    (This)->lpVtbl -> UnregisterNameSpace(This,pCF,pszProtocol)

#define IInternetSession_RegisterMimeFilter(This,pCF,rclsid,pwzType)    \
    (This)->lpVtbl -> RegisterMimeFilter(This,pCF,rclsid,pwzType)

#define IInternetSession_UnregisterMimeFilter(This,pCF,pwzType) \
    (This)->lpVtbl -> UnregisterMimeFilter(This,pCF,pwzType)

#define IInternetSession_CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption)     \
    (This)->lpVtbl -> CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption)

#define IInternetSession_SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)      \
    (This)->lpVtbl -> SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)

#define IInternetSession_GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)     \
    (This)->lpVtbl -> GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetSession_RegisterNameSpace_Proxy( 
    IInternetSession * This,
    /* [in] */ IClassFactory *pCF,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPCWSTR pwzProtocol,
    /* [in] */ ULONG cPatterns,
    /* [in] */ const LPCWSTR *ppwzPatterns,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetSession_RegisterNameSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSession_UnregisterNameSpace_Proxy( 
    IInternetSession * This,
    /* [in] */ IClassFactory *pCF,
    /* [in] */ LPCWSTR pszProtocol);


void __RPC_STUB IInternetSession_UnregisterNameSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSession_RegisterMimeFilter_Proxy( 
    IInternetSession * This,
    /* [in] */ IClassFactory *pCF,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPCWSTR pwzType);


void __RPC_STUB IInternetSession_RegisterMimeFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSession_UnregisterMimeFilter_Proxy( 
    IInternetSession * This,
    /* [in] */ IClassFactory *pCF,
    /* [in] */ LPCWSTR pwzType);


void __RPC_STUB IInternetSession_UnregisterMimeFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSession_CreateBinding_Proxy( 
    IInternetSession * This,
    /* [in] */ LPBC pBC,
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IUnknown *pUnkOuter,
    /* [unique][out] */ IUnknown **ppUnk,
    /* [unique][out] */ IInternetProtocol **ppOInetProt,
    /* [in] */ DWORD dwOption);


void __RPC_STUB IInternetSession_CreateBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSession_SetSessionOption_Proxy( 
    IInternetSession * This,
    /* [in] */ DWORD dwOption,
    /* [in] */ LPVOID pBuffer,
    /* [in] */ DWORD dwBufferLength,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetSession_SetSessionOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSession_GetSessionOption_Proxy( 
    IInternetSession * This,
    /* [in] */ DWORD dwOption,
    /* [out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pdwBufferLength,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetSession_GetSessionOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0191 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETTHREADSWITCH_DEFINED
#define _LPIINTERNETTHREADSWITCH_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0191_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0191_v0_0_s_ifspec;

#ifndef __IInternetThreadSwitch_INTERFACE_DEFINED__
#define __IInternetThreadSwitch_INTERFACE_DEFINED__

/* interface IInternetThreadSwitch */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetThreadSwitch *LPIINTERNETTHREADSWITCH;


EXTERN_C const IID IID_IInternetThreadSwitch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e8-baf9-11ce-8c82-00aa004ba90b")
    IInternetThreadSwitch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetThreadSwitchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetThreadSwitch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetThreadSwitch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetThreadSwitch * This);
        
        END_INTERFACE
    } IInternetThreadSwitchVtbl;

    interface IInternetThreadSwitch
    {
        CONST_VTBL struct IInternetThreadSwitchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetThreadSwitch_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetThreadSwitch_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IInternetThreadSwitch_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IInternetThreadSwitch_Prepare(This)     \
    (This)->lpVtbl -> Prepare(This)

#define IInternetThreadSwitch_Continue(This)    \
    (This)->lpVtbl -> Continue(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetThreadSwitch_Prepare_Proxy( 
    IInternetThreadSwitch * This);


void __RPC_STUB IInternetThreadSwitch_Prepare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetThreadSwitch_Continue_Proxy( 
    IInternetThreadSwitch * This);


void __RPC_STUB IInternetThreadSwitch_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetThreadSwitch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0192 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPRIORITY_DEFINED
#define _LPIINTERNETPRIORITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0192_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0192_v0_0_s_ifspec;

#ifndef __IInternetPriority_INTERFACE_DEFINED__
#define __IInternetPriority_INTERFACE_DEFINED__

/* interface IInternetPriority */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetPriority *LPIINTERNETPRIORITY;


EXTERN_C const IID IID_IInternetPriority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9eb-baf9-11ce-8c82-00aa004ba90b")
    IInternetPriority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetPriorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetPriority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetPriority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetPriority * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IInternetPriority * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IInternetPriority * This,
            /* [out] */ LONG *pnPriority);
        
        END_INTERFACE
    } IInternetPriorityVtbl;

    interface IInternetPriority
    {
        CONST_VTBL struct IInternetPriorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetPriority_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetPriority_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IInternetPriority_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IInternetPriority_SetPriority(This,nPriority)   \
    (This)->lpVtbl -> SetPriority(This,nPriority)

#define IInternetPriority_GetPriority(This,pnPriority)  \
    (This)->lpVtbl -> GetPriority(This,pnPriority)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetPriority_SetPriority_Proxy( 
    IInternetPriority * This,
    /* [in] */ LONG nPriority);


void __RPC_STUB IInternetPriority_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetPriority_GetPriority_Proxy( 
    IInternetPriority * This,
    /* [out] */ LONG *pnPriority);


void __RPC_STUB IInternetPriority_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetPriority_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0193 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLINFO_DEFINED
#define _LPIINTERNETPROTOCOLINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0193_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0193_v0_0_s_ifspec;

#ifndef __IInternetProtocolInfo_INTERFACE_DEFINED__
#define __IInternetProtocolInfo_INTERFACE_DEFINED__

/* interface IInternetProtocolInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolInfo *LPIINTERNETPROTOCOLINFO;

typedef 
enum _tagPARSEACTION
    {   PARSE_CANONICALIZE      = 1,
        PARSE_FRIENDLY  = PARSE_CANONICALIZE + 1,
        PARSE_SECURITY_URL      = PARSE_FRIENDLY + 1,
        PARSE_ROOTDOCUMENT      = PARSE_SECURITY_URL + 1,
        PARSE_DOCUMENT  = PARSE_ROOTDOCUMENT + 1,
        PARSE_ANCHOR    = PARSE_DOCUMENT + 1,
        PARSE_ENCODE    = PARSE_ANCHOR + 1,
        PARSE_DECODE    = PARSE_ENCODE + 1,
        PARSE_PATH_FROM_URL     = PARSE_DECODE + 1,
        PARSE_URL_FROM_PATH     = PARSE_PATH_FROM_URL + 1,
        PARSE_MIME      = PARSE_URL_FROM_PATH + 1,
        PARSE_SERVER    = PARSE_MIME + 1,
        PARSE_SCHEMA    = PARSE_SERVER + 1,
        PARSE_SITE      = PARSE_SCHEMA + 1,
        PARSE_DOMAIN    = PARSE_SITE + 1,
        PARSE_LOCATION  = PARSE_DOMAIN + 1,
        PARSE_SECURITY_DOMAIN   = PARSE_LOCATION + 1,
        PARSE_ESCAPE    = PARSE_SECURITY_DOMAIN + 1,
        PARSE_UNESCAPE  = PARSE_ESCAPE + 1
    }   PARSEACTION;

typedef 
enum _tagPSUACTION
    {   PSU_DEFAULT     = 1,
        PSU_SECURITY_URL_ONLY   = PSU_DEFAULT + 1
    }   PSUACTION;

typedef 
enum _tagQUERYOPTION
    {   QUERY_EXPIRATION_DATE   = 1,
        QUERY_TIME_OF_LAST_CHANGE       = QUERY_EXPIRATION_DATE + 1,
        QUERY_CONTENT_ENCODING  = QUERY_TIME_OF_LAST_CHANGE + 1,
        QUERY_CONTENT_TYPE      = QUERY_CONTENT_ENCODING + 1,
        QUERY_REFRESH   = QUERY_CONTENT_TYPE + 1,
        QUERY_RECOMBINE = QUERY_REFRESH + 1,
        QUERY_CAN_NAVIGATE      = QUERY_RECOMBINE + 1,
        QUERY_USES_NETWORK      = QUERY_CAN_NAVIGATE + 1,
        QUERY_IS_CACHED = QUERY_USES_NETWORK + 1,
        QUERY_IS_INSTALLEDENTRY = QUERY_IS_CACHED + 1,
        QUERY_IS_CACHED_OR_MAPPED       = QUERY_IS_INSTALLEDENTRY + 1,
        QUERY_USES_CACHE        = QUERY_IS_CACHED_OR_MAPPED + 1,
        QUERY_IS_SECURE = QUERY_USES_CACHE + 1,
        QUERY_IS_SAFE   = QUERY_IS_SECURE + 1
    }   QUERYOPTION;


EXTERN_C const IID IID_IInternetProtocolInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ec-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseUrl( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareUrl( 
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetProtocolInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CombineUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [out] */ LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CompareUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetProtocolInfoVtbl;

    interface IInternetProtocolInfo
    {
        CONST_VTBL struct IInternetProtocolInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolInfo_QueryInterface(This,riid,ppvObject)       \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetProtocolInfo_AddRef(This)      \
    (This)->lpVtbl -> AddRef(This)

#define IInternetProtocolInfo_Release(This)     \
    (This)->lpVtbl -> Release(This)


#define IInternetProtocolInfo_ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved)  \
    (This)->lpVtbl -> ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved)

#define IInternetProtocolInfo_CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved)       \
    (This)->lpVtbl -> CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved)

#define IInternetProtocolInfo_CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags)   \
    (This)->lpVtbl -> CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags)

#define IInternetProtocolInfo_QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved)        \
    (This)->lpVtbl -> QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetProtocolInfo_ParseUrl_Proxy( 
    IInternetProtocolInfo * This,
    /* [in] */ LPCWSTR pwzUrl,
    /* [in] */ PARSEACTION ParseAction,
    /* [in] */ DWORD dwParseFlags,
    /* [out] */ LPWSTR pwzResult,
    /* [in] */ DWORD cchResult,
    /* [out] */ DWORD *pcchResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetProtocolInfo_ParseUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolInfo_CombineUrl_Proxy( 
    IInternetProtocolInfo * This,
    /* [in] */ LPCWSTR pwzBaseUrl,
    /* [in] */ LPCWSTR pwzRelativeUrl,
    /* [in] */ DWORD dwCombineFlags,
    /* [out] */ LPWSTR pwzResult,
    /* [in] */ DWORD cchResult,
    /* [out] */ DWORD *pcchResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetProtocolInfo_CombineUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolInfo_CompareUrl_Proxy( 
    IInternetProtocolInfo * This,
    /* [in] */ LPCWSTR pwzUrl1,
    /* [in] */ LPCWSTR pwzUrl2,
    /* [in] */ DWORD dwCompareFlags);


void __RPC_STUB IInternetProtocolInfo_CompareUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetProtocolInfo_QueryInfo_Proxy( 
    IInternetProtocolInfo * This,
    /* [in] */ LPCWSTR pwzUrl,
    /* [in] */ QUERYOPTION OueryOption,
    /* [in] */ DWORD dwQueryFlags,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [in] */ DWORD cbBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetProtocolInfo_QueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetProtocolInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0194 */
/* [local] */ 

#endif
#define IOInet               IInternet            
#define IOInetBindInfo       IInternetBindInfo    
#define IOInetProtocolRoot   IInternetProtocolRoot
#define IOInetProtocol       IInternetProtocol    
#define IOInetProtocolSink   IInternetProtocolSink
#define IOInetProtocolInfo   IInternetProtocolInfo
#define IOInetSession        IInternetSession     
#define IOInetPriority       IInternetPriority    
#define IOInetThreadSwitch   IInternetThreadSwitch
#define IOInetProtocolSinkStackable   IInternetProtocolSinkStackable
#define LPOINET              LPIINTERNET             
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETBINDINFO      LPIINTERNETBINDINFO     
#define LPOINETPROTOCOLROOT  LPIINTERNETPROTOCOLROOT 
#define LPOINETPROTOCOL      LPIINTERNETPROTOCOL     
#define LPOINETPROTOCOLSINK  LPIINTERNETPROTOCOLSINK 
#define LPOINETSESSION       LPIINTERNETSESSION      
#define LPOINETTHREADSWITCH  LPIINTERNETTHREADSWITCH 
#define LPOINETPRIORITY      LPIINTERNETPRIORITY     
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETPROTOCOLSINKSTACKABLE  LPIINTERNETPROTOCOLSINKSTACKABLE 
#define IID_IOInet               IID_IInternet            
#define IID_IOInetBindInfo       IID_IInternetBindInfo    
#define IID_IOInetProtocolRoot   IID_IInternetProtocolRoot
#define IID_IOInetProtocol       IID_IInternetProtocol    
#define IID_IOInetProtocolSink   IID_IInternetProtocolSink
#define IID_IOInetProtocolInfo   IID_IInternetProtocolInfo
#define IID_IOInetSession        IID_IInternetSession     
#define IID_IOInetPriority       IID_IInternetPriority    
#define IID_IOInetThreadSwitch   IID_IInternetThreadSwitch
#define IID_IOInetProtocolSinkStackable   IID_IInternetProtocolSinkStackable
STDAPI CoInternetParseUrl(               
    LPCWSTR     pwzUrl,                  
    PARSEACTION ParseAction,             
    DWORD       dwFlags,                 
    LPWSTR      pszResult,               
    DWORD       cchResult,               
    DWORD      *pcchResult,              
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetCombineUrl(             
    LPCWSTR     pwzBaseUrl,              
    LPCWSTR     pwzRelativeUrl,          
    DWORD       dwCombineFlags,          
    LPWSTR      pszResult,               
    DWORD       cchResult,               
    DWORD      *pcchResult,              
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetCompareUrl(             
    LPCWSTR pwzUrl1,                     
    LPCWSTR pwzUrl2,                     
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetGetProtocolFlags(       
    LPCWSTR     pwzUrl,                  
    DWORD      *pdwFlags,                
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetQueryInfo(              
    LPCWSTR     pwzUrl,                  
    QUERYOPTION QueryOptions,            
    DWORD       dwQueryFlags,            
    LPVOID      pvBuffer,                
    DWORD       cbBuffer,                
    DWORD      *pcbBuffer,               
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSession(             
    DWORD       dwSessionMode,           
    IInternetSession **ppIInternetSession,
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSecurityUrl(         
    LPCWSTR pwzUrl,                      
    LPWSTR  *ppwzSecUrl,                 
    PSUACTION  psuAction,                
    DWORD   dwReserved                   
    );                                   
 
STDAPI CopyStgMedium(const STGMEDIUM * pcstgmedSrc,  
                           STGMEDIUM * pstgmedDest); 
STDAPI CopyBindInfo( const BINDINFO * pcbiSrc,   
                           BINDINFO * pbiDest ); 
STDAPI_(void) ReleaseBindInfo( BINDINFO * pbindinfo );  
 
#define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)      
#define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)      
#define INET_E_DEFAULT_ACTION              INET_E_USE_DEFAULT_PROTOCOLHANDLER  
#define INET_E_QUERYOPTION_UNKNOWN         _HRESULT_TYPEDEF_(0x800C0013L)      
#define INET_E_REDIRECTING                 _HRESULT_TYPEDEF_(0x800C0014L)      
#define OInetParseUrl               CoInternetParseUrl               
#define OInetCombineUrl             CoInternetCombineUrl             
#define OInetCompareUrl             CoInternetCompareUrl             
#define OInetQueryInfo              CoInternetQueryInfo              
#define OInetGetSession             CoInternetGetSession             
#endif // !_URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_ 
//
// Static Protocol flags
//
#define PROTOCOLFLAG_NO_PICS_CHECK     0x00000001

// Creates the security manager object. The first argument is the Service provider
// to allow for delegation
STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved);


// Security manager CLSID's
EXTERN_C const IID CLSID_InternetSecurityManager;  
EXTERN_C const IID CLSID_InternetZoneManager;  
// This service is used for delegation support on the Security Manager interface
#define SID_SInternetSecurityManager         IID_IInternetSecurityManager

#define SID_SInternetHostSecurityManager     IID_IInternetHostSecurityManager

#ifndef _LPINTERNETSECURITYMGRSITE_DEFINED
#define _LPINTERNETSECURITYMGRSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0194_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0194_v0_0_s_ifspec;

#ifndef __IInternetSecurityMgrSite_INTERFACE_DEFINED__
#define __IInternetSecurityMgrSite_INTERFACE_DEFINED__

/* interface IInternetSecurityMgrSite */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetSecurityMgrSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ed-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityMgrSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetSecurityMgrSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityMgrSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityMgrSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IInternetSecurityMgrSite * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IInternetSecurityMgrSiteVtbl;

    interface IInternetSecurityMgrSite
    {
        CONST_VTBL struct IInternetSecurityMgrSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityMgrSite_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetSecurityMgrSite_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IInternetSecurityMgrSite_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IInternetSecurityMgrSite_GetWindow(This,phwnd)  \
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IInternetSecurityMgrSite_EnableModeless(This,fEnable)   \
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetSecurityMgrSite_GetWindow_Proxy( 
    IInternetSecurityMgrSite * This,
    /* [out] */ HWND *phwnd);


void __RPC_STUB IInternetSecurityMgrSite_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityMgrSite_EnableModeless_Proxy( 
    IInternetSecurityMgrSite * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IInternetSecurityMgrSite_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetSecurityMgrSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0195 */
/* [local] */ 

#endif
#ifndef _LPINTERNETSECURITYMANANGER_DEFINED
#define _LPINTERNETSECURITYMANANGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0195_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0195_v0_0_s_ifspec;

#ifndef __IInternetSecurityManager_INTERFACE_DEFINED__
#define __IInternetSecurityManager_INTERFACE_DEFINED__

/* interface IInternetSecurityManager */
/* [object][unique][helpstring][uuid] */ 

#define MUTZ_NOSAVEDFILECHECK 0x00000001 // don't check file: for saved file comment
#define MUTZ_ENFORCERESTRICTED   0x00000100 // enforce restricted zone independent of URL
// MapUrlToZone returns the zone index given a URL
#define MAX_SIZE_SECURITY_ID 512 // bytes
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0001
    {   PUAF_DEFAULT    = 0,
        PUAF_NOUI       = 0x1,
        PUAF_ISFILE     = 0x2,
        PUAF_WARN_IF_DENIED     = 0x4,
        PUAF_FORCEUI_FOREGROUND = 0x8,
        PUAF_CHECK_TIFS = 0x10,
        PUAF_DONTCHECKBOXINDIALOG       = 0x20,
        PUAF_TRUSTED    = 0x40,
        PUAF_ACCEPT_WILDCARD_SCHEME     = 0x80,
        PUAF_ENFORCERESTRICTED  = 0x100
    }   PUAF;

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed
// This is the wrapper function to conveniently read a custom policy.
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0002
    {   SZM_CREATE      = 0,
        SZM_DELETE      = 0x1
    }   SZM_FLAGS;

// SetZoneMapping
//    lpszPattern: string denoting a URL pattern
//        Examples of valid patterns:   
//            *://*.msn.com             
//            http://*.sony.co.jp       
//            *://et.msn.com            
//            ftp://157.54.23.41/       
//            https://localsvr          
//            file:\localsvr\share     
//            *://157.54.100-200.*      
//        Examples of invalid patterns: 
//            http://*.lcs.mit.edu      
//            ftp://*                   
//    dwFlags: SZM_FLAGS values         

EXTERN_C const IID IID_IInternetSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ee-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSecuritySite( 
            /* [unique][in] */ IInternetSecurityMgrSite *pSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecuritySite( 
            /* [out] */ IInternetSecurityMgrSite **ppSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZone( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneMapping( 
            /* [in] */ DWORD dwZone,
            /* [in] */ LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneMappings( 
            /* [in] */ DWORD dwZone,
            /* [out] */ IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            IInternetSecurityManager * This,
            /* [unique][in] */ IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            IInternetSecurityManager * This,
            /* [out] */ IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [out] */ DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetSecurityManager * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerVtbl;

    interface IInternetSecurityManager
    {
        CONST_VTBL struct IInternetSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManager_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetSecurityManager_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IInternetSecurityManager_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IInternetSecurityManager_SetSecuritySite(This,pSite)    \
    (This)->lpVtbl -> SetSecuritySite(This,pSite)

#define IInternetSecurityManager_GetSecuritySite(This,ppSite)   \
    (This)->lpVtbl -> GetSecuritySite(This,ppSite)

#define IInternetSecurityManager_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)     \
    (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)

#define IInternetSecurityManager_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)      \
    (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)

#define IInternetSecurityManager_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) \
    (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)

#define IInternetSecurityManager_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)       \
    (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)

#define IInternetSecurityManager_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)        \
    (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags)

#define IInternetSecurityManager_GetZoneMappings(This,dwZone,ppenumString,dwFlags)      \
    (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetSecurityManager_SetSecuritySite_Proxy( 
    IInternetSecurityManager * This,
    /* [unique][in] */ IInternetSecurityMgrSite *pSite);


void __RPC_STUB IInternetSecurityManager_SetSecuritySite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_GetSecuritySite_Proxy( 
    IInternetSecurityManager * This,
    /* [out] */ IInternetSecurityMgrSite **ppSite);


void __RPC_STUB IInternetSecurityManager_GetSecuritySite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_MapUrlToZone_Proxy( 
    IInternetSecurityManager * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [out] */ DWORD *pdwZone,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IInternetSecurityManager_MapUrlToZone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_GetSecurityId_Proxy( 
    IInternetSecurityManager * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [size_is][out] */ BYTE *pbSecurityId,
    /* [out][in] */ DWORD *pcbSecurityId,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IInternetSecurityManager_GetSecurityId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_ProcessUrlAction_Proxy( 
    IInternetSecurityManager * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ DWORD dwAction,
    /* [size_is][out] */ BYTE *pPolicy,
    /* [in] */ DWORD cbPolicy,
    /* [in] */ BYTE *pContext,
    /* [in] */ DWORD cbContext,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetSecurityManager_ProcessUrlAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_QueryCustomPolicy_Proxy( 
    IInternetSecurityManager * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ REFGUID guidKey,
    /* [size_is][size_is][out] */ BYTE **ppPolicy,
    /* [out] */ DWORD *pcbPolicy,
    /* [in] */ BYTE *pContext,
    /* [in] */ DWORD cbContext,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetSecurityManager_QueryCustomPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_SetZoneMapping_Proxy( 
    IInternetSecurityManager * This,
    /* [in] */ DWORD dwZone,
    /* [in] */ LPCWSTR lpszPattern,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IInternetSecurityManager_SetZoneMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetSecurityManager_GetZoneMappings_Proxy( 
    IInternetSecurityManager * This,
    /* [in] */ DWORD dwZone,
    /* [out] */ IEnumString **ppenumString,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IInternetSecurityManager_GetZoneMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0196 */
/* [local] */ 

#endif
#ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED
#define _LPINTERNETHOSTSECURITYMANANGER_DEFINED
//This is the interface MSHTML exposes to its clients
//The clients need not pass in a URL to these functions
//since MSHTML maintains the notion of the current URL


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0196_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0196_v0_0_s_ifspec;

#ifndef __IInternetHostSecurityManager_INTERFACE_DEFINED__
#define __IInternetHostSecurityManager_INTERFACE_DEFINED__

/* interface IInternetHostSecurityManager */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetHostSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")
    IInternetHostSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetHostSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetHostSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetHostSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetHostSecurityManager * This,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetHostSecurityManager * This,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetHostSecurityManagerVtbl;

    interface IInternetHostSecurityManager
    {
        CONST_VTBL struct IInternetHostSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetHostSecurityManager_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetHostSecurityManager_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define IInternetHostSecurityManager_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define IInternetHostSecurityManager_GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)  \
    (This)->lpVtbl -> GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)

#define IInternetHostSecurityManager_ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)     \
    (This)->lpVtbl -> ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)

#define IInternetHostSecurityManager_QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)   \
    (This)->lpVtbl -> QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetHostSecurityManager_GetSecurityId_Proxy( 
    IInternetHostSecurityManager * This,
    /* [size_is][out] */ BYTE *pbSecurityId,
    /* [out][in] */ DWORD *pcbSecurityId,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IInternetHostSecurityManager_GetSecurityId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetHostSecurityManager_ProcessUrlAction_Proxy( 
    IInternetHostSecurityManager * This,
    /* [in] */ DWORD dwAction,
    /* [size_is][out] */ BYTE *pPolicy,
    /* [in] */ DWORD cbPolicy,
    /* [in] */ BYTE *pContext,
    /* [in] */ DWORD cbContext,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetHostSecurityManager_ProcessUrlAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetHostSecurityManager_QueryCustomPolicy_Proxy( 
    IInternetHostSecurityManager * This,
    /* [in] */ REFGUID guidKey,
    /* [size_is][size_is][out] */ BYTE **ppPolicy,
    /* [out] */ DWORD *pcbPolicy,
    /* [in] */ BYTE *pContext,
    /* [in] */ DWORD cbContext,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetHostSecurityManager_QueryCustomPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetHostSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0197 */
/* [local] */ 

#endif

// The zone manager maintains policies for a set of standard actions. 
// These actions are identified by integral values (called action indexes)
// specified below.

// Minimum legal value for an action    
#define URLACTION_MIN                                          0x00001000

#define URLACTION_DOWNLOAD_MIN                                 0x00001000
#define URLACTION_DOWNLOAD_SIGNED_ACTIVEX                      0x00001001
#define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX                    0x00001004
#define URLACTION_DOWNLOAD_CURR_MAX                            0x00001004
#define URLACTION_DOWNLOAD_MAX                                 0x000011FF

#define URLACTION_ACTIVEX_MIN                                  0x00001200
#define URLACTION_ACTIVEX_RUN                                  0x00001200
#define URLPOLICY_ACTIVEX_CHECK_LIST                           0x00010000
#define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY               0x00001201 // aggregate next four
#define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY                 0x00001202 //
#define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY               0x00001203 //
#define URLACTION_SCRIPT_OVERRIDE_SAFETY                       0x00001401 //
#define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY               0x00001204 //
#define URLACTION_ACTIVEX_TREATASUNTRUSTED                     0x00001205
#define URLACTION_ACTIVEX_CURR_MAX                             0x00001205
#define URLACTION_ACTIVEX_MAX                                  0x000013ff

#define URLACTION_SCRIPT_MIN                                   0x00001400
#define URLACTION_SCRIPT_RUN                                   0x00001400
#define URLACTION_SCRIPT_RESERVED_USE                          0x00001402
#define URLACTION_SCRIPT_SAFE_ACTIVEX                          0x00001405
#define URLACTION_CROSS_DOMAIN_DATA                            0x00001406
#define URLACTION_SCRIPT_PASTE                                 0x00001407
#define URLACTION_SCRIPT_CURR_MAX                              0x00001407
#define URLACTION_SCRIPT_MAX                                   0x000015ff

#define URLACTION_HTML_MIN                                     0x00001600
#define URLACTION_HTML_SUBMIT_FORMS                            0x00001601 // aggregate next two
#define URLACTION_HTML_SUBMIT_FORMS_FROM                       0x00001602 //
#define URLACTION_HTML_SUBMIT_FORMS_TO                         0x00001603 //
#define URLACTION_HTML_FONT_DOWNLOAD                           0x00001604
#define URLACTION_HTML_RESERVED_RUN                            0x00001605 
#define URLACTION_HTML_USERDATA_SAVE                           0x00001606
#define URLACTION_HTML_SUBFRAME_NAVIGATE                       0x00001607
#define URLACTION_HTML_META_REFRESH                            0x00001608
#define URLACTION_HTML_MIXED_CONTENT                           0x00001609
#define URLACTION_HTML_CURR_MAX                                0x00001609
#define URLACTION_HTML_MAX                                     0x000017ff

#define URLACTION_SHELL_MIN                                    0x00001800
#define URLACTION_SHELL_INSTALL_DTITEMS                        0x00001800
#define URLACTION_SHELL_MOVE_OR_COPY                           0x00001802
#define URLACTION_SHELL_FILE_DOWNLOAD                          0x00001803
#define URLACTION_SHELL_VERB                                   0x00001804
#define URLACTION_SHELL_WEBVIEW_VERB                           0x00001805
#define URLACTION_SHELL_CURR_MAX                               0x00001805
#define URLACTION_SHELL_MAX                                    0x000019ff

#define URLACTION_NETWORK_MIN                                  0x00001A00

#define URLACTION_CREDENTIALS_USE                              0x00001A00
#define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK        0x00000000
#define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER       0x00010000
#define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT     0x00020000
#define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY         0x00030000

#define URLACTION_AUTHENTICATE_CLIENT                          0x00001A01
#define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK          0x00000000
#define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE    0x00010000
#define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY           0x00030000


#define URLACTION_COOKIES                                      0x00001A02
#define URLACTION_COOKIES_SESSION                              0x00001A03

#define URLACTION_CLIENT_CERT_PROMPT                           0x00001A04

#define URLACTION_COOKIES_THIRD_PARTY                          0x00001A05
#define URLACTION_COOKIES_SESSION_THIRD_PARTY                  0x00001A06

#define URLACTION_NETWORK_CURR_MAX                             0x00001A06
#define URLACTION_NETWORK_MAX                                  0x00001Bff


// The following Infodelivery actions should have no default policies
// in the registry.  They assume that no default policy means fall
// back to the global restriction.  If an admin sets a policy per
// zone, then it overrides the global restriction.

#define URLACTION_INFODELIVERY_MIN                           0x00001D00
#define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS            0x00001D00
#define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS           0x00001D01
#define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS          0x00001D02
#define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS       0x00001D03
#define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS      0x00001D04
#define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS     0x00001D05
#define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING            0x00001D06
#define URLACTION_INFODELIVERY_CURR_MAX                      0x00001D06
#define URLACTION_INFODELIVERY_MAX                           0x00001Dff
#define URLACTION_CHANNEL_SOFTDIST_MIN                       0x00001E00
#define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS               0x00001E05
#define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT          0x00010000
#define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE          0x00020000
#define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL       0x00030000
#define URLACTION_CHANNEL_SOFTDIST_MAX                       0x00001Eff

// For each action specified above the system maintains
// a set of policies for the action. 
// The only policies supported currently are permissions (i.e. is something allowed)
// and logging status. 
// IMPORTANT: If you are defining your own policies don't overload the meaning of the
// loword of the policy. You can use the hiword to store any policy bits which are only
// meaningful to your action.

// Permissions 
#define URLPOLICY_ALLOW                0x00
#define URLPOLICY_QUERY                0x01
#define URLPOLICY_DISALLOW             0x03

// Notifications are not done when user already queried.
#define URLPOLICY_NOTIFY_ON_ALLOW      0x10
#define URLPOLICY_NOTIFY_ON_DISALLOW   0x20

// Logging is done regardless of whether user was queried.
#define URLPOLICY_LOG_ON_ALLOW         0x40
#define URLPOLICY_LOG_ON_DISALLOW      0x80

#define URLPOLICY_MASK_PERMISSIONS     0x0f
#define GetUrlPolicyPermissions(dw)        (dw & URLPOLICY_MASK_PERMISSIONS)
#define SetUrlPolicyPermissions(dw,dw2)    ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2))


#define URLPOLICY_DONTCHECKDLGBOX     0x100
// The ordinal #'s that define the predefined zones internet explorer knows about. 
// When we support user-defined zones their zone numbers should be between 
// URLZONE_USER_MIN and URLZONE_USER_MAX
#ifndef _LPINTERNETZONEMANAGER_DEFINED
#define _LPINTERNETZONEMANAGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0197_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0197_v0_0_s_ifspec;

#ifndef __IInternetZoneManager_INTERFACE_DEFINED__
#define __IInternetZoneManager_INTERFACE_DEFINED__

/* interface IInternetZoneManager */
/* [unique][helpstring][uuid][object][local] */ 

typedef /* [unique] */ IInternetZoneManager *LPURLZONEMANAGER;

typedef 
enum tagURLZONE
    {   URLZONE_PREDEFINED_MIN  = 0,
        URLZONE_LOCAL_MACHINE   = 0,
        URLZONE_INTRANET        = URLZONE_LOCAL_MACHINE + 1,
        URLZONE_TRUSTED = URLZONE_INTRANET + 1,
        URLZONE_INTERNET        = URLZONE_TRUSTED + 1,
        URLZONE_UNTRUSTED       = URLZONE_INTERNET + 1,
        URLZONE_PREDEFINED_MAX  = 999,
        URLZONE_USER_MIN        = 1000,
        URLZONE_USER_MAX        = 10000
    }   URLZONE;

typedef 
enum tagURLTEMPLATE
    {   URLTEMPLATE_CUSTOM      = 0,
        URLTEMPLATE_PREDEFINED_MIN      = 0x10000,
        URLTEMPLATE_LOW = 0x10000,
        URLTEMPLATE_MEDLOW      = 0x10500,
        URLTEMPLATE_MEDIUM      = 0x11000,
        URLTEMPLATE_HIGH        = 0x12000,
        URLTEMPLATE_PREDEFINED_MAX      = 0x20000
    }   URLTEMPLATE;


enum __MIDL_IInternetZoneManager_0001
    {   MAX_ZONE_PATH   = 260,
        MAX_ZONE_DESCRIPTION    = 200
    } ;
typedef /* [public] */ 
enum __MIDL_IInternetZoneManager_0002
    {   ZAFLAGS_CUSTOM_EDIT     = 0x1,
        ZAFLAGS_ADD_SITES       = 0x2,
        ZAFLAGS_REQUIRE_VERIFICATION    = 0x4,
        ZAFLAGS_INCLUDE_PROXY_OVERRIDE  = 0x8,
        ZAFLAGS_INCLUDE_INTRANET_SITES  = 0x10,
        ZAFLAGS_NO_UI   = 0x20,
        ZAFLAGS_SUPPORTS_VERIFICATION   = 0x40,
        ZAFLAGS_UNC_AS_INTRANET = 0x80
    }   ZAFLAGS;

typedef struct _ZONEATTRIBUTES
    {
    ULONG cbSize;
    WCHAR szDisplayName[ 260 ];
    WCHAR szDescription[ 200 ];
    WCHAR szIconPath[ 260 ];
    DWORD dwTemplateMinLevel;
    DWORD dwTemplateRecommended;
    DWORD dwTemplateCurrentLevel;
    DWORD dwFlags;
    }   ZONEATTRIBUTES;

typedef struct _ZONEATTRIBUTES *LPZONEATTRIBUTES;

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Sets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes as above.
// Returns S_OK or ??? if failed to write the zone attributes.
/* Registry Flags

    When reading, default behavior is:
        If HKLM allows override and HKCU value exists
            Then use HKCU value
            Else use HKLM value
    When writing, default behavior is same as HKCU
        If HKLM allows override
           Then Write to HKCU
           Else Fail
*/
typedef 
enum _URLZONEREG
    {   URLZONEREG_DEFAULT      = 0,
        URLZONEREG_HKLM = URLZONEREG_DEFAULT + 1,
        URLZONEREG_HKCU = URLZONEREG_HKLM + 1
    }   URLZONEREG;

// Gets a named custom policy associated with a zone;
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the callee allocated buffer for the policy byte blob; caller is
//   responsible for freeing this buffer eventually.
// pcbPolicy is the size of the byte blob returned.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if key is found and buffer allocated; ??? if key is not found (no buffer alloced).
// Sets a named custom policy associated with a zone;
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the caller allocated buffer for the policy byte blob.
// pcbPolicy is the size of the byte blob to be set.
// dwRegFlags determines if HTCU or HKLM is set.
// Returns S_OK or ??? if failed to write the zone custom policy.
// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ef-baf9-11ce-8c82-00aa004ba90b")
    IInternetZoneManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PromptAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateZoneEnumerator( 
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneAt( 
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyZoneEnumerator( 
            /* [in] */ DWORD dwEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTemplatePoliciesToZone( 
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IInternetZoneManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetZoneManagerVtbl;

    interface IInternetZoneManager
    {
        CONST_VTBL struct IInternetZoneManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManager_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetZoneManager_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define IInternetZoneManager_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define IInternetZoneManager_GetZoneAttributes(This,dwZone,pZoneAttributes)     \
    (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes)

#define IInternetZoneManager_SetZoneAttributes(This,dwZone,pZoneAttributes)     \
    (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes)

#define IInternetZoneManager_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)     \
    (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)

#define IInternetZoneManager_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)       \
    (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)

#define IInternetZoneManager_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)      \
    (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)

#define IInternetZoneManager_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)      \
    (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)

#define IInternetZoneManager_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)      \
    (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)

#define IInternetZoneManager_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)       \
    (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)

#define IInternetZoneManager_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)        \
    (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)

#define IInternetZoneManager_GetZoneAt(This,dwEnum,dwIndex,pdwZone)     \
    (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone)

#define IInternetZoneManager_DestroyZoneEnumerator(This,dwEnum) \
    (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum)

#define IInternetZoneManager_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)      \
    (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneAttributes_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwZone,
    /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);


void __RPC_STUB IInternetZoneManager_GetZoneAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_SetZoneAttributes_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwZone,
    /* [in] */ ZONEATTRIBUTES *pZoneAttributes);


void __RPC_STUB IInternetZoneManager_SetZoneAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneCustomPolicy_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwZone,
    /* [in] */ REFGUID guidKey,
    /* [size_is][size_is][out] */ BYTE **ppPolicy,
    /* [out] */ DWORD *pcbPolicy,
    /* [in] */ URLZONEREG urlZoneReg);


void __RPC_STUB IInternetZoneManager_GetZoneCustomPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_SetZoneCustomPolicy_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwZone,
    /* [in] */ REFGUID guidKey,
    /* [size_is][in] */ BYTE *pPolicy,
    /* [in] */ DWORD cbPolicy,
    /* [in] */ URLZONEREG urlZoneReg);


void __RPC_STUB IInternetZoneManager_SetZoneCustomPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneActionPolicy_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwZone,
    /* [in] */ DWORD dwAction,
    /* [size_is][out] */ BYTE *pPolicy,
    /* [in] */ DWORD cbPolicy,
    /* [in] */ URLZONEREG urlZoneReg);


void __RPC_STUB IInternetZoneManager_GetZoneActionPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_SetZoneActionPolicy_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwZone,
    /* [in] */ DWORD dwAction,
    /* [size_is][in] */ BYTE *pPolicy,
    /* [in] */ DWORD cbPolicy,
    /* [in] */ URLZONEREG urlZoneReg);


void __RPC_STUB IInternetZoneManager_SetZoneActionPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_PromptAction_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwAction,
    /* [in] */ HWND hwndParent,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ LPCWSTR pwszText,
    /* [in] */ DWORD dwPromptFlags);


void __RPC_STUB IInternetZoneManager_PromptAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_LogAction_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwAction,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ LPCWSTR pwszText,
    /* [in] */ DWORD dwLogFlags);


void __RPC_STUB IInternetZoneManager_LogAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_CreateZoneEnumerator_Proxy( 
    IInternetZoneManager * This,
    /* [out] */ DWORD *pdwEnum,
    /* [out] */ DWORD *pdwCount,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IInternetZoneManager_CreateZoneEnumerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_GetZoneAt_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwEnum,
    /* [in] */ DWORD dwIndex,
    /* [out] */ DWORD *pdwZone);


void __RPC_STUB IInternetZoneManager_GetZoneAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_DestroyZoneEnumerator_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwEnum);


void __RPC_STUB IInternetZoneManager_DestroyZoneEnumerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetZoneManager_CopyTemplatePoliciesToZone_Proxy( 
    IInternetZoneManager * This,
    /* [in] */ DWORD dwTemplate,
    /* [in] */ DWORD dwZone,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IInternetZoneManager_CopyTemplatePoliciesToZone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IInternetZoneManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0198 */
/* [local] */ 

#endif
EXTERN_C const IID CLSID_SoftDistExt;  
#ifndef _LPSOFTDISTEXT_DEFINED
#define _LPSOFTDISTEXT_DEFINED

#define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001
#define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002
#define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004
#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008


#define SOFTDIST_ADSTATE_NONE                0x00000000
#define SOFTDIST_ADSTATE_AVAILABLE       0x00000001
#define SOFTDIST_ADSTATE_DOWNLOADED      0x00000002
#define SOFTDIST_ADSTATE_INSTALLED           0x00000003

typedef struct _tagCODEBASEHOLD
    {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
    }   CODEBASEHOLD;

typedef struct _tagCODEBASEHOLD *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
    }   SOFTDISTINFO;

typedef struct _tagSOFTDISTINFO *LPSOFTDISTINFO;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0198_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0198_v0_0_s_ifspec;

#ifndef __ISoftDistExt_INTERFACE_DEFINED__
#define __ISoftDistExt_INTERFACE_DEFINED__

/* interface ISoftDistExt */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_ISoftDistExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")
    ISoftDistExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessSoftDist( 
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstCodeBase( 
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCodeBase( 
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncInstallDistributionUnit( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISoftDistExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftDistExt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftDistExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftDistExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoftDist )( 
            ISoftDistExt * This,
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstCodeBase )( 
            ISoftDistExt * This,
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCodeBase )( 
            ISoftDistExt * This,
            /* [in] */ LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncInstallDistributionUnit )( 
            ISoftDistExt * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh);
        
        END_INTERFACE
    } ISoftDistExtVtbl;

    interface ISoftDistExt
    {
        CONST_VTBL struct ISoftDistExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftDistExt_QueryInterface(This,riid,ppvObject)        \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISoftDistExt_AddRef(This)       \
    (This)->lpVtbl -> AddRef(This)

#define ISoftDistExt_Release(This)      \
    (This)->lpVtbl -> Release(This)


#define ISoftDistExt_ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)      \
    (This)->lpVtbl -> ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)

#define ISoftDistExt_GetFirstCodeBase(This,szCodeBase,dwMaxSize)        \
    (This)->lpVtbl -> GetFirstCodeBase(This,szCodeBase,dwMaxSize)

#define ISoftDistExt_GetNextCodeBase(This,szCodeBase,dwMaxSize) \
    (This)->lpVtbl -> GetNextCodeBase(This,szCodeBase,dwMaxSize)

#define ISoftDistExt_AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)      \
    (This)->lpVtbl -> AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE ISoftDistExt_ProcessSoftDist_Proxy( 
    ISoftDistExt * This,
    /* [in] */ LPCWSTR szCDFURL,
    /* [in] */ IXMLElement *pSoftDistElement,
    /* [out][in] */ LPSOFTDISTINFO lpsdi);


void __RPC_STUB ISoftDistExt_ProcessSoftDist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISoftDistExt_GetFirstCodeBase_Proxy( 
    ISoftDistExt * This,
    /* [in] */ LPWSTR *szCodeBase,
    /* [in] */ LPDWORD dwMaxSize);


void __RPC_STUB ISoftDistExt_GetFirstCodeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISoftDistExt_GetNextCodeBase_Proxy( 
    ISoftDistExt * This,
    /* [in] */ LPWSTR *szCodeBase,
    /* [in] */ LPDWORD dwMaxSize);


void __RPC_STUB ISoftDistExt_GetNextCodeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISoftDistExt_AsyncInstallDistributionUnit_Proxy( 
    ISoftDistExt * This,
    /* [in] */ IBindCtx *pbc,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD flags,
    /* [in] */ LPCODEBASEHOLD lpcbh);


void __RPC_STUB ISoftDistExt_AsyncInstallDistributionUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISoftDistExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0199 */
/* [local] */ 

STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi );
STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS );
#endif

#ifndef _LPDATAFILTER_DEFINED
#define _LPDATAFILTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0200_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0200_v0_0_s_ifspec;

#ifndef __IDataFilter_INTERFACE_DEFINED__
#define __IDataFilter_INTERFACE_DEFINED__

/* interface IDataFilter */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IDataFilter *LPDATAFILTER;


EXTERN_C const IID IID_IDataFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69d14c80-c18e-11d0-a9ce-006097942311")
    IDataFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoEncode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDecode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncodingLevel( 
            /* [in] */ DWORD dwEncLevel) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDataFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoEncode )( 
            IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *DoDecode )( 
            IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ LONG *plInBytesRead,
            /* [out] */ LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncodingLevel )( 
            IDataFilter * This,
            /* [in] */ DWORD dwEncLevel);
        
        END_INTERFACE
    } IDataFilterVtbl;

    interface IDataFilter
    {
        CONST_VTBL struct IDataFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataFilter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataFilter_AddRef(This)        \
    (This)->lpVtbl -> AddRef(This)

#define IDataFilter_Release(This)       \
    (This)->lpVtbl -> Release(This)


#define IDataFilter_DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)     \
    (This)->lpVtbl -> DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)

#define IDataFilter_DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)     \
    (This)->lpVtbl -> DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)

#define IDataFilter_SetEncodingLevel(This,dwEncLevel)   \
    (This)->lpVtbl -> SetEncodingLevel(This,dwEncLevel)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDataFilter_DoEncode_Proxy( 
    IDataFilter * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LONG lInBufferSize,
    /* [size_is][in] */ BYTE *pbInBuffer,
    /* [in] */ LONG lOutBufferSize,
    /* [size_is][out] */ BYTE *pbOutBuffer,
    /* [in] */ LONG lInBytesAvailable,
    /* [out] */ LONG *plInBytesRead,
    /* [out] */ LONG *plOutBytesWritten,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IDataFilter_DoEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDataFilter_DoDecode_Proxy( 
    IDataFilter * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LONG lInBufferSize,
    /* [size_is][in] */ BYTE *pbInBuffer,
    /* [in] */ LONG lOutBufferSize,
    /* [size_is][out] */ BYTE *pbOutBuffer,
    /* [in] */ LONG lInBytesAvailable,
    /* [out] */ LONG *plInBytesRead,
    /* [out] */ LONG *plOutBytesWritten,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IDataFilter_DoDecode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDataFilter_SetEncodingLevel_Proxy( 
    IDataFilter * This,
    /* [in] */ DWORD dwEncLevel);


void __RPC_STUB IDataFilter_SetEncodingLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDataFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0201 */
/* [local] */ 

#endif
#ifndef _LPENCODINGFILTERFACTORY_DEFINED
#define _LPENCODINGFILTERFACTORY_DEFINED
typedef struct _tagPROTOCOLFILTERDATA
    {
    DWORD cbSize;
    IInternetProtocolSink *pProtocolSink;
    IInternetProtocol *pProtocol;
    IUnknown *pUnk;
    DWORD dwFilterFlags;
    }   PROTOCOLFILTERDATA;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0201_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0201_v0_0_s_ifspec;

#ifndef __IEncodingFilterFactory_INTERFACE_DEFINED__
#define __IEncodingFilterFactory_INTERFACE_DEFINED__

/* interface IEncodingFilterFactory */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

typedef struct _tagDATAINFO
    {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
    }   DATAINFO;


EXTERN_C const IID IID_IEncodingFilterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70bdde00-c18e-11d0-a9ce-006097942311")
    IEncodingFilterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindBestFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEncodingFilterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncodingFilterFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncodingFilterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncodingFilterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindBestFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF);
        
        END_INTERFACE
    } IEncodingFilterFactoryVtbl;

    interface IEncodingFilterFactory
    {
        CONST_VTBL struct IEncodingFilterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncodingFilterFactory_QueryInterface(This,riid,ppvObject)      \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEncodingFilterFactory_AddRef(This)     \
    (This)->lpVtbl -> AddRef(This)

#define IEncodingFilterFactory_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEncodingFilterFactory_FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)      \
    (This)->lpVtbl -> FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)

#define IEncodingFilterFactory_GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF) \
    (This)->lpVtbl -> GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEncodingFilterFactory_FindBestFilter_Proxy( 
    IEncodingFilterFactory * This,
    /* [in] */ LPCWSTR pwzCodeIn,
    /* [in] */ LPCWSTR pwzCodeOut,
    /* [in] */ DATAINFO info,
    /* [out] */ IDataFilter **ppDF);


void __RPC_STUB IEncodingFilterFactory_FindBestFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEncodingFilterFactory_GetDefaultFilter_Proxy( 
    IEncodingFilterFactory * This,
    /* [in] */ LPCWSTR pwzCodeIn,
    /* [in] */ LPCWSTR pwzCodeOut,
    /* [out] */ IDataFilter **ppDF);


void __RPC_STUB IEncodingFilterFactory_GetDefaultFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEncodingFilterFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0202 */
/* [local] */ 

#endif
#ifndef _HITLOGGING_DEFINED
#define _HITLOGGING_DEFINED
// Logging-specific apis
BOOL WINAPI IsLoggingEnabledA(IN LPCSTR  pszUrl);                    
BOOL WINAPI IsLoggingEnabledW(IN LPCWSTR  pwszUrl);                  
#ifdef UNICODE                                                       
#define IsLoggingEnabled         IsLoggingEnabledW                   
#else                                                                
#define IsLoggingEnabled         IsLoggingEnabledA                   
#endif // !UNICODE                                                   
typedef struct _tagHIT_LOGGING_INFO
    {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
    }   HIT_LOGGING_INFO;

typedef struct _tagHIT_LOGGING_INFO *LPHIT_LOGGING_INFO;

BOOL WINAPI WriteHitLogging(IN LPHIT_LOGGING_INFO lpLogginginfo);    
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
    {
    CLSID clsid;
    IUnknown *pUnk;
    DWORD dwFlags;
    } ;
EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY; 
#endif
#ifndef _LPIWRAPPEDPROTOCOL_DEFINED
#define _LPIWRAPPEDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0202_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0202_v0_0_s_ifspec;

#ifndef __IWrappedProtocol_INTERFACE_DEFINED__
#define __IWrappedProtocol_INTERFACE_DEFINED__

/* interface IWrappedProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWrappedProtocol *LPIWRAPPEDPROTOCOL;


EXTERN_C const IID IID_IWrappedProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53c84785-8425-4dc5-971b-e58d9c19f9b6")
    IWrappedProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWrapperCode( 
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IWrappedProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrappedProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrappedProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrappedProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWrapperCode )( 
            IWrappedProtocol * This,
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWrappedProtocolVtbl;

    interface IWrappedProtocol
    {
        CONST_VTBL struct IWrappedProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrappedProtocol_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrappedProtocol_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IWrappedProtocol_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IWrappedProtocol_GetWrapperCode(This,pnCode,dwReserved) \
    (This)->lpVtbl -> GetWrapperCode(This,pnCode,dwReserved)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IWrappedProtocol_GetWrapperCode_Proxy( 
    IWrappedProtocol * This,
    /* [out] */ LONG *pnCode,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IWrappedProtocol_GetWrapperCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IWrappedProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0203 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0203_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0203_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [out] */ LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ STGMEDIUM *pstgmed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC *pformatetc,
    /* [in] */ RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ BYTE *pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub( 
    IBindHost * This,
    /* [unique][in] */ IMoniker *pMk,
    /* [unique][in] */ IBindCtx *pBC,
    /* [unique][in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\actasm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#include "list.h"
#include "helpers.h"

#define DEPENDENCY_HASH_TABLE_SIZE                     127

class CActivatedAssembly {
    public:
        CActivatedAssembly(IAssembly *pAsm, IAssemblyName *pName);
        ~CActivatedAssembly();

    public:
        IAssembly                            *_pAsm;
        IAssemblyName                        *_pName;
};

class CLoadContext : public IFusionLoadContext {
    public:
        CLoadContext(LOADCTX_TYPE ctxType);
        ~CLoadContext();

        static HRESULT Create(CLoadContext **ppLoadContext, LOADCTX_TYPE ctxType);

        // IUnknown

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IFusionLoadContext

        STDMETHODIMP_(LOADCTX_TYPE) GetContextType();

        // Other methods

        HRESULT CheckActivated(IAssemblyName *pName, IAssembly **ppAsm);
        HRESULT AddActivation(IAssembly *pAsm, IAssembly **ppAsmActivated);
        HRESULT RemoveActivation(IAssembly *pAsm);
        STDMETHODIMP Lock();
        STDMETHODIMP Unlock();

    private:
        HRESULT Init();

    private:
        LOADCTX_TYPE                          _ctxType;
        CRITICAL_SECTION                      _cs;
        DWORD                                 _cRef;
        List<CActivatedAssembly *>            _hashDependencies[DEPENDENCY_HASH_TABLE_SIZE];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\adl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#include "asmcache.h"
#include "clbind.h"
#include "list.h"
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
#include "dl.h"
#endif
#include "fuspriv.h"
#include "dbglog.h"

typedef enum tagADLSTATE {
    ADLSTATE_INITIALIZE,
    ADLSTATE_DOWNLOADING,
    ADLSTATE_ABORT,
    ADLSTATE_DOWNLOAD_COMPLETE,
    ADLSTATE_SETUP,
    ADLSTATE_COMPLETE_ALL,
    ADLSTATE_DONE
} ADLSTATE;

//
// CAssemblyDownload
//

class CAssemblyDownload {
    public:

        CAssemblyDownload(ICodebaseList *pCodebaseList, IDownloadMgr *pDLMgr,
                          CDebugLog *pdbglog, LONGLONG llFlags);
        virtual ~CAssemblyDownload();

        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        static HRESULT Create(CAssemblyDownload **ppadl,
                              IDownloadMgr *pDLMgr,
                              ICodebaseList *pCodebaseList,
                              CDebugLog *pdbglog,
                              LONGLONG llFlags);

        HRESULT AddClient(IAssemblyBindSink *pAsmBindSink, BOOL bCallStartBinding);
        HRESULT AddClient(CClientBinding *pclient, BOOL bCallStartBinding);

        HRESULT SetUrl(LPCWSTR pwzUrl);

        HRESULT KickOffDownload(BOOL bFirstDownload);
        HRESULT DownloadComplete(HRESULT hrResult, LPOLESTR pwzFileName, const FILETIME *pftLastMod,
                                 BOOL bTerminate);
        HRESULT DoSetup(LPOLESTR pwzFileName, const FILETIME *pftLastMod);
        HRESULT CompleteAll(IUnknown *pUnk);
        HRESULT ClientAbort(CClientBinding *pclient);
        HRESULT FatalAbort(HRESULT hrResult);

        HRESULT ReportProgress(ULONG ulStatusCode, ULONG ulProgress,
                               ULONG ulProgressMax, DWORD dwNotification,
                               LPCWSTR wzNotification,
                               HRESULT hrNotification);

        HRESULT PreDownload(BOOL bCallCompleteAll, void **ppv);

        HRESULT GetDownloadMgr(IDownloadMgr **ppDLMgr);
        HRESULT SetResult(HRESULT hrResult);
                               
    private:
        HRESULT Init();

        HRESULT RealAbort(CClientBinding *pclient);
        HRESULT PrepNextDownload(LPWSTR pwzNextCodebase, DWORD dwFlags);
        HRESULT DownloadNextCodebase();
        HRESULT DoSetupModule(LPOLESTR pwzFileName,
                              IAssemblyModuleImport **ppModImport);
        HRESULT DoSetupAssembly(LPOLESTR pwzFileName, IAssembly **ppAsm);
        HRESULT LookupFromGlobalCache(LPASSEMBLY *ppAsmOut);
        HRESULT CheckDuplicate();
        HRESULT GetNextCodebase(BOOL *pbIsFileUrl, LPWSTR wzFilePath,
                                DWORD cbLen);

    private:
        DWORD                                         _dwSig;
        LONG                                          _cRef;
        HRESULT                                       _hrResult;
        ADLSTATE                                      _state;
        List<CClientBinding *>                        _clientList;
        LPWSTR                                        _pwzUrl;
        IDownloadMgr                                 *_pDLMgr;
        ICodebaseList                                *_pCodebaseList;
        CDebugLog                                    *_pdbglog;
        CRITICAL_SECTION                              _cs;
        LONGLONG                                      _llFlags;
        BOOL                                          _bInitCS;
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
        COInetProtocolHook                           *_pHook;
        IOInetSession                                *_pSession;
        IOInetProtocol                               *_pProt;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asmcache.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#include <windows.h>
#include <winerror.h>
#include "fusionp.h"
#include "cache.h"

#ifndef _ASMCACHE_
#define _ASMCACHE_

#define STREAM_FORMAT_MANIFEST STREAM_FORMAT_COMPLIB_MANIFEST
#define STREAM_FORMAT_MODULE   STREAM_FORMAT_COMPLIB_MODULE

class CTransCache;
class CDebugLog;

// Top-level apis used internally by fusion.
HRESULT CopyAssemblyFile
    (IAssemblyCacheItem *pasm, LPCOLESTR pszSrcFile, DWORD dwFlags);

BOOL IsNewerFileVersion( LPWSTR pszNewManifestPath, LPWSTR pszExistingManifestPath, int *piNewer);
HRESULT ValidateAssembly(LPCTSTR pszManifestFilePath, IAssemblyName *pName);

// CAssemblyCache declaration.
class CAssemblyCache : public IAssemblyCache
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD (UninstallAssembly)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName, 
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pInfo, 
        /* [out, optional] */ ULONG *pulDisposition
        );
 
    STDMETHOD (QueryAssemblyInfo)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName,
        /* [in, out] */ ASSEMBLY_INFO *pAsmInfo
        );
 
    STDMETHOD (CreateAssemblyCacheItem)( 
        /* [in] */ DWORD dwFlags,
        /* [in] */ PVOID pvReserved,
        /* [out] */ IAssemblyCacheItem **ppAsmItem,
        /* [in, optional] */ LPCWSTR pszAssemblyName  // uncanonicalized, comma separted name=value pairs.
        );

    STDMETHOD (InstallAssembly)( // if you use this, fusion will do the streaming & commit.
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszManifestFilePath, 
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pInfo
        );



    STDMETHOD( CreateAssemblyScavenger) (
        /* [out] */ IUnknown **ppAsmScavenger
    );

    CAssemblyCache();
    ~CAssemblyCache();
private :
    DWORD _dwSig;
    LONG _cRef;
};


                       
#endif // ASMCACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asmenum.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef _ASMENUM_
#define _ASMENUM_

#include <fusionp.h>
#include "cache.h"
#include "enum.h"

// implementation of IAssemblyEnum
class CAssemblyEnum : public IAssemblyEnum
{
public:
    // static creation class
    static CAssemblyEnum* Create();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Main methods.
    STDMETHODIMP GetNextAssembly(LPVOID pvReserved,
        IAssemblyName **ppName, DWORD dwFlags);

    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IAssemblyEnum** ppEnum);

    CAssemblyEnum();
    ~CAssemblyEnum();

    HRESULT Init(IApplicationContext *pAppCtx, 
        IAssemblyName *pName, DWORD dwFlags);
    
private:
    DWORD          _dwSig;
    LONG           _cRef;

    CCache        *_pCache;
    CTransCache   *_pTransCache;
    //DWORD          _dwTransIdx;
    CEnumCache   *_pEnumR;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef ASM_H
#define ASM_H

#include "fusion.h"
#include "cache.h"

#define     ASM_ENTRY_TYPE_DOWNLOADED           0x00000001
#define     ASM_ENTRY_TYPE_WIN                  0x00000002
#define     ASM_ENTRY_TYPE_INCOMPLETE           0x00000010


#define IsDownloadedEntry(dwF)      (dwF & ASM_ENTRY_TYPE_DOWNLOADED )
#define SetDownloadedBit(dwF)       (dwF |= ASM_ENTRY_TYPE_DOWNLOADED )
#define IsAssemblyIncomplete(dwF)   (dwF & ASM_ENTRY_TYPE_INCOMPLETE)
#define SetAssemblyIncompleteBit(dwF)(dwF |= ASM_ENTRY_TYPE_INCOMPLETE)
#define IsWinAssembly(dwF)          (dwF & ASM_ENTRY_TYPE_WIN)
#define SetWinAssemblyBit(dwF)      (dwF |= ASM_ENTRY_TYPE_WIN)

typedef enum tag_CACHE_LOOKUP_TYPE {
    CLTYPE_NAMERES_CACHE        = 0x00000001,
    CLTYPE_GLOBAL_CACHE         = 0x00000002,
    CLTYPE_DOWNLOAD_CACHE       = 0x00000004
} CACHE_LOOKUP_TYPE;

class CDebugLog;
class CLoadContext;

STDAPI CreateAssemblyFromTransCacheEntry(CTransCache *pTransCache, 
    IAssemblyManifestImport *pManImport, IAssembly **ppAsm);

STDAPI CreateAssemblyFromManifestFile(LPCOLESTR szFileName, LPCOLESTR szCodebase, 
    FILETIME *pftCodebase, IAssembly **ppAssembly);

STDAPI CreateAssemblyFromManifestImport(IAssemblyManifestImport *pImport,
                                        LPCOLESTR szCodebase, FILETIME *pftCodebase,
                                        LPASSEMBLY *ppAssembly);

HRESULT CreateAssemblyFromCacheLookup(IApplicationContext *pAppCtx, IAssemblyName *pNameRef,
                                      IAssembly **ppAsm, CDebugLog *pdbglog);

class CAssembly : public IAssembly, public IServiceProvider
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Gets name def of assembly.
    // Delegates to IAssemblyManifestImport.
    STDMETHOD(GetAssemblyNameDef)( 
        /* out */ LPASSEMBLYNAME *ppName);

    // Enumerates dep. assemblies.
    // Delegates to IAssemblyManifestImport
    STDMETHOD(GetNextAssemblyNameRef)( 
        /* in  */ DWORD nIndex,
        /* out */ LPASSEMBLYNAME *ppName);

    // Enumerates modules.
    // Delegates to IAssemblyManifestImport
    STDMETHOD(GetNextAssemblyModule)( 
        /* in  */ DWORD nIndex,
        /* out */ LPASSEMBLY_MODULE_IMPORT *ppImport);

    // Get module by name
    // Delegates to IAssemblyManifestImport
    STDMETHOD(GetModuleByName)( 
        /* in  */ LPCOLESTR pszModuleName,
        /* out */ LPASSEMBLY_MODULE_IMPORT *ppImport);

    // Get manifest module cache path.
    // Delegates to IAssemblyManifestImport
    STDMETHOD(GetManifestModulePath)( 
        /* out     */ LPOLESTR  pszModulePath,
        /* in, out */ LPDWORD   pccModulePath);
        
    STDMETHOD(GetAssemblyPath)(
        /* out     */ LPOLESTR pStr,
        /* in, out */ LPDWORD lpcwBuffer);

    STDMETHOD(GetAssemblyLocation)(
        /* out     */ DWORD *pdwAsmLocation);

    STDMETHOD(GetFusionLoadContext)(IFusionLoadContext **ppLoadContext);

    // IServiceProvider

    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    CAssembly();
    ~CAssembly();

    HRESULT Init(LPASSEMBLY_MANIFEST_IMPORT pImport, 
        CTransCache *pTransCache, LPCOLESTR szCodebase, FILETIME *pftCodeBase);
    IAssemblyManifestImport *CAssembly::GetManifestInterface();

    HRESULT SetAssemblyLocation(DWORD dwAsmLoc);
    BOOL IsPendingDelete();

    // Activated assemblies

    HRESULT GetLoadContext(CLoadContext **pLoadContext);
    HRESULT SetLoadContext(CLoadContext *pLoadContext);

    HRESULT GetProbingBase(LPWSTR pwzProbingBase, DWORD *pccLength);
    HRESULT SetProbingBase(LPCWSTR pwzProbingBase);

    HRESULT InitDisabled(IAssemblyName *pName, LPCWSTR pwzRegisteredAsmPath);
    void SetFileHandle(HANDLE);

private:
    HRESULT SetBindInfo(IAssemblyName* pName) const;
    HRESULT PrepModImport(IAssemblyModuleImport *pModImport) const;
    
private:
    DWORD                      _dwSig;
    DWORD                      _cRef;
    LPASSEMBLY_MANIFEST_IMPORT _pImport;
    IAssemblyName             *_pName;
    CTransCache               *_pTransCache;
    LPWSTR                     _pwzCodebase;
    FILETIME                   _ftCodebase;
    DWORD                      _dwAsmLoc;
    BOOL                       _bDisabled;
    WCHAR                      _wzRegisteredAsmPath[MAX_PATH];
    WCHAR                      _wzProbingBase[MAX_URL_LENGTH];
    CLoadContext              *_pLoadContext;
    HANDLE                     _hFile;
    BOOL                       _bPendingDelete;
};

#endif // ASM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\adlmgr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef __ADLMGR_H_INCLUDED__
#define __ADLMGR_H_INCLUDED__

#include "dbglog.h"
#include "histinfo.h"

#define PREFIX_HTTP                        L"http://"
#define BINPATH_LIST_DELIMITER             L';'
#define SHADOW_COPY_DIR_DELIMITER          L';'

#define DLTYPE_WHERE_REF                             0x0000001
#define DLTYPE_QUALIFIED_REF                         0x0000002

// Extended appbase check flags

#define APPBASE_CHECK_DYNAMIC_DIRECTORY              0x00000001
#define APPBASE_CHECK_PARENT_URL                     0x00000002
#define APPBASE_CHECK_SHARED_PATH_HINT               0x00000004

extern const LPWSTR g_wzProbeExtension;

class CDebugLog;
class CHashNode;
class CPolicyCache;
class CLoadContext;

class CAsmDownloadMgr : public IDownloadMgr, public ICodebaseList
{
    public:
        CAsmDownloadMgr(IAssemblyName *pNameRefSource, IApplicationContext *pAppCtx,
                        ICodebaseList *pCodebaseList, CPolicyCache *pPolicyCache,
                        CDebugLog *pdbglog, LONGLONG llFlags);
        virtual ~CAsmDownloadMgr();

        static HRESULT Create(CAsmDownloadMgr **ppadm,
                              IAssemblyName *pNameRefSource,
                              IApplicationContext *pAppCtx,
                              ICodebaseList *pCodebaseList,
                              LPCWSTR wzBTOCodebase,
                              CDebugLog *pdbglog,
                              void *pvReserved,
                              LONGLONG llFlags);

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IDownloadMgr methods

        STDMETHODIMP PreDownloadCheck(void **ppv);
        STDMETHODIMP DoSetup(LPCWSTR wzSourceUrl, LPCWSTR wzFilePath,
                             const FILETIME *pftLastMod, IUnknown **ppUnk);
        STDMETHODIMP ProbeFailed(IUnknown **ppUnk);
        STDMETHODIMP IsDuplicate(IDownloadMgr *pIDLMgr);
        STDMETHODIMP LogResult();
        STDMETHODIMP DownloadEnabled(BOOL *pbEnabled);

        // ICodebaseList methods

        STDMETHODIMP AddCodebase(LPCWSTR wzCodebase, DWORD dwFlags);
        STDMETHODIMP RemoveCodebase(DWORD dwIndex);
        STDMETHODIMP GetCodebase(DWORD dwIndex, DWORD *pdwFlags, LPWSTR wzCodebase, DWORD *pcbCodebase);
        STDMETHODIMP GetCount(DWORD *pdwCount);
        STDMETHODIMP RemoveAll();

        // Helpers

        HRESULT GetDownloadIdentifier(DWORD *pdwDownloadType,
                                      LPWSTR *ppwzID);
        HRESULT GetAppCtx(IApplicationContext **ppAppCtx);

    private:
        HRESULT Init(LPCWSTR wzBTOCodebase, void *pvReserved);

        // Helpers
        HRESULT DoSetupRFS(LPCWSTR wzFilePath, FILETIME *pftLastModified,
                           LPCWSTR wzSourceUrl, BOOL bWhereRefBind,
                           BOOL bPrivateAsmVerify, BOOL *pbBindRecorded);
        HRESULT DoSetupPushToCache(LPCWSTR wzFilePath, LPCWSTR wzSourceUrl,
                                   FILETIME *pftLastModified,
                                   BOOL bWhereRefBind, BOOL bCopyModules,
                                   BOOL bPrivateAsmVerify,
                                   BOOL *pbBindRecorded);

#ifndef FEATURE_PAL // cab
        HRESULT SetupCAB(LPCWSTR wzFilePath, LPCWSTR wzSourceUrl, BOOL bWhereRefBind, BOOL *pbBindRecorded);
#endif // !FEATURE_PAL

        HRESULT ShadowCopyDirCheck(LPCWSTR wzSourceURL);
        HRESULT CheckRunFromSource(LPCWSTR wzSourceUrl, BOOL *pbRunFromSource);
        
#ifndef FEATURE_PAL // msi
        HRESULT MSIInstallAssembly(LPCWSTR wzContext, IAssembly **ppAsm);
        HRESULT SetupMSI(LPCWSTR wzFilePath);
#endif // !FEATURE_PAL

        HRESULT CreateAssembly(LPCWSTR szPath, LPCWSTR pszURL,
                               FILETIME *pftLastModTime,
                               BOOL bRunFromSource,
                               BOOL bWhereRef,
                               BOOL bPrivateAsmVerify,
                               BOOL bCopyModules,
                               BOOL *pbBindRecorded,
                               IAssembly **ppAsmOut);
        
        HRESULT GetAppCfgCodebaseHint(LPCWSTR pwzAppBase, LPWSTR *ppwzCodebaseHint);

        HRESULT LookupPartialFromGlobalCache(LPASSEMBLY *ppAsmOut, DWORD dwCmpMask);
        HRESULT LookupDownloadCacheAsm(IAssembly **ppAsm);
        HRESULT GetMRUDownloadCacheAsm(LPCWSTR pwzURL, IAssembly **ppAsm);

#ifdef FUSION_QUALIFYASSEMBLY_ENABLED
        HRESULT QualifyAssembly(IAssemblyName **ppNameQualified);
#endif

        HRESULT RecordBindHistory();
        HRESULT RecordInfo();

        // Probing URL generation
        HRESULT ConstructCodebaseList(LPCWSTR wzPolicyCodebase);
        HRESULT SetupDefaultProbeList(LPCWSTR wzAppBase,
                                      LPCWSTR wzProbeFileName,
                                      ICodebaseList *pCodebaseList,
                                      BOOL bCABProbe);
        HRESULT PrepBinPaths(LPWSTR *ppwzUserBinPathList);
        HRESULT PrepPrivateBinPath(LPWSTR *ppwzPrivateBinPath);
        HRESULT ConcatenateBinPaths(LPCWSTR pwzPath1, LPCWSTR pwzPath2,
                                    LPWSTR *ppwzOut);

        HRESULT ApplyHeuristics(const WCHAR *pwzHeuristics[],
                                const unsigned int uiNumHeuristics,
                                WCHAR *pwzValues[],
                                LPCWSTR wzPrefix,
                                LPCWSTR wzExtension,
                                LPCWSTR wzAppBaseCanonicalized,
                                ICodebaseList *pCodebaseList,
                                List<CHashNode *> aHashList[],
                                DWORD dwExtendedAppBaseFlags);
        HRESULT ExtractSubstitutionVars(WCHAR *pwzValues[]);
        HRESULT ExpandVariables(LPCWSTR pwzHeuristic, WCHAR *pwzValues[],
                                LPWSTR wzBuf, int iMaxLen);
        
        HRESULT GenerateProbeUrls(LPCWSTR wzBinPathList,
                                  LPCWSTR wzAppBase,
                                  LPCWSTR wzExt, LPWSTR pwzValues[],
                                  ICodebaseList *pCodebaseList,
                                  DWORD dwExtendedAppBaseFlags,
                                  LONGLONG dwProbingFlags);

        HRESULT CheckProbeUrlDupe(List<CHashNode *> paHashList[],
                                  LPCWSTR pwzSource) const;

        HRESULT SetAsmLocation(IAssembly *pAsm, DWORD dwAsmLoc);

    private:
        DWORD                                       _dwSig;
        LONG                                        _cRef;
        BOOL                                        _bCodebaseHintUsed;
        BOOL                                        _bReadCfgSettings;
        LONGLONG                                    _llFlags;
        LPWSTR                                      _wzBTOCodebase;
        LPWSTR                                      _wzSharedPathHint;
        AsmBindHistoryInfo                          _bindHistory;
        IAssemblyName                              *_pNameRefSource;
        IAssemblyName                              *_pNameRefPolicy;
        IApplicationContext                        *_pAppCtx;
        IAssembly                                  *_pAsm;
        ICodebaseList                              *_pCodebaseList;
        CPolicyCache                               *_pPolicyCache;
        CDebugLog                                  *_pdbglog;
        CLoadContext                               *_pLoadContext;
        LPWSTR                                      _pwzProbingBase;
        BOOL                                        _bLogResultCalled;
#ifdef FUSION_PARTIAL_BIND_DEBUG
        WCHAR                                       _wzParentName[2084];
        BOOL                                        _bGACPartial;
#endif
};

class CAssemblyCacheItem;

HRESULT CheckValidAsmLocation(IAssemblyName *pNameDef, LPCWSTR wzSourceUrl,
                              IApplicationContext *pAppCtx,
                              LPCWSTR pwzParentURL,
                              LPCWSTR pwzSharedPathHint,
                              CDebugLog *pdbglog);

HRESULT IsUnderAppBase(IApplicationContext *pAppCtx, LPCWSTR pwzAppBaseCanonicalized,
                       LPCWSTR pwzParentURLCanonicalized,
                       LPCWSTR pwzSharedPathHint, LPCWSTR pwzSource,
                       DWORD dwExtendedAppBaseFlags);

HRESULT RecoverDeletedBits(CAssemblyCacheItem *pAsmItem, LPWSTR szPath,
                           CDebugLog *pdbglog);


#ifndef FEATURE_PAL // msi
HRESULT CheckMSIInstallAvailable(IAssemblyName *pName, IApplicationContext *pAppCtx);

HRESULT MSIProvideAssemblyPeekEnum(IAssemblyName *pNamePeek, HKEY hkeyOpen,
                                   LPCWSTR wzSubKey);

HRESULT MSIProvideAssemblyPeek(IAssemblyName *pNamePeek, IApplicationContext *pAppCtx);

HRESULT MSIProvideAssemblyPrivatePeek(IAssemblyName *pNamePeek, IApplicationContext *pAppCtx,
                                      LPCWSTR wzSID);
HRESULT MSIProvideAssemblyGlobalPeek(IAssemblyName *pNamePeek, LPCWSTR wzSID);
#endif // !FEATURE_PAL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asmimprt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef ASMIMPRT_H
#define ASMIMPRT_H

#include "fusionp.h"
#include "list.h"

#define ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE 32

STDAPI DeAllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd);
STDAPI AllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd);

STDAPI
CreateAssemblyManifestImport(        
    LPCTSTR                        szManifestFilePath,
    LPASSEMBLY_MANIFEST_IMPORT    *ppImport);

class CAssemblyManifestImport : public IAssemblyManifestImport, public IMetaDataAssemblyImportControl
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(GetAssemblyNameDef)( 
        /* out */ LPASSEMBLYNAME *ppName);

    // BUGBUG - GetNextDepAssemblyNameRef
    STDMETHOD(GetNextAssemblyNameRef)( 
        /* in  */ DWORD nIndex,
        /* out */ LPASSEMBLYNAME *ppName);

    STDMETHOD(GetNextAssemblyModule)( 
        /* in  */ DWORD nIndex,
        /* out */ LPASSEMBLY_MODULE_IMPORT *ppImport);
        
    STDMETHOD(GetModuleByName)( 
        /* in  */ LPCOLESTR pszModuleName,
        /* out */ LPASSEMBLY_MODULE_IMPORT *ppImport);

    STDMETHOD(GetManifestModulePath)( 
        /* out     */ LPOLESTR  pszModulePath,
        /* in, out */ LPDWORD   pccModulePath);

    STDMETHODIMP ReleaseMetaDataAssemblyImport(IUnknown **ppUnk);

    CAssemblyManifestImport();
    ~CAssemblyManifestImport();

    HRESULT Init(LPCTSTR szManifestFilePath);
    HRESULT SetManifestModulePath(LPWSTR pszModulePath);

private:
    HRESULT CopyMetaData();
    HRESULT CleanModuleList();
    HRESULT CopyNameDef(IMetaDataAssemblyImport *pMDImport);
    HRESULT CopyModuleRefs(IMetaDataAssemblyImport *pMDImport);

private:
    DWORD                    _dwSig;
    DWORD                    _cRef;
    CRITICAL_SECTION         _cs;
    TCHAR                    _szManifestFilePath[MAX_PATH];
    DWORD                    _ccManifestFilePath;
    LPASSEMBLYNAME           _pName;
    IMetaDataAssemblyImport *_pMDImport;    
    PBYTE                    _pMap;
    mdFile                  *_rAssemblyModuleTokens;
    DWORD                    _cAssemblyModuleTokens;
    BOOL                     _bInitCS;
    List<IAssemblyModuleImport *> _listModules;


};
    

#endif // ASMIMPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\appctx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef ASM_CTX_H
#define ASM_CTX_H
#include "serialst.h"

// Private app context variable
#define ACTAG_DEVPATH_ACTASM_LIST          L"__FUSION_DEVPATH_ACTASM_LIST__"
#define ACTAG_APP_POLICY_MGR               L"__FUSION_POLICY_MGR__"
#define ACTAG_APP_CFG_DOWNLOAD_ATTEMPTED   L"__FUSION_APPCFG_DOWNLOAD_ATTEMPTED__"
#define ACTAG_APP_CFG_FILE_HANDLE          L"__FUSION_APPCFG_FILE_HANDLE__"
#define ACTAG_APP_CFG_DOWNLOAD_INFO        L"__FUSION_APPCFG_DOWNLOAD_INFO__"
#define ACTAG_APP_CFG_DOWNLOAD_CS          L"__FUSION_APPCFG_DOWNLOAD_CS__"
#define ACTAG_APP_DYNAMIC_DIRECTORY        L"__FUSION_DYNAMIC_DIRECTORY__"
#define ACTAG_APP_CACHE_DIRECTORY          L"__FUSION_APP_CACHE_DIRECTORY__"
#define ACTAG_APP_BIND_HISTORY             L"__FUSION_BIND_HISTORY_OBJECT__"
#define ACTAG_APP_CFG_INFO                 L"__FUSION_APP_CFG_INFO__"
#define ACTAG_HOST_CFG_INFO                L"__FUSION_HOST_CFG_INFO__"
#define ACTAG_ADMIN_CFG_INFO               L"__FUSION_ADMIN_CFG_INFO__"
#define ACTAG_APP_CACHE                    L"__FUSION_CACHE__"
#define ACTAG_APP_POLICY_CACHE             L"__FUSION_POLICY_CACHE__"
#define ACTAG_APP_CFG_PRIVATE_BINPATH      L"__FUSION_APP_CFG_PRIVATE_BINPATH__"
#define ACTAG_LOAD_CONTEXT_DEFAULT         L"__FUSION_DEFAULT_LOAD_CONTEXT__"
#define ACTAG_LOAD_CONTEXT_LOADFROM        L"__FUSION_LOADFROM_LOAD_CONTEXT__"
#define ACTAG_RECORD_BIND_HISTORY          L"__FUSION_RECORD_BIND_HISTORY__"

//#define ACTAG_APP_BASE_URL_UNESCAPED       L"__FUSION_APP_BASE_UNESCAPED__"

class CApplicationContext : public IApplicationContext
{

public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    // IApplicationContext methods

    // Sets associated IAssemblyName*
    STDMETHOD(SetContextNameObject)(
        /* in */ LPASSEMBLYNAME pName);

    // Retrieves associated IAssemblyName*
    STDMETHOD(GetContextNameObject)(
        /* out */ LPASSEMBLYNAME *ppName);

    // Generic blob set keyed by string.
    STDMETHOD(Set)( 
        /* in */ LPCOLESTR szName, 
        /* in */ LPVOID pvValue, 
        /* in */ DWORD cbValue,
        /* in */ DWORD dwFlags);

    // Generic blob get keyed by string.
    STDMETHOD(Get)( 
        /* in      */ LPCOLESTR szName,
        /* out     */ LPVOID  pvValue,
        /* in, out */ LPDWORD pcbValue,
        /* in      */ DWORD   dwFlags);
        
    STDMETHODIMP GetDynamicDirectory(LPWSTR wzDynamicDir, DWORD *pdwSize);
    STDMETHODIMP GetAppCacheDirectory(LPWSTR wzCacheDir, DWORD *pdwSize);
    STDMETHODIMP RegisterKnownAssembly(IAssemblyName *pName, LPCWSTR pwzAsmURL,
                                       IAssembly **ppAsmOut);
    STDMETHODIMP PrefetchAppConfigFile();
    STDMETHODIMP SxsActivateContext(ULONG_PTR *lpCookie);
    STDMETHODIMP SxsDeactivateContext(ULONG_PTR ulCookie);

    HRESULT Lock();
    HRESULT Unlock();

    CApplicationContext();
    ~CApplicationContext();

    HRESULT Init(LPASSEMBLYNAME pName);

private:
    HRESULT CreateActCtx(HANDLE *phActCtx);
    
private:

    // Class manages linked list of Entrys
    class Entry : public LIST_ENTRY
    {
    public:
        DWORD  _dwSig;
        LPTSTR _szName;
        LPBYTE _pbValue;
        DWORD  _cbValue;
        DWORD  _dwFlags;    

        // d'tor nukes Entries
        Entry();
        ~Entry();
        
    };

    // Creates entries.
    HRESULT CreateEntry(LPTSTR szName, LPVOID pvValue, 
        DWORD cbValue, DWORD dwFlags, Entry** pEntry);

    // Copies blob data, optionally freeing existing.
    HRESULT CopyData(Entry *pEntry, LPVOID pvValue, 
        DWORD cbValue, DWORD dwFlags, BOOL fFree);

    DWORD _dwSig;
    DWORD _cRef;
    CRITICAL_SECTION _cs;

    // Associated IAssemblyName*
    LPASSEMBLYNAME _pName;

    // The managed list.    
    SERIALIZED_LIST _List;

    BOOL _bInitialized;

};

BOOL InitSxsProcs();

#endif // ASM_CTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asmint.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#include <windows.h>
#include <winerror.h>
#include <wincrypt.h>
#include "fusionp.h"
#include "fusion.h"

#ifndef _ASMINT_H_
#define _ASMINT_H_

#define MAX_HASH_LEN  100

class CModuleHashNode
{

public :
    CModuleHashNode ();
    ~CModuleHashNode ( );
    void AddToList(CModuleHashNode **pHead);
    void DestroyList();
    static HRESULT DoIntegrityCheck( CModuleHashNode *pStreamList, IAssemblyManifestImport *pImport, BOOL *pbDownLoadComplete);
    HRESULT RectifyFileName( LPCTSTR pszPath, DWORD cbPath);
    void Init ( TCHAR *szPath, ALG_ID aAlgId, DWORD cbHash, BYTE *pHash);
    static BOOL FindMatchingHashInList ( CModuleHashNode *pStreamList, DWORD cbHash, PBYTE pHash, ALG_ID aAlgId, CModuleHashNode **ppMachingModNode );
    static BOOL HashesForAllModulesFound(CModuleHashNode *pStreamList);

private :
    DWORD   _dwSig;
    TCHAR   _szPath[MAX_PATH +1 ];
    DWORD   _cbHash;
    BYTE    _bHash[MAX_HASH_LEN];
    BOOL    _bHashGen;
    BOOL    _bHashFound;
    ALG_ID  _aAlgId;
    CModuleHashNode *_pNext;


};

HRESULT
DoesThisFileExistInManifest( IAssemblyManifestImport *pManifestImport, 
                             LPCTSTR szFilePath, 
                             BOOL *pbFileExistsInManifest );

HRESULT GetHash(LPCTSTR szFileName, ALG_ID iHashAlg, PBYTE pbHash, DWORD *pdwHash);
BOOL CompareHashs(DWORD cbHash, PBYTE pHash1, PBYTE pHash2);
#endif // _ASMINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asmitem.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#include <windows.h>
#include <winerror.h>
#include "fusionp.h"
#include "cache.h"
#include "asmstrm.h"
#include "fusion.h"
#include "asmint.h"


#ifndef _ASMITEM_
#define _ASMITEM_



class CAssemblyCacheItem : public IAssemblyCacheItem
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD (CreateStream)(
        /* [in] */ DWORD dwFlags,                         // For general API flags
        /* [in] */ LPCWSTR pszStreamName,                 // Name of the stream to be passed in
        /* [in] */ DWORD dwFormat,                        // format of the file to be streamed in.
        /* [in] */ DWORD dwFormatFlags,                   // format-specific flags
        /* [out] */ IStream **ppIStream,
        /* [in, optional] */ ULARGE_INTEGER *puliMaxSize  // Max size of the Stream.
        );
 
    STDMETHOD (Commit)(
        /* [in] */ DWORD dwFlags, // For general API flags like IASSEMBLYCACHEITEM _COMMIT_FLAG_REFRESH 
        /* [out, optional] */ ULONG *pulDisposition); 
 
    STDMETHOD (AbortItem)(); // If you have created IAssemblyCacheItem and don't plan to use it, its good idea to call AbortItem before releasing it.

    CAssemblyCacheItem();     
    ~CAssemblyCacheItem();

    HANDLE GetFileHandle();
    BOOL IsManifestFileLocked();

    static HRESULT Create(IApplicationContext *pAppCtx,
        IAssemblyName *pName, LPTSTR pszUrl, 
        FILETIME *pftLastMod, DWORD dwCacheFlags,
        IAssemblyManifestImport *pManImport,
        LPCWSTR pszAssemblyName,
        IAssemblyCacheItem **ppAsmItem);

    HRESULT Init(IApplicationContext *pAppCtx,
        IAssemblyName *pName, LPTSTR pszUrl,
        FILETIME *pftLastMod, DWORD dwCacheFlags,
        IAssemblyManifestImport *pManImport);

    void StreamDone (HRESULT);

    void AddStreamSize(DWORD dwFileSizeLow, DWORD dwFileSizeHigh);

    HRESULT AddToStreamHashList(CModuleHashNode *);

    HRESULT MoveAssemblyToFinalLocation( DWORD dwFlags, DWORD dwVerifyFlags );
    LPTSTR GetManifestPath();
    CTransCache *GetTransCacheEntry();

    HRESULT SetManifestInterface(IAssemblyManifestImport *pImport);
    IAssemblyManifestImport* GetManifestInterface();   

    HRESULT SetNameDef(IAssemblyName *pName);
    IAssemblyName *GetNameDef();


    HRESULT SetCustomData(LPBYTE pbCustom, DWORD cbCustom);

    TCHAR                    _szDestManifest[MAX_PATH]; // full path to manifest

    HRESULT CompareInputToDef();

    HRESULT VerifyDuplicate(DWORD dwVerifyFlags, CTransCache *pTC);

private:

    HRESULT CreateAsmHierarchy( 
        /* [in]  */  LPCOLESTR pszName);

    HRESULT CreateCacheDir( 
        /* [in]  */  LPCOLESTR pszCustomPath,
        /* [in]  */  LPCOLESTR pszName,
        /* [out] */  LPOLESTR pszAsmDir);
        

    DWORD                    _dwSig;
    LONG                     _cRef;                 // refcount
    HRESULT                  _hrError;              // error for rollback to check
    IAssemblyName*           _pName;                // assembly name object
    LONG                     _cStream;              // child refcount
    LONG                     _dwAsmSizeInKB;        // Size of Asm in KB, downloded in this round.
    TCHAR                    _szDir[MAX_PATH];      // assembly item directory
    DWORD                    _cwDir;                // path size including null
    TCHAR                    _szManifest[MAX_PATH]; // full path to manifest
    LPWSTR                   _pszAssemblyName;      // Display name of the assembly from Installer; has to match the def.
    IAssemblyManifestImport *_pManifestImport;      // Interface to Manifest.
    CModuleHashNode         *_pStreamHashList;      // Linked List of Modules hashes for integrity check
    LPTSTR                   _pszUrl;               // Codebase
    FILETIME                 _ftLastMod;            // Last mod time of Codebase.
    CTransCache             *_pTransCache;          // associated trans cache entry.
    DWORD                    _dwCacheFlags;         // TRANSCACHE_FLAGS*
    CCache                  *_pCache;
    LPBYTE                   _pbCustom;             // Custom data
    DWORD                    _cbCustom;             // Custom data size.
    HANDLE                   _hFile;
    BOOL                     _bNeedMutex;
    BOOL                     _bCommitDone;          // Final commit flag, controls cleanup
};

#endif // ASMITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\bsinkez.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef __BSINKEZ_H_INCLUDED__
#define __BSINKEZ_H_INCLUDED__

class CBindSinkEZ : public IAssemblyBindSink
{
    public:
        CBindSinkEZ();
        virtual ~CBindSinkEZ();

        // IUnknown methods
        STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
        STDMETHODIMP_(ULONG)    AddRef();
        STDMETHODIMP_(ULONG)    Release();

        // IAssemblyBindSink
        STDMETHODIMP  OnProgress(DWORD dwNotification, HRESULT hrNotification,
                                 LPCWSTR szNotification, DWORD dwProgress,
                                 DWORD dwProgressMax, IUnknown *pUnk);

        // Helpers
        HRESULT SetEventObj(HANDLE hEvent);


    private:
        DWORD                                    _dwSig;
        ULONG                                    _cRef;

    public:
        HRESULT                                  _hrResult;
        IUnknown                                *_pUnk;

    private:
        HANDLE                                   _hEvent;
        IAssemblyBinding                        *_pBinding;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asmstrm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef ASMSTRM_H
#define ASMSTRM_H

#include <windows.h>
#include "wincrypt.h"
#include <winerror.h>
#include <objbase.h>
#include "fusionp.h"
#include "asmitem.h"
#include "clbutils.h"

class CAssemblyCacheItem;

HRESULT DeleteAssemblyBits(LPCTSTR pszManifestPath);

HRESULT AssemblyCreateDirectory
   (OUT LPOLESTR pszDir, IN OUT LPDWORD pcwDir);

DWORD GetAssemblyStorePath (LPTSTR szPath);
HRESULT GetAssemblyStorePath(LPWSTR szPath, ULONG *pcch);
DWORD GetRandomDirName (LPTSTR szDirName);

class CAssemblyStream : public IStream
{
public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead);
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv, ULONG cb,
        ULONG FAR *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
        ULARGE_INTEGER FAR *plibNewPosition);
    STDMETHOD (CheckHash) ();
    STDMETHOD (AddSizeToItem) ();
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD dwCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag);
    STDMETHOD(Clone) (THIS_ LPSTREAM FAR *ppStm);

    CAssemblyStream (CAssemblyCacheItem* pParent);
    
    HRESULT Init (LPOLESTR pszPath, DWORD dwFormat);

    ~CAssemblyStream ();
    
private:

    void ReleaseParent (HRESULT hr);

    DWORD  _dwSig;
    LONG   _cRef;
    CAssemblyCacheItem* _pParent;
    HANDLE  _hf;
    TCHAR   _szPath[MAX_PATH];
    DWORD   _dwFormat;
    HCRYPTHASH      _hHash;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\asynchelp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(_FUSION_INC_ASYNCHELP_H_INCLUDED_)
#define _FUSION_INC_ASYNCHELP_H_INCLUDED_

#pragma once

class CAsyncContext : public OVERLAPPED
{
public:
    CAsyncContext() { }
    virtual ~CAsyncContext() { }

    // Public handler for async operations which are finished via an I/O completion port
    static VOID OnQueuedCompletion(HANDLE hCompletionPort, DWORD cbTransferred, ULONG_PTR ulCompletionKey, LPOVERLAPPED lpo)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(ulCompletionKey);
        INVOCATION_CONTEXT ic;

        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eCompletionPort;
        ic.m_dwErrorCode = ERROR_SUCCESS;
        ic.m_hCompletionPort = hCompletionPort;
        ic.m_lpo = lpo;
        ic.m_cbTransferred = cbTransferred;

        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via an APC.
    static VOID CALLBACK OnUserAPC(DWORD_PTR dwParam)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(dwParam);
        INVOCATION_CONTEXT ic;

        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eUserAPC;
        ic.m_dwErrorCode = ERROR_SUCCESS;

        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via a thread message
    static VOID OnThreadMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(wParam);
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eThreadMessage;
        ic.m_dwErrorCode = ERROR_SUCCESS;
        ic.m_uMsg = uMsg;
        ic.m_lParam = lParam;
        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via a window message
    static VOID OnWindowMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        CAsyncContext *pThis = reinterpret_cast<CAsyncContext *>(wParam);
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eWindowMessage;
        ic.m_dwErrorCode = ERROR_SUCCESS;
        ic.m_hwnd = hwnd;
        ic.m_uMsg = uMsg;
        ic.m_lParam = lParam;
        pThis->OnCompletion(ic);
    }

    // Public handler for async operations which are signalled via an overlapped completion routine
    // (e.g. ReadFileEx(), WriteFileEx()).
    static VOID CALLBACK OnOverlappedCompletion(DWORD dwErrorCode, DWORD cbTransferred, LPOVERLAPPED lpo)
    {
        CAsyncContext *pThis = static_cast<CAsyncContext *>(lpo);
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eOverlappedCompletionRoutine;
        ic.m_lpo = lpo;
        ic.m_dwErrorCode = dwErrorCode;
        ic.m_cbTransferred = cbTransferred;
        pThis->OnCompletion(ic);
    }

    // Call this member function when an asynch I/O completes immediately
    VOID OnImmediateCompletion(DWORD dwErrorCode, DWORD cbTransferred)
    {
        INVOCATION_CONTEXT ic;
        ic.m_it = CAsyncContext::INVOCATION_CONTEXT::eDirectCall;
        ic.m_lpo = this;
        ic.m_dwErrorCode = dwErrorCode;
        ic.m_cbTransferred = cbTransferred;
        this->OnCompletion(ic);
    }

protected:
    struct INVOCATION_CONTEXT
    {
        enum InvocationType
        {
            eCompletionPort,
            eUserAPC,
            eThreadMessage,
            eWindowMessage,
            eDirectCall,
            eOverlappedCompletionRoutine,
        } m_it;
        DWORD m_dwErrorCode;            // Win32 error code - valid for all invocation types
        HANDLE m_hCompletionPort;       // valid for: eCompletionPort
        LPOVERLAPPED m_lpo;             // valid for: eCompletionPort, eOverlappedCompletionRoutine, eDirectCall
        DWORD m_cbTransferred;          // valid for: eCompletionPort, eOverlappedCompletionRoutine, eDirectCall
        LPARAM m_lParam;                // valid for: eThreadMessage, eWindowMessage
        HWND m_hwnd;                    // valid for: eWindowMessage
        UINT m_uMsg;                    // valid for: eThreadMessage, eWindowMessage
    };

    // Derived classes override OnCompletion to do what's necessary.
    virtual VOID OnCompletion(const INVOCATION_CONTEXT &ric) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\cachergn.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "asmstrm.h"
#include "transprt.h"
#include <windows.h>
#include "dbglog.h"

#define TRANSPORT_CACHE_FLAGS_REGENERATION                  0x100
#define TRANSPORT_CACHE_REGENERATION_IDX_OFFSET             0x100
class CAssemblyCacheRegenerator
{
    protected:
        DWORD               _dwSig;
        CDebugLog           *_pdbglog;

        // for cross process locking
        HANDLE              _hRegeneratorMutex;
        
        // storage for lock that CDatabase::Lock returns
        HLOCK               _hlTransCacheLock[TRANSPORT_CACHE_IDX_TOTAL];
        HLOCK               _hlNameResLock;
        HLOCK               _hlNewGlobalCacheLock;
        
        // interface to temporary cache index files
        static IDatabase    *g_pDBNewCache[TRANSPORT_CACHE_IDX_TOTAL];
        static IDatabase    *g_pDBNewNameRes;

        // reentrancy protection flags
        BOOL                _fThisInstanceIsRegenerating;
        static DWORD         g_dwRegeneratorRunningInThisProcess;
        
        // which database are we regenerating
        DWORD               _dwCacheId;

        // we are regenerating NameRes (TRUE) TransCache (FALSE)
        BOOL                _fIsNameRes;
        
    public:        
        
        CAssemblyCacheRegenerator(CDebugLog *pdbglog, DWORD dwCacheId, BOOL fIsNameRes);
        ~CAssemblyCacheRegenerator();

        HRESULT Init();
        HRESULT Regenerate();
        static HRESULT SetSchemaVersion(DWORD dwNewMinorVersion, DWORD dwCacheId, BOOL fIsNameRes);
        
    private:
        static HRESULT CreateRegenerationTransCache(DWORD dwCacheId, CTransCache **CTransCache);                 
        HRESULT ProcessStoreDir();
        HRESULT RegenerateGlobalCache();
        HRESULT CreateEmptyCache();
        HRESULT ProcessSubDir(LPTSTR szCurrentDir, LPTSTR szSubDir);
        HRESULT LockFusionCache();
        HRESULT UnlockFusionCache();
        HRESULT CloseCacheRegeneratedDatabase();
        //temporary method for checking whether assembly is a ZAP assembly
        HRESULT IsZAPAssembly(LPTSTR szPath, LPBOOL pfZap);
        HRESULT DeleteFilesInDirectory(LPTSTR szDirectory);


    // CCache::InsertTransCacheEntry needs access to CreateRegenerationTransCache
    friend class CCache;
};

HRESULT RegenerateCache(CDebugLog *pdbg, DWORD dwCacheId, BOOL fIsNameRes);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\cblist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef __CBLIST_H_INCLUDED__
#define __CBLIST_H_INCLUDED__

#include "list.h"

class CCodebaseEntry {
    public:
        CCodebaseEntry();
        virtual ~CCodebaseEntry();

    public:
        LPWSTR                         _pwzCodebase;
        DWORD                          _dwFlags;
};

class CCodebaseList : public ICodebaseList
{
    public:
        CCodebaseList();
        virtual ~CCodebaseList();

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // ICodebaseList methods

        STDMETHODIMP AddCodebase(LPCWSTR wzCodebase, DWORD dwFlags);
        STDMETHODIMP RemoveCodebase(DWORD dwIndex);
        STDMETHODIMP GetCodebase(DWORD dwIndex, DWORD *pdwFlags, LPWSTR wzCodebase, DWORD *pcbCodebase);
        STDMETHODIMP GetCount(DWORD *pdwCount);
        STDMETHODIMP RemoveAll();

    private:
        DWORD                             _dwSig;
        DWORD                             _cRef;
        List<CCodebaseEntry *>            _listCodebase;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\cache.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef CACHE_H
#define CACHE_H


#include "transprt.h"
#include "appctx.h"


// ---------------------------------------------------------------------------
// CCache
// cache class
// ---------------------------------------------------------------------------
class CCache : IUnknown
{
    friend class CAssemblyEnum;
    friend class CScavenger;
    friend class CAssemblyCacheRegenerator;

    friend CTransCache;

public:
    // ctor, dtor
    CCache(IApplicationContext *pAppCtx);
    ~CCache();

    // IUnknown methods, implemented only for the Release mechanism in CAppCtx
    // RefCount is used though

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    static HRESULT Create(CCache **ppCache, IApplicationContext *pAppCtx);

    // Return the custom path or NULL if none
    LPCWSTR GetCustomPath();

    // Trans cache apis  ***********************************************************

    // Release global transport cache database.
    static VOID ReleaseTransCacheDatabase(DWORD dwCacheId);
    
    // Inserts entry to transport cache.
    HRESULT InsertTransCacheEntry(IAssemblyName *pName,
        LPTSTR szPath, DWORD dwKBSize, DWORD dwFlags,
        DWORD dwCommitFlags, DWORD dwPinBits,
        CTransCache **ppTransCache);

    // Retrieves transport cache entry from transport cache.
    HRESULT RetrieveTransCacheEntry(IAssemblyName *pName, 
        DWORD dwFlags, CTransCache **ppTransCache);

    // get trans cache entry from naming object.
    HRESULT TransCacheEntryFromName(IAssemblyName *pName, 
        DWORD dwFlags, CTransCache **ppTransCache);

    // Retrieves assembly in global cache with maximum
    // revision/build number based on name passed in.
    static HRESULT GetGlobalMax(IAssemblyName *pName, 
        IAssemblyName **ppNameGlobal, CTransCache **ppTransCache);

    // get assembly name object from transcache entry.
    static HRESULT NameFromTransCacheEntry(
        CTransCache *pTC, IAssemblyName **ppName);

    // Tests for presence of public key token
    static BOOL IsStronglyNamed(IAssemblyName *pName);

    // Tests for presence of custom data
    static BOOL IsCustom(IAssemblyName *pName);

    // Determines whether to create new or reuse DB opened with the custom path
    HRESULT CreateTransCacheEntry(DWORD dwCacheId, CTransCache **ppTransCache);

protected:
        
    // Determines cache index from name and flags.
    static HRESULT ResolveCacheIndex(IAssemblyName *pName, 
        DWORD dwFlags, LPDWORD pdwCacheId);

private:

    DWORD   _dwSig;

    // RefCount
    LONG    _cRef;

    // Last call result.
    HRESULT _hr;

    // Custom cache path, if specified
    WCHAR               _wzCachePath[MAX_PATH];
};

STDAPI NukeDownloadedCache();

STDAPI DeleteAssemblyFromTransportCache( LPCTSTR lpszCmdLine, DWORD *pDelCount );

#endif // CACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\ccstock.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable
#pragma warning(disable:4273)  // Dont' whine when we private-define a dllexport

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

//
// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

//
// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

//
// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)           StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)           StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)            StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)            StrCmpNW(sz1, sz2, cch)

//
// lstrcatnA and lstrcatnW are #defined here to StrCatBuff which is implemented
// in shlwapi. We do this here (and not in shlwapi.h or shlwapip.h) in case the
// kernel guys ever decided to implement this.
//
#define lstrcatnA(sz1, sz2, cchBuffSize)    StrCatBuffA(sz1, sz2, cchBuffSize)
#define lstrcatnW(sz1, sz2, cchBuffSize)    StrCatBuffW(sz1, sz2, cchBuffSize)
#ifdef UNICODE
#define lstrcatn lstrcatnW
#else
#define lstrcatn lstrcatnA
#endif // UNICODE

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#define IsInRange                   InRange

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

// ATOMICRELEASE
//
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#define ATOMICRELEASE(p) IUnknown_AtomicRelease((LPVOID*)&p)
#endif
#endif //ATOMICRELEASE

//
//  Helper macro for managing weak pointers to inner interfaces.
//  (It's the weak version of ATOMICRELEASE.)
//
//  The extra cast to (LPVOID *) is to keep C++ from doing strange
//  inheritance games when all I want to do is change the type.
//
#ifndef RELEASEINNERINTERFACE
#define RELEASEINNERINTERFACE(pOuter, p) \
        SHReleaseInnerInterface(pOuter, (IUnknown**)(LPVOID *)&(p))
#endif // RELEASEINNERINTERFACE

// For checking window charsets
#ifdef UNICODE
#define IsWindowTchar               IsWindowUnicode
#else  // !UNICODE
#define IsWindowTchar               !IsWindowUnicode
#endif // UNICODE

#if DBG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #if DBG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DBG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// BUGBUG (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;


// STOCKLIB util functions

// IsOS(): returns TRUE/FALSE if the platform is the indicated OS.

#define OS_WINDOWS      0           // windows vs. NT
#define OS_NT           1           // windows vs. NT
#define OS_WIN95        2           // Win95 or greater
#define OS_NT4          3           // NT4 or greater
#define OS_NT5          4           // NT5 or greater
#define OS_MEMPHIS      5           // Win98 or greater

STDAPI_(BOOL) IsOS(DWORD dwOS);

//
// round macro that rounds a to the next multiple of b.
//
#ifndef ROUNDUP
#define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#define ROUND_TO_CLUSTER ROUNDUP

//
// inline that does PathIsDotOrDotDot
//
__inline BOOL PathIsDotOrDotDotW(LPCWSTR pszPath)
{
    return ((pszPath[0] == L'.') && 
            ((pszPath[1] == L'\0') || ((pszPath[1] == L'.') && (pszPath[2] == L'\0'))));
}

__inline BOOL PathIsDotOrDotDotA(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

#ifdef UNICODE
#define PathIsDotOrDotDot PathIsDotOrDotDotW
#else
#define PathIsDotOrDotDot PathIsDotOrDotDotA
#endif


//
//  WindowLong accessor macros and other Win64 niceness
//

__inline LPVOID GetWindowPtr(HWND hWnd, int nIndex) {
    return (LPVOID)GetWindowLongPtr(hWnd, nIndex);
}

__inline LPVOID SetWindowPtr(HWND hWnd, int nIndex, LPVOID p) {
    return (LPVOID)SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)p);
}

#define IS_WM_CONTEXTMENU_KEYBOARD(lParam) ((DWORD)(lParam) == 0xFFFFFFFF)

//
//  CharUpperChar - Convert a single character to uppercase
//
__inline WCHAR CharUpperCharW(WCHAR c)
{
    return (WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharUpperCharA(CHAR c)
{
    return (CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)(c));
}

#ifdef UNICODE
#define CharUpperChar       CharUpperCharW
#else
#define CharUpperChar       CharUpperCharA
#endif

//
//  COM Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHCoInitialize();
//      ... do COM stuff ...
//      SHCoUninitialize(hrInit);
//
//  Notice:  Continue doing COM stuff even if SHCoInitialize fails.
//  It might fail if somebody else already CoInit'd with different
//  flags, but we don't want to barf under those conditions.
//

STDAPI SHCoInitialize(void);
#define SHCoUninitialize(hr) if (SUCCEEDED(hr)) CoUninitialize()


//
//  OLE Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHOleInitialize(pMalloc);
//      ... do COM stuff ...
//      SHOleUninitialize(hrInit);
//

#define SHOleInitialize(pMalloc) OleInitialize(pMalloc)

#define SHOleUninitialize(hr)   if (SUCCEEDED(hr))  OleUninitialize()


//
// Mirroring-Support APIs (astracted in \shell\lib\stock5\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

#ifdef USE_MIRRORING

BOOL  IsBiDiLocalizedSystem( void );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define IS_BIDI_LOCALIZED_SYSTEM()      IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()          Mirror_IsEnabledOS()
#define IS_WINDOW_RTL_MIRRORED(hwnd)    (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)         (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)    (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()       (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)        Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)          Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()        Mirror_MirrorProcessRTL()
#define DONTMIRRORBITMAP                dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW             dwExStyleRTLMirrorWnd
#define LAYOUT_PRESERVEBITMAP           dwPreserveBitmap

#else

#define IS_BIDI_LOCALIZED_SYSTEM()      FALSE
#define IS_MIRRORING_ENABLED()          FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)    FALSE
#define IS_DC_RTL_MIRRORED(hdc)         FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)    FALSE
#define IS_PROCESS_RTL_MIRRORED()       FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT()    
#define DONTMIRRORBITMAP                0L
#define RTL_MIRRORED_WINDOW             0L
#define LAYOUT_PRESERVEBITMAP           0L

#endif  // USE_MIRRROING


//
//====== Dynamic array functions  ================================================
//

//------------------------------------------------------------------------
// Dynamic key array
//
typedef struct _DKA * HDKA;     // hdka

HDKA   DKA_CreateA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszFirst, LPCSTR pszDefOrder, BOOL fDefault);
HDKA   DKA_CreateW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszFirst, LPCWSTR pszDefOrder, BOOL fDefault);

int    DKA_GetItemCount(HDKA hdka);

LPCSTR  DKA_GetKeyA(HDKA hdka, int iItem);
LPCWSTR DKA_GetKeyW(HDKA hdka, int iItem);

LONG   DKA_QueryValueA(HDKA hdka, int iItem, LPSTR szValue, LONG  * pcb);
LONG   DKA_QueryValueW(HDKA hdka, int iItem, LPWSTR szValue, LONG  * pcb);

DWORD  DKA_QueryOtherValueA(HDKA pdka, int iItem, LPCSTR pszName, LPSTR pszValue, LONG * pcb);
DWORD  DKA_QueryOtherValueW(HDKA pdka, int iItem, LPCWSTR pszName, LPWSTR pszValue, LONG * pcb);

void   DKA_Destroy(HDKA hdka);

#ifdef UNICODE
#define DKA_Create          DKA_CreateW
#define DKA_GetKey          DKA_GetKeyW
#define DKA_QueryValue      DKA_QueryValueW
#define DKA_QueryOtherValue DKA_QueryOtherValueW
#else
#define DKA_Create          DKA_CreateA
#define DKA_GetKey          DKA_GetKeyA
#define DKA_QueryValue      DKA_QueryValueA
#define DKA_QueryOtherValue DKA_QueryOtherValueA
#endif

//------------------------------------------------------------------------
// Dynamic class array
//
typedef struct _DCA * HDCA;     // hdca

HDCA DCA_Create();
void DCA_Destroy(HDCA hdca);
int  DCA_GetItemCount(HDCA hdca);
BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid);
const CLSID * DCA_GetItem(HDCA hdca, int i);

void DCA_AddItemsFromKeyA(HDCA hdca, HKEY hkey, LPCSTR pszSubKey);
void DCA_AddItemsFromKeyW(HDCA hdca, HKEY hkey, LPCWSTR pszSubKey);

#ifdef UNICODE
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyW
#else
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyA
#endif 

HRESULT DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, LPVOID * ppv);


#ifdef __cplusplus
};
#endif

#endif // RC_INVOKED

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\cacheutils.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _CACHEUTILS_H_
#define _CACHEUTILS_H_

HRESULT CheckAccessPermissions();

#include "transprt.h"

#define SIGNATURE_BLOB_LENGTH      0x80
#define SIGNATURE_BLOB_LENGTH_HASH 0x14
#define MVID_LENGTH                16

HRESULT SetCurrentUserPermissions();
BOOL IsCabFile(LPWSTR pszFileName);
BOOL IsGACWritable();
HRESULT GetAssemblyStagingPath(LPCTSTR pszCustomPath, DWORD dwCacheFlags,
                               BOOL bUser, LPTSTR pszPath, DWORD *pcchSize);

HRESULT CreateAssemblyDirPath( LPCTSTR pszCustomPath, DWORD dwInstaller, DWORD dwCacheFlags,
                               BOOL bUser, LPTSTR pszPath, DWORD *pcchSize);

HRESULT GetTempDBPath(LPTSTR pszFileName, LPTSTR pszFullPathBuf, DWORD cchBufSize);

HRESULT GetDBPath( LPWSTR pszCustomPath, DWORD dwCacheFlags, LPTSTR pszFullPathBuf, DWORD cchBufSize);

HRESULT GetPendingDeletePath(LPCTSTR pszCustomPath, DWORD dwCacheFlags,
                               LPTSTR pszPath, DWORD *pcchSize);

HRESULT SetPerUserDownloadDir();

HRESULT GetGACDir(LPWSTR *pszGACDir);
HRESULT GetZapDir(LPWSTR *pszZapDir);
HRESULT GetDownloadDir(LPWSTR *pszDownLoadDir);
HRESULT SetDownLoadDir();

HRESULT GetAssemblyParentDir( CTransCache *pTransCache, LPWSTR pszParentDir);
HRESULT ParseDirName( CTransCache *pTransCache, LPWSTR pszParentDir, LPWSTR pszAsmDir);
HRESULT RetrieveFromFileStore( CTransCache *pTransCache );

HRESULT ValidateAsmInstallFolderChars(LPWSTR pszFolderName);

HRESULT GetCacheDirsFromName(IAssemblyName *pName, 
    DWORD dwFlags, LPWSTR pszAsmTextName, LPWSTR pszSubDirName);

DWORD GetStringHash(LPCWSTR wzKey);
DWORD GetBlobHash(PBYTE pbKey, DWORD dwLen);

HRESULT StoreFusionInfo(IAssemblyName *pName, LPWSTR pszDir, DWORD *pdwFileSizeLow);
HRESULT GetFusionInfo(CTransCache *pTC, LPWSTR pszAsmDir);

HRESULT GetAssemblyKBSize(LPWSTR pszManifestPath, DWORD *pdwSizeinKB, LPFILETIME pftLastAccess, LPFILETIME pftCreation);

LPWSTR GetManifestFileNameFromURL(LPWSTR pszURL);
HRESULT GetCacheLoc(DWORD dwCacheFlags, LPWSTR *pszCacheLoc);

#endif _CACHEUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\cfgdata.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __CFGDATA_H_INCLUDED__
#define __CFGDATA_H_INCLUDED__

#include "list.h"

class CQualifyAssembly {
    public:
        CQualifyAssembly()
        : _pwzPartialName(NULL)
        , _pNameFull(NULL)
        {
        }

        virtual ~CQualifyAssembly()
        {
            SAFEDELETEARRAY(_pwzPartialName);
            SAFERELEASE(_pNameFull);
        }

    public:
        LPWSTR                            _pwzPartialName;
        IAssemblyName                    *_pNameFull;
};

class CBindingRedir {
    public:
        CBindingRedir()
        : _pwzVersionOld(NULL)
        , _pwzVersionNew(NULL)
        {
        }
            
        virtual ~CBindingRedir()
        {
            SAFEDELETEARRAY(_pwzVersionOld);
            SAFEDELETEARRAY(_pwzVersionNew);
        }

    public:
        LPWSTR                            _pwzVersionOld;
        LPWSTR                            _pwzVersionNew;
};

class CBindingRetarget
{
    public:
        CBindingRetarget()
        :_pwzVersionOld(NULL)
        ,_pwzVersionNew(NULL)
        ,_pwzPublicKeyTokenNew(NULL)
        ,_pwzNameNew(NULL)
        {
        }
        
        virtual ~CBindingRetarget()
        {
            SAFEDELETEARRAY(_pwzVersionOld);
            SAFEDELETEARRAY(_pwzVersionNew);
            SAFEDELETEARRAY(_pwzPublicKeyTokenNew);
            SAFEDELETEARRAY(_pwzNameNew);
        }

    public:
        LPWSTR                          _pwzVersionOld;
        LPWSTR                          _pwzVersionNew;
        LPWSTR                          _pwzPublicKeyTokenNew;
        LPWSTR                          _pwzNameNew;    
};

class CCodebaseHint {
    public:
        CCodebaseHint()
        : _pwzVersion(NULL)
        , _pwzCodebase(NULL)
        {
        }
       
        virtual ~CCodebaseHint()
        {
            SAFEDELETEARRAY(_pwzVersion);
            SAFEDELETEARRAY(_pwzCodebase);
        }

    public:
        LPWSTR                            _pwzVersion;
        LPWSTR                            _pwzCodebase;
};


class CAsmBindingInfo {
    public:
        CAsmBindingInfo()
        : _pwzName(NULL)
        , _pwzPublicKeyToken(NULL)
        , _pwzCulture(NULL)
        , _bApplyPublisherPolicy(TRUE)
        {
        }

        virtual ~CAsmBindingInfo()
        {
            LISTNODE                            pos = NULL;
            CBindingRedir                      *pRedir = NULL;
            CBindingRetarget                   *pRetarget = NULL; 
            CCodebaseHint                      *pCB = NULL;
            
            SAFEDELETEARRAY(_pwzName);
            SAFEDELETEARRAY(_pwzPublicKeyToken);
            SAFEDELETEARRAY(_pwzCulture);
            
            pos = _listBindingRedir.GetHeadPosition();
            while (pos) {
                pRedir = _listBindingRedir.GetNext(pos);
                SAFEDELETE(pRedir);
            }

            _listBindingRedir.RemoveAll();

            pos = _listBindingRetarget.GetHeadPosition();
            while (pos) {
                pRetarget= _listBindingRetarget.GetNext(pos);
                SAFEDELETE(pRetarget);
            }

            _listBindingRetarget.RemoveAll();

            pos = _listCodebase.GetHeadPosition();
            while (pos) {
                pCB = _listCodebase.GetNext(pos);
                SAFEDELETE(pCB);
            }

            _listCodebase.RemoveAll();
        }

    public:
        LPWSTR                            _pwzName;
        LPWSTR                            _pwzPublicKeyToken;
        LPWSTR                            _pwzCulture;
        BOOL                              _bApplyPublisherPolicy;
        List<CBindingRedir *>             _listBindingRedir;
        List<CBindingRetarget *>          _listBindingRetarget;
        List<CCodebaseHint *>             _listCodebase;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\clbind.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __CLBIND_H_INCLUDED__
#define __CLBIND_H_INCLUDED__

class CAssemblyDownload;

//
// CClientBinding
//

class CClientBinding : public IAssemblyBinding {
    public:
        CClientBinding(CAssemblyDownload *pad,
                       IAssemblyBindSink *pbindsink);
        virtual ~CClientBinding();

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid,void ** ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IAssemblyBinding methods
        
        STDMETHODIMP Control(HRESULT hrControl);
        STDMETHODIMP DoDefaultUI(HWND hWnd, DWORD dwFlags);

        // Helpers

        HRESULT CallStartBinding();
        HRESULT SwitchDownloader(CAssemblyDownload *padl);
        IAssemblyBindSink *GetBindSink();
        void SetPendingDelete(BOOL bPending);
        int LockCount();
        int Lock();
        int UnLock();
        BOOL IsPendingDelete();


    private:
        DWORD                                         _dwSig;
        ULONG                                         _cRef;
        IAssemblyBindSink                            *_pbindsink;
        CAssemblyDownload                            *_padl;
        ULONG                                         _cLocks;
        BOOL                                          _bPendingDelete;
};
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\cfgdl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef FUSION_CODE_DOWNLOAD_ENABLED
#pragma once

#define HTTP_RESPONSE_OK                                   200
#define HTTP_RESPONSE_UNAUTHORIZED                         401
#define HTTP_RESPONSE_FORBIDDEN                            403
#define HTTP_RESPONSE_FILE_NOT_FOUND                       404

class CDebugLog;

class CCfgProtocolHook :  public IOInetProtocolSink, 
                          public IOInetBindInfo,
                          public IHttpNegotiate,
                          public IServiceProvider,
                          public IAuthenticate
{
    public:
        CCfgProtocolHook(IOInetProtocol *pProt, IApplicationContext *pAppCtx, CDebugLog *pdbglog);
        virtual ~CCfgProtocolHook();
    
        static Create(CCfgProtocolHook **ppHook, IApplicationContext *pAppCtx,
                      CAssemblyDownload *padl, IOInetProtocol *pProt, CDebugLog *pdbglog);
    
        // IUnknown methods
        STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
    
        // IOInetProtocolSink methods
        STDMETHODIMP Switch( PROTOCOLDATA *pStateInfo);
        STDMETHODIMP ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP ReportData(DWORD grfBSCF, ULONG ulProgress,
                                ULONG ulProgressMax);
        STDMETHODIMP ReportResult(HRESULT hrResult, DWORD dwError,
                                  LPCWSTR wzResult);
    
        // IOInetBindInfo methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo);
        STDMETHODIMP GetBindString(ULONG ulStringType, LPOLESTR *ppwzStr,
                                   ULONG cEl, ULONG *pcElFetched);
    
        // IServiceProvider methods
        STDMETHODIMP QueryService(REFGUID guidService, REFIID riid,
                                  void **ppvObj);

        // IHttpNegotiate methods
        STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                                          DWORD dwReserved,
                                          LPWSTR *pszAdditionalHeaders);
    
        STDMETHODIMP OnResponse(DWORD dwResponseCode,
                                LPCWSTR szResponseHeaders,
                                LPCWSTR szRequestHeaders,
                                LPWSTR *pszAdditionalHeaders);

        // IAuthenticate methods

        STDMETHODIMP Authenticate(HWND *phwnd, LPWSTR *ppwzUserName,
                                  LPWSTR *ppwzPassword);

        // Helpers
        HRESULT AddClient(CAssemblyDownload *padl);

    private:
        HRESULT Init(CAssemblyDownload *padl);
    
    private:
        DWORD                                _dwSig;
        ULONG                                _cRefs;
        HRESULT                              _hrResult;
        IOInetProtocol                      *_pProt; 
        IApplicationContext                 *_pAppCtx;
        CDebugLog                           *_pdbglog;
        List<CAssemblyDownload *>            _listQueuedBinds;
        LPWSTR                               _pwzFileName;
};

struct AppCfgDownloadInfo {
    IOInetProtocol                       *_pProt;
    IOInetSession                        *_pSession;
    CCfgProtocolHook                     *_pHook;

    AppCfgDownloadInfo() {
        _pProt = NULL;
        _pSession = NULL;
        _pHook = NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\clbutils.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef CLBUTILS_H
#define CLBUTILS_H

#include "fusionp.h"

//-------------------------------------------------------------------
// PEHeaders
//-------------------------------------------------------------------
class PEHeaders
{
public:

    static IMAGE_NT_HEADERS * FindNTHeader(PBYTE hMapAddress);
    static IMAGE_COR20_HEADER * getCOMHeader(HMODULE hMod, IMAGE_NT_HEADERS *pNT);
    static PVOID Cor_RtlImageRvaToVa(IN PIMAGE_NT_HEADERS NtHeaders,
                                     IN PVOID Base,
                                     IN ULONG Rva);

    static PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(IN PIMAGE_NT_HEADERS NtHeaders,
                                                          IN PVOID Base,
                                                          IN ULONG Rva);
};



//-------------------------------------------------------------------
// CClbUtils
// Generic complib helper utils
//
//-------------------------------------------------------------------
class CClbUtils
{
private:

    // Checks for either stand-alone or embedded manifests
    // and constructs the meta data import interface.
    static HRESULT ConstructImportInterface(LPTSTR pszFilename, 
        IMetaDataAssemblyImport **ppImport, LPHANDLE phFile);

public:

   
    // Given a file which contains a complib manifest, return
    // an IMetaDataAssemblyImport interface pointer
    static HRESULT CreateMetaDataImport(LPCOLESTR pszFilename, 
        IMetaDataAssemblyImport **ppImport, LPHANDLE phFile);

};

#endif // CLBUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\crtsubst.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1996 rajeevd
        Created
--*/
#ifndef unix
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
extern "C" void RtlMoveMemory (void *, const void *, unsigned long);
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
//#undef StrChr


#define free(ptr)         FREE_MEMORY((HLOCAL) ptr)
#define malloc(size)      ((PVOID)ALLOCATE_MEMORY(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define _strstr           StrStr
#define strstr            StrStr
//#define StrChr            PrivateStrChr
#define _strchr           StrChr
#define strchr            StrChr
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNIC
#define _strnicmp         StrCmpNIC
#define strncmp           StrCmpNC
#define _strncmp          StrCmpNC

#undef itoa
#undef ultoa

//#define itoa(val,s,n)     _itoa(val,s,n)
//#define ultoa(val,s,n)    _ultoa(val,s,n)

 
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\debmacro.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(_FUSION_INC_DEBMACRO_H_INCLUDED_)
#define _FUSION_INC_DEBMACRO_H_INCLUDED_

#pragma once


#if DBG
#define ASSERT(x) if (!(x)) { DebugBreak(); }
#else
#define ASSERT(x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\enum.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef ENUM_H
#define ENUM_H
#include "fusionp.h"
#include "transprt.h"


class CEnumCache {
public:
    CEnumCache(BOOL bShowAll, LPWSTR pszCustomPath);
    ~CEnumCache();
    HRESULT Init(CTransCache* pQry, DWORD dwCmpMask);
    HRESULT Initialize(CTransCache* pQry, DWORD dwCmpMask);

    HRESULT GetNextRecord(CTransCache* pOutRecord);
    HRESULT GetNextAssemblyDir(CTransCache* pOutRecord);
private:
    DWORD       _dwSig;
    BOOL        _bShowAll; // including non-usable assemblies; meant for scavenger to delete.
    DWORD       _dwColumns;
    DWORD       _dwCmpMask;
    CTransCache*    _pQry;
    BOOL        _fAll;
    BOOL        _fAllDone;
    BOOL        _hParentDone;
    HANDLE      _hParentDir;
    HANDLE      _hAsmDir;
    WCHAR       _wzCustomPath[MAX_PATH+1];
    WCHAR       _wzCachePath[MAX_PATH+1];
    WCHAR       _wzParentDir[MAX_PATH+1];
    WCHAR       _wzAsmDir[MAX_PATH+1];
    BOOL                     _bNeedMutex;

};


#endif // ENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\dbglog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __DBGLOG_H_INCLUDED__
#define __DBGLOG_H_INCLUDED__

#include "list.h"

// Logging constants and globals


#define REG_VAL_FUSION_LOG_PATH              TEXT("LogPath")
#define REG_VAL_FUSION_LOG_DISABLE           TEXT("DisableLog")
#define REG_VAL_FUSION_LOG_LEVEL             TEXT("LoggingLevel")
#define REG_VAL_FUSION_LOG_FORCE             TEXT("ForceLog")
#define REG_VAL_FUSION_LOG_FAILURES          TEXT("LogFailures")
#define REG_VAL_FUSION_LOG_RESOURCE_BINDS    TEXT("LogResourceBinds")

extern DWORD g_dwDisableLog;
extern DWORD g_dwLogLevel;
extern DWORD g_dwForceLog;

// Debug Output macros (for easy compile-time disable of logging)

#ifdef FUSION_RETAIL_LOGGING

#define DEBUGOUT(pdbglog, dwLvl, pszLogMsg)  if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg); }
#define DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1); }
#define DEBUGOUT2(pdbglog, dwLvl, pszLogMsg, param1, param2) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2); }
#define DEBUGOUT3(pdbglog, dwLvl, pszLogMsg, param1, param2, param3) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3); }
#define DEBUGOUT4(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3, param4); }
#define DEBUGOUT5(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4, param5) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3, param4, param5); }

#define DUMPDEBUGLOG(pdbglog, dwLvl, hr) if (!g_dwDisableLog && pdbglog) { pdbglog->DumpDebugLog(dwLvl, hr); }

#else

#define DEBUGOUT(pdbglog, dwLvl, pszLogMsg)
#define DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1)
#define DEBUGOUT2(pdbglog, dwLvl, pszLogMsg, param1, param2)
#define DEBUGOUT3(pdbglog, dwLvl, pszLogMsg, param1, param2, param3) 
#define DEBUGOUT4(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4) 
#define DEBUGOUT5(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4, param5) 

#define DUMPDEBUGLOG(pdbglog, dwLvl, hr)

#endif

#define MAX_DBG_STR_LEN                 1024
#define MAX_DATE_LEN                    128
#define DEBUG_LOG_HTML_START            L"<html><pre>\r\n"
#define DEBUG_LOG_HTML_META_LANGUAGE    L"<meta http-equiv=\"Content-Type\" content=\"charset=unicode-1-1-utf-8\">"
#define DEBUG_LOG_MARK_OF_THE_WEB       L"<!-- saved from url=(0015)assemblybinder: -->"
#define DEBUG_LOG_HTML_END              L"\r\n</pre></html>"
#define DEBUG_LOG_NEW_LINE              "\r\n"

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { FUSION_DELETE_SINGLETON((p)); (p) = NULL; };

#undef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { FUSION_DELETE_ARRAY((p)); (p) = NULL; };

class CDebugLogElement {
    public:
        CDebugLogElement(DWORD dwDetailLvl);
        virtual ~CDebugLogElement();

        static HRESULT Create(DWORD dwDetailLvl, LPCWSTR pwzMsg,
                              BOOL bEscapeEntities,
                              CDebugLogElement **ppLogElem);
        HRESULT Init(LPCWSTR pwzMsg, BOOL bEscapeEntities);


        HRESULT Dump(HANDLE hFile);

    public:
        WCHAR                               *_pszMsg;
        DWORD                                _dwDetailLvl;
};

class CDebugLog : public IFusionBindLog {
    public:
        CDebugLog();
        virtual ~CDebugLog();

        static HRESULT Create(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName,
                              CDebugLog **ppdl);

        // IUnknown methods
        
        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IFusionBindLog methods

        STDMETHODIMP GetResultCode();
        STDMETHODIMP GetBindLog(DWORD dwDetailLevel, LPWSTR pwzDebugLog,
                                DWORD *pcbDebugLog);

        // CDebugLog functions
        
        HRESULT SetAsmName(LPCWSTR pwzAsmName);
        HRESULT SetResultCode(HRESULT hr);
        HRESULT DebugOut(DWORD dwDetailLvl, DWORD dwResId, ...);
        HRESULT LogMessage(DWORD dwDetailLvl, LPCWSTR wzDebugStr, BOOL bPrepend, BOOL bEscapeEntities);
        HRESULT DumpDebugLog(DWORD dwDetailLvl, HRESULT hrLog);
        
    private:
        HRESULT CreateLogFile(HANDLE *phFile, LPCWSTR wzFileName,
                              LPCWSTR wzEXEName, HRESULT hrLog);
        HRESULT CloseLogFile(HANDLE *phFile);
        HRESULT Init(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName);

    private:
        List<CDebugLogElement *>                   _listDbgMsg;
        HRESULT                                    _hrResult;
        long                                       _cRef;
        DWORD                                      _dwNumEntries;
        LPWSTR                                     _pwzAsmName;
        BOOL                                       _bLogToWininet;
        WCHAR                                      _szLogPath[MAX_PATH];
        LPWSTR                                     _wzEXEName;
        BOOL                                       _bWroteDetails;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\dl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef FUSION_CODE_DOWNLOAD_ENABLED

#pragma once

#define MAX_TEMP_DIRECTORIES                               256
#define MAX_READ_BUFFER_SIZE                               1024
#define MAX_SIZE_SECURITY_ID                               512


#define HTTP_RESPONSE_OK                                   200
#define HTTP_RESPONSE_UNAUTHORIZED                         401
#define HTTP_RESPONSE_FORBIDDEN                            403
#define HTTP_RESPONSE_FILE_NOT_FOUND                       404

class CDebugLog;

class COInetProtocolHook :  public IOInetProtocolSink, 
                            public IOInetBindInfo,
                            public IHttpNegotiate,
                            public IServiceProvider,
                            public IAuthenticate
{
    public:
        COInetProtocolHook(CAssemblyDownload *pad,
                           IOInetProtocol *pProt,
                           CDebugLog *);
        virtual ~COInetProtocolHook();
    
        static Create(COInetProtocolHook **ppHook, CAssemblyDownload *pad,
                      IOInetProtocol *pProt, LPCWSTR pwzUrlOriginal, CDebugLog *pdbglog);
    
        // IUnknown methods
        STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
    
        // IOInetProtocolSink methods
        STDMETHODIMP Switch(PROTOCOLDATA *pStateInfo);
        STDMETHODIMP ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP ReportData(DWORD grfBSCF, ULONG ulProgress,
                                ULONG ulProgressMax);
        STDMETHODIMP ReportResult(HRESULT hrResult, DWORD dwError,
                                  LPCWSTR wzResult);
    
        // IOInetBindInfo methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo);
        STDMETHODIMP GetBindString(ULONG ulStringType, LPOLESTR *ppwzStr,
                                   ULONG cEl, ULONG *pcElFetched);
    
        // IServiceProvider methods
        STDMETHODIMP QueryService(REFGUID guidService, REFIID riid,
                                  void **ppvObj);

        // IHttpNegotiate methods
        STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                                          DWORD dwReserved,
                                          LPWSTR *pszAdditionalHeaders);

        // IAuthenticate methods
        STDMETHODIMP Authenticate(HWND *phwnd, LPWSTR *ppwzUsername,
                                  LPWSTR *ppwzPassword);
    
        STDMETHODIMP OnResponse(DWORD dwResponseCode,
                                LPCWSTR szResponseHeaders,
                                LPCWSTR szRequestHeaders,
                                LPWSTR *pszAdditionalHeaders);
    private:
        HRESULT Init(LPCWSTR pwzUrlOriginal);
    
    private:
        DWORD                           _dwSig;
        ULONG                           _cRefs;
        HRESULT                         _hrResult;
        IOInetProtocol                 *_pProt; 
        CAssemblyDownload              *_padl;
        LPWSTR                          _pwzFileName;
        BOOL                            _bReportBeginDownload;
        DWORD                           _cbTotal;
        BOOL                            _bSelfAborted;
        FILETIME                        _ftHttpLastMod;
        BYTE                            _abSecurityId[MAX_SIZE_SECURITY_ID];
        DWORD                           _cbSecurityId;
        LPWSTR                          _pwzUrlOriginal;
        CDebugLog                      *_pdbglog;
        IInternetSecurityManager       *_pSecurityManager;
        BOOL                            _bCrossSiteRedirect;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\disk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#ifndef _DISK_H_

#define _DISK_H_

BOOL GetDiskInfoA(PSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvailable, PDWORDLONG pdlTotal);
#define GetDiskInfo GetDiskInfoA

typedef VOID (WINAPI *PFN)();

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn);
HRESULT GetFileSizeRoundedToCluster(HANDLE hFile, PDWORD pdwSizeLow, PDWORD pdwSizeHigh);

HRESULT GetAvailableSpaceOnDisk(PDWORD pdwFree, PDWORD pdwTotal);

#endif // _DISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\fstream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __FSTREAM_H_INCLUDED__
#define __FSTREAM_H_INCLUDED__

class CFileStream : public IStream
{
    public:
        CFileStream();
        virtual ~CFileStream();

        HRESULT OpenForRead(LPCWSTR wzFilePath);

        // IUnknown methods:
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

        // ISequentialStream methods:
        STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
        STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);
    
        // IStream methods:
        STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
        STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
        STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
        STDMETHODIMP Commit(DWORD grfCommitFlags);
        STDMETHODIMP Revert();
        STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
        STDMETHODIMP Clone(IStream **ppIStream);

    private:
        BOOL Close();

    private:
        DWORD                               _cRef;
        HANDLE                              _hFile;
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\fdi.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***    types.h  - Common defines for FCI/FDI stuff -- goes into FCI/FDI.H
 *
 *  Microsoft Confidential
 *  All Rights Reserved.
 *
 *  History:
 *      03-Mar-1993 chuckst Merged from other files
 *      08-Mar-1994 bens    Changed symbol to control recursive include
 *      09-Mar-1994 bens    Cleanups for RESERVE modifications
 *      16-Mar-1994 bens    Nuke padlong()
 *      21-Mar-1994 bens    Spruce up comments
 *      22-Mar-1994 bens    Add BIT16 test so we can build 16 or 32 bit!
 *      26-May-1994 bens    Added Quantum compression definitions
 */

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#pragma warning(disable:4121)

//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif



#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI
#ifndef unix
#pragma pack(4)
#endif /* unix */
//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif

HRESULT Extract(LPCSTR lpCabName, LPCWSTR lpUniquePath);

/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  (16-bit clients please note -- the size is a ULONG, so you may need
 *  to write a wrapper routine for halloc!).  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           Diamond/FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    tcompXXX - Diamond compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))


//** Revert to default structure packing
#ifndef unix
#pragma pack()
#endif /* unix */
#endif // !INCLUDED_TYPES_FCI_FDI
/***    fdi_int.h - Diamond File Decompression Interface definitions
 *                      
 *      Microsoft Confidential
 *
 *  Author:
 *      Chuck Strouss, Benjamin W. Slivka
 *
 *  History:
 *      30-Nov-1993 chuckst Created
 *      21-Dec-1993 bens    Updated with comments from 12/21/93 design review
 *      09-Mar-1994 bens    Add new error code
 *      17-Mar-1994 bens    Specify structure packing explicitly
 *      21-Mar-1994 bens    Spruce up comments
 *      25-Mar-1994 bens    Add fdintCABINET_INFO notification
 *      31-Mar-1994 bens    Clarify handling of open files when errors occur
 *      01-Apr-1994 bens    Add FDIIsCabinet() function.
 *      07-Apr-1994 bens    Add Decryption interfaces; remove fdintPROGRESS
 *      11-Apr-1994 bens    Add more guidance on how to respond to FDI errors.
 *      13-Apr-1994 bens    Add date & time & attribs to fdintCOPY_FILE
 *      18-Apr-1994 bens    Changed CDECL to DIAMONDAPI
 *      05-May-1994 bens    Clarified error handling (billhu/alanr/migueldc)
 *      11-May-1994 bens    Added setId/iCabinet to fdintNEXT_CABINET
 *      07-Jul-1994 bens    Support Quantum virtual file -- PLEASE note the
 *                              comments about PFNOPEN/PFNCLOSE changes, and
 *                              about reserving memory, if necessary, before
 *                              calling FDICreate()!
 *      19-Aug-1994 bens    Add cpuType parameter to FDICreate().
 *      03-Apr-1995 jeffwe  Added chaining indicators to FDICABINETINFO
 *
 *
 *  ATTENTION:
 *      This is the only documentation on the Diamond File Decompression
 *      Interface (FDI).  Please read it carefully, as there are some subtle
 *      points in FDI that are carefully explained below.
 *
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since Diamond concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but Diamond does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since Diamond compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require Diamond to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      Diamond cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint,...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *                  //NOTE: Be sure to see the (sample) code in EXTRACT.C
 *                  //      for an example of how to do this!
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

#ifndef INCLUDED_FDI
#define INCLUDED_FDI    1

//** Specify structure packing explicitly for clients of FDI
#ifndef unix
#pragma pack(4)
#endif /* unix */

/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of Diamond used to
        //              create the cabinet and the FDI. LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinet
        //              in a set.  Diamond will only generate cabinet sets
        //              with these properties.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When DIAMOND.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT                        // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    }
#ifdef unix 
MWUNION_TAG
#endif /* unix */
;
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          Diamond will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    char FAR *psz1;
    char FAR *psz2;
    char FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    int       hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET               // File continued to next cabinet
} FDINOTIFICATIONTYPE; /* fdint */

typedef int (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                           PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) int FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                              PFDINOTIFICATION    pfdin)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *
 *  SPECIAL NOTE FOR QUANTUM DECOMPRESSION:
 *      When using Quantum compression, at compress time (with Diamond)
 *      you specify how much memory Quantum requires at *decompress* time
 *      to store the decompression history buffer.  This can be as large
 *      as *2Mb*, and in an MS-DOS environment, for example, this much
 *      memory may not be available (certainly not under 640K!).  To permit
 *      large CompressionMemory settings on any machine, the Quantum
 *      decompressor will attempt to create a "spill file" if there is not
 *      sufficient memory available.
 *
 *      For PFNOPEN, a special pszFile parameter is passed to indicate that
 *      a temporary "spill file" is requested.  The name passed is "*", and
 *      you should cast the pszFile parameter to an FDISPILLFILE pointer,
 *      and get the requested file size.  You then need to create a file
 *      of the specified size with read/write access, save the file name and
 *      handle for later use by PFNCLOSE, and then return the handle.  If
 *      you cannot create the file of the specified size, you should return
 *      an error (-1).  This file should be placed on a fast local hard disk,
 *      to maximize the speed of decompression.
 *
 *      For PFNCLOSE, you should check the handle to see if it the spill file
 *      created previously by PFNOPEN (FDI will create at most one spill file
 *      per FDICreate() call).  If it is the spill file handle, you should
 *      close the handle and then delete the file, using the file name you
 *      saved when you created the spill file in PFNOPEN.
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);

#ifndef unix
#pragma pack (1)
#endif /* unix */
/** FDISPILLFILE - Pass as pszFile on PFNOPEN to create spill file
 *
 *  ach    - A two byte string to signal to PFNOPEN that a spill file is
 *           requested.  Value is '*','\0'.
 *  cbFile - Required spill file size, in bytes.
 */
typedef struct {
    char    ach[2];                 // Set to { '*', '\0' }
    long    cbFile;                 // Required spill file size
} FDISPILLFILE; /* fdisf */
typedef FDISPILLFILE *PFDISPILLFILE; /* pfdisf */
#ifndef unix
#pragma pack ()
#endif /* unix */

/*** cpuType values for FDICreate()
 *
 *  WARNING: For 16-bit Windows applications, the CPU detection may not
 *           correctly detect 286 CPUs.  Instead, use the following code:
 *
 *              DWORD   flags;
 *              int     cpuType;
 *
 *              flags = GetWinFlags();
 *              if (flags & WF_CPU286)
 *                  cpuType = cpu80286;
 *              else
 *                  cpuType = cpu80386;
 *
 *              hfdi = FDICreate(....,cpuType,...);
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 WARNING: Don't use auto-detect from a 16-bit Windows
 *                          application!  Use GetWinFlags()!
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 *  Special notes for Quantum Decompression:
 *      If you have used a high setting for CompressionMemory in creating
 *      the cabinet file(s), then FDI will attempt to allocate a lot of
 *      memory (as much as 2Mb, if you specified 21 for CompressionMemory).
 *      Therefore, if you plan to allocate additional memory *after* the
 *      FDICreate() call, you should reserve some memory *prior* to calling
 *      FDICreate(), and then free it up afterwards (or do all your allocation
 *      before calling FDICreate().

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);

 */

/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici);
 */


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char FAR     *pszCabinet,
                            char FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);

 */

/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);

 */

//** Revert to default structure packing
#ifndef unix
#pragma pack()
#endif /* unix */
#endif //!INCLUDED_FDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\debug.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
//====== Assertion/Debug output APIs =================================

#include "debmacro.h"
//#include <platform.h> // for __endexcept

#if defined(DECLARE_DEBUG) && DBG


//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
//UNUSED EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
//UNUSED EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

//UNUSED EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
//UNUSED EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
//UNUSED EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
//UNUSED EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
//UNUSED EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";

// (These are deliberately CHAR)
//UNUSED EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
//UNUSED EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
//UNUSED EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
//UNUSED EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
//UNUSED EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";

#endif  // DECLARE_DEBUG && DBG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
//UNUSED EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
//UNUSED EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))
#undef Assert
#undef AssertE
#undef AssertMsg
//UNUSED #undef AssertStrLen
#undef DebugMsg
//UNUSED #undef FullDebugMsg
// #undef ASSERT
#undef EVAL
// #undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
//UNUSED #undef _ASSERTE             // we substitute this ATL macro
#endif

#endif

// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_dwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

//UNUSED extern DWORD g_dwDumpFlags;
//UNUSED extern DWORD g_dwBreakFlags;
//UNUSED extern DWORD g_dwTraceFlags;
#if DBG
//UNUSED extern DWORD g_dwPrototype;
#else
//UNUSED #define g_dwPrototype   0
#endif
//UNUSED extern DWORD g_dwFuncTraceFlags;

#if DBG || defined(PRODUCT_PROF)
//UNUSED BOOL CcshellGetDebugFlags(void);
#else
//UNUSED #define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
//UNUSED #define BF_ONVALIDATE       0x00000001      // Break on assertions or validation
//UNUSED #define BF_ONAPIENTER       0x00000002      // Break on entering an API
//UNUSED #define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
//UNUSED #define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
//UNUSED #define BF_THR              0x00000100      // Break when THR() receives a failure

// Trace flags for g_dwTraceFlags
//UNUSED #define TF_ALWAYS           0xFFFFFFFF
//UNUSED #define TF_NEVER            0x00000000
//UNUSED #define TF_WARNING          0x00000001
//UNUSED #define TF_ERROR            0x00000002
//UNUSED #define TF_GENERAL          0x00000004      // Standard messages
//UNUSED #define TF_FUNC             0x00000008      // Trace function calls
//UNUSED #define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// BUGBUG (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
//UNUSED #undef DM_TRACE
//UNUSED #undef DM_WARNING
//UNUSED #undef DM_ERROR
#endif
//UNUSED #define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
//UNUSED #define DM_WARNING          TF_WARNING      // OBSOLETE Warning
//UNUSED #define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
//UNUSED #define DEBUGTEXT(sz, msg)      /* ;Internal */ \
//UNUSED     static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.
#if DBG

#if 0
#ifdef _X86_
// Use int 3 so we stop immediately in the source
//UNUSED #define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
//UNUSED #define DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif
#else
//UNUSED #define DEBUG_BREAK DebugBreak()
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreak);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreak);

BOOL IsShellExecutable();

void CDECL CcshellDebugMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);

extern void __cdecl _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
extern void __cdecl _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);

//UNUSED void _AssertStrLenA(LPCSTR pszStr, int iLen);
//UNUSED void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#define CcshellAssertFailed(_file, _line, _exp, _flag) FusionpAssertFailed((_flag), SZ_COMPNAME, (_file), (_line), __FUNCTION__, (_exp))

#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
//UNUSED #define _AssertStrLen           _AssertStrLenW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
//UNUSED #define _AssertStrLen           _AssertStrLenA
#endif



// Explanation of debug macros:
//
// ----
// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//   The g_dwBreakFlags global governs whether the function DebugBreaks.
//
// ----
// SHELLASSERT(f)
// 
//   If the process is "explore.exe", "iexplore.exe", "rundll32.exe" or "welcome.exe"
//   Then it behaves just like ASSERT(f). Else, the fuction is like ASSERT(f) except
//   with NO DebugBreak();
//
// ----
// AssertE(f)
//
//   Works like Assert, except (f) is also executed in the retail 
//   version as well.
//
// ----
// EVAL(f)
//
//   Evaluates the expression (f).  The expression is always evaluated,
//   even in retail builds.  But the macro only asserts in the debug
//   build.  This macro may only be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
// ----
// DBEXEC(flg, expr)
//
//   under DBG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DBG, does nothing (and does not evaluate either of its args)
// ----
// TraceMsg(mask, sz, args...) 
//
//   Generate wsprintf-formatted msg using specified trace mask.  
//   The g_dwTraceFlags global governs whether message is displayed.
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
// ----
// DebugMsg(mask, sz, args...) 
//
//   OBSOLETE!  
//   Like TraceMsg, except you must wrap the sz parameter with TEXT().
//
// ----
// AssertMsg(bAssert, sz, args...)
//
//   Generate wsprintf-formatted msg if the assertion is false.  
//   The g_dwBreakFlags global governs whether the function DebugBreaks.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//
// ----
//
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//

//UNUSED #define SHELLASSERT(f)                                                                                      \
//UNUSED     {                                                                                                       \
//UNUSED         DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
//UNUSED         if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE) && IsShellExecutable())          \
//UNUSED         {                                                                                                   \
//UNUSED             DEBUG_BREAK;                                                                                    \
//UNUSED         }                                                                                                   \
//UNUSED     }                                                                                                       \

#define AssertE(f)          ASSERT(f)

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
//UNUSED #define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
//UNUSED void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
//UNUSED void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
//UNUSED #define ShellAtlTrace   ShellAtlTraceW
#else
//UNUSED #define ShellAtlTrace   ShellAtlTraceA
#endif
//UNUSED #define ATLTRACE            ShellAtlTrace
#endif

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(__FILE__, __LINE__, #exp, 0), 0))

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#define AssertMsg           _AssertMsg
//UNUSED #define AssertStrLen        _AssertStrLen
//UNUSED #define AssertStrLenA       _AssertStrLenA
//UNUSED #define AssertStrLenW       _AssertStrLenW

#ifdef DISALLOW_DebugMsg
//UNUSED #define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
//UNUSED #define DebugMsg            _DebugMsg
#endif

#ifdef FULL_DEBUG
//UNUSED #define FullDebugMsg        _DebugMsg
#else
//UNUSED #define FullDebugMsg        1 ? (void)0 : (void)
#endif

//UNUSED #define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
//UNUSED #define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
//UNUSED #define Dbg_SafeStr         Dbg_SafeStrW
#else
//UNUSED #define Dbg_SafeStr         Dbg_SafeStrA
#endif

//UNUSED #define ASSERT_MSGW         CcshellAssertMsgW
//UNUSED #define ASSERT_MSGA         CcshellAssertMsgA
// #define ASSERT_MSG          CcshellAssertMsg
// #define ASSERTMSG           CcshellAssertMsg

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
//UNUSED #define DBG_ENTER(flagFTF, fn)                  \
//UNUSED         (FUNC_MSG(flagFTF, " > " #fn "()"), \
//UNUSED          CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
//UNUSED #define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
//UNUSED         (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
//UNUSED          CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
//UNUSED #define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
//UNUSED         (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
//UNUSED          CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
//UNUSED #define DBG_EXIT(flagFTF, fn)                              \
//UNUSED         (CcshellStackLeave(), \
//UNUSED          FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
//UNUSED #define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
//UNUSED         (CcshellStackLeave(), \
//UNUSED          FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
//UNUSED #define DBG_EXIT_INT(flagFTF, fn, n)                       \
//UNUSED         (CcshellStackLeave(), \
//UNUSED          FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
//UNUSED #define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
//UNUSED         (CcshellStackLeave(), \
//UNUSED          FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
//UNUSED #define DBG_EXIT_UL(flagFTF, fn, ul)                   \
//UNUSED         (CcshellStackLeave(), \
//UNUSED          FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
//UNUSED         (CcshellStackLeave(), \
//UNUSED          FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

//UNUSED #define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
//UNUSED #define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DBG


//UNUSED #define AssertE(f)      (f)

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
//UNUSED #define _ASSERTE(f)

// We map ATLTRACE macros to our functions
//UNUSED #define ATLTRACE            1 ? (void)0 : (void)
#endif

#define AssertMsg       1 ? (void)0 : (void)
//UNUSED #define AssertStrLen(lpStr, iLen)
#define DebugMsg        1 ? (void)0 : (void)
//UNUSED #define FullDebugMsg    1 ? (void)0 : (void)
#define EVAL(exp)       ((exp) != 0)
#define DBEXEC(flg, expr)   /*NOTHING*/


//UNUSED #define Dbg_SafeStr     1 ? (void)0 : (void)

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#ifdef UNICODE
#define TraceMsg        TraceMsgW
#else
#define TraceMsg        TraceMsgA
#endif

#define FUNC_MSG        1 ? (void)0 : (void)

//UNUSED #define ASSERT_MSGA     TraceMsgA
//UNUSED #define ASSERT_MSGW     TraceMsgW
//UNUSED #define ASSERT_MSG      TraceMsg
// #define ASSERTMSG       TraceMsg

//UNUSED #define DBG_ENTER(flagFTF, fn)
//UNUSED #define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
//UNUSED #define DBG_ENTER_SZ(flagFTF, fn, sz)
//UNUSED #define DBG_EXIT(flagFTF, fn)
//UNUSED #define DBG_EXIT_INT(flagFTF, fn, n)
//UNUSED #define DBG_EXIT_BOOL(flagFTF, fn, b)
//UNUSED #define DBG_EXIT_UL(flagFTF, fn, ul)
//UNUSED #define DBG_EXIT_DWORD      DBG_EXIT_UL
//UNUSED #define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
//UNUSED #define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DBG


// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#if DBG

//UNUSED EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
//UNUSED EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
//UNUSED EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine );
//UNUSED EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

//UNUSED #define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
//UNUSED #define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
//UNUSED #define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
//UNUSED #define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))

#else  // DBG

//UNUSED #define THR(x)          (x)
//UNUSED #define TBOOL(x)        (x)
//UNUSED #define TINT(x)         (x)
//UNUSED #define TPTR(x)         (x)

#endif // DBG



//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:

#else  // NOSHELLDEBUG

#ifdef UNIX
//UNUSED #include <crtdbg.h>
//UNUSED #define ASSERT(f)       _ASSERT(f)
//UNUSED #include <mainwin.h>
//UNUSED #define TraceMsg(type, sformat)  DebugMessage(0, sformat)
//UNUSED #define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#if DBG

//UNUSED LPCTSTR Dbg_GetCFName(UINT ucf);
//UNUSED LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
//UNUSED LPCTSTR Dbg_GetREFIIDName(REFIID riid);
//UNUSED LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

//UNUSED #define Dbg_GetCFName(ucf)          (void)0
//UNUSED #define Dbg_GetHRESULTName(hr)      (void)0
//UNUSED #define Dbg_GetREFIIDName(riid)     (void)0
//UNUSED #define Dbg_GetVTName(vt)           (void)0

#endif // DBG

// I'm a lazy typist...
//UNUSED #define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
// #include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
//UNUSED int __stdcall StartCAP(void);   // start profiling
//UNUSED int __stdcall StopCAP(void);    // stop profiling until StartCAP
//UNUSED int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
//UNUSED int __stdcall ResumeCAP(void);  // resume profiling
//UNUSED int __stdcall StartCAPAll(void);    // process-wide start profiling
//UNUSED int __stdcall StopCAPAll(void);     // process-wide stop profiling
//UNUSED int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
//UNUSED int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
//UNUSED void __stdcall MarkCAP(long lMark);  // write mark to MEA
//UNUSED extern DWORD g_dwProfileCAP;
#else
//UNUSED #define StartCAP()      0
//UNUSED #define StopCAP()       0
//UNUSED #define SuspendCAP()    0
//UNUSED #define ResumeCAP()     0
//UNUSED #define StartCAPAll()   0
//UNUSED #define StopCAPAll()    0
//UNUSED #define SuspendCAPAll() 0
//UNUSED #define ResumeCAPAll()  0
//UNUSED #define MarkCAP(n)      0

//UNUSED #define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\fdi_d.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __FDI_D_H_INCLUDED__
#define __FDI_D_H_INCLUDED__

#include "fdi.h"

// FDI.DLL delay-load class

class CFdiDll
{
    public:
#define DELAY_FDI_HFDI(_fn, _args, _nargs) \
    HFDI _fn _args { \
        HRESULT hres = Init(); \
        HFDI hfdi = 0; \
        if (SUCCEEDED(hres)) { \
            hfdi = _pfn##_fn _nargs; \
        } \
        return hfdi;    } \
    HFDI (FAR DIAMONDAPI* _pfn##_fn) _args;
    
#define DELAY_FDI_BOOL(_fn, _args, _nargs) \
    BOOL _fn _args { \
        HRESULT hres = Init(); \
        BOOL bRet = 0; \
        if (SUCCEEDED(hres)) { \
            bRet = _pfn##_fn _nargs; \
        } \
        return bRet;    } \
    BOOL (FAR DIAMONDAPI* _pfn##_fn) _args;

    HRESULT     Init(void);
    CFdiDll(BOOL fFreeLibrary = TRUE);
    ~CFdiDll();

    BOOL    m_fInited;
    BOOL    m_fFreeLibrary;
    HMODULE m_hMod;
    
    DELAY_FDI_HFDI(FDICreate,
        (PFNALLOC pfnalloc,
        PFNFREE pfnfree,
        PFNOPEN pfnopen,
        PFNREAD pfnread,
        PFNWRITE pfnwrite,
        PFNCLOSE pfnclose,
        PFNSEEK pfnseek,
        int cpuType,
        PERF perf),
        (pfnalloc, pfnfree, pfnopen, pfnread, pfnwrite, pfnclose, pfnseek, cpuType, perf));
        
    DELAY_FDI_BOOL(FDICopy,
        (HFDI hfdi,
        char *pszCabinet,
        char *pszCabPath,
        int flags,
        PFNFDINOTIFY pfnfdin,
        PFNFDIDECRYPT pfnfdid,
        void *pvUser),
        (hfdi, pszCabinet, pszCabPath, flags, pfnfdin, pfnfdid, pvUser));

    DELAY_FDI_BOOL(FDIIsCabinet,
        (HFDI hfdi,
        int hf,
        PFDICABINETINFO pfdici),
        (hfdi, hf, pfdici));

    DELAY_FDI_BOOL(FDIDestroy,
        (HFDI hfdi),
        (hfdi));

};

inline CFdiDll::CFdiDll(BOOL fFreeLibrary)
{
    m_fInited = FALSE;
    m_fFreeLibrary = fFreeLibrary;
}

inline CFdiDll::~CFdiDll()
{
    if (m_fInited && m_fFreeLibrary) {
        FreeLibrary(m_hMod);
    }
}

inline HRESULT CFdiDll::Init(void)
{
    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary(TEXT("CABINET.DLL"));

    if (!m_hMod) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) return E_UNEXPECTED;

    CHECKAPI(FDICreate);
    CHECKAPI(FDICopy);
    CHECKAPI(FDIIsCabinet);
    CHECKAPI(FDIDestroy);

    m_fInited = TRUE;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\hashnode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __HASHNODE_H_INCLUDED__
#define __HASHNODE_H_INCLUDED__

class CHashNode {
    public:
        CHashNode();
        virtual ~CHashNode();
    
        static HRESULT Create(LPCWSTR pwzSource, CHashNode **ppHashNode);

        BOOL IsDuplicate(LPCWSTR pwzStr) const;

    private:
        HRESULT Init(LPCWSTR pwzSource);

    private:
        LPWSTR                     _pwzSource;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\fusionheap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(_FUSION_INC_FUSIONHEAP_H_INCLUDED_)
#define _FUSION_INC_FUSIONHEAP_H_INCLUDED_

#pragma once

#include "debmacro.h"

#define FUSION_NEW_SINGLETON(_type) new _type
#define FUSION_NEW_ARRAY(_type, _n) new _type[_n]
#define FUSION_DELETE_ARRAY(_ptr) if((_ptr)) delete [] (_ptr)
#define FUSION_DELETE_SINGLETON(_ptr) if((_ptr)) delete (_ptr)

#define NEW(_type) FUSION_NEW_SINGLETON(_type)

EXTERN_C
BOOL
FusionpInitializeHeap(
    HINSTANCE hInstance
    );

EXTERN_C
VOID
FusionpUninitializeHeap();


#endif // !defined(_FUSION_INC_FUSIONHEAP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\fusionmodule.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(_FUSION_INC_FUSIONMODULE_H_INCLUDED_)
#define _FUSION_INC_FUSIONMODULE_H_INCLUDED_

#pragma once

#include <wtypes.h>
#include "oleaut_d.h"
#include "debmacro.h"
#include "FusionBuffer.h"

#define FUSION_OA_API(_fn, _args, _nargs) void _fn _args { ASSERT(m_fFusionModuleInitialized); m_OleAut._fn _nargs; }
#define FUSION_OA_API_(_rett, _fn, _args, _nargs) _rett _fn _args { ASSERT(m_fFusionModuleInitialized); return m_OleAut._fn _nargs; }

#define FUSION_MODULE_UNUSED(x) (x)

class CFusionModule
{
public:
    CFusionModule() : m_fFusionModuleInitialized(false), m_hInstDLL(NULL), m_dwEnumLocaleTLS(0)
#if DBG
        , m_dwTraceContextTLS(0) 
#endif
    { }
    ~CFusionModule() { }

    // Pass all DllMain() activations through here for attach and detach time work.
    BOOL ModuleDllMain(HINSTANCE hInstDLL, DWORD dwReason, LPVOID pvReserved);
    HRESULT Initialize();
    FUSION_OA_API_(HRESULT, VariantClear, (VARIANTARG *pvarg), (pvarg))
    FUSION_OA_API_(HRESULT, VariantInit, (VARIANTARG *pvarg), (pvarg))
    FUSION_OA_API_(HRESULT, VariantCopy, (VARIANTARG *pvargDest, const VARIANTARG *pvargSrc), (pvargDest, const_cast<VARIANTARG *>(pvargSrc)))
    FUSION_OA_API_(HRESULT, VariantChangeType, (VARIANTARG *pvargDest, const VARIANTARG *pvargSrc, USHORT wFlags, VARTYPE vt),
        (pvargDest, const_cast<VARIANTARG *>(pvargSrc), wFlags, vt))
    FUSION_OA_API_(BSTR, SysAllocString, (LPCOLESTR sz), (sz))
    FUSION_OA_API(SysFreeString, (BSTR bstr), (bstr))

    typedef BOOL (CALLBACK * LOCALE_ENUMPROCEXW)(LPWSTR pszLCID, LPVOID pvContext);
    typedef BOOL (CALLBACK * LOCALE_ENUMPROCEXA)(LPSTR pszLCID, LPVOID pvContext);

    BOOL EnumSystemLocalesExA(LOCALE_ENUMPROCEXA lpLocaleEnumProc, DWORD dwFlags, LPVOID pvContext);
    BOOL EnumSystemLocalesExW(LOCALE_ENUMPROCEXW lpLocaleEnumProc, DWORD dwFlags, LPVOID pvContext);

#if DBG
    template <typename T> void GetFunctionTraceContext(T *&rpt)
    {
        rpt = reinterpret_cast<T *>(::TlsGetValue(m_dwTraceContextTLS));
    }

    template <typename T> void SetFunctionTraceContext(T *pt)
    {
        ::TlsSetValue(m_dwTraceContextTLS, pt);
    }
#endif

protected:
    bool m_fFusionModuleInitialized;
    DWORD m_dwEnumLocaleTLS; // TLS key used in wrapped calls to EnumSystemLocales
#if DBG
    DWORD m_dwTraceContextTLS; // TLS key used to manage active trace contexts
#endif
    COleAutDll m_OleAut;
    HINSTANCE m_hInstDLL;

    typedef struct tagENUMSYSTEMLOCALESEXCONTEXTA
    {
        LPVOID pvContext; // user specified context
        LOCALE_ENUMPROCEXA lpLocaleEnumProc; // user specified enumeration function
    } ENUMSYSTEMLOCALESEXCONTEXTA, *LPENUMSYSTEMLOCALESEXCONTEXTA;

    typedef struct tagENUMSYSTEMLOCALESEXCONTEXTW
    {
        LPVOID pvContext; // user specified context
        LOCALE_ENUMPROCEXW lpLocaleEnumProc; // user specified enumeration function
    } ENUMSYSTEMLOCALESEXCONTEXTW, *LPENUMSYSTEMLOCALESEXCONTEXTW;

    static BOOL CALLBACK EnumLocalesProcA(LPSTR pszLCID);
    static BOOL CALLBACK EnumLocalesProcW(LPWSTR pszLCID);
};

#undef FUSION_MODULE_UNUSED

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\helpers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#ifndef __HELPERS_H_INCLUDED__
#define __HELPERS_H_INCLUDED__

#include "xmlparser.h"
#include "nodefact.h"

#define FROMHEX(a) ((a)>=L'a' ? a - L'a' + 10 : a - L'0')
#define TOLOWER(a) (((a) >= L'A' && (a) <= L'Z') ? (L'a' + (a - L'A')) : (a))


#define MAX_URL_LENGTH                     2084 // same as INTERNET_MAX_URL_LENGTH

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES
#define MAX_SID_LEN             (sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))


HRESULT Unicode2Ansi(const wchar_t *src, char ** dest);
HRESULT Ansi2Unicode(const char * src, wchar_t **dest);
BOOL IsFullyQualified(LPCWSTR wzPath);
UINT GetDriveTypeWrapper(LPCWSTR wzPath);
HRESULT AppCtxGetWrapper(IApplicationContext *pAppCtx, LPWSTR wzTag,
                         WCHAR **ppwzValue);
HRESULT NameObjGetWrapper(IAssemblyName *pName, DWORD nIdx, 
                          LPBYTE *ppbBuf, LPDWORD pcbBuf);
HRESULT GetFileLastModified(LPCWSTR pwzFileName, FILETIME *pftLastModified);
DWORD GetRealWindowsDirectory(LPWSTR wszRealWindowsDir, UINT uSize);
HRESULT SetAppCfgFilePath(IApplicationContext *pAppCtx, LPCWSTR wzFilePath);

HRESULT CfgEnterCriticalSection(IApplicationContext *pAppCtx);
HRESULT CfgLeaveCriticalSection(IApplicationContext *pAppCtx);
HRESULT MakeUniqueTempDirectory(LPCWSTR wzTempDir, LPWSTR wzUniqueTempDir,
                                DWORD dwLen);
HRESULT CreateFilePathHierarchy( LPCOLESTR pszName );
DWORD GetRandomName (LPTSTR szDirName, DWORD dwLen);
HRESULT CreateDirectoryForAssembly
   (IN DWORD dwDirSize, IN OUT LPTSTR pszPath, IN OUT LPDWORD pcwPath);
HRESULT RemoveDirectoryAndChildren(LPWSTR szDir);
STDAPI CopyPDBs(IAssembly *pAsm);
HRESULT VersionFromString(LPCWSTR wzVersion, WORD *pwVerMajor, WORD *pwVerMinor,
                          WORD *pwVerBld, WORD *pwVerRev);

BOOL LoadSNAPIs();
BOOL VerifySignature(LPWSTR szFilePath, LPBOOL pfWasVerified, DWORD dwFlags);
HRESULT FusionGetUserFolderPath(LPWSTR pszPath);
BOOL GetCorSystemDirectory(LPWSTR szCorSystemDir);
DWORD HashString(LPCWSTR wzKey, DWORD dwHashSize, BOOL bCaseSensitive = TRUE);
HRESULT ExtractXMLAttribute(LPWSTR *ppwzValue, XML_NODE_INFO **aNodeInfo,
                            USHORT *pCurIdx, USHORT cNumRecs);
HRESULT AppendString(LPWSTR *ppwzHead, LPCWSTR pwzTail, DWORD dwLen);

HRESULT GetFileLastTime(LPWSTR pszPath, LPFILETIME pftFileLastWriteTime, LPFILETIME pftFileLastAccessTime);
LPWSTR GetNextDelimitedString(LPWSTR *ppwzList, WCHAR wcDelimiter);
HRESULT GetCORVersion(LPWSTR pbuffer, DWORD *dwLength);
HRESULT InitializeEEShim();

HRESULT FusionpHresultFromLastError();
HRESULT GetRandomFileName(LPTSTR pszPath, DWORD dwFileName);

HRESULT GetManifestFileLock( LPWSTR pszManifestFile, HANDLE *phFile);

int GetTimeFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpDate,
                       LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);

int GetDateFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpDate,
                       LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);

DWORD GetPrivateProfileStringExW(LPCWSTR lpAppName, LPCWSTR lpKeyName,
                                 LPCWSTR lpDefault, LPWSTR *ppwzReturnedString,
                                 LPCWSTR lpFileName);

HRESULT UpdatePublisherPolicyTimeStampFile(IAssemblyName *pName);

void FusionFormatGUID(GUID guid, LPWSTR pszBuf, DWORD cchSize);
HRESULT UrlCanonicalizeUnescape(LPCWSTR pszUrl, LPWSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
HRESULT UrlCombineUnescape(LPCWSTR pszBase, LPCWSTR pszRelative, LPWSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
HRESULT GetCurrentUserSID(WCHAR *rgchSID);

BOOL IsHosted();

BOOL FusionGetVolumePathNameW(LPCWSTR lpszFileName,
                              LPWSTR lpszVolumePathName,
                              DWORD cchBufferLength
                              );
DWORD
FusionGetRemoteUniversalName(LPWSTR pwzPathName, LPVOID lpBuff, LPDWORD pcbSize );

HRESULT InitFusionRetargetPolicy();
HRESULT InitFusionFxConfigPolicy();

DWORD
IsService_NT5
(
/* [in] */  UINT    nPid,
/* [out] */ bool    *pbIsService,
/* [out] */ LPTSTR  lpszImagePath,
/* [out] */ ULONG   cchImagePath,
/* [out] */ LPTSTR  lpszServiceShortName,
/* [in] */  ULONG   cchServiceShortName,
/* [out] */ LPTSTR  lpszServiceDescription,
/* [in] */  ULONG   cchServiceDescription
);

HRESULT
IsService_NT4
(
IN  UINT    nPid,
OUT bool    *pbIsService
);

DWORD
IsService
(
/* [in] */  UINT    nPid,
/* [out] */ bool    *pbIsService,
/* [out] */ LPTSTR  lpszImagePath,
/* [out] */ ULONG   cchImagePath,
/* [out] */ LPTSTR  lpszServiceShortName,
/* [in] */  ULONG   cchServiceShortName,
/* [out] */ LPTSTR  lpszServiceDescription,
/* [in] */  ULONG   cchServiceDescription
);

DWORD
GetProcessHandle
(
IN  ULONG   lPid,
OUT HANDLE  *phProcess
);

HRESULT
GetLocalSystemSid(
        OUT PSID* ppLocalSystemSid
        );

HRESULT
GetProcessSid( 
        OUT PSID* ppSid 
        );

HRESULT
GetTokenSid( 
        IN  HANDLE hToken,
        OUT PSID*  ppSid
        );

BOOL IsLocalSystem(void);


class CPSID {
public:
    CPSID(PSID h = 0) : m_h(h)          {}
   ~CPSID()                                                     { if (m_h != 0) FreeSid(m_h); }

    PSID* operator &()                          { return &m_h; }
    operator PSID() const                       { return m_h; }
    PSID detach()                                       { PSID h = m_h; m_h = 0; return h; }

private:
    CPSID(const CPSID&);
    CPSID& operator=(const CPSID&);

private:
        PSID m_h;
};

HRESULT PathCreateFromUrlWrap(LPCWSTR pszUrl, LPWSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LPWSTR StripFilePrefix(LPWSTR pwzURL);
HRESULT CheckFileExistence(LPCWSTR pwzFile, BOOL *pbExists);

int FusionCompareString(LPCWSTR pwz1, LPCWSTR pwz2, BOOL bCaseSensitive = TRUE);
int FusionCompareStringI(LPCWSTR pwz1, LPCWSTR pwz2);
int FusionCompareStringNI(LPCWSTR pwz1, LPCWSTR pwz2, int nChar);
int FusionCompareStringN(LPCWSTR pwz1, LPCWSTR pwz2, int nChar, BOOL bCaseSensitive = TRUE);
HRESULT Base32Encode(BYTE *pbData, DWORD cbData, LPWSTR *ppwzBase32);
HRESULT PathAddBackslashWrap(LPWSTR pwzPath, DWORD dwMaxLen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\histnode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __HISTNODE_H_INCLUDED__
#define __HISTNODE_H_INCLUDED__

#include "histinfo.h"

class CHistoryInfoNode {
    public:
        CHistoryInfoNode();
        virtual ~CHistoryInfoNode();

        HRESULT Init(AsmBindHistoryInfo *pHistInfo);
        static HRESULT Create(AsmBindHistoryInfo *pHistInfo, CHistoryInfoNode **pphn);

    public:
        DWORD                                   _dwSig;
        AsmBindHistoryInfo                      _bindHistoryInfo;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\fusionp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _FUSIONP_H_

#define _FUSIONP_H_

#pragma once

#include "debmacro.h"

#include "windows.h"
#include "winerror.h"
#include "corerror.h"
#include "cor.h"
#include "strids.h"
#include "fusionpriv.h"

// MSCOREE exports

typedef HRESULT (*pfnGetXMLObject)(LPVOID *ppv);
typedef HRESULT (*pfnGetCORVersion)(LPWSTR pbuffer, DWORD cchBuffer, DWORD *dwLength);
typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);
typedef HRESULT (*COINITIALIZECOR)(DWORD);
typedef HRESULT (*pfnGetAssemblyMDImport)(LPCWSTR szFileName, REFIID riid, LPVOID *ppv);
typedef BOOLEAN (*PFNSTRONGNAMETOKENFROMPUBLICKEY)(LPBYTE, DWORD, LPBYTE*, LPDWORD);
typedef HRESULT (*PFNSTRONGNAMEERRORINFO)();
typedef BOOLEAN (*PFNSTRONGNAMESIGNATUREVERIFICATION)(LPCWSTR, DWORD, DWORD *);
typedef VOID (*PFNSTRONGNAMEFREEBUFFER)(LPBYTE);

#define MAX_RANDOM_ATTEMPTS      0xFFFF

// BUGBUG: Flags copied from CLR's strongname.h for strong name signature
// verification.

// Flags for use with the verify routines.
#define SN_INFLAG_FORCE_VER      0x00000001     // verify even if settings in the registry disable it
#define SN_INFLAG_INSTALL        0x00000002     // verification is the first (on entry to the cache)
#define SN_INFLAG_ADMIN_ACCESS   0x00000004     // cache protects assembly from all but admin access
#define SN_INFLAG_USER_ACCESS    0x00000008     // cache protects user's assembly from other users
#define SN_INFLAG_ALL_ACCESS     0x00000010     // cache provides no access restriction guarantees
#define SN_OUTFLAG_WAS_VERIFIED  0x00000001     // set to false if verify succeeded due to registry settings


#define ASM_UNDER_CONSTRUCTION         0x80000000

#define ASM_DELAY_SIGNED               0x40000000
#define ASM_COMMIT_DELAY_SIGNED        0x80000000


#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
#define PLATFORM_TYPE_WINNT         ((DWORD)(1))
#define PLATFORM_TYPE_UNIX          ((DWORD)(2))

#define DIR_SEPARATOR_CHAR TEXT('\\')

#define URL_DIR_SEPERATOR_CHAR      L'/'
#define URL_DIR_SEPERATOR_STRING    L"/"

#define DWORD_STRING_LEN (sizeof(DWORD)*2) // this should be 8 chars; "ff00ff00" DWORD represented in string format.

#define ATTR_SEPARATOR_CHAR     L'_'
#define ATTR_SEPARATOR_STRING   L"_"

EXTERN_C DWORD GlobalPlatformType;

#define NUMBER_OF(_x) (sizeof(_x) / sizeof((_x)[0]))

#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { FUSION_DELETE_SINGLETON((p)); (p) = NULL; };

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };

#undef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { FUSION_DELETE_ARRAY((p)); (p) = NULL; };

#undef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#include "shlwapi.h"
#ifdef USE_FUSWRAPPERS

#include "priv.h"
#include "crtsubst.h"
#include "shlwapip.h"
#include "w95wraps.h"

#else

// use URT WRAPPERS
#include "winwrap.h"
#include "urtwrap.h"

#endif // USE_FUSWRAPPERS


#include "fusion.h"
#include "fusionheap.h"

#ifdef PERFTAGS
#include <mshtmdbg.h>

// 
// entries for differennt logging name
//
#define FusionTag(tag, szDll, szDist) PerfTag(tag, szDll, szDist)

#define FusionLog(tag, pv, a0) DbgExPerfLogFn(tag, pv, a0)
#define FusionLog1(tag, pv, a0, a1) DbgExPerfLogFn(tag, pv, a0, a1)
#define FusionLog2(tag, pv, a0, a1, a2) DbgExPerfLogFn(tag, pv, a0, a1, a2)

#else
#define FusionTag(tag, szDll, szDist) 
#define FusionLog(tag, pv, a0) 
#define FusionLog1(tag, pv, a0, a1) 
#define FusionLog2(tag, pv, a0, a1, a2)

#endif // PERFTAGS


#ifdef KERNEL_MODE
#define URLDownloadToCacheFileW(caller, szURL, szFile, dwBuf, dwReserved, callback) E_FAIL
#define CoInternetGetSession(dwMode, ppSession, dwReserved) E_FAIL
#define CopyBindInfo(pcbisrc, pbidest) E_FAIL
#else

#endif // KERNEL_MODE

typedef enum tagUserAccessMode { READ_ONLY=0, READ_WRITE=1  } UserAccessMode;


extern UserAccessMode g_GAC_AccessMode;

extern UserAccessMode g_DownloadCache_AccessMode;

extern UserAccessMode g_CurrUserPermissions;

#define REG_KEY_FUSION_SETTINGS              TEXT("Software\\Microsoft\\Fusion")

#define FUSION_CACHE_DIR_ROOT_SZ            TEXT("\\assembly")
#define FUSION_CACHE_DIR_DOWNLOADED_SZ      TEXT("\\assembly\\dl2")
#define FUSION_CACHE_DIR_GAC_SZ             TEXT("\\assembly\\GAC")
#define FUSION_CACHE_DIR_ZAP_SZ             TEXT("\\assembly\\NativeImages1_")
#define FUSION_CACHE_STAGING_DIR_SZ         TEXT("\\assembly\\tmp")
#define FUSION_CACHE_PENDING_DEL_DIR_SZ     TEXT("\\assembly\\temp")


extern WCHAR g_UserFusionCacheDir[MAX_PATH+1];
extern WCHAR g_szWindowsDir[MAX_PATH+1];
extern WCHAR g_GACDir[MAX_PATH+1];
extern WCHAR g_ZapDir[MAX_PATH+1];

extern DWORD g_ZapQuotaInKB;
extern DWORD g_DownloadCacheQuotaInKB;

extern DWORD g_ScavengingThreadId;
extern WCHAR g_FusionDllPath[MAX_PATH+1];

struct TRANSCACHEINFO
{
    DWORD       dwType;            // entry type
    FILETIME    ftCreate;          // created time
    FILETIME    ftLastAccess;      // last access time
    LPWSTR      pwzName;          //  Name;
    LPWSTR      pwzCulture;       // Culture
    BLOB        blobPKT;          // Public Key Token (hash(PK))
    DWORD       dwVerHigh;        // Version (High)
    DWORD       dwVerLow;         // Version (Low)
    BLOB        blobCustom;       // Custom attribute.
    BLOB        blobSignature;    // Signature blob
    BLOB        blobMVID;         // MVID
    DWORD       dwPinBits;        // Bits for pinning Asm; one bit for each installer
    LPWSTR      pwzCodebaseURL;   // where is the assembly coming from 
    FILETIME    ftLastModified;   // Last-modified of codebase url.
    LPWSTR      pwzPath;          // Cache path
    DWORD       dwKBSize;         // size in KB 
    BLOB        blobPK;           // Public Key (if strong)
    BLOB        blobOSInfo;       // list of platforms
    BLOB        blobCPUID;        // list of processors.
};

#define     DB_S_FOUND (S_OK)
#define  DB_S_NOTFOUND (S_FALSE)
#define DB_E_DUPLICATE (HRESULT_FROM_WIN32(ERROR_DUP_NAME))

#ifndef USE_FUSWRAPPERS

#define OS_WINDOWS                  0           // windows vs. NT
#define OS_NT                       1           // windows vs. NT
#define OS_WIN95                    2           // Win95 or greater
#define OS_NT4                      3           // NT4 or greater
#define OS_NT5                      4           // NT5 or greater
#define OS_MEMPHIS                  5           // Win98 or greater
#define OS_MEMPHIS_GOLD             6           // Win98 Gold
#define OS_WIN2000                  7           // Some derivative of Win2000
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server

STDAPI_(BOOL) IsOS(DWORD dwOS);

#endif

extern HANDLE g_hCacheMutex;
HRESULT CreateCacheMutex();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\histasm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __HISTASM_H_INCLUDED__
#define __HISTASM_H_INCLUDED__

#include "histinfo.h"

class CHistoryAssembly : public IHistoryAssembly {
    public:
        CHistoryAssembly();
        virtual ~CHistoryAssembly();

        static HRESULT Create(LPCWSTR pwzFilePath, LPCWSTR pwzActivationDate,
                              LPCWSTR wzAsmName, LPCWSTR wzPublicKeyToken,
                              LPCWSTR wzCulture, LPCWSTR wzVerRef,
                              CHistoryAssembly **ppHistAsm);
        
        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IHistoryAssembly methods

        STDMETHODIMP GetAssemblyName(LPWSTR wzAsmName, DWORD *pdwSize);
        STDMETHODIMP GetPublicKeyToken(LPWSTR wzPublicKeyToken, DWORD *pdwSize);
        STDMETHODIMP GetCulture(LPWSTR wzCulture, DWORD *pdwSize);
        STDMETHODIMP GetReferenceVersion(LPWSTR wzVerRef, DWORD *pdwSize);
        STDMETHODIMP GetActivationDate(LPWSTR wzActivationDate, DWORD *pdwSize);

        STDMETHODIMP GetAppCfgVersion(LPWSTR pwzVerAppCfg, DWORD *pdwSize);
        STDMETHODIMP GetPublisherCfgVersion(LPWSTR pwzVerPublisherCfg, DWORD *pdwSize);
        STDMETHODIMP GetAdminCfgVersion(LPWSTR pwzAdminCfg, DWORD *pdwSize);

    private:
        HRESULT Init(LPCWSTR pwzFilePath, LPCWSTR pwzActivationDate, LPCWSTR pwzAsmName,
                     LPCWSTR pwzPublicKeyToken, LPCWSTR pwzCulture, LPCWSTR pwzVerRef);

    private:
        DWORD                                  _dwSig;
        DWORD                                  _cRef;
        LPWSTR                                 _pwzActivationDate;
        LPWSTR                                 _pwzAsmName;
        LPWSTR                                 _pwzPublicKeyToken;
        LPWSTR                                 _pwzCulture;
        LPWSTR                                 _pwzVerReference;
        WCHAR                                  _wzFilePath[MAX_PATH];
        AsmBindHistoryInfo                     _bindInfo;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\histinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#ifndef __HISTINFO_H_INCLUDED__
#define __HISTINFO_H_INCLUDED__

#include "naming.h"

#define REG_VAL_FUSION_MAX_APP_HISTORY     TEXT("MaxApplicationHistory")
#define REG_VAL_FUSION_XSP_HISTORY_LOGS    TEXT("XSPHistoryLogs")

#define DEFAULT_INI_VALUE                  L""

#define HISTORY_SECTION_HEADER             L"PolicyResolutionHistory"
#define HEADER_DATA_NUM_SECTIONS           L"NumResolutions"
#define HEADER_DATA_EXE_PATH               L"ExecutablePath"
#define HEADER_DATA_APP_NAME               L"ApplicationName"
#define SNAPSHOT_DATA_URT_VERSION          L"RuntimeVersion"
#define ASSEMBLY_DATA_VER_REFERENCE        L"VerReference"
#define ASSEMBLY_DATA_VER_APP_CFG          L"VerAppCfg"
#define ASSEMBLY_DATA_VER_PUBLISHER_CFG    L"VerPublisherCfg"
#define ASSEMBLY_DATA_VER_ADMIN_CFG        L"VerAdminCfg"
#define FUSION_SNAPSHOT_PREFIX             L"ActivationSnapShot"
#define FUSION_HISTORY_SUBDIR              L"ApplicationHistory"

#define HISTORY_DELIMITER_CHAR             L'/'

#define INI_BIG_BUFFER_SIZE                1024
#define INI_READ_BUFFER_SIZE               1024
#define MAX_INI_TAG_LENGTH                 1024
#define MAX_INI_VALUE_LENGTH               1024
#define MAX_PERSISTED_ACTIVATIONS_DEFAULT  5
#define MAX_ACTIVATION_DATE_LEN            32

#define MAX_CULTURE_SIZE                   32

typedef struct tagAsmBindHistoryInfo {
    WCHAR wzAsmName[MAX_INI_TAG_LENGTH];
    WCHAR wzPublicKeyToken[MAX_PUBLIC_KEY_TOKEN_LEN];
    WCHAR wzCulture[MAX_CULTURE_SIZE];
    WCHAR wzVerReference[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerAppCfg[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerPublisherCfg[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerAdminCfg[MAX_VERSION_DISPLAY_SIZE];
} AsmBindHistoryInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\installapis.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#ifndef _INSTALLAPIS_H_
#define _INSTALLAPIS_H_

STDAPI InstallAssembly(DWORD    dwInstaller,
                       DWORD    dwInstallFlags,
                       LPCOLESTR szPath, 
                       LPCOLESTR pszURL, 
                       FILETIME *pftLastModTime, 
                       IApplicationContext *pAppCtx,
                       IAssembly **ppAsmOut);

STDAPI InstallModule(DWORD  dwInstaller,
                     DWORD  dwInstallFlags,
                     LPCOLESTR szPath, 
                     IAssemblyName* pName, 
                     IApplicationContext *pAppCtx, 
                     LPCOLESTR pszURL, 
                     FILETIME *pftLastModTime);










#endif _INSTALLAPIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\history.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef __HISTORY_H_INCLUDED__
#define __HISTORY_H_INCLUDED__

#include "list.h"
#include "histinfo.h"
#include "iniwrite.h"
#include "naming.h"

#define SIZE_MODULE_PATH_HASH                          0xFFFFFFFF

#define FILENAME_PUBLISHER_PCY_TIMESTAMP               L"\\PublisherPolicy.tme"


class CDebugLog;
class CHistoryInfoNode;

typedef enum {
    POLICY_STATUS_UNCHANGED,
    POLICY_STATUS_NEW,
    POLICY_STATUS_DIFFERENT
} POLICY_STATUS;

class CBindHistory {
    public:
        CBindHistory();
        virtual ~CBindHistory();
        
        HRESULT Init(LPCWSTR wzApplicationName, LPCWSTR wzModulePath,
                     FILETIME *pftLastModConfig);
        static HRESULT Create(LPCWSTR wzApplicationName, LPCWSTR wzModulePath,
                              FILETIME *pftLastModConfig, CBindHistory **ppbh);

        HRESULT PersistBindHistory(AsmBindHistoryInfo *pHistInfo);

    private:
        POLICY_STATUS GetAssemblyStatus(LPCWSTR wzActivationDate,
                                        AsmBindHistoryInfo *pHistInfo);
        HRESULT InitActivationDates();
        HRESULT FlushPendingHistory(LPCWSTR wzActivationDate);
        HRESULT CreateInUseFile(LPCWSTR pwzHistoryFile);

    private:
        DWORD                              _dwSig;
        BOOL                               _bFoundDifferent;
        WCHAR                              _wzFilePath[MAX_PATH + 1];
        WCHAR                              _wzActivationDateMRU[MAX_ACTIVATION_DATE_LEN];
        WCHAR                              _wzActivationDateCurrent[MAX_ACTIVATION_DATE_LEN];
        WCHAR                              _wzURTVersion[MAX_VERSION_DISPLAY_SIZE];
        LPWSTR                             _wzApplicationName;
        BOOL                               _bPolicyUnchanged;
        BOOL                               _bInitCS;
        CRITICAL_SECTION                   _csHistory;
        CIniWriter                         _iniWriter;
        CDebugLog                         *_pdbglog;
        HANDLE                             _hFile;
        WCHAR                              _wzInUseFile[MAX_PATH];
        List<CHistoryInfoNode *>           _listPendingHistory;
};


HRESULT PrepareBindHistory(IApplicationContext *pAppCtx);
HRESULT GetHistoryFilePath(LPCWSTR wzApplicationName, LPCWSTR wzModulePath,
                           LPWSTR wzFilePath, DWORD *pdwSize);
HRESULT LookupHistoryAssemblyInternal(LPCWSTR pwzFilePath, LPCWSTR pwzActivationDate,
                                      LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                                      LPCWSTR pwzLocale, LPCWSTR pwzVerRef,
                                      IHistoryAssembly **ppHistAsm);

HRESULT GetConfigLastModified(IApplicationContext *pAppCtx, FILETIME *pftLastModConfig);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\iniread.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __INIREAD_H_INCLUDED__
#define __INIREAD_H_INCLUDED__

#include "histinfo.h"

class CIniReader : public IHistoryReader {
    public:
        CIniReader();
        virtual ~CIniReader();

        HRESULT Init(LPCWSTR wzFilePath);

        
        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IHistoryReader methods

        STDMETHODIMP GetFilePath(LPWSTR wzFilePath, DWORD *pdwSize);
        STDMETHODIMP GetApplicationName(LPWSTR wzAppName, DWORD *pdwSize);
        STDMETHODIMP GetEXEModulePath(LPWSTR wzExePath, DWORD *pdwSize);
        
        STDMETHODIMP GetNumActivations(DWORD *pdwNumActivations);
        STDMETHODIMP GetActivationDate(DWORD dwIdx, FILETIME *pftDate);

        STDMETHODIMP GetRunTimeVersion(FILETIME *pftActivationDate,
                                  LPWSTR wzRunTimeVersion, DWORD *pdwSize);
        STDMETHODIMP GetNumAssemblies(FILETIME *pftActivationDate, DWORD *pdwNumAsms);
        STDMETHODIMP GetHistoryAssembly(FILETIME *pftActivationDate, DWORD dwIdx,
                                        IHistoryAssembly **ppHistAsm);

    public: 
        // Other (non IHistoryReader) methods

        STDMETHODIMP GetAssemblyInfo(LPCWSTR wzActivationDate,
                                LPCWSTR wzAssemblyName,
                                LPCWSTR wzPublicKeyToken,
                                LPCWSTR wzCulture,
                                LPCWSTR wzVerReference,
                                AsmBindHistoryInfo *pBindInfo);
        STDMETHODIMP_(BOOL) DoesExist(IHistoryAssembly *pHistAsm);


    private:
        STDMETHODIMP ExtractAssemblyInfo(LPWSTR wzAsmStr, LPWSTR *ppwzAsmName,
                                    LPWSTR *ppwzAsmPublicKeyToken,
                                    LPWSTR *ppwzAsmCulture,
                                    LPWSTR *ppwzAsmVerRef);
    private:
        DWORD                                  _dwSig;
        LPWSTR                                 _wzFilePath;
        DWORD                                  _cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\iniwrite.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __INIWRITE_H_INCLUDED__
#define __INIWRITE_H_INCLUDED__

#include "histinfo.h"

class CIniWriter {
    public:
        CIniWriter();
        virtual ~CIniWriter();

        HRESULT Init(LPCWSTR pwzFileName);

        HRESULT AddSnapShot(LPCWSTR wzActivationDate, LPCWSTR wzURTVersion);
        HRESULT DeleteSnapShot(LPCWSTR wzActivationDate);
        HRESULT AddAssembly(LPCWSTR wzActivationDate, AsmBindHistoryInfo *pHist);
        HRESULT InsertHeaderData(LPCWSTR wzEXEPath, LPCWSTR wzAppName);

    private:
        DWORD                        _dwSig;
        LPWSTR                       _pwzFileName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\lock.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "helpers.h"
#include "fusionP.h"

#pragma once

class CCriticalSection
{
    public:
        CCriticalSection(CRITICAL_SECTION *pcs)
        : _pcs(pcs)
        , _bEntered(FALSE)
        {
            ASSERT(pcs);
        }

        ~CCriticalSection()
        {
            if (_bEntered) {
                ::LeaveCriticalSection(_pcs);
            }
        }

        // Don't try to catch when entering or leaving critical
        // sections! We used to do this, but this is absolutely not the
        // right behaviour.
        //
        // Enter/Leave will raise exceptions when they can't allocate the
        // event used to signal waiting threads when there is contention.
        // However, if the event can't be allocated, other threads
        // that were waiting on the event never get signalled, so they'll
        // spin forever.
        //
        // If Enter/Leave ever raise an exception, you should just bubble
        // the exception up, and not try to do anything.

        HRESULT Lock()
        {
            HRESULT                          hr = S_OK;

            if (_bEntered) {
                return E_UNEXPECTED;
            }

            ::EnterCriticalSection(_pcs);
            _bEntered = TRUE;

            return hr;
        }

        HRESULT Unlock()
        {
            HRESULT                      hr = S_OK;
            
            if (_bEntered) {
                _bEntered = FALSE;
                ::LeaveCriticalSection(_pcs);
            }
            else {
                ASSERT(0);
                hr = E_UNEXPECTED;
            }

            return hr;
        }

    private:
        CRITICAL_SECTION                    *_pcs;
        BOOL                                 _bEntered;
};
                
class CMutex
{
    public:
        CMutex(HANDLE hMutex)
        : _hMutex(hMutex)
        , _bLocked(FALSE)
        {
            ASSERT(hMutex);
        }

        ~CMutex()
        {
            if (_bLocked) {
                if(!(::ReleaseMutex(_hMutex))){
                }
            }
        }

        HRESULT Lock()
        {
            HRESULT                          hr = S_OK;
            DWORD                            dwWait;

            if(_hMutex == INVALID_HANDLE_VALUE) // no need to take lock.
                goto exit;

            if (_bLocked) {
                hr = E_UNEXPECTED;
                goto exit;
            }

            dwWait = ::WaitForSingleObject(_hMutex, INFINITE);
            if((dwWait != WAIT_OBJECT_0) && (dwWait != WAIT_ABANDONED)){
                    hr = FusionpHresultFromLastError();
            }

            if (hr == S_OK) {
                _bLocked = TRUE;
            }

        exit :
            return hr;
        }

        HRESULT Unlock()
        {
            HRESULT                      hr = S_OK;

            if (_bLocked) {
                _bLocked = FALSE;
                if(!(::ReleaseMutex(_hMutex))){
                    hr = FusionpHresultFromLastError();
                }
            }
            else {
                ASSERT(0);
                hr = E_UNEXPECTED;
            }

            return hr;
        }

    private:
        HANDLE                               _hMutex;
        BOOL                                 _bLocked;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\list.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __LIST_H_INCLUDED__
#define __LIST_H_INCLUDED__

//+---------------------------------------------------------------------------
//
//  File:       list.h
//
//  Contents: Quick 'n dirty basic templated list class.
//
//  History:    04-26-1999      Alan Shi    (AlanShi)      Created.
//
//----------------------------------------------------------------------------

//
// ListNode
//

typedef void * LISTNODE;

template <class Type> class ListNode {
    public:
        ListNode(Type item);
        virtual ~ListNode();

        void SetNext(ListNode *pNode);
        void SetPrev(ListNode *pNode);
        Type GetItem();
        ListNode *GetNext();
        ListNode *GetPrev();

    private:
        DWORD               _dwSig;
        Type                _type;
        ListNode           *_pNext;
        ListNode           *_pPrev;
};

//
// List
//

template <class Type> class List {
    public:
        List();
        ~List();

        LISTNODE AddHead(const Type &item);
        LISTNODE AddTail(const Type &item);

        LISTNODE GetHeadPosition();
        LISTNODE GetTailPosition();
        void RemoveAt(LISTNODE pNode);
        void RemoveAll();
        LISTNODE Find(const Type &item);
        int GetCount();
        Type GetNext(LISTNODE &pNode);
        Type GetAt(LISTNODE pNode);
        LISTNODE AddSorted(const Type &item, LPVOID pfn);

    public:
        DWORD                            _dwSig;

    private:
        ListNode<Type>                  *_pHead;
        ListNode<Type>                  *_pTail;
        int                              _iCount;
};

//
// ListNode Implementation
//

template <class Type> ListNode<Type>::ListNode(Type item)
: _pNext(NULL)
, _pPrev(NULL)
, _type(item)
{
    _dwSig = 'EDON';
}

template <class Type> ListNode<Type>::~ListNode()
{
}

template <class Type> void ListNode<Type>::SetNext(ListNode *pNode)
{
    _pNext = pNode;
}

template <class Type> void ListNode<Type>::SetPrev(ListNode *pNode)
{
    _pPrev = pNode;
}

template <class Type> Type ListNode<Type>::GetItem()
{
    return _type;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetNext()
{
    return _pNext;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetPrev()
{
    return _pPrev;
}


//
// List Implementation
//


template <class Type> List<Type>::List()
: _pHead(NULL)
, _pTail(NULL)
, _iCount(0)
{
    _dwSig = 'TSIL';
}

template <class Type> List<Type>::~List()
{
    RemoveAll();
}

template <class Type> LISTNODE List<Type>::AddHead(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;

    pNode = NEW(ListNode<Type>(item));
    if (pNode) {
        _iCount++;
       pNode->SetNext(_pHead);
       pNode->SetPrev(NULL);
       if (_pHead == NULL) {
           _pTail = pNode;
       }
       else {
           _pHead->SetPrev(pNode);
       }
       _pHead = pNode;
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddSorted(const Type &item, 
                                                     LPVOID pfn)
{
    ListNode<Type>           *pNode = NULL;
    LISTNODE           pCurrNode = NULL;
    LISTNODE           pPrevNode = NULL;
    int                      i;
    Type                     curItem;

    LONG (*pFN) (const Type item1, const Type item2);

    pFN = (LONG (*) (const Type item1, const Type item2))pfn;

    if(_pHead == NULL) {
        return AddHead(item);
    }
    else {
        pCurrNode = GetHeadPosition();
        curItem = ((ListNode<Type> *) pCurrNode)->GetItem();
        for (i = 0; i < _iCount; i++) {
            if (pFN(item, curItem) < 1) {
                pNode = NEW(ListNode<Type>(item));
                pNode->SetPrev((ListNode<Type> *)pPrevNode);
                pNode->SetNext((ListNode<Type> *)pCurrNode);
                if(pPrevNode) {
                    ((ListNode<Type> *)pPrevNode)->SetNext(pNode);
                }
                else {
                    _pHead = pNode;
                }
                _iCount++;
                break;
            }
            pPrevNode = pCurrNode;
            curItem = GetNext(pCurrNode);
            if(i+1 == _iCount)
                return AddTail(item);
        }
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddTail(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;
    
    pNode = NEW(ListNode<Type>(item));
    if (pNode) {
        _iCount++;
        if (_pTail) {
            pNode->SetPrev(_pTail);
            _pTail->SetNext(pNode);
            _pTail = pNode;
        }
        else {
            _pHead = _pTail = pNode;
        }
    }

    return (LISTNODE)pNode;
}

template <class Type> int List<Type>::GetCount()
{
    return _iCount;
}

template <class Type> LISTNODE List<Type>::GetHeadPosition()
{
    return (LISTNODE)_pHead;
}

template <class Type> LISTNODE List<Type>::GetTailPosition()
{
    return (LISTNODE)_pTail;
}

template <class Type> Type List<Type>::GetNext(LISTNODE &pNode)
{
    Type                  item;
    ListNode<Type>       *pListNode = (ListNode<Type> *)pNode;

    // Faults if you pass NULL
    item = pListNode->GetItem();
    pNode = (LISTNODE)(pListNode->GetNext());

    return item;
}

template <class Type> void List<Type>::RemoveAll()
{
    int                        i;
    LISTNODE                   listNode = NULL;
    ListNode<Type>            *pDelNode = NULL;

    listNode = GetHeadPosition();

    for (i = 0; i < _iCount; i++) {
        pDelNode = (ListNode<Type> *)listNode;
        GetNext(listNode);
        delete pDelNode;
    }
    
    _iCount = 0;
    _pHead = NULL;
    _pTail = NULL;
}

template <class Type> void List<Type>::RemoveAt(LISTNODE pNode)
{
    ListNode<Type>           *pListNode = (ListNode<Type> *)pNode;
    ListNode<Type>           *pPrevNode = NULL;
    ListNode<Type>           *pNextNode = NULL;

    if (pNode) {
        pPrevNode = pListNode->GetPrev();
        pNextNode = pListNode->GetNext();

        if (pPrevNode) {
            pPrevNode->SetNext(pNextNode);
            if (pNextNode) {
                pNextNode->SetPrev(pPrevNode);
            }
            else {
                // We're removing the last node, so we have a new tail
                _pTail = pPrevNode;
            }
            delete pNode;
            pNode = NULL;
        }
        else {
            // No previous, so we are the head of the list
            _pHead = pNextNode;
            if (pNextNode) {
                pNextNode->SetPrev(NULL);
            }
            else {
                // No previous, or next. There was only one node.
                _pHead = NULL;
                _pTail = NULL;
            }
            delete pNode;
        }

        _iCount--;
    }
}
        

template <class Type> LISTNODE List<Type>::Find(const Type &item)
{
    int                      i;
    Type                     curItem;
    LISTNODE                 pNode = NULL;
    LISTNODE                 pMatchNode = NULL;
    ListNode<Type> *         pListNode = NULL;

    pNode = GetHeadPosition();
    for (i = 0; i < _iCount; i++) {
        pListNode = (ListNode<Type> *)pNode;
        curItem = GetNext(pNode);
        if (curItem == item) {
            pMatchNode = (LISTNODE)pListNode;
            break;
        }
    }

    return pMatchNode;
}

template <class Type> Type List<Type>::GetAt(LISTNODE pNode)
{
    ListNode<Type>                *pListNode = (ListNode<Type> *)pNode;

    // Faults if pListNode == NULL
    return pListNode->GetItem();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\mdlmgr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __MDLMGR_H_INCLUDED__
#define __MDLMGR_H_INCLUDED__

#include "dbglog.h"

class CModDownloadMgr : public IDownloadMgr, public ICodebaseList
{
    public:
        CModDownloadMgr(IAssemblyName *pName, IAssemblyManifestImport *pManImport, 
            IApplicationContext *pAppCtx, CDebugLog *pdbglog);
        virtual ~CModDownloadMgr();

        HRESULT Init(LPCWSTR pwzCodebase, LPCWSTR pwzModuleName);

        static HRESULT Create(CModDownloadMgr **ppDLMgr, IAssemblyName *pName,
                              IAssemblyManifestImport *pManImport, 
                              IApplicationContext *pAppCtx, LPCWSTR pwzCodebase,
                              LPCWSTR pwzModuleName, CDebugLog *pdbglog);

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IDownloadMgr methods

        STDMETHODIMP DoSetup(LPCWSTR wzSourceUrl, LPCWSTR wzFilePath,
                             const FILETIME *pftLastMod, IUnknown **ppUnk);
        STDMETHODIMP ProbeFailed(IUnknown **ppUnk);
        STDMETHODIMP PreDownloadCheck(void **ppv);
        STDMETHODIMP IsDuplicate(IDownloadMgr *ppDLMgr);
        STDMETHODIMP LogResult();
        STDMETHODIMP DownloadEnabled(BOOL *pbEnabled);

        // ICodebaseList methods

        STDMETHODIMP AddCodebase(LPCWSTR wzCodebase, DWORD dwFlags);
        STDMETHODIMP RemoveCodebase(DWORD dwIndex);
        STDMETHODIMP GetCodebase(DWORD dwIndex, DWORD *pdwFlags, LPWSTR wzCodebase, DWORD *pcbCodebase);
        STDMETHODIMP GetCount(DWORD *pdwCount);
        STDMETHODIMP RemoveAll();

    private:
        DWORD                                       _dwSig;
        ULONG                                       _cRef;
        LONGLONG                                    _llFlags;
        DWORD                                       _dwNumCodebases;
        LPWSTR                                      _pwzCodebase;
        LPWSTR                                      _pwzModuleName;
        IAssemblyName                              *_pName;
        IAssemblyManifestImport                    *_pManImport;
        IApplicationContext                        *_pAppCtx;
        CDebugLog                                  *_pdbglog;
};


HRESULT AddModuleToAssembly(IApplicationContext *pAppCtx, IAssemblyName *pName,
                            LPCOLESTR pszURL, FILETIME *pftLastModTime,
                            LPCOLESTR szPath, LPCWSTR pwzModuleName, 
                            IAssemblyManifestImport *pManImport,
                            CDebugLog *pdbglog,
                            IAssemblyModuleImport **ppModImport);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\modimprt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef MODIMPRT_H
#define MODIMPRT_H

#include <windows.h>
#include <winerror.h>
#include <objbase.h>
#include "asmitem.h"
#include "clbutils.h"

class CDebugLog;

STDAPI
CreateAssemblyModuleImport(
    LPTSTR             szModulePath,
    LPBYTE             pbHashValue,
    DWORD              cbHashValue,
    DWORD              dwFlags,
    LPASSEMBLYNAME     pNameDef,
    IAssemblyManifestImport *pManImport,
    LPASSEMBLY_MODULE_IMPORT *ppImport);

class CAssemblyModuleImport : public IAssemblyModuleImport
{
public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IStream methods implemented ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead);

    // *** IStream methods not implemented ***    
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv, ULONG cb,
        ULONG FAR *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
        ULARGE_INTEGER FAR *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD dwCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag);
    STDMETHOD(Clone) (THIS_ LPSTREAM FAR *ppStm);


    // ctor, dtor
    CAssemblyModuleImport ();
    ~CAssemblyModuleImport ();
    
    // Init
    HRESULT Init(
        LPTSTR             szModulePath,
        LPBYTE             pbHashValue,
        DWORD              cbHashValue,
        LPASSEMBLYNAME     pNameDef,
        IAssemblyManifestImport *pManImport,
        DWORD              dwModuleFlags);

    // Read-only get functions
    STDMETHOD(GetModuleName)   (LPOLESTR szModuleName, LPDWORD pccModuleName);
    STDMETHOD(GetHashAlgId)    (LPDWORD pdwHashValueId);
    STDMETHOD(GetHashValue)    (LPBYTE pbHashValue, LPDWORD pcbHashValue);
    STDMETHOD(GetFlags)        (LPDWORD pdwFlags);
    STDMETHOD(GetModulePath)   (LPOLESTR szModulePath, LPDWORD pccModulePath);

    // Download API
    STDMETHODIMP_(BOOL) IsAvailable();
    STDMETHODIMP BindToObject(IAssemblyBindSink *pBindSink,
                              IApplicationContext *pAppCtx,
                              LONGLONG llFlags, LPVOID *ppv);

    // Not present in interface.
    HRESULT GetNameDef(LPASSEMBLYNAME *ppName);

private:
    HRESULT CreateLogObject(CDebugLog **ppdbglog, LPCWSTR pwszModuleName, IApplicationContext *pAppCtx);

private:
    DWORD _dwSig;
    DWORD _cRef;
    HANDLE  _hf;
    TCHAR   _szModulePath[MAX_PATH];
    DWORD   _ccModulePath;

    
    LPBYTE _pbHashValue;
    DWORD  _cbHashValue;
    DWORD  _dwFlags;
    BOOL   _bInitCS;

    LPASSEMBLYNAME _pNameDef;
    IAssemblyManifestImport *_pManImport;
    CRITICAL_SECTION _cs;
};

#endif // MODIMPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\nodefact.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once

#include "list.h"
#include "xmlns.h"

typedef enum tagParseState {
    PSTATE_LOOKUP_CONFIGURATION,
    PSTATE_CONFIGURATION,
    PSTATE_RUNTIME,
    PSTATE_ASSEMBLYBINDING,
    PSTATE_DEPENDENTASSEMBLY,
} ParseState;

#define CFG_CULTURE_NEUTRAL                         L"neutral"

#define XML_CONFIGURATION_DEPTH                    1
#define XML_RUNTIME_DEPTH                          2
#define XML_ASSEMBLYBINDING_DEPTH                  3
#define XML_PROBING_DEPTH                          4
#define XML_DEPENDENTASSEMBLY_DEPTH                4
#define XML_GLOBAL_PUBLISHERPOLICY_DEPTH           4
#define XML_ASSEMBLYIDENTITY_DEPTH                 5
#define XML_BINDINGREDIRECT_DEPTH                  5
#define XML_CODEBASE_DEPTH                         5
#define XML_PUBLISHERPOLICY_DEPTH                  5
#define XML_BINDINGRETARGET_DEPTH                  5



#ifdef FUSION_QUALIFYASSEMBLY_ENABLED

#define XML_QUALIFYASSEMBLY_DEPTH                  4
#define POLICY_TAG_QUALIFYASSEMBLY                 L"urn:schemas-microsoft-com:asm.v1^qualifyAssembly"
#define XML_ATTRIBUTE_PARTIALNAME                  L"partialName"
#define XML_ATTRIBUTE_FULLNAME                     L"fullName"

#endif



#define POLICY_TAG_CONFIGURATION                   L"configuration"
#define POLICY_TAG_RUNTIME                         L"runtime"
#define POLICY_TAG_ASSEMBLYBINDING                 L"urn:schemas-microsoft-com:asm.v1^assemblyBinding"
#define POLICY_TAG_PROBING                         L"urn:schemas-microsoft-com:asm.v1^probing"
#define POLICY_TAG_DEPENDENTASSEMBLY               L"urn:schemas-microsoft-com:asm.v1^dependentAssembly"
#define POLICY_TAG_ASSEMBLYIDENTITY                L"urn:schemas-microsoft-com:asm.v1^assemblyIdentity"
#define POLICY_TAG_BINDINGREDIRECT                 L"urn:schemas-microsoft-com:asm.v1^bindingRedirect"
#define POLICY_TAG_CODEBASE                        L"urn:schemas-microsoft-com:asm.v1^codeBase"
#define POLICY_TAG_PUBLISHERPOLICY                 L"urn:schemas-microsoft-com:asm.v1^publisherPolicy"
#define POLICY_TAG_BINDINGRETARGET                 L"urn:schemas-microsoft-com:asm.v1^bindingRetarget" 

#define XML_ATTRIBUTE_NAME                         L"name"
#define XML_ATTRIBUTE_PUBLICKEYTOKEN               L"publicKeyToken"
#define XML_ATTRIBUTE_CULTURE                      L"culture"
#define XML_ATTRIBUTE_VERSION                      L"version"
#define XML_ATTRIBUTE_OLDVERSION                   L"oldVersion"
#define XML_ATTRIBUTE_NEWVERSION                   L"newVersion"
#define XML_ATTRIBUTE_HREF                         L"href"
#define XML_ATTRIBUTE_APPLY                        L"apply"
#define XML_ATTRIBUTE_PRIVATEPATH                  L"privatePath"

#define XML_ATTRIBUTE_NEWPUBLICKEYTOKEN            L"newPublicKeyToken"
#define XML_ATTRIBUTE_APPLIESTO                    L"appliesTo"

#define XML_ATTRIBUTE_NEWNAME                      L"newName"

class CAsmBindingInfo;
class CQualifyAssembly;
class CCodebaseHint;
class CBindingRedir;
class CBindingRetarget;
class CDebugLog;
class CNamespaceManager;

class CNodeFactory : public IXMLNodeFactory
{
    public:
        CNodeFactory(CDebugLog *pdbglog);
        virtual ~CNodeFactory();

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IXMLNodeFactory methods

        STDMETHODIMP NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt);
        STDMETHODIMP BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
        STDMETHODIMP EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
        STDMETHODIMP Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo);
        STDMETHODIMP CreateNode(IXMLNodeSource __RPC_FAR *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo);

        // Other methods

        HRESULT GetRetargetedAssembly(LPCWSTR wzAssemblyNameIn, LPCWSTR wzPublicKeyTokenIn, LPCWSTR wzCulture, LPCWSTR wzVersionIn, LPWSTR *ppwzAssemblyNameOut, LPWSTR *ppwzPublicKeyTokenOut, LPWSTR *ppwzVersionOut);

        HRESULT GetPolicyVersion(LPCWSTR wzAssemblyName, LPCWSTR wzPublicKeyToken,
                                 LPCWSTR wzCulture, LPCWSTR wzVersionIn,
                                 LPWSTR *ppwzVersionOut);

        HRESULT GetSafeMode(LPCWSTR wzAssemblyName, LPCWSTR wzPublicKeyToken,
                            LPCWSTR wzCulture, LPCWSTR wzVersionIn,
                            BOOL *pbSafeMode);

        HRESULT GetCodebaseHint(LPCWSTR pwzAsmName, LPCWSTR pwzVersion,
                                LPCWSTR pwzPublicKeyToken, LPCWSTR pwzCulture,
                                LPCWSTR pwzAppBase, LPWSTR *ppwzCodebase);

        HRESULT GetSharedPath(LPWSTR *ppwzSharedPath);
        HRESULT GetPrivatePath(LPWSTR *ppwzPrivatePath);
        HRESULT QualifyAssembly(LPCWSTR pwzDisplayName, IAssemblyName **ppNameQualified, CDebugLog *pdbglog);
        
        VOID    DisableAppliesTo();
    private:
        HRESULT ProcessProbingTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);
        HRESULT ProcessQualifyAssemblyTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);
        HRESULT ProcessBindingRedirectTag(XML_NODE_INFO **aNodeInfo,
                                          USHORT cNumRecs, CBindingRedir *pRedir);
        HRESULT ProcessBindingRetargetTag(XML_NODE_INFO **aNodeInfo,
                                          USHORT cNumRecs, CBindingRetarget *pRetarget);

        HRESULT ProcessAssemblyBindingTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);
        HRESULT ProcessCodebaseTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs,
                                   CCodebaseHint *pCB);
        HRESULT ProcessPublisherPolicyTag(XML_NODE_INFO **aNodeInfo,
                                          USHORT cNumRecs,
                                          BOOL bGlobal);
        HRESULT ProcessAssemblyIdentityTag(XML_NODE_INFO **aNodeInfo, USHORT cNumRecs);
        
        HRESULT ApplyNamespace(XML_NODE_INFO *pNodeInfo, LPWSTR *ppwzTokenNS,
                               DWORD dwFlags);

    private:
        DWORD                             _dwSig;
        DWORD                             _cRef;
        DWORD                             _dwState;
        DWORD                             _dwCurDepth;
        BOOL                              _bGlobalSafeMode;
        LPWSTR                            _pwzPrivatePath;
        List<CAsmBindingInfo *>           _listAsmInfo;
        List<CQualifyAssembly *>          _listQualifyAssembly;
        CDebugLog                        *_pdbglog;
        CAsmBindingInfo                  *_pAsmInfo;
        CNamespaceManager                 _nsmgr;
        // Is current runtime version matching the ones specified in "appliesTo"?
        BOOL                              _bCorVersionMatch;
        BOOL                              _bHonorAppliesTo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\naming.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NAMING_INCLUDED
#define _NAMING_INCLUDED

#include "fusionp.h"
#include "fuspriv.h"

#define MAX_SID_LENGTH                         1024
#define FUSION_TAG_SID                         L"__fusion__:"

class CDebugLog;

#ifdef __cplusplus

#define MAX_PUBLIC_KEY_TOKEN_LEN      1024
#define MAX_VERSION_DISPLAY_SIZE  sizeof("65535.65535.65535.65535")

class CAssemblyDownload;
class CAsmDownloadMgr;
class CDebugLog;
class CAssembly;


STDAPI
CreateAssemblyNameObjectFromMetaData(
    LPASSEMBLYNAME    *ppAssemblyName,
    LPCOLESTR          szAssemblyName,
    ASSEMBLYMETADATA  *pamd,
    LPVOID             pvReserved);

// Binding methods
static HRESULT DownloadAppCfg(IApplicationContext *pAppCtx, CAssemblyDownload *padl,
                       IAssemblyBindSink *pbindsink, CDebugLog *pdbglog, BOOL bAsyncAllowed);

#ifdef FUSION_CODE_DOWNLOAD_ENABLED    
static HRESULT DownloadAppCfgAsync(IApplicationContext *pAppCtx,
                            CAssemblyDownload *padl, LPCWSTR wszURL,
                            CDebugLog *pdbglog);
#endif

// classes invisible to 'C'

struct Property
{
    LPVOID pv;
    DWORD  cb;
};

class CPropertyArray
{
private:

    DWORD    _dwSig;
    Property _rProp[ASM_NAME_MAX_PARAMS];

public:

    CPropertyArray();
    ~CPropertyArray();

    inline HRESULT Set(DWORD PropertyId, LPVOID pvProperty, DWORD  cbProperty);
    inline HRESULT Get(DWORD PropertyId, LPVOID pvProperty, LPDWORD pcbProperty);
    inline Property operator [] (DWORD dwPropId);
};



class CAssemblyName : public IAssemblyName
{

private:

    DWORD        _dwSig;
    DWORD        _cRef;
    CPropertyArray _rProp;
    BOOL         _fIsFinalized;
    BOOL         _fPublicKeyToken;
    BOOL         _fCustom;
    BOOL         _fCSInitialized;
    CRITICAL_SECTION _cs;
    
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyName methods
    STDMETHOD(SetProperty)(
        /* in */ DWORD  PropertyId,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD  cbProperty);


    STDMETHOD(GetProperty)(
        /* in      */  DWORD    PropertyId,
        /*     out */  LPVOID   pvProperty,
        /* in  out */  LPDWORD  pcbProperty);


    STDMETHOD(Finalize)();

    STDMETHOD(GetDisplayName)(
        /* [out]   */   LPOLESTR  szDisplayName,
        /* in  out */   LPDWORD   pccDisplayName,
        /* [in]    */   DWORD     dwDisplayFlags);
   
    STDMETHOD(GetName)( 
        /* [out][in] */ LPDWORD lpcwBuffer,
        /* [out] */ LPOLESTR pwzBuffer);

    STDMETHOD(GetVersion)( 
        /* [out] */ LPDWORD pwVersionHi,
        /* [out] */ LPDWORD pwVersionLow);
    
    STDMETHOD (IsEqual)(
        /* [in] */ LPASSEMBLYNAME pName,
        /* [in] */ DWORD dwCmpFlags);
        
    STDMETHOD (IsEqualLogging)(
        /* [in] */ LPASSEMBLYNAME pName,
        /* [in] */ DWORD dwCmpFlags,
        /* [in] */ CDebugLog *pdbglog);

    STDMETHOD(BindToObject)(
        /* in      */  REFIID               refIID,
        /* in      */  IUnknown            *pUnkBindSink,
        /* in      */  IUnknown            *pUnkAppCtx,
        /* in      */  LPCOLESTR            szCodebase,
        /* in      */  LONGLONG             llFlags,
        /* in      */  LPVOID               pvReserved,
        /* in      */  DWORD                cbReserved,
        /*     out */  VOID               **ppv);

    STDMETHODIMP Clone(IAssemblyName **ppName);

    CAssemblyName();
    ~CAssemblyName();

    HRESULT GetVersion(DWORD   dwMajorVersionEnumValue, 
                          LPDWORD pdwVersionHi,
                          LPDWORD pdwVersionLow);

    HRESULT GetFileVersion( LPDWORD pdwVersionHi, LPDWORD pdwVersionLow);

    HRESULT Init(LPCTSTR pszAssemblyName, ASSEMBLYMETADATA *pamd);

    static ULONGLONG GetVersion(IAssemblyName *pName);

    HRESULT Parse(LPWSTR szDisplayName);
    HRESULT GetPublicKeyToken(LPDWORD cbBuf, LPBYTE pbBuf, BOOL fDisplay);
    static BOOL IsPartial(IAssemblyName *pName, LPDWORD pdwCmpMask = NULL);
    
    HRESULT SetDefaults();

private:

    // Generate PublicKeyToken from public key blob.
    HRESULT GetPublicKeyTokenFromPKBlob(LPBYTE pbPublicKeyToken, DWORD cbPublicKeyToken,
        LPBYTE *ppbSN, LPDWORD pcbSN);
   
    
    HRESULT CreateLogObject(CDebugLog **ppdbglog, LPCWSTR szCodebase, IApplicationContext *pAppCtx);
    HRESULT DescribeBindInfo(CDebugLog *pdbglog, IApplicationContext *pAppCtx, LPCWSTR wzCodebase, LPCWSTR pwzCallingAsm);
    HRESULT ProcessDevPath(IApplicationContext *pAppCtx, LPVOID *ppv, CAssembly *pCAsmParent, CDebugLog *pdbglog);
};

// classes invisible to 'C'
#endif

#endif _NAMING_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\parse.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef PARSE_H
#define PARSE_H

#define CTSTRLEN(s) (sizeof(s)/sizeof(TCHAR) - 1)
#define RFC1766_KEY_SZ L"MIME\\Database\\Rfc1766"

#define NAME_BUF_SIZE MAX_PATH
#define VALUE_BUF_SIZE MAX_PATH

// Used for generating display name.
#define FLAG_QUOTE          0x1
#define FLAG_DELIMIT        0x2

#define PARSE_FLAGS_LCID_TO_SZ 0x1
#define PARSE_FLAGS_SZ_TO_LCID 0x2

// ---------------------------------------------------------------------------
// CParseUtils
// Generic parsing utils.
// ---------------------------------------------------------------------------
class CParseUtils
{

public:

    // Inline strip leading and trailing whitespace.
    static VOID TrimWhiteSpace(LPWSTR *psz, LPDWORD pcc);

    // Inline parse of delimited token.
    static BOOL GetDelimitedToken(LPWSTR* pszBuf,   LPDWORD pccBuf,
        LPWSTR* pszTok,   LPDWORD pccTok, WCHAR cDelim);
        
    // Inline parse of key=value token.
    static BOOL GetKeyValuePair(LPWSTR  szB,    DWORD ccB,
        LPWSTR* pszK,   LPDWORD pccK, LPWSTR* pszV,   LPDWORD pccV);

    // Outputs token to buffer.
    static HRESULT SetKey(LPWSTR szBuffer, LPDWORD pccBuffer, 
        PCWSTR szKey, DWORD ccAlloced, DWORD dwFlags);

    // Outputs key=value token to buffer.
    static HRESULT SetKeyValuePair(LPWSTR szBuffer, LPDWORD pcbBuffer, PCWSTR szKey, 
        PCWSTR szValue,  DWORD cbAlloced, DWORD dwFlags);

    // Converts binary to hex encoded unicode string.
    static VOID BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst);

    // Converts hex encoded unicode string to binary.
    static VOID UnicodeHexToBin(LPCWSTR pSrc, UINT cSrc, LPBYTE pDest);


};

#endif // PARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\platform.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  File:       platform.h
//
//  Contents:   Macros for portable access to platform dependent values.
//
//
// This file contains macros for easy cross platform developing.
// There are macros for compiler differences and platform/layer differences.
//
//----------------------------------------------------------------------------


#ifndef __PLATFORM_H_
#define __PLATFORM_H_

#ifdef __cplusplus
   // +++ Unaligned memory access templates/macros
// #  include <unaligned.hpp>
#endif

////////////////////////////////////////////////////////////////////
//
// Global defines (should be moved to NT public headers)
//

#define VER_PLATFORM_WIN32_UNIX 9

////////////////////////////////////////////////////////////////////
//
// Compiler differences
//

#if !defined(_MSC_VER) && !defined(__APOGEE__)
    // For compilers lacking VC++ extensions

#   define __cdecl
#   define INLINEOP      /* Inline operators not available IEUNIX */

#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX

#else // !_MSC_VER

    // VC++ compilers

#   define INLINEOP inline
#   define UNSIZED_ARRAY

#endif

#define EMPTY_SIZE UNSIZED_ARRAY

////////////////////////////////////////////////////////////////////
//
// Platform / Layer dependent sections.
//
// NOTE! #ifdefing based on WIN32 is invalid as some layers define
//       WIN32 for compatability.
//

#define ENDEXCEPT  __endexcept
#define ENDFINALLY __endfinally

#if !defined( UNIX )
#define __endexcept
#define __endfinally
#endif // UNIX

// +++ File Separators

#if defined( UNIX )
// UNIX

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '/'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'/'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "/"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"/"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ':'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L':'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ":"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L":"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\n"
#  endif

#else // UNIX

// Windows / MAC

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '\\'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'\\'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "\\"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"\\"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ';'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L';'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ";"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L";"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\r\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\r\n"
#  endif

#endif // Windows / MAC



#ifdef UNIX


#  define PLATFORM_ACCEL_KEY ALT
#  define PLATFORM_ACCEL_STR "Alt"  // --  Look in rc.sed files
#  define FACCELKEY FALT

#define VK_OEM_SLASH 0xBF

#else   /* UNIX  */

#define INTERFACE_PROLOGUE(a)
#define INTERFACE_EPILOGUE(a)
#define INTERFACE_PROLOGUE_(a,b)
#define INTERFACE_EPILOGUE_(a,b)


#  define PLATFORM_ACCEL_KEY CONTROL
#  define PLATFORM_ACCEL_STR "Ctrl"  // --  Look in rc.sed files
#  define FACCELKEY FCONTROL

#define VK_OEM_SLASH '/'

#endif  /* UNIX */

#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))

#ifdef BIG_ENDIAN
#define MAKE_LI(low,high) { high, low }
#define PALETTE_ENTRY( r, g, b, f )  { f, b, g, r }
#else
#define MAKE_LI(low,high) { low, high }
#define PALETTE_ENTRY( r, g, b, f )  { r, g, b, f }
#endif

#endif // __PLATFORM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\policy.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __POLICY_H_INCLUDED__
#define __POLICY_H_INCLUDED__

#include "ProcessorArchitecture.h"
#include "histinfo.h"

#define POLICY_ASSEMBLY_PREFIX                   L"policy."

class CDebugLog;
class CApplicationContext;
class CNodeFactory;

void GetDefaultPlatform(OSINFO *pOS);

HRESULT GetPolicyVersion(LPCWSTR wzCfgFile, LPCWSTR wzAssemblyName,
                         LPCWSTR wzPublicKeyToken, LPCWSTR wzVersionIn,
                         LPWSTR *ppwzVersionOut, BOOL *pbSafeMode,
                         CDebugLog *pdbglog);

HRESULT PrepQueryMatchData(IAssemblyName *pName, LPWSTR *ppwzAsmName, 
                           LPWSTR *ppwzAsmVersion, LPWSTR *ppwzPublicKeyToken, 
                           LPWSTR *ppwzLanguage);

HRESULT GetPublisherPolicyFilePath(LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken,
                                   LPCWSTR pwzCulture, WORD wVerMajor,
                                   WORD wVerMinor, LPWSTR *ppwzPublisherCfg);

HRESULT GetCodebaseHint(LPCWSTR wzCfgFilePath, LPCWSTR wzAsmName,
                        LPCWSTR wzVersion, LPCWSTR wzPublicKeyToken,
                        LPWSTR *ppwzCodebase, CDebugLog *pdbglog);

HRESULT GetGlobalSafeMode(LPCWSTR wzCfgFilePath, BOOL *pbSafeMode);

// XML in file
HRESULT ParseXML(CNodeFactory **ppNodeFactory, LPCWSTR wzFileName, BOOL bBehaviorEverett,
                 CDebugLog *pdbglog);

// XML in memory
HRESULT ParseXML(CNodeFactory **ppNodeFactory, LPVOID lpMemory, ULONG cbSize, 
                 BOOL bBehaviorEverett, CDebugLog *pdbglog);

HRESULT ApplyPolicy(LPCWSTR wzHostCfg, LPCWSTR wzAppCfg, 
                    IAssemblyName *pNameSource, IAssemblyName **ppNamePolicy,
                    LPWSTR *ppwzPolicyCodebase, IApplicationContext *pAppCtx,
                    AsmBindHistoryInfo *pHistInfo, 
                    BOOL bDisallowApplyPublisherPolicy, BOOL bDisallowAppBindingRedirects,
                    BOOL bUnifyFXAssemblies, CDebugLog *pdbglog);

HRESULT ReadConfigSettings(IApplicationContext *pAppCtx, 
                           LPCWSTR wzAppCfg, CDebugLog *pdbglog);

HRESULT GetVersionFromString(LPCWSTR wzStr, ULONGLONG *pullVer);

BOOL IsMatchingVersion(LPCWSTR wzVerCfg, LPCWSTR wzVerSource);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\mstream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
#ifndef __MSTREAM_H_INCLUDED__
#define __MSTREAM_H_INCLUDED__

// IStream interface for memory.
class CMemoryStream : public IStream
{
    public:
        CMemoryStream();
        virtual ~CMemoryStream();

        HRESULT Init(LPVOID lpStart, ULONG cbSize, BOOL bReadOnly);

        // IUnknown methods:
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

        // ISequentialStream methods:
        STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
        STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);
    
        // IStream methods:
        STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
        STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
        STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
        STDMETHODIMP Commit(DWORD grfCommitFlags);
        STDMETHODIMP Revert();
        STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
        STDMETHODIMP Clone(IStream **ppIStream);

    private:
        DWORD                   _cRef;          
		LPVOID                  _lpStart;       //where the memory block starts
		LPVOID                  _lpCurrent;     //current position
		ULONG                   _cbSize;        //size of the memory block
		BOOL                    _bReadOnly;     //is the memory read only?
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\port32.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((WPARAM)(x))
#define OFFSETOF(x)     ((WPARAM)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) BOOLFROMPTR(hinst)

// HIWORD is typically used to detect whether a pointer parameter
// is a real pointer or is a MAKEINTATOM.  HIWORD64 is the Win64-compatible
// version of this usage.  It does *NOT* return the top word of a 64-bit value.
// Rather, it returns the top 48 bits of the 64-bit value.
//
// Yes, the name weak.  Any better ideas?
//
// BOOLFROMPTR is used when you have a pointer or a ULONG_PTR
// and you want to turn it into a BOOL.  In Win32,
// sizeof(BOOL) == sizeof(LPVOID) so a straight cast works.
// In Win64, you have to do it the slow way because pointers are 64-bit.
//
//
#ifdef _WIN64
#define HIWORD64(p)     ((ULONG_PTR)(p) >> 16)
#define BOOLFROMPTR(p)  ((p) != 0)
#define SPRINTF_PTR     "%016I64x"
#else
#define HIWORD64        HIWORD
#define BOOLFROMPTR(p)  ((BOOL)(p))
#define SPRINTF_PTR     "%08x"
#endif

#define DATASEG_READONLY    ".text"         // don't use this, compiler does this for you
#define DATASEG_PERINSTANCE "INSTDATA"      // per instance data (per process)
#define DATASEG_SHARED      "SHARED"        // global global data (shared across process)
#define CODESEG_INIT        ".text"

#define GetWindowInt        GetWindowLongPtr
#define SetWindowInt        SetWindowLongPtr
#define SetWindowID(hwnd,id)    SetWindowLongPtr(hwnd, GWLP_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLongPtr(hwnd, GCLP_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLongPtr(hwnd, GCLP_HICON))
#define BOOL_PTR                INT_PTR

#ifdef WINNT

#else

typedef TBYTE TUCHAR;

#endif


#else  // !WIN32

typedef LPCSTR LPCTSTR;
typedef LPSTR  LPTSTR;
typedef const short far *LPCWSTR;
#define TEXT(x) (x)

#define ISLPTR(pv)          (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT        "_INIT"

#define GetWindowInt        GetWindowWord
#define SetWindowInt        SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\pcycache.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __PCYCACHE_H_INCLUDED__
#define __PCYCACHE_H_INCLUDED__

#include "list.h"
#include "histinfo.h"

#define POLICY_CACHE_SIZE                  255

class CPolicyMapping {
    public:
        CPolicyMapping(IAssemblyName *pNameSource, IAssemblyName *pNamePolicy,
                       AsmBindHistoryInfo *pBindHistory);
        virtual ~CPolicyMapping();

        static HRESULT Create(IAssemblyName *pNameRefSource,
                              IAssemblyName *pNameRefPolicy,
                              AsmBindHistoryInfo *pBindHistory,
                              CPolicyMapping **ppMapping);

    public:
        IAssemblyName                         *_pNameRefSource;
        IAssemblyName                         *_pNameRefPolicy;
        AsmBindHistoryInfo                     _bindHistory;
};

class CPolicyCache : public IUnknown {
    public:
        CPolicyCache();
        virtual ~CPolicyCache();
        
        static HRESULT Create(CPolicyCache **ppPolicyCache);

        // IUnknown methods

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // Helpers

        HRESULT InsertPolicy(IAssemblyName *pNameRefSource,
                             IAssemblyName *pNameRefPolicy,
                             AsmBindHistoryInfo *pBindHistory);

        HRESULT LookupPolicy(IAssemblyName *pNameRefSource,
                             IAssemblyName **ppNameRefPolicy,
                             AsmBindHistoryInfo *pBindHistory);

    private:
        HRESULT Init();

    private:
        DWORD                                 _cRef;
        BOOL                                  _bInitialized;
        CRITICAL_SECTION                      _cs;
        List<CPolicyMapping *>                _listMappings[POLICY_CACHE_SIZE];

};


HRESULT PreparePolicyCache(IApplicationContext *pAppCtx, CPolicyCache **ppPolicyCache);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\processorarchitecture.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

/*-----------------------------------------------------------------------------
common "code" factored out of FusionWin and FusionUrt
-----------------------------------------------------------------------------*/

//BUGBUG this must be defined in a public header. Is currently in ole32\ih\ole2com.h.
#if defined(_X86_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_INTEL
#elif defined(_ALPHA64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_ALPHA64
#elif defined(_IA64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_IA64
#else
#error Unknown Processor type
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\refcountenum.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once
#ifndef _REFCOUNTENUM_
#define _REFCOUNTENUM_

#include <fusionp.h>
#include "refcount.h"

// implementation of CInstallReferenceEnum
class CInstallReferenceEnum : public IInstallReferenceEnum
{
public:

    CInstallReferenceEnum();
    ~CInstallReferenceEnum();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Main methods.

    STDMETHODIMP GetNextInstallReferenceItem(IInstallReferenceItem **ppRefItem, DWORD dwFlags, LPVOID pvReserved);
    HRESULT Init(IAssemblyName *pName, DWORD dwFlags);

    
private:
    LONG                _cRef;
    CInstallRefEnum    *_pInstallRefEnum;
};

// implementation of CInstallReferenceEnum
class CInstallReferenceItem : public IInstallReferenceItem
{
public:

    CInstallReferenceItem(LPFUSION_INSTALL_REFERENCE);
    ~CInstallReferenceItem();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Main methods.

    STDMETHODIMP CInstallReferenceItem::GetReference(LPFUSION_INSTALL_REFERENCE *ppRefData, DWORD dwFlags, LPVOID pvReserved);

    LPFUSION_INSTALL_REFERENCE    _pRefData;
    
private:
    LONG                _cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\scavenger.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SCAVENGER_H_
#define _SCAVENGER_H_


#include "fusionp.h"
#include "transprt.h"

// ---------------------------------------------------------------------------
// CScavenger
// static Scavenger class
// ---------------------------------------------------------------------------
class CScavenger : public IAssemblyScavenger
{
public:

    CScavenger();
    ~CScavenger();

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // scavenging apis...

    STDMETHOD  (ScavengeAssemblyCache)(
               );

    STDMETHOD  (GetCacheDiskQuotas)(
                            /* [out] */ DWORD *pdwZapQuotaInGAC,
                            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
                            /* [out] */ DWORD *pdwDownloadQuotaUser
                   );

        STDMETHOD (SetCacheDiskQuotas)
                   (
                            /* [in] */ DWORD dwZapQuotaInGAC,
                            /* [in] */ DWORD dwDownloadQuotaAdmin,
                            /* [in] */ DWORD dwDownloadQuotaUser
                   );

    STDMETHOD (GetCurrentCacheUsage)
                    (
                    /* [in] */ DWORD *dwZapUsage,
                    /* [in] */ DWORD *dwDownloadUsage
                    );



    static HRESULT DeleteAssembly( DWORD dwCacheFlags, LPCWSTR pszCustomPath, 
                                   LPWSTR pszManFilePath, BOOL bForceDelete);

    static  HRESULT NukeDownloadedCache();

protected:

private :

    LONG _cRef;
};

HRESULT SetDownLoadUsage(   /* [in] */ BOOL  bUpdate,
                            /* [in] */ int   dwDownloadUsage);

HRESULT DoScavengingIfRequired(BOOL bSynchronous);

HRESULT CreateScavengerThread();

STDAPI CreateScavenger(IUnknown **);

STDAPI NukeDownloadedCache();

HRESULT FlushOldAssembly(LPCWSTR pszCustomPath, LPWSTR pszAsmDirPath, LPWSTR pszManifestFileName, BOOL bForceDelete);

HRESULT CleanupTempDir(DWORD dwCacheFlags, LPCWSTR pszCustomPath);

#endif // _SCAVENGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\refcount.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once
#ifndef _REFCOUNT_
#define _REFCOUNT_

#include "fusion.h"

#define INSTALL_REFERENCES_STRING L"References"

#define UNINSTALL_REG_SUBKEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\"

#define MSI_ID L"MSI"
#define MSI_DESCRIPTION L"Windows Installer"

#define FUSION_GUID_LENGTH  (50)

#define FRC_UNINSTALL_SUBKEY_SCHEME (1)
#define FRC_FILEPATH_SCHEME (2)
#define FRC_OPAQUE_STRING_SCHEME (3)
#define FRC_OSINSTALL_SCHEME (4)
#define FRC_MAX_SCHEME (5)

#define FRC_MSI_SCHEME FRC_MAX_SCHEME

#define KEY_FILE_SCHEME_CHAR  L';'

class CInstallRef
{
    LPCFUSION_INSTALL_REFERENCE _pRefData;
    LPWSTR _szDisplayName;
    WCHAR  _szGUID[FUSION_GUID_LENGTH+1]; // guid length +1
    DWORD  _dwScheme;

public:


    CInstallRef(LPCFUSION_INSTALL_REFERENCE pRefData, LPWSTR _szDisplayName);
    ~CInstallRef();

    HRESULT Initialize();

    HRESULT AddReference(/*
                HANDLE hRegKey, 
                BOOL &rfWasDeleted */);

    HRESULT DeleteReference( /*HANDLE hRefRegKey, BOOL &rfWasDeleted */);

    HRESULT WriteIntoRegistry( HANDLE hRefRegKey );

    HRESULT IsReferencePresentIn( 
                HANDLE hRegKey, 
                BOOL &rfPresent,
                BOOL *pfNonCanonicalDataMatches);

    /*
    const GUID &GetSchemeGuid() const { return m_SchemeGuid; }

    const CBaseStringBuffer &GetIdentifier() const { return m_buffIdentifier; }

    const CBaseStringBuffer &GetCanonicalData() const { return m_buffNonCanonicalData; }

    DWORD GetFlags() const { return m_dwFlags; }

    BOOL SetIdentity(PCASSEMBLY_IDENTITY pAsmIdent) { 
        return m_IdentityReference.Initialize(pAsmIdent);
    }

    const CAssemblyReference& GetIdentity() const { return m_IdentityReference; }


    BOOL GetIdentifierValue( CBaseStringBuffer &pBuffTarget ) const {
        return pBuffTarget.Win32Assign(m_buffGeneratedIdentifier);
    }

    BOOL AcquireContents( const CAssemblyInstallReferenceInformation& );

    */
};

class CInstallRefEnum 
{

public :

    CInstallRefEnum(IAssemblyName *pName, BOOL bDoNotConvertId);
    ~CInstallRefEnum();

    HRESULT ValidateRegKey(HKEY &hkey);

    HRESULT GetNextRef (DWORD dwFlags, LPWSTR pszIdentifier, PDWORD pcchId,
                        LPWSTR pszData, PDWORD pcchData, PDWORD pdwScheme, LPVOID pvReserved);

    HRESULT GetNextReference (DWORD dwFlags, LPWSTR pszIdentifier, PDWORD pcchId,
                                           LPWSTR pszData, PDWORD pcchData, GUID *pGuid, LPVOID pvReserved);

    HRESULT GetNextScheme ();
    HRESULT GetNextIdentifier (LPWSTR pszIdentifier, DWORD *pcchId, LPBYTE pszData, PDWORD pcbData);

    static BOOL GetGUID(DWORD dwScheme, GUID &guid);
    HRESULT CleanUpRegKeys();
    HRESULT ValidateUninstallKey(LPCWSTR pszIdentifier);


private :

    HRESULT _hr;
    HKEY _hkey;
    DWORD _dwIndex;
    DWORD _curScheme;
    DWORD _dwRefsInThisScheme;
    DWORD _dwTotalValidRefs;
    BOOL  _arDeleteSubKeys[FRC_MAX_SCHEME];
    GUID _curGUID;
    LPWSTR _pszDisplayName;
    BOOL _bDone;
    BOOL _bDoNotConvertId;

};

HRESULT EnumActiveRefsToAssembly(IAssemblyName *pName);
HRESULT ActiveRefsToAssembly(/*LPCWSTR pszDisplayName*/ IAssemblyName *pName, PBOOL pbHasActiveRefs);
HRESULT GACAssemblyReference(LPCWSTR pszManifestFilePath, IAssemblyName *pAsmName, LPCFUSION_INSTALL_REFERENCE pRefData, BOOL bAdd);
HRESULT GetRegLocation(LPWSTR &pszRegKeyString, LPCWSTR pszDisplayName, LPCWSTR pszGUIDString);
HRESULT GenerateIdentifier(LPCWSTR pszInputId, DWORD dwScheme, LPWSTR pszGenId, DWORD cchGenId);
HRESULT GenerateKeyFileIdentifier(LPCWSTR pszKeyFilePath, LPWSTR pszVolInfo, DWORD cchVolInfo);
HRESULT ValidateOSInstallReference(LPCFUSION_INSTALL_REFERENCE pRefData);

#endif // _REFCOUNT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\strids.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#define ID_FUSLOG_ASSEMBLY_CREATION_FAILURE              10000
#define ID_FUSLOG_ASSEMBLY_LOOKUP_FAILURE                10001
#define ID_FUSLOG_ISEQUAL_DIFF_NAME                      10005
#define ID_FUSLOG_ISEQUAL_DIFF_VERSION_MAJOR             10006
#define ID_FUSLOG_ISEQUAL_DIFF_VERSION_MINOR             10007
#define ID_FUSLOG_ISEQUAL_DIFF_VERSION_REVISION          10008
#define ID_FUSLOG_ISEQUAL_DIFF_VERSION_BUILD             10009
#define ID_FUSLOG_ISEQUAL_DIFF_PUBLIC_KEY_TOKEN          10010
#define ID_FUSLOG_ISEQUAL_DIFF_CULTURE                   10011
#define ID_FUSLOG_ISEQUAL_DIFF_CUSTOM                    10012
#define ID_FUSLOG_CANONICALIZATION_ERROR                 10014
#define ID_FUSLOG_DEVPATH_NO_PREJIT                      10015
#define ID_FUSLOG_POLICY_CACHE_FAILURE                   10016
#define ID_FUSLOG_APP_CFG_PIGGYBACK                      10017
#define ID_FUSLOG_PREBIND_INFO_START                     10018
#define ID_FUSLOG_PREBIND_INFO_DISPLAY_NAME              10019
#define ID_FUSLOG_PREBIND_INFO_WHERE_REF                 10020
#define ID_FUSLOG_PREBIND_INFO_APPBASE                   10021
#define ID_FUSLOG_PREBIND_INFO_DEVPATH                   10022
#define ID_FUSLOG_PREBIND_INFO_PRIVATE_PATH              10023
#define ID_FUSLOG_PREBIND_INFO_DYNAMIC_BASE              10024
#define ID_FUSLOG_PREBIND_INFO_CACHE_BASE                10025
#define ID_FUSLOG_PREBIND_INFO_APP_NAME                  10026
#define ID_FUSLOG_PREBIND_INFO_END                       10027
#define ID_FUSLOG_APP_CFG_DOWNLOAD                       10028
#define ID_FUSLOG_APP_CFG_DOWNLOAD_LOCATION              10029
#define ID_FUSLOG_LOADCTX_HIT                            10030
#define ID_FUSLOG_APP_CFG_NOT_EXIST                      10031
#define ID_FUSLOG_APP_CFG_FOUND                          10032
#define ID_FUSLOG_PROCESS_DEVPATH                        10033
#define ID_FUSLOG_DEVPATH_UNSET                          10034
#define ID_FUSLOG_DEVPATH_PROBE_MISS                     10035
#define ID_FUSLOG_DEVPATH_REF_DEF_MISMATCH               10036
#define ID_FUSLOG_DEVPATH_FOUND                          10037
#define ID_FUSLOG_DEVPATH_NOT_FOUND                      10038
#define ID_FUSLOG_XML_PRIVATE_ASM_REDIRECT               10039
#define ID_FUSLOG_XML_PARSE_ERROR_CODE                   10041
#define ID_FUSLOG_XML_ASSEMBLYIDENTITY_MISSING_NAME      10042
#define ID_FUSLOG_XML_BINDINGREDIRECT_INSUFFICIENT_DATA  10043
#define ID_FUSLOG_XML_CODEBASE_HREF_MISSING              10044
#define ID_FUSLOG_XML_MULTIPLE_IDENTITIES                10045
#define ID_FUSLOG_PRIVATE_PATH_DUPLICATE                 10046
#define ID_FUSLOG_POLICY_NOT_APPLIED                     10047
#define ID_FUSLOG_HOST_CONFIG_FILE                       10048
#define ID_FUSLOG_HOST_CONFIG_FILE_MISSING               10049
#define ID_FUSLOG_HOST_CFG_REDIRECT                      10051
#define ID_FUSLOG_HOST_CFG_NO_REDIRECT                   10052
#define ID_FUSLOG_APP_CFG_REDIRECT                       10053
#define ID_FUSLOG_APP_CFG_SAFE_MODE                      10054
#define ID_FUSLOG_PUB_CFG_MISSING                        10055
#define ID_FUSLOG_PUB_CFG_FOUND                          10056
#define ID_FUSLOG_PUB_CFG_REDIRECT                       10057
#define ID_FUSLOG_MACHINE_CFG_MISSING                    10058
#define ID_FUSLOG_MACHINE_CFG_FOUND                      10059
#define ID_FUSLOG_MACHINE_CFG_REDIRECT                   10060
#define ID_FUSLOG_REDIRECT_NO_CODEBASE                   10061
#define ID_FUSLOG_POLICY_CODEBASE                        10062
#define ID_FUSLOG_POST_POLICY_REFERENCE                  10063
#define ID_FUSLOG_APPLY_POLICY_FAILED                    10064
#define ID_FUSLOG_CFG_PRIVATE_PATH                       10065
#define ID_FUSLOG_XML_PARSE_ERROR_FILE                   10066
#define ID_FUSLOG_CODEBASE_RETRIEVE_FAILURE              10067
#define ID_FUSLOG_ATTEMPT_NEW_DOWNLOAD                   10068
#define ID_FUSLOG_PROBE_FAIL_BUT_ASM_FOUND               10069
#define ID_FUSLOG_ASM_SETUP_FAILURE                      10070
#define ID_FUSLOG_PREDOWNLOAD_FAILURE                    10071
#define ID_FUSLOG_URLMON_MISSING                         10072
#define ID_FUSLOG_DOWNLOAD_PIGGYBACK                     10073
#define ID_FUSLOG_DOWNLOAD_SUCCESS                       10074
#define ID_FUSLOG_LAST_MOD_FAILURE                       10075
#define ID_FUSLOG_MSI_CODEBASE_UNSUPPORTED               10076
#define ID_FUSLOG_CAB_ASM_NOT_FOUND_EXTRACTED            10077
#define ID_FUSLOG_FAILED_PROBING                         10078
#define ID_FUSLOG_PARTIAL_GAC_UNSUPPORTED                10079
#define ID_FUSLOG_GAC_LOOKUP_SUCCESS                     10080
#define ID_FUSLOG_MSI_INSTALL_ATTEMPT                    10081
#define ID_FUSLOG_MSI_ASM_INSTALL_SUCCESS                10082
#define ID_FUSLOG_POLICY_CACHE_INSERT_FAILURE            10084
#define ID_FUSLOG_MSI_SUCCESS_FUSION_SETUP_FAIL          10085
#define ID_FUSLOG_SETUP_RUN_FROM_SOURCE                  10086
#define ID_FUSLOG_MODULE_INTEGRITY_CHECK_FAILURE         10087
#define ID_FUSLOG_SETUP_DOWNLOAD_CACHE                   10088
#define ID_FUSLOG_REF_DEF_MISMATCH                       10089
#define ID_FUSLOG_SETUP_FAILURE                          10090
#define ID_FUSLOG_IGNORE_INVALID_PROBE                   10091
#define ID_FUSLOG_CACHE_LOOKUP_SUCCESS                   10092
#define ID_FUSLOG_PREJIT_NOT_FOUND                       10093
#define ID_FUSLOG_CODEBASE_CONSTRUCTION_FAILURE          10094
#define ID_FUSLOG_CODEBASE_UNAVAILABLE                   10095
#define ID_FUSLOG_DOWNLOAD_CACHE_LOOKUP_SUCCESS          10096
#define ID_FUSLOG_SETUP_CAB                              10097
#define ID_FUSLOG_TEMP_DIR_CREATE_FAILURE                10098
#define ID_FUSLOG_CAB_EXTRACT_FAILURE                    10099
#define ID_FUSLOG_CAB_ASM_FOUND                          10100
#define ID_FUSLOG_CAB_EXTRACT_SUCCESS                    10101
#define ID_FUSLOG_DOWNLOAD_CACHE_CREATE_FAILURE          10102
#define ID_FUSLOG_CAB_ASM_NOT_FOUND                      10103
#define ID_FUSLOG_TEMP_DIR_REMOVE_FAILURE                10104
#define ID_FUSLOG_MANIFEST_EXTRACT_FAILURE               10105
#define ID_FUSLOG_NAME_DEF_EXTRACT_FAILURE               10106
#define ID_FUSLOG_INVALID_PRIVATE_ASM_LOCATION           10107
#define ID_FUSLOG_PARTIAL_ASM_IN_APP_DIR                 10108
#define ID_FUSLOG_REPROBE_REQUIRED                       10109
#define ID_FUSLOG_DUPLICATE_ASM_COMMIT                   10110
#define ID_FUSLOG_COPY_FILE_FAILURE                      10112
#define ID_FUSLOG_INVALID_LOCATION_INFO                  10113
#define ID_FUSLOG_ASYNC_CFG_DOWNLOAD_SUCCESS             10114
#define ID_FUSLOG_ASYNC_CFG_DOWNLOAD_FAILURE             10115
#define ID_FUSLOG_CACHE_ITEM_CREATE_FAILURE              10116
#define ID_FUSLOG_CACHE_ITEM_COMMIT_FAILURE              10117


#define ID_FUSLOG_OPERATION_SUCCESSFUL                   10118
#define ID_FUSLOG_OPERATION_FAILED                       10119
#define ID_FUSLOG_DETAILED_LOG                           10120
#define ID_FUSLOG_HEADER_TEXT                            10121
#define ID_FUSLOG_BIND_RESULT_TEXT                       10122
#define ID_FUSLOG_NO_DESCRIPTION                         10123
#define ID_FUSLOG_FUSION_DLL_PATH                        10124
#define ID_FUSLOG_EXECUTABLE                             10125

#define ID_FUSLOG_QUALIFIED_ASSEMBLY                     10126
#define ID_FUSLOG_CALLING_ASSEMBLY                       10127

#define ID_FUSLOG_ISEQUAL_DIFF_RETARGET                  10130
#define ID_FUSLOG_RETARGET_CFG_MISSING                   10131
#define ID_FUSLOG_RETARGET_CFG_NAME_REDIRECT             10132
#define ID_FUSLOG_RETARGET_CFG_VER_REDIRECT              10133
#define ID_FUSLOG_RETARGET_CFG_PKT_REDIRECT              10134
#define ID_FUSLOG_XML_PARSE_ERROR_MEMORY                 10135
#define ID_FUSLOG_XML_BINDINGRETARGET_INSUFFICIENT_DATA  10136


#define ID_FUSLOG_CROSS_SITE_REDIRECT                    10140
#define ID_FUSLOG_DISALLOW_APPLY_PUB_POLICY              10141
#define ID_FUSLOG_DISALLOW_APP_BINDING_REDIRECTS         10142

#define ID_FUSLOG_FX_CFG_MISSING                         10150
#define ID_FUSLOG_FX_CFG_VER_REDIRECT                    10151
#define ID_FUSLOG_APPLIESTO_DUPLICATE                    10152

#define ID_FUSLOG_PARTIAL_BIND_DEBUG                     11000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\sem32.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///+---------------------------------------------------------------------------
//
//  File:       Sem.H
//
//  Contents:   Semaphore classes
//
//  Classes:    CMutexSem - Mutex semaphore class
//              CShareSem - Multiple Reader, Single Writer class
//
//  Notes:      No 32-bit implementation exists yet for these classes, it
//              will be provided when we have a 32-bit development
//              environment.  In the meantime, the 16-bit implementations
//              provided here can be used to ensure your code not blocking
//              while you hold a semaphore.
//
//----------------------------------------------------------------------------

#ifndef __SEM32_HXX__
#define __SEM32_HXX__

#pragma once

#include <windows.h>

enum SEMRESULT
{
    SEMSUCCESS = 0,
    SEMTIMEOUT,
    SEMNOBLOCK,
    SEMERROR
};

enum SEMSTATE
{
    SEMSHARED,
    SEMSHAREDOWNED
};

// BUGBUG: inlcude winbase.h or some such
// infinite timeout when requesting a semaphore

#if !defined INFINITE
#define INFINITE 0xFFFFFFFF
#endif

//+---------------------------------------------------------------------------
//
//  Class:      CMutexSem (mxs)
//
//  Purpose:    Mutex Semaphore services
//
//  Interface:  Init            - initializer (two-step)
//              Request         - acquire semaphore
//              Release         - release semaphore
//
//  Notes:      This class wraps a mutex semaphore.  Mutex semaphores protect
//              access to resources by only allowing one client through at a
//              time.  The client Requests the semaphore before accessing the
//              resource and Releases the semaphore when it is done.  The
//              same client can Request the semaphore multiple times (a nest
//              count is maintained).
//              The mutex semaphore is a wrapper around a critical section
//              which does not support a timeout mechanism. Therefore the
//              usage of any value other than INFINITE is discouraged. It
//              is provided merely for compatibility.
//
//----------------------------------------------------------------------------

class CMutexSem
{
public:
                CMutexSem();
    inline BOOL Init();
                ~CMutexSem();

    SEMRESULT   Request(DWORD dwMilliseconds = INFINITE);
    void        Release();

private:
    CRITICAL_SECTION _cs;
};

//+---------------------------------------------------------------------------
//
//  Class:      CLock (lck)
//
//  Purpose:    Lock using a Mutex Semaphore
//
//  Notes:      Simple lock object to be created on the stack.
//              The constructor acquires the semaphor, the destructor
//              (called when lock is going out of scope) releases it.
//
//----------------------------------------------------------------------------

class CLock
{
public:
    CLock ( CMutexSem& mxs );
    ~CLock ();
private:
    CMutexSem&  _mxs;
};


//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem::CMutexSem, public
//
//  Synopsis:   Mutex semaphore constructor
//
//  Effects:    Initializes the semaphores data
//
//  History:    14-Jun-91   AlexT       Created.
//
//----------------------------------------------------------------------------

inline CMutexSem::CMutexSem()
{
    Init();
}

inline CMutexSem::Init()
{
    InitializeCriticalSection(&_cs);
    return TRUE;
};

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem::~CMutexSem, public
//
//  Synopsis:   Mutex semaphore destructor
//
//  Effects:    Releases semaphore data
//
//  History:    14-Jun-91   AlexT       Created.
//
//----------------------------------------------------------------------------

inline CMutexSem::~CMutexSem()
{
    DeleteCriticalSection(&_cs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem::Request, public
//
//  Synopsis:   Acquire semaphore
//
//  Effects:    Asserts correct owner
//
//  Arguments:  [dwMilliseconds] -- Timeout value
//
//  History:    14-Jun-91   AlexT       Created.
//
//  Notes:      Uses GetCurrentTask to establish the semaphore owner, but
//              written to work even if GetCurrentTask fails.
//
//----------------------------------------------------------------------------

inline SEMRESULT CMutexSem::Request(DWORD dwMilliseconds)
{
    dwMilliseconds;

    EnterCriticalSection(&_cs);
    return(SEMSUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem::Release, public
//
//  Synopsis:   Release semaphore
//
//  Effects:    Asserts correct owner
//
//  History:    14-Jun-91   AlexT       Created.
//
//  Notes:      Uses GetCurrentTask to establish the semaphore owner, but
//              written to work even if GetCurrentTask fails.
//
//----------------------------------------------------------------------------

inline void CMutexSem::Release()
{
    LeaveCriticalSection(&_cs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLock::CLock
//
//  Synopsis:   Acquire semaphore
//
//  History:    02-Oct-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

inline CLock::CLock ( CMutexSem& mxs )
: _mxs ( mxs )
{
    _mxs.Request ( INFINITE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLock::~CLock
//
//  Synopsis:   Release semaphore
//
//  History:    02-Oct-91   BartoszM       Created.
//
//----------------------------------------------------------------------------

inline CLock::~CLock ()
{
    _mxs.Release();
}


#endif /* __SEM32_HXX__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\serialst.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

    05-Jul-1999 adriaanc
        nabbed for fusion

--*/

#if defined(__cplusplus)
extern "C" {
#endif


// defines copied from wininet\common
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))


#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))


#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}


#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }


#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }


#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#define LockSerializedList(list) \
    EnterCriticalSection(&(list)->Lock)

#define UnlockSerializedList(list) \
    LeaveCriticalSection(&(list)->Lock)

//
// types
//

#if DBG
typedef struct _RESOURCE_INFO
{
    DWORD Tid;
} RESOURCE_INFO, *LPRESOURCE_INFO;
#endif // DBG

typedef struct {

#if DBG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // DBG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CRITICAL_SECTION Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if DBG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if DBG

VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // DBG

#define InitializeSerializedList(list) \
    { \
        InitializeListHead(&(list)->List); \
        InitializeCriticalSection(&(list)->Lock); \
        (list)->ElementCount = 0; \
    }

#define TerminateSerializedList(list) \
    DeleteCriticalSection(&(list)->Lock)

#define InsertAtHeadOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertHeadList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define InsertAtTailOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertTailList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define RemoveFromSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        RemoveEntryList(entry); \
        --(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // DBG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\priv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef STRICT
#undef STRICT
#endif
#define STRICT

#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL     0x10000000  // stop at the NULL termination; this define is stolen from winnlsp.h
#endif
/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

#ifdef WIN32
#define _SHLWAPI_
#define _OLE32_                     // we delay-load OLE
#define _INC_OLE
#define CONST_VTABLE
#endif

#define CC_INTERNAL

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400
#ifdef WINVER
#undef WINVER
#endif
#define WINVER              0x0400

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <port32.h>
#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
//#include <winnlsp.h>
#include <docobj.h>
#define WANT_SHLWAPI_POSTSPLIT
#include <shlobj.h>
#include <shellapi.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <ccstock.h>
#include "fusionheap.h"
#include <regstr.h>
// #include <vdate.h>



// These are temp hacks !!
#define SEE_MASK_FILEANDURL 0x00400000  // defined in private\inc\shlapip.h !
#define MFT_NONSTRING 0x00000904  // defined in private\inc\winuserp.h !



//
// Local includes
//

#include "thunk.h"

//
// Wrappers so our Unicode calls work on Win95
//

#define lstrcmpW            StrCmpW
#define lstrcmpiW           StrCmpIW
#define lstrcatW            StrCatW
#define lstrcpyW            StrCpyW
#define lstrcpynW           StrCpyNW

#define CharLowerW          CharLowerWrapW
#define CharNextW           CharNextWrapW
#define CharPrevW           CharPrevWrapW

//
// This is a very important piece of performance hack for non-DBCS codepage.
//
#ifdef UNICODE
// NB - These are already macros in Win32 land.
#ifdef WIN32
#undef AnsiNext
#undef AnsiPrev
#endif

#define AnsiNext(x) ((x)+1)
#define AnsiPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)
#endif // DBCS

#define CH_PREFIX TEXT('&')

//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in debug.h)
//

// Trace flags
#define TF_IDLIST           0x00000010      // IDList stuff
#define TF_PATH             0x00000020      // path stuff
#define TF_URL              0x00000040      // URL stuff
#define TF_REGINST          0x00000080      // REGINST stuff
#define TF_RIFUNC           0x00000100      // REGINST func tracing
#define TF_REGQINST         0x00000200      // RegQueryInstall tracing
#define TF_DBLIST           0x00000400      // SHDataBlockList tracing

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

// -1 means use CP_ACP, but do *not* verify
// kind of a hack, but it's DBG and leaves 99% of callers unchanged
#define CP_ACPNOVALIDATE    ((UINT)-1)

//
// Global variables
//
EXTERN_C HINSTANCE g_hinst;

#define HINST_THISDLL   g_hinst

void Dll_EnterCriticalSection(void);
void Dll_LeaveCriticalSection(void);

#define ENTERCRITICAL   Dll_EnterCriticalSection();
#define LEAVECRITICAL   Dll_LeaveCriticalSection();

#if DBG

EXTERN_C int   g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
#define ASSERTCRITICAL      Assert(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner);
#define ASSERTNONCRITICAL   Assert(GetCurrentThreadId() != g_CriticalSectionOwner);

#else // DBG

#define ASSERTCRITICAL
#define ASSERTNONCRITICAL

#endif // DBG

EXTERN_C BOOL g_bRunningOnNT;
EXTERN_C BOOL g_bRunningOnNT5OrHigher;
EXTERN_C BOOL g_bNTBeta2;
EXTERN_C CRITICAL_SECTION g_cs;

// Icon mirroring
EXTERN_C HDC g_hdc;
EXTERN_C HDC g_hdcMask;
EXTERN_C BOOL g_bMirrorOS;

EXTERN_C DWORD_PTR _SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR  *psfi, UINT cbFileInfo, UINT uFlags);
EXTERN_C DWORD_PTR _SHGetFileInfoW(LPCWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW FAR  *psfi, UINT cbFileInfo, UINT uFlags);

EXTERN_C UINT  _DragQueryFileA(HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cch);
EXTERN_C UINT  _DragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);

EXTERN_C UINT _SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);
EXTERN_C int _IsNetDrive(int iDrive);
EXTERN_C int _DriveType(int iDrive);
EXTERN_C int _RealDriveType(int iDrive, BOOL fOKToHitNet);

EXTERN_C LPITEMIDLIST _SHBrowseForFolderW(LPBROWSEINFOW pbiW);
EXTERN_C LPITEMIDLIST _SHBrowseForFolderA(LPBROWSEINFOA pbiA);
EXTERN_C BOOL _SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pwzPath);
EXTERN_C BOOL _SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);
#ifdef UNICODE_SHDOCVW
EXTERN_C BOOL _SHGetNewLinkInfoW(LPCWSTR pszpdlLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags);
EXTERN_C BOOL _SHGetNewLinkInfoA(LPCSTR pszpdlLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags);
EXTERN_C HRESULT _SHDefExtractIconW(LPCWSTR pszFile, int nIconIndex, UINT  uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
EXTERN_C HRESULT _SHDefExtractIconA(LPCSTR pszFile, int nIconIndex, UINT  uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
EXTERN_C HICON _ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);
EXTERN_C HICON _ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);
EXTERN_C BOOL _GetSaveFileNameA(LPOPENFILENAMEA lpofn);
EXTERN_C BOOL _GetSaveFileNameW(LPOPENFILENAMEW lpofn);
EXTERN_C BOOL _GetOpenFileNameA(LPOPENFILENAMEA lpofn);
EXTERN_C BOOL _GetOpenFileNameW(LPOPENFILENAMEW lpofn);
EXTERN_C void _SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
EXTERN_C BOOL _PrintDlgA(LPPRINTDLGA lppd);
EXTERN_C BOOL _PrintDlgW(LPPRINTDLGW lppd);
EXTERN_C BOOL _PageSetupDlgA(LPPAGESETUPDLGA lppsd);
EXTERN_C BOOL _PageSetupDlgW(LPPAGESETUPDLGW lppsd);
#endif

EXTERN_C BOOL _ShellExecuteExW(LPSHELLEXECUTEINFOW pExecInfoW);
EXTERN_C BOOL _ShellExecuteExA(LPSHELLEXECUTEINFOA pExecInfoA);
EXTERN_C int _SHFileOperationW(LPSHFILEOPSTRUCTW pFileOpW);
EXTERN_C int _SHFileOperationA(LPSHFILEOPSTRUCTA pFileOpA);
EXTERN_C UINT _ExtractIconExW(LPCWSTR pwzFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);
EXTERN_C UINT _ExtractIconExA(LPCSTR pszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);


EXTERN_C BOOL  _PlaySoundA(LPCSTR pszSound, HMODULE hMod, DWORD fFlags);
EXTERN_C BOOL  _PlaySoundW(LPCWSTR pszSound, HMODULE hMod, DWORD fFlags);

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\transprt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef TRANSCACHE_H
#define TRANSCACHE_H

#include <fusionp.h>
#include "helpers.h"

// Cache index identifiers
#define TRANSPORT_CACHE_SIMPLENAME_IDX  0x0
#define TRANSPORT_CACHE_ZAP_IDX         0x1
#define TRANSPORT_CACHE_GLOBAL_IDX      0x2


class CCache;

// ---------------------------------------------------------------------------
// CTransCache
// ---------------------------------------------------------------------------
class CTransCache
{
protected:

    DWORD _dwSig;
    
    
public:

    TRANSCACHEINFO*   _pInfo;
    // RefCount
    LONG        _cRef;

    HRESULT     _hr;

    // IINDEX_TRANSCACHE_STRONGNAME_PARTIAL 
    enum StrongPartialFlags
    {
        TCF_STRONG_PARTIAL_NAME            = 0x1,
        TCF_STRONG_PARTIAL_CULTURE         = 0x2,
        TCF_STRONG_PARTIAL_PUBLIC_KEY_TOKEN      = 0x4,
        TCF_STRONG_PARTIAL_MAJOR_VERSION   = 0x8,
        TCF_STRONG_PARTIAL_MINOR_VERSION   = 0x10,
        TCF_STRONG_PARTIAL_BUILD_NUMBER    = 0x20,
        TCF_STRONG_PARTIAL_REVISION_NUMBER = 0x40,
        TCF_STRONG_PARTIAL_CUSTOM          = 0x80
    };

    // IINDEX_TRANSCACHE_SIMPLENAME_PARTIAL 
    enum SimplePartialFlags
    {
        TCF_SIMPLE_PARTIAL_CODEBASE_URL           = 0x1,
        TCF_SIMPLE_PARTIAL_CODEBASE_LAST_MODIFIED = 0x2
    };

            
    // ctor, dtor
    CTransCache(DWORD dwCacheId, CCache *pCache);
    ~CTransCache();

    // RefCount
    LONG AddRef();
    LONG Release();

    static HRESULT Create(CTransCache **ppTransCache, DWORD dwCacheId);
    static HRESULT Create(CTransCache **ppTransCache, DWORD dwCacheId, CCache *pCache);
    static DWORD   CTransCache::GetCacheIndex(DWORD dwCacheType);
    // Deallocates info.
    VOID CleanInfo(TRANSCACHEINFO *pInfo, BOOL fFree = TRUE);

    // apply global QFE
    HRESULT ApplyQFEPolicy(CTransCache **ppOutTransCache);    
    HRESULT Retrieve();
    HRESULT Retrieve(CTransCache **pTransCache, DWORD dwCmpMask);
    BOOL IsMatch(CTransCache *pRec, DWORD dwCmpMaskIn, LPDWORD pdwCmpMaskOut);
    TRANSCACHEINFO* CloneInfo();

    DWORD GetCacheType();
    HRESULT InitShFusion(DWORD dwCacheId, LPWSTR pwzCachePath);
    LPWSTR GetCustomPath();

    
    DWORD MapNameMaskToCacheMask(DWORD dwMask);
    DWORD MapCacheMaskToQueryCols(DWORD dwMask);
    BOOL            IsSimpleName();
    BOOL            IsPurgable();
    ULONGLONG       GetVersion();
    HRESULT UpdateDiskUsage(int dwDiskUsageInKB);

private:
    DWORD _dwTableID;
    CCache *_pCache;

friend class CAssemblyEnum;  // for _dwTableID
};


#endif // TRANSCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\sxs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#define FILE_EXT_MANIFEST                      L".manifest"

//
// SxS structures and APIs copied from winbase.h (to avoid having to
// compile fusion with _WIN32_WINNT >= 0x0500).
//

typedef struct tagACTCTXW {
    ULONG     cbSize;
    DWORD     dwFlags;
    LPCWSTR   lpSource;
    USHORT    wProcessorArchitecture;
    LANGID    wLangId;
    LPCWSTR   lpAssemblyDirectory;
    LPCWSTR   lpResourceName;
    LPCWSTR   lpApplicationName;
} ACTCTXW, *PACTCTXW;

typedef HANDLE (*PFNCREATEACTCTXW)(PACTCTXW pActCtx);
typedef HANDLE (*PFNADDREFACTCTX)(HANDLE hActCtx);
typedef VOID (*PFNRELEASEACTCTX)(HANDLE hActCtx);
typedef BOOL (*PFNACTIVATEACTCTX)(HANDLE hActCtx, ULONG_PTR *lpCookie);
typedef BOOL (*PFNDEACTIVATEACTCTX)(DWORD dwFlags, ULONG_PTR ulCookie);

#define DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION (0x00000001)

#define ACTCTX_FLAG_RESOURCE_NAME_VALID             (0x00000008)
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT             (0x00000010)

#define MAKEINTRESOURCE(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\utf8.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    );

DWORD
_fastcall
Dns_AnsiToUtf8(
    IN      PCHAR       pchAnsi,
    IN      DWORD       cchAnsi,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
Dns_Utf8ToAnsi(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
Dns_LengthOfUtf8ForAnsi(
    IN      PCHAR       pchAnsi,
    IN      DWORD       cchAnsi
    );

BOOL
_fastcall
Dns_IsStringAscii(
    IN      LPSTR       pszString
    );

BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR       pchAnsi,
    IN      DWORD       cchAnsi
    );

DWORD
Dns_ValidateUtf8Byte(
    IN      BYTE    chUtf8,
    IN OUT  PDWORD  pdwTrailCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\xmlns.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __XMLNS_H_INCLUDED__
#define __XMLNS_H_INCLUDED__

#include "list.h"
#include "xmlparser.h"

#define NAMESPACE_HASH_TABLE_SIZE                 31

#define XML_NAMESPACE_TAG                         L"xmlns"
#define XML_NAMESPACE_TAG_LEN                     ((sizeof(XML_NAMESPACE_TAG) / sizeof(WCHAR)) - 1)

#define XML_NAMESPACE_PREFIX_TAG                  L"xmlns:"
#define XML_NAMESPACE_PREFIX_TAG_LEN              ((sizeof(XML_NAMESPACE_PREFIX_TAG) / sizeof(WCHAR)) - 1)

#define XMLNS_FLAGS_APPLY_DEFAULT_NAMESPACE       0x00000001

class CNamespaceMapNode;

typedef List<CNamespaceMapNode *> NamespaceStack;

class CNamespaceMapNode {
    public:
        CNamespaceMapNode();
        virtual ~CNamespaceMapNode();
        
        static HRESULT Create(LPCWSTR pwzPrefix, LPCWSTR pwzURI, DWORD dwCurDepth,
                              CNamespaceMapNode **ppMapNode);

    public:
        LPWSTR                             _pwzPrefix;
        LPWSTR                             _pwzURI;
        DWORD                              _dwDepth;
};

class CNamespaceManager {
    public:
        CNamespaceManager();
        virtual ~CNamespaceManager();

        HRESULT OnCreateNode(IXMLNodeSource __RPC_FAR *pSource,
                             PVOID pNodeParent, USHORT cNumRecs,
                             XML_NODE_INFO __RPC_FAR **aNodeInfo);
        HRESULT OnEndChildren();
        HRESULT Map(LPCWSTR pwzAttribute, LPWSTR *ppwzQualified, DWORD dwFlags);
        void Error(HRESULT hrError);

    private:
        NamespaceStack                         _stackDefNamespace;
        List<NamespaceStack *>                 _listMap[NAMESPACE_HASH_TABLE_SIZE];
        DWORD                                  _dwCurDepth;
        HRESULT                                _hrResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\mparse\asmimprt.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <winerror.h>
#include <shlwapi.h>
#include "naming.h"
#include "debmacro.h"
#include "clbutils.h"
#include "asmimprt.h"
#include "modimprt.h"
#include "policy.h"
#include "fusionheap.h"
#include "lock.h"
#include "cacheutils.h"

pfnGetAssemblyMDImport g_pfnGetAssemblyMDImport = NULL;
COINITIALIZECOR g_pfnCoInitializeCor = NULL;

//-------------------------------------------------------------------
// CreateMetaDataImport
//-------------------------------------------------------------------
HRESULT CreateMetaDataImport(LPCOLESTR pszFilename, IMetaDataAssemblyImport **ppImport)
{
    HRESULT hr;


    hr = InitializeEEShim();
    if (FAILED(hr)) {
        goto exit;
    }

    hr = (*g_pfnGetAssemblyMDImport)(pszFilename, IID_IMetaDataAssemblyImport, (void **)ppImport);
    if (FAILED(hr)) {
        goto exit;
    }

exit:
    
    return hr;
}

// ---------------------------------------------------------------------------
// CreateAssemblyManifestImport
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyManifestImport(
    LPCTSTR szManifestFilePath,
    LPASSEMBLY_MANIFEST_IMPORT *ppImport)
{
    HRESULT hr = S_OK;
    CAssemblyManifestImport *pImport = NULL;

    pImport = NEW(CAssemblyManifestImport);
    if (!pImport)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pImport->Init(szManifestFilePath);

    if (FAILED(hr)) 
    {
        SAFERELEASE(pImport);
        goto exit;
    }

exit:

    *ppImport = pImport;

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport constructor
// ---------------------------------------------------------------------------
CAssemblyManifestImport::CAssemblyManifestImport()
{
    _dwSig                  = 'INAM';
    _pName                  = NULL;
    _pMDImport              = NULL;
    _rAssemblyModuleTokens  = NULL;
    _cAssemblyModuleTokens  = 0;
    *_szManifestFilePath    = TEXT('\0');
    _ccManifestFilePath     = 0;
    _bInitCS                = FALSE;

    _cRef                   = 1;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport destructor
// ---------------------------------------------------------------------------
CAssemblyManifestImport::~CAssemblyManifestImport()
{
    SAFERELEASE(_pName);
    SAFERELEASE(_pMDImport);

    SAFEDELETEARRAY(_rAssemblyModuleTokens);

    if (_bInitCS) {
        DeleteCriticalSection(&_cs);
    }

    CleanModuleList();
}

// ---------------------------------------------------------------------------
// CAssembly::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::Init(LPCTSTR szManifestFilePath)
{
    HRESULT hr = S_OK;
    const cElems = ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE;

    if (!szManifestFilePath) {
        hr = E_INVALIDARG;
        goto exit;
    }

    __try {
        InitializeCriticalSection(&_cs);
        _bInitCS = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    _ccManifestFilePath = lstrlen(szManifestFilePath) + 1;

    ASSERT(_ccManifestFilePath < MAX_PATH);

    memcpy(_szManifestFilePath, szManifestFilePath, _ccManifestFilePath * sizeof(TCHAR));

    // Make sure the path isn't relative
    ASSERT(PathFindFileName(_szManifestFilePath) != _szManifestFilePath);

    _rAssemblyModuleTokens       = NEW(mdFile[cElems]);

    if (!_rAssemblyModuleTokens)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = CopyMetaData();
    if (FAILED(hr)) {
        goto exit;
    }

exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::SetManifestModulePath
// ---------------------------------------------------------------------------
HRESULT CAssemblyManifestImport::SetManifestModulePath(LPWSTR pszModulePath)
{
    HRESULT hr = S_OK;
    if (!pszModulePath)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    _ccManifestFilePath = lstrlen(pszModulePath) + 1;
    ASSERT(_ccManifestFilePath < MAX_PATH);
    memcpy(_szManifestFilePath, pszModulePath, _ccManifestFilePath * sizeof(WCHAR));

exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::GetAssemblyNameDef
// ---------------------------------------------------------------------------

STDMETHODIMP CAssemblyManifestImport::GetAssemblyNameDef(LPASSEMBLYNAME *ppName)
{
    HRESULT                                       hr = S_OK;

    if (!ppName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppName = NULL;

    ASSERT(_pName);

    *ppName = _pName;
    (*ppName)->AddRef();
Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::GetNextAssemblyNameRef
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImport::GetNextAssemblyNameRef(DWORD nIndex, LPASSEMBLYNAME *ppName)
{
    HRESULT     hr              = S_OK;
    HCORENUM    hEnum           = 0;  
    DWORD       cTokensMax      = 0;
    mdAssembly  *rAssemblyRefTokens = NULL;
    DWORD        cAssemblyRefTokens = 0;
    IMetaDataAssemblyImport *pMDImport = NULL;


    TCHAR  szAssemblyName[MAX_PATH];

    const VOID*             pvPublicKeyToken = 0;
    const VOID*             pvHashValue    = NULL;

    DWORD ccAssemblyName = MAX_PATH,
          cbPublicKeyToken   = 0,
          ccLocation     = MAX_PATH,
          cbHashValue    = 0,
          dwRefFlags     = 0;

    INT i;
    
    mdAssemblyRef    mdmar;
    ASSEMBLYMETADATA amd = {0};


    rAssemblyRefTokens = NEW(mdAssemblyRef[ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE]);
    if (!rAssemblyRefTokens) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    if (FAILED(hr = CreateMetaDataImport(_szManifestFilePath, &pMDImport)))
        goto done;

    // Attempt to get token array. If we have insufficient space
    // in the default array we will re-allocate it.
    if (FAILED(hr = pMDImport->EnumAssemblyRefs(
        &hEnum, 
        rAssemblyRefTokens, 
        ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE, 
        &cTokensMax)))
    {
        goto done;
    }
    
    // Number of tokens known. close enum.
    pMDImport->CloseEnum(hEnum);
    hEnum = 0;

    // No dependent assemblies.
    if (!cTokensMax)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto done;
    }

    // Insufficient array size. Grow array.
    if (cTokensMax > ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE)
    {
        // Re-allocate space for tokens.
        SAFEDELETEARRAY(rAssemblyRefTokens);
        cAssemblyRefTokens = cTokensMax;
        rAssemblyRefTokens = NEW(mdAssemblyRef[cAssemblyRefTokens]);
        if (!rAssemblyRefTokens)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // Re-get tokens.        
        if (FAILED(hr = pMDImport->EnumAssemblyRefs(
            &hEnum, 
            rAssemblyRefTokens, 
            cTokensMax, 
            &cAssemblyRefTokens)))
        {
            goto done;
        }

        // Close enum.
        pMDImport->CloseEnum(hEnum);            
        hEnum = 0;
    }
    // Otherwise, the default array size was sufficient.
    else
    {
        cAssemblyRefTokens = cTokensMax;
    }

done:

    // Verify the index passed in. 
    if (nIndex >= cAssemblyRefTokens)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto exit;
    }

    // Reference indexed dep assembly ref token.
    mdmar = rAssemblyRefTokens[nIndex];

    // Default allocation sizes.
    amd.ulProcessor = amd.ulOS = 32;
    amd.cbLocale = MAX_PATH;
    
    // Loop max 2 (try/retry)
    for (i = 0; i < 2; i++)
    {
        // Allocate ASSEMBLYMETADATA instance.
        if (FAILED(hr = AllocateAssemblyMetaData(&amd)))
            goto exit;
   
        // Get the properties for the refrenced assembly.
        hr = pMDImport->GetAssemblyRefProps(
            mdmar,              // [IN] The AssemblyRef for which to get the properties.
            &pvPublicKeyToken,      // [OUT] Pointer to the PublicKeyToken blob.
            &cbPublicKeyToken,      // [OUT] Count of bytes in the PublicKeyToken Blob.
            szAssemblyName,     // [OUT] Buffer to fill with name.
            MAX_PATH,     // [IN] Size of buffer in wide chars.
            &ccAssemblyName,    // [OUT] Actual # of wide chars in name.
            &amd,               // [OUT] Assembly MetaData.
            &pvHashValue,       // [OUT] Hash blob.
            &cbHashValue,       // [OUT] Count of bytes in the hash blob.
/*
            NULL,               // [OUT] Token for Execution Location.
*/
            &dwRefFlags         // [OUT] Flags.
            );

        if (FAILED(hr))
            goto exit;

        // Check if retry necessary.
        if (!i)
        {   
            if (amd.ulProcessor <= 32 
                && amd.ulOS <= 32)
            {
                break;
            }            
            else
                DeAllocateAssemblyMetaData(&amd);
        }

    // Retry with updated sizes
    }

    // Allow for funky null locale convention
    // in metadata - cbLocale == 0 means szLocale ==L'\0'
    if (!amd.cbLocale)
    {
        ASSERT(amd.szLocale && !*(amd.szLocale));
        amd.cbLocale = 1;
    }
    else if (amd.szLocale)
    {
        WCHAR *ptr;
        ptr = StrChrW(amd.szLocale, L';');
        if (ptr)
        {
            (*ptr) = L'\0';
            amd.cbLocale = ((DWORD) (ptr - amd.szLocale) + 1 );
        }            
    }
    else
    {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }
    
    // Create the assembly name object.
    if (FAILED(hr = CreateAssemblyNameObjectFromMetaData(ppName, szAssemblyName, &amd, NULL)))
        goto exit;

    // Set the rest of the properties.
    // PublicKeyToken
    if (FAILED(hr = (*ppName)->SetProperty((pvPublicKeyToken && cbPublicKeyToken) ?
            ASM_NAME_PUBLIC_KEY_TOKEN : ASM_NAME_NULL_PUBLIC_KEY_TOKEN,
            (LPVOID) pvPublicKeyToken, cbPublicKeyToken))

        // Hash value
        || FAILED(hr = (*ppName)->SetProperty(ASM_NAME_HASH_VALUE, 
            (LPVOID) pvHashValue, cbHashValue)))
    {
        goto exit;
    }

        
    // See if the assembly[ref] is retargetable (ie, for a generic assembly).
    if (IsAfRetargetable(dwRefFlags)) {
        BOOL bTrue = TRUE;
        hr = (*ppName)->SetProperty(ASM_NAME_RETARGET, &bTrue, sizeof(bTrue));

        if (FAILED(hr))
            goto exit;
    }

exit:    
    if (FAILED(hr))
        SAFERELEASE(*ppName);
    SAFERELEASE(pMDImport);
    SAFEDELETEARRAY(rAssemblyRefTokens);
    DeAllocateAssemblyMetaData(&amd);
        
    return hr;
}

STDMETHODIMP CAssemblyManifestImport::GetNextAssemblyModule(DWORD nIndex,
                                                            IAssemblyModuleImport **ppImport)
{
    HRESULT                                    hr = S_OK;
    LISTNODE                                   pos;
    DWORD                                      dwCount;
    DWORD                                      i;
    IAssemblyModuleImport                     *pImport = NULL;

    dwCount = _listModules.GetCount();
    if (nIndex >= dwCount) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto Exit;
    }

    pos = _listModules.GetHeadPosition();
    for (i = 0; i <= nIndex; i++) {
        pImport = _listModules.GetNext(pos);
    }

    ASSERT(pImport);

    *ppImport = pImport;
    (*ppImport)->AddRef();

Exit:
    return hr;
}

HRESULT CAssemblyManifestImport::CopyMetaData()
{
    HRESULT                                      hr = S_OK;
    IMetaDataAssemblyImport                     *pMDImport = NULL;

    CleanModuleList();

    hr = CreateMetaDataImport(_szManifestFilePath, &pMDImport); 
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = CopyNameDef(pMDImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = CopyModuleRefs(pMDImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Success

    _pMDImport = pMDImport;
    _pMDImport->AddRef();

Exit:
    SAFERELEASE(pMDImport);
    
    if (FAILED(hr)) {
        CleanModuleList();
    }

    return hr;
}

HRESULT CAssemblyManifestImport::CopyModuleRefs(IMetaDataAssemblyImport *pMDImport)
{
    HRESULT                                      hr = S_OK;
    HCORENUM                                     hEnum = 0;
    mdFile                                       mdf;
    TCHAR                                        szModuleName[MAX_PATH];
    DWORD                                        ccModuleName = MAX_PATH;
    const VOID                                  *pvHashValue = NULL;
    DWORD                                        cbHashValue = 0;
    LPASSEMBLYNAME                               pNameDef = NULL;
    LPASSEMBLYNAME                               pNameDefCopy = NULL;
    DWORD                                        ccPath = 0;
    DWORD                                        dwFlags = 0;
    TCHAR                                        szModulePath[MAX_PATH];
    TCHAR                                       *pszName = NULL;
    mdFile                                       rAssemblyModuleTokens[ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE];
    DWORD                                        cAssemblyModuleTokens = ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE;
    DWORD                                        i;
    IAssemblyModuleImport                       *pImport = NULL;

    ASSERT(pMDImport);
    
    hr = GetAssemblyNameDef(&pNameDef);
    if (FAILED(hr)) {
        goto Exit;
    }

    // Form module file path from manifest path and module name.
    pszName = PathFindFileName(_szManifestFilePath);

    ccPath = pszName - _szManifestFilePath;    
    ASSERT(ccPath < MAX_PATH);

    while (cAssemblyModuleTokens > 0) {
        hr = pMDImport->EnumFiles(&hEnum, rAssemblyModuleTokens,
                                  ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE,
                                  &cAssemblyModuleTokens);
        if (FAILED(hr)) {
            goto Exit;
        }
    
        for (i = 0; i < cAssemblyModuleTokens; i++) {
            mdf = rAssemblyModuleTokens[i];
        
            hr = pMDImport->GetFileProps(
                mdf,            // [IN] The File for which to get the properties.
                szModuleName,   // [OUT] Buffer to fill with name.
                MAX_PATH,       // [IN] Size of buffer in wide chars.
                &ccModuleName,  // [OUT] Actual # of wide chars in name.
                &pvHashValue,   // [OUT] Pointer to the Hash Value Blob.
                &cbHashValue,   // [OUT] Count of bytes in the Hash Value Blob.
                &dwFlags);      // [OUT] Flags.
            if (FAILED(hr)) {
                goto Exit;
            }
            else if (hr == CLDB_S_TRUNCATION) {
                // Cannot have a name greater than MAX_PATH
                hr = FUSION_E_ASM_MODULE_MISSING;
                pMDImport->CloseEnum(hEnum);
                goto Exit;
            }

            if (ccPath + ccModuleName >= MAX_PATH) {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto Exit;
            }
        
            memcpy(szModulePath, _szManifestFilePath, ccPath * sizeof(TCHAR));
            memcpy(szModulePath + ccPath, szModuleName, ccModuleName * sizeof(TCHAR));
            
            hr = pNameDef->Clone(&pNameDefCopy);
            if (FAILED(hr)) {
                pMDImport->CloseEnum(hEnum);
                goto Exit;
            }
    
            hr = CreateAssemblyModuleImport(szModulePath, (LPBYTE)pvHashValue, cbHashValue,
                                            dwFlags, pNameDefCopy, NULL, &pImport);
            if (FAILED(hr)) {
                pMDImport->CloseEnum(hEnum);
                goto Exit;
            }
    
            _listModules.AddTail(pImport);
            SAFERELEASE(pNameDefCopy);
            pImport = NULL;
        }
    }

    pMDImport->CloseEnum(hEnum);
    hr = S_OK;

Exit:
    SAFERELEASE(pNameDef);

    return hr;
}

HRESULT CAssemblyManifestImport::CopyNameDef(IMetaDataAssemblyImport *pMDImport)
{
    HRESULT                                         hr = S_OK;
    mdAssembly                                      mda;
    ASSEMBLYMETADATA                                amd = {0};
    VOID                                           *pvPublicKeyToken = NULL;
    DWORD                                           dwPublicKeyToken = 0;
    TCHAR                                           szAssemblyName[MAX_PATH];
    DWORD                                           dwFlags = 0;
    DWORD                                           dwSize = 0;
    DWORD                                           dwHashAlgId = 0;
    DWORD                                           cbSigSize = 0;
    IAssemblySignature                             *pSignature = NULL;
    IMetaDataImport                                *pImport = NULL;
    GUID                                            guidMVID;
    BYTE                                            abSignature[SIGNATURE_BLOB_LENGTH];

    int                                             i;


    ASSERT(pMDImport);
        
    // Get the assembly token
    hr = pMDImport->GetAssemblyFromScope(&mda);
    if (FAILED(hr)) {
        hr = COR_E_ASSEMBLYEXPECTED;
        goto Exit;
    }

    // Default allocation sizes
    amd.ulProcessor = 32;
    amd.ulOS = 32;
    amd.cbLocale = MAX_PATH;

        // Loop max 2 (try/retry)
    for (i = 0; i < 2; i++) {
        hr = AllocateAssemblyMetaData(&amd);
        if (FAILED(hr)) {
            goto Exit;
        }

        // Get name and metadata
        hr = pMDImport->GetAssemblyProps(             
            mda,            // [IN] The Assembly for which to get the properties.
            (const void **)&pvPublicKeyToken,  // [OUT] Pointer to the PublicKeyToken blob.
            &dwPublicKeyToken,  // [OUT] Count of bytes in the PublicKeyToken Blob.
            &dwHashAlgId,   // [OUT] Hash Algorithm.
            szAssemblyName, // [OUT] Buffer to fill with name.
            MAX_PATH, // [IN]  Size of buffer in wide chars.
            &dwSize,        // [OUT] Actual # of wide chars in name.
            &amd,           // [OUT] Assembly MetaData.
            &dwFlags        // [OUT] Flags.                                                                
          );
        if (FAILED(hr)) {
            if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                hr = FUSION_E_INVALID_NAME;
            }

            goto Exit;
        }

        // Check if retry necessary.
        if (!i)
        {
            if (amd.ulProcessor <= 32 && amd.ulOS <= 32) {
                break;
            }            
            else {
                DeAllocateAssemblyMetaData(&amd);
            }
        }

        // Retry with updated sizes
    }


    
    // Allow for funky null locale convention
    // in metadata - cbLocale == 0 means szLocale ==L'\0'
    if (!amd.cbLocale) {
        ASSERT(amd.szLocale && !*(amd.szLocale));
        amd.cbLocale = 1;
    }
    else if (amd.szLocale) {
        WCHAR *ptr;
        ptr = StrChrW(amd.szLocale, L';');
        if (ptr) {
            (*ptr) = L'\0';
            amd.cbLocale = ((DWORD) (ptr - amd.szLocale) + 1 );
        }            
    }
    else {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto Exit;
    }

    if (lstrlenW(szAssemblyName) >= MAX_PATH) {
        // Name is too long.

        hr = FUSION_E_INVALID_NAME;
        goto Exit;
    }

    // Create a name object and hand it out;
    hr = CreateAssemblyNameObjectFromMetaData(&_pName, szAssemblyName, &amd,
                                              NULL);
    if (FAILED(hr)) {
        goto Exit;
    }

    // See if the assembly[ref] is retargetable (ie, for a generic assembly).
    if (IsAfRetargetable(dwFlags)) {
        BOOL bTrue = TRUE;
        hr = _pName->SetProperty(ASM_NAME_RETARGET, &bTrue, sizeof(bTrue));

        if (FAILED(hr))
            goto Exit;
    }

    hr = _pName->SetProperty(ASM_NAME_HASH_ALGID, &dwHashAlgId, sizeof(DWORD));
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = _pName->SetProperty(((pvPublicKeyToken && dwPublicKeyToken) ? (ASM_NAME_PUBLIC_KEY) : (ASM_NAME_NULL_PUBLIC_KEY)),
                             pvPublicKeyToken, dwPublicKeyToken * sizeof(BYTE));
    if (FAILED(hr)) {
        goto Exit;
    }

    // Set signature blob

    hr = pMDImport->QueryInterface(IID_IAssemblySignature, (void **)&pSignature);
    if (FAILED(hr)) {
        goto Exit;
    }

    // It is legitimate for this to fail if the assembly is not strong name signed.  If so,
    // just skip the property and continue.  No need to reset the HR, since it is assigned
    // to in the statement after this block.
    cbSigSize = SIGNATURE_BLOB_LENGTH;
    hr = pSignature->GetAssemblySignature(abSignature, &cbSigSize);
    if (SUCCEEDED(hr)) {
        if (!(cbSigSize == SIGNATURE_BLOB_LENGTH || cbSigSize == SIGNATURE_BLOB_LENGTH_HASH)) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        // BUGBUG: Always just use the top 20 bytes
        hr = _pName->SetProperty(ASM_NAME_SIGNATURE_BLOB, &abSignature, SIGNATURE_BLOB_LENGTH_HASH);
        if (FAILED(hr)) {
            goto Exit;
        }
    }
    else
        hr = S_OK;

    // Set MVID

    hr = pMDImport->QueryInterface(IID_IMetaDataImport, (void **)&pImport);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = pImport->GetScopeProps(NULL, 0, 0, &guidMVID);
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = _pName->SetProperty(ASM_NAME_MVID, &guidMVID, sizeof(guidMVID));
    if (FAILED(hr)) {
        goto Exit;
    }

    // Set name def to read-only.
    // Any subsequent calls to SetProperty on this name
    // will fire an assert.
    _pName->Finalize();

Exit:
    DeAllocateAssemblyMetaData(&amd);

    SAFERELEASE(pImport);
    SAFERELEASE(pSignature);

    return hr;
}


HRESULT CAssemblyManifestImport::CleanModuleList()
{
    HRESULT                                      hr = S_OK;
    LISTNODE                                     pos;
    IAssemblyModuleImport                       *pImport;

    pos = _listModules.GetHeadPosition();
    while (pos) {
        pImport = _listModules.GetNext(pos);
        SAFERELEASE(pImport);
    }

    _listModules.RemoveAll();

    return hr;
}
    
    
// ---------------------------------------------------------------------------
// CAssemblyManifestImport::GetModuleByName
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImport::GetModuleByName(LPCOLESTR pszModuleName, 
    IAssemblyModuleImport **ppImport)
{
    HRESULT                hr;
    LPTSTR                 pszName;
    DWORD                  dwIdx      = 0;
    IAssemblyModuleImport *pModImport = NULL;
    
    // NULL indicated name means get manifest module.
    if (!pszModuleName)
    {
        // Parse manifest module name from file path.
        pszName = StrRChr(_szManifestFilePath, NULL, TEXT('\\')) + 1;
    }
    // Otherwise get named module.
    else
    {
        pszName = (LPTSTR) pszModuleName;
    }

    // Enumerate the modules in this manifest.
    while (SUCCEEDED(hr = GetNextAssemblyModule(dwIdx++, &pModImport)))
    {
        TCHAR szModName[MAX_PATH];
        DWORD ccModName;
        ccModName = MAX_PATH;
        if (FAILED(hr = pModImport->GetModuleName(szModName, &ccModName)))
            goto exit;
            
        // Compare module name against given.
        if (!FusionCompareStringI(szModName, pszName))
        {
            // Found the module
            break;
        }   
        SAFERELEASE(pModImport);
    }


    if (SUCCEEDED(hr))
        *ppImport = pModImport;

exit:
    return hr;    
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::GetManifestModulePath
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImport::GetManifestModulePath(LPOLESTR pszModulePath, 
    LPDWORD pccModulePath)
{
    HRESULT hr = S_OK;
    
    if (*pccModulePath < _ccManifestFilePath)
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    if (SUCCEEDED(hr))
        memcpy(pszModulePath, _szManifestFilePath, _ccManifestFilePath * sizeof(TCHAR));

    *pccModulePath = _ccManifestFilePath;

    return hr;
}


// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImport::AddRef()
{
    return InterlockedIncrement((LONG *)&_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyManifestImport::Release()
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyManifestImport::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                                  hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IAssemblyManifestImport) || IsEqualIID(riid, IID_IUnknown)) {
        *ppv = (IAssemblyManifestImport *)this;
    }
    else if (IsEqualIID(riid, IID_IMetaDataAssemblyImportControl)) {
        *ppv = (IMetaDataAssemblyImportControl *)this;
    }
    else {
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
} 

// ---------------------------------------------------------------------------
// CAssemblyManifestImport::ReleaseMetaDataAssemblyImport
// ---------------------------------------------------------------------------

STDMETHODIMP CAssemblyManifestImport::ReleaseMetaDataAssemblyImport(IUnknown **ppUnk)
{
    HRESULT                                hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

    if (ppUnk) {
        // Hand out an AddRef'ed IMetaDataAssemblyImport

        *ppUnk = _pMDImport;
        if (*ppUnk) {
            (*ppUnk)->AddRef();
        }
    }

    // Always release our ref count

    if (_pMDImport) {
        SAFERELEASE(_pMDImport);
        hr = S_OK;
    }

    return hr;
}

STDAPI
CreateDefaultAssemblyMetaData(ASSEMBLYMETADATA **ppamd)
{
    HRESULT hr;
    ASSEMBLYMETADATA *pamd;
    
    // Allocate ASSEMBLYMETADATA
    pamd = NEW(ASSEMBLYMETADATA);
    if (!pamd)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    memset(pamd, 0, sizeof(ASSEMBLYMETADATA));
    
    pamd->cbLocale = pamd->ulProcessor = pamd->ulOS = 1;    
    
    if (FAILED(hr = AllocateAssemblyMetaData(pamd)))
        goto exit;

    // Fill in ambient props if specified

    // Default locale is null.
    *(pamd->szLocale) = L'\0';

    // Get platform (OS) info
    GetDefaultPlatform(pamd->rOS);

    // Default processor id.
    *(pamd->rProcessor) = DEFAULT_ARCHITECTURE;


    *ppamd = pamd;    

exit:

    return hr;
}

// Creates an ASSEMBLYMETADATA struct for write.
STDAPI
AllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
    HRESULT hr = S_OK;
    
    // Re/Allocate Locale array
    if (pamd->szLocale)
        delete [] pamd->szLocale;        
    pamd->szLocale = NULL;

    if (pamd->cbLocale) {
        pamd->szLocale = NEW(WCHAR[pamd->cbLocale]);
        if (!pamd->szLocale)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    // Re/Allocate Processor array
    if (pamd->rProcessor)
        delete [] pamd->rProcessor;
    pamd->rProcessor = NEW(DWORD[pamd->ulProcessor]);
    if (!pamd->rProcessor)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Re/Allocate OS array
    if (pamd->rOS)
        delete [] pamd->rOS;
    pamd->rOS = NEW(OSINFO[pamd->ulOS]);
    if (!pamd->rOS)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

/*
    // Re/Allocate configuration
    if (pamd->szConfiguration)
        delete [] pamd->szConfiguration;
    pamd->szConfiguration = NEW(TCHAR[pamd->cbConfiguration = MAX_CLASS_NAME]);
    if (!pamd->szConfiguration)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
*/

exit:
    if (FAILED(hr) && pamd)
        DeAllocateAssemblyMetaData(pamd);

    return hr;
}


STDAPI
DeAllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
    // NOTE - do not 0 out counts
    // since struct may be reused.

    if (pamd->cbLocale)
    {
        delete [] pamd->szLocale;
        pamd->szLocale = NULL;
    }

    if (pamd->rProcessor)
    {    
        delete [] pamd->rProcessor;
        pamd->rProcessor = NULL;
    }
    if (pamd->rOS)
    {
        delete [] pamd->rOS;
        pamd->rOS = NULL;
    }
/*
    if (pamd->szConfiguration)
    {
        delete [] pamd->szConfiguration;
        pamd->szConfiguration = NULL;
    }
*/
    return S_OK;
}

STDAPI
DeleteAssemblyMetaData(ASSEMBLYMETADATA *pamd)
{
    DeAllocateAssemblyMetaData(pamd);
    delete pamd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\urlparse.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef __cplusplus

// SHLWAPI.DLL delay load for URL parsing APIs

class CShlwapi
{
    public:
#define DELAY_SHLWAPI(_fn, _args, _nargs) \
    DWORD _fn _args { \
        HRESULT hres = Init(); \
        DWORD dwRet; \
        if (SUCCEEDED(hres)) { \
            dwRet = _pfn##_fn _nargs; \
        } \
        return dwRet;    } \
    DWORD (STDAPICALLTYPE* _pfn##_fn) _args;

    HRESULT     Init(void);
    CShlwapi();
    ~CShlwapi();

    BOOL    m_fInited;
    HMODULE m_hMod;

    DELAY_SHLWAPI(UrlCanonicalizeW,
        (LPCWSTR pszUrl,
        LPWSTR pszCanonicalized,
        LPDWORD pcchCanonicalized,
        DWORD dwFlags),
        (pszUrl, pszCanonicalized, pcchCanonicalized, dwFlags));

    DELAY_SHLWAPI(UrlCombineW,
        (LPCWSTR pszBase,
        LPCWSTR pszRelative,
        LPWSTR pszCombined,
        LPDWORD pcchCombined,
        DWORD dwFlags),
        (pszBase, pszRelative, pszCombined, pcchCombined, dwFlags));

    DELAY_SHLWAPI(PathCreateFromUrlW,
        (LPCWSTR pszUrl,
        LPWSTR pszPath,
        LPDWORD pcchPath,
        DWORD dwFlags),
        (pszUrl, pszPath, pcchPath, dwFlags));

    DELAY_SHLWAPI(UrlIsW,
        (LPCWSTR pszUrl,
        URLIS UrlIs),
        (pszUrl, UrlIs));

    DELAY_SHLWAPI(UrlGetPartW,
        (LPCWSTR pszIn,
        LPWSTR pszOut,
        LPDWORD pcchOut,
        DWORD dwPart,
        DWORD dwFlags),
        (pszIn, pszOut, pcchOut, dwPart, dwFlags));

    DELAY_SHLWAPI(PathIsURLW,
        (LPCWSTR pszPath),
        (pszPath));
};

inline CShlwapi::CShlwapi()
{
    m_fInited = FALSE;
}

inline CShlwapi::~CShlwapi()
{
    if (m_fInited) {
        FreeLibrary(m_hMod);
    }
}

inline HRESULT CShlwapi::Init(void)
{
    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary(TEXT("SHLWAPI.DLL"));

    if (!m_hMod) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) return E_UNEXPECTED;

    CHECKAPI(UrlCanonicalizeW);
    CHECKAPI(UrlCombineW);
    CHECKAPI(PathCreateFromUrlW);
    CHECKAPI(UrlIsW);
    CHECKAPI(UrlGetPartW);
    CHECKAPI(PathIsURLW);

    m_fInited = TRUE;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\urtwrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//#define GetBinaryType WszGetBinaryType
//#define GetShortPathName WszGetShortPathName
//#define GetLongPathName WszGetLongPathName
//#define GetEnvironmentStrings WszGetEnvironmentStrings
//#define FreeEnvironmentStrings WszFreeEnvironmentStrings
//#define FormatMessage WszFormatMessage
//#define CreateMailslot WszCreateMailslot
//#define EncryptFile WszEncryptFile
//#define DecryptFile WszDecryptFile
//#define OpenRaw WszOpenRaw
//#define QueryRecoveryAgents WszQueryRecoveryAgents
#define CreateMutex WszCreateMutex
//#define OpenMutex WszOpenMutex
#define CreateEvent WszCreateEvent
//#define OpenEvent WszOpenEvent
//#define CreateWaitableTimer WszCreateWaitableTimer
//#define OpenWaitableTimer WszOpenWaitableTimer
#define CreateFileMapping WszCreateFileMapping
//#define OpenFileMapping WszOpenFileMapping
//#define GetLogicalDriveStrings WszGetLogicalDriveStrings
#define LoadLibrary WszLoadLibrary
//#define LoadLibraryEx WszLoadLibraryEx
#define GetModuleFileName WszGetModuleFileName
#undef GetModuleFileNameW
#define GetModuleFileNameW WszGetModuleFileName
#define GetModuleHandle WszGetModuleHandle
//#define CreateProcess WszCreateProcess
//#define FatalAppExit WszFatalAppExit
//#define GetStartupInfo WszGetStartupInfo
//#define GetCommandLine WszGetCommandLine
//#define GetEnvironmentVariable WszGetEnvironmentVariable
//#define SetEnvironmentVariable WszSetEnvironmentVariable
//#define ExpandEnvironmentStrings WszExpandEnvironmentStrings
//#define OutputDebugString WszOutputDebugString
//#define FindResource WszFindResource
//#define FindResourceEx WszFindResourceEx
//#define EnumResourceTypes WszEnumResourceTypes
//#define EnumResourceNames WszEnumResourceNames
//#define EnumResourceLanguages WszEnumResourceLanguages
//#define BeginUpdateResource WszBeginUpdateResource
//#define UpdateResource WszUpdateResource
//#define EndUpdateResource WszEndUpdateResource
//#define GlobalAddAtom WszGlobalAddAtom
//#define GlobalFindAtom WszGlobalFindAtom
//#define GlobalGetAtomName WszGlobalGetAtomName
//#define AddAtom WszAddAtom
//#define FindAtom WszFindAtom
//#define GetAtomName WszGetAtomName
//#define GetProfileInt WszGetProfileInt
//#define GetProfileString WszGetProfileString
//#define WriteProfileString WszWriteProfileString
//#define GetProfileSection WszGetProfileSection
//#define WriteProfileSection WszWriteProfileSection
//#define GetPrivateProfileInt WszGetPrivateProfileInt
#undef GetPrivateProfileString
#define GetPrivateProfileString WszGetPrivateProfileString
#undef GetPrivateProfileStringW
#define GetPrivateProfileStringW WszGetPrivateProfileString
#undef WritePrivateProfileStringW
#define WritePrivateProfileStringW WszWritePrivateProfileString
#undef WritePrivateProfileString
#define WritePrivateProfileString WszWritePrivateProfileString
//#define GetPrivateProfileSection WszGetPrivateProfileSection
//#define WritePrivateProfileSection WszWritePrivateProfileSection
//#define GetPrivateProfileSectionNames WszGetPrivateProfileSectionNames
//#define GetPrivateProfileStruct WszGetPrivateProfileStruct
//#define WritePrivateProfileStruct WszWritePrivateProfileStruct
#define GetDriveType WszGetDriveType
//#define GetSystemDirectory WszGetSystemDirectory
#undef GetTempPath
#define GetTempPath WszGetTempPath
#undef GetTempPathW
#define GetTempPathW WszGetTempPath
//#define GetTempFileName WszGetTempFileName
#undef GetWindowsDirectoryW
#define GetWindowsDirectoryW WszGetWindowsDirectory
//#define SetCurrentDirectory WszSetCurrentDirectory
#define GetCurrentDirectory WszGetCurrentDirectory
#ifdef UNICODE
#define GetDiskFreeSpace GetDiskFreeSpaceW
#else
#define GetDiskFreeSpace GetDiskFreeSpaceA
#endif
//#define GetDiskFreeSpaceEx WszGetDiskFreeSpaceEx
#define CreateDirectory WszCreateDirectory
#undef CreateDirectoryW
#define CreateDirectoryW WszCreateDirectory
//#define CreateDirectoryEx WszCreateDirectoryEx
#define RemoveDirectory WszRemoveDirectory
//#define GetFullPathName WszGetFullPathName
//#define DefineDosDevice WszDefineDosDevice
//#define QueryDosDevice WszQueryDosDevice
#define CreateFile WszCreateFile
#undef CreateFileW
#define CreateFileW WszCreateFile
#define SetFileAttributes WszSetFileAttributes
#define GetFileAttributes WszGetFileAttributes
#undef GetFileAttributesW
#define GetFileAttributesW WszGetFileAttributes
//#define GetCompressedFileSize WszGetCompressedFileSize
#define DeleteFile WszDeleteFile
//#define FindFirstFileEx WszFindFirstFileEx
#define FindFirstFile WszFindFirstFile
#define FindNextFile WszFindNextFile
#define SearchPath WszSearchPath
#define CopyFile WszCopyFile
//#define CopyFileEx WszCopyFileEx
#define MoveFile WszMoveFile
//#define MoveFileEx WszMoveFileEx
//#define MoveFileWithProgress WszMoveFileWithProgress
//#define CreateSymbolicLink WszCreateSymbolicLink
//#define QuerySymbolicLink WszQuerySymbolicLink
//#define CreateHardLink WszCreateHardLink
//#define CreateNamedPipe WszCreateNamedPipe
//#define GetNamedPipeHandleState WszGetNamedPipeHandleState
//#define CallNamedPipe WszCallNamedPipe
//#define WaitNamedPipe WszWaitNamedPipe
//#define SetVolumeLabel WszSetVolumeLabel
#define GetVolumeInformation WszGetVolumeInformation
//#define ClearEventLog WszClearEventLog
//#define BackupEventLog WszBackupEventLog
//#define OpenEventLog WszOpenEventLog
//#define RegisterEventSource WszRegisterEventSource
//#define OpenBackupEventLog WszOpenBackupEventLog
//#define ReadEventLog WszReadEventLog
//#define ReportEvent WszReportEvent
//#define AccessCheckAndAuditAlarm WszAccessCheckAndAuditAlarm
//#define AccessCheckByTypeAndAuditAlarm WszAccessCheckByTypeAndAuditAlarm
//#define AccessCheckByTypeResultListAndAuditAlarm WszAccessCheckByTypeResult ListAndAuditAlarm
//#define ObjectOpenAuditAlarm WszObjectOpenAuditAlarm
//#define ObjectPrivilegeAuditAlarm WszObjectPrivilegeAuditAlarm
//#define ObjectCloseAuditAlarm WszObjectCloseAuditAlarm
//#define ObjectDeleteAuditAlarm WszObjectDeleteAuditAlarm
//#define PrivilegedServiceAuditAlarm WszPrivilegedServiceAuditAlarm
//#define SetFileSecurity WszSetFileSecurity
//#define GetFileSecurity WszGetFileSecurity
//#define FindFirstChangeNotification WszFindFirstChangeNotification
//#define IsBadStringPtr WszIsBadStringPtr
//#define LookupAccountSid WszLookupAccountSid
//#define LookupAccountName WszLookupAccountName
//#define BuildCommDCB WszBuildCommDCB
//#define BuildCommDCBAndTimeouts WszBuildCommDCBAndTimeouts
//#define CommConfigDialog WszCommConfigDialog
//#define GetDefaultCommConfig WszGetDefaultCommConfig
//#define SetDefaultCommConfig WszSetDefaultCommConfig
//#define SetComputerName WszSetComputerName
//#define GetUserName WszGetUserName
//#define LogonUser WszLogonUser
//#define CreateProcessAsUser WszCreateProcessAsUser
//#define GetCurrentHwProfile WszGetCurrentHwProfile
#define GetVersionEx WszGetVersionEx
//#define CreateJobObject WszCreateJobObject
//#define OpenJobObject WszOpenJobObject

#undef RegOpenKeyEx
#define RegOpenKeyEx WszRegOpenKeyEx
#undef RegCreateKeyEx
#define RegCreateKeyEx WszRegCreateKeyEx
#undef RegDeleteKey
#define RegDeleteKey WszRegDeleteKey
#undef RegQueryInfoKey
#define RegQueryInfoKey WszRegQueryInfoKey
#undef RegEnumValue
#define RegEnumValue WszRegEnumValue
#undef RegSetValueEx
#define RegSetValueEx WszRegSetValueEx
#undef RegDeleteValue
#define RegDeleteValue WszRegDeleteValue
#undef RegQueryValueEx
#define RegQueryValueEx WszRegQueryValueEx
#undef OutputDebugString
#define OutputDebugString WszOutputDebugString
#undef OutputDebugStringW
/*
#undef OutputDebugStringA
#define OutputDebugStringA WszOutputDebugString
#define OutputDebugStringW WszOutputDebugString
*/



#define FormatMessage WszFormatMessage
#define CharLower WszCharLower

#undef CharUpperW
#define CharUpper CharUpperWrapW


#define MessageBox WszMessageBox
#define CreateSemaphore WszCreateSemaphore

#define lstrcmpW            StrCmpW
#define lstrcmpiW           StrCmpIW
#define lstrcatW            StrCatW
#define lstrcpyW            StrCpyW
#define lstrcpynW           StrCpyNW

//#define CharLowerW          CharLowerWrapW
//#define CharNextW           CharNextWrapW
//#define CharPrevW           CharPrevWrapW

#define lstrlen      lstrlenW
#define lstrcmp      lstrcmpW
#define lstrcmpi     lstrcmpiW
#define lstrcpyn     lstrcpynW
#define lstrcpy      lstrcpyW
#define lstrcat      lstrcatW
#define wsprintf     wsprintfW
#define wvsprintf    wvsprintfW

LPWSTR WINAPI
CharUpperWrapW( LPWSTR pch );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\mparse\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Danpo Zhang

!ENDIF

MAJORCOMP=fusion
MINORCOMP=mparse

TARGETNAME=urtmparse
TARGETTYPE=LIBRARY
TARGETPATHLIB=$(FUSION_LIB_DEST)

SOURCES= \
    asmimprt.cpp \
    modimprt.cpp

SOURCES_USED=sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\mparse\modimprt.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "asmstrm.h"
#include "debmacro.h"
#include "modimprt.h"
#include "asmcache.h"
#include "adl.h"
#include "mdlmgr.h"
#include "bsinkez.h"
#include "naming.h"
#include "lock.h"

// ---------------------------------------------------------------------------
// CreateAssemblyNameModuleImport
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyModuleImport(
    LPTSTR             szModulePath,
    LPBYTE             pbHashValue,
    DWORD              cbHashValue,
    DWORD              dwFlags,
    LPASSEMBLYNAME     pNameDef,
    IAssemblyManifestImport *pManImport,
    LPASSEMBLY_MODULE_IMPORT *ppImport)
{
    HRESULT hr = S_OK;
    CAssemblyModuleImport *pImport = NULL;

    pImport = NEW(CAssemblyModuleImport);
    if (!pImport)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pImport->Init(
        szModulePath,
        pbHashValue,
        cbHashValue,
        pNameDef,
        pManImport,
        dwFlags);

    if (FAILED(hr)) 
    {
        SAFERELEASE(pImport);
        goto exit;
    }

exit:

    *ppImport = pImport;
    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport ctor
// ---------------------------------------------------------------------------
CAssemblyModuleImport::CAssemblyModuleImport()
{
    _dwSig         = 'IDOM';
    _hf            = INVALID_HANDLE_VALUE;
    *_szModulePath = TEXT('\0');   
    _ccModulePath  = 0;
    _pbHashValue   = NULL;
    _cbHashValue   = 0;
    _dwFlags       = 0;
    _pNameDef      = NULL;
    _bInitCS = FALSE;

    _cRef          = 1;
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport dtor
// ---------------------------------------------------------------------------
CAssemblyModuleImport::~CAssemblyModuleImport()
{
    if (_hf != INVALID_HANDLE_VALUE)
        CloseHandle(_hf);

    SAFEDELETEARRAY(_pbHashValue);
    SAFERELEASE(_pNameDef);
    SAFERELEASE(_pManImport);

    if (_bInitCS) {
        DeleteCriticalSection(&_cs);
    }
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyModuleImport::Init (
    LPTSTR             szModulePath,
    LPBYTE             pbHashValue,
    DWORD              cbHashValue,
    LPASSEMBLYNAME     pNameDef,
    IAssemblyManifestImport *pManImport,
    DWORD              dwFlags)
{
    HRESULT hr = S_OK;

    // Module path.
    _ccModulePath = lstrlen(szModulePath) + 1;
    memcpy(_szModulePath, szModulePath, _ccModulePath * sizeof(TCHAR));

    // Hash value and count
    _cbHashValue = cbHashValue;
    _pbHashValue = NEW(BYTE[_cbHashValue]);
    if (!_pbHashValue)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }    
    memcpy(_pbHashValue, pbHashValue, _cbHashValue);

    // Name def back pointer
    _pNameDef = pNameDef;
    if (_pNameDef) {
        _pNameDef->AddRef();
    }

    _pManImport = pManImport;
    if (_pManImport)
        _pManImport->AddRef();
        
    // Flags
    _dwFlags = dwFlags;

    __try {
        InitializeCriticalSection(&_cs);
        _bInitCS = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }


exit:

    return hr;
}


//
// IStream::Read is only IStream implemented method.
//

// ---------------------------------------------------------------------------
// CAssemblyModuleImport::Read
// Implements IStream::Read
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyModuleImport::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{    
    HRESULT                            hr = S_OK;
    CCriticalSection                   cs(&_cs);

    // Grab crit sect 
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto exit;
    }
        
    // First read?
    if (_hf == INVALID_HANDLE_VALUE)
    {
        // Open file for reading.
        _hf = CreateFile (_szModulePath, 
                          GENERIC_READ, 
                          FILE_SHARE_READ,
                          NULL, 
                          OPEN_EXISTING, 
                          FILE_FLAG_SEQUENTIAL_SCAN, 
                          NULL);

        if (_hf == INVALID_HANDLE_VALUE )
        {
            hr = FusionpHresultFromLastError();
            cs.Unlock();
            goto exit;
        }
    }
    
    // Read requested bits.
    if (!ReadFile(_hf, 
                  pv, 
                  cb, 
                  pcbRead, 
                  NULL))
    {
        hr = FusionpHresultFromLastError();
    }

    cs.Unlock();

exit:
    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport::GetModuleName
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyModuleImport::GetModuleName(LPOLESTR pszModuleName, 
    LPDWORD pccModuleName)
{
    HRESULT hr     = S_OK;
    TCHAR *pszName = NULL;
    DWORD  ccName  = NULL;
    
    // Name is last path delineated token.
    pszName = StrRChr(_szModulePath, NULL, TEXT('\\')) + 1;

    ccName = lstrlen(pszName) + 1;
    if (*pccModuleName < ccName)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto exit;
    }

    memcpy(pszModuleName, pszName, ccName * sizeof(TCHAR));

exit:
    *pccModuleName = ccName;
    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport::GetHashAlgId
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyModuleImport::GetHashAlgId(LPDWORD pdwHashAlgId)
{
    DWORD cbHashAlgId = sizeof(DWORD);
    if (_pNameDef)
    {
        return _pNameDef->GetProperty(ASM_NAME_HASH_ALGID, 
            pdwHashAlgId, &cbHashAlgId);
    }
    else
        return E_FAIL;
}
    

// ---------------------------------------------------------------------------
// CAssemblyModuleImport::GetHashValue
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyModuleImport::GetHashValue(LPBYTE pbHashValue,
    LPDWORD pcbHashValue)
{
    HRESULT hr = S_OK;
    if (*pcbHashValue < _cbHashValue)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto exit;
    }

    memcpy(pbHashValue, _pbHashValue, _cbHashValue);
        
exit:
    *pcbHashValue = _cbHashValue;
    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport::GetFlags
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyModuleImport::GetFlags(LPDWORD pdwFlags)
{
    *pdwFlags = _dwFlags;
    return S_OK;
}


// ---------------------------------------------------------------------------
// CAssemblyModuleImport::GetModulePath
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyModuleImport::GetModulePath(LPOLESTR pszModulePath, 
    LPDWORD pccModulePath)
{
    HRESULT hr = S_OK;
    DWORD dwFileAttributes = 0;
    BOOL bExists = FALSE;

    if (*pccModulePath < _ccModulePath)
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    if (SUCCEEDED(hr))
    {
        memcpy(pszModulePath, _szModulePath, _ccModulePath * sizeof(TCHAR));
        hr = CheckFileExistence(pszModulePath, &bExists);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (!bExists) {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

    *pccModulePath = _ccModulePath;

Exit:
    return hr;
}

//
// IStream methods not implemented...
//

STDMETHODIMP CAssemblyModuleImport::Commit(THIS_ DWORD dwCommitFlags)
{
    return E_NOTIMPL;
}


STDMETHODIMP CAssemblyModuleImport::Write(THIS_ VOID const HUGEP *pv, ULONG cb,
            ULONG FAR *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::Revert(THIS)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyModuleImport::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    return E_NOTIMPL;
}

//
// IUnknown boilerplate...
//

STDMETHODIMP CAssemblyModuleImport::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyModuleImport)
       )
    {
        *ppvObj = static_cast<IAssemblyModuleImport*> (this);
        AddRef();
        return S_OK;
    }
    else if ( IsEqualIID(riid, IID_IStream))
    {
        *ppvObj = static_cast<IStream*> (this);
        AddRef();
        return S_OK;
    }        
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CAssemblyModuleImport::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CAssemblyModuleImport::Release(void)
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}

// ---------------------------------------------------------------------------
// CAssemblyModuleImport::IsAvailable
// ---------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CAssemblyModuleImport::IsAvailable()
{
    WCHAR             pszModPath[MAX_PATH];
    DWORD             cbModPath = MAX_PATH;

    return (GetModulePath(pszModPath, &cbModPath) == S_OK);
}

// ---------------------------------------------------------------------------
// CAssemblyModuleImport::BindToObject
// ---------------------------------------------------------------------------

STDMETHODIMP CAssemblyModuleImport::BindToObject(IAssemblyBindSink *pBindSink,
                                                 IApplicationContext *pAppCtx,
                                                 LONGLONG llFlags,
                                                 LPVOID *ppv)
{
    HRESULT                              hr = S_OK;
    LPTSTR                               ptszCodebaseURL = NULL;
    LPTSTR                               ptszTemp = NULL;
    LPWSTR                               pwzCodebase = NULL;
    LPWSTR                               pwzCodebaseUrl = NULL;
    TCHAR                                ptszModuleName[MAX_PATH];
    WCHAR                                pwszModuleName[MAX_PATH];
    LPWSTR                               wzCanonicalized=NULL;
    DWORD                                dwLen = 0;
    DWORD                                cbModName = 0;
    int                                  iLen = 0;
    CTransCache                         *pTransCache = NULL;
    CModDownloadMgr                     *pDLMgr = NULL;
    CAssemblyDownload                   *padl = NULL;
    CDebugLog                           *pdbglog = NULL;

    if (!pAppCtx || !pBindSink || !ppv) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IsAvailable()) {
        // Client did not need to call BTO, but they did anyway!
        *ppv = this;
        AddRef();
        hr = S_OK;
        goto Exit;
    }

    // Get the CODEBASE of the assembly from the assembly name def.
    if (FAILED(hr = NameObjGetWrapper(_pNameDef, ASM_NAME_CODEBASE_URL, 
        (LPBYTE*) &pwzCodebaseUrl, &dwLen)))
        goto Exit;
        
    if (!pwzCodebaseUrl) {
        // We don't have a codebase! The assembly was populated by
        // some other means other than BindToObject. Abort.
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Construct the codebase for the module

    cbModName = MAX_PATH;
    hr = GetModuleName(ptszModuleName, &cbModName);
    if (FAILED(hr)) {
        goto Exit;
    }

    // BUGBUG: Assumes TCHAR==WCHAR
    lstrcpyW(pwszModuleName, ptszModuleName);

    ptszTemp = PathFindFileName(pwzCodebaseUrl) ;
    *ptszTemp = TEXT('\0');
    iLen = lstrlenW(pwzCodebaseUrl) + lstrlen(ptszModuleName) + 1;

    pwzCodebase = NEW(WCHAR[iLen]);
    if (!pwzCodebase) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    wnsprintf(pwzCodebase, iLen, TEXT("%ws%ws"), pwzCodebaseUrl, ptszModuleName);

    wzCanonicalized = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!wzCanonicalized)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwLen = MAX_URL_LENGTH;
    hr = UrlCanonicalizeUnescape(pwzCodebase, wzCanonicalized, &dwLen, 0);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    // Create debug log

#ifdef FUSION_RETAIL_LOGGING
    CreateLogObject(&pdbglog, pwszModuleName, pAppCtx);
#endif

    // Download the module

    hr = CModDownloadMgr::Create(&pDLMgr, _pNameDef, _pManImport, 
        pAppCtx, wzCanonicalized, pwszModuleName, pdbglog);
    if (FAILED(hr)) {
        goto Exit;
    }                             

    hr = CAssemblyDownload::Create(&padl, pDLMgr, pDLMgr, pdbglog, llFlags);
    if (SUCCEEDED(hr)) {
        hr = padl->AddClient(pBindSink, TRUE);
        if (FAILED(hr)) {
            SAFERELEASE(pDLMgr);
            SAFERELEASE(padl);
            goto Exit;
        }

        hr = padl->KickOffDownload(TRUE);
    }

Exit:

    SAFERELEASE(pTransCache);
    SAFERELEASE(padl);
    SAFERELEASE(pDLMgr);

    if (pwzCodebase) {
        delete [] pwzCodebase;
    }

    if (pwzCodebaseUrl) {
        delete [] pwzCodebaseUrl;
    }

    if (pdbglog) {
        pdbglog->Release();
    }

    SAFEDELETEARRAY(wzCanonicalized);
    return hr;
}

// Hands out a pointer to this interface's owned name def.
HRESULT CAssemblyModuleImport::GetNameDef(LPASSEMBLYNAME *ppName)
{
    ASSERT(_pNameDef);

    *ppName = _pNameDef;
    (*ppName)->AddRef();

    return S_OK;
}

HRESULT CAssemblyModuleImport::CreateLogObject(CDebugLog **ppdbglog,
                                               LPCWSTR pwszModuleName,
                                               IApplicationContext *pAppCtx)
{
    HRESULT                              hr = S_OK;
    LPWSTR                               pwzAsmName = NULL;
    LPWSTR                               pwzDbgName = NULL;
    DWORD                                dwSize;
    int                                  iLen = 0;

    if (!ppdbglog || !pwszModuleName || !pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pwzAsmName = NULL;
    pwzDbgName = NULL;
    dwSize = 0;

    hr = _pNameDef->GetDisplayName(NULL, &dwSize, 0);
    if (FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        goto Exit;
    }

    pwzAsmName = NEW(WCHAR[dwSize]);
    if (!pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = _pNameDef->GetDisplayName(pwzAsmName, &dwSize, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    iLen = lstrlenW(pwzAsmName) + lstrlenW(pwszModuleName) + 2; // +1 for delimiter +1 for NULL

    pwzDbgName = NEW(WCHAR[iLen]);
    if (!pwzDbgName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    StrCpyW(pwzDbgName, pwszModuleName);
    StrCatW(pwzDbgName, L"!");
    StrCatW(pwzDbgName, pwzAsmName);
    
    hr = CDebugLog::Create(pAppCtx, pwzDbgName, ppdbglog);
    if (FAILED(hr)) {
        goto Exit;
    }

Exit:
    SAFEDELETEARRAY(pwzAsmName);
    SAFEDELETEARRAY(pwzDbgName);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\inc\util.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef UTIL_H
#define UTIL_H
#pragma once

#include "fusionheap.h"
#include "shlwapi.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(a) (sizeof(a)/sizeof((a)[0]))
#endif

inline
WCHAR*
WSTRDupDynamic(LPCWSTR pwszSrc)
{
    LPWSTR pwszDest = NULL;
    if (pwszSrc != NULL)
    {
        const DWORD dwLen = lstrlenW(pwszSrc) + 1;
        pwszDest = FUSION_NEW_ARRAY(WCHAR, dwLen);

        if( pwszDest )
            memcpy(pwszDest, pwszSrc, dwLen * sizeof(WCHAR));
    }

    return pwszDest;
}

inline
CHAR*
STRDupDynamic(LPCSTR pszSrc)
{
    CHAR*  pszDest = NULL;

    DWORD dwLen = strlen(pszSrc) + 1;
    pszDest = FUSION_NEW_ARRAY(CHAR, dwLen);
    if( pszDest )
    {
        StrCpyA(pszDest, pszSrc );
    }

    return pszDest;
}

#if defined(UNICODE)
#define TSTRDupDynamic WSTRDupDynamic
#else
#define TSTRDupDynamic STRDupDynamic
#endif

inline
LPBYTE
MemDupDynamic(const BYTE *pSrc, DWORD cb)
{
    ASSERT(cb);
    LPBYTE  pDest = NULL;

    pDest = FUSION_NEW_ARRAY(BYTE, cb);
    if(pDest)
        memcpy(pDest, pSrc, cb);

    return pDest;
}
            


inline
VOID GetCurrentGmtTime( LPFILETIME  lpFt)
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}

inline
VOID GetTodaysTime( LPFILETIME  lpFt)
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    sSysT.wHour = sSysT.wMinute = sSysT.wSecond = sSysT.wMilliseconds = 0;
    SystemTimeToFileTime(&sSysT, lpFt);
}

inline
USHORT FusionGetMajorFromVersionHighHalf(DWORD dwVerHigh)
{
    return HIWORD(dwVerHigh);
}

inline
USHORT FusionGetMinorFromVersionHighHalf(DWORD dwVerHigh)
{
    return LOWORD(dwVerHigh);
}

inline
USHORT FusionGetRevisionFromVersionLowHalf(DWORD dwVerLow)
{
    return LOWORD(dwVerLow);
}

inline
USHORT FusionGetBuildFromVersionLowHalf(DWORD dwVerLow)
{
    return HIWORD(dwVerLow);
}


#if defined(FUSION_WIN)

#include "debmacro.h"
#include "FusionArray.h"
#include "fusionbuffer.h"
#include "EnumBitOperations.h"

//
//  FusionCopyString() has a non-obvious interface due to the overloading of
//  pcchBuffer to both describe the size of the buffer on entry and the number of
//  characters required on exit.
//
//  prgchBuffer is the buffer to write to.  If *pcchBuffer is zero when FusionCopyString()
//      is called, it may be NULL.
//
//  pcchBuffer is a required parameter, which on entry must contain the number of unicode
//      characters in the buffer pointed to by prgchBuffer.  On exit, if the buffer was
//      not large enough to hold the character string, including a trailing null,
//      it is set to the number of WCHARs required to hold the string, including the
//      trailing null, and HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) is returned.
//
//      If the buffer is large enough, *pcchBuffer is set to the number of characters
//      written into the buffer, including the trailing null character.
//
//      This is contrary to most functions which return the number of characters written
//      not including the trailing null, but since both on input and in the error case,
//      it deals with the size of the buffer required rather than the number of non-
//      null characters written, it seems inconsistent to only in the success case
//      omit the null from the count.
//
//  szIn is a pointer to sequence of unicode characters to be copied.
//
//  cchIn is the number of Unicode characters in the character string to copy.  If a
//      value less than zero is passed in, szIn must point to a null-terminated string,
//      and the current length of the string is used.  If a value zero or greater is
//      passed, exactly that many characters are assumed to be in the character string.
//

HRESULT FusionCopyString(
    WCHAR *prgchBuffer,
    SIZE_T *pcchBuffer,
    LPCWSTR szIn,
    SSIZE_T cchIn = -1
    );

HRESULT FusionCopyBlob(BLOB *pblobOut, const BLOB &rblobIn);
VOID FusionFreeBlob(BLOB *pblob);

BOOL
FusionDupString(
    PWSTR *ppszOut,
    PCWSTR szIn,
    SSIZE_T cchIn = -1
    );

int
FusionpCompareStrings(
    PCWSTR sz1,
    SSIZE_T cch1,
    PCWSTR sz2,
    SSIZE_T cch2,
    bool fCaseInsensitive
    );

BOOL
FusionpParseProcessorArchitecture(
    IN PCWSTR String,
    IN SSIZE_T Cch,
    OUT USHORT *ProcessorArchitecture OPTIONAL
    );

BOOL
FusionpFormatProcessorArchitecture(
    IN USHORT ProcessorArchitecture,
    IN OUT CBaseStringBuffer *Buffer,
    OUT SIZE_T *CchWritten OPTIONAL
    );

BOOL
FusionpFormatEnglishLanguageName(
    IN LANGID LangID,
    IN OUT CBaseStringBuffer *Buffer,
    OUT SIZE_T *CchWritten = NULL OPTIONAL
    );

/*-----------------------------------------------------------------------------
like ::CreateDirectoryW, but will create the parent directories as needed
-----------------------------------------------------------------------------*/
BOOL
FusionpCreateDirectories(
    PCWSTR pszDirectory
    );

/*-----------------------------------------------------------------------------
'\\' or '/'
-----------------------------------------------------------------------------*/
BOOL
FusionpIsSlash(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
just the 52 chars a-zA-Z, need to check with fs
-----------------------------------------------------------------------------*/
BOOL
FusionpIsDriveLetter(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

VOID
FusionpSetLastErrorFromHRESULT(
    HRESULT hr
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class CFusionDirectoryDifference;

BOOL
FusionpCompareDirectoriesSizewiseRecursively(
    CFusionDirectoryDifference*  pResult,
    const CStringBuffer& dir1,
    const CStringBuffer& dir2
    );

class CFusionDirectoryDifference
{
private: // deliberately unimplemented
    CFusionDirectoryDifference(const CFusionDirectoryDifference&);
    VOID operator=(const CFusionDirectoryDifference&);
public:
    CFusionDirectoryDifference()
    :
        m_e(eEqual),
        m_pstr1(&m_str1),
        m_pstr2(&m_str2)
    {
    }

    VOID
    DbgPrint(
        PCWSTR dir1,
        PCWSTR dir2
        );

public:
    enum E
    {
        eEqual,
        eExtraOrMissingFile,
        eMismatchedFileSize,
        eMismatchedFileCount,
        eFileDirectoryMismatch
    };

    E               m_e;

    union
    {
        struct
        {
            CStringBuffer*   m_pstr1;
            CStringBuffer*   m_pstr2;
        };
        struct // eExtraOrMissingFile
        {
            CStringBuffer*   m_pstrExtraOrMissingFile;
        };
        struct // eMismatchFileSize
        {
            CStringBuffer*   m_pstrMismatchedSizeFile1;
            CStringBuffer*   m_pstrMismatchedSizeFile2;
            ULONGLONG        m_nMismatchedFileSize1;
            ULONGLONG        m_nMismatchedFileSize2;
        };
        struct // eMismatchFileCount
        {
            CStringBuffer*   m_pstrMismatchedCountDir1;
            CStringBuffer*   m_pstrMismatchedCountDir2;
            ULONGLONG        m_nMismatchedFileCount1;
            ULONGLONG        m_nMismatchedFileCount2;
        };
        struct // eFileDirectoryMismatch
        {
            CStringBuffer*   m_pstrFile;
            CStringBuffer*   m_pstrDirectory;
        };
    };

// private:
    CStringBuffer   m_str1;
    CStringBuffer   m_str2;
};

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class CFusionFilePathAndSize
{
public:
    CFusionFilePathAndSize() : m_size(0) { }

    // bsearch and qsort accept optionally subtley different functions
    // bsearch looks for a key in an array, the key and the array elements
    // can be of different types, qsort compares only elements in the array
    static int __cdecl QsortComparePath(const void*, const void*);

    // for qsort/bsearch an array of pointers to CFusionFilePathAndSize
    static int __cdecl QsortIndirectComparePath(const void*, const void*);

    CStringBuffer   m_path;
    __int64         m_size;
};

template <> inline HRESULT
FusionCopyContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& rtDestination,
    const CFusionFilePathAndSize& rtSource
    );

/*-----------------------------------------------------------------------------
two DWORDs to an __int64
-----------------------------------------------------------------------------*/
ULONGLONG
FusionpFileSizeFromFindData(
    const WIN32_FIND_DATAW& wfd
    );

/*-----------------------------------------------------------------------------
HRESULT_FROM_WIN32(GetLastError()) or E_FAIL if GetLastError() == NO_ERROR
-----------------------------------------------------------------------------*/
HRESULT
FusionpHresultFromLastError();

/*-----------------------------------------------------------------------------
FindFirstFile results you always ignore "." and ".."
-----------------------------------------------------------------------------*/
BOOL FusionpIsDotOrDotDot(PCWSTR str);

/*-----------------------------------------------------------------------------
simple code for walking directories, with a per file callback
could be fleshed out more, but good enough for present purposes
-----------------------------------------------------------------------------*/

class CDirWalk
{
public:
    enum ECallbackReason
    {
        eBeginDirectory = 1,
        eFile,
        eEndDirectory
    };

    CDirWalk();

    //
    // the callback cannot reenable what is has disabled
    // perhaps move these to be member data bools
    //
    enum ECallbackResult
    {
        eKeepWalking            = 0x00000000,
        eError                  = 0x00000001,
        eSuccess                = 0x00000002,
        eStopWalkingFiles       = 0x00000004,
        eStopWalkingDirectories = 0x00000008,
        eStopWalkingDeep        = 0x00000010
    };

    //
    // Just filter on like *.dll, in the future you can imagine
    // filtering on attributes like read onlyness, or running
    // SQL queries over the "File System Oledb Provider"...
    //
    // Also, note that we currently do a FindFirstFile/FindNextFile
    // loop for each filter, plus sometimes one more with *
    // to pick up directories. It is probably more efficient to
    // use * and then filter individually but I don't feel like
    // porting over \Vsee\Lib\Io\Wildcard.cpp right now (which
    // was itself ported from FsRtl, and should be in Win32!)
    //
    const PCWSTR*    m_fileFiltersBegin;
    const PCWSTR*    m_fileFiltersEnd;
    CStringBuffer    m_strParent; // set this to the initial directory to walk
    WIN32_FIND_DATAW m_fileData; // not valid for directory callbacks, but could be with a little work
    PVOID            m_context;

    ECallbackResult
    (*m_callback)(
        ECallbackReason  reason,
        CDirWalk*        dirWalk
        );

    BOOL
    Walk(
        );

protected:
    ECallbackResult
    WalkHelper(
        );
};

ENUM_BIT_OPERATIONS(CDirWalk::ECallbackResult)

/*-----------------------------------------------------------------------------*/

typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY
{
    DWORD m_dwFlagMask;
    PCWSTR m_pszString;
    SIZE_T m_cchString;
    DWORD m_dwFlagsToTurnOff; // enables more generic flags first in map hiding more specific combinations later
} FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;

#define DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(_x) { _x, L ## #_x, NUMBER_OF(L ## #_x) - 1, _x },

typedef const FUSION_FLAG_FORMAT_MAP_ENTRY *PCFUSION_FLAG_FORMAT_MAP_ENTRY;

EXTERN_C
BOOL
FusionpFormatFlags(
    IN DWORD dwFlagsToFormat,
    IN SIZE_T cMapEntries,
    IN PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    IN OUT CStringBuffer *pbuff,
    OUT SIZE_T *pcchWritten OPTIONAL
    );

/*-----------------------------------------------------------------------------
inline implementations
-----------------------------------------------------------------------------*/
inline BOOL
FusionpIsSlash(
    WCHAR ch
    )
{
    return (ch == '\\' || ch == '/');
}

inline BOOL
FusionpIsDotOrDotDot(
    PCWSTR str
    )
{
    return (str[0] == '.' && (str[1] == 0 || (str[1] == '.' && str[2] == 0)));
}

inline BOOL
FusionpIsDriveLetter(
    WCHAR ch
    )
{
    if (ch >= 'a' && ch <= 'z')
        return TRUE;
    if (ch >= 'A' && ch <= 'Z')
        return TRUE;
    return FALSE;
}

inline ULONGLONG
FusionpFileSizeFromFindData(
    const WIN32_FIND_DATAW& wfd
    )
{
    ULARGE_INTEGER uli;

    uli.LowPart = wfd.nFileSizeLow;
    uli.HighPart = wfd.nFileSizeHigh;

    return uli.QuadPart;
}

inline HRESULT
FusionpHresultFromLastError()
{
    HRESULT hr = S_OK;
    DWORD dwLastError = GetLastError();
    if (dwLastError != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwLastError);
    }
    else
    {
        hr = FUSION_INTERNAL_ERROR;
    }
    return hr;
}

template <> inline HRESULT
FusionCopyContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& rtDestination,
    const CFusionFilePathAndSize& rtSource
    )
{
    HRESULT hr;
    FN_TRACE_HR(hr);
    IFFAILED_EXIT(hr = rtDestination.m_path.Assign(rtSource.m_path));
    rtDestination.m_size = rtSource.m_size;
    hr = NOERROR;
Exit:
    return hr;
}

#define FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING (0x00000001)

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer *Buffer,
    SIZE_T *Cch
    );


#endif // defined(FUSION_WIN)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\copy2gac\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMMON_H_
#define _COMMON_H_


#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
//#include <vector>
#include <assert.h>
#include <comdef.h>


#define SAFE_DELETE(x) { if (x) {delete x; x=NULL;} }
#define SAFE_DELETEARRAY(x) { if (x) { delete [] x; x = NULL;} }


#endif //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\fuslogvw\cdlids.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#define IDD_CDLLOGVIEW                                     1500
#define IDC_CB_VIEWLOG                                     1501
#define IDC_CB_REFRESH                                     1502
#define IDC_CB_DELETE                                      1503
#define IDC_CB_DELETE_ALL                                  1504
#define IDC_LV_LOGMESSAGES                                 1505
#define IDC_STATIC                                         1506
#define IDC_RADIO_DEFAULT                                  1507
#define IDC_RADIO_XSP                                      1508
#define IDC_RADIO_CUSTOM                                   1509
#define IDC_STATIC1                                        1510
#define IDC_CB_ENABLELOG                                   1511

#define ID_FUSLOGVW_BUTTON_VIEW_LOG                        2000
#define ID_FUSLOGVW_BUTTON_DELETE_ENTRY                    2001
#define ID_FUSLOGVW_BUTTON_DELETE_ALL                      2002
#define ID_FUSLOGVW_BUTTON_REFRESH                         2003
#define ID_FUSLOGVW_BUTTON_EXIT                            2004
#define ID_FUSLOGVW_GROUPBOX_LOG_LOCATION                  2005
#define ID_FUSLOGVW_RADIO_LOCATION_DEFAULT                 2006
#define ID_FUSLOGVW_RADIO_LOCATION_ASP_NET                 2007
#define ID_FUSLOGVW_RADIO_LOCATION_CUSTOM                  2008
#define ID_FUSLOGVW_DIALOG_TITLE                           2009
#define ID_FUSLOGVW_CHECKBOX_ENABLELOG                     2010

#define ID_FUSLOGVW_HEADER_TEXT_APPLICATION                3000
#define ID_FUSLOGVW_HEADER_TEXT_DESCRIPTION                3001
#define ID_FUSLOGVW_HEADER_TEXT_DATE_TIME                  3002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\copy2gac\copy2gac.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <comdef.h>
#include <tchar.h>

//#include "initguid.h"
#include <initguid.h>
#include "copy2gac.h"
#include "bindsink.h"



TCHAR *CApp::c_szBakupDir = TEXT("bak\\");

CApp::CApp() :
        m_bDeleteAssemblies (FALSE),
        m_bAuto(FALSE),
        m_bRestore(FALSE),
        m_hFusionDll(NULL),
        m_pfnCreateAssemblyCache(NULL),
        m_bInstall(FALSE),
        m_bUninstall(FALSE),
        m_bQuiet(FALSE),
        m_bUseInstallRef(FALSE),
        m_hff(INVALID_HANDLE_VALUE)
{
        
        *m_szAsmListFilename=0;
        *m_szCorPathOverride=0;
        *m_szInstallRefID=0;
        *m_szInstallRefDesc=0;
        m_bstrCorPath = "";
        m_pCache = NULL;
}


CApp::~CApp() {
         
        if (m_pCache)
            SAFERELEASE(m_pCache);

        if (m_hFusionDll)
                FreeLibrary(m_hFusionDll);

}

void    
CApp::ErrorMessage( const TCHAR *format, ... ) {

        va_list arglist;
        TCHAR buf[1024];

        va_start(arglist,format);
        wvnsprintf(buf,1024, format,arglist);
        va_end( arglist );

        if (m_bQuiet)
                _tprintf( _T("Error:  %s\n"), buf);
        else
                WszMessageBoxInternal( NULL, buf, TEXT("Copy2GAC Error:"), MB_OK);
}

BOOL
CApp::ParseParameters( int argc, TCHAR* argv[]) {

        while ( --argc )
        {

                if (    !lstrcmpi( argv[argc], TEXT("-d")) 
                        ||      !lstrcmpi( argv[argc], TEXT("/d")) )
                {
                        m_bDeleteAssemblies = TRUE;
                } 
                else 
                if (    !lstrcmpi( argv[argc], TEXT("/?"))
                        ||      !lstrcmpi( argv[argc], TEXT("-?")) )
                {
                        return FALSE;
                }
                else 
                if (    !lstrcmpi( argv[argc], TEXT("/r"))
                        ||      !lstrcmpi( argv[argc], TEXT("-r")) )
                {
                        m_bRestore = TRUE;
                }
                else 
                if (    !lstrcmpi( argv[argc], TEXT("/i"))
                        ||      !lstrcmpi( argv[argc], TEXT("-i")) )
                {
                        m_bInstall = TRUE;
                }
                else 
                if (    !lstrcmpi( argv[argc], TEXT("/q"))
                        ||      !lstrcmpi( argv[argc], TEXT("-q")) )
                {
                        m_bQuiet = TRUE;
                }
                else 
                if (    !lstrcmpi( argv[argc], TEXT("/u"))
                        ||      !lstrcmpi( argv[argc], TEXT("-u")) )
                {
                        m_bUninstall = TRUE;
                }
                else 
                if (    !_tcsncicmp( argv[argc], TEXT("/f:"), lstrlen(TEXT("/f:")))
                        ||      !_tcsncicmp( argv[argc], TEXT("-f:"),lstrlen(TEXT("-f:"))) )
                {
                        if (    lstrlen(argv[argc]) == lstrlen(TEXT("/f:")) ) 
                        {
                                return FALSE;
                        }else {
                                lstrcpy(m_szAsmListFilename, argv[argc]+3);
                        }
                }
                else 
                if (    !_tcsncicmp( argv[argc], TEXT("/p:"), lstrlen(TEXT("/p:")))
                        ||      !_tcsncicmp( argv[argc], TEXT("-p:"),lstrlen(TEXT("-p:"))) )
                {
                        if (    lstrlen(argv[argc]) == lstrlen(TEXT("/p:")) ) 
                        {
                                return FALSE;
                        }else {
                                lstrcpy(m_szCorPathOverride, argv[argc]+3);
                                int len=lstrlen(m_szCorPathOverride);
                                if (m_szCorPathOverride[len-1]!=_T('\\'))
                                        m_szCorPathOverride[len-1]=_T('\\');
                        }
                }
                else 
                if (    !_tcsncicmp( argv[argc], TEXT("/ri:"), lstrlen(TEXT("/ri:")))
                        ||      !_tcsncicmp( argv[argc], TEXT("-ri:"),lstrlen(TEXT("-ri:"))) )
                {
                        if (    (lstrlen(argv[argc]) == lstrlen(TEXT("/ri:")) )
                        ||      (lstrlen(argv[argc]) >= MAX_PATH)    ) 
                        {
                                return FALSE;
                        }else {
                                lstrcpy(m_szInstallRefID, argv[argc]+4);
                        }
                }
                else 
                if (    !_tcsncicmp( argv[argc], TEXT("/rd:"), lstrlen(TEXT("/rd:")))
                        ||      !_tcsncicmp( argv[argc], TEXT("-rd:"),lstrlen(TEXT("-rd:"))) )
                {
                        if (    (lstrlen(argv[argc]) == lstrlen(TEXT("/rd:")))
                        ||      (lstrlen(argv[argc]) >= MAX_PATH)    )
                        {
                                return FALSE;
                        }else {
                                lstrcpy(m_szInstallRefDesc, argv[argc]+4);
                        }
                }
                else 
                if (    !lstrcmpi( argv[argc], TEXT("/a"))
                        ||      !lstrcmpi( argv[argc], TEXT("-a")) )
                {
                        m_bAuto = TRUE;
                }
        }

        _tprintf(_T("\n"));

        if (!m_bInstall && !m_bUninstall) {
                _tprintf( _T("Must specify either /i or /u.\n"));
                return FALSE;
        }
        
        if (lstrlen(m_szInstallRefID) && !lstrlen(m_szInstallRefDesc)  ) {
                _tprintf( _T("Missing /rd:InstallReferenceDescription.\n"));
                return FALSE;
        }

        if (!lstrlen(m_szInstallRefID) && lstrlen(m_szInstallRefDesc)  ) {
                _tprintf( _T("Missing /ri:InstallReferenceID.\n"));
                return FALSE;
        }
        
        if (m_bAuto && *m_szAsmListFilename) {
                _tprintf( _T("Cannot use /a & /f together.\n"));
                return FALSE;
        }
        if (!m_bAuto && !*m_szAsmListFilename) {
                _tprintf( _T("Must specify either /a or /f.\n"));
                return FALSE;
        }
        
        if (m_bInstall && m_bUninstall) {
                _tprintf( _T("Cannot use /i & /u together.\n"));
                return FALSE;
        }

        if (m_bUninstall) {
                //ignore these during uninstall
                m_bRestore = FALSE;
        }

        if (m_bInstall) {
                //ignore these during install
                m_bDeleteAssemblies = FALSE;
        }

        return TRUE;
}

BOOL
CApp::Initialize() {

        HMODULE hModEEShim = LoadLibrary(TEXT("mscoree.dll"));
        if (!hModEEShim)
        {
                _tprintf( _T("Error loading mscoree.dll\n") );
                _tprintf( _T("Make sure you have COM+ installed\n") );
                return FALSE;
        }

        typedef HRESULT (WINAPI *PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);
        PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;

        pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY) 
                                GetProcAddress(hModEEShim, "GetCORSystemDirectory");


        WCHAR wszCorPath[MAX_PATH];
        *wszCorPath = 0;

        DWORD ccPath = MAX_PATH;

        if (!pfnGetCorSystemDirectory 
                || FAILED(pfnGetCorSystemDirectory( wszCorPath, ccPath, &ccPath)))
        {
                _tprintf( _T("Error reading COM+ install location from mscoree.dll\n"));
                _tprintf( _T("Make sure COM+ is installed correctly\n"));
        }


        FreeLibrary(hModEEShim);

        if (!*wszCorPath) {
                return FALSE;
        }

        m_bstrCorPath = wszCorPath;
        
        TCHAR szFusionPath[MAX_PATH];
        lstrcpy(szFusionPath, m_bstrCorPath);
        lstrcat(szFusionPath,TEXT("fusion.dll"));
        m_hFusionDll = LoadLibrary( szFusionPath );
        if (!m_hFusionDll) {
                return FALSE;
        }

        m_pfnCreateAssemblyCache = (pfnCREATEASSEMBLYCACHE)GetProcAddress( m_hFusionDll, "CreateAssemblyCache");
        if (!m_pfnCreateAssemblyCache)
                return FALSE;

        if ( FAILED(m_pfnCreateAssemblyCache(&m_pCache, 0)))
            return FALSE;

        m_pfnCreateAssemblyNameObject = (pfnCREATEASSEMBLYNAMEOBJECT)GetProcAddress( m_hFusionDll, "CreateAssemblyNameObject");
        if (!m_pfnCreateAssemblyNameObject) 
                return FALSE;

        m_pfnCreateApplicationContext = (pfnCREATEAPPLICATIONCONTEXT)GetProcAddress( m_hFusionDll, "CreateApplicationContext");
        if (!m_pfnCreateAssemblyNameObject) 
                return FALSE;

        m_pfnCopyPDBs = (pfnCOPYPDBS)GetProcAddress( m_hFusionDll, "CopyPDBs");
        if (!m_pfnCopyPDBs)
                return FALSE;

        return TRUE;
}

HRESULT
CApp::BindToObject( WCHAR *wszDisplayName, WCHAR *wszCodebase, IAssembly **ppAssembly ) {

        IAssemblyName *pAsmName = NULL;
        IAssemblyName *pAppName = NULL;
        IApplicationContext *pAppContext = NULL;
        IAssemblyName *pNameDef = NULL;
                CBindSink     *pBindSink = NULL;
        DWORD dwFlags = 0;

        if (wszDisplayName)
                dwFlags = CANOF_PARSE_DISPLAY_NAME ;
        else 
                dwFlags = 0;

        HRESULT hr = m_pfnCreateAssemblyNameObject( &pAppName, wszDisplayName, dwFlags , NULL);
        if (FAILED(hr) || !pAppName) {

                goto exitBind;
        }


        hr = m_pfnCreateApplicationContext( pAppName, &pAppContext );
        if (FAILED(hr) || !pAppContext) {
                goto exitBind;
        }

        hr = m_pfnCreateAssemblyNameObject( &pAsmName, NULL, 0, NULL);
        if (FAILED(hr) || !pAsmName) {
                goto exitBind;
        }
        
        
        hr = pAppContext->Set(ACTAG_APP_BASE_URL, (WCHAR*)m_bstrCorPath, (lstrlenW(m_bstrCorPath)+1)*sizeof(WCHAR),0);
        if (FAILED(hr)) {
                goto exitBind;
        }
        
        

                hr = CreateBindSink(&pBindSink, (LPVOID*)ppAssembly);
                if (FAILED(hr))
                        goto exitBind;
                

        hr = pAsmName->BindToObject( __uuidof(IAssembly), pBindSink, pAppContext, wszCodebase, 0, NULL,0, (PVOID*)ppAssembly );

        if (FAILED(hr) || !ppAssembly) {
                //_tprintf(_T("Failed to bind\n"));
                        if (hr == E_PENDING) {
                                WaitForSingleObject(pBindSink->_hEvent, INFINITE);        
                                hr = pBindSink->_hr;
                        }else {
                goto exitBind;
                        }
        } else {
                //_tprintf(_T("Succeeded binding\n"));
        }

exitBind:
                SAFE_RELEASE(pBindSink);
        SAFE_RELEASE(pAsmName);
        SAFE_RELEASE(pAppName);
        SAFE_RELEASE(pAppContext);
        SAFE_RELEASE(pNameDef);

        return hr;
}


WCHAR*
CApp::GetDisplayName( IAssembly *pAssembly ) {

        WCHAR *wszDisplayName = NULL;
        IAssemblyName *pNameDef = NULL;

        assert(pAssembly);

        HRESULT hr = pAssembly->GetAssemblyNameDef(&pNameDef);
        if (FAILED(hr)) {
            goto Exit;
        }

        DWORD dwChars = 0;
        hr = pNameDef->GetDisplayName( NULL, &dwChars,ASM_DISPLAYF_VERSION 
                                      | ASM_DISPLAYF_CULTURE 
                                      | ASM_DISPLAYF_PUBLIC_KEY_TOKEN 
                                      | ASM_DISPLAYF_CUSTOM );
        if (FAILED(hr)) {
            goto Exit;
        }


        wszDisplayName = new WCHAR[dwChars];
        if (!wszDisplayName) {
            goto Exit;
        }

        hr = pNameDef->GetDisplayName( wszDisplayName, &dwChars,
                                       ASM_DISPLAYF_VERSION
                                       | ASM_DISPLAYF_CULTURE 
                                       | ASM_DISPLAYF_PUBLIC_KEY_TOKEN 
                                       | ASM_DISPLAYF_CUSTOM );
        if (FAILED(hr)) {
            goto Exit;
        }


Exit:
        if(FAILED(hr) && wszDisplayName) {
            delete [] wszDisplayName;
            wszDisplayName = NULL;
        }

        if (pNameDef) {
            pNameDef->Release();
        }

        return wszDisplayName;
}


HRESULT
CApp::UninstallAssembly( WCHAR *wszCodebase ) {

        IAssembly *pAssembly = NULL;

        HRESULT hr = BindToObject(NULL, wszCodebase, &pAssembly );

        if (FAILED(hr)) {
                return hr;
        }
        if (!pAssembly)
                return E_FAIL;
        
        if (pAssembly)
        {
                WCHAR *wszDisplayName = GetDisplayName( pAssembly );

                if (wszDisplayName) {
                        _tprintf(_T("Uninstalling %s\n"), wszDisplayName);
                       
                                                DWORD dwDisp;
                        HRESULT hr = m_pCache->UninstallAssembly(0, wszDisplayName, m_bUseInstallRef?&m_installRef:NULL, &dwDisp);
                        if (FAILED(hr)) {
                                _tprintf(_T("UninstallAssembly failed with hr = %X\n"), hr );
                        }

                        delete [] wszDisplayName;
                }
                pAssembly->Release();
        }

        return S_OK;
}

/*
BOOL
CApp::RestoreAssembly( _bstr_t &bstrFile ) {
        _bstr_t bstrFilename = m_bstrCorPath;
        bstrFilename += "bak\\";
        bstrFilename += bstrFile;
        //_tprintf(_T("Restoring %s\n"), (TCHAR*)bstrFilename);

        _bstr_t bstrDestFilename = m_bstrCorPath;
        bstrDestFilename += bstrFile;

        if (!CopyFile( bstrFilename, bstrDestFilename, FALSE)) {
                _tprintf( _T("Failed to copy %s to corpath.\n"), (TCHAR*)bstrFile );
                return FALSE;
        }

        m_dwAssembliesMigrated++;
        if (!UninstallAssembly( bstrFilename )) {
                //nothing
        }
        
        if (!DeleteFile( bstrFilename )) {
                _tprintf( _T("Failed to delete %s\n"), (TCHAR*)bstrFilename);
        }

        return TRUE;
}

*/
BOOL 
CApp::GetNextFilenameAuto( WCHAR *wszFilename) {

        //if we havent got a FF handle yet, do it now
        if (m_hff == INVALID_HANDLE_VALUE) {
                bstr_t bstrSearchPath = m_bstrCorPath;
                bstrSearchPath += "*.dll";

                m_hff = FindFirstFile( bstrSearchPath, &m_ffData);
                if (m_hff == INVALID_HANDLE_VALUE) {
                        return FALSE;
                }
        } else {

                if (!FindNextFile( m_hff, &m_ffData )) {
                        FindClose(m_hff);
                        m_hff=INVALID_HANDLE_VALUE;
                        return FALSE;
                }
        }

        _bstr_t bstrFilename( m_ffData.cFileName );
        //_tprintf(_T("Found %s\n"),(TCHAR*)bstrFilename);

        lstrcpyW( wszFilename, bstrFilename);
        return TRUE;
}

BOOL
CApp::GetNextFilenameFromFilelist( WCHAR *wszFilename) {


        if  (m_hff==INVALID_HANDLE_VALUE) {
                m_hff = CreateFile( m_szAsmListFilename,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);

                if (m_hff == INVALID_HANDLE_VALUE) {
                        _tprintf( _T("Could not open %s\n"), m_szAsmListFilename);
                        return FALSE;
                }
        }

        char szFilename[MAX_PATH];
        char *tmp = szFilename;
        DWORD dwBytesRead;

        *tmp=0;

        while (1) {
                
                if (tmp == szFilename + MAX_PATH)
                {
                    _tprintf( _T("Invalid assembly filename in input file.\n") );
                    CloseHandle( m_hff );
                    m_hff = INVALID_HANDLE_VALUE;
                    return FALSE;
                }
                
                BOOL bRes = ReadFile( m_hff, tmp, 1, &dwBytesRead, NULL);
                
                if (!bRes || !dwBytesRead) {
                        *tmp=0;
                        break;
                }
                
                if (*tmp == '\n') {
                        *tmp = 0;
                        break;
                }else if ( *tmp != '\r') {
                        tmp++;
                }
        }

        if (*szFilename) {
                _bstr_t bstrFilename(szFilename);
                lstrcpyW(wszFilename, bstrFilename);
                return TRUE;
        }
        else {
            CloseHandle( m_hff );
            m_hff = INVALID_HANDLE_VALUE;
            return FALSE;
        }
}


BOOL
CApp::GetNextFilename( WCHAR *wszFilename ) {
        if (m_bAuto) 
                return GetNextFilenameAuto(wszFilename);
        else
                return GetNextFilenameFromFilelist(wszFilename);
}

/*
BOOL
CApp::Restore() {

        HANDLE hff;
        WIN32_FIND_DATA ffData;
        
        bstr_t bstrSearchPath = m_bstrCorPath;
        bstrSearchPath += "bak\\*.dll";

        hff = FindFirstFile( bstrSearchPath, &ffData);
        if (hff == INVALID_HANDLE_VALUE) {
                return FALSE;
        }

        do {
                
                _bstr_t bstrFilename(ffData.cFileName);
                _tprintf(_T("Restoring %s\n"),(TCHAR*)bstrFilename);

                RestoreAssembly( bstrFilename );

        }while (FindNextFile( hff, &ffData ));

        FindClose(hff);

        return TRUE;
}

*/
/*
BOOL
CApp::AutoMigrate() {

        HANDLE hff;
        WIN32_FIND_DATA ffData;
        
        TCHAR szSearchPath[MAX_PATH];
        lstrcpy( szSearchPath, m_bstrCorPath);
        lstrcat( szSearchPath,TEXT("*.dll"));

        hff = FindFirstFile( szSearchPath, &ffData);
        if (hff == INVALID_HANDLE_VALUE) {
                return FALSE;
        }

        do {
                
                _bstr_t bstrFilename(ffData.cFileName);
                //_tprintf(_T("trying %s\n"),(TCHAR*)bstrFilename);

                int i=-1;
                while ( AsmExceptions[++i] ) {
                        if (!lstrcmpi(AsmExceptions[i], bstrFilename))
                                break;
                }
                if (!AsmExceptions[i]) //that means we are at the end of the array (null)
                        MigrateAssembly( bstrFilename );

        }while (FindNextFile( hff, &ffData ));

        FindClose(hff);

        return TRUE;
}
*/


HRESULT
CApp::Install() {

        WCHAR wszFilename[MAX_PATH];
        HRESULT hrRet = S_OK;

        int i=0;

        while (GetNextFilename(wszFilename)) {
                _bstr_t bstrFilename(wszFilename);

                //_tprintf( _T("Installing %s\n"), (TCHAR*)bstrFilename);
                HRESULT hr = MigrateAssembly( bstrFilename );
                if (FAILED(hr)) {
                        if (!m_bAuto)
                                ErrorMessage( TEXT("Failed to Install %s.\n  hr = 0x%8X"), (TCHAR*)bstrFilename, hr);
                        hrRet = hr;
                } else {
                        i++;
                }
        }

        _tprintf( TEXT("Installed %d Assemblies into GAC.\n"), i);

        // Call genpubcfg if available

        if (GetFileAttributesA("genpubcfg.exe") != -1) {
            CHAR                szCmdLine[MAX_PATH];
            CHAR                szAsmListFilename[MAX_PATH];
            BOOL                bRet;
            STARTUPINFOA        si;
            PROCESS_INFORMATION pi;
        
            ZeroMemory(&si, sizeof(si));
            ZeroMemory(&pi, sizeof(pi));

            si.cb = sizeof(si);

            bRet = WideCharToMultiByte(CP_ACP, 0, m_szAsmListFilename, -1, szAsmListFilename, sizeof(szAsmListFilename),
                                       NULL, NULL);
            if (bRet) {
                wnsprintfA(szCmdLine, MAX_PATH, "genpubcfg -f:%s -d:%s", szAsmListFilename, (CHAR*)m_bstrCorPath);

                if (!CreateProcessA(NULL, szCmdLine, NULL, NULL, TRUE,
                                    0, NULL, NULL, &si, &pi)) {
                    _tprintf(TEXT("Error spawning genpubcfg.exe\n"));
                }

                WaitForSingleObject(pi.hProcess, INFINITE);
            }
            else {
                _tprintf(TEXT("Fatal error calling WideCharToMultiByte\n"));
            }
        }

        return hrRet;
}


HRESULT
CApp::Uninstall() {

        WCHAR wszFilename[MAX_PATH];

        HRESULT hrRet = S_OK;

        int i=0;

        while (GetNextFilename(wszFilename)) {
                _bstr_t bstrFilename = m_bstrCorPath;
                bstrFilename += wszFilename;

                HRESULT hr = UninstallAssembly( bstrFilename );
                if (FAILED(hr)) {
                        if (!m_bAuto)
                                ErrorMessage( TEXT("Failed to Uninstall %s.\n  hr = 0x%8X"), (TCHAR*)bstrFilename, hr);
                        hrRet = hr;
                } else {
                        i++;
                }
        }
        
        _tprintf( TEXT("Uninstalled %d Assemblies from GAC.\n"), i);
        
        if (GetFileAttributesA("genpubcfg.exe") != -1) {
            CHAR                szCmdLine[MAX_PATH];
            STARTUPINFOA        si;
            PROCESS_INFORMATION pi;
        
            ZeroMemory(&si, sizeof(si));
            ZeroMemory(&pi, sizeof(pi));

            si.cb = sizeof(si);

            wnsprintfA(szCmdLine, MAX_PATH, "genpubcfg -u");

            if (!CreateProcessA(NULL, szCmdLine, NULL, NULL, TRUE,
                                0, NULL, NULL, &si, &pi)) {
                _tprintf(TEXT("Error spawning genpubcfg.exe\n"));
            }

            WaitForSingleObject(pi.hProcess, INFINITE);
        }

        return hrRet;

}





HRESULT
CApp::MigrateAssembly( TCHAR *szFile) {

        _bstr_t bstrCommand;
        _bstr_t bstrDestPath;

        //set up source path/command
        bstrCommand = m_bstrCorPath;
        bstrCommand += szFile;
        
        //setup dest path
        bstrDestPath = m_bstrCorPath;
        bstrDestPath += c_szBakupDir;
        bstrDestPath += szFile ;

        TCHAR *pszSourcePath = ((TCHAR*)bstrCommand);

        if ( m_bDeleteAssemblies ) {
                BOOL bRes = CopyFile( pszSourcePath, bstrDestPath, FALSE);
                if (!bRes) {
                        _tprintf( _T("Failed to backup %s. Skipping installation.\n"), pszSourcePath );
                        return HRESULT_FROM_WIN32(GetLastError());
                }
        }

        HRESULT hr = m_pCache->InstallAssembly(IASSEMBLYCACHE_INSTALL_FLAG_REFRESH, (WCHAR*)bstrCommand, m_bUseInstallRef? &m_installRef : NULL);
        if (FAILED(hr)) {
                if ( hr != HRESULT_FROM_WIN32(ERROR_BAD_FORMAT) && hr != 0x80131042 && m_bAuto)
                        _tprintf( _T("    Failed to install %s (hr = 0x%X)\n"), pszSourcePath,hr);

                //delete the backup file since we failed
                DeleteFile( bstrDestPath );

        }else  {

                _tprintf( _T("Installed %s\n"), szFile);
        
                if (m_bDeleteAssemblies) {
                        BOOL bRes = DeleteFile( pszSourcePath );
                        if (!bRes) {
                                _tprintf( _T("    Warning: Failed to delete %s\n"), pszSourcePath );
                                //hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                }
        }
        return hr;
}

/*
BOOL
CApp::Migrate() {

        HANDLE hFile = CreateFile( m_szAsmListFilename,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
                printf("Could not open %s\n", m_szAsmListFilename);
                return FALSE;
        }
        
        char szFilename[MAX_PATH];
        char *tmp = szFilename;
        DWORD dwBytesRead;

        while (1) {
                BOOL bRes = ReadFile( hFile, tmp, 1, &dwBytesRead, NULL);

                if (!bRes || !dwBytesRead) {
                        if (*tmp)
                                *tmp = '\n';
                        else
                                break;
                }
                
                if (*tmp=='\r') {
                } else if (*tmp=='\n') {
                        *tmp = 0;
                        //printf("Filename:%s\n",szFilename);
                        tmp=szFilename;
                        MigrateAssembly( szFilename );
                        *tmp = 0;
                }else {
                        tmp++;
                }

        }

        CloseHandle( hFile);
        return TRUE;
}
*/


int CApp::Main(int argc, TCHAR* argv[])
{

        if ((argc==1) || !ParseParameters( argc, argv )) {
                
                _tprintf( TEXT("\n"));
                _tprintf( TEXT("Use:  copy2gac [action] [input] [options]\n") );
                
                _tprintf( TEXT("Action:\n") );
                _tprintf( TEXT("  /i : Install to GAC\n") );
                _tprintf( TEXT("  /u : Uninstall from GAC\n") );
                
                _tprintf( TEXT("Input:\n") );
                _tprintf( TEXT("  /f:inputfile.txt : Reads a list of files from inputfile.txt\n") );
                _tprintf( TEXT("  /a : All dlls in directory\n") );
                _tprintf( TEXT("Options:\n") );
                _tprintf( TEXT("  /ri:ReferenceID : Install reference ID\n") );
                _tprintf( TEXT("  /rd:ReferenceDescription : Install reference description\n") );
                _tprintf( TEXT("  /d : Deletes the assemblies after they are installed") );
                _tprintf( TEXT("\n        and backs them up in the \"bak\" subdir of your corpath.") );
                _tprintf( TEXT("\n        (Only valid for Install)\n") );
                _tprintf( TEXT("  /p:NewPath : Use NewPath instead of Corpath\n") );
                return E_INVALIDARG;
        }

        if ( !Initialize() )
                return E_FAIL; //BUGBUG: return better error code

        if (*m_szCorPathOverride)
                m_bstrCorPath=m_szCorPathOverride;

        _tprintf( TEXT("%sPath: %s\n"),*m_szCorPathOverride? _T("Source"): _T("Cor"), (TCHAR*)m_bstrCorPath );
        
        if (m_bDeleteAssemblies) {
                TCHAR szBackupDir[MAX_PATH];
                lstrcpy(szBackupDir, m_bstrCorPath);
                lstrcat(szBackupDir, c_szBakupDir );
                if (!CreateDirectory( szBackupDir, NULL)) {
                    return HRESULT_FROM_WIN32(GetLastError());
                }
        }


                //initialize the Fusion Install Reference
                m_installRef.cbSize                 = sizeof (FUSION_INSTALL_REFERENCE);
                m_installRef.dwFlags                = 0;
                m_installRef.guidScheme             = FUSION_REFCOUNT_OPAQUE_STRING_GUID;
                m_installRef.szIdentifier           = m_szInstallRefID;
        m_installRef.szNonCannonicalData    = m_szInstallRefDesc;
            
        if (lstrlen(m_szInstallRefID) && lstrlen(m_szInstallRefDesc))
            m_bUseInstallRef = TRUE;

        if (m_bInstall) {
                return Install();
        } else {
                return Uninstall();
        }

        return S_OK;
}


int __cdecl _tmain(int argc, TCHAR* argv[]) {
        CApp copy2gac;

#ifndef USE_FUSWRAPPERS
            OnUnicodeSystem();
#endif

        return copy2gac.Main(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\copy2gac\bindsink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//
//
// BindSink.h  
// Minimal bind sink implementation
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef BINDSINK_H
#define BINDSINK_H

#include "common.h"
#include <fusion.h>
#include <fusionpriv.h>
#include <stdio.h>

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };


// ---------------------------------------------------------------------------
// class CBindSink
// 
// This class implements IAssemblyBindSink which is passed into BindToObject 
// and will receive progress callbacks from fusion in the event binding requires 
// an async download. On successful download, receives IAssembly interface.
// ---------------------------------------------------------------------------
class CBindSink : public IAssemblyBindSink
{
public:

    // Bind result, wait event and IAssembly* ptr
    HRESULT             _hr;
    HANDLE              _hEvent;
    LPVOID              *_ppInterface;
    IAssemblyBinding    *_pAsmBinding;
    DWORD               _dwAbortSize;
    

    CBindSink();
    ~CBindSink();
    
    // Single method on interface called by fusion for all notifications.
    STDMETHOD (OnProgress)(
        DWORD          dwNotification,
        HRESULT        hrNotification,
        LPCWSTR        szNotification,
        DWORD          dwProgress,
        DWORD          dwProgressMax,
        IUnknown       *pUnk);
    

    // IUnknown boilerplate.
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

private:

    DWORD _cRef;
};

// ---------------------------------------------------------------------------
// CBindSink ctor
// ---------------------------------------------------------------------------
CBindSink::CBindSink()
{
    _hEvent         = 0;
    _ppInterface    = NULL;
    _hr             = S_OK;
    _cRef           = 0;
    _pAsmBinding    = NULL;
    _dwAbortSize    = 0xFFFFFFFF;
}

// ---------------------------------------------------------------------------
// CBindSink dtor
// ---------------------------------------------------------------------------
CBindSink::~CBindSink()
{
    if (_hEvent)
        CloseHandle(_hEvent);
    //Should already be released in DONE event
    if (_pAsmBinding)
        SAFERELEASE(_pAsmBinding);
}

// ---------------------------------------------------------------------------
// CBindSink::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindSink::AddRef()
{
    return _cRef++; 
}

// ---------------------------------------------------------------------------
// CBindSink::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindSink::Release()
{
    if (--_cRef == 0) {
        delete this;
        return 0;
    }
    return _cRef;
}

// ---------------------------------------------------------------------------
// CBindSink::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindSink::QueryInterface(REFIID riid, void** ppv)
{
    if (   IsEqualIID(riid, __uuidof(IUnknown))
        || IsEqualIID(riid, __uuidof(IAssemblyBindSink))
       )
    {
        *ppv = static_cast<IAssemblyBindSink*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CBindSink::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindSink::OnProgress(
    DWORD          dwNotification,
    HRESULT        hrNotification,
    LPCWSTR        szNotification,
    DWORD          dwProgress,
    DWORD          dwProgressMax,
    IUnknown       *pUnk)
{
    HRESULT hr = S_OK;
    
    //tprintf(stderr,_T("dwNotification = %d, hr = %x, sz = %s, Prog = %d\n"),dwNotification, hrNotification, szNotification? szNotification : _T("none"), dwProgress);
    switch(dwNotification)
    {
        // All notifications shown; only
        // ASM_NOTIFICATION_DONE handled, 
        // setting _hEvent.
        case ASM_NOTIFICATION_START:
            if (_dwAbortSize == 0)
            {
                hr = E_ABORT;
                goto exit;
            }

            hr = pUnk ->QueryInterface(__uuidof(IAssemblyBinding),
                                                (void**)&_pAsmBinding);
            if (FAILED(hr))
            {
                _ftprintf(stderr,_T("Unable to create IAssemblyBinding interface (HRESULT = %x"),hr);
                hr = E_ABORT;
            }

            break;
        case ASM_NOTIFICATION_PROGRESS:
            if (_dwAbortSize <= dwProgress)
            {
                //ASSERT(_pAsmBinding);
                if (_pAsmBinding)
                    _pAsmBinding->Control(E_ABORT);
            }

            break;
        case ASM_NOTIFICATION_SUSPEND:
            break;
        case ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE:
            break;
        
        // Download complete. If successful obtain IAssembly*.
        // Set _hEvent to unblock calling thread.
        case ASM_NOTIFICATION_DONE:
            
            //Release _pAsmBinding since we don't need it anymore
            SAFERELEASE(_pAsmBinding);

            _hr = hrNotification;
            if (SUCCEEDED(hrNotification) && pUnk)
            {
                // Successfully received assembly interface.
                if (FAILED(pUnk->QueryInterface(__uuidof(IAssembly), _ppInterface)))
                   pUnk->QueryInterface(__uuidof(IAssemblyModuleImport), _ppInterface);
            } 
            SetEvent(_hEvent);
            break;

        default:
            break;
    }
        
exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CreateBindSink
// ---------------------------------------------------------------------------
HRESULT CreateBindSink(CBindSink **ppBindSink, LPVOID *ppInterface)
{
    HRESULT hr = S_OK;
    CBindSink *pBindSink = NULL;

    pBindSink = new CBindSink();
    if (!pBindSink)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create the associated event and record target IAssembly*
    pBindSink->_hEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
    pBindSink->_ppInterface = ppInterface;

    // addref and handout.
    *ppBindSink = pBindSink;
    (*ppBindSink)->AddRef();

exit:

    return hr;
}

#endif // BINDSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\copy2gac\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"COPY2GAC.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Fusion: tool to copy assemblies to GAC\0"
#define VER_ORIGFILENAME_STR    "copy2gac.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\fuslogvw\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"FUSLOGVW.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Fusion Log Viewer\0"
#define VER_ORIGFILENAME_STR    "fuslogvw.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\fuslogvw\fuslogvw.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       fuslogvw.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    25 Mar 97   t-alans (Alan Shi)   Created
//              12 Jan 00   AlanShi (Alan Shi)   Copied from cdllogvw
//              30 May 00   AlanShi (Alan Shi)   Modified to show date/time
//              01 Dec 00   AlanShi (Alan Shi)   Added application name field
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include <commctrl.h>
#include "cdlids.h"
#include "wininet.h"

#define URL_SEARCH_PATTERN             "?FusionBindError!exe="
#define FILESPEC_SEARCH_PATTERN        TEXT("FusionBindError!exe=")
#define DELIMITER_CHAR                 '!'
#define MAX_CACHE_ENTRY_INFO_SIZE      2048
#define MAX_DATE_LEN                   64
#define MAX_RES_TEXT_LEN               1024

#define XSP_APP_CACHE_DIR              TEXT("Temporary ASP.NET Files")
#define XSP_FUSION_LOG_DIR             TEXT("Bind Logs")
#define REG_KEY_FUSION_SETTINGS        TEXT("Software\\Microsoft\\Fusion")
#define REG_VAL_FUSION_LOG_PATH        TEXT("LogPath")
#define REG_VAL_FUSION_LOG_FAILURES    TEXT("LogFailures")

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

typedef enum tagLogLocation {
    LOG_DEFAULT,
    LOG_XSP,
    LOG_CUSTOM
} LogLocation;

LogLocation g_LogLocation;
TCHAR g_szCustomLogPath[MAX_PATH];
TCHAR g_szXSPLogPath[MAX_PATH];
HINSTANCE g_hInst;

typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);

LRESULT CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
void ViewLogEntry(HWND hwnd);
void RefreshLogView(HWND hwnd, LogLocation logLocation);
void RefreshCustomView(HWND hwnd, LPCTSTR szPath);
void RefreshWininetView(HWND hwnd);
void DeleteLogEntry(HWND hwnd);
void DeleteAllLogs(HWND hwnd);
void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf);
void InitListView(HWND hwndLV);
void InitText(HWND hwnd);
void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo);
void AddLogItemCustom(HWND hwndLV, WIN32_FIND_DATA *pfindData);
void InitCustomLogPaths();
BOOL InsertCustomLogEntry(LPTSTR szFilePath, HWND hwndLV);
BOOL GetCorSystemDirectory(LPTSTR szCorSystemDir);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PSTR szCmdLine, int iCmdShow)
{
    g_hInst = hInstance;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_CDLLOGVIEW), NULL, DlgProc);

    return 0;
}

LRESULT CALLBACK DlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND                                 hwndLV;
    HWND                                 hwndRBDefault;
    LPNMHDR                              pnmh = NULL;
    LONG                                 lResult;
    LONG                                 lState;
    HKEY                                 hkey;
    DWORD                                dwLogFailures = 0;
    DWORD                                dwSize;
    DWORD                                dwType;

    switch (iMsg) {
        case WM_INITDIALOG:
            hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
            InitListView(hwndLV);

            hwndRBDefault = GetDlgItem(hwnd, IDC_RADIO_DEFAULT);
            SendMessage(hwndRBDefault, BM_SETCHECK, BST_CHECKED, 0);

            g_LogLocation = LOG_DEFAULT;

            InitCustomLogPaths();
            InitText(hwnd);

            RefreshLogView(hwnd, g_LogLocation);

            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
            if (lResult == ERROR_SUCCESS) {
                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_FAILURES, NULL,
                                          &dwType, (LPBYTE)&dwLogFailures, &dwSize);
                RegCloseKey(hkey);
            }

            if (dwLogFailures) {
                SendMessage(GetDlgItem(hwnd, IDC_CB_ENABLELOG), BM_SETCHECK, 1, 0);
            }
            else {
                SendMessage(GetDlgItem(hwnd, IDC_CB_ENABLELOG), BM_SETCHECK, 0, 0);
            }

            // Test for read/write access, and grey out if can't change

            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_ALL_ACCESS, &hkey);
            if (lResult == ERROR_SUCCESS) {
                RegCloseKey(hkey);
            }
            else {
                EnableWindow(GetDlgItem(hwnd, IDC_CB_ENABLELOG), FALSE);
            }

            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;
                case IDC_CB_VIEWLOG:
                    ViewLogEntry(hwnd);
                    break;

                case IDC_CB_REFRESH:
                    RefreshLogView(hwnd, g_LogLocation);
                    break;

                case IDC_CB_DELETE:
                    DeleteLogEntry(hwnd);
                    break;

                case IDC_CB_DELETE_ALL:
                    DeleteAllLogs(hwnd);
                    break;

                case IDC_RADIO_DEFAULT:
                    if (g_LogLocation == LOG_DEFAULT) {
                        // No change
                        break;
                    }

                    g_LogLocation = LOG_DEFAULT;
                    RefreshLogView(hwnd, g_LogLocation);

                    break;

                case IDC_RADIO_XSP:
                    if (g_LogLocation == LOG_XSP) {
                        // No change
                        break;
                    }

                    g_LogLocation = LOG_XSP;
                    RefreshLogView(hwnd, g_LogLocation);
                    break;

                case IDC_RADIO_CUSTOM:
                    if (g_LogLocation == LOG_CUSTOM) {
                        // No change
                        break;
                    }

                    g_LogLocation = LOG_CUSTOM;
                    RefreshLogView(hwnd, g_LogLocation);
                    break;
               
               case IDC_CB_ENABLELOG:
                    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_ALL_ACCESS, &hkey);
                    if (lResult == ERROR_SUCCESS) {
                        lState = SendMessage(GetDlgItem(hwnd, IDC_CB_ENABLELOG),
                                              BM_GETCHECK, 0, 0);
                        dwLogFailures = (lState == BST_CHECKED) ? (1) : (0);

                        RegSetValueEx(hkey, REG_VAL_FUSION_LOG_FAILURES, 0,
                                      REG_DWORD, (BYTE*)&dwLogFailures, sizeof(dwLogFailures));

                        RegCloseKey(hkey);
                    }

                    break;
            }

            return TRUE;

        case WM_NOTIFY:
            if (wParam == IDC_LV_LOGMESSAGES) {
                pnmh = (LPNMHDR)lParam;

                if (pnmh->code == LVN_ITEMACTIVATE) {
                    // Double click (or otherwise activated)
                    ViewLogEntry(hwnd);
                }
            }

            return TRUE;
    }

    return FALSE;
}

void DeleteLogEntry(HWND hwnd)
{
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    HWND                            hwndLV;
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szDispNameBuf[INTERNET_MAX_URL_LENGTH];
    char                            szEXEBuf[MAX_PATH];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
    
    lIndex = ListView_GetSelectionMark(hwndLV);

    ListView_GetItemText(hwndLV, lIndex, 0, szEXEBuf, MAX_PATH);
    ListView_GetItemText(hwndLV, lIndex, 1, szDispNameBuf, INTERNET_MAX_URL_LENGTH);

    if (g_LogLocation == LOG_DEFAULT) {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s%s!name=%s", URL_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
        
        pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    
        if (DeleteUrlCacheEntry(szUrl)) {
            RefreshLogView(hwnd, g_LogLocation);
        }
        else {
            MessageBox(hwnd, "Error: Unable to delete cache file!",
                       "Log View Error", MB_OK | MB_ICONERROR);
        }
    }
    else {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s\\%s\\%s%s!name=%s.htm",
                  ((g_LogLocation == LOG_XSP) ? (g_szXSPLogPath) : (g_szCustomLogPath)),
                  szEXEBuf, FILESPEC_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
        if (!DeleteFile(szUrl)) {
            MessageBox(hwnd, "Error: Unable to delete cache file!",
                       "Log View Error", MB_OK | MB_ICONERROR);
        }

        RefreshLogView(hwnd, g_LogLocation);
    }
}

void DeleteAllLogs(HWND hwnd)
{
    HWND                            hwndLV;
    char                            szDispNameBuf[INTERNET_MAX_URL_LENGTH];
    char                            szEXEBuf[MAX_PATH];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    int                             iCount;
    int                             i;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    iCount = ListView_GetItemCount(hwndLV);
    for (i = 0; i < iCount; i++) {
        ListView_GetItemText(hwndLV, i, 0, szEXEBuf, MAX_PATH);
        ListView_GetItemText(hwndLV, i, 1, szDispNameBuf, INTERNET_MAX_URL_LENGTH);
    
        if (g_LogLocation == LOG_DEFAULT) {
            wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s%s!name=%s", URL_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
        
            DeleteUrlCacheEntry(szUrl);
        }
        else {
            wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s\\%s\\%s%s!name=%s.htm",
                      ((g_LogLocation == LOG_XSP) ? (g_szXSPLogPath) : (g_szCustomLogPath)),
                      szEXEBuf, FILESPEC_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
            if (!DeleteFile(szUrl)) {
                MessageBox(hwnd, "Error: Unable to delete cache file!",
                           "Log View Error", MB_OK | MB_ICONERROR);
            }
        }
    }

    RefreshLogView(hwnd, g_LogLocation);
}

void ViewLogEntry(HWND hwnd)
{
    LRESULT                         lIndex = 0;
    LRESULT                         lLength = 0;
    HWND                            hwndLV;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    char                            szDispNameBuf[INTERNET_MAX_URL_LENGTH];
    char                            szEXEBuf[MAX_PATH];
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    lIndex = ListView_GetSelectionMark(hwndLV);
    ListView_GetItemText(hwndLV, lIndex, 0, szEXEBuf, MAX_PATH);
    ListView_GetItemText(hwndLV, lIndex, 1, szDispNameBuf, INTERNET_MAX_URL_LENGTH);
    
    if (g_LogLocation == LOG_DEFAULT) {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s%s!name=%s", URL_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);
    
        pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    
        if (GetUrlCacheEntryInfo(szUrl, pCacheEntryInfo, &dwBufferSize)) {
            if (pCacheEntryInfo->lpszLocalFileName != NULL) {
                if (ShellExecute(NULL, "open",  pCacheEntryInfo->lpszLocalFileName,
                                 NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32) {
                    // ShellExecute returns <= 32 if error occured
                    MessageBox(hwnd, TEXT("Error: Unable to open cache file!"),
                                TEXT("Log View Error"), MB_OK | MB_ICONERROR);
                }
            }
            else {
                    MessageBox(hwnd, TEXT("Error: No file name available!"),
                               TEXT("Log View Error"), MB_OK | MB_ICONERROR);
            }
        }
    }
    else {
        wnsprintf(szUrl, INTERNET_MAX_URL_LENGTH, "%s\\%s\\%s%s!name=%s.htm",
                  ((g_LogLocation == LOG_XSP) ? (g_szXSPLogPath) : (g_szCustomLogPath)),
                  szEXEBuf, FILESPEC_SEARCH_PATTERN, szEXEBuf, szDispNameBuf);

        if (ShellExecute(NULL, "open", szUrl,
                         NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32) {
            // ShellExecute returns <= 32 if error occured
            MessageBox(hwnd, TEXT("Error: Unable to open cache file!"),
                        TEXT("Log View Error"), MB_OK | MB_ICONERROR);
        }
    }
        
}

void RefreshLogView(HWND hwnd, LogLocation logLocation)
{
    HWND                        hwndLV;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    switch (logLocation) {
        case LOG_DEFAULT:
            RefreshWininetView(hwnd);
            break;

        case LOG_XSP:
            if (lstrlen(g_szXSPLogPath)) {
                RefreshCustomView(hwnd, g_szXSPLogPath);
            }
            else {
                ListView_DeleteAllItems(hwndLV);
            }

            break;

        case LOG_CUSTOM:
            if (lstrlen(g_szCustomLogPath)) {
                RefreshCustomView(hwnd, g_szCustomLogPath);
            }
            else {
                hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
                ListView_DeleteAllItems(hwndLV);
            }
            break;
    }
}

void RefreshCustomView(HWND hwnd, LPCTSTR szPath)
{
    HANDLE                              hFile = INVALID_HANDLE_VALUE;
    TCHAR                               szSearchSpec[MAX_PATH];
    TCHAR                               szFileName[MAX_PATH];
    HWND                                hwndLV;
    WIN32_FIND_DATA                     findData;

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);
    ListView_DeleteAllItems(hwndLV);

#ifdef UNICODE
    wnsprintfW(szSearchSpec, MAX_PATH, L"%ws\\*.*", szPath);
#else
    wnsprintfA(szSearchSpec, MAX_PATH, "%s\\*.*", szPath);
#endif

    hFile = FindFirstFile(szSearchSpec, &findData);
    if (hFile == INVALID_HANDLE_VALUE) {
        goto Exit;
    }

    if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lstrcmp(findData.cFileName, TEXT("."))) &&
        (lstrcmp(findData.cFileName, TEXT("..")))) {

#ifdef UNICODE
        wnsprintfW(szFileName, MAX_PATH, L"%ws\\%ws", szPath, findData.cFileName);
#else
        wnsprintfA(szFileName, MAX_PATH, "%s\\%s", szPath, findData.cFileName);
#endif

        InsertCustomLogEntry(szFileName, hwndLV);
    }

    while (FindNextFile(hFile, &findData)) {
        if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (lstrcmp(findData.cFileName, TEXT("."))) &&
            (lstrcmp(findData.cFileName, TEXT("..")))) {
                
#ifdef UNICODE
            wnsprintfW(szFileName, MAX_PATH, L"%ws\\%ws", szPath, findData.cFileName);
#else
            wnsprintfA(szFileName, MAX_PATH, "%s\\%s", szPath, findData.cFileName);
#endif

            InsertCustomLogEntry(szFileName, hwndLV);
        }
    }

Exit:
    return;
}

BOOL InsertCustomLogEntry(LPTSTR szFilePath, HWND hwndLV)
{
    BOOL                                bRet = TRUE;
    HANDLE                              hFile = INVALID_HANDLE_VALUE;
    TCHAR                               szSearchSpec[MAX_PATH];
    WIN32_FIND_DATA                     findData;

#ifdef UNICODE
    wnsprintfW(szSearchSpec, MAX_PATH, L"%ws\\*.htm" szFilePath);
#else
    wnsprintfA(szSearchSpec, MAX_PATH, "%s\\*.htm", szFilePath);
#endif
    
    hFile = FindFirstFile(szSearchSpec, &findData);
    if (hFile == INVALID_HANDLE_VALUE) {
        bRet = FALSE;
        goto Exit;
    }

    if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        AddLogItemCustom(hwndLV, &findData);
    }
    
    while (FindNextFile(hFile, &findData)) {
        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }
        
        AddLogItemCustom(hwndLV, &findData);
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return bRet;
}

void AddLogItemCustom(HWND hwndLV, WIN32_FIND_DATA *pfindData)
{
    LVITEM                          lvitem;
    LPTSTR                          szNameTag = NULL;
    LPTSTR                          szExt = NULL;
    static TCHAR                    szBuf[MAX_DATE_LEN];
    static TCHAR                    szExeBuf[MAX_PATH];

    memset(&lvitem, 0, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;
    
    FormatDateBuffer(&pfindData->ftLastAccessTime, szBuf);

    lstrcpy(szExeBuf, pfindData->cFileName + lstrlen(FILESPEC_SEARCH_PATTERN));
    szNameTag = StrStr(szExeBuf, TEXT("!name="));
    if (!szNameTag) {
        // Fatal!
        return;
    }

    *szNameTag++ = TEXT('\0');

    szNameTag += lstrlen(TEXT("name="));
    szExt = StrStrI(szNameTag, TEXT(".htm"));
    if (szExt) {
        *szExt = TEXT('\0');
    }

    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.pszText = szExeBuf;
    lvitem.iItem = ListView_InsertItem(hwndLV, &lvitem);

    lvitem.iSubItem = 1;
    lvitem.pszText = szNameTag;
    ListView_SetItem(hwndLV, &lvitem);

    lvitem.iSubItem = 2;
    lvitem.pszText = szBuf;
    ListView_SetItem(hwndLV, &lvitem);
}

void RefreshWininetView(HWND hwnd)
{
    HANDLE                          hUrlCacheEnum;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    HWND                            hwndLV;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

    hwndLV = GetDlgItem(hwnd, IDC_LV_LOGMESSAGES);

    ListView_DeleteAllItems(hwndLV);
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    hUrlCacheEnum = FindFirstUrlCacheEntry(URL_SEARCH_PATTERN, pCacheEntryInfo,
                                           &dwBufferSize);
    if (hUrlCacheEnum != NULL) {
        if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
            if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                AddLogItem(hwndLV, pCacheEntryInfo);
            }
        }

        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        while (FindNextUrlCacheEntry(hUrlCacheEnum, pCacheEntryInfo,
                                     &dwBufferSize)) {
            if (pCacheEntryInfo->lpszSourceUrlName != NULL) {
                if (StrStrI(pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN)) {
                    AddLogItem(hwndLV, pCacheEntryInfo);
                }
            }

            dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        }
    }
}

void AddLogItem(HWND hwndLV, LPINTERNET_CACHE_ENTRY_INFO pCacheEntryInfo)
{
    LVITEM                          lvitem;
    LPSTR                           szNameTag = NULL;
    static char                     szBuf[MAX_DATE_LEN];
    static char                     szExeBuf[INTERNET_MAX_URL_LENGTH];
    

    memset(&lvitem, 0, sizeof(lvitem));
    lvitem.mask = LVIF_TEXT;
    
    FormatDateBuffer(&pCacheEntryInfo->LastModifiedTime, szBuf);

    if (lstrlen(pCacheEntryInfo->lpszSourceUrlName) + 1 >= INTERNET_MAX_URL_LENGTH) {
        return;
    }

    lstrcpy(szExeBuf, pCacheEntryInfo->lpszSourceUrlName + lstrlen(URL_SEARCH_PATTERN));
    szNameTag = StrStr(szExeBuf, "!name=");
    if (!szNameTag) {
        // Fatal!
        return;
    }

    *szNameTag++ = TEXT('\0');

    szNameTag += lstrlen("name=");

    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.pszText = szExeBuf;
    lvitem.iItem = ListView_InsertItem(hwndLV, &lvitem);

    lvitem.iSubItem = 1;
    lvitem.pszText = szNameTag;
    ListView_SetItem(hwndLV, &lvitem);

    lvitem.iSubItem = 2;
    lvitem.pszText = szBuf;
    ListView_SetItem(hwndLV, &lvitem);
}

void FormatDateBuffer(FILETIME *pftLastMod, LPSTR szBuf)
{
    SYSTEMTIME                    systime;
    FILETIME                      ftLocalLastMod;
    char                          szBufDate[MAX_DATE_LEN];
    char                          szBufTime[MAX_DATE_LEN];

    szBuf[0] = '\0';

    FileTimeToLocalFileTime(pftLastMod, &ftLocalLastMod);
    FileTimeToSystemTime(&ftLocalLastMod, &systime);
    
    if (!GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, szBufDate, MAX_DATE_LEN)) {
        return;
    }

    if (!GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &systime, NULL, szBufTime, MAX_DATE_LEN)) {
        return;
    }
    
    wnsprintf(szBuf, MAX_DATE_LEN, "%s @ %s", szBufDate, szBufTime);
}

void InitListView(HWND hwndLV)
{
    LVCOLUMN                lvcol;
    TCHAR                   szText[MAX_RES_TEXT_LEN];

    memset(&lvcol, 0, sizeof(LVCOLUMN));

    lvcol.mask = LVCF_TEXT | LVCF_WIDTH;

    // Application
    
    lvcol.cx = 78;

    if (!LoadString(g_hInst, ID_FUSLOGVW_HEADER_TEXT_APPLICATION, szText, MAX_RES_TEXT_LEN)) {
        return;
    }

    lvcol.pszText = szText;
    ListView_InsertColumn(hwndLV, 0, &lvcol);

    // Description

    if (!LoadString(g_hInst, ID_FUSLOGVW_HEADER_TEXT_DESCRIPTION, szText, MAX_RES_TEXT_LEN)) {
        return;
    }

    lvcol.cx = 320;
    lvcol.pszText = szText;

    ListView_InsertColumn(hwndLV, 1, &lvcol);

    // Date/Time

    if (!LoadString(g_hInst, ID_FUSLOGVW_HEADER_TEXT_DATE_TIME, szText, MAX_RES_TEXT_LEN)) {
        return;
    }

    lvcol.pszText = szText;
    lvcol.cx = 154;

    ListView_InsertColumn(hwndLV, 2, &lvcol);
}

void InitCustomLogPaths()
{
    LONG                            lResult;
    HKEY                            hkey;
    // BOOL                            bRet;
    DWORD                           dwSize;
    DWORD                           dwAttr;
    DWORD                           dwType;
    TCHAR                           szCorSystemDir[MAX_PATH];
    // TCHAR                           szXSPAppCacheDir[MAX_PATH];

    g_szCustomLogPath[0] = L'\0';
    g_szXSPLogPath[0] = L'\0';

    // Custom log path

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if (lResult == ERROR_SUCCESS) {
        dwSize = MAX_PATH;
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_PATH, NULL,
                                  &dwType, (LPBYTE)g_szCustomLogPath, &dwSize);
        if (lResult == ERROR_SUCCESS) {
            PathRemoveBackslash(g_szCustomLogPath);
        }

        RegCloseKey(hkey);

        dwAttr = GetFileAttributes(g_szCustomLogPath);
        if (dwAttr == -1 || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
            g_szCustomLogPath[0] = L'\0';
        }
    }

    // XSP log path

    if (!GetCorSystemDirectory(szCorSystemDir)) {
        goto Exit;
    }

    dwSize = lstrlen(szCorSystemDir);
    if (dwSize) {
        if (szCorSystemDir[dwSize - 1] == TEXT('\\')) {
            szCorSystemDir[dwSize - 1] = TEXT('\0');
        }
    }

#ifdef UNICODE
    wnsprintfW(g_szXSPLogPath, MAX_PATH, L"%ws\\%ws\\%ws", szCorSystemDir,
               XSP_APP_CACHE_DIR, XSP_FUSION_LOG_DIR);
#else
    wnsprintfA(g_szXSPLogPath, MAX_PATH, "%s\\%s\\%s", szCorSystemDir,
               XSP_APP_CACHE_DIR, XSP_FUSION_LOG_DIR);
#endif              

    dwAttr = GetFileAttributes(g_szXSPLogPath);
    if (dwAttr == -1) {
        g_szXSPLogPath[0] = TEXT('\0');
    }

Exit:
    return;
}

void InitText(HWND hwnd)
{
    TCHAR                                    szText[MAX_RES_TEXT_LEN];

    szText[0] = L'\0';

    if (LoadString(g_hInst, ID_FUSLOGVW_DIALOG_TITLE, szText, MAX_RES_TEXT_LEN)) {
        SendMessage(hwnd, WM_SETTEXT, 0, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_VIEW_LOG, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_VIEWLOG, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_DELETE_ENTRY, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_DELETE, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_DELETE_ALL, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_DELETE_ALL, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_REFRESH, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_REFRESH, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_BUTTON_EXIT, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDCANCEL, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_DEFAULT, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_DEFAULT, szText);
    }
    
    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_DEFAULT, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_DEFAULT, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_ASP_NET, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_XSP, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_RADIO_LOCATION_CUSTOM, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_RADIO_CUSTOM, szText);
    }

    if (LoadString(g_hInst, ID_FUSLOGVW_CHECKBOX_ENABLELOG, szText, MAX_RES_TEXT_LEN)) {
        SetDlgItemText(hwnd, IDC_CB_ENABLELOG, szText);
    }
}

BOOL GetCorSystemDirectory(LPTSTR szCorSystemDir)
{
    BOOL fRet = FALSE;
    DWORD ccPath = MAX_PATH;
    WCHAR szDir[MAX_PATH];
    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;

    HMODULE hEEShim = LoadLibrary(TEXT("mscoree.dll"));
    if (!hEEShim)
        goto exit;

    pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY) 
        GetProcAddress(hEEShim, "GetCORSystemDirectory");

    if (!pfnGetCorSystemDirectory 
        || FAILED(pfnGetCorSystemDirectory(szDir, MAX_PATH, &ccPath)))
        goto exit;

#ifdef UNICODE
    lstrcpyW(szCorSystemDir, szDir);
#else
    if (!WideCharToMultiByte(CP_ACP, 0, szDir, -1, szCorSystemDir, MAX_PATH * sizeof(TCHAR),
                             NULL, NULL)) {
        goto exit;
    }
#endif

    fRet = TRUE;

exit:
    
    if (!fRet)
    {
        FreeLibrary(hEEShim);
    }
    return fRet;
}

int 
_stdcall 
ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), 
                NULL, 
                pszCmdLine,
                (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;           // We never come here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\copy2gac\copy2gac.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COPY2GAC_H_
#define _COPY2GAC_H_

#include "common.h"
#include "fusion.h"
#include "fusionpriv.h"
#include "fusionp.h"

__declspec( selectany ) TCHAR *AsmExceptions[] = {
        TEXT("Microsoft.VisualC.dll"),
        TEXT("mscorlib.dll"),
        NULL
};


#define SAFE_RELEASE(x) { if (x) (x)->Release(); (x)=NULL; }

typedef HRESULT (__stdcall *pfnCREATEASSEMBLYCACHE) (IAssemblyCache **ppAssemblyCacheObj, DWORD dwFlags);
typedef HRESULT (__stdcall *pfnCREATEASSEMBLYNAMEOBJECT) (LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);
typedef HRESULT (__stdcall *pfnCREATEAPPLICATIONCONTEXT) (IAssemblyName *pName, LPAPPLICATIONCONTEXT *ppCtx);
typedef HRESULT (__stdcall *pfnCOPYPDBS) (IAssembly *pAsm);


class CApp {
        
        public:
                CApp();
                ~CApp();

                int             Main(int argc, TCHAR* argv[]);


        private:
                BOOL    ParseParameters( int argc, TCHAR* argv[]);
                BOOL    Initialize();

                BOOL    GetNextFilename( WCHAR *wszFilename );
                BOOL    GetNextFilenameAuto(WCHAR *wszFilename);
                BOOL    GetNextFilenameFromFilelist(WCHAR *wszFilename);

                HRESULT MigrateAssembly( TCHAR *szPath );

                //BOOL  Restore();
                //BOOL  RestoreAssembly( _bstr_t &bstrPath );
                
                HRESULT BindToObject( WCHAR *wszDisplayName, WCHAR *wszCodebase, IAssembly **ppAssembly );
                WCHAR   *GetDisplayName( IAssembly *pAssembly );

                HRESULT UninstallAssembly( WCHAR *wszCodebase );
                HRESULT Install();
                HRESULT Uninstall();
                void    ErrorMessage( const TCHAR *format, ... );

        private:

                BOOL    m_bDeleteAssemblies;
                BOOL    m_bAuto;
                BOOL    m_bRestore;
                BOOL    m_bInstall;
                BOOL    m_bUninstall;
                BOOL    m_bQuiet;
                BOOL    m_bUseInstallRef;

                HANDLE  m_hff;
                WIN32_FIND_DATA m_ffData;

                TCHAR   m_szAsmListFilename[MAX_PATH];
                TCHAR   m_szCorPathOverride[MAX_PATH];
                TCHAR   m_szInstallRefID[MAX_PATH];
                TCHAR   m_szInstallRefDesc[MAX_PATH];
                _bstr_t m_bstrCorPath;
                HMODULE m_hFusionDll;
                IAssemblyCache*  m_pCache;
				FUSION_INSTALL_REFERENCE m_installRef;

                pfnCREATEASSEMBLYCACHE  m_pfnCreateAssemblyCache;
                pfnCREATEASSEMBLYNAMEOBJECT m_pfnCreateAssemblyNameObject;
                pfnCREATEAPPLICATIONCONTEXT m_pfnCreateApplicationContext;
                pfnCOPYPDBS m_pfnCopyPDBs;
                static TCHAR    *c_szBakupDir;

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\shfusres\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.cpp : source file that includes just the standard includes
//	ShFusRes.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\shfusres\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__CA603852_EEC0_4EC5_A719_D5E3077F18E7__INCLUDED_)
#define AFX_STDAFX_H__CA603852_EEC0_4EC5_A719_D5E3077F18E7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CA603852_EEC0_4EC5_A719_D5E3077F18E7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\shfusres\shfusres.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ShFusRes.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

BOOL APIENTRY DllMain( HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\shfusres\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// *********************************************************************
//
//  Microsoft Windows
//  File:       resource.h
//
//  Contents:   ShFusion resource ID's
//
//  Created by: Fred Aaron (Freda)
//
//
// *********************************************************************

#define MANIFEST_RESOURCE_ID            2
#define IDS_TTFUSIONGLOBALCACHE         5
#define IDS_TTFUSIONDOWNLOADSTRONG      6
#define IDS_TTFUSIONDOWNLOADSIMPLE      7
#define IDS_TTDELETE                    8
#define IDS_TTVIEW                      9
#define IDS_TTUNDO                      10
#define IDS_CONFIRM_DELONEITEM          11
#define IDS_CONFIRM_DELITEMS            12
#define IDS_MULTIPLE_TITLE              13
#define IDS_CONFIRM_DELITEM_TITLE       14
#define IDS_DELETEERROR                 15
#define IDS_SHELLFOLDERPOPUP_PROPERTIES_HELP 16
#define IDS_ENUMERROR                   18
#define IDS_TTFUSIONCACHESCAVANGE       19
#define IDS_FOLDERNAME_APPLICATION      20
#define IDS_FOLDERNAME_GLOBAL           21
#define IDS_FOLDERNAME_PRIVATE          22
#define IDS_FOLDERNAME_SHARED           23
#define IDS_GLOBAL_CACHEVIEW_NAME       25
#define IDS_SHARED_CACHEVIEW_NAME       26
#define IDS_PRIVATE_CACHEVIEW_NAME      27
#define IDS_DOWNLOAD_CACHEVIEW_NAME     28
#define IDS_DOWNLOAD_CACHEVIEW_TYPE     29
#define IDS_NAMERES_CACHEVIEW_NAME      30
#define IDS_NAMERES_CACHEVIEW_TARGET    31
#define IDS_NAMERES_CACHEVIEW_APPSID    32
#define IDS_NAMERES_CACHEVIEW_ADMINSID  33
#define IDS_CACHEVIEW_VERSION           34
#define IDS_CACHEVIEW_CULTURE           35
#define IDS_CACHEVIEW_PUBLIC_KEY_TOKEN  36
#define IDS_CACHEVIEW_CODEBASE          37
#define IDS_UNINSTALL_DISPOSITION_ERROR 38
#define IDS_UNEXPECTED_ERROR            39
#define IDS_COLUMN1                     50
#define IDS_COLUMN2                     51
#define IDS_TB_COMMAND                  52
#define IDS_MI_COMMAND                  53
#define IDS_EXT_TITLE                   54
#define IDS_MI_FILEITEM                 55
#define IDS_FOLDER                      56
#define IDS_VIEW                        57
#define IDS_VIEW_LARGE                  58
#define IDS_VIEW_SMALL                  59
#define IDS_VIEW_LIST                   60
#define IDS_VIEW_DETAILS                61
#define IDS_NEW                         62
#define IDS_NEW_FOLDER                  63
#define IDS_NEW_ITEM                    64
#define IDS_PASTE                       65
#define IDS_EXPLORE                     66
#define IDS_OPEN                        67
#define IDS_RENAME                      68
#define IDS_CUT                         69
#define IDS_COPY                        70
#define IDS_DELETE                      71
#define IDS_MODIFY_DATA                 72
#define IDS_ITEM                        73
#define IDS_FOLDER_DATA                 74
#define IDS_ASSEMBLY_TYPE_SIMPLE        75
#define IDS_ASSEMBLY_TYPE_STRONG        76
#define IDS_ASSEMBLY_TYPE_PREJIT        77
#define IDS_ASSEMBLY_TYPE_UNKNOWN       78
#define IDS_STATUSBAR_OBJECT_SEL        79
#define IDS_STATUSBAR_OBJECT            80
#define IDS_BYTES                       90
#define IDS_ORDERKB                     91
#define IDS_ORDERMB                     92
#define IDS_ORDERGB                     93
#define IDS_ORDERTB                     94
#define IDS_ORDERPB                     95
#define IDS_ORDEREB                     96
#define IDS_DRIVELETTER                 97
#define IDS_VOLUMELABEL                 98
#define IDS_MOUNTEDVOLUME               99
#define IDS_UNLABELEDVOLUME             100
#define IDS_DRIVES_REMOVABLE            101
#define IDS_DRIVES_DRIVE525             102
#define IDS_DRIVES_DRIVE35              103
#define IDS_DRIVES_DRIVE525_UGLY        104
#define IDS_DRIVES_DRIVE35_UGLY         105
#define IDS_DRIVES_UGLY_TEST            106
#define IDS_DRIVES_FIXED                107
#define IDS_DRIVES_DVD                  108
#define IDS_DRIVES_CDROM                109
#define IDS_DRIVES_RAMDISK              110
#define IDS_DRIVES_NETDRIVE             111
#define IDS_DRIVES_NETUNAVAIL           112
#define IDS_DRIVES_REGITEM              113
#define IDS_DRIVES_REMOVABLE_GROUP      114
#define IDS_DRIVES_FIXED_GROUP          115
#define IDS_DRIVES_NETDRIVE_GROUP       116
#define IDS_DRIVES_OTHER_GROUP          117
#define IDS_CACHE_SETTINGS_TITLE        118
#define IDS_BIND_POLICY_LBRY            120
#define IDS_BIND_POLICY_LBRN            121
#define IDS_ARM_INTRO1                  122
#define IDS_NAR_INTRO2                  123
#define IDS_ARM_OPTIONS                 124
#define IDS_NAR_ADMIN_POLICY            125
#define IDS_NAR_ADMIN_POLICY_INFO       126
#define IDS_DELETE_ERROR_TITLE          127
#define IDS_INSTALL_ERROR_TITLE         128
#define IDS_ARM_NOAPPS                  130
#define IDS_ARM_NOPOLICYCHANGE          131
#define IDS_ARM_DLG2SNAPSHOTS           133
#define IDS_VN_COMMENTS                 140
#define IDS_VN_COMPANYNAME              141
#define IDS_VN_FILEDESCRIPTION          142
#define IDS_VN_INTERNALNAME             143
#define IDS_VN_LEGALTRADEMARKS          144
#define IDS_VN_ORIGINALFILENAME         145
#define IDS_VN_PRIVATEBUILD             146
#define IDS_VN_PRODUCTNAME              147
#define IDS_VN_PRODUCTVERSION           148
#define IDS_VN_SPECIALBUILD             149
#define IDS_VN_FILEVERSIONKEY           150
#define IDS_VN_LANGUAGE                 151
#define IDS_VN_LANGUAGES                152
#define IDS_ARM_CONFIRM_RESTORE         155
#define IDS_ARM_RESTORE_EXPLAIN         156
#define IDS_ARM_UNDO_SUCCESS            157
#define IDS_ARM_UNDO_FAILURE            158
#define IDS_ARM_RESTORE_SUCCESS         159
#define IDS_ARM_RESTORE_FAILURE         160
#define IDS_ARM_CONFIRM_SAFEMODE        161
#define IDS_ARM_SAFEMODE_EXPLAIN        162
#define IDS_ARM_SAFEMODE_SUCCESS        163
#define IDS_ARM_SAFEMODE_FAILURE        164
#define IDS_ARM_APPLY_SUCCESS           165
#define IDS_ARM_GOOD_EXIT               166
#define IDS_ARM_ALREADY_CONFIGURED      167
#define IDS_ARM_ALREADY_CONFIGURED_EXIT 168
#define IDS_NAR_MALFORMED_APPCFG        169
#define IDS_NAR_MALFORMED_APPCFG_INFO   170
#define IDS_ARM_APPLY_FAILURE           171
#define IDS_ARM_FAILED_EXIT             172
#define IDS_FILE_CONTENTS_CHANGED       173
#define IDS_ARM_DLG1APP_NAME            174
#define IDS_ARM_DLG1APP_PATH            175
#define IDS_NAR_RESTOREINFO             176
#define IDS_NAR_ADVANCED                177
#define IDS_ADDLOCALDRIVE               178
#define IDS_DELLOCALDRIVE               179
#define IDS_ADDLOCALDRIVE_HELP          180
#define IDS_DELLOCALDRIVE_HELP          181
#define IDS_NAR_INCOMPATIBLE_VERSIONS   182
#define IDS_NAR_NORUNTIME_VERSION       183
#define IDS_NAR_APPLICATION_SAFEMODE    184
#define IDS_NAR_APPLICATION_RESTORE     185
#define IDB_BITMAP_MYVIEW               240
#define IDR_MENU_FILEPOPUP              250
#define IDR_MENU_EDITPOPUP              251
#define IDR_MENU_VIEWPOPUP              252
#define IDB_BITMAP_FUSIONCACHE16        274
#define IDB_BITMAP_FUSIONCACHE24        275
#define IDB_BITMAP_UPSORT               276
#define IDB_BITMAP_DOWNSORT             277
#define IDR_SHELLVIEW_POPUP             301
#define IDR_SHELLFOLDER_POPUP           302
#define IDR_DESKTOPINI                  400
#define IDD_PROP_GENERAL                510
#define IDD_PROP_VERSION                521
#define IDD_VERSION_FILEVERSION         522
#define IDD_VERSION_DESCRIPTION         523
#define IDD_VERSION_COPYRIGHT           524
#define IDD_VERSION_KEY                 525
#define IDD_VERSION_VALUE               526
#define IDD_NAR_SRCH                    530
#define IDC_NAR_ANI_SRCH                531
#define IDD_NAR_WRK                     535
#define IDD_NAR_PAGE1                   540
#define IDC_LV_NAR_PAGE1_APPS           541
#define IDC_NAR_PAGE_ICON               542
#define IDC_NAR_INTRO_STR               543
#define IDD_NAR_PAGE2                   545
#define IDD_NAR_PAGE3                   550
#define IDC_NAR_PAGE3_ADVANCED          551
#define IDD_NAR_PAGE4                   560
#define IDC_NAR_PAGE4_LV_SNAPSHOTS      561
#define IDC_NAR_PAGE4_APPLY             563
#define IDD_NAR_PAGE5                   570
#define IDD_PROP_SCAVENGER              670
#define IDC_DRV_ICON                    671
#define IDC_DRV_LABEL                   672
#define IDD_LINE_1                      673
#define IDC_DRV_TYPE                    674
#define IDC_DRV_TYPE_TXT                675
#define IDC_DRV_FS_TXT                  676
#define IDC_DRV_FS                      677
#define IDD_LINE_2                      678
#define IDC_DRV_USEDCOLOR               679
#define IDC_DRV_USEDBYTES_TXT           680
#define IDC_DRV_USEDBYTES               681
#define IDC_DRV_USEDMB                  682
#define IDC_DRV_FREECOLOR               683
#define IDC_DRV_FREEBYTES_TXT           684
#define IDC_DRV_FREEBYTES               685
#define IDC_DRV_FREEMB                  686
#define IDC_DRV_TOTSEP                  687
#define IDC_DRV_TOTBYTES_TXT            688
#define IDC_DRV_TOTBYTES                689
#define IDC_DRV_TOTMB                   690
#define IDC_DRV_PIE                     691
#define IDC_DRV_LETTER                  692
#define IDC_DRV_SCAVENGE                693
#define IDC_DRV_CACHECOLOR              697
#define IDC_DRV_CACHEBYTES_TXT          698
#define IDC_DRV_CACHEBYTES              699
#define IDC_DRV_CACHEMB                 700
#define IDC_STORE_PREJIT_TXT            701
#define IDC_STORE_DOWNLOAD_TXT          702
#define IDC_PREJIT_TYPE                 703
#define IDC_PREJIT_SIZE                 704
#define IDC_PREJIT_SIZE_SPIN            705
#define IDC_DOWNLOAD_SIZE               706
#define IDC_DOWNLOAD_SIZE_SPIN          707
#define IDC_DOWNLOAD_TYPE               708

//*********************************************************************
// Bidi defines for dialogs
//
#define IDD_PROP_GENERAL_BIDI           800
#define IDD_PROP_VERSION_BIDI           801
#define IDD_PROP_SCAVENGER_BIDI         802
#define IDD_NAR_SRCH_BIDI               803
#define IDD_NAR_WRK_BIDI                804
#define IDD_NAR_PAGE1_BIDI              805
#define IDD_NAR_PAGE2_BIDI              806
#define IDD_NAR_PAGE3_BIDI              807
#define IDD_NAR_PAGE4_BIDI              808
#define IDD_NAR_PAGE5_BIDI              809

#define IDI_FOLDER                      900
#define IDI_FOLDEROP                    901
#define IDI_ROOT                        902
#define IDI_CACHE_APP                   903
#define IDI_CACHE_SIMPLE                904
#define IDI_CACHE_STRONG                905
#define IDI_ARM                         906
#define IDI_DATE                        907
#define IDR_MAINWNDACCEL                950
#define IDC_STATIC_CONTROL              1000
#define IDC_STATIC_ICON                 1001
#define IDC_STATIC_LABEL_CREATION       1006
#define IDC_STATIC_LABEL_LASTACCESS     1007
#define IDC_STATIC_LABEL_LASTMODIFIED   1008
#define IDC_STATIC_LABEL_TOTALSIZE      1009
#define IDC_STATIC_LABEL_CLSID          1010
#define IDC_STATIC_LABEL_CULTURE        1011
#define IDC_STATIC_LABEL_STATUS         1012
#define IDC_STATIC_LABEL_VERSION        1013
#define IDC_STATIC_LABEL_CODEBASE       1014
#define IDC_STATIC_LABEL_PUBLIC_KEY_TOKEN 1015
#define IDC_STATIC_NAME                 1016
#define IDC_STATIC_LASTACCESS           1017
#define IDC_STATIC_LASTMODIFIED         1018
#define IDC_STATIC_STATUS               1019
#define IDC_STATIC_VERSION              1020
#define IDC_STATIC_PUBLIC_KEY_TOKEN     1021
#define IDC_STATIC_TOTALSIZE            1022
#define IDC_STATIC_CLSID                1023
#define IDC_STATIC_LABEL_NAME           1024
#define IDC_STATIC_CREATION             1025
#define IDC_STATIC_CULTURE              1026
#define IDC_STATIC_CODEBASE             1027
#define IDC_STATIC_LABEL_REFS           1028
#define IDC_STATIC_REFS                 1029
#define IDC_CURRENTCACHESIZE            1050
#define IDC_SETMAXCACHESIZE             1051
#define IDC_SETMINCACHESIZE             1052
#define ID_FUSIONCACHE_GLOBALVIEW       2000
#define ID_FUSIONCACHE_DOWNLOADSTRONG   2001
#define ID_FUSIONCACHE_DOWNLOADSIMPLE   2002
#define ID_FUSIONCACHE_DOWNLOAD         2003
#define ID_FUSIONCACHE_SCAVANGE         2004
#define ID_SXSCACHE_DETAILVIEW          2005
#define ID_EDITPOPUP_CUT                2011
#define ID_EDITPOPUP_COPY               2012
#define ID_EDITPOPUP_PASTE              2013
#define ID_EDITPOPUP_UNDO               2014
#define ID_EDITPOPUP_PASTESHORTCUT      2015
#define ID_EDITPOPUP_SELECTALL          2016
#define ID_EDITPOPUP_INVERTSELECTION    2017
#define ID_REFRESH_DISPLAY              2019
#define ID_VIEWPOPUP_VIEWMENU           2020
#define ID_VIEWPOPUP_LARGEICONS         2021
#define ID_VIEWPOPUP_SMALLICONS         2022
#define ID_VIEWPOPUP_LIST               2023
#define ID_VIEWPOPUP_DETAILS            2024
#define ID_VIEWPOPUP_PROPERTIES         2025
#define ID_LAUNCH_ARM                   2026
#define ID_SHELLVIEWPOPUP_COPY          2500
#define ID_SHELLVIEWPOPUP_CUT           2501
#define ID_SHELLVIEWPOPUP_PASTE         2502
#define ID_SHELLVIEWPOPUP_PASTESHORTCUT 2503
#define ID_SHELLVIEWPOPUP_PROPERTIES    2504
#define ID_SHELLFOLDERPOPUP_EXPLORE     2505
#define ID_SHELLFOLDERPOPUP_OPEN        2506
#define ID_SHELLFOLDERPOPUP_FIND        2507
#define ID_SHELLFOLDERPOPUP_SHARING     2508
#define ID_SHELLFOLDERPOPUP_CUT         2509
#define ID_SHELLFOLDERPOPUP_COPY        2510
#define ID_SHELLFOLDERPOPUP_PASTE       2511
#define ID_SHELLFOLDERPOPUP_DELETE      2512
#define ID_SHELLFOLDERPOPUP_PROPERTIES  2513
#define ID_ACCEL_POPUP                  2514
#define ID_ACCEL_PROPERTIES             2515
#define ID_ACCEL_SELECTALL              2516
#define ID_ACCEL_CLIPCOPY               2517
#define ID_ACCEL_DELETE                 2518
#define IDM_FIRST                       3000
#define IDM_EXPLORE                     3000
#define IDM_OPEN                        3001
#define IDM_NEW                         3002
#define IDM_NEW_FOLDER                  3003
#define IDM_NEW_ITEM                    3004
#define IDM_MODIFY_DATA                 3005
#define IDM_RENAME                      3006
#define IDM_DELETE                      3007
#define IDM_COPY                        3008
#define IDM_CUT                         3009
#define IDM_PASTE                       3010
#define IDM_SEPARATOR                   3011
#define IDM_VIEW                        3012
#define IDM_VIEW_LARGE                  3013
#define IDM_VIEW_SMALL                  3014
#define IDM_VIEW_LIST                   3015
#define IDM_VIEW_DETAILS                3016
#define IDM_LAST                        3016

//*********************************************************************
// Menus and Menu Items
//
#define MENU_DEFSHELLVIEW               3029

#define IDM_FILE_SAMPLE                 3030
#define IDM_FILE_LINK                   3031
#define IDM_FILE_DEL                    3032
#define IDM_FILE_PROPERTIES             3033
#define IDM_FILE_RENAME                 3034

#define IDM_EDIT_SELECTALL              3035
#define IDM_EDIT_SELECTINVERT           3036
#define IDM_EDIT_CUT                    3037
#define IDM_EDIT_COPY                   3038
#define IDM_EDIT_PASTE                  3039
#define IDM_VIEW_CACHE_SETTINGS         3040
#define IDM_VIEW_ACTUAL                 3041
#define IDM_EDIT_UNDO                   3042

//*********************************************************************
// Other messages delivered through WM_COMMAND             
//*********************************************************************
#define IDM_HELP_TOPIC                  3045
#define IDM_HELP_ABOUT                  3046
#define IDA_FINDCOMP                    4000
#define IDC_STATIC_CONTROLNAME          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\shfusres\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"SHFUSRES.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Fusion Assembly Viewer Resources\0"
#define VER_ORIGFILENAME_STR    "shfusres.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\storetst\bindsink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//
//
// BindSink.h  
// Minimal bind sink implementation
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef BINDSINK_H
#define BINDSINK_H

#include <fusion.h>
#include <stdio.h>

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };

// Required Fusion interface IDs
const GUID IID_IAssembly = \
{ 0xff08d7d4,0x04c2,0x11d3,{0x94,0xaa,0x00,0xc0,0x4f,0xc3,0x08,0xff}};

const GUID IID_IAssemblyBindSink = \
{0xaf0bc960,0x0b9a,0x11d3,{0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51}};

// ---------------------------------------------------------------------------
// class CBindSink
// 
// This class implements IAssemblyBindSink which is passed into BindToObject 
// and will receive progress callbacks from fusion in the event binding requires 
// an async download. On successful download, receives IAssembly interface.
// ---------------------------------------------------------------------------
class CBindSink : public IAssemblyBindSink
{
public:

    // Bind result, wait event and IAssembly* ptr
    HRESULT             _hr;
    HANDLE              _hEvent;
    LPVOID              *_ppInterface;
    IAssemblyBinding    *_pAsmBinding;
    DWORD               _dwAbortSize;
    

    CBindSink();
    ~CBindSink();
    
    // Single method on interface called by fusion for all notifications.
    STDMETHOD (OnProgress)(
        DWORD          dwNotification,
        HRESULT        hrNotification,
        LPCWSTR        szNotification,
        DWORD          dwProgress,
        DWORD          dwProgressMax,
        IUnknown       *pUnk);
    

    // IUnknown boilerplate.
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

private:

    DWORD _cRef;
};

// ---------------------------------------------------------------------------
// CBindSink ctor
// ---------------------------------------------------------------------------
CBindSink::CBindSink()
{
    _hEvent         = 0;
    _ppInterface    = NULL;
    _hr             = S_OK;
    _cRef           = 0;
    _pAsmBinding    = NULL;
    _dwAbortSize    = 0xFFFFFFFF;
}

// ---------------------------------------------------------------------------
// CBindSink dtor
// ---------------------------------------------------------------------------
CBindSink::~CBindSink()
{
    if (_hEvent)
        CloseHandle(_hEvent);
    //Should already be released in DONE event
    if (_pAsmBinding)
        SAFERELEASE(_pAsmBinding);
}

// ---------------------------------------------------------------------------
// CBindSink::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindSink::AddRef()
{
    return _cRef++; 
}

// ---------------------------------------------------------------------------
// CBindSink::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindSink::Release()
{
    if (--_cRef == 0) {
        delete this;
        return 0;
    }
    return _cRef;
}

// ---------------------------------------------------------------------------
// CBindSink::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindSink::QueryInterface(REFIID riid, void** ppv)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyBindSink)
       )
    {
        *ppv = static_cast<IAssemblyBindSink*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CBindSink::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindSink::OnProgress(
    DWORD          dwNotification,
    HRESULT        hrNotification,
    LPCWSTR        szNotification,
    DWORD          dwProgress,
    DWORD          dwProgressMax,
    IUnknown       *pUnk)
{
    HRESULT hr = S_OK;
    
    _ftprintf(stderr,_T("dwNotification = %d, hr = %x, sz = %s, Prog = %d\n"),dwNotification, hrNotification, szNotification? szNotification : _T("none"), dwProgress);
    switch(dwNotification)
    {
        // All notifications shown; only
        // ASM_NOTIFICATION_DONE handled, 
        // setting _hEvent.
        case ASM_NOTIFICATION_START:
            if (_dwAbortSize == 0)
            {
                hr = E_ABORT;
                goto exit;
            }

            hr = pUnk ->QueryInterface(__uuidof(IAssemblyBinding),
                                                (void**)&_pAsmBinding);
            if (FAILED(hr))
            {
                _ftprintf(stderr,_T("Unable to create IAssemblyBinding interface (HRESULT = %x"),hr);
                hr = E_ABORT;
            }

            break;
        case ASM_NOTIFICATION_PROGRESS:
            if (_dwAbortSize <= dwProgress)
            {
                //ASSERT(_pAsmBinding);
                if (_pAsmBinding)
                    _pAsmBinding->Control(E_ABORT);
            }

            break;
        case ASM_NOTIFICATION_SUSPEND:
            break;
        case ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE:
            break;
        
        // Download complete. If successful obtain IAssembly*.
        // Set _hEvent to unblock calling thread.
        case ASM_NOTIFICATION_DONE:
            
            //Release _pAsmBinding since we don't need it anymore
            SAFERELEASE(_pAsmBinding);

            _hr = hrNotification;
            if (SUCCEEDED(hrNotification) && pUnk)
            {
                // Successfully received assembly interface.
                if (FAILED(pUnk->QueryInterface(IID_IAssembly, _ppInterface)))
                   pUnk->QueryInterface(__uuidof(IAssemblyModuleImport), _ppInterface);
            } 
            SetEvent(_hEvent);
            break;

        default:
            break;
    }
        
exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CreateBindSink
// ---------------------------------------------------------------------------
HRESULT CreateBindSink(CBindSink **ppBindSink, LPVOID *ppInterface)
{
    HRESULT hr = S_OK;
    CBindSink *pBindSink = NULL;

    pBindSink = new CBindSink();
    if (!pBindSink)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create the associated event and record target IAssembly*
    pBindSink->_hEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
    pBindSink->_ppInterface = ppInterface;

    // addref and handout.
    *ppBindSink = pBindSink;
    (*ppBindSink)->AddRef();

exit:

    return hr;
}

#endif // BINDSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\storetst\fusdelay.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <stdio.h>
#include <delayimp.h>
#include "fusionp.h"


typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);


FARPROC WINAPI FusionDelayLoadHook(unsigned dliNotify, PDelayLoadInfo pdli )
{
    static BOOL fFound = FALSE;
    HMODULE hmodEEShim = NULL;
    HMODULE hmodFusion = NULL;
    DWORD ccPath       = MAX_PATH;
    WCHAR szFusionPath[MAX_PATH];

    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;
    
    if (fFound)
        goto exit;
            
    switch(dliNotify)
    {            
        case dliNotePreLoadLibrary:
        {
            if (strcmp(pdli->szDll, "fusion.dll"))
                goto exit;
  
            hmodEEShim = LoadLibrary(L"mscoree.dll");
            if (!hmodEEShim)
                goto exit;

            pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY) 
                GetProcAddress(hmodEEShim, "GetCORSystemDirectory");

            if (!pfnGetCorSystemDirectory 
                || FAILED(pfnGetCorSystemDirectory(szFusionPath, MAX_PATH, &ccPath)))
            {
                FreeLibrary(hmodEEShim);
                hmodEEShim = NULL;
                goto exit;
            }

            lstrcatW(szFusionPath, L"fusion.dll");
            hmodFusion = LoadLibrary(szFusionPath);
            if (!hmodFusion)
                goto exit;

            fFound = TRUE;
           
            break;
        }
        default:
        {
            break;
        }
    }

exit:
    return (FARPROC) hmodFusion;
}


PfnDliHook __pfnDliNotifyHook = FusionDelayLoadHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\storetst\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"STORETST.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Fusion Test Tool\0"
#define VER_ORIGFILENAME_STR    "storetst.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\afxres.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Microsoft Foundation Classes C++ library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifndef _MFC_VER
#define _MFC_VER 0x0600
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#if _MFC_VER >= 0x0600
#define CBRS_GRIPPER        0x00400000L
#endif

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#if _MFC_VER >= 0x0600
#define CBRS_ALL            0x0040FFFFL
#else
#define CBRS_ALL            0xFFFFL
#endif

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#if _MFC_VER >= 0x0600
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar
#endif

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#if _MFC_VER >= 0x0600
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
#endif
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#if _MFC_VER >= 0x0600
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#endif
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

#if _MFC_VER >= 0x0600
// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D
#endif

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\storetst\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>
#include <wchar.h>

#include "initguid.h"
#include "fusionp.h"
#include "bindsink.h"


IMalloc         *g_pMalloc=NULL;
static  HANDLE g_Semaphore=NULL;

#define MAX_COMMAND_ARGS    32

#define ENUM_GLOBAL _T("GAC")
#define ENUM_ZAP    _T("ZAP")
#define ENUM_SIMPLE _T("DOWNLOAD")

TCHAR   cVersionSeperator = TEXT('.');

DWORD   g_dwDisplayFlags = ASM_DISPLAYF_VERSION 
                        | ASM_DISPLAYF_CULTURE
                        | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                        | ASM_DISPLAYF_CUSTOM;


STDAPI  NukeDownloadedCache();
STDAPI  DeleteAssemblyFromTransportCache( LPCTSTR lpszCmdLine, DWORD *pDelCount );
STDAPI  CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      

STDAPI InstallCustomAssembly(
    LPCOLESTR              szPath, 
    LPBYTE                 pbCustom,
    DWORD                  cbCustom,
    IAssembly            **ppAsmOut);

STDAPI InstallCustomModule(
    IAssemblyName        *pName,
    LPCOLESTR              szPath);

typedef enum _COMMAND_CODE {
    CmdNukeDownloaded,
    CmdEnumAssemblies,
        CmdEnumAssemblyReferences,
    CmdEnumByName,
    CmdEnumNameRes,
    CmdInsertEntry,
    CmdInsertEntryEZ,
    CmdBind,
    CmdBindEZ,
    CmdFindEntry,
    CmdFindEntryByKey,
    CmdDeleteEntry,
    CmdDeleteEntryByKey,
    CmdDeleteEntryByName,
    CmdLockEntryByKey,
    CmdUnlockEntryByKey,
    CmdReadCmdsFromFile,
    CmdPvtEnumAll,
    CmdPvtEnumByAppbase,
    CmdPvtFindEntryByKey,
    CmdPvtDeleteEntryByKey,

    CmdFlushCache,
    CmdScavengeCache,
    CmdInstallAssembly,
    CmdForceInstallAssembly,
    CmdInstallCustomAssembly,
    CmdInstallCustomModule,
    CmdGetAssemblyInstallInfo,

    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef enum _COMMAND_TYPE_ {
    Public,
    Private  // Order of these defs is  important.
} COMMAND_TYPE, *LPCOMMAND_TYPE;

COMMAND_TYPE    g_UserType=Public;

typedef struct _COMMAND_INFO {
    LPTSTR CommandName;
    LPTSTR AltCommandName;
    LPTSTR CommandParams;
    COMMAND_CODE CommandCode;
    COMMAND_TYPE CommandType;
} COMMAND_INFO, *LPCOMMAND_INFO;

COMMAND_INFO GlobalCommandInfo[] = {
    {TEXT( "Bind   ==>\t" ),  TEXT( "b" ), TEXT( "NameString CodeBase <AppBase> <AppCfg> <SID>" ), CmdBind, Private },
    {TEXT( "BindEZ ==>\t" ),  TEXT( "be" ), TEXT( "CodeBase <AppBase> <AppCfg> <SID>" ), CmdBindEZ, Private },
    {TEXT( "Nuke Download Cache ==>\t" ),  TEXT( "nd" ), TEXT( "" ), CmdNukeDownloaded, Private} ,
    {TEXT( "Install Assembly \t==>\t" ),  TEXT( "in" ), TEXT( "AssemblyPath <GUID Identifier Value>" ), CmdInstallAssembly, Public} ,
    {TEXT( "Force Install Assembly \t==>\t" ),  TEXT( "inf" ), TEXT( "AssemblyPath <GUID Identifier Value>" ), CmdForceInstallAssembly, Public} ,
    {TEXT( "Install Custom Assembly \t==>\t" ),  TEXT( "inca" ), TEXT( "AssemblyPath CustomString" ), CmdInstallCustomAssembly, Public} ,
    {TEXT( "Install Custom Module \t==>\t" ),  TEXT( "incm" ), TEXT( "AssemblyName, ModulePath" ), CmdInstallCustomModule, Public} ,
    {TEXT( "Uninstall Assembly  ==>\t" ),  TEXT( "un" ), TEXT( "AssemblyNameString <GUID Indentifier Value>" ), CmdDeleteEntryByName, Public},
//    {TEXT( "GetAssemblyInstallInfo ==>\t" ),  TEXT( "gi" ), TEXT( "AssemblyNameString <InstallerType>" ), CmdGetAssemblyInstallInfo, Private} ,
    {TEXT( "Enumerate Assemblies ==>\t" ),  TEXT( "ea" ), TEXT( "CacheType <AssemblyNameString>" ), CmdEnumAssemblies, Public} ,
        {TEXT( "Enumerate Assembly Install Reference ==>\t" ),  TEXT( "er" ), TEXT( "<AssemblyNameString>" ), CmdEnumAssemblyReferences, Public} ,
    {TEXT( "Enumerate NameRes   ==>\t" ),  TEXT( "en" ), TEXT( "" ), CmdEnumNameRes, Private} ,
    {TEXT( "Flush Cache \t==>\t" ),  TEXT( "fc" ), TEXT( "" ), CmdFlushCache, Private},
    {TEXT( "Scavenge Cache \t==>\t" ),  TEXT( "sc" ), TEXT( "SizeHigh SizeLow" ), CmdScavengeCache, Private} ,
    {TEXT( "Read Cmds From File \t==>\t" ),  TEXT( "rf" ), TEXT( "FileName  <# of threads>" ), CmdReadCmdsFromFile, Private} ,

    {TEXT( "Help  \t\t==>\t" ), TEXT( "/?" ),  TEXT(""), CmdHelp, Public },
    {TEXT( "Quit  \t\t==>\t" ), TEXT( "q" ),  TEXT(""), CmdQuit, Public }
};

extern "C" int __cdecl _tmain(int, TCHAR**);




HRESULT GetFileLastModified(LPCWSTR pwzFileName, FILETIME *pftLastModified)
{
    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    if (!pwzFileName || !pftLastModified) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hFile = CreateFileW(pwzFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (!GetFileTime(hFile, NULL, NULL, pftLastModified)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;
}

LPSTR W2ANew(LPCWSTR wzFrom)
{
    int cchRequired;
    char *pszT = NULL;

    cchRequired = WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, NULL, 0, NULL, NULL
);
    cchRequired++;
    pszT = new char[cchRequired];
    if (!pszT)
    {
        return NULL;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, pszT, cchRequired, NULL, NULL))
    {
        pszT = NULL;
    }

    return pszT;
}

LPWSTR A2WNew(LPCSTR szFrom )
{
    int cwchRequired;
    WCHAR *pwzT = NULL;

    cwchRequired = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, NULL, 0);
    cwchRequired++;

    pwzT = new WCHAR[cwchRequired];
    if (!pwzT)
    {
        return NULL;
    }

    if (!MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwzT, cwchRequired))
    {
        pwzT = NULL;
    }

    return pwzT;
}

LPWSTR T2WNew(LPCTSTR szFrom )
{
    WCHAR *pwzT = NULL;

#ifndef UNICODE

        int cwchRequired = 0;

    cwchRequired = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, NULL, 0);
    cwchRequired++;

    pwzT = new WCHAR[cwchRequired];
    if (!pwzT)
    {
        return NULL;
    }

    if (!MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwzT, cwchRequired))
    {
        pwzT = NULL;
    }
#else

        pwzT = new WCHAR[lstrlen(szFrom)+1];
        if (pwzT)
            lstrcpy(pwzT, szFrom);

#endif

    return pwzT;        
}


//Converts Culture=empty to Culture=""
LPTSTR  TranslateLocale(LPTSTR pszSource)
{
    LPTSTR  pszDest = NULL;
    LPTSTR  pszTmp = NULL;

    if (pszSource)
    {
        pszDest = new TCHAR[_tcslen(pszSource)+1];

        if (pszTmp = _tcsstr(pszSource, _T("Culture=empty")))
        {
            _tcsncpy(pszDest, pszSource, pszTmp-pszSource);
            pszDest[pszTmp-pszSource] = _T('\0');
            _tcscat(pszDest, _T("Loc=\"\""));
            _tcscat(pszDest, pszTmp + _tcslen(_T("Culture=empty")));
        }
        else
        {
            _tcscpy(pszDest, pszSource);
        }
    }

    return pszDest;
}

HRESULT VersionFromString(LPTSTR pszVersion, TCHAR cSeperator, LPDWORD pdwVerHi, LPDWORD pdwVerLo)
{
        LPTSTR pchVer = pszVersion;
        TCHAR ch;
        
        USHORT n = 0;
        USHORT a = 0;
        USHORT b = 0;
        USHORT c = 0;
        USHORT d = 0;

        enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;

        for (ch = (char) *pchVer++;;ch = (char) *pchVer++) 
        {

                if ((ch == cSeperator) || (ch == _T('\0'))) 
                {

                        switch (have) {

                        case HAVE_NONE:
                                a = n;
                                have = HAVE_A;
                                break;

                        case HAVE_A:
                                b = n;
                                have = HAVE_B;
                                break;

                        case HAVE_B:
                                c = n;
                                have = HAVE_C;
                                break;

                        case HAVE_C:
                                d = n;
                                have = HAVE_D;
                                break;

                        case HAVE_D:
                                //TODO: log failure
                                return S_OK; // invalid arg
                        }

                        if (ch == _T('\0')) 
                        {
                                // all done convert a,b,c,d into two dwords of version

                                *pdwVerHi = ((a << 16)|b);
                                *pdwVerLo = ((c << 16)|d);
                                return S_OK;
                        }

                        n = 0; // reset

                } 
                else if ( (ch < _T('0')) || (ch > _T('9')))
                {

                        *pdwVerLo = 0xffffffff;
                        //ANVLOGSEVERE(TEXT("Invalid Argument.  Version string conatins an incorrect Format"));
                        return S_OK;
                        //return E_INVALIDARG;    // invalid arg
                }
                else
                        n = n*10 + (ch - _T('0'));


        } /* end forever */     

        return S_OK;
}

HRESULT StringFromVersion(DWORD dwVerHi, DWORD dwVerLo, LPTSTR ptszVersionBuf, TCHAR cSeperator)
{
        if (!ptszVersionBuf)
                return E_INVALIDARG;

        _stprintf(ptszVersionBuf, TEXT("%d%c%d%c%d%c%d"), (dwVerHi & 0xffff0000)>>16,
                                                                                                        cSeperator,
                                                                                                        (dwVerHi & 0xffff),
                                                                                                        cSeperator,
                                                                                                        (dwVerLo & 0xffff0000)>>16,
                                                                                                        cSeperator,
                                                                                                        (dwVerLo & 0xffff));

        return S_OK;
}

COMMAND_CODE
DecodeCommand(
    LPTSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    for( i = 0; i < NumCommands; i++) {
        if( ( g_UserType >= GlobalCommandInfo[i].CommandType) &&
            (( _tcsicmp( CommandName, GlobalCommandInfo[i].CommandName ) == 0 ) ||
           ( _tcsicmp( CommandName, GlobalCommandInfo[i].AltCommandName ) == 0 ))) 
        {
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    for( i = 0; i < NumCommands; i++) {
        if( g_UserType >= GlobalCommandInfo[i].CommandType)
        {
            _ftprintf(stderr, _T( "    %s (%s) %s\n" ),
                GlobalCommandInfo[i].CommandName,
                GlobalCommandInfo[i].AltCommandName,
                GlobalCommandInfo[i].CommandParams );
        }
    }
}

VOID
DisplayCopyright(
    VOID
    )
{
    if( g_UserType >= Public)
        _ftprintf(stderr,_T( "STORETST: Copyright (C) Microsoft Corp 1999. All rights reserved.\n") );
    else
        _ftprintf(stderr,_T( "CacheMgr: Copyright (C) Microsoft Corp 1999. All rights reserved.\n") );

    _ftprintf(stderr,_T( "Usage: command <command parameters>\n" ));

}


VOID
DisplayUsage(
    VOID
    )
{

    DisplayCopyright();

    _ftprintf(stderr, _T( "Commands : \n" ));
    PrintCommands();
    return;
}



VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    )
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}

LPTSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPTSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};

    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        _stprintf (OutputBuffer, TEXT( "<none>" ));
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        _stprintf( OutputBuffer,
                    TEXT( "%02u/%02u/%04u %02u:%02u:%02u " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }

    return( OutputBuffer );
}

////////////////////////////////////////////////////////////
//Static Helper functions to convert hex string<->bin
////////////////////////////////////////////////////////////

//--------------------------------------------------------------------
// BinToUnicodeHex
//--------------------------------------------------------------------
void BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst)
{
        UINT x;
        UINT y;

#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))

        for ( x = 0, y = 0 ; x < cSrc ; ++x )
        {
                UINT v;
                v = pSrc[x]>>4;
                pDst[y++] = TOHEX( v );  
                v = pSrc[x] & 0x0f;                             
                pDst[y++] = TOHEX( v ); 
        }                                                                        
        pDst[y] = '\0';
}

//--------------------------------------------------------------------
// UnicodeHexToBin
//--------------------------------------------------------------------
VOID UnicodeHexToBin(LPWSTR pSrc, UINT cSrc, LPBYTE pDest)
{
    BYTE v;
    LPBYTE pd = pDest;
    LPWSTR ps = pSrc;

#define FROMHEX(a) ((a)>=L'a' ? a - L'a' + 10 : a - L'0')

    for (UINT i = 0; i < cSrc-1; i+=2)
    {
        v =  FROMHEX(ps[i]) << 4;
        v |= FROMHEX(ps[i+1]);
       *(pd++) = v;
    }
}


DWORD ProcessFindEntry(int argc, LPTSTR* argv) 
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessInsertEntry(int argc, LPTSTR* argv) 
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}


DWORD ProcessEnumByName(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessNukeDownloadedCache(int argc, LPTSTR* argv)
{
    HRESULT hr = S_OK;

    hr = NukeDownloadedCache();

    if (FAILED(hr))
    {
        _ftprintf(stderr, _T("Error deleting cache (HRESULT = %x)\n"),hr);
    }
    else
    {
        _ftprintf(stderr, _T("Download cache deleted successfully\n"),hr);
        hr = S_OK;
    }

    return hr;
}

DWORD ProcessEnumAll(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessDeleteEntry(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessInsertEZ(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

HRESULT BindHelper(LPTSTR pszNameIn, LPTSTR pszCodeBase, LPTSTR pszAppBase,
                   LPTSTR pszAppConfig, LPTSTR pszSID, DWORD dwFlags,
                   DWORD dwAbortNum, DWORD dwAbortSize)
{
    HRESULT hr = S_OK;

    // Assembly names (source is ref, target is def
    // from assembly) bind sink and application context,
    // and resulting IAssembly* required for binding.    
    LPASSEMBLYNAME          pNameRef     = NULL;
    LPASSEMBLYNAME          pNameDef     = NULL;
    CBindSink               *pBindSink   = NULL;
    LPASSEMBLYNAME          pAppCtxName  = NULL;
    LPAPPLICATIONCONTEXT    pAppCtx      = NULL;
    LPASSEMBLY              pAssembly    = NULL;
    DWORD                   iModCount    = 0;
    IAssemblyModuleImport*  pModImport   = NULL;
    IAssemblyModuleImport*  pModImport2  = NULL;
    DWORD                   dwNameSize   = MAX_CLASS_NAME;
    WCHAR                   szModName[MAX_CLASS_NAME];
    LPWSTR                  szDisplayName = NULL;
    DWORD                   dwModuleNum  = 0;
    LPTSTR                  pszName      = NULL;

    //Change Culture=empty in name string to Culture=""
    if ( (dwFlags & CANOF_PARSE_DISPLAY_NAME) && pszNameIn)
    {
        pszName = TranslateLocale(pszNameIn);
    }

    //Create an AssemblyName object
    hr = CreateAssemblyNameObject(&pNameRef, pszName, dwFlags, NULL);
    if (pszName)
        delete [] pszName;

    if (FAILED(hr))
        goto exit; 

    // Construct an application context for the bind.
    if (FAILED(hr = CreateAssemblyNameObject(&pAppCtxName, L"My App", CANOF_SET_DEFAULT_VALUES, NULL)))
        goto exit;
    if (FAILED(hr = CreateApplicationContext(pAppCtxName, &pAppCtx)))
        goto exit;
        
    // Set the AppBase in the Application Context
    if (pszAppBase)
    {
        pAppCtx->Set(
                     ACTAG_APP_BASE_URL,
                     pszAppBase,
                     (lstrlen(pszAppBase)+1)*sizeof(TCHAR),
                     0);

        //If AppBase is set, let's also set the policy file
                
                // If no policy file is specified app.cfg is used as the default policy file 
                // else the user specified file is used. 
        
                TCHAR c_szDefaultConfigFile[] = TEXT("app.cfg");

                if(pszAppConfig == NULL)
                        pAppCtx->Set(
                 ACTAG_APP_CONFIG_FILE,
                     c_szDefaultConfigFile,
                 (lstrlen(c_szDefaultConfigFile)+1)*sizeof(TCHAR),
                 0);
                
                else
                        pAppCtx->Set(
                             ACTAG_APP_CONFIG_FILE,
                         pszAppConfig,
                 (lstrlen(pszAppConfig)+1)*sizeof(TCHAR),
                 0);
    }

    //Set SID in the application context
    if (pszSID)
    {
        pAppCtx->Set(
                     ACTAG_APP_SNAPSHOT_ID,
                     pszSID,
                     (lstrlen(pszSID)+1)*sizeof(TCHAR),
                     0);
    }

    // Create the bind sink object.
    if (FAILED(hr = CreateBindSink(&pBindSink, (LPVOID*)&pAssembly)))
        goto exit;

    //Set Abort option
    if (dwAbortNum == 1)
    {
        pBindSink->_dwAbortSize = dwAbortSize;
    }

    if (!lstrcmpi(pszCodeBase,TEXT("null")))
            pszCodeBase = NULL;

    // Bind to the assembly. We specify only the codebase which
    // is where we expect to find the simply named assembly.
    hr = pNameRef->BindToObject(
        IID_IAssembly, 
        pBindSink,
        pAppCtx, 
        pszCodeBase,        
        ASM_BINDF_FORCE_CACHE_INSTALL,
        NULL,
        0,
        (LPVOID*) &pAssembly);

    // If a download is required the bind call went async and
    // we wait on the associated event until download complete.
    // Otherwise the binding succeeded synchronously.
    if (hr == E_PENDING)
    {
        WaitForSingleObject(pBindSink->_hEvent, INFINITE);        
        hr = pBindSink->_hr;
    }
    
    if (FAILED(hr))
        goto exit;

    if (!pAssembly) {
        _ftprintf(stderr,_T("Error: Binder reported success but it gave no IAssembly back\n")); 
        hr = E_FAIL;
        goto exit;
    }
    
    //We don't need this bind sink anymore
    SAFERELEASE(pBindSink);
    
    // We now have an IAssembly interface for the
    // assembly which resides in the private fusion
    // assembly cache.

    // Get the IAssemblyName associated with the 
    // assembly. This is known as the name definition
    // (name def)
    if (FAILED(hr = pAssembly->GetAssemblyNameDef(&pNameDef)))
        goto exit;
    
    // Print out the target assembly name and version (from name def)
    // This should agree with the name ref info used to bind. Also
    // get the cache path of the assembly.
    WCHAR szName[MAX_CLASS_NAME], szPath[MAX_PATH];
    DWORD cb = 0;

    if (FAILED(hr = pNameDef->GetName(&(cb = MAX_CLASS_NAME), szName))
        || FAILED(hr = pAssembly->GetManifestModulePath(szPath, &(cb = MAX_PATH))))
        goto exit;

    _ftprintf(stderr,_T("Assembly Name : %ws\n"), szName);
    _ftprintf(stderr,_T("Manifest Path : %ws\n"), szPath);

    //Print codebase
    WCHAR* pszAsmCodebase = NULL;
    cb = 0;
    hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, NULL, &cb);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        pszAsmCodebase = new WCHAR[cb];
        hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pszAsmCodebase, &cb);
        if (cb > 0)
            _ftprintf(stderr,_T("Codebase : %ws\n"), pszAsmCodebase);
        else
        {
            _ftprintf(stderr,_T("Codebase : ERROR (hr=%X)\n"), hr);
        }
        delete [] pszAsmCodebase;
        pszAsmCodebase = NULL;
    }

    //Print MVID
    BYTE*   pbMVID = NULL;
    WCHAR   szMVID[1024];
    cb=0;
    hr = pNameDef->GetProperty(ASM_NAME_SIGNATURE_BLOB, NULL, &cb);
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        pbMVID = new BYTE[cb];
        hr = pNameDef->GetProperty(ASM_NAME_SIGNATURE_BLOB, pbMVID, &cb);
        if (cb > 0)
        {
            BinToUnicodeHex(pbMVID, cb, szMVID);
            _ftprintf(stderr,_T("MVID : %ws\n"), szMVID);
        }
        delete [] pbMVID;
    }

    //Let's also print the display name
    dwNameSize = 0;
    hr = pNameDef->GetDisplayName(szDisplayName, &dwNameSize, g_dwDisplayFlags);
    if (dwNameSize)
    {
            szDisplayName = new WCHAR[dwNameSize];
            if (SUCCEEDED(pNameDef->GetDisplayName(szDisplayName, &dwNameSize, g_dwDisplayFlags)))
                    _ftprintf(stderr,_T("Display Name : %ws\n"), szDisplayName);
            delete [] szDisplayName;
    }

    //Bind to all modules in assembly
    
    // Create the bind sink object.
    if (FAILED(hr = CreateBindSink(&pBindSink, (LPVOID*)&pModImport2)))
        goto exit;

        do
        {
            if (SUCCEEDED(hr = pAssembly->GetNextAssemblyModule(iModCount, &pModImport)))
            {
                dwModuleNum++;    
                dwNameSize = MAX_CLASS_NAME;
                if (!pModImport->IsAvailable())
                {
                    //Check if we should abort download of this module
                    if (dwModuleNum == (dwAbortNum-1))
                        pBindSink->_dwAbortSize = dwAbortSize;

                    hr = pModImport->BindToObject(
                                    pBindSink,
                                    pAppCtx,
                                    0,
                                    (LPVOID*) &pModImport2);

                    if (hr == E_PENDING)
                    {
                            WaitForSingleObject(pBindSink->_hEvent, INFINITE);        
                            hr = pBindSink->_hr;
                    }

                    if (!SUCCEEDED(hr))
                            goto exit;
                    
                    pModImport2->GetModuleName(szModName, &dwNameSize);
                    _ftprintf(stderr,_T("Downloaded Module - %ws\n"), szModName);

                    SAFERELEASE(pModImport2);
                }
                else
                {
                    pModImport->GetModuleName(szModName, &dwNameSize);
                    _ftprintf(stderr,_T("Module found in cache - %ws\n"), szModName);
                }

                SAFERELEASE(pModImport);
                
                iModCount++;
            }
        }while (SUCCEEDED(hr));

        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
                hr = S_OK;

exit:
    // Cleanup
    SAFERELEASE(pNameRef);
    SAFERELEASE(pNameDef);
    SAFERELEASE(pBindSink);
    SAFERELEASE(pAppCtx);
    SAFERELEASE(pAssembly);
    SAFERELEASE(pModImport);
    SAFERELEASE(pModImport2);
    SAFERELEASE(pAppCtxName);
    
    if (SUCCEEDED(hr))
    {
        _ftprintf(stderr,_T("Bind SUCCEEDED\n"));
    }
    else
    {
        _ftprintf(stderr,_T("Bind FAILED (hr=%X)\n"), hr);
    }

    return hr;
}

DWORD ProcessBindEZ(int argc, LPTSTR* argv)
{
    HRESULT hr          = S_OK;
    int     i           = 0;
    DWORD   dwAbortFlag = 0;

    TCHAR c_szBindEZUsage[] = _T("(BindEZ) Usage: be CodeBase <AppBase> <SID>\n");

    if (argc < 2)
    {
        _ftprintf(stderr, c_szBindEZUsage);
        return (ERROR_INVALID_PARAMETER);
    }

    hr =BindHelper(NULL, 
                    argv[0], 
                    argc>1?argv[1]:NULL,
                    argc>2?argv[2]:NULL,
                    argc>3?argv[3]:NULL,
                    CANOF_SET_DEFAULT_VALUES,
                    argc>4?_ttoi(argv[4]):NULL,
                    argc>5?_ttoi(argv[5]):NULL);
                   
    return (DWORD) hr;
}

DWORD ProcessInNewThread(LPTSTR szCmdLine);

DWORD ProcessCommandsFromFile(int argc, LPTSTR* argv)
{
    HRESULT hr = S_OK;
    TCHAR   szCmdLine[MAX_PATH+1];
    DWORD   cNoOfThreads=1;
    TCHAR   szSemName[MAX_PATH+1];


    TCHAR c_szBindUsage[] = _T("(Read Cmds From File ) Usage: rf FileName  <# of threads> \n");

    if (argc < 1)
    {
        _ftprintf(stderr, c_szBindUsage);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }



    FILE *FileStream = _tfopen(argv[0], _T("r") );

    if(FileStream == NULL)
    {
        _ftprintf(stderr, _T("Error <%d> opening file <%s> \n"), GetLastError(), argv[0]);
        goto exit;
    }

    if(!g_Semaphore)
    {
            if(argc > 1)
            {
                cNoOfThreads = _ttoi(argv[1]);
            }
            wsprintf(szSemName, _T("Fusion_storetst_%d"), GetCurrentProcessId());
            g_Semaphore = CreateSemaphore(NULL, cNoOfThreads, cNoOfThreads, szSemName);
            if(!g_Semaphore)
            {
                _ftprintf(stderr, _T("Error <%d> Creating Semaphore <%s> \n"), GetLastError(), szSemName);
                goto exit;
            }
    }

    while(_fgetts(szCmdLine, MAX_PATH, FileStream))
    {
            // Wait for object
        WaitForSingleObject(g_Semaphore, -1);
        hr = ProcessInNewThread(szCmdLine);
    }

exit :

    if(FileStream != NULL)
    {
        fclose(FileStream);
    }

    return (DWORD)hr;
}

DWORD ProcessBind(int argc, LPTSTR* argv)
{
    HRESULT hr = S_OK;

    TCHAR c_szBindUsage[] = _T("(Bind) Usage: b NameString CodeBase <AppBase> <SID>\n");

    if (argc < 2)
    {
        _ftprintf(stderr, c_szBindUsage);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    hr = BindHelper(argv[0], 
            argv[1], 
            argc>2?argv[2]:NULL, 
            argc>3?argv[3]:NULL,
            argc>4?argv[4]:NULL,
            CANOF_PARSE_DISPLAY_NAME,
            argc>5?_ttoi(argv[5]):NULL,
            argc>6?_ttoi(argv[6]):NULL);

    return (DWORD)hr;
}

DWORD ProcessEnumAssemblies(int argc, LPTSTR* argv)
{
    TCHAR c_szEnumAssembliesUsage[] = _T("(EnumAssemblies) Usage: ea Type(GLOBAL|STRONG|SIMPLE) <AssemblyNameString>\n");
    
    HRESULT                 hr              = S_OK;

    if (argc == 0)
    {
        LPTSTR buf = NULL;
        buf = new TCHAR[20];
        _tcscpy(buf,ENUM_GLOBAL);
        if (FAILED(hr = ProcessEnumAssemblies(1, &buf)))
            goto end;
        _tcscpy(buf,ENUM_ZAP);
        if (FAILED(hr = ProcessEnumAssemblies(1, &buf)))
            goto end;
        _tcscpy(buf,ENUM_SIMPLE);
        if (FAILED(hr = ProcessEnumAssemblies(1, &buf)))
            goto end;
        
end:
        if (buf)
            delete [] buf;
        return hr;
    }
    
    IAssemblyEnum*          pEnum           = NULL;
    IAssemblyName*          pEnumName       = NULL;
    IAssemblyName*          pAsmName        = NULL;
    IApplicationContext*    pAppCtx         = NULL;
    DWORD                   dwFlags         = 0;
    DWORD                   dwCount         = 0;
    WCHAR*                  szDisplayName   = NULL;
    DWORD                   dwLen           = 0;
    WCHAR*                  pszCodebase     = NULL;
    DWORD                   cb=1024;
    BYTE*                   pbMVID = NULL;
    WCHAR                   szMVID[1024];

    szMVID[0] = _T('\0');

    //Set Enum flag - which cache to enum
    if (!lstrcmpi(argv[0], ENUM_GLOBAL))
    {
        dwFlags = ASM_CACHE_GAC;
    }
    else if (!lstrcmpi(argv[0], ENUM_ZAP))
    {
        dwFlags = ASM_CACHE_ZAP;
    }
    else if (!lstrcmpi(argv[0], ENUM_SIMPLE))
    {
        dwFlags = ASM_CACHE_DOWNLOAD;
    }
    else
    {
        _ftprintf(stderr, _T("Unknown Assembly Type. Use %s or %s or %s\n"),ENUM_GLOBAL,ENUM_ZAP,ENUM_SIMPLE);
        return (ERROR_INVALID_PARAMETER);
    }

    //Create AssemblyName for enum
    if (argc > 1)
    {
        if (FAILED(hr = CreateAssemblyNameObject(&pEnumName, argv[1], CANOF_PARSE_DISPLAY_NAME, NULL)))
            goto exit;
    }
    
    _ftprintf(stdout, _T("Fusion Cache Enumeration: (%s):\n"),argv[0]);
    
    hr = CreateAssemblyEnum(&pEnum, 
                            NULL, 
                            pEnumName,
                            dwFlags, 
                            NULL);
    SAFERELEASE(pEnumName);

    while (hr == S_OK)
    {
        hr = pEnum->GetNextAssembly(&pAppCtx, &pAsmName, 0);
        if (hr == S_OK)
        {
            dwCount++;
            dwLen = 0;
            _ftprintf(stdout, _T("Assembly #%d: \n"), dwCount);
            hr = pAsmName->GetDisplayName(NULL, &dwLen, g_dwDisplayFlags);
            if (dwLen)
            {
                szDisplayName = new WCHAR[dwLen+1];
                hr = pAsmName->GetDisplayName(szDisplayName, &dwLen, g_dwDisplayFlags);
                if (SUCCEEDED(hr))
                {
                    _ftprintf(stdout,_T("%ws\n"), szDisplayName);
                    cb = 0;
                    hr = pAsmName->GetProperty(ASM_NAME_CODEBASE_URL, NULL, &cb);
                    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                    {
                        pszCodebase = new WCHAR[cb];
                        hr = pAsmName->GetProperty(ASM_NAME_CODEBASE_URL, pszCodebase, &cb);
                        if (cb > 0)
                            _ftprintf(stderr,_T("Codebase : %ws\n"), pszCodebase);
                        else
                        {
                            _ftprintf(stderr,_T("Codebase : ERROR (hr=%X)\n"), hr);
                        }
                        delete [] pszCodebase;
                        pszCodebase = NULL;
                    }
                    cb=0;
                    hr = pAsmName->GetProperty(ASM_NAME_SIGNATURE_BLOB, NULL, &cb);
                    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                    {
                        pbMVID = new BYTE[cb];
                        hr = pAsmName->GetProperty(ASM_NAME_SIGNATURE_BLOB, pbMVID, &cb);
                        if (cb > 0)
                        {
                            BinToUnicodeHex(pbMVID, cb, szMVID);
                            _ftprintf(stderr,_T("MVID : %ws\n"), szMVID);
                        }
                        delete [] pbMVID;
                        pbMVID = NULL;
                    }
                }
                else
                {
                    _ftprintf(stderr,_T("Error in IAssemblyName::GetDisplayName (HRESULT=%X)"),hr);
                    goto exit;
                }
                delete [] szDisplayName;
                szDisplayName = NULL;
            }

            if (pAppCtx)
            {
                pAppCtx->Release();
                pAppCtx = NULL;
            }
            if (pAsmName)
            {
                pAsmName->Release();
                pAsmName = NULL;
            }
        }
        _ftprintf(stdout, _T("\n"));
    }

    _ftprintf(stdout, _T("Number of items = %d\n"),dwCount);

    if (hr == S_FALSE)
        hr = S_OK;

exit:
    if (FAILED(hr))
    {
        _ftprintf(stdout, _T("Error in Enumeration (HRESULT=%X)"),hr);
    }
    if (pAppCtx)
        SAFERELEASE(pAppCtx);
    if (pAsmName)
        SAFERELEASE(pAsmName);
    if (pEnum)
        SAFERELEASE(pEnum);
    if (pEnumName)
        SAFERELEASE(pEnumName);
    if (szDisplayName)
        delete [] szDisplayName;
    if (pszCodebase)
        delete [] pszCodebase;
    if (pbMVID)
        delete [] pbMVID;

    return hr;
}


DWORD ProcessEnumAssemblyReferences(int argc, LPTSTR* argv)
{
    TCHAR c_szEnumAssembliesUsage[] = _T("(EnumAssemblyInstallReference) Usage: er <AssemblyNameString>\n");
    
    HRESULT                                             hr              = S_OK;  
        HRESULT                                         hrInstallRef    = S_OK; 
    IAssemblyEnum*                              pEnum           = NULL;
    IAssemblyName*                              pEnumName       = NULL;
    IAssemblyName*                              pAsmName        = NULL;
    IApplicationContext*                pAppCtx         = NULL;
    DWORD                                               dwFlags         = 0;
    DWORD                                               dwCount         = 0;
    WCHAR*                                              szDisplayName   = NULL;
    DWORD                                               dwLen           = 0;
    WCHAR*                                              pszCodebase     = NULL;
    DWORD                                               cb                              = 1024;
    BYTE*                                               pbMVID                  = NULL;
    WCHAR                                               szMVID[1024];
        IInstallReferenceEnum           *pInstallRefEnum= NULL;
    IInstallReferenceItem               *pRefItem               = NULL;
    LPFUSION_INSTALL_REFERENCE  pRefData                = NULL;


    szMVID[0] = _T('\0');

    dwFlags = ASM_CACHE_GAC;
 
    //Create AssemblyName for enum
    if (argc > 0)
    {
        if (FAILED(hr = CreateAssemblyNameObject(&pEnumName, argv[0], CANOF_PARSE_DISPLAY_NAME, NULL)))
            goto exit;

           _ftprintf(stdout, _T("Fusion Assembly Install Reference: (%s):\n"),argv[0]);
 
    } 
    
    
    hr = CreateAssemblyEnum(&pEnum, 
                            NULL, 
                            pEnumName,
                            dwFlags, 
                            NULL);
    SAFERELEASE(pEnumName);

    while (hr == S_OK)
    {
        hr = pEnum->GetNextAssembly(&pAppCtx, &pAsmName, 0);
        if (hr == S_OK)
        {
            dwCount++;
            dwLen = 0;
                        _ftprintf(stdout, _T("Assembly #%d: \n"), dwCount);
            hr = pAsmName->GetDisplayName(NULL, &dwLen, g_dwDisplayFlags);
            if (dwLen)
            {
                szDisplayName = new WCHAR[dwLen+1];
                hr = pAsmName->GetDisplayName(szDisplayName, &dwLen, ASM_DISPLAYF_VERSION | ASM_DISPLAYF_CULTURE | ASM_DISPLAYF_PUBLIC_KEY_TOKEN );
                if (SUCCEEDED(hr))
                {
                            _ftprintf(stdout,_T("%ws\n\n"), szDisplayName);
                                cb = 0;
                                        
                                                hrInstallRef = CreateInstallReferenceEnum(&pInstallRefEnum, pAsmName, 0, NULL);

                                                while(hrInstallRef == S_OK)
                                                {
                                                        SAFERELEASE(pRefItem);

                                                        hrInstallRef = pInstallRefEnum->GetNextInstallReferenceItem( &pRefItem, 0, NULL);

                                                        if(hrInstallRef != S_OK)
                                                                break;

                                                        hr = pRefItem->GetReference( &pRefData, 0, NULL);

                                                        if(hr != S_OK)
                                                                break;

                                                        if (pRefData) {

                                                                _ftprintf(stdout,_T("REFERENCE: \n"));

                                                                //print GUID
                                                                if (pRefData->guidScheme == FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID) {
                                                                        _ftprintf(stdout,_T("GUID: FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID\n") );

                                                                } else if (pRefData->guidScheme == FUSION_REFCOUNT_FILEPATH_GUID) {
                                                                        _ftprintf(stdout,_T("GUID: FUSION_REFCOUNT_FILEPATH_GUID\n") );

                                                                } else if (pRefData->guidScheme == FUSION_REFCOUNT_OPAQUE_STRING_GUID) {
                                                                        _ftprintf(stdout,_T("GUID: FUSION_REFCOUNT_OPAQUE_STRING_GUID\n") );

                                                                } else if (pRefData->guidScheme == FUSION_REFCOUNT_MSI_GUID) {
                                                                        _ftprintf(stdout,_T("GUID: FUSION_REFCOUNT_MSI_GUID\n") );

                                                                } else {
                                                                        _ftprintf(stdout,_T("GUID: UNKNOWN_GUID\n") );
                                                                }

                                                                _ftprintf(stdout,_T("Identifier: %ws\n"), pRefData->szIdentifier);
                                                                _ftprintf(stdout,_T("Data: %ws\n\n"), pRefData->szNonCannonicalData);

                                                                pRefData=NULL;
                                                        }


                                                }

                                                hrInstallRef = S_OK;
                                }
                else
                {
                    _ftprintf(stderr,_T("Error in IAssemblyName::GetDisplayName (HRESULT=%X)"),hr);
                    goto exit;
                }

                delete [] szDisplayName;
                szDisplayName = NULL;
            }

            if (pAppCtx)
            {
                pAppCtx->Release();
                pAppCtx = NULL;
            }
            if (pAsmName)
            {
                pAsmName->Release();
                pAsmName = NULL;
            }
        }
        _ftprintf(stdout, _T("\n"));
    }

    _ftprintf(stdout, _T("Number of items = %d\n"),dwCount);

    if (hr == S_FALSE)
        hr = S_OK;

exit:
    if (FAILED(hr))
    {
        _ftprintf(stdout, _T("Error in Enumeration (HRESULT=%X)"),hr);
    }

        SAFERELEASE(pInstallRefEnum);
        SAFERELEASE(pRefItem);

    if (pAppCtx)
        SAFERELEASE(pAppCtx);
    if (pAsmName)
        SAFERELEASE(pAsmName);
    if (pEnum)
        SAFERELEASE(pEnum);
    if (pEnumName)
        SAFERELEASE(pEnumName);
    if (szDisplayName)
        delete [] szDisplayName;
    if (pszCodebase)
        delete [] pszCodebase;
    if (pbMVID)
        delete [] pbMVID;

    return hr;
}





DWORD ProcessEnumNameRes(int argc, LPTSTR* argv)
{
    _ftprintf(stdout, _T("Name resolution cache has been deprecated. \nUse \"storetst ea\" to enumerate GAC, download or ZAP cache.\n\n"));
    
   return S_OK;
}

  
DWORD ProcessFlushCache(int argc, LPTSTR* argv)
{
    HRESULT hr = S_OK;

    IAssemblyCache*     pCache          = NULL;
    IAssemblyScavenger* pScavenger      = NULL;
    DWORD               dwFreedInKB     = 0;

    hr = CreateAssemblyCache(&pCache, 0);

    if (FAILED(hr))
    {
            _ftprintf(stderr, _T("CreateAssemblyCache FAILED (HRESULT=%X)\n"),hr);
            goto exit;
    }

    hr = pCache->CreateAssemblyScavenger((IUnknown**)&pScavenger);

    if (FAILED(hr))
    {
            _ftprintf(stderr, _T("IAssemblyCache::CreateAssemblyScavenger FAILED (HRESULT=%X)\n"),hr);
            goto exit;
    }
    /*
    hr = pScavenger->FlushStaleEntriesFromCache(&dwFreedInKB);
    if (FAILED(hr))
    {
            _ftprintf(stderr, _T("IAssemblyScavenger::FlushStaleEntriesFromCache FAILED (HRESULT=%X)\n"),hr);
            goto exit;
    }
    */
    //Flush succeeded - print amount freed
    _ftprintf(stdout, _T("Flushed stale entries from cache -> %d Kilobytes freed\n"),dwFreedInKB);
            
exit:
    if (pCache)
            SAFERELEASE(pCache);
    if (pScavenger)
            SAFERELEASE(pScavenger);

    return hr;
}
 
HRESULT TestScavenging(DWORD HighDiskKB, DWORD LowDiskKB);

DWORD ProcessScavengeCache(int argc, LPTSTR* argv)
{
    HRESULT hr = S_OK;

    TCHAR c_szScavengeUsage[] = _T("(ScavengeCache) Usage: sc CacheDiskSpaceHighLimitInKB CacheDiskSpaceLowLimitInKB\n");
    if (argc < 2)
    {
            _ftprintf(stderr, c_szScavengeUsage);
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // hr = TestScavenging(_ttoi(argv[0]), _ttoi(argv[1]));
        
    /*
        IAssemblyCache*         pCache          = NULL;
        IAssemblyScavenger*     pScavenger      = NULL;
        DWORD                           dwFreedInKB     = 0;
        
        hr = CreateAssemblyCache(&pCache, 0);

        if (FAILED(hr))
        {
                _ftprintf(stderr, _T("CreateAssemblyCache FAILED (HRESULT=%X)\n"),hr);
                goto exit;
        }

        hr = pCache->CreateAssemblyScavenger(&pScavenger);

        if (FAILED(hr))
        {
                _ftprintf(stderr, _T("IAssemblyCache::CreateAssemblyScavenger FAILED (HRESULT=%X)\n"),hr);
                goto exit;
        }

        hr = pScavenger->ScavengePrivateCache(_ttoi(argv[0]),&dwFreedInKB);
        if (FAILED(hr))
        {
                _ftprintf(stderr, _T("IAssemblyScavenger::ScavengePrivateCache FAILED (HRESULT=%X)\n"),hr);
                goto exit;
        }

        //Flush succeeded - print amount freed
        _ftprintf(stdout, _T("Scavenged entries from cache -> %d Kilobytes freed\n"),dwFreedInKB);
                
exit:
        if (pCache)
                SAFERELEASE(pCache);
        if (pScavenger)
                SAFERELEASE(pScavenger);
    */

    _ftprintf(stderr, _T("TestScavenging returned HRESULT = %x\n"),hr);

        return hr;
}

DWORD ProcessInstallCustomAssembly(int argc, LPTSTR* argv)
{
    HRESULT hr;
    FILETIME ftLastModified;
    LPTSTR pszSrcFile = NULL, pszCustom = NULL;
    DWORD ccCustom = 0, cbCustom = 0;
    LPBYTE pbCustom = NULL;


    pszSrcFile = argv[0];
    pszCustom = argv[1];

    hr = GetFileLastModified(pszSrcFile, &ftLastModified);
    if (FAILED(hr))
        goto exit;

    ccCustom = lstrlen(pszCustom);
    cbCustom = ccCustom / sizeof(WCHAR);
    pbCustom = new BYTE[cbCustom];
    if (!pbCustom)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    UnicodeHexToBin(pszCustom, ccCustom, pbCustom);

    if (FAILED(hr = InstallCustomAssembly(pszSrcFile, pbCustom, cbCustom,  NULL)))
        goto exit;

exit:
    if (pbCustom)
        delete pbCustom;
    return hr;
}    

DWORD ProcessInstallCustomModule(int argc, LPTSTR* argv)
{
    HRESULT hr;
    IAssemblyName *pName = NULL;
    FILETIME ftLastModified;
    LPTSTR pszName = NULL, pszSrcFile = NULL;

    pszName = argv[0];
    pszSrcFile = argv[1];

    hr = GetFileLastModified(pszSrcFile, &ftLastModified);
    if (FAILED(hr))
        goto exit;

    if (FAILED(hr = CreateAssemblyNameObject(&pName, pszName, 
        CANOF_PARSE_DISPLAY_NAME, NULL)))
        goto exit;

    if (FAILED(hr = InstallCustomModule(pName, pszSrcFile)))
        goto exit;

exit:
    SAFERELEASE(pName);
    return hr;
}    


DWORD ProcessInstallAssembly(int argc, LPTSTR* argv, BOOL bForce)
{
    IAssemblyCache*                             pCache                          = NULL;
    HRESULT                                             hr                                  = S_OK;
        FUSION_INSTALL_REFERENCE*       pInstallReference       = NULL;
        DWORD                       dwFlags             = IASSEMBLYCACHE_INSTALL_FLAG_REFRESH;
        
        if (argc > 1) {
                pInstallReference       = new (FUSION_INSTALL_REFERENCE);

                if ( !pInstallReference ) {
                        _ftprintf(stderr, _T("OutOfMemory.  Could not create instance of FUSION_INSTALL_REFERENCE\n"));  
                        goto exit;
                }
        }


        if (pInstallReference) {
                pInstallReference->cbSize= sizeof(FUSION_INSTALL_REFERENCE);
                pInstallReference->dwFlags=0;


                if (!lstrcmp(L"UNINSTALL", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID;
                } else if (!lstrcmp(L"FILEPATH", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_FILEPATH_GUID;
                } else if (!lstrcmp(L"OPAQUE", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_OPAQUE_STRING_GUID;
                } else if (!lstrcmp(L"MSI", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_MSI_GUID;
                }
        else {
                        _ftprintf(stderr, _T("invalid usage : see help for more info\n"));  
                        goto exit;
                }

        if(argc >= 3) {
                pInstallReference->szIdentifier=argv[2];
        }
        else {
                        _ftprintf(stderr, _T("invalid usage : see help for more info\n"));  
                        goto exit;
                }

        if(argc >= 4) {
                pInstallReference->szNonCannonicalData=argv[3]; 
        }
        else {
                pInstallReference->szNonCannonicalData=NULL;
        }
        }

    hr = CreateAssemblyCache(&pCache, 0);
    if (FAILED(hr))
        goto exit;

    if(bForce)
    {
        dwFlags |= IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH;
    }

    hr = pCache->InstallAssembly(dwFlags, argv[0], pInstallReference);
    if (FAILED(hr))
        goto exit;

exit:
    SAFERELEASE(pCache);

    if (FAILED(hr))
    {
        _ftprintf(stderr, _T("Install Assembly failed (HRESULT = %x)\n"),hr);  
    }
    else
    {
        _ftprintf(stdout, _T("==> Installation SUCCEEDED\n"));
    }

    return hr;
}
               
DWORD ProcessFindByKey(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD DeleteByKey(DWORD Key)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessDeleteByKey(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

TCHAR   c_szUninstallDispList[6][50]={_T(""),
                                    _T("DISPOSITION_UNINSTALLED"),
                                    _T("DISPOSITION_STILL_IN_USE"),
                                    _T("DISPOSITION_ALREADY_UNINSTALLED"),
                                    _T("DISPOSITION_DELETE_PENDING"),
                                                                        _T("DISPOSITION_HAS_INSTALL_REFERENCES")};


DWORD ProcessDeleteByName(int argc, LPTSTR* argv)
{
    LPTSTR          pszName     = NULL;
    IAssemblyCache* pCache      = NULL;
    IAssemblyName*  pEnumName   = NULL;
    IAssemblyName*  pAsmName    = NULL;
    IAssemblyEnum*  pEnum       = NULL;
    HRESULT         hr          = S_OK;
    DWORD           dwCount     = 0;
    DWORD           dwFailures  = 0;
    LPWSTR          szDisplayName = NULL;
    DWORD           dwLen       = 0;
    ULONG           ulDisp      = 0;

    TCHAR   c_szDeleteByNameUsage[] = _T("(uninstall assembly) Usage: un <Assembly name in string format>\n");
        FUSION_INSTALL_REFERENCE*       pInstallReference       = NULL;
        
        
        if (argc > 1) {
                pInstallReference       = new (FUSION_INSTALL_REFERENCE);

                if ( !pInstallReference ) {
                        _ftprintf(stderr, _T("OutOfMemory.  Could not create instance of FUSION_INSTALL_REFERENCE\n"));  
                        goto exit;
                }
        }


        if (pInstallReference) {
                pInstallReference->cbSize= sizeof(FUSION_INSTALL_REFERENCE);
                pInstallReference->dwFlags=0;


                if (!lstrcmp(L"UNINSTALL", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID;
                } else if (!lstrcmp(L"FILEPATH", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_FILEPATH_GUID;
                } else if (!lstrcmp(L"OPAQUE", argv[1]) ) {
                        pInstallReference->guidScheme=FUSION_REFCOUNT_OPAQUE_STRING_GUID;
                }

                pInstallReference->szIdentifier=argv[2];
                pInstallReference->szNonCannonicalData=argv[3]; 
        }


    //Change Culture=empty in name string to Culture=""
    pszName = TranslateLocale(argv[0]);

    hr = CreateAssemblyCache(&pCache, 0);
    if (FAILED(hr))
        goto exit;

    //Name passed in may be partial, therefore enumerate matching assemblies
    //and uninstall each one. Uninstall API should be called with full name ref.

    //Create AssemblyName for enum
    if (FAILED(hr = CreateAssemblyNameObject(&pEnumName, pszName, CANOF_PARSE_DISPLAY_NAME, NULL)))
        goto exit;
    
    hr = CreateAssemblyEnum(&pEnum, 
                            NULL, 
                            pEnumName,
                            ASM_CACHE_GAC, 
                            NULL);

    SAFERELEASE(pEnumName);

    //Loop through assemblies and uninstall each one
    while (hr == S_OK)
    {
        hr = pEnum->GetNextAssembly(NULL, &pAsmName, 0);
        if (hr == S_OK)
        {
            dwLen = 0;
            hr = pAsmName->GetDisplayName(NULL, &dwLen, 0);
            if (dwLen)
            {
                szDisplayName = new WCHAR[dwLen+1];
                hr = pAsmName->GetDisplayName(szDisplayName, &dwLen, 0);
                if (SUCCEEDED(hr))
                {
               
                    hr = pCache->UninstallAssembly(0, szDisplayName, pInstallReference, &ulDisp);
                    if (SUCCEEDED(hr))
                    {
                        dwCount++;
                        _ftprintf(stdout,_T("Uninstalled: %s\n"), szDisplayName);
                        _ftprintf(stdout,_T("Disposition: %d, %s\n"), ulDisp,c_szUninstallDispList[ulDisp]);
                    }
                    else
                    {
                        dwFailures++;
                        _ftprintf(stderr,_T("\nUninstall Failed (HRESULT=%X): %ws\n"), hr, szDisplayName);
                        hr = S_OK;
                    }
                }
                else
                {
                    _ftprintf(stderr,_T("Error in IAssemblyName::GetDisplayName (HRESULT=%X)\n"),hr);
                    goto exit;
                }
                delete [] szDisplayName;
                szDisplayName = NULL;
            }

            if (pAsmName)
            {
                pAsmName->Release();
                pAsmName = NULL;
            }
        }
    }

exit:
    if (FAILED(hr))
        _ftprintf(stderr, _T("Error during uninstall (HRESULT = %x)\n"),hr);

    _ftprintf(stdout, _T("\nNumber of items uninstalled = %d\n"),dwCount);

    _ftprintf(stdout, _T("Number of failures = %d\n\n"),dwFailures);

    if (pszName)
        delete [] pszName;

    return hr;
}

DWORD ProcessGetAssemblyInstallInfo(int argc, LPTSTR* argv)
{
/*
    TCHAR   c_szGetAssemblyInstallInfoUsage[] = _T("(GetAssemblyInstallInfo) Usage: gi AssemblyNameString <InstallerType (MSI or URT)>\n");

    if (argc < 1 )
    {
        _ftprintf(stderr, c_szGetAssemblyInstallInfoUsage);
        return (ERROR_INVALID_PARAMETER);
    }

    HRESULT         hr = S_OK;
    IAssemblyName*  pName = NULL;
    IAssemblyCache* pCache = NULL;
    LPTSTR          pszName = NULL;
    DWORD           dwInstaller = INSTALLER_URT;
    DWORD           dwOutFlags = 0;
    DWORD           dwInFlags = 0;
    DWORD           dwSizeInKB = 0;
    WCHAR*          pszPath = NULL;
    DWORD           dwPath = 0;

    if (argc > 2)
    {
        if (!lstrcmpi(argv[1], INSTALLTYPE_MSI))
        {
            dwInstaller = INSTALLER_MSI;
        }
        else if (!lstrcmpi(argv[1], INSTALLTYPE_URT))
        {
            dwInstaller = INSTALLER_URT;
        }
        else
        {
            _ftprintf(stderr, _T("Unknown installer type, use MSI or URT"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    pszName = TranslateLocale(argv[0]);

    dwInFlags |= ASM_INSTALLF_COMPLETE;
    dwInFlags |= ASM_INSTALLF_VALIDATE;
    dwInFlags |= ASM_INSTALLF_GET_PIN;

    if (FAILED(hr = CreateAssemblyNameObject(&pName, pszName, CANOF_PARSE_DISPLAY_NAME, NULL)))
        goto exit;

    if (FAILED(hr = CreateAssemblyCache(&pCache, NULL)))
        goto exit;

    hr = pCache->GetAssemblyInstallInfo(pName,
                                        dwInstaller,
                                        dwInFlags,
                                        &dwOutFlags,
                                        &dwSizeInKB,
                                        NULL,
                                        &dwPath);

    if (!dwPath)
        goto exit;

    dwPath++;

    pszPath = new WCHAR[dwPath];
    hr = pCache->GetAssemblyInstallInfo(pName,
                                    dwInstaller,
                                    dwInFlags,
                                    &dwOutFlags,
                                    &dwSizeInKB,
                                    pszPath,
                                    &dwPath);

    if (FAILED(hr))
        goto exit;

    _ftprintf(stdout, _T("  AssemblyPath = %s\n"),pszPath);
    
    if (dwOutFlags)
    {
        _ftprintf(stdout, _T("  Flags: \n"));
        if (dwOutFlags & ASM_INSTALLF_COMPLETE)
            _ftprintf(stdout, _T("    ASM_INSTALLF_COMPLETE \n"));
        if (dwOutFlags & ASM_INSTALLF_VALIDATE)
            _ftprintf(stdout, _T("    ASM_INSTALLF_VALIDATE \n"));
        if (dwOutFlags & ASM_INSTALLF_GET_PIN)
            _ftprintf(stdout, _T("    ASM_INSTALLF_GET_PIN \n"));
    }
    else
        _ftprintf(stdout, _T("  Flags: NONE\n"));

    _ftprintf(stdout, _T("\n"));

exit:
    if (pszName)
        delete [] pszName;
    
    if (FAILED(hr))
        _ftprintf(stderr, _T("GetAssemblyInstallInfo failed (HRESULT = %x)"), hr);
*/
    return S_OK;
}

DWORD ProcessLockByKey(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessUnlockByKey(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}


DWORD ProcessPvtEnumAll(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessPvtEnumByAppbase(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessPvtFindByKey(int argc, LPTSTR* argv)
{
   _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD ProcessPvtDeleteByKey(int argc, LPTSTR* argv)
{
    _ftprintf(stderr, _T("Not implemented... \n"));

    return E_NOTIMPL;
}

DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPTSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;
    switch( CommandCode ) {
    case CmdFindEntry:
        Error = ProcessFindEntry(CommandArgc, CommandArgv); 
        break;
    
    case CmdInsertEntry:
        Error = ProcessInsertEntry(CommandArgc, CommandArgv);
        break;

    case CmdEnumByName:
        Error = ProcessEnumByName(CommandArgc, CommandArgv);
        break;

    case CmdDeleteEntry:
        Error = ProcessDeleteEntry(CommandArgc, CommandArgv);
        break;

    case CmdNukeDownloaded:
        Error = ProcessNukeDownloadedCache(CommandArgc, CommandArgv);
        break;

    case CmdReadCmdsFromFile:
        Error = ProcessCommandsFromFile(CommandArgc, CommandArgv);
        break;

    case CmdEnumAssemblies:
        Error = ProcessEnumAssemblies(CommandArgc, CommandArgv);
        break;

        case CmdEnumAssemblyReferences:
        Error = ProcessEnumAssemblyReferences(CommandArgc, CommandArgv);
        break;

    case CmdEnumNameRes:
        Error = ProcessEnumNameRes(CommandArgc, CommandArgv);
        break;

    case CmdInsertEntryEZ:
        Error = ProcessInsertEZ(CommandArgc, CommandArgv);
        break;

    case CmdBind:
        Error = ProcessBind(CommandArgc, CommandArgv);
        break;

    case CmdBindEZ:
        Error = ProcessBindEZ(CommandArgc, CommandArgv);
        break;

    case CmdFindEntryByKey:
        Error = ProcessFindByKey(CommandArgc, CommandArgv);
        break;

    case CmdDeleteEntryByKey:
        Error = ProcessDeleteByKey(CommandArgc, CommandArgv);
        break;

    case CmdDeleteEntryByName:
        Error = ProcessDeleteByName(CommandArgc, CommandArgv);
        break;

    case CmdGetAssemblyInstallInfo:
        Error = ProcessGetAssemblyInstallInfo(CommandArgc, CommandArgv);
        break;

    case CmdLockEntryByKey:
        Error = ProcessLockByKey(CommandArgc, CommandArgv);
        break;

    case CmdUnlockEntryByKey:
        Error = ProcessUnlockByKey(CommandArgc, CommandArgv);
        break;

    case CmdPvtEnumAll:
        Error = ProcessPvtEnumAll(CommandArgc, CommandArgv);
        break;
    case CmdPvtEnumByAppbase:
        Error = ProcessPvtEnumByAppbase(CommandArgc, CommandArgv);
        break;
    case CmdPvtFindEntryByKey:
        Error = ProcessPvtFindByKey(CommandArgc, CommandArgv);
        break;
    case CmdPvtDeleteEntryByKey:
        Error = ProcessPvtDeleteByKey(CommandArgc, CommandArgv);
        break;
    case CmdFlushCache:
        Error = ProcessFlushCache(CommandArgc, CommandArgv);
        break;
    case CmdScavengeCache:
        Error = ProcessScavengeCache(CommandArgc, CommandArgv);
        break;
    case CmdInstallAssembly:
        Error = ProcessInstallAssembly(CommandArgc, CommandArgv, FALSE);
        break;
    case CmdForceInstallAssembly:
        Error = ProcessInstallAssembly(CommandArgc, CommandArgv, TRUE);
        break;
    case CmdInstallCustomAssembly:
        Error = ProcessInstallCustomAssembly(CommandArgc, CommandArgv);
        break;
    case CmdInstallCustomModule:
        Error = ProcessInstallCustomModule(CommandArgc, CommandArgv);
        break;

    case CmdHelp:
        DisplayUsage();
        break;
    case CmdQuit:
#if FUSION_DEBUG_HEAP
        FusionpDumpHeap("");
#endif
        exit(0);

    default:
        break;

    }
    return Error;
}


VOID
ParseArguments(
    LPTSTR InBuffer,
    LPTSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPTSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr ==_T(  ' '  )) {
            CurrentPtr++;
        }

        if( *CurrentPtr ==_T(  '\0'  )) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != _T( '\0' )) &&
                (*CurrentPtr != _T( '\n' )) ) {
            if( *CurrentPtr == _T(  '"'  )) {      
                if( Cnt == 0 )
                {
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                    if (*CurrentPtr == _T( '"' ))
                        break;                  // An empty string
                }
                else
                    *CurrentPtr = _T( '\0' );     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == _T( ' ' )) ||   
                (*CurrentPtr == _T( '\0' )) )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr ==_T(  '\0'  )) {
            break;
        }

        *CurrentPtr++ = _T( '\0' );
    }

    *CArgc = i;
    return;
}


int __cdecl _tmain (
    int argc,
    TCHAR **argv
    )
{
    DWORD Error = ERROR_SUCCESS;
    COMMAND_CODE CommandCode;
    DWORD CArgc;
    LPTSTR CArgv[MAX_COMMAND_ARGS];
    DWORD  CommandArgc;
    TCHAR InBuffer[1024];
    DWORD dwLen=0;
    TCHAR szPath[MAX_PATH+1];

    LPTSTR *CommandArgv;

#if FUSION_TRACING_ENABLED
    g_FusionTraceContextTLSIndex = ::TlsAlloc();
    if (g_FusionTraceContextTLSIndex == -1)
    {
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Unable to allocate TLS index; GetLastError() = %d\n", ::GetLastError());
        goto end;
    }
#endif // FUSION_TRACING_ENABLED

    CoInitialize(NULL);
    CoGetMalloc(1, &g_pMalloc);

#ifndef USE_FUSWRAPPERS
            OnUnicodeSystem();
#endif

    dwLen = lstrlen(argv[0]);
    ASSERT(dwLen <= MAX_PATH);

    lstrcpy(szPath, argv[0]);

    while( szPath[dwLen-1] != L'\\' && dwLen > 0 )
        dwLen--;

    if(!StrNCmpI(szPath+dwLen, L"storetst", lstrlen(L"storetst")))
    {
        g_UserType = Private;
    }

    if (argc > 1)
    {
        // means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            _tprintf(_T( "Unknown Command Specified.\n" ));
            exit (1);
        }


        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

                goto end;
    }
    else
    {
        DisplayUsage();
    }

    while(1) {
#ifdef UNICODE
        _ftprintf(stderr, _T( "[UNICODE] Command : " ));
#else
        _ftprintf(stderr, _T( "[ANSI] Command : " ));
#endif
        _getts( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            _ftprintf(stderr, _T( "Unknown Command Specified.\n" ));
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }



end:
    CoUninitialize();

#if FUSION_TRACING_ENABLED
    if (g_FusionTraceContextTLSIndex != -1)
    {
        ::TlsFree(g_FusionTraceContextTLSIndex);
        g_FusionTraceContextTLSIndex = -1;
    }
#endif

    return Error;
}

DWORD CommandThread(LPVOID lpVoid)
{
    HRESULT hr = S_OK;
    LPTSTR szCmdLine = (LPTSTR) lpVoid;
    DWORD CArgc=0;
    LPTSTR CArgv[MAX_COMMAND_ARGS];
    DWORD  CommandArgc;
    LPTSTR *CommandArgv;
    COMMAND_CODE CommandCode;

    //
    // decode command.
    //
    ParseArguments( szCmdLine, CArgv, &CArgc );

    if(CArgc < 1)
        goto exit;

    CommandCode = DecodeCommand( CArgv[0] );
    if( CommandCode == UnknownCommand ) 
    {
        _ftprintf(stderr, _T( "Unknown Command Specified. <%s> \n" ), CArgv[0]);
        goto exit;
    }

    CommandArgc = CArgc - 1;
    CommandArgv = &CArgv[1];

    hr = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

exit :

    ReleaseSemaphore(g_Semaphore, 1, NULL);
    HeapFree( GetProcessHeap(), 0, lpVoid);
    ExitThread(hr);

}

DWORD ProcessInNewThread(LPTSTR szCmdLine)
{
    HRESULT hr = S_OK;
    HANDLE hThread=0;
    DWORD dwThreadId=0;
    LPTSTR  pszCmdLine=NULL;

    typedef struct {
        DWORD  CommandArgc;
        LPTSTR CArgv[MAX_COMMAND_ARGS];
        COMMAND_CODE CommandCode;
        TCHAR   szCmdLine[MAX_PATH+1];
    } COMMANDINFO, *LPCOMMANDINFO;

    pszCmdLine = (LPTSTR) HeapAlloc( GetProcessHeap(), 0, (SIZE_T) (lstrlen(szCmdLine) + 1) * sizeof(TCHAR) );

    if(pszCmdLine == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    StrCpy(pszCmdLine, szCmdLine);
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) CommandThread, (LPVOID) pszCmdLine,  0, &dwThreadId );

    if(hThread == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        HeapFree( GetProcessHeap(), 0, pszCmdLine);
    }

exit :

    return hr;
}


    /*
    HANDLE  hInFile = NULL;
#define   MaxBytes (MAX_PATH * 20)
    BYTE    pBuf[MaxBytes];
    LPTSTR  pCurrBuf=(LPTSTR)pBuf;
    DWORD   cbRead=0;
    BOOL    bNotDone=TRUE;
    LPTSTR  pszCmdLine=szCmdLine;
    CHAR   szNewLineChar[4] = {'\015', '\012', '\0', '\0'};

    hInFile = CreateFile(argv[0], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );

    if(hInFile == INVALID_HANDLE_VALUE)
    {
        _ftprintf(stderr, _T("Error <%d> opening file <%s> \n"), GetLastError(), argv[0]);
        goto exit;
    }

    while(bNotDone)
    {
        if((LPVOID)pCurrBuf >= (LPVOID)(pBuf+cbRead))
        {
            if(ReadFile(hInFile, pBuf, MaxBytes, &cbRead, NULL) && (cbRead!=0))
            {
                pCurrBuf = (LPTSTR) pBuf;
            }
            else
            {
                bNotDone = FALSE;
            }
        }

        // TCHAR ch = _T('\n'); // (*pCurrBuf) != _T('\n')
        while((StrNCmp(pCurrBuf, (LPTSTR) szNewLineChar, 1)) && ((LPVOID)pCurrBuf < (LPVOID)(pBuf+cbRead)))
        {
            *pszCmdLine = *pCurrBuf;
            pszCmdLine++;
            pCurrBuf++;
        }

        if((!StrNCmp(pCurrBuf, (LPTSTR) szNewLineChar, 1)) || (bNotDone==FALSE))
        {
            *pszCmdLine = _T('\0');
            pCurrBuf++;
            // Wait for object
            ProcessInNewThread(szCmdLine);
            // _getts( InBuffer );
            pszCmdLine = szCmdLine;
        }

    } // not done
    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\contextmenu.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

VERBMAPPING g_VerbMap[] = {
    L"Large Icons",    ID_VIEWPOPUP_LARGEICONS,
    L"Small Icons",    ID_VIEWPOPUP_SMALLICONS,
    L"List",           ID_VIEWPOPUP_LIST,
    L"Details",        ID_VIEWPOPUP_DETAILS,
    L"Properties",     ID_SHELLFOLDERPOPUP_PROPERTIES,
    L"Delete",         ID_SHELLFOLDERPOPUP_DELETE,
/*  L"explore",        IDM_EXPLORE,
    L"open",           IDM_OPEN,
    L"delete",         IDM_DELETE,
    L"rename",         IDM_RENAME,
    L"copy",           IDM_COPY,
    L"cut",            IDM_CUT,
    L"paste",          IDM_PASTE,
    L"NewFolder",      IDM_NEW_FOLDER,
    L"NewItem",        IDM_NEW_ITEM,
    L"ModifyData",     IDM_MODIFY_DATA,
    L"Open Logging Console",  IDM_LOGGING,
*/
    L"",               (DWORD)-1
    };

///////////////////////////////////////////////////////////
// IShellExtInit implementation
//
// CContextMenu::Initialize
//      Initializes a property sheet extension, context menu extension, 
//          or drag-and-drop handler. 
//      The meanings of some parameters depend on the extension type. 
//          For context menu extensions, pidlFolder specifies the folder 
//          that contains the selected file objects, lpdobj identifies the 
//          selected file objects, and hKeyProgID specifies the file class 
//          of the file object that has the focus. 
STDMETHODIMP CShellView::Initialize (LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpdobj, HKEY hKeyProgID)
{
    return NOERROR;
}

/**************************************************************************
   CContextMenu::GetCommandString()
**************************************************************************/
STDMETHODIMP CShellView::GetCommandString(UINT_PTR idCommand, UINT uFlags, 
LPUINT lpReserved, LPSTR lpszName, UINT uMaxNameLen)
{
    HRESULT  hr = E_INVALIDARG;

    switch(uFlags) {
        case GCS_HELPTEXT:
            switch(idCommand) {
                case 0:
                    hr = NOERROR;
                    break;
            }
            break;
   
        case GCS_VERBA:
        {
            int   i;
            for(i = 0; -1 != g_VerbMap[i].dwCommand; i++) {
                if(g_VerbMap[i].dwCommand == idCommand) {
                    LPSTR strVerbA = WideToAnsi(g_VerbMap[i].szVerb);

                    if(!strVerbA) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    
                    if ((UINT)(lstrlenA(strVerbA) + 1) > uMaxNameLen)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                        SAFEDELETEARRAY(strVerbA);
                        break;
                    }
                   
                    StrCpyA(lpszName, strVerbA);
                    SAFEDELETEARRAY(strVerbA);
                    hr = NOERROR;
                    break;
                }
            }
        }
        break;

        // 
        // NT 4.0 with IE 3.0x or no IE will always call this with GCS_VERBW. In this 
        // case, you need to do the lstrcpyW to the pointer passed.
        //
        case GCS_VERBW:
        {
            int   i;
            for(i = 0; -1 != g_VerbMap[i].dwCommand; i++) {
                if(g_VerbMap[i].dwCommand == idCommand) {
                    if ((UINT)(lstrlenW(g_VerbMap[i].szVerb) + 1) > uMaxNameLen)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                        break;
                    }
                    StrCpy((LPWSTR) lpszName, g_VerbMap[i].szVerb);
                    hr = NOERROR;
                    break;
                }
            }
        }
        break;

    case GCS_VALIDATE:
        hr = NOERROR;
        break;
    }

    return hr;
}

/**************************************************************************
   CContextMenu::QueryContextMenu()

   Adds menu items to the specified menu. The menu items should be inserted in the 
   menu at the position specified by uiIndexMenu, and their menu item identifiers 
   must be between the idCmdFirst and idCmdLast parameter values. 

   The actual identifier of each menu item should be idCmdFirst plus a menu identifier 
   offset in the range zero through (idCmdLast - idCmdFirst). 
**************************************************************************/
STDMETHODIMP CShellView::QueryContextMenu(HMENU hMenu, UINT uiIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int i = uiIndexMenu;
    if (m_pSF == NULL)  // RClick on our root
    {
/*      TCHAR       szText[_MAX_PATH];

        MENUITEMINFO mii = { 0 };
        mii.fMask       = MIIM_TYPE | MIIM_STATE;
        mii.fType       = MFT_SEPARATOR;
        mii.dwTypeData  = NULL;
        mii.fState      = MFS_ENABLED;
        WszInsertMenuItem(hMenu, uiIndexMenu++, TRUE, &mii);

        mii.cbSize      = sizeof(MENUITEMINFO);
        mii.fMask       = MIIM_ID | MIIM_TYPE | MIIM_STATE;
        mii.wID         = idCmdFirst + ID_ADDLOCALDRIVE;
        mii.fType       = MFT_STRING;
        LoadString(g_hFusResDllMod, IDS_ADDLOCALDRIVE, szText, sizeof(szText));
        mii.dwTypeData  = szText;
        mii.fState      = MFS_ENABLED;
        WszInsertMenuItem(hMenu, uiIndexMenu++, TRUE, &mii);

        mii.cbSize      = sizeof(MENUITEMINFO);
        mii.fMask       = MIIM_ID | MIIM_TYPE | MIIM_STATE;
        mii.wID         = idCmdFirst + ID_DELLOCALDRIVE;
        mii.fType       = MFT_STRING;
        LoadString(g_hFusResDllMod, IDS_DELLOCALDRIVE, szText, sizeof(szText));
        mii.dwTypeData  = szText;
        mii.fState      = MFS_ENABLED;
        WszInsertMenuItem(hMenu, uiIndexMenu++, TRUE, &mii);
*/
    }
    else if(m_hWndListCtrl == GetFocus()) {
        // Called from our CShellView context menu handler
        HMENU       hMenuTemp = NULL;
        HMENU       hShellViewMenu = NULL;
        int         iMenuItems = 0;
        int         iCnt = ListView_GetSelectedCount(m_hWndListCtrl);

        if( (hMenuTemp = WszLoadMenu(g_hFusResDllMod, MAKEINTRESOURCEW(IDR_SHELLVIEW_POPUP))) == NULL)
            return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));

        if( (hShellViewMenu = GetSubMenu(hMenuTemp, 0)) == NULL)
            return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));

        // iterate thro' the hEditMenu and add them to hMenu
        if( (iMenuItems = GetMenuItemCount(hShellViewMenu)) > 0) {
            int nItem = 0;

            while (nItem < iMenuItems) {
                MENUITEMINFO    mii = { 0 };
                MENUITEMINFO    miiInsert = { 0 };

                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU|MIIM_CHECKMARKS|MIIM_DATA|MIIM_ID|MIIM_STATE|MIIM_TYPE;//all

                if (WszGetMenuItemInfo(hShellViewMenu, nItem, TRUE, &mii)) {
                    if (mii.fType == MFT_STRING) {
                        TCHAR szMenuText[_MAX_PATH];
                        WszGetMenuString(hShellViewMenu, nItem, szMenuText, ARRAYSIZE(szMenuText), MF_BYPOSITION);

                        miiInsert.cbSize    = sizeof(MENUITEMINFO);
                        miiInsert.fMask     = MIIM_TYPE | MIIM_ID | MIIM_STATE | (mii.hSubMenu ? MIIM_SUBMENU : 0);
                        miiInsert.fType     = mii.fType;
                        miiInsert.fState    = MFS_ENABLED;
                        miiInsert.hSubMenu  = (mii.hSubMenu ? CreatePopupMenu() : NULL);
                        miiInsert.dwTypeData= szMenuText;
                        miiInsert.wID       = mii.wID;

                        // Special case Strong / Simple caches since those items can't be deleted
                        if(mii.wID == ID_SHELLFOLDERPOPUP_DELETE) {
                            if( (m_iCurrentView != VIEW_GLOBAL_CACHE) || (iCnt == 0) )
                                miiInsert.fState    = MFS_DISABLED;
                        }

                        // Special case view option menu if an item is selected
                        if(mii.hSubMenu != NULL) {
                            MENUITEMINFO msii = { 0 };
                            MENUITEMINFO msiiInsert = { 0 };

                            msii.cbSize = sizeof(MENUITEMINFO);
                            msii.fMask = MIIM_SUBMENU|MIIM_CHECKMARKS|MIIM_DATA|MIIM_ID|MIIM_STATE|MIIM_TYPE;//all

                            if (WszGetMenuItemInfo(mii.hSubMenu, nItem, TRUE, &msii)) {
                                if( (msii.wID == ID_VIEWPOPUP_LARGEICONS) || (msii.wID == ID_VIEWPOPUP_SMALLICONS) || 
                                    (msii.wID == ID_VIEWPOPUP_LIST) || (msii.wID == ID_VIEWPOPUP_DETAILS) ) {
                                        if(ListView_GetSelectedCount(m_hWndListCtrl)) {
                                            miiInsert.fState    = MFS_DISABLED;
                                        }
                                    }
                            }
                        }

                        // Special case Application view since no functionality exists
                        if(mii.wID == ID_SHELLFOLDERPOPUP_PROPERTIES) {
                            if(!ListView_GetSelectedCount(m_hWndListCtrl)) {
                                miiInsert.fState    = MFS_DISABLED;
                            }
                        }
                                                
                        WszInsertMenuItem(hMenu, uiIndexMenu++, FALSE, &miiInsert);
                    }
                    else if (mii.fType == MFT_SEPARATOR) {
                        WszInsertMenuItem(hMenu, uiIndexMenu++, FALSE, &mii);
                    }

                    if(mii.hSubMenu) {
                        // Item has a submenu
                        InsertSubMenus(miiInsert.hSubMenu, mii.hSubMenu);
                    }
                }
                nItem++;
            }
        }
    }
    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(i-uiIndexMenu));
}

/**************************************************************************
   CShellView::InsertSubMenus()
**************************************************************************/
void CShellView::InsertSubMenus(HMENU hParentMenu, HMENU hSubMenu)
{
    // Called from our CShellView context menu handler
    ASSERT(hParentMenu && hSubMenu);

    if(hParentMenu && hSubMenu) {
        int         iMenuItems = 0;

        // iterate thro' the hSubMenu and add them to hParentMenu
        if( (iMenuItems = GetMenuItemCount(hSubMenu)) > 0) {
            int     nItem = 0;
            BOOL    fViewMenu = FALSE;

            while (nItem < iMenuItems) {
                MENUITEMINFO mii = { 0 };
                MENUITEMINFO miiInsert = { 0 };

                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU|MIIM_CHECKMARKS|MIIM_DATA|MIIM_ID|MIIM_STATE|MIIM_TYPE;//all

                if (WszGetMenuItemInfo(hSubMenu, nItem, TRUE, &mii)) {

                    if( (mii.wID == ID_VIEWPOPUP_LARGEICONS) || (mii.wID == ID_VIEWPOPUP_SMALLICONS) || 
                        (mii.wID == ID_VIEWPOPUP_LIST) || (mii.wID == ID_VIEWPOPUP_DETAILS) )
                        fViewMenu = TRUE;

                    if (mii.fType == MFT_STRING) {
                        TCHAR szMenuText[_MAX_PATH];
                        WszGetMenuString(hSubMenu, nItem, szMenuText, ARRAYSIZE(szMenuText), MF_BYPOSITION);

                        miiInsert.cbSize    = sizeof(MENUITEMINFO);
                        miiInsert.fMask     = MIIM_TYPE | MIIM_ID | MIIM_STATE | (mii.hSubMenu ? MIIM_SUBMENU : 0);
                        miiInsert.fType     = mii.fType;
                        miiInsert.fState    = MFS_ENABLED;
                        miiInsert.hSubMenu  = (mii.hSubMenu ? CreatePopupMenu() : NULL);
                        miiInsert.dwTypeData= szMenuText;
                        miiInsert.wID       = mii.wID;

                        WszInsertMenuItem(hParentMenu, nItem, FALSE, &miiInsert);
                    }
                    else if (mii.fType == MFT_SEPARATOR) {
                        WszInsertMenuItem(hParentMenu, nItem, FALSE, &mii);
                    }

                    if(mii.hSubMenu) {
                        // Item has a submenu
                        InsertSubMenus(miiInsert.hSubMenu, mii.hSubMenu);
                    }
                }
                nItem++;
            }

            if(fViewMenu) {
                UINT        uID;

                switch(m_fsFolderSettings.ViewMode)
                {
                case FVM_ICON:
                    uID = ID_VIEWPOPUP_LARGEICONS;
                    break;
                case FVM_SMALLICON:
                    uID = ID_VIEWPOPUP_SMALLICONS;
                    break;
                case FVM_LIST:
                    uID = ID_VIEWPOPUP_LIST;
                    break;
                case FVM_DETAILS:
                    uID = ID_VIEWPOPUP_DETAILS;
                    break;
                default:
                    uID = 0;
                    break;
                }

                if(uID)
                    CheckMenuRadioItem(hParentMenu, ID_VIEWPOPUP_LARGEICONS, ID_VIEWPOPUP_DETAILS, uID, MF_BYCOMMAND);
            }
        }
    }
}

/**************************************************************************
   CContextMenu::InvokeCommand()
**************************************************************************/
STDMETHODIMP CShellView::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    LPCMINVOKECOMMANDINFOEX piciex;

    if(pici->cbSize < sizeof(CMINVOKECOMMANDINFO))
        return E_INVALIDARG;

    if(pici->cbSize >= sizeof(CMINVOKECOMMANDINFOEX) - sizeof(POINT))
        piciex = (LPCMINVOKECOMMANDINFOEX)pici;
    else
        piciex = NULL;

    if(HIWORD(pici->lpVerb)) {
        //the command is being sent via a verb
        LPCTSTR  pVerb;

        BOOL  fUnicode = FALSE;
        WCHAR szVerb[MAX_PATH];

        if(piciex && ((pici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE)) {
            fUnicode = TRUE;
        }

        if(!fUnicode || piciex->lpVerbW == NULL) {
            MultiByteToWideChar( CP_ACP, 0, pici->lpVerb, -1,szVerb, ARRAYSIZE(szVerb));
            pVerb = szVerb;
        }
        else {
            pVerb = piciex->lpVerbW;
        }

        //run through our list of verbs and get the command ID of the verb, if any
        int   i;
        for(i = 0; -1 != g_VerbMap[i].dwCommand; i++) {
            if(0 == FusionCompareStringI(pVerb, g_VerbMap[i].szVerb)) {
                pici->lpVerb = (LPCSTR)MAKEINTRESOURCEW(g_VerbMap[i].dwCommand);
                break;
            }
        }
    }

    //this will also catch if an unsupported verb was specified
    if(HIWORD((ULONG)(ULONG_PTR)pici->lpVerb) > IDM_LAST)
        return E_INVALIDARG;

    switch(LOWORD(pici->lpVerb)) {
        case ID_SHELLFOLDERPOPUP_DELETE:
            if(RemoveSelectedItems(m_hWndListCtrl)) {
            // BUGBUG: Do Refresh cause W9x inst getting the event
            // set for some reason. File FileWatch.cpp
            if( (g_hWatchFusionFilesThread == INVALID_HANDLE_VALUE) || !g_bRunningOnNT) {
                WszPostMessage(m_hWndParent, WM_COMMAND, MAKEWPARAM(ID_REFRESH_DISPLAY, 0), 0);
            }
        }
        break;

        case ID_SHELLFOLDERPOPUP_PROPERTIES:
            CreatePropDialog(m_hWndListCtrl);
            break;
        case ID_VIEWPOPUP_LARGEICONS:
            onViewStyle(LVS_ICON, m_iCurrentView);
            break;
        case ID_VIEWPOPUP_SMALLICONS:
            onViewStyle(LVS_SMALLICON, m_iCurrentView);
            break;
        case ID_VIEWPOPUP_LIST:
            onViewStyle(LVS_LIST, m_iCurrentView);
            break;
        case ID_VIEWPOPUP_DETAILS:
            onViewStyle(LVS_REPORT, m_iCurrentView);
            break;
/*
        case IDM_EXPLORE:
            DoExplore(GetParent(pici->hwnd));
            break;

        case IDM_OPEN:
            DoOpen(GetParent(pici->hwnd));
            break;

        case IDM_NEW_FOLDER:
            DoNewFolder(pici->hwnd);
            break;

        case IDM_NEW_ITEM:
            DoNewItem(pici->hwnd);
            break;

        case IDM_MODIFY_DATA:
            DoModifyData(pici->hwnd);
            break;

        case IDM_RENAME:
            DoRename(pici->hwnd);
            break;

        case IDM_PASTE:
            DoPaste();
            break;

        case IDM_CUT:
            DoCopyOrCut(pici->hwnd, TRUE);
            break;

        case IDM_COPY:
            DoCopyOrCut(pici->hwnd, FALSE);
            break;

        case IDM_DELETE:
            DoDelete();
            break;
*/
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\appcontext.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

#define PRIV_ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID    (0x00000001)
#define PRIV_ACTCTX_FLAG_LANGID_VALID                    (0x00000002)
#define PRIV_ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID        (0x00000004)
#define PRIV_ACTCTX_FLAG_RESOURCE_NAME_VALID             (0x00000008)
#define PRIV_ACTCTX_FLAG_SET_PROCESS_DEFAULT             (0x00000010)
#define PRIV_ACTCTX_FLAG_APPLICATION_NAME_VALID          (0x00000020)
#define PRIV_ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF           (0x00000040)
#define PRIV_ACTCTX_FLAG_HMODULE_VALID                   (0x00000080)

typedef struct tagPRIV_ACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} PRIV_ACTCTXA, *PPRIV_ACTCTXA;
typedef struct tagPRIV_ACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} PRIV_ACTCTXW, *PPRIV_ACTCTXW;
typedef const PRIV_ACTCTXW* PCPRIV_ACTCTXW;

class CActivationContext
{
protected:
    PRIV_ACTCTXW m_ActCtxStructure;
    HANDLE m_hActCtx; 

    HANDLE (WINAPI *m_pfnCreateActCtxW)(PCPRIV_ACTCTXW);
    VOID (WINAPI *m_pfnReleaseActCtx)(HANDLE);
    BOOL (WINAPI *m_pfnActivateActCtx)(HANDLE, ULONG_PTR*);
    BOOL (WINAPI *m_pfnDeactivateActCtx)(DWORD, ULONG_PTR);

    template<typename PFN> void FindProcAddress( PFN* ppFN, HMODULE hm, PCSTR psz )
    {
        *ppFN = reinterpret_cast<PFN>(GetProcAddress(hm, psz));
    }

public:

    BOOL Activate(ULONG_PTR *pulpCookie)
    {
        if ( m_pfnActivateActCtx && this->m_hActCtx )
            return m_pfnActivateActCtx(this->m_hActCtx, pulpCookie);
        return TRUE;
    }
    
    BOOL Deactivate(ULONG_PTR ulpCookie)
    {
        if ( m_pfnActivateActCtx && this->m_hActCtx )
            return m_pfnDeactivateActCtx(0, ulpCookie);
        return TRUE;
    }

    CActivationContext()
        : m_pfnActivateActCtx(NULL), 
          m_pfnCreateActCtxW(NULL), 
          m_pfnDeactivateActCtx(NULL), 
          m_pfnReleaseActCtx(NULL),
          m_hActCtx(NULL)
    {
    }

    ~CActivationContext()
    {
        if(m_hActCtx && m_pfnReleaseActCtx) {
            m_pfnReleaseActCtx(m_hActCtx);
            m_hActCtx = NULL;
        }
    }

    BOOL Initialize(HMODULE hmSource, UINT uiResourceIdent)
    {
        WCHAR   wszModulePath[_MAX_PATH];
        HMODULE hmK32;
        BOOL Construct;

        *wszModulePath = L'\0';
        
        // Make sure we have a module
        if(!hmSource) {
            return FALSE;
        }

        //
        // Set up the function table
        //
        if( !(hmK32 = WszGetModuleHandle(L"kernel32.dll"))) {
            return FALSE;
        }

        FindProcAddress( &m_pfnCreateActCtxW, hmK32, "CreateActCtxW" );
        FindProcAddress( &m_pfnReleaseActCtx, hmK32, "ReleaseActCtx" );
        FindProcAddress( &m_pfnActivateActCtx, hmK32, "ActivateActCtx" );
        FindProcAddress( &m_pfnDeactivateActCtx, hmK32, "DeactivateActCtx" );

        Construct = ( 
            m_pfnCreateActCtxW && 
            m_pfnReleaseActCtx && 
            m_pfnDeactivateActCtx && 
            m_pfnActivateActCtx );

        // Get the path for the instance module
        WszGetModuleFileName(hmSource, wszModulePath, ARRAYSIZE(wszModulePath));

        if(!lstrlen(wszModulePath)) {
            return FALSE;
        }

        if(Construct) {
            // Build up our activation context request structure
            ZeroMemory(&m_ActCtxStructure, sizeof(m_ActCtxStructure));

            m_ActCtxStructure.cbSize = sizeof(m_ActCtxStructure);
            m_ActCtxStructure.dwFlags = PRIV_ACTCTX_FLAG_HMODULE_VALID | PRIV_ACTCTX_FLAG_RESOURCE_NAME_VALID;
            m_ActCtxStructure.lpSource = wszModulePath;
            m_ActCtxStructure.hModule = hmSource;
            m_ActCtxStructure.lpResourceName = MAKEINTRESOURCEW(uiResourceIdent);
            m_hActCtx = m_pfnCreateActCtxW(&m_ActCtxStructure);

            if(m_hActCtx == INVALID_HANDLE_VALUE) {
                m_hActCtx = NULL;
            }

            return m_hActCtx != NULL;
        }
        else {
            //
            // We're downlevel - just return true.  Future users of this (stack-frame style)
            // will just do nothing.
            // 
            return TRUE;
        }
    }
};

class CActivationContextActivator
{
    CActivationContext &m_rTarget;
    BOOL m_fActive;
    ULONG_PTR m_ulpCookie;

    CActivationContextActivator( const CActivationContextActivator& );
    CActivationContextActivator& operator=( const CActivationContextActivator& );

public:
    CActivationContextActivator(CActivationContext& target, BOOL fActivate = TRUE) 
        : m_rTarget(target), m_fActive(FALSE)
    { 
        if ( fActivate )
            this->Activate();
    }

    ~CActivationContextActivator() {
        if ( m_fActive )
            this->Deactivate();
    }

    BOOL Activate()
    {
        if (!m_fActive) {
            m_fActive = m_rTarget.Activate(&m_ulpCookie);
        }

        return m_fActive;
    }

    BOOL Deactivate()
    {
        if(!m_fActive) {
#if DBG  
            DebugBreak();
#endif
        }
        else {
            m_rTarget.Deactivate(m_ulpCookie);
            m_fActive = FALSE;
        }

        return !m_fActive;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\dataobject.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// DataObject.h
//

#ifndef IDATAOBJ_H
#define IDATAOBJ_H

#include <windows.h>
#include <ole2.h>
#include "EnumIDL.h"

class CShellFolder;
// TODO : Add the number of formats supported
#define MAX_NUM_FORMAT 1
class CDataObject: public IDataObject, IEnumFORMATETC
{
private:
	LONG        m_lRefCount;
	ULONG		m_ulCurrent;	// for IEnumFORMATETC
	ULONG		m_cFormatsAvailable;
	FORMATETC	m_feFormatEtc[MAX_NUM_FORMAT];
	STGMEDIUM	m_smStgMedium[MAX_NUM_FORMAT];
public:
	CDataObject(CShellFolder *pSF, UINT uiCount, LPCITEMIDLIST *apidls);
	~CDataObject();

	//IUnknown members that delegate to m_pUnkOuter.
	STDMETHOD (QueryInterface)(REFIID riid, PVOID *ppvObj);
	STDMETHOD_ (ULONG, AddRef)(void);
	STDMETHOD_ (ULONG, Release)(void);

	// IDataObject methods
	STDMETHOD (GetData)(LPFORMATETC pformatetcIn,  LPSTGMEDIUM pmedium );
	STDMETHOD (GetDataHere)(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium );
	STDMETHOD (QueryGetData)(LPFORMATETC pformatetc );
	STDMETHOD (GetCanonicalFormatEtc)(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut);
	STDMETHOD (SetData)(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease);
	STDMETHOD (EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc);
	STDMETHOD (DAdvise)(FORMATETC FAR* pFormatetc, DWORD advf,
				LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
	STDMETHOD (DUnadvise)(DWORD dwConnection);
	STDMETHOD (EnumDAdvise)(LPENUMSTATDATA FAR* ppenumAdvise);

	// IEnumFORMATETC members
	STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG*);
	STDMETHODIMP Skip(ULONG);
	STDMETHODIMP Reset(void);
	STDMETHODIMP Clone(LPENUMFORMATETC*);
private:
	// TODO : add functions that render data in supported formats
private:
	CShellFolder	*m_pSF;
	UINT			m_uiItemCount;
	LPITEMIDLIST	*m_aPidls;
	CPidlMgr		*m_pPidlMgr;
private:
	HGLOBAL createHDrop();
};

#endif // IDATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\dropsource.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

#ifndef PPVOID
#define PPVOID PVOID *
#endif

#define MIIM_STRING      0x00000040

#ifdef DEBUG
  int c=0;
  CRITICAL_SECTION dbgSect;
  #define ENTER(x) LPCSTR szFunc=(x);EnterCriticalSection(&dbgSect);c++;\
                 int nSpace=c; for (;nSpace;nSpace--) OutputDebugStringA (" ");\
                 OutputDebugStringA ("ENTER:"); OutputDebugStringA ((x)); \
                 OutputDebugStringA("\n");LeaveCriticalSection (&dbgSect);

  #define LEAVE(y) EnterCriticalSection (&dbgSect);nSpace=c;c--; \
                 for (;nSpace;nSpace--) OutputDebugStringA (" "); \
                 OutputDebugStringA ("LEAVE:"); OutputDebugStringA (szFunc);\
                 OutputDebugStringA("\n");LeaveCriticalSection (&dbgSect);\
                 return (y);

  #define LEAVENONE EnterCriticalSection (&dbgSect);nSpace=c;c--; \
                 for (;nSpace;nSpace--) OutputDebugStringA (" "); \
                 OutputDebugStringA ("LEAVE:"); OutputDebugStringA (szFunc);\
                 OutputDebugStringA("\n");LeaveCriticalSection (&dbgSect);\
                 return;

#else
  #define ENTER(x)
  #define LEAVE(y) return ((y));
  #define LEAVENONE return;
#endif

//**********************************************************************
// CDropSource::CDropSource
//
// Purpose:
//      Constructor
//
// Parameters:
//      None
// Return Value:
//      None
//**********************************************************************
CDropSource::CDropSource()
{
    m_lRefCount = 1;

#ifdef DEBUG
    InitializeCriticalSection(&dbgSect);
#endif
}

//**********************************************************************
// CDropSource::~CDropSource
//
// Purpose:
//      Constructor
//
// Parameters:
//      None
// Return Value:
//      None
//**********************************************************************
CDropSource::~CDropSource()
{
#ifdef DEBUG
    DeleteCriticalSection(&dbgSect);
#endif
}

//**********************************************************************
// CDropSource::QueryInterface
//
// Purpose:
//      Return a pointer to a requested interface
//
// Parameters:
//      REFIID riid         -   ID of interface to be returned
//      PPVOID ppv          -   Location to return the interface
//
// Return Value:
//      NOERROR             -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//**********************************************************************
STDMETHODIMP CDropSource::QueryInterface(REFIID riid, PVOID *ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IDropSource)) {    //IDropSource
        *ppv = (IDropSource*) this;
    }

    if (*ppv != NULL) {
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

//**********************************************************************
// CDropSource::AddRef
//
// Purpose:
//      Increments the reference count for an interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CDropSource::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//**********************************************************************
// CDropSource::Release
//
// Purpose:
//      Decrements the reference count for the interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CDropSource::Release()
{
    LONG     lRef = InterlockedDecrement(&m_lRefCount);

    if(!lRef) {
        DELETE(this);
    }

    return lRef;
}

//**********************************************************************
// CDropSource::QueryContinueDrag
//
// Purpose:
//      Determines whether a drag-and-drop operation should be continued,
//      canceled, or completed
//
// Parameters:
//      BOOL fEsc           -   Status of escape key since previous call
//      DWORD grfKeyState   -   Current state of keyboard modifier keys
//
// Return Value:
//      DRAGDROP_S_CANCEL   -   Drag operation is to be cancelled
//      DRAGDROP_S_DROP     -   Drop operation is to be completed
//      S_OK                -   Drag operation is to be continued
//**********************************************************************
STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEsc,
                                            DWORD grfKeyState)
{
    // If escape key is pressed stop drag and drop
    if (fEsc)
    {
        return ResultFromScode(DRAGDROP_S_CANCEL);
    }

    // If LButton is up then complete the drag operation
    if (!(grfKeyState & MK_LBUTTON))
    {
        return ResultFromScode(DRAGDROP_S_DROP);
    }

    return ResultFromScode(S_OK);
}

//**********************************************************************
// CDropSource::GiveFeedback
//
// Purpose:
//      Enables a source application to give visual feedback to the end
//      user during a drag-and-drop
//
// Parameters:
//      DWORD dwEffect      -   Effect of a drop operation
//
// Return Value:
//      DRAGDROP_S_USEDEFAULTCURSORS    -   Use default cursors
//**********************************************************************
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}

#define NUMFMT 2
const UINT uFormats[NUMFMT] = {CF_TEXT, CF_UNICODETEXT};

class CMenuDataObject : public IDataObject, public IEnumFORMATETC
{
   private:
   HMENU m_hm;
   UINT m_uPos;
   int m_nFmt;
   LONG m_lRefCount;

   public:
// IUnknown methods
    STDMETHOD (QueryInterface) (REFIID riid, PVOID *ppv);
    STDMETHOD_ (DWORD, AddRef)();
    STDMETHOD_ (DWORD, Release)();

// IDataObject methods
   STDMETHOD (GetData)( FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
   STDMETHOD (GetDataHere)( FORMATETC *pformatetc, STGMEDIUM *pmedium);
   STDMETHOD (QueryGetData)(FORMATETC *pformatetc) ;
   STDMETHOD (GetCanonicalFormatEtc)( FORMATETC *pformatetcIn, FORMATETC *pformatetcOut);
   STDMETHOD (SetData)(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
   STDMETHOD (EnumFormatEtc)( DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
   STDMETHOD (DAdvise)( FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
   STDMETHOD (DUnadvise)(DWORD dwConnection);
   STDMETHOD (EnumDAdvise)(IEnumSTATDATA **ppenumAdvise);

// IEnumFORMATETC methods
   STDMETHOD (Next)( ULONG celt, FORMATETC *rgelt, ULONG *pceltFetched);

   STDMETHOD (Skip)(ULONG celt) ;

   STDMETHOD (Reset)( void);

   STDMETHOD (Clone)(IEnumFORMATETC **ppenum);

   CMenuDataObject(HMENU hm, UINT uPos);
};

//
// CMenuDataObject methods
//
STDMETHODIMP CMenuDataObject::QueryInterface (REFIID riid, PVOID *ppv)
{
   ENTER("CMenuDataObject::QueryInterface");
   *ppv = NULL;
   if (IsEqualCLSID (IID_IUnknown, riid))
   {
      InterlockedIncrement(&m_lRefCount);
      *ppv = (VOID *)(IUnknown *)(IDataObject *)this;
      LEAVE( NOERROR);
   }
   if (IsEqualCLSID (IID_IDataObject, riid))
   {
      InterlockedIncrement(&m_lRefCount);
      *ppv = (VOID *)(IDataObject *)this;
      LEAVE(NOERROR);
   }
   if (IsEqualCLSID (IID_IEnumFORMATETC, riid))
   {
      InterlockedIncrement(&m_lRefCount);
      *ppv = (VOID *)(IEnumFORMATETC *)this;
      LEAVE(NOERROR);
   }
   LEAVE(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CMenuDataObject::AddRef()
{
   ENTER("CMenuDataObject::AddRef");
   LEAVE(InterlockedIncrement(&m_lRefCount));
}

STDMETHODIMP_(ULONG) CMenuDataObject::Release()
{
   ENTER("CMenuDataObject::Release");
   LONG     lRef = InterlockedDecrement(&m_lRefCount);

   if(!lRef) {
      DELETE(this);
   }

   LEAVE(lRef);
}

//
// Our GetData only works for CF_TEXT and CF_UNICODETEXT
// It returns a handle to global memory in which the menu item's text
// is stored
STDMETHODIMP CMenuDataObject::GetData( FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
   ENTER("CMenuDataObject::GetData")
   if (! (pformatetcIn->tymed & TYMED_FILE))
   {
      LEAVE(DV_E_TYMED);
   }

   MENUITEMINFO mii;
   HANDLE hMem;
   ZeroMemory (&mii, sizeof(MENUITEMINFO));
   mii.cbSize = sizeof(MENUITEMINFO);
   mii.fMask = MIIM_STRING;
   WszGetMenuItemInfo (m_hm, m_uPos, TRUE, &mii);
   if (mii.cch)
   {
      hMem = GlobalAlloc (GMEM_MOVEABLE|GMEM_SHARE, (++mii.cch)*2); // enough space for UNICODE characters
      if (!hMem)
      {
         LEAVE(STG_E_MEDIUMFULL);
      }
      mii.dwTypeData = (LPTSTR)GlobalLock (hMem);
   }
   else
   {
      LEAVE(DV_E_FORMATETC);
   }
   WszGetMenuItemInfo(m_hm, m_uPos, TRUE, &mii);

   switch (pformatetcIn->cfFormat)
   {
      case CF_TEXT:
         {
            #ifdef UNICODE
            LPSTR szText = NEW(char[mii.cch*2]); // pad the end
            if(!szText) {
                LEAVE( E_OUTOFMEMORY );
            }
            WideCharToMultiByte (CP_ACP, 0, mii.dwTypeData, -1, szText, mii.cch*2, NULL, NULL);
            lstrcpyA ((LPSTR)mii.dwTypeData, szText);
            SAFEDELETEARRAY(szText);
            #endif
            GlobalUnlock (hMem);
            pmedium->hGlobal = hMem;
            pmedium->tymed = TYMED_FILE;
            LEAVE( S_OK);
         }
      case CF_UNICODETEXT:
         {

            #ifndef UNICODE
            LPWSTR szText = NEW(WCHAR[mii.cch+1]);
            if(!szText) {
                LEAVE( E_OUTOFMEMORY );
            }
            MultiByteToWideChar (CP_ACP, 0, mii.dwTypeData, -1, szText, mii.cch);
            lstrcpyW ((LPWSTR)mii.dwTypeData, szText);
            GlobalFree (szText);
            #endif
            GlobalUnlock (hMem);
            pmedium->hGlobal = hMem;
            pmedium->tymed = TYMED_FILE;
            LEAVE( S_OK);
         }
   }
   LEAVE( DV_E_FORMATETC);
}

STDMETHODIMP CMenuDataObject :: GetDataHere( FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
   return E_NOTIMPL;
}

STDMETHODIMP CMenuDataObject :: QueryGetData(FORMATETC *pformatetc)
{
   ENTER("CMenuDataObject::QueryGetData");
//   if(pformatetc->cfFormat != CF_TEXT && pformatetc->cfFormat != CF_UNICODETEXT || !(pformatetc->tymed & TYMED_FILE))
   if(!(pformatetc->tymed & TYMED_FILE))
   {
      LEAVE(DV_E_FORMATETC);
   }
   LEAVE( S_OK);
}

//
// Our format doesn't change based on the display device, so use the default
//
STDMETHODIMP CMenuDataObject :: GetCanonicalFormatEtc( FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
   ENTER("CMenuDataObject::GetCanonicalFormatEtc");
   CopyMemory (pformatetcIn, pformatetcOut, sizeof (FORMATETC));
   pformatetcOut = NULL;
   LEAVE(DATA_S_SAMEFORMATETC);
}

STDMETHODIMP CMenuDataObject :: SetData(FORMATETC __RPC_FAR *pformatetc, STGMEDIUM __RPC_FAR *pmedium, BOOL fRelease)
{
   return E_NOTIMPL;
}

STDMETHODIMP CMenuDataObject :: EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
   ENTER("CMenuDataObject::EnumFormatEtc");
   *ppenumFormatEtc = NULL;
   if (DATADIR_SET == dwDirection)
   {
      LEAVE(E_NOTIMPL);
   }
   *ppenumFormatEtc = (IEnumFORMATETC *)this;
   LEAVE(S_OK);
}

STDMETHODIMP CMenuDataObject :: DAdvise( FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
   return E_NOTIMPL;
}

STDMETHODIMP CMenuDataObject :: DUnadvise(DWORD dwConnection)
{
   return E_NOTIMPL;
}

STDMETHODIMP CMenuDataObject :: EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
   return E_NOTIMPL;
}

CMenuDataObject :: CMenuDataObject (HMENU hm, UINT uPos)
{
   ENTER("CMenuDataObject::CMenuDataObject");
   m_hm = hm; m_uPos = uPos; m_nFmt = 0;
   LEAVENONE
}


STDMETHODIMP CMenuDataObject :: Next( ULONG celt, FORMATETC *rgelt, ULONG *pceltFetched)
{
   ENTER("CMenuDataObject::Next");
   if (celt < 1 || m_nFmt >= NUMFMT)
   {
      LEAVE(S_FALSE);
   }
   FORMATETC *pfm;
   for (UINT i=m_nFmt;i < NUMFMT && (i-m_nFmt<celt);i++)
   {
      pfm = rgelt+(i-m_nFmt);
      pfm->cfFormat = (WORD)uFormats[i];
      pfm->ptd = NULL;
      pfm->dwAspect = DVASPECT_CONTENT;
      pfm->lindex = -1;
      pfm->tymed = TYMED_FILE;
   }
   if ((i-m_nFmt) == celt)
   {
      m_nFmt=i;
      LEAVE(S_OK);
   }
   m_nFmt = NUMFMT;
   LEAVE(S_FALSE);
}

STDMETHODIMP CMenuDataObject :: Skip(ULONG celt)
{
   ENTER("CMenuDataObject::Skip")
   m_nFmt += celt;
   if (m_nFmt > NUMFMT)
   {
      LEAVE(S_FALSE);
   }
   LEAVE(S_OK);
}

STDMETHODIMP CMenuDataObject :: Reset( void)
{
   ENTER("CMenuDataObject::Reset")
   m_nFmt = 0;
   LEAVE(S_OK);
}

STDMETHODIMP CMenuDataObject :: Clone(IEnumFORMATETC **ppenum)
{
   return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\armdlgs.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    ArmDlgs.cpp

Abstract:

    Implementation of .NET Application Restore dialogs and supporting
    functions

Author:

    Freddie L. Aaron (FredA) 02-Feb-2001

Revision History:

--*/

#include "stdinc.h"
#include "XmlDefs.h"

// Global defines
#define DLG1VIEWDATA            0
#define DLG2VIEWDATA_GOOD       1
#define MAX_SMALL_IMAGE_LIST    100

#define OPTION_HIGHBITS             0x0F0F
#define OPTION_RESTORE              0x0001
#define OPTION_SAFEMODE             0x0002
#define MAX_BUFFER_SIZE             4096

#define NAR_TEMP_POLICY_FILENAME            L"NarTmp.config"

// Publisher Policy type for WriteSnapShotBindingDataToXML
typedef enum {
    PPNone,
    PPSetYes,
    PPSetNo,
} PUBPOLICYTYPES;

// Filetime structures for snapshots
typedef struct {
    FILETIME    ftSnapShot;
    FILETIME    ftRange;
} FILETIMERANGE, *LPFILETIMERANGE;

// Externals
extern HRESULT InsertNewPolicy(HWND hParentWnd, LPBINDENTRYINFO pBindInfo, HWND hWorkingWnd);
extern HRESULT SetGlobalSafeMode(IHistoryReader *pReader);
extern HRESULT SetStartupSafeMode(IHistoryReader *pReader, BOOL fSet, BOOL *fDisposition);
extern HRESULT IsGlobalSafeModeSet(IHistoryReader *pReader, BOOL *fSafeModeSet);
extern HRESULT DoesBackupConfigExist(IHistoryReader *pReader, BOOL fOriginal, BOOL *fResult );
extern HRESULT RestorePreviousConfigFile(IHistoryReader *pReader, BOOL fOriginal);

// Proto's
INT_PTR CALLBACK Nar_Page1_DlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Nar_Page2_DlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Nar_Page3_DlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Nar_Page4_DlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Nar_Page5_DlgProc(HWND, UINT, WPARAM, LPARAM);
void PromptRestoreDialog(HWND hWndParent, LPBINDENTRYINFO pBindInfo);
void PromptSafeModeDialog(HWND hWndParent, LPBINDENTRYINFO pBindInfo);
void PromptUndoFixDialog(HWND hWndParent, LPBINDENTRYINFO pBindInfo);
HRESULT GetAppSnapShotBindingData(LPBINDENTRYINFO pBindInfo);
HRESULT WriteSnapShotBindingDataToXML(LPBINDENTRYINFO pBindInfo, PUBPOLICYTYPES ppType);

HIMAGELIST                      hImageListSmall = NULL;
static CHeaderCtrl              *pApphdrCtrl = NULL;
List<BindingReferenceInfo *>    *g_pBRIList;

CACHE_VIEWS DlgAppView[] = {
    {
        {   // Dialog 1, Application Name View
            {TEXT("\0"), 100, LVCFMT_LEFT, 0, IDS_ARM_DLG1APP_NAME},
            {TEXT("\0"), -1, LVCFMT_LEFT, 0, IDS_ARM_DLG1APP_PATH},
            {TEXT("\0"), -1, -1, -1, -1},
        }
    },
    {
        {   // Dialog 2, Application Good Version
            {TEXT("\0"), -1, LVCFMT_LEFT, 0, IDS_ARM_DLG2SNAPSHOTS},
            {TEXT("\0"), -1, -1, -1, -1},
        }
    },
    {   
        {
            {TEXT("\0"), -1, -1, -1, -1},
        }
    }
};

// **************************************************************************/
void AutoSizeLV_Column(HWND hWndLV, int iCol)
{
    if(hWndLV) {
        if(WszGetWindowLong(hWndLV, GWL_STYLE) & WS_HSCROLL) {
            int iWidth = ListView_GetColumnWidth(hWndLV, iCol);
            iWidth -= GetSystemMetrics(SM_CXVSCROLL);
            ListView_SetColumnWidth(hWndLV, iCol, iWidth);
        }
    }
}

// **************************************************************************/
void CleanOutBindingData(List<AsmBindDiffs *> *pABList)
{
    if(!pABList) {
        ASSERT(0);
        return;
    }

    // Clean out the old diff data list
    if(pABList && pABList->GetCount()) {
        LISTNODE    pListNode = pABList->GetHeadPosition();
        while(pListNode != NULL) {
            AsmBindDiffs    *pABD;
            pABD = pABList->GetAt(pListNode);
            SAFEDELETE(pABD);
            pABList->GetNext(pListNode);
        }
        pABList->RemoveAll();
    }

    return;
}

// **************************************************************************/
HRESULT PreBindingPolicyVerify(LPBINDENTRYINFO pBindInfo, BOOL fBindUsingCurrentAppCfg)
{
    PFNPREBINDASSEMBLYEX     pfnPreBindAssemblyEx = NULL;
    IApplicationContext     *pAppCtx         = NULL;
    IAssemblyName           *pAppCtxName  = NULL;
    IAssemblyName           *pAsmName = NULL;
    IAssemblyName           *pAsmNamePostPolicy = NULL;
    LISTNODE                pListNode = NULL;
    LPGLOBALASMCACHE        pAsmItem = NULL;
    AsmBindDiffs            *pABD = NULL;
    HRESULT                 hr;
    WCHAR                   wszAppName[_MAX_PATH];
    WCHAR                   wszPathAppBase[_MAX_PATH];
    WCHAR                   wzAppConfig[MAX_PATH];
    DWORD                   dwSize;

    MyTrace("PreBindingPolicyVerify - Entry");

    if(g_hFusionDllMod == NULL) {
        ASSERT(0);
        hr = E_FAIL;
        goto Exit;
    }

    pfnPreBindAssemblyEx   = (PFNPREBINDASSEMBLYEX) GetProcAddress(g_hFusionDllMod, PREBINDASSEMBLYEX_FN_NAME);
    if(!pfnPreBindAssemblyEx) {
        ASSERT(0);
        hr = E_FAIL;
        goto Exit;
    }

    if(!pBindInfo || !pBindInfo->pReader) {
        ASSERT(0);
        hr = E_INVALIDARG;
        goto Exit;
    }
 
    *wszAppName = L'\0';
    *wszPathAppBase = L'\0';
    *wzAppConfig = L'\0';

    // Get AppName
    dwSize = ARRAYSIZE(wszAppName);
    if(FAILED(hr = pBindInfo->pReader->GetApplicationName(wszAppName, &dwSize))) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Get AppPath
    dwSize = ARRAYSIZE(wszPathAppBase);
    hr = pBindInfo->pReader->GetEXEModulePath(wszPathAppBase, &dwSize);
    if(FAILED(hr)) {
        goto Exit;
    }

    // Get current app.cfg
    if(fBindUsingCurrentAppCfg) {
        if(lstrlen(wszPathAppBase) + lstrlen(CONFIG_EXTENSION) + 1 > ARRAYSIZE(wzAppConfig)) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }

        wnsprintf(wzAppConfig, ARRAYSIZE(wzAppConfig), L"%ws%ws", wszPathAppBase, CONFIG_EXTENSION);
    }

    *(PathFindFileName(wszPathAppBase)) = L'\0';
    PathRemoveBackslash(wszPathAppBase);
    PathRemoveExtension(wszAppName);

    // Construct an application context for the bind.
    if(FAILED(hr = g_pfCreateAsmNameObj(&pAppCtxName, wszAppName, CANOF_SET_DEFAULT_VALUES, NULL))) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Check our sizes
    if(!lstrlen(wszPathAppBase) || !lstrlen(pBindInfo->wszTempPolicyFile) || !lstrlen(pBindInfo->wzMachineConfigPath)) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto Exit; 
    }

    MyTrace("Checking policy - AppBase, Path to Policy File, Path to Machine.Config");
    MyTraceW(wszPathAppBase);
    if(fBindUsingCurrentAppCfg) {
        MyTraceW(wzAppConfig);
    }
    else {
        MyTraceW(pBindInfo->wszTempPolicyFile);
    }
    MyTraceW(pBindInfo->wzMachineConfigPath);

    // Create empty App context for enum
    if(FAILED(hr = g_pfCreateAppCtx(pAppCtxName, &pAppCtx))) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Set the AppBase
    pAppCtx->Set(ACTAG_APP_BASE_URL, wszPathAppBase, (lstrlen(wszPathAppBase)+1) * sizeof(WCHAR), 0);

    // Set the app.config
    if(fBindUsingCurrentAppCfg) {
        if(WszGetFileAttributes(wzAppConfig) != -1) {
            pAppCtx->Set(ACTAG_APP_CFG_LOCAL_FILEPATH, wzAppConfig, (lstrlen(wzAppConfig)+1) * sizeof(WCHAR), 0);
        }
    }
    else {
        if(WszGetFileAttributes(pBindInfo->wszTempPolicyFile) != -1) {
            pAppCtx->Set(ACTAG_APP_CFG_LOCAL_FILEPATH, pBindInfo->wszTempPolicyFile, (lstrlen(pBindInfo->wszTempPolicyFile)+1) * sizeof(WCHAR), 0);
        }
    }

    // Set the Machine.config
    pAppCtx->Set(ACTAG_MACHINE_CONFIG, pBindInfo->wzMachineConfigPath, (lstrlen(pBindInfo->wzMachineConfigPath)+1) * sizeof(WCHAR), 0);

    // Walk all the assembly bindings for this snapshot
    pListNode = pBindInfo->pABDList->GetHeadPosition();
    while(pListNode != NULL) {
        WORD        wVerMajor, wVerMinor, wVerBld, wVerRev;
        LPBYTE      lpByte;
        DWORD       dwLen;

        pABD = pBindInfo->pABDList->GetAt(pListNode);

        // Create IAssemblyName
        if(FAILED(hr = g_pfCreateAsmNameObj(&pAsmName, pABD->wzAssemblyName, 0, NULL))) {
            goto Exit;
        }

        // Set properties for this Assembly
        dwLen = lstrlen(pABD->wzPublicKeyToken) / 2;
        if( (lpByte = NEW(BYTE[dwLen])) == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        UnicodeHexToBin(pABD->wzPublicKeyToken, lstrlenW(pABD->wzPublicKeyToken), lpByte);
        pAsmName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, lpByte, dwLen);
        SAFEDELETEARRAY(lpByte);
        pAsmName->SetProperty(ASM_NAME_CULTURE, pABD->wzCulture, (lstrlen(pABD->wzCulture) + 1) * sizeof(WCHAR));

        // Fix #449328  ARM tool not reverting back publisher policy changes
        // We should be writting out the final version, not the referenced version
        VersionFromString(pABD->wzVerRef, &wVerMajor, &wVerMinor, &wVerBld, &wVerRev);
        pAsmName->SetProperty(ASM_NAME_MAJOR_VERSION, &wVerMajor, sizeof(wVerMajor));
        pAsmName->SetProperty(ASM_NAME_MINOR_VERSION, &wVerMinor, sizeof(wVerMinor));
        pAsmName->SetProperty(ASM_NAME_BUILD_NUMBER, &wVerBld, sizeof(wVerBld));
        pAsmName->SetProperty(ASM_NAME_REVISION_NUMBER, &wVerRev, sizeof(wVerRev));

        // Perform Prebind
        hr = pfnPreBindAssemblyEx(pAppCtx, pAsmName, NULL, pBindInfo->wzSnapshotRuntimeVer, &pAsmNamePostPolicy, NULL);
        if(FAILED(hr) && (hr != FUSION_E_REF_DEF_MISMATCH)) {
            goto Exit;
        }

        if(!pAsmNamePostPolicy) {
            hr = E_UNEXPECTED;
            goto Exit;
        }
        
        // Get the resulting information
        if((pAsmItem = FillFusionPropertiesStruct(pAsmNamePostPolicy)) == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Verify this assemblies version information against current policy.
        // If they match then remove them from the list.
        WORD        wAdminVerMajor, wAdminVerMinor, wAdminVerBld, wAdminVerRev;

        VersionFromString(pABD->wzVerAdminCfg, &wAdminVerMajor, &wAdminVerMinor, &wAdminVerBld, &wAdminVerRev);
        
        if( (pAsmItem->wMajorVer == wAdminVerMajor) && (pAsmItem->wMinorVer == wAdminVerMinor) &&
            (pAsmItem->wBldNum == wAdminVerBld) && (pAsmItem->wRevNum == wAdminVerRev) ) {

            // Remove the match
            LISTNODE        pTempNode = pListNode;

            pBindInfo->pABDList->GetNext(pListNode);
            pBindInfo->pABDList->RemoveAt(pTempNode);
            SAFEDELETE(pABD);
        }
        else {
            if(!fBindUsingCurrentAppCfg) {
                pABD->fYesPublisherPolicy = TRUE;
            }
            pBindInfo->pABDList->GetNext(pListNode);
        }

        SafeDeleteAssemblyItem(pAsmItem);
        SAFERELEASE(pAsmName);
        SAFERELEASE(pAsmNamePostPolicy);
    }

    hr = S_OK;

Exit:

    SAFERELEASE(pAsmName);
    SAFERELEASE(pAsmNamePostPolicy);
    SAFERELEASE(pAppCtxName);
    SAFERELEASE(pAppCtx);
    SAFERELEASE(pAsmName);

    if(FAILED(hr)) {
        MyTrace("PreBindingPolicyVerify - FAILED");
    }

    MyTrace("PreBindingPolicyVerify - Exit");
    return hr;
}

// **************************************************************************/
void InitListViewCtrl(HWND hWndListCtrl, LISTVIEWITEMS *pViewData, HIMAGELIST *hImageList)
{
    LVCOLUMN    lvc = { 0 };
    RECT        rc;
    int         i = 0;
    int         iItem = 0;
    int         iWidthUsed = 0;

    ASSERT(hWndListCtrl && pViewData);

    WszSendMessage(hWndListCtrl, WM_SETREDRAW, FALSE, 0);
    GetWindowRect(hWndListCtrl, &rc);

    // Make sure there are no colums
    HWND    hWndHeader = NULL;
    int     iColCount = 0;

    hWndHeader = ListView_GetHeader(hWndListCtrl);
    if(hWndHeader) {
        iColCount = Header_GetItemCount(hWndHeader);
    }
    
    while(iColCount) {
        ListView_DeleteColumn(hWndListCtrl, iColCount--);
    }

    lvc.mask = LVCF_TEXT | LVCF_FMT;

    while(*pViewData[iItem].tszName != NULL) {
        lvc.fmt = pViewData[iItem].iFormat;
        lvc.pszText = pViewData[iItem].tszName;
        WszListView_InsertColumn(hWndListCtrl, i, &lvc);
        if(pViewData[iItem].iWidth != -1) {
            ListView_SetColumnWidth(hWndListCtrl, i, pViewData[iItem].iWidth);
        }
        else {
            ListView_SetColumnWidth(hWndListCtrl, i, LVSCW_AUTOSIZE_USEHEADER);
        }

        i++;
        iItem++;
    }

    // Set the image list, if created
    if(hImageList) {
        ListView_SetImageList(hWndListCtrl, *hImageList, LVSIL_SMALL);
    }

    WszSendMessage(hWndListCtrl, WM_SETREDRAW, TRUE, 0);
}

// **************************************************************************/
void FreeListViewLParam(HWND hListView)
{
    int     iItemCount = WszListView_GetItemCount(hListView);
    
    for(int iLoop = 0; iLoop < iItemCount; iLoop++) {
        LV_ITEM  lvi = { 0 };
        lvi.mask        = LVIF_PARAM;
        lvi.iItem       = iLoop;
        if(WszListView_GetItem(hListView, &lvi)) {
            LPVOID      lpData = (LPVOID) lvi.lParam;
            SAFEDELETE(lpData);
        }
    }
}

// **************************************************************************/
HRESULT GetMostRecentActivationDate(IHistoryReader *pReader, FILETIME *pft, FILETIME *pftReference)
{
    HRESULT             hRC = E_FAIL;
    HRESULT             hr;
    DWORD               dwNumActivations;
    DWORD               i;
    FILETIME            ft;
    BOOL                fRefEstablished = FALSE;

    if(!pReader) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    if(!pft) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    memset(pft, 0, sizeof(FILETIME));
    memset(&ft, 0, sizeof(FILETIME));

    if(SUCCEEDED(pReader->GetNumActivations(&dwNumActivations))) {
        // Get the most recent activiation file time
        for (i = 1; i <= dwNumActivations; i++) {
            hr = pReader->GetActivationDate(i, &ft);
            if (FAILED(hr)) {
                goto Exit;
            }

            if(pftReference == NULL) {
                // Want only the most recent filetime
                if(CompareFileTime(&ft, pft) == 1) {
                    memcpy(pft, &ft, sizeof(FILETIME));
                }
            }
            else
            {
                // We want the next most recent time relative to pftReference
                if(!fRefEstablished) {
                    if(CompareFileTime(pftReference, &ft) == 1) {
                        fRefEstablished = TRUE;
                        memcpy(pft, &ft, sizeof(FILETIME));
                    }
                }
                else {
                    if(CompareFileTime(&ft, pft) == 1) {
                        memcpy(pft, &ft, sizeof(FILETIME));
                    }
                }
            }
        }

        if( (fRefEstablished) || (pftReference == NULL) ) {
            // If we didn't want a reference or we established
            // one, then all is good

            hRC = S_OK;
        }
    }

Exit:
    return hRC;
}

// **************************************************************************/
HRESULT GetManagedAppCount(LPDWORD pdwManagedAppCount)
{
    HRESULT                         hr = S_OK;
    WCHAR                           wszSearchPath[_MAX_PATH];
    WCHAR                           wszHistPath[_MAX_PATH];
    DWORD                           dwSize;
    HANDLE                          hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA                 fd;
    PFNGETHISTORYFILEDIRECTORYW     pfGetHistoryFileDirectoryW = NULL;

    if(pdwManagedAppCount) {
        *pdwManagedAppCount = 0;
    }

    if( (pdwManagedAppCount != NULL) && (g_hFusionDllMod != NULL) ) {
        pfGetHistoryFileDirectoryW = (PFNGETHISTORYFILEDIRECTORYW) GetProcAddress(g_hFusionDllMod, GETHISTORYFILEDIRECTORYW_FN_NAME);
        ASSERT(pfGetHistoryFileDirectoryW);
    }
    else {
        return E_FAIL;
    }

    if(pfGetHistoryFileDirectoryW == NULL) {
        return E_FAIL;
    }

    dwSize = ARRAYSIZE(wszHistPath);
    hr = pfGetHistoryFileDirectoryW(wszHistPath, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    wnsprintf(wszSearchPath, ARRAYSIZE(wszSearchPath), L"%ws\\*.ini", wszHistPath);

    if( (hFile = WszFindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if(pdwManagedAppCount) {
        *pdwManagedAppCount += 1;
    }

    while (WszFindNextFile(hFile, &fd)) {
        if(pdwManagedAppCount)
        *pdwManagedAppCount += 1;
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return hr;
}

// **************************************************************************/
HRESULT GetHistoryReaders(List<BindingReferenceInfo *> *pList)
{
    HRESULT                     hr = S_OK;
    WCHAR                       wszSearchPath[_MAX_PATH];
    WCHAR                       wszHistPath[_MAX_PATH];
    WCHAR                       wszFileName[_MAX_PATH];
    WCHAR                       wszAppName[_MAX_PATH];
    WCHAR                       wszAppPath[_MAX_PATH];

    DWORD                       dwSize;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA             fd;
    BindingReferenceInfo        *pBRIList;
    IHistoryReader              *pReader = NULL;
    PFNCREATEHISTORYREADERW     pfCreateHistoryReaderW = NULL;
    PFNGETHISTORYFILEDIRECTORYW pfGetHistoryFileDirectoryW = NULL;

    if( (pList != NULL) && (g_hFusionDllMod != NULL) ) {
        pfCreateHistoryReaderW = (PFNCREATEHISTORYREADERW) GetProcAddress(g_hFusionDllMod, CREATEHISTORYREADERW_FN_NAME);
        pfGetHistoryFileDirectoryW = (PFNGETHISTORYFILEDIRECTORYW) GetProcAddress(g_hFusionDllMod, GETHISTORYFILEDIRECTORYW_FN_NAME);

        ASSERT(pfCreateHistoryReaderW && pfGetHistoryFileDirectoryW);
        if(! (pfCreateHistoryReaderW && pfGetHistoryFileDirectoryW)) {
            return E_FAIL;
        }
    }
    else {
        return E_FAIL;
    }

    dwSize = ARRAYSIZE(wszHistPath);
    hr = pfGetHistoryFileDirectoryW(wszHistPath, &dwSize);
    if (FAILED(hr)) {
        goto Exit;
    }

    wnsprintf(wszSearchPath, ARRAYSIZE(wszSearchPath), L"%ws\\*.ini", wszHistPath);

    if( (hFile = WszFindFirstFile(wszSearchPath, &fd)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    wnsprintf(wszFileName, ARRAYSIZE(wszFileName), L"%ws\\%ws", wszHistPath, fd.cFileName);

    hr = pfCreateHistoryReaderW(wszFileName, &pReader);
    if (FAILED(hr)) {
        goto Exit;
    }

    dwSize = ARRAYSIZE(wszAppName);
    hr = pReader->GetApplicationName(wszAppName, &dwSize);
    if (FAILED(hr)) {
        SAFERELEASE(pReader);
        goto Exit;
    }

    dwSize = ARRAYSIZE(wszAppPath);
    hr = pReader->GetEXEModulePath(wszAppPath, &dwSize);
    if(FAILED(hr)) {
        SAFERELEASE(pReader);
        goto Exit;
    }

    if(pList != NULL) {
        pBRIList = NEW(BindingReferenceInfo);
        if (!pBRIList) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pBRIList->pReader = (LPVOID) pReader;

        if(!pList->AddTail(pBRIList)) {
            hr = E_FAIL;
            goto Exit;
        }
    }

    while (WszFindNextFile(hFile, &fd)) {

        wnsprintf(wszFileName, ARRAYSIZE(wszFileName), L"%ws\\%ws", wszHistPath, fd.cFileName);

        hr = pfCreateHistoryReaderW(wszFileName, &pReader);
        if (FAILED(hr)) {
            goto Exit;
        }

        dwSize = ARRAYSIZE(wszAppName);
        hr = pReader->GetApplicationName(wszAppName, &dwSize);
        if (FAILED(hr)) {
            SAFERELEASE(pReader);
            goto Exit;
        }

        dwSize = ARRAYSIZE(wszAppPath);
        hr = pReader->GetEXEModulePath(wszAppPath, &dwSize);
        if(FAILED(hr)) {
            SAFERELEASE(pReader);
            goto Exit;
        }

        if(pList != NULL) {
            pBRIList = NEW(BindingReferenceInfo);
            if (!pBRIList) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            pBRIList->pReader = (LPVOID) pReader;
            if(!pList->AddTail(pBRIList)) {
                hr = E_FAIL;
                goto Exit;
            }
        }
    }

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return hr;
}

// **************************************************************************/
HRESULT RefreshActivationDateListView(HWND hWndLV, LPBINDENTRYINFO pBindInfo)
{
    LPFILETIMERANGE pftArray = NULL;
    HRESULT         hr = S_OK;
    DWORD           dwNumActivations;
    int             iNumOfActivations;
    int             x;

    if(!hWndLV || !pBindInfo || !pBindInfo->pReader) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    if(FAILED(hr = pBindInfo->pReader->GetNumActivations(&dwNumActivations))) {
        return hr;
    }

    WszListView_DeleteAllItems(hWndLV);

    // Add the Restore / SafeMode entry to Options
    {
        LV_ITEM     lvi = { 0 };
        WCHAR       wszText[MAX_PATH];
        FILETIME    *pft;
        BOOL        fResult = FALSE;

        // Different versions. Insert new item into listview.
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.pszText = (LPWSTR)wszText;

        // Fix 453155 - App safe mode option present in advanced dialog box when blank app config file is present
        // No longer check for success on IsGlobalSafeModeSet since
        // a non existant app.cfg will produce a failure.
        IsGlobalSafeModeSet(pBindInfo->pReader, &fResult);
        if(!fResult) {
            if( (pft = NEW(FILETIME)) == NULL) {
                ASSERT(0);
                goto Exit;
            }

            pft->dwHighDateTime = OPTION_HIGHBITS;
            pft->dwLowDateTime = OPTION_SAFEMODE;
            lvi.lParam = (LPARAM) pft;

            *wszText = L'\0';
            WszLoadString(g_hFusResDllMod, IDS_NAR_APPLICATION_SAFEMODE, wszText, ARRAYSIZE(wszText));
            if(lstrlen(wszText)) {
                WszListView_InsertItem(hWndLV, &lvi);
            }
        }
/*
        // Fix 453285 NAR: Remove option "Restore to orignal configuration" option
        if(SUCCEEDED(DoesBackupConfigExist(pBindInfo->pReader, TRUE, &fResult)) && fResult) {
            if( (pft = NEW(FILETIME)) == NULL) {
                ASSERT(0);
                goto Exit;
            }

            pft->dwHighDateTime = OPTION_HIGHBITS;
            pft->dwLowDateTime = OPTION_RESTORE;

            lvi.lParam = (LPARAM) pft;
            *wszText = L'\0';
            WszLoadString(g_hFusResDllMod, IDS_NAR_APPLICATION_RESTORE, wszText, ARRAYSIZE(wszText));
            if(lstrlen(wszText)) {
                WszListView_InsertItem(hWndLV, &lvi);
            }
        }
*/
    }

    // Change to Zero based range
    iNumOfActivations = (int) dwNumActivations - 1;

    pftArray = NEW(FILETIMERANGE[dwNumActivations]);

    if(pftArray == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    memset(pftArray, 0, sizeof(FILETIMERANGE) * dwNumActivations);

    // Get all the activation times, also copy them into the ftRange. ftRange
    // will be used to establish the range dates to be displayed
    for (x = 1; x <= (int) dwNumActivations; x++) {
        if(FAILED(pBindInfo->pReader->GetActivationDate(x, &pftArray[x-1].ftSnapShot))) {
            hr = E_FAIL;
            goto Exit;
        }
    }

    // And now we can sort the snapshots
    x = 0;
    while(x < iNumOfActivations) {
        if(CompareFileTime(&pftArray[x].ftSnapShot, &pftArray[x+1].ftSnapShot) == 1) {
            FILETIME        ftTemp;

            memcpy(&ftTemp, &pftArray[x].ftSnapShot, sizeof(FILETIME));
            memcpy(&pftArray[x].ftSnapShot, &pftArray[x+1].ftSnapShot, sizeof(FILETIME));
            memcpy(&pftArray[x+1].ftSnapShot, &ftTemp, sizeof(FILETIME));
            x--;
            if(x < 0) {
                x = 0;
            }
        }
        else {
            x++;
        }
    }

    // Now grab x+1 ftSnapshot and place it into x ftRange
    for(x = 0; x <= iNumOfActivations-1; x++) {
        memcpy(&pftArray[x].ftRange, &pftArray[x+1].ftSnapShot, sizeof(FILETIME));
    }

    FILETIME        ftTemp;
    GetSystemTimeAsFileTime(&ftTemp);
    FileTimeToLocalFileTime(&ftTemp, &pftArray[iNumOfActivations].ftRange);

    // Insert the dates in our view
    for(x = 0; x <= iNumOfActivations; x++) {
        LV_ITEM     lvi = { 0 };
        WCHAR       wzDateBuf[STRING_BUFFER];

        *wzDateBuf = L'\0';

        // FIX #435021 - URTUI: "Fix an application" wizard shows a strange date range
        //
        // History logging writes local file time format into ini files, so we must convert these
        // to regular filetimes first before we call into FormatDateString so that the displayed
        // date and time are in local format.
        FILETIME        ftSnapShot;
        FILETIME        ftRange;

        LocalFileTimeToFileTime(&pftArray[x].ftSnapShot, &ftSnapShot);
        LocalFileTimeToFileTime(&pftArray[x].ftRange, &ftRange);

        FormatDateString(&ftSnapShot, &ftRange, FALSE, wzDateBuf, ARRAYSIZE(wzDateBuf));

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.state = 0;

        if(CompareFileTime(&pftArray[x].ftSnapShot, &pBindInfo->ftRevertToSnapShot) == 0) {
            lvi.mask |= LVIF_STATE;
            lvi.state |= LVIS_CUT;
        }

        FILETIME *pft = NEW(FILETIME);
        memcpy(pft, &pftArray[x].ftSnapShot, sizeof(FILETIME));

        lvi.pszText = (LPWSTR)wzDateBuf;
        lvi.lParam = (LPARAM)pft;
        WszListView_InsertItem(hWndLV, &lvi);
    }

Exit:
    SAFEDELETEARRAY(pftArray);

    return hr;
}

// **************************************************************************/
HRESULT GetAppSnapShotBindingData(LPBINDENTRYINFO pBindInfo)
{
    PFNLOOKUPHISTORYASSEMBLYW       pfLookupHistoryAssembly = NULL;
    IHistoryAssembly                *pHistAsm = NULL;
    AsmBindDiffs                    *pABD = NULL;
    HRESULT                         hr = S_OK;
    DWORD                           dwNumAsms = 0;
    DWORD                           i = 0;

    MyTrace("GetAppSnapShotBindingData - Entry");

    if(!pBindInfo || !pBindInfo->pABDList) {
        MyTrace("E_INVALIDARG");
        ASSERT(0);
        hr = E_INVALIDARG;
        goto Exit;
    }

    if(!g_hFusionDllMod) {
        MyTrace("g_hFusionDllMod == NULL");
        ASSERT(0);
        hr = E_FAIL;
        goto Exit;
    }

    pfLookupHistoryAssembly = (PFNLOOKUPHISTORYASSEMBLYW) GetProcAddress(g_hFusionDllMod, LOOKUPHISTORYASSEMBLY_FN_NAME);

    if(!pfLookupHistoryAssembly) {
        MyTrace("pfLookupHistoryAssembly == NULL");
        ASSERT(0);
        hr = E_FAIL;
        goto Exit;
    }

    if(FAILED(hr = pBindInfo->pReader->GetNumAssemblies(&pBindInfo->ftRevertToSnapShot, &dwNumAsms))) {
        MyTrace("pReader->GetNumAssemblies Failed");
        ASSERT(0);
        goto Exit;
    }

    for (i = 1; i <= dwNumAsms; i++) {
        DWORD           dwSize = 0;

        if(FAILED(hr = pBindInfo->pReader->GetHistoryAssembly(&pBindInfo->ftRevertToSnapShot, i, &pHistAsm))) {
            MyTrace("pReader->GetHistoryAssembly Failed");
            goto Exit;
        }

        pABD = NEW(AsmBindDiffs);
        if(!pABD) {
            MyTrace("E_OUTOFMEMORY");
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        memset(pABD, 0, sizeof(AsmBindDiffs));

        dwSize = ARRAYSIZE(pABD->wzAssemblyName);
        if(FAILED(hr = pHistAsm->GetAssemblyName(pABD->wzAssemblyName, &dwSize))) {
            MyTrace("pHistAsm->GetAssemblyName Failed");
            goto Exit;
        }

        dwSize = ARRAYSIZE(pABD->wzPublicKeyToken);
        if(FAILED(hr = pHistAsm->GetPublicKeyToken(pABD->wzPublicKeyToken, &dwSize))) {
            MyTrace("pHistAsm->GetPublicKeyToken Failed");
            goto Exit;
        }

        dwSize = ARRAYSIZE(pABD->wzCulture);
        if(FAILED(hr = pHistAsm->GetCulture(pABD->wzCulture, &dwSize))) {
            MyTrace("pHistAsm->GetCulture Failed");
            goto Exit;
        }
        else if (hr == S_OK) {
            *pABD->wzCulture = L'\0';
        }

        // Get REF version
        dwSize = ARRAYSIZE(pABD->wzVerRef);
        if(FAILED(hr = pHistAsm->GetReferenceVersion(pABD->wzVerRef, &dwSize))) {
            MyTrace("pHistAsm->GetReferenceVersion Failed");
            goto Exit;
        }

        // Get APP.CFG version
        dwSize = ARRAYSIZE(pABD->wzVerAppCfg);
        if(FAILED(hr = pHistAsm->GetAppCfgVersion(pABD->wzVerAppCfg, &dwSize))) {
            MyTrace("pHistAsm->GetReferenceVersion Failed");
            goto Exit;
        }

        // Get Publisher CFG version
        dwSize = ARRAYSIZE(pABD->wzVerPubCfg);
        if(FAILED(hr = pHistAsm->GetPublisherCfgVersion(pABD->wzVerPubCfg, &dwSize))) {
            MyTrace("pHistAsm->GetPublisherCfgVersion Failed");
            goto Exit;
        }
        
        // Get ADMIN version
        dwSize = ARRAYSIZE(pABD->wzVerAdminCfg);
        if(FAILED(hr = pHistAsm->GetAdminCfgVersion(pABD->wzVerAdminCfg, &dwSize))) {
            MyTrace("pHistAsm->GetAdminCfgVersion Failed");
            goto Exit;
        }

        if(!pBindInfo->pABDList->AddTail(pABD)) {
            hr = E_FAIL;
            goto Exit;
        }

        pABD = NULL;
    }

Exit:
    SAFEDELETE(pABD);
    SAFERELEASE(pHistAsm);

    MyTrace("GetAppSnapShotBindingData - Exit");
    return hr;
}

// **************************************************************************/
HRESULT WriteSnapShotBindingDataToXML(LPBINDENTRYINFO pBindInfo, PUBPOLICYTYPES ppType)
{
    LISTNODE    pListNode;
    LPWSTR      pwzConfigTemplate;
    HRESULT     hr = E_FAIL;
    ULONG       cbData;
    ULONG       cbBytesWritten = 0;
    DWORD       dwNumAssemblies;
    DWORD       dwSize;
    DWORD       dwBufSize;

    if(!pBindInfo || !pBindInfo->pABDList) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    pListNode = pBindInfo->pABDList->GetHeadPosition();
    if(!pListNode) {
        ASSERT(0);
        return E_UNEXPECTED;
    }

    // Get the path to the managed app
    dwSize = ARRAYSIZE(pBindInfo->wszTempPolicyFile);
    if(FAILED(hr = pBindInfo->pReader->GetEXEModulePath(pBindInfo->wszTempPolicyFile, &dwSize))) {
        ASSERT(0);
        return E_FAIL;
    }

    // Build path to temp policy file
    *(PathFindFileName(pBindInfo->wszTempPolicyFile)) = L'\0';
    StrCat(pBindInfo->wszTempPolicyFile, NAR_TEMP_POLICY_FILENAME);
    WszDeleteFile(pBindInfo->wszTempPolicyFile);

    // Make sure we have assemblies in the snapshot
    if(FAILED(pBindInfo->pReader->GetNumAssemblies(&pBindInfo->ftRevertToSnapShot, &dwNumAssemblies))) {
        ASSERT(0);
        return E_FAIL;
    }

    // Construct our working buffer
    dwBufSize = (dwNumAssemblies + 1) * MAX_BUFFER_SIZE;
    pwzConfigTemplate = NEW(WCHAR[dwBufSize]);
    if(!pwzConfigTemplate) {
        ASSERT(0);
        return E_OUTOFMEMORY;
    }

    if(lstrlen(pBindInfo->wzRuntimeRefVer)) {
        wnsprintf(pwzConfigTemplate, dwBufSize, XML_CONFIG_TEMPLATE_BEGIN_STARTUP, pBindInfo->wzRuntimeRefVer, pBindInfo->wzSnapshotRuntimeVer);
    }
    else {
        wnsprintf(pwzConfigTemplate, dwBufSize, XML_CONFIG_TEMPLATE_BEGIN, pBindInfo->wzSnapshotRuntimeVer);
    }

    while(pListNode) {
        WCHAR           wszText[_MAX_PATH];
        AsmBindDiffs    *pABD;

        pABD = pBindInfo->pABDList->GetAt(pListNode);

        StrCat(pwzConfigTemplate, XML_BEGIN_DEPENDENT_ASM);
    
        // Do Assembly ID
        wnsprintf(wszText, ARRAYSIZE(wszText), XML_ASSEMBLY_IDENT, pABD->wzAssemblyName, pABD->wzPublicKeyToken, pABD->wzCulture);
        StrCat(pwzConfigTemplate, wszText);

        // Do Redirect
        // Fix #449328 ARM tool not reverting back publisher policy changes
        // Writing out the versions backwards
        if(FusionCompareString(pABD->wzVerRef, pABD->wzVerAdminCfg)) {
            wnsprintf(wszText, ARRAYSIZE(wszText), XML_BINDING_REDIRECT, pABD->wzVerRef, pABD->wzVerAdminCfg);
            StrCat(pwzConfigTemplate, wszText);
        }

        // Do PublisherPolicy
        if(ppType == PPSetYes) {
            StrCat(pwzConfigTemplate, XML_PUBPOLICY_YES);
        }
        else if(ppType == PPSetNo) {
            StrCat(pwzConfigTemplate, XML_PUBPOLICY_NO);
        }

        StrCat(pwzConfigTemplate, XML_END_DEPENDENT_ASM);
        pBindInfo->pABDList->GetNext(pListNode);
    }

    StrCat(pwzConfigTemplate, XML_CONFIG_TEMPLATE_END);

    LPSTR   pStrData = WideToAnsi(pwzConfigTemplate);
    cbData = lstrlenA(pStrData) * ELEMENTSIZE(pStrData);

    SAFEDELETEARRAY(pwzConfigTemplate);

    CFileStreamBase fsbase(FALSE);

    if(fsbase.OpenForWrite(pBindInfo->wszTempPolicyFile)) {
        if(SUCCEEDED(fsbase.Write(pStrData, cbData, &cbBytesWritten))) {
            if(cbBytesWritten == cbData) {
                fsbase.Close();
                hr = S_OK;
            }
            else {
                hr = HRESULT_FROM_WIN32(GetLastError());
                MyTrace("WriteSnapShotBindingDataToXML failed to write correct number of bytes.");
            }
        }
        else {
            hr = HRESULT_FROM_WIN32(GetLastError());
            MyTrace("WriteSnapShotBindingDataToXML failed to write data.");
        }
    }
    else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        MyTrace("WriteSnapShotBindingDataToXML failed to open for write");
        MyTraceW(pBindInfo->wszTempPolicyFile);
    }

    SAFEDELETEARRAY(pStrData);

    if(FAILED(hr)) {
        MyTrace("WriteSnapShotBindingDataToXML - FAILED");
    }

    return hr;
}

// **************************************************************************/
void ExecuteAddRemoveProgramsApplet(void)
{
    WCHAR szFile[MAX_PATH];
    WCHAR szParam[MAX_PATH];

    SHELLEXECUTEINFOW sei = {0};

    if(WszGetSystemDirectory(szFile , ARRAYSIZE(szFile))) {
        StrCpy(szParam , TEXT( ",0" ));
        StrCpy(szFile , TEXT( "appwiz.cpl" ));

        sei.cbSize = sizeof( SHELLEXECUTEINFOW );
        sei.fMask = SEE_MASK_NOCLOSEPROCESS;
        sei.lpFile = szFile;
        sei.lpParameters = szParam;

        WszShellExecuteEx(&sei);
    }
}

// **************************************************************************/
static void CenterDialog(HWND hwndDlg)
{
    int     nScreenWidth = GetSystemMetrics(SM_CXSCREEN);
    int     nScreenHeight = GetSystemMetrics(SM_CYSCREEN);
    int     nDlgWidth = 0;
    int     nDlgHeight = 0;

    RECT rectDlg = {0, 0, 0, 0};

    GetWindowRect(hwndDlg, &rectDlg);
    nDlgWidth = (rectDlg.right - rectDlg.left);
    nDlgHeight = (rectDlg.bottom - rectDlg.top);

    MoveWindow(hwndDlg, (int)((nScreenWidth - nDlgWidth) / 2), 
        (int)((nScreenHeight - nDlgHeight) / 2), nDlgWidth, nDlgHeight, FALSE);
}

// **************************************************************************/
INT_PTR CALLBACK WorkingDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        WszAnimate_Open( GetDlgItem(hDlg, IDC_NAR_ANI_SRCH), MAKEINTRESOURCEW( IDA_FINDCOMP ) );
        WszAnimate_Play( GetDlgItem(hDlg, IDC_NAR_ANI_SRCH), 0, -1, -1 );

        SetForegroundWindow(hDlg);
        CenterDialog( hDlg );

        ShowWindow(hDlg, SW_SHOW);
        SetWindowPos(hDlg, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        break;

    case WM_DESTROY:
        WszAnimate_Close(GetDlgItem(hDlg, IDC_NAR_ANI_SRCH));
        break;

    default:
        return FALSE;

    }

    return TRUE;
}

// **************************************************************************/
HRESULT GetAssociatedReader(LPWSTR pwzFullyQualifiedAppPath, LPWSTR pwzAppName, LPBINDENTRYINFO pBindInfo)
{
    LISTNODE    pListNode = NULL;
    HRESULT     hr = E_FAIL;

    // Fill in the assembly application names
    pListNode = g_pBRIList->GetHeadPosition();
    while(pListNode != NULL) {
        BindingReferenceInfo *pBRI = NULL;
        IHistoryReader       *pReader = NULL;

        WCHAR       wszAppName[MAX_PATH];
        WCHAR       wszAppPath[_MAX_PATH];
        DWORD       dwSize;

        pBRI = g_pBRIList->GetAt(pListNode);
        pReader = (IHistoryReader*) pBRI->pReader;

        dwSize = ARRAYSIZE(wszAppName);
        if(SUCCEEDED(pReader->GetApplicationName(wszAppName, &dwSize))) {
            dwSize = ARRAYSIZE(wszAppPath);
            if(SUCCEEDED(pReader->GetEXEModulePath(wszAppPath, &dwSize))) {
                if(!FusionCompareStringI(pwzAppName, wszAppName)) {
                    if(!FusionCompareStringAsFilePath(pwzFullyQualifiedAppPath, wszAppPath)) {
                        pBindInfo->pReader = pReader;
                        hr = S_OK;
                        break;
                    }
                }
            }
        }

        g_pBRIList->GetNext(pListNode);
    }

    return hr;
}

// lParam1 -> lParam list item x
// lParam2 -> lParam list item y
// lpData -> HiWord = m_iCurrentView,  LoWord =   iColumn
// **************************************************************************/
int CALLBACK SortCompareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lpData)
{
    IHistoryReader  *pItem1Reader = (IHistoryReader *) lParam1;
    IHistoryReader  *pItem2Reader = (IHistoryReader *) lParam2;
    BOOL            fSortAcending = (BOOL) HIWORD(lpData);
    int             iLastColSorted = (int)  LOWORD(lpData);
    int             diff = 0;

    // Compare the items for the right views
    switch(iLastColSorted)
    {
    case 0:
        {
            WCHAR       wszAppName1[MAX_PATH];
            WCHAR       wszAppName2[MAX_PATH];
            DWORD       dwSize;

            diff = 0;

            dwSize = ARRAYSIZE(wszAppName1);
            if(FAILED(pItem1Reader->GetApplicationName(wszAppName1, &dwSize))) {
                break;
            }

            dwSize = ARRAYSIZE(wszAppName2);
            if(FAILED(pItem2Reader->GetApplicationName(wszAppName2, &dwSize))) {
                break;
            }
            diff = FusionCompareStringI(wszAppName1, wszAppName2);
        }
        break;
    case 1:
        {
            WCHAR       wszAppPath1[_MAX_PATH];
            WCHAR       wszAppPath2[_MAX_PATH];
            DWORD       dwSize;

            diff = 0;

            dwSize = ARRAYSIZE(wszAppPath1);
            if(FAILED(pItem1Reader->GetApplicationName(wszAppPath1, &dwSize))) {
                break;
            }

            dwSize = ARRAYSIZE(wszAppPath2);
            if(FAILED(pItem2Reader->GetApplicationName(wszAppPath2, &dwSize))) {
                break;
            }

            diff = FusionCompareStringAsFilePath(wszAppPath1, wszAppPath2);
        }
        break;
    default:
        {
            //
            // If you hit this, you need to update this function
            // to handle the new column you've added to the listview.
            //
            ASSERT(FALSE);
            break;
        }
    }

    return fSortAcending ? diff : -(diff);
}

//
// LVN_COLUMNCLICK handler.
//
// **************************************************************************/
LRESULT OnLVN_ColumnClick(LPNMLISTVIEW pnmlv)
{
    static int      iLastColSorted = 0;
    static BOOL     bSortAscending = TRUE;

    // Only sort on headers
    if(pnmlv->iItem == -1) {
        if (iLastColSorted != pnmlv->iSubItem) {
            iLastColSorted = pnmlv->iSubItem;
            bSortAscending = TRUE;
        }
        else {
            bSortAscending = !bSortAscending;
        }

        if(pApphdrCtrl) {
            pApphdrCtrl->SetColumnHeaderBmp(pnmlv->iSubItem, bSortAscending);
        }

        WszListView_SortItems(pnmlv->hdr.hwndFrom, SortCompareItems, MAKELPARAM(iLastColSorted, bSortAscending));
    }
    return 0;
}

// **************************************************************************/
BOOL SelectActivationDate(HWND hWndLV, FILETIME *pft)
{
    int     iItemCount = WszListView_GetItemCount(hWndLV);
    int     iCurrentItem = 0;
    BOOL    fItemSet = FALSE;

    ASSERT(hWndLV && pft);
    if(hWndLV && pft) {
        while(iCurrentItem < iItemCount) {
            LV_ITEM  lvi = { 0 };

            lvi.mask = LVIF_PARAM;
            lvi.iItem = iCurrentItem;

            if(WszListView_GetItem(hWndLV, &lvi)) {
                FILETIME        *pftItem = (FILETIME*) lvi.lParam;

                if(CompareFileTime(pft, pftItem) == 0) {
                    WszListView_SetItemState(hWndLV, iCurrentItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                    fItemSet = TRUE;
                    break;
                }
            }

            iCurrentItem++;
        }
    }

    return fItemSet;
}

// **************************************************************************/
void InitNarPage1Dlg(HWND hDlg, LPARAM lParam)
{
    LISTNODE    pListNode = NULL;
    WCHAR       wszIntro[1024];
    HWND        hListCtrl = NULL;
    HICON       hIcon = NULL;
    HIMAGELIST  hImgListSmall;

    ASSERT(lParam);
    WszSetWindowLong(hDlg, DWLP_USER, lParam);

    ShowWindow(hDlg, SW_HIDE);

    hListCtrl = GetDlgItem(hDlg, IDC_LV_NAR_PAGE1_APPS);
    ListView_SetExtendedListViewStyleEx(hListCtrl, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    if(!pApphdrCtrl) {
        pApphdrCtrl = NEW(CHeaderCtrl());
        if(pApphdrCtrl) {
            pApphdrCtrl->AttachToHwnd(hListCtrl);
        }
    }

    // Create the small image list
    int nSmallCx = GetSystemMetrics(SM_CXSMICON);
    int nSmallCy = GetSystemMetrics(SM_CYSMICON);
    hImgListSmall = ImageList_Create(nSmallCx, nSmallCy, ILC_COLORDDB | ILC_MASK, 0, MAX_SMALL_IMAGE_LIST);
    InitListViewCtrl(hListCtrl, DlgAppView[DLG1VIEWDATA].lvis, &hImgListSmall);

    hIcon = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ARM));
    if(hIcon) {
        WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    WszLoadString(g_hFusResDllMod, IDS_ARM_INTRO1, wszIntro, ARRAYSIZE(wszIntro));
    WszSetDlgItemText(hDlg, IDC_NAR_INTRO_STR, wszIntro);

    // Fill in the assembly application names
    pListNode = g_pBRIList->GetHeadPosition();
    while(pListNode != NULL) {
        BindingReferenceInfo *pBRI = NULL;
        IHistoryReader       *pReader = NULL;

        WCHAR       wszAppName[MAX_PATH];
        WCHAR       wszAppPath[_MAX_PATH];
        DWORD       dwSize;
        HRESULT     hr = S_OK;

        pBRI = g_pBRIList->GetAt(pListNode);
        pReader = (IHistoryReader*) pBRI->pReader;

        dwSize = ARRAYSIZE(wszAppName);
        hr = pReader->GetApplicationName(wszAppName, &dwSize);

        dwSize = ARRAYSIZE(wszAppPath);
        hr = pReader->GetEXEModulePath(wszAppPath, &dwSize);
        if(FAILED(hr)) {
            SAFERELEASE(pReader);
        }
        else
        {
            LV_ITEM  lvi = { 0 };

            lvi.mask    = LVIF_TEXT | LVIF_PARAM;
            lvi.iItem   = 0;
            lvi.lParam  = (LPARAM) pReader;
            lvi.pszText = wszAppName;
            lvi.iImage  = 0;

            // Get the app image.
            if(hImgListSmall != NULL) {
                HICON       hSmallIcon = NULL;
                SHFILEINFO  psfi;

                // BUGBUG: Need to make platform independent
                if(MySHGetFileInfoWrap(wszAppPath, SHGFI_ICON , &psfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON)) {
                    lvi.iImage = ImageList_AddIcon(hImgListSmall, psfi.hIcon);
                    lvi.mask |= LVIF_IMAGE;
                }
            }

            // Insert the App Name
            lvi.iItem = WszListView_InsertItem(hListCtrl, &lvi);

            // Set the App path
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 1;
            lvi.pszText = wszAppPath;
            WszListView_SetItem(hListCtrl, &lvi);
        }

        g_pBRIList->GetNext(pListNode);
    }

    AutoSizeLV_Column(hListCtrl, 1);

    WszListView_SortItems(hListCtrl, SortCompareItems, MAKELPARAM(0, TRUE));

    if(pApphdrCtrl) {
        pApphdrCtrl->SetColumnHeaderBmp(0, TRUE);
    }

    // Select the first item in the list
    if(WszListView_GetItemCount(hListCtrl) != 0) {
        SetFocus(hListCtrl);
        WszListView_SetItemState(hListCtrl, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    CenterDialog(hDlg);
    SetForegroundWindow(hDlg);
    ShowWindow(hDlg, SW_SHOW);
}

// **************************************************************************/
INT_PTR CALLBACK Nar_Page1_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPBINDENTRYINFO     pBindInfo = (LPBINDENTRYINFO) WszGetWindowLong(hDlg, DWLP_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitNarPage1Dlg(hDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmh = (LPNMHDR)lParam;

            switch(lpnmh->code)
            {
            case NM_DBLCLK:
                if(ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_LV_NAR_PAGE1_APPS))) {
                    WszPostMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDOK, 0), 0);
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    if(wParam == IDC_LV_NAR_PAGE1_APPS) {
                        LV_ITEM     lvi = { 0 };
                        BOOL        fItemSelected = FALSE;

                        lvi.mask = LVIF_STATE;
                        lvi.stateMask = LVIS_SELECTED;

                        while(1) {
                            if(!WszListView_GetItem(lpnmh->hwndFrom, &lvi))
                                break;

                            if(lvi.state & LVIS_SELECTED) {
                                fItemSelected = TRUE;
                                break;
                            }

                            lvi.iItem++;
                        }

                        EnableWindow(GetDlgItem(hDlg, IDOK), fItemSelected);
                    }
                }
                break;

            case LVN_COLUMNCLICK:
                OnLVN_ColumnClick( (LPNMLISTVIEW) lpnmh);
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam)) 
        {
            case IDCANCEL:
                pBindInfo->iResultCode = NAR_E_USER_CANCELED;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;
            case IDOK:
                {
                    LV_ITEM     lvi = { 0 };
                    HWND        hListCtrl = NULL;
                    INT_PTR     iResult = 0;
                    int         iItemCount, iCurrentItem;

                    iCurrentItem = 0;
                    hListCtrl = GetDlgItem(hDlg, IDC_LV_NAR_PAGE1_APPS);
                    iItemCount = WszListView_GetItemCount(hListCtrl);

                    lvi.mask = LVIF_STATE | LVIF_PARAM;
                    lvi.stateMask = LVIS_SELECTED;

                    for(;iItemCount > 0; iItemCount--, lvi.iItem++) {
                        WszListView_GetItem(hListCtrl, &lvi);

                        if(lvi.state & LVIS_SELECTED) {
                            pBindInfo->pReader = (IHistoryReader*) lvi.lParam;
                            pBindInfo->iResultCode = NAR_E_SUCCESS;
                            break;
                        }
                    }

                    // If there wasn't a selection, default to canceled
                    if(!pBindInfo->pReader) {
                        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
                    }

                    EndDialog(hDlg, pBindInfo->iResultCode);
                }
                break;
        }
        break;
    case WM_CLOSE:
        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
        EndDialog(hDlg, pBindInfo->iResultCode);
        break;
    case WM_DESTROY:
        {
            HICON hIcon = (HICON) WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_GETICON, 0, 0);
            if (hIcon != NULL)
                DestroyIcon(hIcon);

            if(hImageListSmall) {
                ImageList_Destroy(hImageListSmall);
            }

            if(pApphdrCtrl) {
                SAFEDELETE(pApphdrCtrl);
            }
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// **************************************************************************/
void InitNarPage2Dlg(HWND hDlg, LPARAM lParam)
{
    LPBINDENTRYINFO         pBindInfo = (LPBINDENTRYINFO) lParam;
    WCHAR       wszAppName[_MAX_PATH];
    WCHAR       wszDisplay[1024];
    DWORD       dwSize = ARRAYSIZE(wszAppName);
    HICON       hIcon = NULL;

    if(!pBindInfo) {
        ASSERT(0);
        return;
    }

    *wszAppName = '\0';

    ShowWindow(hDlg, SW_HIDE);
    WszSetWindowLong(hDlg, DWLP_USER, lParam);

    // Set the icon
    hIcon = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ARM));
    if(hIcon) {
        WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    WszLoadString(g_hFusResDllMod, IDS_NAR_INTRO2, wszDisplay, ARRAYSIZE(wszDisplay));
    WszSetDlgItemText(hDlg, IDC_NAR_INTRO_STR, wszDisplay);

    pBindInfo->pReader->GetApplicationName(wszAppName, &dwSize);

    CenterDialog(hDlg);
    EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
    SetForegroundWindow(hDlg);
    ShowWindow(hDlg, SW_SHOW);
}

// **************************************************************************/
INT_PTR CALLBACK Nar_Page2_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPBINDENTRYINFO         pBindInfo = (LPBINDENTRYINFO) WszGetWindowLong(hDlg, DWLP_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitNarPage2Dlg(hDlg, lParam);
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam)) 
        {
            case IDYES:
                pBindInfo->iResultCode = NAR_E_UNDO_APP;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;
            case IDNO:
                pBindInfo->iResultCode = NAR_E_FIX_APP;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;
            case IDCANCEL:
                pBindInfo->iResultCode = NAR_E_USER_CANCELED;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;
        }
        break;
    case WM_CLOSE:
        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
        EndDialog(hDlg, pBindInfo->iResultCode);
        break;
    case WM_DESTROY:
        {
            HICON hIcon = (HICON)WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_GETICON, 0, 0);
            if (hIcon != NULL)
                DestroyIcon(hIcon);

            if(hImageListSmall) {
                ImageList_Destroy(hImageListSmall);
            }
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// **************************************************************************/
void InitNarPage3Dlg(HWND hDlg, LPARAM lParam)
{
    LPBINDENTRYINFO pBindInfo = (LPBINDENTRYINFO) lParam;
    WCHAR           wszIntro[1024];
    WCHAR           wszFmt[1024];
    WCHAR           wszAppName[MAX_PATH];
    WCHAR           wszDateBuf[MAX_DATE_LEN];
    DWORD           dwSize;
    HICON           hIcon = NULL;

    ASSERT(pBindInfo);

    ShowWindow(hDlg, SW_HIDE);

    // Set icon
    hIcon = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ARM));
    if(hIcon) {
        WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    // Get most recent activation date
    GetMostRecentActivationDate(pBindInfo->pReader, &pBindInfo->ftMostRecentSnapShot, NULL);

    // Get n-1 activation date, we shouldn't fail here
    if(FAILED(GetMostRecentActivationDate(pBindInfo->pReader, &pBindInfo->ftRevertToSnapShot, &pBindInfo->ftMostRecentSnapShot))) {
        EndDialog(hDlg, NAR_E_UNEXPECTED);
        return;
    }

    // Format and display info string
    WszLoadString(g_hFusResDllMod, IDS_NAR_RESTOREINFO, wszFmt, ARRAYSIZE(wszFmt));

    dwSize = ARRAYSIZE(wszAppName);
    pBindInfo->pReader->GetApplicationName(wszAppName, &dwSize);

    // FIX #435021 - URTUI: "Fix an application" wizard shows a strange date range
    //
    // History logging writes local file time format into ini files, so we must convert these
    // to regular filetimes first before we call into FormatDateString so that the displayed
    // date and time are in local format.
    FILETIME        ftSnapShot;

    LocalFileTimeToFileTime(&pBindInfo->ftRevertToSnapShot, &ftSnapShot);
    FormatDateString(&ftSnapShot, NULL, FALSE, wszDateBuf, ARRAYSIZE(wszDateBuf));

    wnsprintf(wszIntro, ARRAYSIZE(wszIntro), wszFmt, wszAppName, wszDateBuf);
    WszSetDlgItemText(hDlg, IDC_NAR_INTRO_STR, wszIntro);

    WszSetWindowLong(hDlg, DWLP_USER, (LPARAM) pBindInfo);

    EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
    SetForegroundWindow(hDlg);
    CenterDialog(hDlg);
    ShowWindow(hDlg, SW_SHOW);
}

// **************************************************************************/
INT_PTR CALLBACK Nar_Page3_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPBINDENTRYINFO pBindInfo = (LPBINDENTRYINFO) WszGetWindowLong(hDlg, DWLP_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitNarPage3Dlg(hDlg, lParam);
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam)) 
        {
            case IDCANCEL:
                pBindInfo->iResultCode = NAR_E_USER_CANCELED;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;
            case IDOK:
                pBindInfo->iResultCode = NAR_E_FIX_APP;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;
            case IDC_NAR_PAGE3_ADVANCED:
                // User wants Advanced Mode
                pBindInfo->iResultCode = 
                    WszDialogBoxParam(g_hFusResDllMod, 
                        g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_PAGE4_BIDI) : MAKEINTRESOURCEW(IDD_NAR_PAGE4),
                        hDlg, Nar_Page4_DlgProc, (LPARAM) pBindInfo);
                if( (pBindInfo->iResultCode == NAR_E_FIX_APP) || (pBindInfo->iResultCode == NAR_E_SUCCESS) ) {
                    EndDialog(hDlg, pBindInfo->iResultCode);
                }
                break;
        }
        break;
    case WM_CLOSE:
        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
        EndDialog(hDlg, pBindInfo->iResultCode);
        break;
    case WM_DESTROY:
        {
            HICON       hIcon = (HICON)WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_GETICON, 0, 0);
            if(hIcon) {
                DestroyIcon(hIcon);
            }
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// **************************************************************************/
void InitNarPage4Dlg(HWND hDlg, LPARAM lParam)
{
    LPBINDENTRYINFO     pBindInfo = (LPBINDENTRYINFO) lParam;
    LISTNODE            pListNode = NULL;
    HWND                hListCtrl = NULL;
    HICON               hIcon = NULL;
    HIMAGELIST          hSmImageListDate;
    WCHAR               wszStr[_MAX_PATH * 2];
    HWND                hWndLV = GetDlgItem(hDlg, IDC_NAR_PAGE4_LV_SNAPSHOTS);

    WszSetWindowLong(hDlg, DWLP_USER, lParam);
    ASSERT(pBindInfo);

    ShowWindow(hDlg, SW_HIDE);
    WszSetWindowLong(hDlg, DWLP_USER, lParam);

    ListView_SetExtendedListViewStyleEx(hWndLV, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    int nSmallCx = GetSystemMetrics(SM_CXSMICON);
    int nSmallCy = GetSystemMetrics(SM_CYSMICON);

    // Create the listview image list
    if( (hSmImageListDate = ImageList_Create(nSmallCx, nSmallCy, ILC_COLORDDB | ILC_MASK, 1, 0)) != NULL) {
        HICON hIco;

        hIco = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_DATE), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIco) {
            ImageList_AddIcon(hSmImageListDate, hIco);
        }
    }

    InitListViewCtrl(hWndLV, DlgAppView[DLG2VIEWDATA_GOOD].lvis, &hSmImageListDate);

    // Add previous config dates
    RefreshActivationDateListView(hWndLV, pBindInfo);
    if(!SelectActivationDate(hWndLV, &pBindInfo->ftRevertToSnapShot)) {
        // Didn't select an revert snapshot, so select the first item in the list
        if(WszListView_GetItemCount(hWndLV) != 0) {
            SetFocus(hWndLV);
            WszListView_SetItemState(hWndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        }
    }
    
    AutoSizeLV_Column(hWndLV, 0);

/*
    int nSmallCx = GetSystemMetrics(SM_CXSMICON);
    int nSmallCy = GetSystemMetrics(SM_CYSMICON);

    // Create the listview image list
    if( (hSmImageListDate = ImageList_Create(nSmallCx, nSmallCy, ILC_COLORDDB | ILC_MASK, 1, 0)) != NULL)
    {
        HICON hIcon;
        SHFILEINFO  psfi;

        // BUGBUG: Need to make platform independent
        if(MySHGetFileInfoWrap(wszAppPath, SHGFI_ICON , &psfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON)) {
            lvi.iImage = ImageList_AddIcon(hImageListSmall, psfi.hIcon);
            lvi.mask |= LVIF_IMAGE;

            ImageList_AddIcon(hSmImageListDate, psfi.hIcon);
        }
    }
*/

    hIcon = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ARM));
    if(hIcon) {
        WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    WszLoadString(g_hFusResDllMod, IDS_NAR_ADVANCED, wszStr, ARRAYSIZE(wszStr));
    WszSetDlgItemText(hDlg, IDC_NAR_INTRO_STR, wszStr);

    EnableWindow(GetDlgItem(hDlg, IDC_NAR_PAGE4_APPLY), TRUE);

    CenterDialog(hDlg);
    SetForegroundWindow(hDlg);
    ShowWindow(hDlg, SW_SHOW);
}

// **************************************************************************/
INT_PTR CALLBACK Nar_Page4_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPBINDENTRYINFO     pBindInfo = (LPBINDENTRYINFO) WszGetWindowLong(hDlg, DWLP_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitNarPage4Dlg(hDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmh = (LPNMHDR)lParam;

            switch(lpnmh->code)
            {
            case NM_DBLCLK:
                if(ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_NAR_PAGE4_LV_SNAPSHOTS))) {
                    WszPostMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_NAR_PAGE4_APPLY, 0), 0);
                }
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam)) 
        {
            case IDCANCEL:
                pBindInfo->iResultCode = NAR_E_USER_CANCELED;
                EndDialog(hDlg, pBindInfo->iResultCode);
                break;

            case IDC_NAR_PAGE4_APPLY:
                {
                    LV_ITEM     lvi = { 0 };
                    HWND        hWndLV = GetDlgItem(hDlg, IDC_NAR_PAGE4_LV_SNAPSHOTS);

                    lvi.mask = LVIF_STATE | LVIF_PARAM;
                    lvi.stateMask = LVIS_SELECTED;

                    while(1) {
                        if(!WszListView_GetItem(hWndLV, &lvi)) {
                            pBindInfo->iResultCode = NAR_E_USER_CANCELED;
                            break;
                        }

                        if(lvi.state & LVIS_SELECTED) {
                            FILETIME    *pft = (FILETIME *) lvi.lParam;

                            if(lvi.lParam == NULL) {
                                ASSERT(0);
                                pBindInfo->iResultCode = NAR_E_UNEXPECTED;
                                EndDialog(hDlg, pBindInfo->iResultCode);
                                break;
                            }

                            if(pft->dwHighDateTime == OPTION_HIGHBITS) {

                                // Special code marker for our ListView Options
                                if(pft->dwLowDateTime == OPTION_RESTORE) {
                                    PromptRestoreDialog(hDlg, pBindInfo);
                                    if(pBindInfo->iResultCode == NAR_E_SUCCESS) {
                                        EndDialog(hDlg, pBindInfo->iResultCode);
                                    }
                                }
                                else if(pft->dwLowDateTime == OPTION_SAFEMODE) {
                                    PromptSafeModeDialog(hDlg, pBindInfo);
                                    if(pBindInfo->iResultCode == NAR_E_SUCCESS) {
                                        EndDialog(hDlg, pBindInfo->iResultCode);
                                    }
                                }
                                else {
                                    // Unknown code
                                    ASSERT(0);
                                }
                            }
                            else {
                                memcpy(&pBindInfo->ftRevertToSnapShot, (void *) lvi.lParam, sizeof(FILETIME));
                                pBindInfo->iResultCode = NAR_E_FIX_APP;
                            }
                            break;
                        }

                        lvi.iItem++;
                    }

                    if(pBindInfo->iResultCode != NAR_E_USER_CANCELED) {
                        EndDialog(hDlg, pBindInfo->iResultCode);
                    }
                }
                break;
        }
        break;
    case WM_CLOSE:
        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
        EndDialog(hDlg, pBindInfo->iResultCode);
        break;
    case WM_DESTROY:
        {
            HICON           hIcon = (HICON)WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_GETICON, 0, 0);

            FreeListViewLParam(GetDlgItem(hDlg, IDC_NAR_PAGE4_LV_SNAPSHOTS));

            if(hIcon) {
                DestroyIcon(hIcon);
            }
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// **************************************************************************/
INT_PTR CALLBACK Nar_Page5_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ShowWindow(hDlg, SW_HIDE);

            WCHAR       wszStr[_MAX_PATH * 2];
            WCHAR       wszFmt1[_MAX_PATH * 2];
            WCHAR       wszArg1[_MAX_PATH * 2];

            HICON hIcon = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ARM));
            ASSERT(hIcon != NULL);
            WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_SETICON, (WPARAM)hIcon, 0);

            WszLoadString(g_hFusResDllMod, IDS_ARM_OPTIONS, wszFmt1, ARRAYSIZE(wszFmt1));

            switch(lParam)
            {
            case NAR_E_NO_MANAGED_APPS_FOUND:
                WszLoadString(g_hFusResDllMod, IDS_ARM_NOAPPS, wszArg1, ARRAYSIZE(wszArg1));
                wnsprintf(wszStr, ARRAYSIZE(wszStr), wszFmt1, wszArg1);
                break;
            case NAR_E_NO_POLICY_CHANGE_FOUND:
                WszLoadString(g_hFusResDllMod, IDS_ARM_NOPOLICYCHANGE, wszArg1, ARRAYSIZE(wszArg1));
                wnsprintf(wszStr, ARRAYSIZE(wszStr), wszFmt1, wszArg1);
                break;
            default: 
                wnsprintf(wszStr, ARRAYSIZE(wszStr), wszFmt1, TEXT(""));
                break;
            }

            WszSetDlgItemText(hDlg, IDC_NAR_INTRO_STR, wszStr);
            CenterDialog(hDlg);

            SetForegroundWindow(hDlg);
        }
        break;
    case WM_COMMAND:
        {
            INT_PTR nResult;

            nResult = 0;
            switch(LOWORD(wParam)) 
            {
                case IDYES:
                    nResult = IDOK;
                    // Fall thru
                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, nResult);
                    break;
            }
        }
        break;
    case WM_DESTROY:
        {
            HICON hIcon = (HICON)WszSendDlgItemMessage(hDlg, IDC_NAR_PAGE_ICON, STM_GETICON, 0, 0);
            if (hIcon != NULL)
                DestroyIcon(hIcon);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// **************************************************************************/
BOOL ClearMsgQueue(HWND hWnd, DWORD dwTickCount)
{
    BOOL        fBreak = FALSE;
    MSG         msg;
    DWORD       dwLastTick;
    DWORD       dwCurrentTick;

    if(dwTickCount) {
        dwLastTick = GetTickCount();
    }

    while(1) {
        while(WszPeekMessage(&msg, hWnd, 0, 0, PM_NOREMOVE)) {
            WszGetMessage(&msg, hWnd, 0, 0);

            if(msg.message == WM_QUIT)
                fBreak = TRUE;
            if(!WszIsDialogMessage(hWnd, &msg)) {
                TranslateMessage(&msg);
                WszDispatchMessage(&msg);
            }
        }

        if(dwTickCount) {
            dwCurrentTick = GetTickCount();
            if(dwCurrentTick - dwLastTick >= dwTickCount) {
                break;
            }
        }
        else {
            break;
        }
    }

    return fBreak;
}

// **************************************************************************/
void LoadResourceViewStrings(void)
{
    // Initialize the view columns
    int x=0, y=0;
    
    while(DlgAppView[x].lvis[y].iResourceID != -1) {
        WszLoadString(g_hFusResDllMod, DlgAppView[x].lvis[y].iResourceID, DlgAppView[x].lvis[y].tszName, ARRAYSIZE(DlgAppView[x].lvis[y].tszName));
        y++;
        if(DlgAppView[x].lvis[y].iResourceID == -1) {
            x++;
            y=0;
        }
        
        if(DlgAppView[x].lvis[y].iResourceID == -1)
            break;
    }
}

// **************************************************************************/
void DisplayOptionsDialog(HWND hParentWnd, LPARAM lParam)
{
    // Put up dialog say no manage apps found, go to add / remove?
    if(WszDialogBoxParam(g_hFusResDllMod, 
        g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_PAGE5_BIDI) : MAKEINTRESOURCEW(IDD_NAR_PAGE5),
        hParentWnd, Nar_Page5_DlgProc, lParam) == IDOK) {
        ExecuteAddRemoveProgramsApplet();
    }
}

// **************************************************************************/
void PromptRestoreDialog(HWND hWndParent, LPBINDENTRYINFO pBindInfo)
{
    LPWSTR      wszTitle = NULL;
    LPWSTR      wszMsg = NULL;
    INT_PTR     iResponse;

    wszTitle = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wszTitle) {
        return;
    }

    wszMsg = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wszMsg) {
        SAFEDELETEARRAY(wszTitle);
        return;
    }

    // User want's to restore original app.cfg
    WszLoadString(g_hFusResDllMod, IDS_ARM_CONFIRM_RESTORE, wszTitle, MAX_BUFFER_SIZE);
    WszLoadString(g_hFusResDllMod, IDS_ARM_RESTORE_EXPLAIN, wszMsg, MAX_BUFFER_SIZE);

    iResponse = WszMessageBox(hWndParent, wszMsg, wszTitle,
        (g_fBiDi ? MB_RTLREADING : 0) | MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);
    if(iResponse == IDYES) {
        UINT        uTitle;
        UINT        uMsg;

        if(SUCCEEDED(RestorePreviousConfigFile(pBindInfo->pReader, TRUE))) {
            uTitle = IDS_ARM_RESTORE_SUCCESS;
            uMsg = IDS_ARM_GOOD_EXIT;
            pBindInfo->iResultCode = NAR_E_SUCCESS;
        }
        else {
            uTitle = IDS_ARM_RESTORE_FAILURE;
            uMsg = IDS_ARM_FAILED_EXIT;
            pBindInfo->iResultCode = NAR_E_RESTORE_FAILED;
        }

        WszLoadString(g_hFusResDllMod, uTitle, wszTitle, MAX_BUFFER_SIZE);
        WszLoadString(g_hFusResDllMod, uMsg, wszMsg, MAX_BUFFER_SIZE);
        WszMessageBox(hWndParent, wszMsg, wszTitle,
            (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | MB_ICONINFORMATION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);
    }
    else {
        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
    }

    SAFEDELETEARRAY(wszTitle);
    SAFEDELETEARRAY(wszMsg);
}

// **************************************************************************/
void PromptSafeModeDialog(HWND hWndParent, LPBINDENTRYINFO pBindInfo)
{
    LPWSTR      wszTitle = NULL;
    LPWSTR      wszMsg = NULL;
    INT_PTR     iResponse;

    wszTitle = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wszTitle) {
        return;
    }

    wszMsg = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wszMsg) {
        SAFEDELETEARRAY(wszTitle);
        return;
    }

    WszLoadString(g_hFusResDllMod, IDS_ARM_CONFIRM_SAFEMODE, wszTitle, MAX_BUFFER_SIZE);
    WszLoadString(g_hFusResDllMod, IDS_ARM_SAFEMODE_EXPLAIN, wszMsg, MAX_BUFFER_SIZE);

    iResponse = WszMessageBox(hWndParent, wszMsg, wszTitle,
        (g_fBiDi ? MB_RTLREADING : 0) | MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);

    if(iResponse == IDYES) {
        UINT        uTitle;
        UINT        uMsg;

        if(SUCCEEDED(SetGlobalSafeMode(pBindInfo->pReader))) {
            uTitle = IDS_ARM_SAFEMODE_SUCCESS;
            uMsg = IDS_ARM_GOOD_EXIT;
            pBindInfo->iResultCode = NAR_E_SUCCESS;
        }
        else {
            uTitle = IDS_ARM_SAFEMODE_FAILURE;
            uMsg = IDS_ARM_FAILED_EXIT;
            pBindInfo->iResultCode = NAR_E_SAFEMODE_FAILED;
        }

        WszLoadString(g_hFusResDllMod, uTitle, wszTitle, MAX_BUFFER_SIZE);
        WszLoadString(g_hFusResDllMod, uMsg, wszMsg, MAX_BUFFER_SIZE);
        WszMessageBox(hWndParent, wszMsg, wszTitle, 
            (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | MB_ICONINFORMATION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);
    }
    else {
        pBindInfo->iResultCode = NAR_E_USER_CANCELED;
    }

    SAFEDELETEARRAY(wszTitle);
    SAFEDELETEARRAY(wszMsg);
}

// **************************************************************************/
void PromptUndoFixDialog(HWND hWndParent, LPBINDENTRYINFO pBindInfo)
{
    BOOL        fResult;

    if(!pBindInfo || !pBindInfo->pReader || !hWndParent) {
        ASSERT(0);
        return;
    }

    pBindInfo->iResultCode = NAR_E_FIX_APP;

    // If an original config or ARM backup exists, prompt user if they want to undo changes
    if(FAILED(DoesBackupConfigExist(pBindInfo->pReader, FALSE, &fResult))) {
        return;
    }
    if(fResult) {
        LPWSTR  wszTitle = NULL;
        LPWSTR  wszMsg = NULL;
        int     iResponse;

        wszTitle = NEW(WCHAR[MAX_BUFFER_SIZE]);
        if (!wszTitle) {
            return;
        }
    
        wszMsg = NEW(WCHAR[MAX_BUFFER_SIZE]);
        if (!wszMsg) {
            SAFEDELETEARRAY(wszTitle);
            return;
        }
    
        // Get user selection
        iResponse = WszDialogBoxParam(g_hFusResDllMod,
            g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_PAGE2_BIDI) : MAKEINTRESOURCEW(IDD_NAR_PAGE2),
            hWndParent, Nar_Page2_DlgProc, (LPARAM) pBindInfo);

        // User want's to fix the app
        if(iResponse == NAR_E_FIX_APP) {
            pBindInfo->iResultCode = NAR_E_FIX_APP;
        }
        // User want's to cancel
        else if(iResponse == NAR_E_USER_CANCELED) {
            pBindInfo->iResultCode = NAR_E_USER_CANCELED;
        }
        // User want's to undo a previous change
        else if(iResponse == NAR_E_UNDO_APP) {
            if(SUCCEEDED(RestorePreviousConfigFile(pBindInfo->pReader, FALSE))) {
                WszLoadString(g_hFusResDllMod, IDS_ARM_UNDO_SUCCESS, wszTitle, MAX_BUFFER_SIZE);
                WszLoadString(g_hFusResDllMod, IDS_ARM_GOOD_EXIT, wszMsg, MAX_BUFFER_SIZE);
                pBindInfo->iResultCode = NAR_E_SUCCESS;
            }
            else {
                WszLoadString(g_hFusResDllMod, IDS_ARM_UNDO_FAILURE, wszTitle, MAX_BUFFER_SIZE);
                WszLoadString(g_hFusResDllMod, IDS_ARM_FAILED_EXIT, wszMsg, MAX_BUFFER_SIZE);
                pBindInfo->iResultCode = NAR_E_RESTORE_FAILED;
            }

            WszMessageBox(hWndParent, wszMsg, wszTitle, 
                (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | MB_ICONINFORMATION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);
        }
        else {
            // UnExpected Response
            ASSERT(0);
        }

        SAFEDELETEARRAY(wszTitle);
        SAFEDELETEARRAY(wszMsg);
    }
}

// **************************************************************************/
HRESULT GetAppRuntimeInfo(
  IHistoryReader *pReader,
  LPWSTR  pwzRuntimeDir,
  DWORD   cchRuntimeDir,
  LPWSTR  pwzRuntimeVer,
  DWORD   cchRuntimeVer)
{
    WCHAR       wzFullAppPath[MAX_PATH];
    WCHAR       wzFullAppPathConfig[MAX_PATH];
    HRESULT     hr = S_OK;
    DWORD       dwRetSizeDir = 0;
    DWORD       dwRetSizeVer = 0;
    DWORD       dwSize = 0;

    MyTrace("GetAppRuntimeInfo - Entry");

    if(!pReader || !pwzRuntimeDir || !pwzRuntimeVer || !cchRuntimeDir || !cchRuntimeVer) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if(!g_pfnGetRequestedRuntimeInfo) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    *wzFullAppPath = L'\0';
    *wzFullAppPathConfig = L'\0';
    *pwzRuntimeDir = L'\0';
    *pwzRuntimeVer = L'\0';

    // Call into mscoree to get app's expected runtime version
    dwSize = ARRAYSIZE(wzFullAppPath);
    hr = pReader->GetEXEModulePath(wzFullAppPath, &dwSize);
    if(FAILED(hr)) {
        MyTrace("GetAppRuntimeInfo::pReader->GetEXEModulePath Failed");
        goto Exit;
    }

    // Build filename to .config file
    if(lstrlen(wzFullAppPath) + lstrlen(CONFIG_EXTENSION) + 1 > MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }

    wnsprintf(wzFullAppPathConfig, ARRAYSIZE(wzFullAppPathConfig), L"%ws%ws", wzFullAppPath, CONFIG_EXTENSION);
    
    hr = g_pfnGetRequestedRuntimeInfo(wzFullAppPath,  // App Name
        NULL,                   // Default version
        wzFullAppPathConfig,    // .Config file
        0,                      // Startup flags
        0,                      // reserved
        pwzRuntimeDir,          // Path to runtime to be loaded
        cchRuntimeDir,          // Sizeof above
        &dwRetSizeDir,          // Actual size returned
        pwzRuntimeVer,          // Path to version of runtime to be loaded
        cchRuntimeVer,          // Sizeof above
        &dwRetSizeVer);         // Acutal size returned

    if(FAILED(hr)) {
        MyTrace("PolicyManager::g_pfnGetRequestedRuntimeInfo Failed");
        goto Exit;
    }
    
Exit:

    MyTrace("GetAppRuntimeInfo - Exit");

    return hr;
}

// **************************************************************************/
STDAPI PolicyManager(HWND hWndParent, LPWSTR pwzFullyQualifiedAppPath, LPWSTR pwzAppName, LPWSTR pwzCulture)
{
    LPBINDENTRYINFO pBindInfo = NULL;
    INT_PTR         iOpResult;
    HRESULT         hrReturnValue = NAR_E_SUCCESS;
    HWND            hWndWorkingDialog = NULL;
    DWORD           dwManagedAppCount;
    DWORD           dwNumActivations;
    BOOL            fLoadedFusionDll = FALSE;
    BOOL            fLoadedResourceDll = FALSE;
    BOOL            fLoadedEEShimDLL = FALSE;
    BOOL            fDisposition = FALSE;
    LPWSTR          wszMsg = NULL;
    LPWSTR          wszTitle = NULL;
    LPWSTR          wzFmtBuff = NULL;
    HRESULT         hr = S_OK;
    CActivationContext  pAppCtx;
    UINT            uMsgType = MB_ICONERROR;
    DWORD           dwSize;

    MyTrace("PolicyManager - Entry");

    pAppCtx.Initialize(g_hInstance, MANIFEST_RESOURCE_ID);

    CActivationContextActivator dummyContext(pAppCtx);

    InitCommonControls();

    wszMsg = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wszMsg) {
        hrReturnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    wszTitle = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wszTitle) {
        hrReturnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    wzFmtBuff = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wzFmtBuff) {
        hrReturnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // Do this check to prevent unloading of fusion.dll when NAR is
    // launched via the viewer.
    if(!g_hFusionDllMod) {
        if(!LoadFusionDll()) {
            hrReturnValue = HRESULT_FROM_WIN32(GetLastError());
            ASSERT(0);
            goto CleanUp;
        }
        fLoadedFusionDll = TRUE;
    }

    if(!g_hFusResDllMod) {
        if(!LoadResourceDll(pwzCulture)) {
            hrReturnValue = HRESULT_FROM_WIN32(GetLastError());
            ASSERT(0);
            goto CleanUp;
        }

        fLoadedResourceDll = TRUE;
    }

    if(!g_hEEShimDllMod) {
        if(!LoadEEShimDll()) {
            hrReturnValue = HRESULT_FROM_WIN32(GetLastError());
            ASSERT(0);
            goto CleanUp;
        }

        fLoadedEEShimDLL = TRUE;
    }

    if(hWndParent == NULL) {
        hWndParent = GetDesktopWindow();
    }

    g_pBRIList = NULL;

    // Show the working dialog
    hWndWorkingDialog = WszCreateDialog(g_hFusResDllMod, 
        g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_SRCH_BIDI) : MAKEINTRESOURCEW(IDD_NAR_SRCH),
        hWndParent, WorkingDlgProc);
    ClearMsgQueue(hWndWorkingDialog, 2500);

    // See if we any have managed App's
    GetManagedAppCount(&dwManagedAppCount);
    if(!dwManagedAppCount) {
        SAFEDESTROYWINDOW(hWndWorkingDialog);
        DisplayOptionsDialog(hWndParent, NAR_E_NO_MANAGED_APPS_FOUND);
        hrReturnValue = NAR_E_NO_MANAGED_APPS_FOUND;
        goto CleanUp;
    }

    // Create Binding Reference List
    if((g_pBRIList = NEW(List<BindingReferenceInfo *>)) == NULL) {
        ASSERT(0);
        hrReturnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // If we have managed apps, then show a list for selection
    if(FAILED(GetHistoryReaders(g_pBRIList))) {
        // Unable to get history readers
        hrReturnValue = NAR_E_GETHISTORYREADERS;
        goto CleanUp;
    }

    // Create specific Binding Info
    if((pBindInfo = NEW(BINDENTRYINFO)) == NULL) {
        MyTrace("Memory Allocation Error");
        ASSERT(0);
        hrReturnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    memset(pBindInfo, 0, sizeof(BINDENTRYINFO));

    // Create a Assembly Binding Diff list
    if((pBindInfo->pABDList = NEW(List<AsmBindDiffs *>)) == NULL) {
        MyTrace("Memory Allocation Error");
        ASSERT(0);
        hrReturnValue = E_OUTOFMEMORY;
        goto CleanUp;
    }

    LoadResourceViewStrings();

    SAFEDESTROYWINDOW(hWndWorkingDialog);

    // Did we get app name and path passed in?
    if(pwzFullyQualifiedAppPath && pwzAppName) {
        if(lstrlen(pwzFullyQualifiedAppPath) && lstrlen(pwzAppName)) {
            if(FAILED(GetAssociatedReader(pwzFullyQualifiedAppPath, pwzAppName, pBindInfo))) {
                // We didn't find the managed app's history reader were interested in
                 hrReturnValue = NAR_E_NO_MANAGED_APPS_FOUND;
                goto CleanUp;
            }
        }
    }
    else {
        // Prompt user for which managed app to fix
        iOpResult = WszDialogBoxParam(g_hFusResDllMod,
            g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_PAGE1_BIDI) : MAKEINTRESOURCEW(IDD_NAR_PAGE1),
            hWndParent, Nar_Page1_DlgProc, (LPARAM) pBindInfo);

        if(iOpResult == NAR_E_USER_CANCELED) {
            hrReturnValue = NAR_E_USER_CANCELED;
            goto CleanUp;
        }
    }

    // If backup's available, Prompt user with options dialog
    PromptUndoFixDialog(hWndParent, pBindInfo);
    if(pBindInfo->iResultCode != NAR_E_FIX_APP) {
        goto CleanUp;
    }

    // Check for more than <= 1 snapshot, display advanced tab
    if(SUCCEEDED(pBindInfo->pReader->GetNumActivations(&dwNumActivations)) && dwNumActivations <= 1) {
        iOpResult = WszDialogBoxParam(g_hFusResDllMod,
            g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_PAGE4_BIDI) : MAKEINTRESOURCEW(IDD_NAR_PAGE4),
            hWndParent, Nar_Page4_DlgProc, (LPARAM) pBindInfo);
    }
    else {
        // Showing what were doing
        iOpResult = WszDialogBoxParam(g_hFusResDllMod,
            g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_PAGE3_BIDI) : MAKEINTRESOURCEW(IDD_NAR_PAGE3),
            hWndParent, Nar_Page3_DlgProc, (LPARAM) pBindInfo);
    }

    if( (iOpResult == NAR_E_USER_CANCELED) || (iOpResult == NAR_E_UNEXPECTED) ) {
        hrReturnValue = iOpResult;
        goto CleanUp;
    }

    // User want's to fix the app?
    if(iOpResult != NAR_E_FIX_APP) {
        hrReturnValue = pBindInfo->iResultCode;
        goto CleanUp;
    }

    // Show the working dialog
    hWndWorkingDialog = WszCreateDialog(g_hFusResDllMod, 
        g_fBiDi ? MAKEINTRESOURCEW(IDD_NAR_WRK_BIDI) : MAKEINTRESOURCEW(IDD_NAR_WRK),
        hWndParent, WorkingDlgProc);
    ClearMsgQueue(hWndWorkingDialog, 2500);

    // *********************************************/
    // Do supportedRuntime version validation
    // ********************************************/
    MyTrace("PolicyManager:: Checking 1st pass supportedRuntime version");

    *pBindInfo->wzSnapshotRuntimeVer = L'\0';
    *pBindInfo->wzRuntimeRefVer = L'\0';
    *pBindInfo->wzMachineConfigPath = L'\0';

    // These should be the same size
    ASSERT( ARRAYSIZE(pBindInfo->wzRuntimeRefVer) == ARRAYSIZE(pBindInfo->wzRuntimeRefVer));
    
    dwSize = ARRAYSIZE(pBindInfo->wzRuntimeRefVer);
    hr = pBindInfo->pReader->GetRunTimeVersion(&pBindInfo->ftRevertToSnapShot, pBindInfo->wzRuntimeRefVer, &dwSize);
    if(SUCCEEDED(hr)) {
        WCHAR       wzDir[MAX_PATH];
        WCHAR       wzVer[MAX_VERSION_DISPLAY_SIZE];

        *wzDir = L'\0';
        *wzVer = L'\0';

        // Copy the runtime version referenced in the snapshot we are going
        // to so the we can ensure we get the right machine.config file.
        StrCpy(pBindInfo->wzSnapshotRuntimeVer, pBindInfo->wzRuntimeRefVer);

        hr = GetAppRuntimeInfo(pBindInfo->pReader, wzDir, ARRAYSIZE(wzDir), wzVer, ARRAYSIZE(wzVer));
        if(FAILED(hr)) {
            WCHAR       wzCorPath[MAX_PATH];
            LPWSTR      pwzCorVersion = NULL;
            DWORD       dwSize;

            MyTrace("PolicyManager::GetAppRuntimeInfo Failed");

            // This maybe an unmanaged application, get the cor runtime version
            // check to see if they match before failing completly
            dwSize = 0;
            hr = g_pfnGetCorVersion(pwzCorVersion, dwSize, &dwSize);
            if(SUCCEEDED(hr)) {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }
            else if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                pwzCorVersion = NEW(WCHAR[dwSize]);
                if (!pwzCorVersion) {
                    hr = E_OUTOFMEMORY;
                    goto CleanUp;
                }

                hr = g_pfnGetCorVersion(pwzCorVersion, dwSize, &dwSize);
            }

            if (FAILED(hr)) {
                MyTrace("PolicyManager::Failed pfnGetCorVersion");
                SAFEDELETEARRAY(pwzCorVersion);
                goto CleanUp;
            }

            if(lstrlen(pwzCorVersion) + 1 > sizeof(wzVer)) {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                SAFEDELETEARRAY(pwzCorVersion);
                goto CleanUp;
            }

            StrCpy(wzVer, pwzCorVersion);
            SAFEDELETEARRAY(pwzCorVersion);

            // Now get the runtime path
            dwSize = ARRAYSIZE(wzCorPath);
            hr = g_pfnGetCorSystemDirectory(wzCorPath, dwSize, &dwSize);
            if(FAILED(hr)) {
                MyTrace("PolicyManager::Failed pfnGetCorSystemDirectory");
                goto CleanUp;
            }

            // Strip off (version)\ from the path
            PathRemoveBackslash(wzCorPath);
            *PathFindFileName(wzCorPath) = L'\0';

            if(lstrlen(wzCorPath) + 1 > ARRAYSIZE(wzDir)) {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto CleanUp;
            }

            StrCpy(wzDir, wzCorPath);
        }
        
        PathRemoveBackslash(wzDir);

        // Check supportedRuntime version information. If the reverting snapshot
        // matches what mscoree returns, then we don't have to put the node in the
        // app.cfg file
        if(!FusionCompareString(pBindInfo->wzRuntimeRefVer, wzVer)) {
            *pBindInfo->wzRuntimeRefVer = L'\0';
        }

        // Save off path to this runtime version of machine.config
        // path + '\' + runtimeversion + '\' + "config\\machine.config"
        if(lstrlen(wzDir) + 1 + lstrlen(wzVer) + 1 + lstrlen(MACHINE_CONFIG_PATH) + 1 >= MAX_PATH) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto CleanUp;
        }
        
        wnsprintf(pBindInfo->wzMachineConfigPath, ARRAYSIZE(pBindInfo->wzMachineConfigPath),
            L"%ws\\%ws\\%ws", wzDir, *pBindInfo->wzRuntimeRefVer ? pBindInfo->wzRuntimeRefVer : wzVer, MACHINE_CONFIG_PATH);

    }


    // *********************************************/
    // Do ADMIN policy validation
    // ********************************************/
    MyTrace("PolicyManager:: Checking temp app.config for admin policy");
    CleanOutBindingData(pBindInfo->pABDList);

    // Get binding data for selected snapshot
    if(FAILED(GetAppSnapShotBindingData(pBindInfo))) {
        hrReturnValue = NAR_E_UNEXPECTED;
        goto CleanUp;
    }

    // Write the binding data out, No publisher policy
    if(FAILED(WriteSnapShotBindingDataToXML(pBindInfo, PPSetNo))) {
        hrReturnValue = NAR_E_UNEXPECTED;
        goto CleanUp;
    }

    // Run PreBind to get details
    hr = PreBindingPolicyVerify(pBindInfo, FALSE);
    if(FAILED(hr)) {
        hrReturnValue = hr;
        goto UIDisplay;
    }

    // Diff data left?  Make sure assemblies that are left are not unified assemblies
    if(pBindInfo->pABDList->GetCount()) {

        // *********************************************/
        // Do Unified assembly policy validation
        // ********************************************/
        if(FAILED(WriteSnapShotBindingDataToXML(pBindInfo, PPSetNo))) {
            hrReturnValue = NAR_E_UNEXPECTED;
            goto CleanUp;
        }
    
        // Run PreBind to get details
        hr = PreBindingPolicyVerify(pBindInfo, FALSE);
        if(FAILED(hr)) {
            hrReturnValue = hr;
            goto UIDisplay;
        }

        // If we have diff data left, then changing policy won't
        // make a difference because ADMIN policy has been set.
        if(pBindInfo->pABDList->GetCount()) {
            MyTrace("PolicyManager:: Admin policy in place, can't fix");
            SAFEDESTROYWINDOW(hWndWorkingDialog);

            WszLoadString(g_hFusResDllMod, IDS_NAR_ADMIN_POLICY, wszTitle, MAX_BUFFER_SIZE);
            WszLoadString(g_hFusResDllMod, IDS_NAR_ADMIN_POLICY_INFO, wszMsg, MAX_BUFFER_SIZE);

            WszMessageBox(hWndParent, wszMsg, wszTitle, 
                (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | MB_ICONINFORMATION | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);
            hrReturnValue = NAR_E_ADMIN_POLICY_SET;
            goto CleanUp;
        }
    }

    MyTrace("PolicyManager:: No Admin policy in place");

    // *********************************************/
    // Do PUBLISHER policy validation
    // ********************************************/
    MyTrace("PolicyManager:: Checking temp app.config for publisher policy");
    CleanOutBindingData(pBindInfo->pABDList);

    // Get binding data for selected snapshot
    if(FAILED(GetAppSnapShotBindingData(pBindInfo))) {
        hrReturnValue = NAR_E_UNEXPECTED;
        goto CleanUp;
    }

    // Write the binding data out, Yes publisher policy
    if(FAILED(WriteSnapShotBindingDataToXML(pBindInfo, PPSetYes))) {
        hrReturnValue = NAR_E_UNEXPECTED;
        goto CleanUp;
    }

    // Run PreBind to get details
    hr = PreBindingPolicyVerify(pBindInfo, FALSE);
    if(FAILED(hr)) {
        hrReturnValue = hr;
        goto UIDisplay;
    }

    // No diff data. We need to make sure that the 
    // app.config file relfects what the selected snapshot is
    if(!pBindInfo->pABDList->GetCount()) {
        MyTrace("PolicyManager:: No publisher policy in place, mirroring snapshot");

        CleanOutBindingData(pBindInfo->pABDList);

        // Get binding data for selected snapshot
        if(FAILED(GetAppSnapShotBindingData(pBindInfo))) {
            hrReturnValue = NAR_E_UNEXPECTED;
            goto CleanUp;
        }

        // Run PreBind and remove assemblies that we can get too.
        hr = PreBindingPolicyVerify(pBindInfo, TRUE);
        if(FAILED(hr)) {
            hrReturnValue = hr;
            goto UIDisplay;
        }
    }
    else {
        MyTrace("PolicyManager:: Publisher policy in place, fixing app.config");
    }

    // Call to change order SupportedRuntime, effect assemblies or change policy
    // if needed. pBindInfo->fPolicyChanged tell's us something was changed
    // in the app.cfg file
    hr = InsertNewPolicy(hWndParent, pBindInfo, hWndWorkingDialog);

    if(FAILED(hr)) {
        goto UIDisplay;
    }

    // *********************************************/
    // Do final supportedRuntime version validation
    // ********************************************/
    // Make sure we get the right runtime version, if not
    // set safemode to true
    if(pBindInfo->fPolicyChanged && *pBindInfo->wzRuntimeRefVer) {
        WCHAR       wzDir[MAX_PATH];
        WCHAR       wzVer[MAX_VERSION_DISPLAY_SIZE];

        *wzDir = L'\0';
        *wzVer = L'\0';

        MyTrace("PolicyManager:: Checking 2nd pass supportedRuntime");

        hr = GetAppRuntimeInfo(pBindInfo->pReader, wzDir, ARRAYSIZE(wzDir), wzVer, ARRAYSIZE(wzVer));
        if(FAILED(hr)) {
            MyTrace("PolicyManager::GetAppRuntimeInfo Failed");
            hrReturnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        // Check to see if we are going to get the runtime version we want.
        if(!FusionCompareString(pBindInfo->wzRuntimeRefVer, wzVer)) {
            goto UIDisplay;
        }

        // We need to set startup safemode and try again
        hr = SetStartupSafeMode(pBindInfo->pReader, TRUE, &fDisposition);

        // Failed or nothing changed
        if(FAILED(hr) || !fDisposition) {

            // Revert the app.cfg since we don't want to leave it broken
            hr = RestorePreviousConfigFile(pBindInfo->pReader, FALSE);

            // Non-critical failure, fall thru
            if(FAILED(hr)) {
                MyTrace("Failed to revert changes in app.cfg");
            }

            hr = hrReturnValue = NAR_E_RUNTIME_VERSION;
            goto UIDisplay;
        }

        MyTrace("PolicyManager:: Checking 3rd pass supportedRuntime");

        // Something changed so try a final time to see if
        // we can get the version of the runtime we want.
        hr = GetAppRuntimeInfo(pBindInfo->pReader, wzDir, ARRAYSIZE(wzDir), wzVer, ARRAYSIZE(wzVer));
        if(FAILED(hr)) {
            MyTrace("PolicyManager::GetAppRuntimeInfo Failed");
            hrReturnValue = E_UNEXPECTED;
            goto CleanUp;
        }

        // Are we getting the right version yet?
        if(FusionCompareString(pBindInfo->wzRuntimeRefVer, wzVer)) {

            // Revert the app.cfg since we don't want to leave
            hr = RestorePreviousConfigFile(pBindInfo->pReader, FALSE);

            // Non-critical failure, fall thru
            if(FAILED(hr)) {
                MyTrace("Failed to revert changes in app.cfg");
            }
            
            hr = hrReturnValue = NAR_E_RUNTIME_VERSION;
        }
    }

UIDisplay:

    MyTrace("UIDisplay");

    SAFEDESTROYWINDOW(hWndWorkingDialog);

    if(SUCCEEDED(hr)) {
        uMsgType = MB_ICONINFORMATION;
        if(pBindInfo->fPolicyChanged) {
            WszLoadString(g_hFusResDllMod, IDS_ARM_APPLY_SUCCESS, wszTitle, MAX_BUFFER_SIZE);
            WszLoadString(g_hFusResDllMod, IDS_ARM_GOOD_EXIT, wszMsg, MAX_BUFFER_SIZE);
        }
        else {
            WszLoadString(g_hFusResDllMod, IDS_ARM_ALREADY_CONFIGURED, wszTitle, MAX_BUFFER_SIZE);
            WszLoadString(g_hFusResDllMod, IDS_ARM_ALREADY_CONFIGURED_EXIT, wszMsg, MAX_BUFFER_SIZE);
        }
    }
    else if(hr ==  NAR_E_RUNTIME_VERSION) {
        WszLoadString(g_hFusResDllMod, IDS_ARM_APPLY_FAILURE, wszTitle, MAX_BUFFER_SIZE);
        WszLoadString(g_hFusResDllMod, IDS_NAR_NORUNTIME_VERSION, wzFmtBuff, MAX_BUFFER_SIZE);
        wnsprintf(wszMsg, MAX_BUFFER_SIZE, wzFmtBuff, pBindInfo->wzSnapshotRuntimeVer);
    }
    else if(hr == NAR_E_MALFORMED_XML) {
        WszLoadString(g_hFusResDllMod, IDS_NAR_MALFORMED_APPCFG, wszTitle, MAX_BUFFER_SIZE);
        WszLoadString(g_hFusResDllMod, IDS_NAR_MALFORMED_APPCFG_INFO, wszMsg, MAX_BUFFER_SIZE);
    }
    else if(hrReturnValue == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)) {
        // Trying to repair a great version application
        // than the restore tool is running.
        WszLoadString(g_hFusResDllMod, IDS_ARM_APPLY_FAILURE, wszTitle, MAX_BUFFER_SIZE);
        WszLoadString(g_hFusResDllMod, IDS_NAR_INCOMPATIBLE_VERSIONS, wzFmtBuff, MAX_BUFFER_SIZE);
        wnsprintf(wszMsg, MAX_BUFFER_SIZE, wzFmtBuff, pBindInfo->wzSnapshotRuntimeVer);
        hrReturnValue = E_FAIL;
    }
    else if(hr == NAR_E_USER_CANCELED) {
        // User canceled, bail out without UI
        goto CleanUp;
    }
    else {
        WszLoadString(g_hFusResDllMod, IDS_ARM_APPLY_FAILURE, wszTitle, MAX_BUFFER_SIZE);
        WszLoadString(g_hFusResDllMod, IDS_ARM_FAILED_EXIT, wszMsg, MAX_BUFFER_SIZE);
    }

#ifdef DBG
    WCHAR   wszErrorCode[256];

    wnsprintf(wszErrorCode, ARRAYSIZE(wszErrorCode), L"\r\nInsertNewPolicy hr = 0x%0x\r\n", hr);
    StrCat(wszMsg, wszErrorCode);
#endif

    WszMessageBox(hWndParent, wszMsg, wszTitle, 
        (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | uMsgType | MB_APPLMODAL | MB_SETFOREGROUND | MB_TOPMOST);

CleanUp:

    MyTrace("Cleanup");

    SAFEDELETEARRAY(wszMsg);
    SAFEDELETEARRAY(wszTitle);
    SAFEDELETEARRAY(wzFmtBuff);

    if(FAILED(hrReturnValue)) {
        WCHAR   wszError[256];

        wnsprintf(wszError, ARRAYSIZE(wszError), L"PolicyManager:: Failure occured 0x%0x\r\n", hrReturnValue);
        MyTraceW(wszError);
    }

    if(pBindInfo) {
        if(lstrlen(pBindInfo->wszTempPolicyFile)) {
            WszDeleteFile(pBindInfo->wszTempPolicyFile);
        }
    }

    if(g_pBRIList) {
        LISTNODE    pListNode = g_pBRIList->GetHeadPosition();
        while(pListNode != NULL) {
            BindingReferenceInfo    *pBRI;
            pBRI = g_pBRIList->GetAt(pListNode);
            SAFEDELETE(pBRI);
            g_pBRIList->GetNext(pListNode);
        }

        SAFEDELETE(g_pBRIList);
    }

    if(pBindInfo) {
        if(pBindInfo->pABDList) {
            LISTNODE    pListNode = pBindInfo->pABDList->GetHeadPosition();
            while(pListNode != NULL) {
                AsmBindDiffs    *pABD;
                pABD = pBindInfo->pABDList->GetAt(pListNode);
                SAFEDELETE(pABD);
                pBindInfo->pABDList->GetNext(pListNode);
            }

            SAFEDELETE(pBindInfo->pABDList);
        }

        SAFERELEASE(pBindInfo->pReader);
        SAFEDELETE(pBindInfo);
    }

    SAFEDESTROYWINDOW(hWndWorkingDialog);

    // Unload if this function loaded the dll's
    if(fLoadedFusionDll) {
        FreeFusionDll();
    }

    if(fLoadedResourceDll) {
        FreeResourceDll();
    }

    if(fLoadedEEShimDLL) {
        FreeEEShimDll();
    }

    MyTrace("PolicyManager - Exit");
    return hrReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\dataobject.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// DataObject.cpp
//
// The IDataObject interface specifies methods that enable data transfer and 
// notification of changes in data. 
//
// Data transfer methods specify the format of the transferred data along with 
// the medium through which the data is to be transferred. Optionally, the data 
// can be rendered for a specific target device. In addition to methods for
// retrieving and storing data, the IDataObject interface specifies methods for 
// enumerating available formats and managing connections to advisory sinks for 
// handling change notifications.

#include "stdinc.h"

#define SETFORMATETC(ptr, cf, dva, tym, ptdv, lin)\
    ((ptr).cfFormat = cf,\
    (ptr).ptd = ptdv,\
    (ptr).dwAspect = dva,\
    (ptr).lindex = lin,\
    (ptr).tymed = tym);

// TODO : declare extern variables for registered clipboard formats
// Eg : extern unsigned short g_cfMyClipBoardFormat;

CDataObject::CDataObject(CShellFolder *pSF, UINT uiItemCount, LPCITEMIDLIST *aPidls)
{
    MyTrace("New CDataObject");
    m_lRefCount = 1;

    m_pPidlMgr = NEW( CPidlMgr );
    
    m_cFormatsAvailable = MAX_NUM_FORMAT;

    m_pSF           = pSF;
    if (m_pSF)
    {
        m_pSF->AddRef();
    }
    m_uiItemCount   = uiItemCount;

    m_aPidls = reinterpret_cast<LPITEMIDLIST *>(NEW(BYTE[uiItemCount * sizeof(LPITEMIDLIST)]));
    if (m_aPidls && m_pPidlMgr)
    {
        UINT i = 0;
        for (i = 0; i < uiItemCount; i++)
        {
            m_aPidls[i] = m_pPidlMgr->Concatenate(m_pSF->m_pidl, m_pPidlMgr->Copy(aPidls[i]));
        }
    }
    
    // TODO : Set the format etc and the stg medium for all supported Clipboard formats
    // Also can be done through SetData call
    // For Example :
    // SETFORMATETC(m_feFormatEtc[0], g_cfMyClipBoardFormat, DVASPECT_CONTENT, TYMED_HGLOBAL, NULL, -1);
    // m_smStgMedium[0].tymed   = TYMED_HGLOBAL;
    // m_smStgMedium[0].hGlobal = NULL;

    SETFORMATETC(m_feFormatEtc[0], CF_HDROP, DVASPECT_CONTENT, TYMED_HGLOBAL, NULL, -1);
    m_smStgMedium[0].tymed  = TYMED_HGLOBAL;
    m_smStgMedium[0].hGlobal= NULL;
    m_ulCurrent = 0;
}

CDataObject::~CDataObject()
{
    MyTrace("CDataObject::~CDataObject");

    if (m_pSF)
    {
        m_pSF->Release();
    }
    if(m_aPidls && m_pPidlMgr)
    {
        UINT  i;
        for(i = 0; i < m_uiItemCount; i++)
        {
            m_pPidlMgr->Delete(m_aPidls[i]);
        }
        SAFEDELETE(m_aPidls);
        m_aPidls = NULL;
    }
    SAFEDELETE(m_pPidlMgr);
}

///////////////////////////////////////////////////////////
// IUnknown implementation
//
// CDataObject::QueryInterface
STDMETHODIMP  CDataObject::QueryInterface(REFIID riid, PVOID *ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IDataObject)) {    //IDataObject
        *ppv = (IDataObject*) this;
    }
    else if(IsEqualIID(riid, IID_IEnumFORMATETC)) { //IEnumFORMATETC
        *ppv = (IEnumFORMATETC*) this;
    } 

    if (*ppv) {
        (*(LPUNKNOWN*)ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef(void)
{
    return InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(ULONG) CDataObject::Release(void)
{
    LONG    lRef = InterlockedDecrement(&m_lRefCount);

    if(!lRef) {
        DELETE(this);
    }

    return lRef;
}

///////////////////////////////////////////////////////////
// IDataObject members
//
// CDataObject::GetData
// Called by a data consumer to obtain data from a source data object. 
//
// The GetData method renders the data described in the specified FORMATETC 
// structure and transfers it through the specified STGMEDIUM structure. 
// The caller then assumes responsibility for releasing the STGMEDIUM structure.
// Notes to Implementers
// IDataObject::GetData must check all fields in the FORMATETC structure. 
// It is important that IDataObject::GetData render the requested aspect and, 
// if possible, use the requested medium. If the data object cannot comply with 
// the information specified in the FORMATETC, the method should return DV_E_FORMATETC. 
// If an attempt to allocate the medium fails, the method should return STG_E_MEDIUMFULL. 
// It is important to fill in all of the fields in the STGMEDIUM structure. 
//
// Although the caller can specify more than one medium for returning the data, 
// IDataObject::GetData can supply only one medium. If the initial transfer fails with 
// the selected medium, this method can be implemented to try one of the other media 
// specified before returning an error.
STDMETHODIMP CDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pSM)
{
    MyTrace("CDataObject::GetData");
    if(pFE == NULL || pSM == NULL)
    {
        return ResultFromScode(E_INVALIDARG);      
    }
    pSM->hGlobal = NULL;

    for(ULONG i=0; i < m_cFormatsAvailable;i++)
    {
        if ( ((pFE->tymed & m_feFormatEtc[i].tymed) == m_feFormatEtc[i].tymed) &&
            pFE->dwAspect == m_feFormatEtc[i].dwAspect &&
            pFE->cfFormat == m_feFormatEtc[i].cfFormat)
        {
            pSM->tymed = m_smStgMedium[i].tymed;
            // TODO : Render data and put in appropriate pSM member variables
            // For Example
            // if (pFE->cfFormat == g_cfMyClipBoardFormat)
            //{
            //  pSM->hGlobal    = createMyClipBoardData();
            //  return ResultFromScode(S_OK);
            //}
            if (pFE->cfFormat == CF_HDROP)
            {
                pSM->hGlobal    = createHDrop();
                return ResultFromScode(S_OK);
            }
        }
    }
    return ResultFromScode(DATA_E_FORMATETC);
}

// CDataObject::GetDataHere
// Called by a data consumer to obtain data from a source data object. 
// This method differs from the GetData method in that the caller must 
// allocate and free the specified storage medium.
//
// The IDataObject::GetDataHere method is similar to IDataObject::GetData, except that 
// the caller must both allocate and free the medium specified in pmedium. 
// GetDataHere renders the data described in a FORMATETC structure and copies the 
// data into that caller-provided STGMEDIUM structure. For example, if the medium is 
// TYMED_HGLOBAL, this method cannot resize the medium or allocate a new hGlobal.
//
// In general, the only storage media it is necessary to support in this method are 
// TYMED_ISTORAGE, TYMED_ISTREAM, and TYMED_FILE. 
STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSM)
{
    MyTrace("CDataObject::GetDataHere");
    if(pFE == NULL || pSM == NULL)
    {
        return ResultFromScode(E_INVALIDARG);      
    }
    return ResultFromScode(E_NOTIMPL);
}

// CDataObject::QueryGetData
// Determines whether the data object is capable of rendering the data described in 
// the FORMATETC structure. Objects attempting a paste or drop operation can call 
// this method before calling IDataObject::GetData to get an indication of whether 
// the operation may be successful.
//
// The client of a data object calls IDataObject::QueryGetData to determine whether 
// passing the specified FORMATETC structure to a subsequent call to IDataObject::GetData 
// is likely to be successful. A successful return from this method does not necessarily 
// ensure the success of the subsequent paste or drop operation.
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormat)
{
    MyTrace("CDataObject::QueryGetData");
    if(!lpFormat)
    {
        return ResultFromScode(S_FALSE);
    }
    // TODO : This object support DVASPECT_CONTENT, Change it appropriately
    //      if you support other aspects
    if (!(DVASPECT_CONTENT & lpFormat->dwAspect))
    {
        return (DV_E_DVASPECT);
    }
    // Check for tymeds
    BOOL bReturn = FALSE;
    for(ULONG i=0; i < m_cFormatsAvailable;i++)
    {
        bReturn |= ((lpFormat->tymed & m_feFormatEtc[i].tymed) == m_feFormatEtc[i].tymed);
    }
    return (bReturn ? S_OK : DV_E_TYMED);
}

// CDataObject::GetCanonicalFormatEtc
// Provides a standard FORMATETC structure that is logically equivalent to one that is 
// more complex. You use this method to determine whether two different FORMATETC structures 
// would return the same data, removing the need for duplicate rendering.
//
// If a data object can supply exactly the same data for more than one requested FORMATETC 
// structure, IDataObject::GetCanonicalFormatEtc can supply a "canonical", or standard 
// FORMATETC that gives the same rendering as a set of more complicated FORMATETC 
// structures. For example, it is common for the data returned to be insensitive to the 
// target device specified in any one of a set of otherwise similar FORMATETC structures. 
STDMETHODIMP CDataObject::GetCanonicalFormatEtc(LPFORMATETC pFE1, LPFORMATETC pFEOut)
{
    MyTrace("CDataObject::GetCanonicalFormatEtc");
    if (NULL == pFEOut)
    {
        return E_INVALIDARG;
    }
    pFEOut->ptd = NULL;
    return DATA_S_SAMEFORMATETC;
}

// CDataObject::SetData
// Called by an object containing a data source to transfer data to the object 
// that implements this method.
//
// IDataObject::SetData allows another object to attempt to send data to the implementing 
// data object. A data object implements this method if it supports receiving data 
// from another object. If it does not support this, it should be implemented to return E_NOTIMPL. 
STDMETHODIMP CDataObject::SetData(LPFORMATETC pFE , LPSTGMEDIUM pSTM, BOOL fRelease)
{
    MyTrace("CDataObject::SetData");
    // TODO : Set m_feFormatEtc and m_smStgMedium 
    return ResultFromScode(E_NOTIMPL);  
}

// CDataObject::EnumFormatEtc
// Creates an object for enumerating the FORMATETC structures for a data object. These 
// structures are used in calls to IDataObject::GetData or IDataObject::SetData. 
//
// IDataObject::EnumFormatEtc creates an enumerator object that can be used to determine 
// all of the ways the data object can describe data in a FORMATETC structure, and 
// supplies a pointer to its IEnumFORMATETC interface. This is one of the standard 
// enumerator interfaces. 
STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDir, LPENUMFORMATETC FAR *pEnum)
{
    MyTrace("CDataObject::EnumFormatEtc");
    switch (dwDir)
    {
        case DATADIR_GET:
        {
            return QueryInterface(IID_IEnumFORMATETC, (LPVOID*) pEnum);
        }
        break;
        case DATADIR_SET:
        {
            default:
            pEnum=NULL;
        }
        break;
    }
    if (NULL==pEnum)
    {
        return ResultFromScode(OLE_S_USEREG);
    }
    return ResultFromScode(S_OK);   
}

// CDataObject::DAdvise
// Called by an object supporting an advise sink to create a connection between a data 
// object and the advise sink. This enables the advise sink to be notified of changes 
// in the data of the object.
//
// IDataObject::DAdvise creates a change notification connection between a data object 
// and the caller. The caller provides an advisory sink to which the notifications can 
// be sent when the object's data changes. 
// Objects used simply for data transfer typically do not support advisory notifications 
// and return OLE_E_ADVISENOTSUPPORTED from IDataObject::DAdvise.
STDMETHODIMP CDataObject::DAdvise(FORMATETC FAR *pFE,  DWORD advf,LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    MyTrace("CDataObject::DAdvise");
    return OLE_E_ADVISENOTSUPPORTED;
}

// CDataObject::DUnadvise
// Destroys a notification connection that had been previously set up.
//
// This methods destroys a notification created with a call to the 
// IDataObject::DAdvise method.
STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
    MyTrace("CDataObject::DUnadvise");
    return OLE_E_ADVISENOTSUPPORTED;
}

// CDataObject::EnumDAdvise
// Creates an object that can be used to enumerate the current advisory connections.
// 
// The enumerator object created by this method implements the IEnumSTATDATA interface, 
// one of the standard enumerator interfaces that contain the Next, Reset, Clone, 
// and Skip methods. IEnumSTATDATA permits the enumeration of the data stored in 
// an array of STATDATA structures. Each of these structures provides information
// on a single advisory connection, and includes FORMATETC and ADVF information, 
// as well as the pointer to the advise sink and the token representing the connection
STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    MyTrace("CDataObject::EnumDAdvise");
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

// private members for delay-rendering data
//HGLOBAL CDataObject::createMyClipBoardData()
//{
//  return NULL;
//}
HGLOBAL CDataObject::createHDrop()
{
    MyTrace("CDataObject::createHDrop");
    HGLOBAL hGlobal = NULL;

    if (m_pPidlMgr && m_uiItemCount > 0)
    {
        hGlobal = GlobalAlloc(GPTR | GMEM_ZEROINIT, 
                        sizeof(DROPFILES) + (m_uiItemCount*((_MAX_PATH+1)*sizeof(TCHAR)))+2);   // 2 for double NULL termination
        int uiCurPos = sizeof(DROPFILES);
        if (hGlobal)
        {
            LPDROPFILES pDropFiles = (LPDROPFILES) GlobalLock(hGlobal);
            if (pDropFiles)
            {
                pDropFiles->pFiles = sizeof(DROPFILES);
                pDropFiles->fWide = TRUE;

                for (UINT i = 0; i < m_uiItemCount; i++)
                {
                    TCHAR       szText[_MAX_PATH];
                    BYTE        *psz;

                    m_pPidlMgr->getPidlPath(m_aPidls[i], szText, ARRAYSIZE(szText));
                    psz = (BYTE*) pDropFiles;
                    psz += uiCurPos;
                    StrCpy((LPWSTR)psz, szText);
                    uiCurPos += lstrlen(szText) + 1;
                }
            }
            GlobalUnlock(hGlobal);
        }
    }
    return hGlobal;
}

//////////////////////////////////////////////////////////
// IEnumFORMATETC Implementation
//
// CDataObject::Next
// Retrieves the next uRequested items in the enumeration sequence. If there are fewer 
// than the requested number of elements left in the sequence, it retrieves the 
// remaining elements. The number of elements actually retrieved is returned through 
// pulFetched (unless the caller passed in NULL for that parameter).
//
STDMETHODIMP CDataObject::Next(ULONG uRequested, LPFORMATETC pFormatEtc, ULONG* pulFetched)
{
    MyTrace("CDataObject::Next");
    if(NULL != pulFetched)
    {
        *pulFetched = 0L;
    }
    if(NULL == pFormatEtc)
    {
        return E_INVALIDARG;
    }

    ULONG uFetched;
    for(uFetched = 0; m_ulCurrent < m_cFormatsAvailable && uRequested > uFetched; uFetched++)
    {
        *pFormatEtc++ = m_feFormatEtc[m_ulCurrent++];
    }
    if(NULL != pulFetched)
    {
        *pulFetched = uFetched;
    }
    return ((uFetched == uRequested) ? S_OK : S_FALSE);
}

// CDataObject::Skip
// Skips over the next specified number of elements in the enumeration sequence.
STDMETHODIMP CDataObject::Skip(ULONG cSkip)
{
    MyTrace("CDataObject::Skip");
    if((m_ulCurrent + cSkip) >= m_cFormatsAvailable)
    {
        return S_FALSE;
    }
    m_ulCurrent += cSkip;
    return S_OK;
}

// CDataObject::Reset
// Resets the enumeration sequence to the beginning.
STDMETHODIMP CDataObject::Reset(void)
{
    MyTrace("CDataObject::Reset");
    m_ulCurrent = 0;
    return S_OK;
}

// CDataObject::Clone
// Creates another enumerator that contains the same enumeration state as the current 
// one. 
// Creates another enumerator that contains the same enumeration state as the current 
// one. 
//
// Using this function, a client can record a particular point in the enumeration 
// sequence, and then return to that point at a later time. The new enumerator 
// supports the same interface as the original one.
STDMETHODIMP CDataObject::Clone(LPENUMFORMATETC* ppEnum)
{
    MyTrace("CDataObject::Clone");
    *ppEnum = NULL;

    CDataObject *pNew = NEW(CDataObject(m_pSF, m_uiItemCount, (LPCITEMIDLIST*)m_aPidls));
    if (NULL == pNew) {
        return E_OUTOFMEMORY;
    }
    pNew->m_ulCurrent = m_ulCurrent;
    *ppEnum = pNew;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\dropsource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//**********************************************************************
// CDropSource::CDropSource
//
// Purpose:
//      Class definition for drag and drop file functionality
//
// Parameters:
//      None
// Return Value:
//      None
//**********************************************************************
class CDropSource : public IDropSource
{
   private:
       LONG m_lRefCount;

   public:
    // IUnknown methods
    STDMETHOD (QueryInterface) (REFIID riid, PVOID *ppv);
    STDMETHOD_ (DWORD, AddRef)();
    STDMETHOD_ (DWORD, Release)();

    // IDropSource methods
   STDMETHOD (QueryContinueDrag) (BOOL fEscapePressed, DWORD grfKeyState);
   STDMETHOD (GiveFeedback) (DWORD dwEffect);

   CDropSource();
   ~CDropSource();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\culture.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

typedef struct _SXS_CULTURE_INFO
{
    LANGID ParentLangID;
    LANGID ChildLangID;
    USHORT CultureStringCch;
    PCWSTR CultureString;
} SXS_CULTURE_INFO, *PSXS_CULTURE_INFO;

typedef const struct _SXS_CULTURE_INFO *PCSXS_CULTURE_INFO;

// Table originally taken from Win32 SxS folks (mgrier) and includes
// additional defines used by CLR language folks. CLR Contact 
// is Yung-Shin Lin (yslin)
//

// Note:
//  A macro MAX_CULTURE_STRINGLENGTH is defined in stdinc.h
//  which captures the length of the longest culture string . If you 
//  updated this table, and put a longer culture string to it, make 
//  sure you update the macro as well.
//
static const SXS_CULTURE_INFO s_rgCultures[] =
{
    { 0x0001, 0x0000, 2, L"ar" },
    { 0x0002, 0x0000, 2, L"bg" },
    { 0x0003, 0x0000, 2, L"ca" },
    { 0x0004, 0x0000, 6, L"zh-CHS" },
    { 0x0005, 0x0000, 2, L"cs" },
    { 0x0006, 0x0000, 2, L"da" },
    { 0x0007, 0x0000, 2, L"de" },
    { 0x0008, 0x0000, 2, L"el" },
    { 0x0009, 0x0000, 2, L"en" },
    { 0x000a, 0x0000, 2, L"es" },
    { 0x000b, 0x0000, 2, L"fi" },
    { 0x000c, 0x0000, 2, L"fr" },
    { 0x000d, 0x0000, 2, L"he" },
    { 0x000e, 0x0000, 2, L"hu" },
    { 0x000f, 0x0000, 2, L"is" },
    { 0x0010, 0x0000, 2, L"it" },
    { 0x0011, 0x0000, 2, L"ja" },
    { 0x0012, 0x0000, 2, L"ko" },
    { 0x0013, 0x0000, 2, L"nl" },
    { 0x0014, 0x0000, 2, L"no" },
    { 0x0015, 0x0000, 2, L"pl" },
    { 0x0016, 0x0000, 2, L"pt" },
    { 0x0018, 0x0000, 2, L"ro" },
    { 0x0019, 0x0000, 2, L"ru" },
    { 0x001a, 0x0000, 2, L"hr" },
    { 0x001b, 0x0000, 2, L"sk" },
    { 0x001c, 0x0000, 2, L"sq" },
    { 0x001d, 0x0000, 2, L"sv" },
    { 0x001e, 0x0000, 2, L"th" },
    { 0x001f, 0x0000, 2, L"tr" },
    { 0x0020, 0x0000, 2, L"ur" },
    { 0x0021, 0x0000, 2, L"id" },
    { 0x0022, 0x0000, 2, L"uk" },
    { 0x0023, 0x0000, 2, L"be" },
    { 0x0024, 0x0000, 2, L"sl" },
    { 0x0025, 0x0000, 2, L"et" },
    { 0x0026, 0x0000, 2, L"lv" },
    { 0x0027, 0x0000, 2, L"lt" },
    { 0x0029, 0x0000, 2, L"fa" },
    { 0x002a, 0x0000, 2, L"vi" },
    { 0x002b, 0x0000, 2, L"hy" },
    { 0x002c, 0x0000, 2, L"az" },
    { 0x002d, 0x0000, 2, L"eu" },
    { 0x002f, 0x0000, 2, L"mk" },
    { 0x0036, 0x0000, 2, L"af" },
    { 0x0037, 0x0000, 2, L"ka" },
    { 0x0038, 0x0000, 2, L"fo" },
    { 0x0039, 0x0000, 2, L"hi" },
    { 0x003e, 0x0000, 2, L"ms" },
    { 0x003f, 0x0000, 2, L"kk" },
    { 0x0040, 0x0000, 2, L"ky" },
    { 0x0041, 0x0000, 2, L"sw" },
    { 0x0043, 0x0000, 2, L"uz" },
    { 0x0044, 0x0000, 2, L"tt" },
    { 0x0046, 0x0000, 2, L"pa" },
    { 0x0047, 0x0000, 2, L"gu" },
    { 0x0049, 0x0000, 2, L"ta" },
    { 0x004a, 0x0000, 2, L"te" },
    { 0x004b, 0x0000, 2, L"kn" },
    { 0x004e, 0x0000, 2, L"mr" },
    { 0x004f, 0x0000, 2, L"sa" },
    { 0x0050, 0x0000, 2, L"mn" },
    { 0x0056, 0x0000, 2, L"gl" },
    { 0x0057, 0x0000, 3, L"kok" },
    { 0x005a, 0x0000, 3, L"syr" },
    { 0x0065, 0x0000, 3, L"div" },
    { 0x0401, 0x0001, 5, L"ar-SA" },
    { 0x0402, 0x0002, 5, L"bg-BG" },
    { 0x0403, 0x0003, 5, L"ca-ES" },
    { 0x0404, 0x7c04, 5, L"zh-TW" },
    { 0x0405, 0x0005, 5, L"cs-CZ" },
    { 0x0406, 0x0006, 5, L"da-DK" },
    { 0x0407, 0x0007, 5, L"de-DE" },
    { 0x0408, 0x0008, 5, L"el-GR" },
    { 0x0409, 0x0009, 5, L"en-US" },
    { 0x040b, 0x000b, 5, L"fi-FI" },
    { 0x040c, 0x000c, 5, L"fr-FR" },
    { 0x040d, 0x000d, 5, L"he-IL" },
    { 0x040e, 0x000e, 5, L"hu-HU" },
    { 0x040f, 0x000f, 5, L"is-IS" },
    { 0x0410, 0x0010, 5, L"it-IT" },
    { 0x0411, 0x0011, 5, L"ja-JP" },
    { 0x0412, 0x0012, 5, L"ko-KR" },
    { 0x0413, 0x0013, 5, L"nl-NL" },
    { 0x0414, 0x0014, 5, L"nb-NO" },
    { 0x0415, 0x0015, 5, L"pl-PL" },
    { 0x0416, 0x0016, 5, L"pt-BR" },
    { 0x0418, 0x0018, 5, L"ro-RO" },
    { 0x0419, 0x0019, 5, L"ru-RU" },
    { 0x041a, 0x001a, 5, L"hr-HR" },
    { 0x041b, 0x001b, 5, L"sk-SK" },
    { 0x041c, 0x001c, 5, L"sq-AL" },
    { 0x041d, 0x001d, 5, L"sv-SE" },
    { 0x041e, 0x001e, 5, L"th-TH" },
    { 0x041f, 0x001f, 5, L"tr-TR" },
    { 0x0420, 0x0020, 5, L"ur-PK" },
    { 0x0421, 0x0021, 5, L"id-ID" },
    { 0x0422, 0x0022, 5, L"uk-UA" },
    { 0x0423, 0x0023, 5, L"be-BY" },
    { 0x0424, 0x0024, 5, L"sl-SI" },
    { 0x0425, 0x0025, 5, L"et-EE" },
    { 0x0426, 0x0026, 5, L"lv-LV" },
    { 0x0427, 0x0027, 5, L"lt-LT" },
    { 0x0429, 0x0029, 5, L"fa-IR" },
    { 0x042a, 0x002a, 5, L"vi-VN" },
    { 0x042b, 0x002b, 5, L"hy-AM" },
    { 0x042c, 0x002c, 10, L"az-AZ-Latn" },
    { 0x042d, 0x002d, 5, L"eu-ES" },
    { 0x042f, 0x002f, 5, L"mk-MK" },
    { 0x0436, 0x0036, 5, L"af-ZA" },
    { 0x0437, 0x0037, 5, L"ka-GE" },
    { 0x0438, 0x0038, 5, L"fo-FO" },
    { 0x0439, 0x0039, 5, L"hi-IN" },
    { 0x043e, 0x003e, 5, L"ms-MY" },
    { 0x043f, 0x003f, 5, L"kk-KZ" },
    { 0x0440, 0x0040, 5, L"ky-KZ" },
    { 0x0441, 0x0041, 5, L"sw-KE" },
    { 0x0443, 0x0043, 10, L"uz-UZ-Latn" },
    { 0x0444, 0x0044, 5, L"tt-RU" },
    { 0x0446, 0x0046, 5, L"pa-IN" },
    { 0x0447, 0x0047, 5, L"gu-IN" },
    { 0x0449, 0x0049, 5, L"ta-IN" },
    { 0x044a, 0x004a, 5, L"te-IN" },
    { 0x044b, 0x004b, 5, L"kn-IN" },
    { 0x044e, 0x004e, 5, L"mr-IN" },
    { 0x044f, 0x004f, 5, L"sa-IN" },
    { 0x0450, 0x0050, 5, L"mn-MN" },
    { 0x0456, 0x0056, 5, L"gl-ES" },
    { 0x0457, 0x0057, 6, L"kok-IN" },
    { 0x045a, 0x005a, 6, L"syr-SY" },
    { 0x0465, 0x0065, 6, L"div-MV" },
    { 0x0801, 0x0001, 5, L"ar-IQ" },
    { 0x0804, 0x0004, 5, L"zh-CN" },
    { 0x0807, 0x0007, 5, L"de-CH" },
    { 0x0809, 0x0009, 5, L"en-GB" },
    { 0x080a, 0x000a, 5, L"es-MX" },
    { 0x080c, 0x000c, 5, L"fr-BE" },
    { 0x0810, 0x0010, 5, L"it-CH" },
    { 0x0813, 0x0013, 5, L"nl-BE" },
    { 0x0814, 0x0014, 5, L"nn-NO" },
    { 0x0816, 0x0016, 5, L"pt-PT" },
    { 0x081a, 0x001a, 10, L"sr-SP-Latn" },
    { 0x081d, 0x001d, 5, L"sv-FI" },
    { 0x082c, 0x002c, 10, L"az-AZ-Cyrl" },
    { 0x083e, 0x003e, 5, L"ms-BN" },
    { 0x0843, 0x0043, 10, L"uz-UZ-Cyrl" },
    { 0x0c01, 0x0001, 5, L"ar-EG" },
    { 0x0c04, 0x7c04, 5, L"zh-HK" },
    { 0x0c07, 0x0007, 5, L"de-AT" },
    { 0x0c09, 0x0009, 5, L"en-AU" },
    { 0x0c0a, 0x000a, 5, L"es-ES" },
    { 0x0c0c, 0x000c, 5, L"fr-CA" },
    { 0x0c1a, 0x001a, 10, L"sr-SP-Cyrl" },
    { 0x1001, 0x0001, 5, L"ar-LY" },
    { 0x1004, 0x0004, 5, L"zh-SG" },
    { 0x1007, 0x0007, 5, L"de-LU" },
    { 0x1009, 0x0009, 5, L"en-CA" },
    { 0x100a, 0x000a, 5, L"es-GT" },
    { 0x100c, 0x000c, 5, L"fr-CH" },
    { 0x1401, 0x0001, 5, L"ar-DZ" },
    { 0x1404, 0x0004, 5, L"zh-MO" },
    { 0x1407, 0x0007, 5, L"de-LI" },
    { 0x1409, 0x0009, 5, L"en-NZ" },
    { 0x140a, 0x000a, 5, L"es-CR" },
    { 0x140c, 0x000c, 5, L"fr-LU" },
    { 0x1801, 0x0001, 5, L"ar-MA" },
    { 0x1809, 0x0009, 5, L"en-IE" },
    { 0x180a, 0x000a, 5, L"es-PA" },
    { 0x180c, 0x000c, 5, L"fr-MC" },
    { 0x1c01, 0x0001, 5, L"ar-TN" },
    { 0x1c09, 0x0009, 5, L"en-ZA" },
    { 0x1c0a, 0x000a, 5, L"es-DO" },
    { 0x2001, 0x0001, 5, L"ar-OM" },
    { 0x2009, 0x0009, 5, L"en-JM" },
    { 0x200a, 0x000a, 5, L"es-VE" },
    { 0x2401, 0x0001, 5, L"ar-YE" },
    { 0x2409, 0x0009, 5, L"en-CB" },
    { 0x240a, 0x000a, 5, L"es-CO" },
    { 0x2801, 0x0001, 5, L"ar-SY" },
    { 0x2809, 0x0009, 5, L"en-BZ" },
    { 0x280a, 0x000a, 5, L"es-PE" },
    { 0x2c01, 0x0001, 5, L"ar-JO" },
    { 0x2c09, 0x0009, 5, L"en-TT" },
    { 0x2c0a, 0x000a, 5, L"es-AR" },
    { 0x3001, 0x0001, 5, L"ar-LB" },
    { 0x3009, 0x0009, 5, L"en-ZW" },
    { 0x300a, 0x000a, 5, L"es-EC" },
    { 0x3401, 0x0001, 5, L"ar-KW" },
    { 0x3409, 0x0009, 5, L"en-PH" },
    { 0x340a, 0x000a, 5, L"es-CL" },
    { 0x3801, 0x0001, 5, L"ar-AE" },
    { 0x380a, 0x000a, 5, L"es-UY" },
    { 0x3c01, 0x0001, 5, L"ar-BH" },
    { 0x3c0a, 0x000a, 5, L"es-PY" },
    { 0x4001, 0x0001, 5, L"ar-QA" },
    { 0x400a, 0x000a, 5, L"es-BO" },
    { 0x440a, 0x000a, 5, L"es-SV" },
    { 0x480a, 0x000a, 5, L"es-HN" },
    { 0x4c0a, 0x000a, 5, L"es-NI" },
    { 0x500a, 0x000a, 5, L"es-PR" },
    { 0x7c04, 0x0000, 6, L"zh-CHT" },
};

// **************************************************************************/
// int __cdecl bsearch_callback(const void *pv1, const void *pv2)
// **************************************************************************/
int __cdecl bsearch_callback(const void *pv1, const void *pv2)
{
    PCSXS_CULTURE_INFO p1 = (PCSXS_CULTURE_INFO) pv1;
    PCSXS_CULTURE_INFO p2 = (PCSXS_CULTURE_INFO) pv2;

    if (p1->ParentLangID < p2->ParentLangID)
        return -1;
    else if (p1->ParentLangID == p2->ParentLangID)
        return 0;

    return 1;
}

// **************************************************************************/
// BOOL ShFusionMapLANGIDToCultures(LANGID langid, LPWSTR pwzGeneric, DWORD dwGenericSize,
//                              LPWSTR pwzSpecific, DWORD dwSpecificSize)
// **************************************************************************/
BOOL ShFusionMapLANGIDToCultures(LANGID langid, LPWSTR pwzGeneric, DWORD dwGenericSize,
                             LPWSTR pwzSpecific, DWORD dwSpecificSize)
{
    SXS_CULTURE_INFO Key;
    PCSXS_CULTURE_INFO p1 = NULL;
    PCSXS_CULTURE_INFO p2 = NULL;

    if(!pwzGeneric) {
        ASSERT(0);
        return FALSE;
    }

    if(!pwzSpecific) {
        ASSERT(0);
        return FALSE;
    }

    if(dwGenericSize == 0) {
        ASSERT(0);
        return FALSE;
    }

    if(dwSpecificSize == 0) {
        ASSERT(0);
        return FALSE;
    }

    Key.ParentLangID = langid;

    p1 = (PCSXS_CULTURE_INFO) bsearch(&Key, s_rgCultures, NUMBER_OF(s_rgCultures), sizeof(SXS_CULTURE_INFO), &bsearch_callback);

    if (p1 != NULL) {
        Key.ParentLangID = p1->ChildLangID;
        p2 = (PCSXS_CULTURE_INFO) bsearch(&Key, s_rgCultures, NUMBER_OF(s_rgCultures), sizeof(SXS_CULTURE_INFO), &bsearch_callback);
    }

    if (p1 != NULL) {
        wnsprintf(pwzSpecific, dwSpecificSize, L"%ws", p1->CultureString);
    }
    if (p2 != NULL) {
        wnsprintf(pwzGeneric, dwGenericSize, L"%ws", p2->CultureString);
    }

    return TRUE;
}

// **************************************************************************/
// LANGID DetermineLangId(void)
// **************************************************************************/
typedef LANGID (__stdcall *PFNLANGAPI) (void);         // Language API
HRESULT DetermineLangId(LANGID *pLangId)
{
    PFNLANGAPI  pfnLangAPI = NULL;

    // Let's load up Kernal32.dll to find our API
    HMODULE     hKernelMod = WszGetModuleHandle(L"Kernel32.dll");
    if(!hKernelMod) {
        const DWORD   dwLastError = GetLastError();
        return HRESULT_FROM_WIN32(dwLastError);
    }

    // Try highest platform supported API first
    // Me and up
    if( (pfnLangAPI = (PFNLANGAPI) GetProcAddress(hKernelMod, "GetUserDefaultUILanguage")) != NULL) {
        *pLangId = pfnLangAPI();
        return S_OK;
    }
    else {
        const DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_PROC_NOT_FOUND)
            return HRESULT_FROM_WIN32(dwLastError);
    }

    // Me and up
    if( (pfnLangAPI = (PFNLANGAPI) GetProcAddress(hKernelMod, "GetSystemDefaultUILanguage")) != NULL) {
        *pLangId = pfnLangAPI();
        return S_OK;
    }
    else {
        const DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_PROC_NOT_FOUND)
            return HRESULT_FROM_WIN32(dwLastError);
    }

    // W95 and up
    if( (pfnLangAPI = (PFNLANGAPI) GetProcAddress(hKernelMod, "GetUserDefaultLangID")) != NULL) {
        *pLangId = pfnLangAPI();
        return S_OK;
    }
    else {
        const DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_PROC_NOT_FOUND)
            return HRESULT_FROM_WIN32(dwLastError);
    }

    // W95 and up
    if( (pfnLangAPI = (PFNLANGAPI) GetProcAddress(hKernelMod, "GetSystemDefaultLangID")) != NULL) {
        *pLangId = pfnLangAPI();
        return S_OK;
    }
    else {
        const DWORD dwLastError = GetLastError();
        if (dwLastError != ERROR_PROC_NOT_FOUND)
            return HRESULT_FROM_WIN32(dwLastError);
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\droptarget.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

///////////////////////////////////////////////////////////
// IDropTarget implemenatation
//
// Indicates whether a drop can be accepted, and, if so, the effect of the drop.
// You do not call IDropTarget::DragEnter directly; instead the DoDragDrop 
// function calls it to determine the effect of a drop the first time the user 
// drags the mouse into the registered window of a drop target. 
// To implement IDropTarget::DragEnter, you must determine whether the target 
// can use the data in the source data object by checking three things: 
//      o The format and medium specified by the data object 
//      o The input value of pdwEffect 
//      o The state of the modifier keys 
// On return, the method must write the effect, one of the members of the 
// DROPEFFECT enumeration, to the pdwEffect parameter. 
// **************************************************************************/
STDMETHODIMP CShellView::DragEnter(LPDATAOBJECT pDataObj, DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{  
    MyTrace("DragEnter");

    FORMATETC   fmtetc;

    // No Drop's on Download View
    if(m_iCurrentView == VIEW_DOWNLOAD_CACHE)
        return E_FAIL;
    
    fmtetc.cfFormat   = m_cfPrivateData;
    fmtetc.ptd        = NULL;
    fmtetc.dwAspect   = DVASPECT_CONTENT;
    fmtetc.lindex     = -1;
    fmtetc.tymed      = TYMED_HGLOBAL;

    // QueryGetData for pDataObject for our format
    m_bAcceptFmt = (S_OK == pDataObj->QueryGetData(&fmtetc)) ? TRUE : FALSE;
    queryDrop(dwKeyState, pdwEffect);

    if(m_bAcceptFmt)
    {
        FORMATETC   fe;
        STGMEDIUM   stgmed;

        fe.cfFormat   = m_cfPrivateData;
        fe.ptd        = NULL;
        fe.dwAspect   = DVASPECT_CONTENT;
        fe.lindex     = -1;
        fe.tymed      = TYMED_HGLOBAL;

        if( SUCCEEDED(pDataObj->GetData(&fe, &stgmed)) )
        {
            // Validate drop extensions
            LPDROPFILES pDropFiles = (LPDROPFILES)GlobalLock(stgmed.hGlobal);

            if(pDropFiles != NULL)
            {
                m_bAcceptFmt = IsValidFileTypes(pDropFiles);
                GlobalUnlock(stgmed.hGlobal);
            }
        }
    }

    return m_bAcceptFmt ? S_OK : E_FAIL;
}

// Provides target feedback to the user and communicates the drop's effect 
// to the DoDragDrop function so it can communicate the effect of the drop 
// back to the source. 
// For efficiency reasons, a data object is not passed in IDropTarget::DragOver. 
// The data object passed in the most recent call to IDropTarget::DragEnter 
// is available and can be used.
// **************************************************************************/
STDMETHODIMP CShellView::DragOver(DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
    MyTrace("DragOver");

    BOOL bRet = queryDrop(dwKeyState, pdwEffect);
    return bRet ? S_OK : E_FAIL;
}

// Removes target feedback and releases the data object. 
// You do not call this method directly. The DoDragDrop function calls this 
// method in either of the following cases: 
//      o When the user drags the cursor out of a given target window. 
//      o When the user cancels the current drag-and-drop operation. 
// To implement IDropTarget::DragLeave, you must remove any target feedback 
// that is currently displayed. You must also release any references you hold 
// to the data transfer object.
// **************************************************************************/
STDMETHODIMP CShellView::DragLeave(VOID)
{
    MyTrace("DragLeave");

    m_bAcceptFmt = FALSE;
    return S_OK;
}

// Incorporates the source data into the target window, removes target 
// feedback, and releases the data object. 
// You do not call this method directly. The DoDragDrop function calls 
// this method when the user completes the drag-and-drop operation. 
// In implementing IDropTarget::Drop, you must incorporate the data 
// object into the target. Use the formats available in IDataObject, 
// available through pDataObject, along with the current state of 
// the modifier keys to determine how the data is to be incorporated, 
// such as linking or embedding.
// In addition to incorporating the data, you must also clean up as you 
// do in the IDropTarget::DragLeave method: 
//      o Remove any target feedback that is currently displayed. 
//      o Release any references to the data object. 
// You also pass the effect of this operation back to the source application 
// through DoDragDrop, so the source application can clean up after the 
// drag-and-drop operation is complete: 
//      o Remove any source feedback that is being displayed. 
//      o Make any necessary changes to the data, such as removing the 
//        data if the operation was a move. 
// **************************************************************************/
STDMETHODIMP CShellView::Drop(LPDATAOBJECT pDataObj, DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
    MyTrace("Drop");

    if (queryDrop(dwKeyState, pdwEffect)) {      
        FORMATETC   fe;
        STGMEDIUM   stgmed;

        fe.cfFormat   = m_cfPrivateData;
        fe.ptd        = NULL;
        fe.dwAspect   = DVASPECT_CONTENT;
        fe.lindex     = -1;
        fe.tymed      = TYMED_HGLOBAL;

        // Get the storage medium from the data object.
        if(SUCCEEDED(pDataObj->GetData(&fe, &stgmed))) {

            BOOL bRet = doDrop(stgmed.hGlobal, DROPEFFECT_MOVE == *pdwEffect);

            //release the STGMEDIUM
            ReleaseStgMedium(&stgmed);
            *pdwEffect = DROPEFFECT_NONE;
            return bRet ? S_OK : E_FAIL;
        }
    }

    *pdwEffect = DROPEFFECT_NONE;
    return E_FAIL;
}

// **************************************************************************/
BOOL CShellView::queryDrop(DWORD dwKeyState, LPDWORD pdwEffect)
{
    MyTrace("queryDrop");

    DWORD dwOKEffects = *pdwEffect;

    *pdwEffect = DROPEFFECT_NONE;

    if (m_bAcceptFmt) {
        *pdwEffect = getDropEffectFromKeyState(dwKeyState);

        if(DROPEFFECT_LINK == *pdwEffect) {
            *pdwEffect = DROPEFFECT_NONE;
        }

        if(*pdwEffect & dwOKEffects) {
            return TRUE;
        }
    }
    return FALSE;
}

// **************************************************************************/
DWORD CShellView::getDropEffectFromKeyState(DWORD dwKeyState)
{
    MyTrace("getDropEffectFromKeyState");

    DWORD dwDropEffect = DROPEFFECT_MOVE;

    if(dwKeyState & MK_CONTROL) {
        if(dwKeyState & MK_SHIFT) {
            dwDropEffect = DROPEFFECT_LINK;
        }
        else {
            dwDropEffect = DROPEFFECT_COPY;
        }
    }
    return dwDropEffect;
}

// **************************************************************************/
BOOL CShellView::doDrop(HGLOBAL hMem, BOOL bCut)
{
    MyTrace("doDrop");

    LPWSTR      pwzErrorString = NULL;

    DWORD       dwTotalFiles = 0;
    DWORD       dwTotalFilesInstalled = 0;
    HCURSOR     hOldCursor;

    hOldCursor = SetCursor(WszLoadCursor(NULL, MAKEINTRESOURCEW(IDC_WAIT)));

    if(hMem) {
        // We support CF_HDROP and hence the global mem object
        // contains a DROPFILES structure
        LPDROPFILES pDropFiles = (LPDROPFILES) GlobalLock(hMem);
        if (pDropFiles) {
            m_fAddInProgress = TRUE;

            LPWSTR pwszFileArray = NULL;
            LPWSTR pwszFileCurrent = NULL;

            if(pDropFiles->fWide) {
                // Unicode Alignment
                pwszFileArray = (LPWSTR) ((PBYTE) pDropFiles + pDropFiles->pFiles);
                pwszFileCurrent = pwszFileArray;
            }
            else {
                // Non Unicode Alignment
                pwszFileArray = reinterpret_cast<LPWSTR>(((PBYTE) pDropFiles + pDropFiles->pFiles));
                pwszFileCurrent = AnsiToWide((LPSTR) pwszFileArray);

                if(!pwszFileCurrent) {
                    SetLastError(ERROR_OUTOFMEMORY);
                    GlobalUnlock(hMem);
                    return FALSE;
                }
            }

            BOOL        fInstallDone = FALSE;

            while(!fInstallDone) {
                HRESULT     hr;
                dwTotalFiles++;

                if(SUCCEEDED( hr = InstallFusionAsmCacheItem(pwszFileCurrent, FALSE))) {
                    dwTotalFilesInstalled++;
                }
                else {
                    // Display error dialog for installation failure
                    FormatGetMscorrcError(hr, pwszFileCurrent, &pwzErrorString);
                }

                if(pDropFiles->fWide) {
                    // Unicode increment, Advance to next file in list
                    pwszFileCurrent += lstrlen(pwszFileCurrent) + 1;

                    // More files in the list?
                    if(!*pwszFileCurrent) {
                        fInstallDone = TRUE;
                        continue;
                    }
                }
                else {
                    // Non unicode, Advance to next file in list
                    char    *pChar = (char*) pwszFileArray;

                    // Do char increment since pwszFileArray is actually
                    // of char type
                    pChar += lstrlen(pwszFileCurrent) + 1;
                    SAFEDELETEARRAY(pwszFileCurrent);

                    // More files in the list?
                    if(!*pChar) {
                        fInstallDone = TRUE;
                        continue;
                    }

                    pwszFileArray = (LPWSTR) pChar;
                    pwszFileCurrent = AnsiToWide((LPSTR) pwszFileArray);

                    if(!pwszFileCurrent) {
                        SetLastError(ERROR_OUTOFMEMORY);
                        SAFEDELETEARRAY(pwzErrorString);
                        GlobalUnlock(hMem);
                        return FALSE;
                    }
                }
            }
            
            GlobalUnlock(hMem);
            m_fAddInProgress = FALSE;
        }
    }

    // Refresh the display only if the cache watch thread isn't running
    if(dwTotalFilesInstalled) {
        // BUGBUG: Do Refresh cause W9x inst getting the event
        // set for some reason. File FileWatch.cpp
        if( (g_hWatchFusionFilesThread == INVALID_HANDLE_VALUE) || !g_bRunningOnNT) {
            WszPostMessage(m_hWndParent, WM_COMMAND, MAKEWPARAM(ID_REFRESH_DISPLAY, 0), 0);
        }
    }

    SetCursor(hOldCursor);

    // Display error dialog if all files weren't installed.
    if(dwTotalFiles != dwTotalFilesInstalled) {
        WCHAR       wszTitle[_MAX_PATH];

        WszLoadString(g_hFusResDllMod, IDS_INSTALL_ERROR_TITLE, wszTitle, ARRAYSIZE(wszTitle));
        MessageBeep(MB_ICONASTERISK);
        WszMessageBox(m_hWndParent, pwzErrorString, wszTitle,
            (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
    }

    SAFEDELETEARRAY(pwzErrorString);

    return dwTotalFilesInstalled ? TRUE : FALSE;
}

// **************************************************************************/
BOOL CShellView::IsValidFileTypes(LPDROPFILES pDropFiles)
{
    BOOL        m_bAcceptFmt = TRUE;
    int         iItem;

    if(pDropFiles != NULL) {
        const struct {
            WCHAR   szExt[5];
        } s_ValidExt[] = {
            {   TEXT(".EXE")    },
            {   TEXT(".DLL")    },
            {   TEXT(".MCL")    },
            {   TEXT("\0")      },
        };

        LPWSTR pwszFileArray = NULL;
        LPWSTR pwszFileCurrent = NULL;

        if(pDropFiles->fWide) {
            // Unicode Alignment
            pwszFileArray = (LPWSTR) ((PBYTE) pDropFiles + pDropFiles->pFiles);
            pwszFileCurrent = pwszFileArray;
        }
        else {
            // Non Unicode Alignment
            pwszFileArray = reinterpret_cast<LPWSTR>(((PBYTE) pDropFiles + pDropFiles->pFiles));
            pwszFileCurrent = AnsiToWide((LPSTR) pwszFileArray);

            if(!pwszFileCurrent) {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }
        }

        while(*pwszFileCurrent) {
            PWCHAR      pwzStr;
            BOOL        fValid;

            if(lstrlen(pwszFileCurrent) < 4) {
                m_bAcceptFmt = FALSE;
                break;
            }

            fValid = FALSE;
            pwzStr = wcsrchr(pwszFileCurrent, L'.');
            iItem = 0;

            if(pwzStr) {
                while(*s_ValidExt[iItem].szExt) {
                    if(!FusionCompareStringAsFilePath(pwzStr, s_ValidExt[iItem].szExt)) {
                        fValid = TRUE;
                        break;
                    }
                    iItem++;
                }
            }

            // If we have a valid filename, continue on down the list
            if(fValid) {
                if(pDropFiles->fWide) {
                    // Unicode increment, Advance to next file in list
                    pwszFileCurrent += lstrlen(pwszFileCurrent) + 1;
                }
                else {
                    // Non unicode, Advance to next file in list
                    LPSTR           pStr = reinterpret_cast<LPSTR>(pwszFileArray);

                    pStr += lstrlen(pwszFileCurrent) + 1;
                    pwszFileArray = reinterpret_cast<LPWSTR>(pStr);

                    SAFEDELETEARRAY(pwszFileCurrent);
                    pwszFileCurrent = AnsiToWide((LPSTR) pwszFileArray);
                    if(!pwszFileCurrent) {
                        SetLastError(ERROR_OUTOFMEMORY);
                        return FALSE;
                    }
                }
            }
            else {
                // Invalid file in the list, don't accept drop
                m_bAcceptFmt = FALSE;
                break;
            }
        }

        if(!pDropFiles->fWide) {
            SAFEDELETEARRAY(pwszFileCurrent);
        }
    }

    return m_bAcceptFmt;
}

// **************************************************************************/
#define MAX_BUFFER_SIZE 2048
#define MAX_BIG_BUFFER_SIZE 8192
void CShellView::FormatGetMscorrcError(HRESULT hResult, LPWSTR pwzFileName, LPWSTR *ppwzErrorString)
{
    WCHAR   wzLangSpecific[MAX_CULTURE_STRING_LENGTH+1];
    WCHAR   wzLangGeneric[MAX_CULTURE_STRING_LENGTH+1];
    WCHAR   wszCorePath[_MAX_PATH];
    WCHAR   wszMscorrcPath[_MAX_PATH];
    LPWSTR  wzErrorStringFmt = NULL;
    DWORD   dwPathSize;
    DWORD   dwSize;
    HMODULE hEEShim = NULL;
    HMODULE hLibmscorrc = NULL;
    LPWSTR  pwMsgBuf = NULL;
    LANGID  langId;
    BOOL    fLoadedShim = FALSE;

    wzErrorStringFmt = NEW(WCHAR[MAX_BUFFER_SIZE]);
    if (!wzErrorStringFmt) {
        return;
    }

    *wzLangSpecific = L'\0';
    *wzLangGeneric = L'\0';
    *wszCorePath = L'\0';
    *wszMscorrcPath = L'\0';
    *wzErrorStringFmt = L'\0';

    // Try to determine Culture if needed
    if(SUCCEEDED(DetermineLangId(&langId))) {
        ShFusionMapLANGIDToCultures(langId, wzLangGeneric, ARRAYSIZE(wzLangGeneric),
            wzLangSpecific, ARRAYSIZE(wzLangSpecific));
    }

    // Get path to mscoree.dll
    if(!g_hEEShimDllMod) {
        fLoadedShim = TRUE;
    }
    
    if(LoadEEShimDll()) {
        *wszCorePath = L'\0';

        dwPathSize = ARRAYSIZE(wszCorePath);
        g_pfnGetCorSystemDirectory(wszCorePath, ARRAYSIZE(wszCorePath), &dwPathSize);

        if(fLoadedShim) {
            FreeEEShimDll();
        }
    }

    LPWSTR  pStrPathsArray[] = {wzLangSpecific, wzLangGeneric, NULL};

    // check the length of possible path of our language dll
    // to make sure we don't overrun our buffer.
    //
    // corpath + language + '\' + mscorrc.dll + '\0'
    if (lstrlenW(wszCorePath) + ARRAYSIZE(wzLangGeneric) + 1 + lstrlenW(SZ_MSCORRC_DLL_NAME) + 1 > _MAX_PATH)
    {
        return;
    }

    // Go through all the possible path locations for our
    // language dll (ShFusRes.dll). Use the path that has this
    // file installed in it or default to core framework ShFusRes.dll
    // path.
    for(int x = 0; x < ARRAYSIZE(pStrPathsArray); x++){
        // Find resource file exists
        StrCpy(wszMscorrcPath, wszCorePath);

        if(pStrPathsArray[x]) {
            StrCat(wszMscorrcPath, (LPWSTR) pStrPathsArray[x]);
            StrCat(wszMscorrcPath, TEXT("\\"));
        }

        StrCat(wszMscorrcPath, SZ_MSCORRC_DLL_NAME);
        if(WszGetFileAttributes(wszMscorrcPath) != -1) {
            break;
        }

        *wszMscorrcPath = L'\0';
    }

    // Now load the resource dll
    if(lstrlen(wszMscorrcPath)) {
        hLibmscorrc = WszLoadLibrary(wszMscorrcPath);
        if(hLibmscorrc) {
            WszLoadString(hLibmscorrc, HRESULT_CODE(hResult), wzErrorStringFmt, MAX_BUFFER_SIZE);
            FreeLibrary(hLibmscorrc);
        }
    }

    // Fix 458945 - Viewer does not display error strings for Win32 error codes not wrapped by mscorrc
    // If we don't have a string, then try standard error
    if(!lstrlen(wzErrorStringFmt)) {
        LPWSTR ws = NULL;

        ws = NEW(WCHAR[MAX_BIG_BUFFER_SIZE]);
        if (!ws) {
            SAFEDELETEARRAY(wzErrorStringFmt);
            return;
        }

        *ws = L'\0';

        // Get the string error from the HR
        DWORD res = WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                                    NULL, hResult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                                    ws, MAX_BIG_BUFFER_SIZE, NULL);

        if(res) {
            StrCpy(wzErrorStringFmt, L"%1 ");
            StrCat(wzErrorStringFmt, ws);
        }
        else {
            WszLoadString(g_hFusResDllMod, IDS_UNEXPECTED_ERROR, wzErrorStringFmt, MAX_BUFFER_SIZE);
            wnsprintf(ws, MAX_BIG_BUFFER_SIZE, L" 0x%0x", hResult);
            StrCat(wzErrorStringFmt, ws);
        }

        SAFEDELETEARRAY(ws);
    }

    // Don't display whole path, just get the filename that failed
    // to install
    LPWSTR  pszFileName = PathFindFileName(pwzFileName);

    // MSCORRC.DLL contains strings input's that are only %n and don't contain any formating at all.
    // this really breaks us cause we can not call the prefered method of FormatMessage.
    // So, we are going to search for %1 only and simply replace it with the filename that cause
    // error (Praying that this is right).
/*
    // This is a the proper way to do the formatting
    LPVOID pArgs[] = { pszFileName, NULL };

    WszFormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_STRING |
        FORMAT_MESSAGE_ARGUMENT_ARRAY,
        wzErrorStringFmt,
        0,
        0,
        (LPWSTR)pwMsgBuf,
        0,
        (va_list *)pArgs
    );
*/
    // Hack fix because MSCORRC.DLL doesn't contain formatting information
    LPWSTR  pStr = StrStrI(wzErrorStringFmt, L"%1");
    if(pStr) {
        dwSize = lstrlen(wzErrorStringFmt) + lstrlen(pszFileName) + 1;
        pwMsgBuf = NEW(WCHAR[dwSize]);
        if(pwMsgBuf) {
            *pStr = L'\0';
            StrCpy(pwMsgBuf, wzErrorStringFmt);
            StrCat(pwMsgBuf, pszFileName);
            pStr += lstrlen(L"%1");
            StrCat(pwMsgBuf, pStr);
        }
    }

    // Now append any previous strings to this one
    dwSize = 0;
    if(*ppwzErrorString) {
        dwSize = lstrlen(*ppwzErrorString);
        dwSize += 2;        // Add 2 for cr/lf combo
    }

    dwSize += lstrlen(pwMsgBuf);    // Add new string length
    dwSize++;                       // Add 1 for null terminator

    LPWSTR  pStrTmp = NEW(WCHAR[dwSize]);

    if(pStrTmp) {
        *pStrTmp = L'\0';

        if(*ppwzErrorString) {
            StrCpy(pStrTmp, *ppwzErrorString);
            StrCat(pStrTmp, L"\r\n");
            SAFEDELETEARRAY(*ppwzErrorString);
        }

        if(pwMsgBuf) {
            StrCat(pStrTmp, pwMsgBuf);
        }
        else {
            StrCat(pStrTmp, pszFileName);
        }
    }
    
    SAFEDELETEARRAY(pwMsgBuf);
    SAFEDELETEARRAY(wzErrorStringFmt);
    SAFEDELETEARRAY(*ppwzErrorString);
    *ppwzErrorString = pStrTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\extracticon.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ExtractIcon.h
//

#ifndef EXTRACTICON_H
#define EXTRACTICON_H

class CExtractIcon : public IExtractIconA, public IExtractIconW
{
public:
    CExtractIcon(LPCITEMIDLIST);
    ~CExtractIcon();

    //IUnknown methods
    STDMETHOD (QueryInterface) (REFIID, PVOID *);
    STDMETHOD_ (ULONG, AddRef) (void);
    STDMETHOD_ (ULONG, Release) (void);

    //IExtractIconA methods
    STDMETHOD (GetIconLocation) (UINT, LPSTR, UINT, int *, UINT *);
    STDMETHOD (Extract) (LPCSTR, UINT, HICON *, HICON *, UINT);
    
    //IExtractIconW methods
    STDMETHOD (GetIconLocation) (UINT, LPWSTR, UINT, int *, LPUINT);
    STDMETHOD (Extract) (LPCWSTR, UINT, HICON*, HICON*, UINT);
protected:
    LONG    m_lRefCount;
private:
    LPITEMIDLIST    m_pidl;
    LPPIDLMGR       m_pPidlMgr;
};

#endif   //EXTRACTICON_H

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\extracticon.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ExtractIcon.cpp
//
// You implement IExtractIcon to provide either instance-specific icons 
// for objects in a particular class or icons for subfolders that extend 
// Windows Explorer's namespace. These implementations are accomplished by 
// writing handler code in an OLE in-process server COM DLL

#include "stdinc.h"
#include "globals.h"

CExtractIcon::CExtractIcon(LPCITEMIDLIST pidl)
{
    m_pPidlMgr = NEW(CPidlMgr);
    m_pidl = m_pPidlMgr->Copy(pidl);
    m_lRefCount = 1;
    g_uiRefThisDll++;
}

CExtractIcon::~CExtractIcon()
{
    g_uiRefThisDll--;

    if(m_pidl) {
        m_pPidlMgr->Delete(m_pidl);
        m_pidl = NULL;
    }

    SAFEDELETE(m_pPidlMgr);
}

///////////////////////////////////////////////////////////
// IUnknown Implementation
//
STDMETHODIMP CExtractIcon::QueryInterface(REFIID riid, PVOID *ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IExtractIconW)) {  //IExtractIconW
        *ppv = (IExtractIconW*)this;
    }
    else if(IsEqualIID(riid, IID_IExtractIconA)) {  //IExtractIconA
        *ppv = (IExtractIconA*)this;
    }

    if(*ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}                                             

STDMETHODIMP_(DWORD) CExtractIcon::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(DWORD) CExtractIcon::Release()
{
    LONG    lRef = InterlockedDecrement(&m_lRefCount);

    if(!lRef) {
        DELETE(this);
    }

    return lRef;
}

////////////////////////////////////////////////////////////////////////
//  IExtractIconA Implementation
STDMETHODIMP CExtractIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, 
                                                        int *piIndex, UINT *pwFlags)
{
    MyTrace("GetIconLocationA - Entry");

    LPWSTR      pwzIconFile = NULL;
    LPSTR       pszIconFilePath = NULL;
    HRESULT     hr = E_FAIL;

    pwzIconFile = NEW(WCHAR[MAX_PATH]);
    
    // Get our icon's location
    hr = GetIconLocation(uFlags, pwzIconFile, MAX_PATH, piIndex, pwFlags);
    if(FAILED(hr)) {
        goto Exit;
    }

    pszIconFilePath = WideToAnsi(pwzIconFile);
    if(!pszIconFilePath) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    if((UINT)lstrlenA(pszIconFilePath)+1 > cchMax) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    lstrcpyA(szIconFile, pszIconFilePath);
    hr = S_OK;

Exit:
    SAFEDELETEARRAY(pszIconFilePath);
    SAFEDELETEARRAY(pwzIconFile);

    MyTrace("GetIconLocationA - Exit");
    return hr;
}

STDMETHODIMP CExtractIcon::Extract(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge, 
                                                HICON *phiconSmall, UINT nIcons)
{
    LPWSTR  pwzIconFileName = NULL;
    HRESULT hr = E_FAIL;
    
    MyTrace("::ExtractA - Entry");

    if(pszFile && lstrlenA(pszFile)) {
        pwzIconFileName = AnsiToWide(pszFile);
        if(!pwzIconFileName) {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            goto Exit;
        }
    }

    hr = Extract(pwzIconFileName, nIconIndex, phiconLarge, phiconSmall, nIcons);

Exit:
    MyTrace("::ExtractA - Exit");
    SAFEDELETEARRAY(pwzIconFileName);
    return hr;
}

///////////////////////////////////////////////////////////
// IExtractIcon Implementation
STDMETHODIMP CExtractIcon::GetIconLocation(UINT uFlags, LPWSTR szIconFile, 
                                           UINT cchMax, LPINT piIndex, LPUINT puFlags)
{
    // get the module file name
    if( 0 == WszGetModuleFileName(g_hFusResDllMod, szIconFile, cchMax) )
        return HRESULT_FROM_WIN32(GetLastError());

    if (uFlags & GIL_OPENICON) {
        *piIndex = IDI_FOLDEROP;
    }
    else {
        *piIndex = IDI_FOLDER;
    }

    *puFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;
    MAKEICONINDEX(*piIndex);

    return S_OK;
}

STDMETHODIMP CExtractIcon::Extract(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                   HICON *phiconSmall, UINT nIconSize)
{
    MyTrace("ExtractW - Entry");
    if (m_pidl)
    {
        LPITEMIDLIST pidlLast = m_pPidlMgr->GetLastItem(m_pidl);
        if (pidlLast)
        {
            switch (m_pPidlMgr->getType(pidlLast))
            {
            case PT_GLOBAL_CACHE:
            case PT_DOWNLOADSIMPLE_CACHE:
            case PT_DOWNLOADSTRONG_CACHE:
            case PT_DOWNLOAD_CACHE:
                {
                    *phiconLarge = ImageList_GetIcon(g_hImageListLarge, nIconIndex, ILD_TRANSPARENT);
                    *phiconSmall = ImageList_GetIcon(g_hImageListSmall, nIconIndex, ILD_TRANSPARENT);
                }
                break;
/*          case PT_FILE:
                {
                    SHFILEINFO  sfi = { 0 };
                    HIMAGELIST  hImageListLarge, hImageListSmall;
                    TCHAR       szPath[_MAX_PATH];
                    TCHAR       szExt[_MAX_PATH];
                    PTCHAR      psz;

                    m_pPidlMgr->getPidlPath(pidlLast, szPath, ARRAYSIZE(szPath));
                    psz = StrChr(szPath, '.');
                    memset(&szExt, 0, ARRAYSIZE(szExt));
                    if (psz)
                        StrCpy(szExt, psz);

                    hImageListLarge = (HIMAGELIST) SHGetFileInfo(szExt, FILE_ATTRIBUTE_NORMAL,
                                                        &sfi, sizeof(sfi),  SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_SYSICONINDEX);
                    if (hImageListLarge)
                        *phiconLarge = ImageList_GetIcon(hImageListLarge, sfi.iIcon, ILD_TRANSPARENT);

                    hImageListSmall = (HIMAGELIST) SHGetFileInfo(szExt, FILE_ATTRIBUTE_NORMAL,
                                                        &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_SMALLICON|SHGFI_SYSICONINDEX);
                    if (hImageListSmall)
                        *phiconSmall = ImageList_GetIcon(hImageListSmall, sfi.iIcon, ILD_TRANSPARENT);
                }
                break;
*/
            case PT_INVALID:
                {
                }
                break;
            }
        }
    }

    MyTrace("ExtractW - Exit");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\enumidl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// EnumIDL.h
//

#ifndef _ENUMIDLIST_H_
#define _ENUMIDLIST_H_

typedef enum tagMYPIDLTYPE
{
    PT_GLOBAL_CACHE         = 0x00,
	PT_DOWNLOADSIMPLE_CACHE	= 0x01,
	PT_DOWNLOADSTRONG_CACHE	= 0x02,
	PT_DOWNLOAD_CACHE       = 0x03,
    PT_FILE                 = 0x04,
    PT_INVALID              = 0x05,
}MYPIDLTYPE;

typedef struct tagMYPIDLDATA
{
	MYPIDLTYPE	pidlType;
	DWORD		dwSizeHigh;
	DWORD		dwSizeLow;
	DWORD		dwAttribs;
	FILETIME	ftLastWriteTime;
	UINT		uiSizeFile;
	UINT		uiSizeType;
	// uiSizeFile, uiSizeType contain the size of 
	// File & Type strings from szFileAndType
	WCHAR		szFileAndType[1];
}MYPIDLDATA, FAR *LPMYPIDLDATA;

////////////////////////////////////////////////////
// CPidlMgr : Class for managing Pidls
class CPidlMgr  
{
public:
	CPidlMgr ();
	~CPidlMgr ();
public:
	void			Delete(LPITEMIDLIST);
	LPITEMIDLIST	GetNextItem(LPCITEMIDLIST);
	LPITEMIDLIST	Copy(LPCITEMIDLIST);
	UINT			GetSize(LPCITEMIDLIST);
	LPMYPIDLDATA	GetDataPointer(LPCITEMIDLIST pidl);
	LPITEMIDLIST	GetLastItem(LPCITEMIDLIST pidl);
	LPITEMIDLIST	Concatenate(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // Implemenation specific helper functions
public:
	void			getPidlPath(LPCITEMIDLIST pidl, PTCHAR pwszText, UINT uSize);
	void			getItemText(LPCITEMIDLIST, PTCHAR, UINT);
	MYPIDLTYPE		getType(LPCITEMIDLIST);
public:
	LPITEMIDLIST	createRoot(PTCHAR pszRoot, MYPIDLTYPE pidlType);
	LPITEMIDLIST	createFolder(PTCHAR pszFolder, const WIN32_FIND_DATA& ffd);
	LPITEMIDLIST	createFile(PTCHAR pszFile, const WIN32_FIND_DATA& ffd);
	LPITEMIDLIST	createItem(PTCHAR pszItemText, MYPIDLTYPE pidlType,
								const WIN32_FIND_DATA& ffd);
};
typedef CPidlMgr  FAR*	LPPIDLMGR;

////////////////////////////////////////////////////
// CEnumIDList : Class for managing IDLists
typedef struct tagMYENUMLIST
{
	LPITEMIDLIST			pidl;
	struct tagMYENUMLIST	*pNext;
}MYENUMLIST, FAR *LPMYENUMLIST;

class CShellFolder;
class CEnumIDList  : public IEnumIDList
{
public:
	CEnumIDList(CShellFolder *, LPCITEMIDLIST pidl, 
		DWORD dwFlags);
	~CEnumIDList();

	//IUnknown methods
	STDMETHOD (QueryInterface)(REFIID, PVOID *);
	STDMETHOD_ (DWORD, AddRef)();
	STDMETHOD_ (DWORD, Release)();

	//IEnumIDList
	STDMETHOD (Next) (DWORD, LPITEMIDLIST*, LPDWORD);
	STDMETHOD (Skip) (DWORD);
	STDMETHOD (Reset) (void);
	STDMETHOD (Clone) (LPENUMIDLIST*);
protected:
	LONG    m_lRefCount;
private:
	// TODO : Add implementation specific functions to create the IDList
	void createIDList(LPCITEMIDLIST pidl);
	BOOL addToEnumList(LPITEMIDLIST pidl);
	void addFile(WIN32_FIND_DATA& ffd, DWORD);
private:
	LPPIDLMGR	    m_pPidlMgr;
	LPMYENUMLIST	m_pCurrentList;
	LPMYENUMLIST	m_pFirstList;
	LPMYENUMLIST	m_pLastList;
private:
	CShellFolder *m_pSF;
	DWORD			m_dwFlags;
};

#endif //_ENUMIDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\filestream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include "XmlManager.h"
#define UNUSED(x)

CFileStreamBase::~CFileStreamBase()
{
    if (m_hFile != INVALID_HANDLE_VALUE) {
        const DWORD dwLastError = ::GetLastError();
        ::CloseHandle(m_hFile);
        ::SetLastError(dwLastError);
    }
}

BOOL CFileStreamBase::OpenForWrite( LPWSTR pwszPath )
{
    if ( m_hFile != INVALID_HANDLE_VALUE )
        return FALSE;

    m_hFile = ::WszCreateFile(
        pwszPath,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return ( m_hFile != INVALID_HANDLE_VALUE );
}

BOOL CFileStreamBase::OpenForRead( LPWSTR pwszPath)
{
    if ( m_hFile != INVALID_HANDLE_VALUE )
        return false;

    m_hFile = ::WszCreateFile(
        pwszPath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return ( m_hFile != INVALID_HANDLE_VALUE );
}

BOOL CFileStreamBase::Close()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if (!::CloseHandle(m_hFile)) {
            return FALSE;
        }
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

ULONG CFileStreamBase::AddRef()
{
    return ::InterlockedIncrement((LONG *) &m_cRef);
}

ULONG CFileStreamBase::Release(void)
{
    ULONG ulRefCount = 0;
    ulRefCount = ::InterlockedDecrement((LONG *) &m_cRef);
    if ( (ulRefCount == 0) && m_DeleteOnLastRelease ) {
        SAFEDELETETHIS(this);
    }
    return ulRefCount;
}

HRESULT CFileStreamBase::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = NOERROR;

    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL) {
        hr = E_POINTER;
        goto Exit;
    }

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);

    if (pIUnknown == NULL) {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;

    hr = S_OK;

Exit:
    return hr;
}

HRESULT CFileStreamBase::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = NOERROR;
    ULONG cbRead = 0;

    if(pcbRead != NULL)
        *pcbRead = 0;

    if(m_hFile == INVALID_HANDLE_VALUE) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if( !m_bSeenFirstCharacter )
    {
#ifdef AWFUL_SPACE_HACK    
        while ( TRUE )
        {
            CHAR ch;
            ReadFile( m_hFile, &ch, 1, &cbRead, NULL );
            if ( ( ch != '\n' ) && ( ch != '\r' ) && ( ch != ' ' ) && ( ch != '\t' ) ) {
                m_bSeenFirstCharacter = TRUE;
                ::SetFilePointer(m_hFile, -1, NULL, FILE_CURRENT);
                break;
            }
        }
#endif        
    }

    if(!::ReadFile(m_hFile, pv, cb, &cbRead, NULL)) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if(cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if(pcbRead != NULL)
        *pcbRead = cbRead;

Exit:
    return hr;
}

HRESULT CFileStreamBase::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr = NOERROR;
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if(m_hFile == INVALID_HANDLE_VALUE) {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if(!::WriteFile(m_hFile, pv, cb, &cbWritten, NULL)) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if(cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if(pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    return hr;
}

HRESULT CFileStreamBase::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    HRESULT hr = NOERROR;
    DWORD dwWin32Origin = 0;

    if (m_hFile == INVALID_HANDLE_VALUE) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if(g_bRunningOnNT) {
        plibNewPosition->HighPart = 0;
    }

    if(!::SetFilePointer(m_hFile, (LONG) dlibMove.LowPart, (PLONG) plibNewPosition->HighPart, dwWin32Origin)) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CFileStreamBase::SetSize(ULARGE_INTEGER libNewSize)
{
    UNUSED(libNewSize);
    return E_NOTIMPL;
}

HRESULT CFileStreamBase::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT CFileStreamBase::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = NOERROR; 

    if (grfCommitFlags != 0) 
        return E_INVALIDARG; 

    if ( !Close())
        hr = HRESULT_FROM_WIN32 (GetLastError());

    return hr ; 
}

HRESULT CFileStreamBase::Revert()
{
    return E_NOTIMPL;
}

HRESULT CFileStreamBase::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT CFileStreamBase::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT CFileStreamBase::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(STATSTG));

    return E_NOTIMPL;
}

HRESULT CFileStreamBase::Clone(IStream **ppIStream)
{
    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\enumidl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// EnumIDL.cpp
//
// You can implement this interface when you want a caller to be able 
// to enumerate the item identifiers contained in a folder object. 
// You get a pointer to IEnumIDList through IShellFolder::EnumObjects. 

#include "stdinc.h"


#define VIEW_FOLDERNAME_DOWNLOAD        L"Download"

typedef struct tagVIRTUALVIEWS
{
    TCHAR       szCacheTypes[30];
    MYPIDLTYPE  pidlType;
} VIRTUALVIEWS, *LPVIRTUALVIEWS;

// Define virtual view names
VIRTUALVIEWS    vv[PT_INVALID];

CEnumIDList::CEnumIDList(CShellFolder *pSF, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    m_pPidlMgr      = NEW(CPidlMgr);
    m_pSF           = pSF;
    m_dwFlags       = dwFlags;
    m_pCurrentList  = NULL;
    m_pFirstList    = NULL;
    m_pLastList     = NULL;

    m_lRefCount = 1;
    g_uiRefThisDll++;
    memset(&vv, 0, sizeof(vv));
/*
    LoadString(g_hFusResDllMod, IDS_FOLDERNAME_GLOBAL, vv[0].szCacheTypes, ARRAYSIZE(vv[1].szCacheTypes));
    vv[1].pidlType = PT_GLOBAL_CACHE;
    LoadString(g_hFusResDllMod, IDS_FOLDERNAME_PRIVATE, vv[1].szCacheTypes, ARRAYSIZE(vv[2].szCacheTypes));
    vv[2].pidlType = PT_DOWNLOADSIMPLE_CACHE;
    LoadString(g_hFusResDllMod, IDS_FOLDERNAME_SHARED, vv[2].szCacheTypes, ARRAYSIZE(vv[3].szCacheTypes));
    vv[3].pidlType = PT_DOWNLOADSTRONG_CACHE;
*/
    StrCpy(vv[0].szCacheTypes, VIEW_FOLDERNAME_DOWNLOAD);
    vv[0].pidlType = PT_DOWNLOAD_CACHE;
    vv[1].pidlType = PT_INVALID;

    createIDList(pidl);
}

CEnumIDList::~CEnumIDList()
{
    SAFEDELETE(m_pPidlMgr);
    g_uiRefThisDll--;
}

///////////////////////////////////////////////////////////
// IUnknown implementation
//
STDMETHODIMP CEnumIDList::QueryInterface(REFIID riid, PVOID *ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IEnumIDList)) {    //IEnumIDList
        *ppv = (IEnumIDList*) this;
    }

    if (*ppv != NULL) {
        (*(LPUNKNOWN*)ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}                                             

STDMETHODIMP_(DWORD) CEnumIDList::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(DWORD) CEnumIDList::Release()
{
    LONG    uRef = InterlockedDecrement(&m_lRefCount);

    if(!uRef) {
        DELETE(this);
    }

    return uRef;
}

///////////////////////////////////////////////////////////
// IEnumIDList implemenation
//
STDMETHODIMP CEnumIDList::Next(DWORD dwElements, 
    LPITEMIDLIST apidl[], LPDWORD pdwFetched)
{
    DWORD    dwIndex;
    HRESULT  hr = S_OK;

    if(dwElements > 1 && !pdwFetched) {
        return E_INVALIDARG;
    }

    for(dwIndex = 0; dwIndex < dwElements; dwIndex++) {
        if(!m_pCurrentList) {
            hr =  S_FALSE;
            break;
        }
        apidl[dwIndex] = m_pPidlMgr->Copy(m_pCurrentList->pidl);
        m_pCurrentList = m_pCurrentList->pNext;
    }

    if (pdwFetched) {
        *pdwFetched = dwIndex;
    }
    return hr;
}

STDMETHODIMP CEnumIDList::Skip(DWORD dwSkip)
{
    DWORD    dwIndex;
    HRESULT  hr = S_OK;

    for(dwIndex = 0; dwIndex < dwSkip; dwIndex++) {
        if(!m_pCurrentList) {
            hr = S_FALSE;
            break;
        }
        m_pCurrentList = m_pCurrentList->pNext;
    }
    return hr;
}

STDMETHODIMP CEnumIDList::Reset(void)
{
    m_pCurrentList = m_pFirstList;
    return S_OK;
}

STDMETHODIMP CEnumIDList::Clone(LPENUMIDLIST *ppEnum)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////
// Private methods for enumerating...
// TODO : Modify the code to suit your needs
//
void CEnumIDList::createIDList(LPCITEMIDLIST pidl)
{
    // TODO : The following code is just for demonstration purpose only..
    //          Modify the code to suit your needs
    //
    // Mirror the "LocalDir" entry from the HKCR\CLSID\Settings key
    //

    if (pidl == NULL) {
        INT_PTR     i;

        for(i = 0; vv[i].pidlType != PT_INVALID; i++) {
            LPITEMIDLIST pidlLocal = m_pPidlMgr->createRoot(vv[i].szCacheTypes, vv[i].pidlType);
            addToEnumList(pidlLocal);
        }
    }
    else {
        MyTrace("createIDList Start NULL!=pidl");
        HANDLE              hFindFile;
        WIN32_FIND_DATA     ffd = { 0 };
        TCHAR               szSearch[_MAX_PATH];
        BOOL                bRet = TRUE;
        
        m_pPidlMgr->getPidlPath(pidl, szSearch, ARRAYSIZE(szSearch));
        StrCat(szSearch, TEXT("\\*.*"));
        hFindFile = WszFindFirstFile(szSearch, &ffd);

        while (bRet && hFindFile != INVALID_HANDLE_VALUE) {
            if (ffd.cFileName[0] == '.') {
                bRet = WszFindNextFile(hFindFile, &ffd);
                continue;
            }
            addFile(ffd, m_dwFlags);
            bRet = WszFindNextFile(hFindFile, &ffd);
        }
        FindClose(hFindFile);
    }

    MyTrace("createIDList End");
}

void CEnumIDList::addFile(WIN32_FIND_DATA& ffd, DWORD dwFlags)
{
    if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) {
        if ((dwFlags & SHCONTF_FOLDERS) == SHCONTF_FOLDERS) {
            if (ffd.cFileName[0] != '.') {
                TCHAR wsz[_MAX_PATH];
                StrCpy(wsz, ffd.cFileName);

                LPITEMIDLIST pidl = m_pPidlMgr->createFolder(wsz, ffd);
                addToEnumList(pidl);
            }
        }
    }
    else
    {
        if ((dwFlags & SHCONTF_NONFOLDERS) == SHCONTF_NONFOLDERS) {
            TCHAR wsz[_MAX_PATH];
            StrCpy(wsz, ffd.cFileName);

            LPITEMIDLIST pidl = m_pPidlMgr->createFile(wsz, ffd);
            addToEnumList(pidl);
        }
    }
}

BOOL CEnumIDList::addToEnumList(LPITEMIDLIST pidl)
{
    LPMYENUMLIST  pNew;

    MyTrace("::addToEnumList Entry ");

    if( (pNew = (LPMYENUMLIST) NEWMEMORYFORSHELL(sizeof(MYENUMLIST))) != NULL ) {
        pNew->pNext = NULL;
        pNew->pidl = pidl;

        if(!m_pFirstList) {
            m_pFirstList    = pNew;
            m_pCurrentList  = m_pFirstList;
        }

        if (m_pLastList) {
            m_pLastList->pNext = pNew;
        }

        m_pLastList = pNew;

        MyTrace("Exit TRUE");
        return TRUE;
    }
    MyTrace("Exit FALSE");
    return FALSE;
}

////////////////////////////////////////////////////////////////
// CPidlMgr : Class to manage pidls
CPidlMgr::CPidlMgr()
{
}

CPidlMgr::~CPidlMgr()
{
}

void CPidlMgr::Delete(LPITEMIDLIST pidl)
{
    DELETESHELLMEMORY(pidl);
}

LPITEMIDLIST CPidlMgr::GetNextItem(LPCITEMIDLIST pidl)
{
    if (pidl) {
        return (LPITEMIDLIST)(LPBYTE) ( ((LPBYTE)pidl) + pidl->mkid.cb);
    }
    return (NULL);
}

LPITEMIDLIST CPidlMgr::Copy(LPCITEMIDLIST pidlSrc)
{
    LPITEMIDLIST pidlTarget = NULL;
    UINT cbSrc = 0;

    if (NULL == pidlSrc) {
        return (NULL);
    }

    cbSrc = GetSize(pidlSrc);

    if( (pidlTarget = (LPITEMIDLIST) NEWMEMORYFORSHELL(cbSrc)) == NULL) {
        return NULL;
    }

#ifdef DEBUG
    FillMemory(pidlTarget, cbSrc, 0xFF);
#endif

    CopyMemory(pidlTarget, pidlSrc, cbSrc);
    return pidlTarget;
}

UINT CPidlMgr::GetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    LPITEMIDLIST pidlTemp = (LPITEMIDLIST) pidl;

    if(pidlTemp) {
        while(pidlTemp->mkid.cb) {
            cbTotal += pidlTemp->mkid.cb;
            pidlTemp = GetNextItem(pidlTemp);
        }  
        cbTotal += sizeof(ITEMIDLIST);
    }
    return (cbTotal);
}

LPMYPIDLDATA CPidlMgr::GetDataPointer(LPCITEMIDLIST pidl)
{
    if(!pidl) {
        return NULL;
    }
    return (LPMYPIDLDATA)(pidl->mkid.abID);
}

LPITEMIDLIST CPidlMgr::GetLastItem(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST   pidlLast = NULL;

    if(pidl) {
        while(pidl->mkid.cb) {
            pidlLast = (LPITEMIDLIST)pidl;
            pidl = GetNextItem(pidl);
        }  
    }
    return pidlLast;
}

LPITEMIDLIST CPidlMgr::Concatenate(LPCITEMIDLIST pidl1, 
    LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST   pidlNew;
    UINT           cb1 = 0, 
    cb2 = 0;

    if(!pidl1 && !pidl2) {
        return NULL;
    }

    if(!pidl1) {
        pidlNew = Copy(pidl2);
        return pidlNew;
    }

    if(!pidl2) {
        pidlNew = Copy(pidl1);
        return pidlNew;
    }

    cb1 = GetSize(pidl1) - sizeof(ITEMIDLIST);
    cb2 = GetSize(pidl2);

    if( (pidlNew = (LPITEMIDLIST) NEWMEMORYFORSHELL(cb1 + cb2)) != NULL) {
        CopyMemory(pidlNew, pidl1, cb1);
        CopyMemory(((LPBYTE)pidlNew) + cb1, pidl2, cb2);
    }

    return pidlNew;
}

void CPidlMgr::getPidlPath(LPCITEMIDLIST pidl, PTCHAR pszText, UINT uSize)
{
        LPITEMIDLIST pidlTemp = (LPITEMIDLIST) pidl;
        UINT uiCopied = 1;  // set uiCopied to 1 to indicate the NULL character
        pszText[0] = L'\0';

        while (pidlTemp && pidlTemp->mkid.cb && uiCopied < uSize) {
            LPMYPIDLDATA pData = GetDataPointer(pidlTemp);
            uiCopied += lstrlen(pData->szFileAndType);

            if (uiCopied <= uSize)
            {
                StrCat(pszText, pData->szFileAndType);
            }

            pidlTemp = GetNextItem(pidlTemp);
            if (pidlTemp && pidlTemp->mkid.cb) 
            {
                uiCopied++;
                if (uiCopied <= uSize)    
                {
                    StrCat(pszText, TEXT("\\"));
                }
            }
        }
}

MYPIDLTYPE CPidlMgr::getType(LPCITEMIDLIST pidl)
{
    LPMYPIDLDATA pData = GetDataPointer(pidl);
    if (pData) {
        return pData->pidlType;
    }
    return PT_INVALID;
}

LPITEMIDLIST CPidlMgr::createRoot(PTCHAR pszRoot, MYPIDLTYPE pidlType)
{
    WIN32_FIND_DATA ffd = { 0 };
    return createItem(pszRoot, pidlType, ffd);
}

LPITEMIDLIST CPidlMgr::createFolder(PTCHAR pszFolder, const WIN32_FIND_DATA& ffd)
{
    return createItem(pszFolder, PT_INVALID, ffd);
}

LPITEMIDLIST CPidlMgr::createFile(PTCHAR pszFile, const WIN32_FIND_DATA& ffd)
{
    return createItem(pszFile, PT_INVALID, ffd);
}

LPITEMIDLIST CPidlMgr::createItem(PTCHAR pszItemText, MYPIDLTYPE pidlType, const WIN32_FIND_DATA& ffd)
{
    LPMYPIDLDATA    pData;
    LPITEMIDLIST    pidlTemp, pidlNew;
    static TCHAR    szType[] = { TEXT("Root") };
    UINT            uSizeStr, uTotSizeStr, uSize;

    MyTrace("::createItem Start");
    ASSERT(pszItemText);

    uTotSizeStr = uSizeStr = (lstrlen(pszItemText) + 1) * sizeof(TCHAR);
    uTotSizeStr += (lstrlen(szType) + 1) * sizeof(TCHAR);

    uSize = sizeof(ITEMIDLIST) + (sizeof(MYPIDLDATA)) + uTotSizeStr;
    uSize += sizeof(ITEMIDLIST);    // + for the NULL terminating itemIDList

    // Allocate
    if( (pidlNew = (LPITEMIDLIST) NEWMEMORYFORSHELL(uSize)) != NULL) {
        ZeroMemory(pidlNew, uSize);

        pidlTemp = pidlNew;

        //set the size of this item
        pidlTemp->mkid.cb = (USHORT) (uTotSizeStr + sizeof(MYPIDLDATA));

        //set the data for this item
        pData = GetDataPointer(pidlTemp);
        pData->pidlType = pidlType;
        pData->uiSizeFile = uSizeStr;
        CopyMemory(pData->szFileAndType, pszItemText, uSizeStr);

        pData->uiSizeType = lstrlen(szType) * sizeof(TCHAR);

        CopyMemory( (((LPBYTE)pData->szFileAndType) + pData->uiSizeFile), szType, pData->uiSizeType);
    }

    return pidlNew;
}

void CPidlMgr::getItemText(LPCITEMIDLIST pidl, PTCHAR pszText, UINT uSize)
{
    pszText[0] = L'\0';
    if (pidl) {
        LPMYPIDLDATA pData = GetDataPointer(pidl);
        
        if ((UINT)(lstrlen(pData->szFileAndType) + 1) > uSize)
        {
            return;
        }
        StrCpy(pszText, pData->szFileAndType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\filestream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#include <unknwn.h>

class CFileStreamBase : public IStream
{
public:
    CFileStreamBase( BOOL bPoof = TRUE ) 
        : m_cRef(0), 
          m_hFile(INVALID_HANDLE_VALUE), 
          m_bSeenFirstCharacter(FALSE),
          m_DeleteOnLastRelease(bPoof)
    { }
    
    virtual ~CFileStreamBase();

    const static int NoDeleteOnZeroRefs = 1;
    const static int HeapAllocated = 2;
    
    BOOL OpenForRead( LPWSTR pszPath );
    BOOL OpenForWrite( LPWSTR pszPath );

    BOOL Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    ULONG       m_cRef;
    HANDLE      m_hFile;
    BOOL        m_bSeenFirstCharacter;
    BOOL        m_DeleteOnLastRelease;

private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\headerctrl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _HEADERCTRL_H
#define _HEADERCTRL_H

class CHeaderCtrl
{
// Construction
public:
	CHeaderCtrl();

// Attributes
public:
    void AttachToHwnd(HWND hWndListView);
	int GetLastColumn(void);

protected:
	HBITMAP GetArrowBitmap(BOOL bAscending);
	HBITMAP m_up;
	HBITMAP m_down;
	int m_iLastColumn;
	BOOL m_bSortAscending;
    HWND m_hWnd;

// Operations
public:
    void SetColumnHeaderBmp(long index, BOOL bAscending);
	int SetSortImage( int nColumn, BOOL bAscending );
	BOOL RemoveSortImage(int nColumn);
	void RemoveAllSortImages(void);
    int GetCurrentSortColumn(void) { return m_iLastColumn; };
    BOOL GetSortOrder(void) { return m_bSortAscending; };

public:
	virtual ~CHeaderCtrl();
};

#endif   //_HEADERCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\headerctrl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// *****************************************************************
// CHeaderCtrl window
//
#include "stdinc.h"
#include "HeaderCtrl.h"

// *****************************************************************
// CHeaderCtrl
CHeaderCtrl::CHeaderCtrl()
{
    m_hWnd = NULL;
    m_iLastColumn = -1;
}

// *****************************************************************
void CHeaderCtrl::AttachToHwnd(HWND hWndListView)
{
    if(IsWindow(hWndListView)) {
        m_hWnd = hWndListView;

        // Load the default Up/Down sort arrows
        m_up = (HBITMAP) WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDB_BITMAP_UPSORT),
            IMAGE_BITMAP, 0, 0,  LR_LOADMAP3DCOLORS );

        m_down = (HBITMAP) WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDB_BITMAP_DOWNSORT),
            IMAGE_BITMAP, 0, 0,  LR_LOADMAP3DCOLORS );
    }
    else {
        ASSERT(0);
    }
}

// *****************************************************************
CHeaderCtrl::~CHeaderCtrl()
{
    if(m_up) {
        DeleteObject(m_up);
    }

    if(m_down) {
        DeleteObject(m_down);
    }
}

// *****************************************************************
inline HBITMAP CHeaderCtrl::GetArrowBitmap(BOOL bAscending)
{
    if( bAscending ) {
        return m_up;
    }
    else {
        return m_down;
    }

    return NULL;
}

// *****************************************************************
int CHeaderCtrl::SetSortImage(int nColumn, BOOL bAscending)
{
    if(!IsWindow(m_hWnd)) {
        ASSERT(0);
        return -1;
    }

    HWND            hWndLVHeader = ListView_GetHeader(m_hWnd);
    HDITEM          hdi1 = {HDI_BITMAP | HDI_FORMAT, 0, NULL, NULL, 0, 0, 0, 0, 0};
    HDITEM          hdi2 = {HDI_BITMAP | HDI_FORMAT, 0, NULL, NULL, 0, HDF_BITMAP | HDF_BITMAP_ON_RIGHT, 0, 0, 0};

    int nPrevCol = m_iLastColumn;
    m_bSortAscending = bAscending;

    // set the passed column to display the appropriate sort indicator
    Header_GetItem(hWndLVHeader, nColumn, &hdi1);
    hdi2.fmt |= hdi1.fmt;

    // Get the right arrow bitmap
    hdi2.hbm = GetArrowBitmap(bAscending);
    Header_SetItem(hWndLVHeader, nColumn, &hdi2);

    // save off the last column the user clikced on
    m_iLastColumn = nColumn;

    return nPrevCol;
}

// *****************************************************************
void CHeaderCtrl::SetColumnHeaderBmp(long index, BOOL bAscending)
{
    if(!IsWindow(m_hWnd)) {
        ASSERT(0);
        return;
    }

    int nPrevCol = SetSortImage(index, bAscending);

    // If sort columns are different, delete the sort bitmap from
    // the last column
    if (nPrevCol != index && nPrevCol != -1) {
        HWND    hWndLVHeader = ListView_GetHeader(m_hWnd);
        HDITEM  hdi1 = {HDI_BITMAP | HDI_FORMAT, 0, NULL, NULL, 0, 0, 0, 0, 0};

        Header_GetItem(hWndLVHeader, nPrevCol, &hdi1);
        hdi1.fmt &= ~(HDF_BITMAP | HDF_BITMAP_ON_RIGHT);
        hdi1.hbm = NULL;
        Header_SetItem(hWndLVHeader, nPrevCol, &hdi1);
    }
}

// *****************************************************************
BOOL CHeaderCtrl::RemoveSortImage(int nColumn)
{
    if(!IsWindow(m_hWnd)) {
        ASSERT(0);
        return -1;
    }

    // clear the sort indicator from the previous column
    HDITEM      hdi1 = {HDI_BITMAP | HDI_FORMAT, 0, NULL, NULL, 0, 0, 0, 0, 0};
    HWND        hWndLVHeader = ListView_GetHeader(m_hWnd);

    Header_GetItem(hWndLVHeader, nColumn, &hdi1);
    hdi1.fmt &= ~(HDF_BITMAP | HDF_BITMAP_ON_RIGHT);
    hdi1.hbm = NULL;
    return Header_SetItem(hWndLVHeader, nColumn, &hdi1);
}

// *****************************************************************
void CHeaderCtrl::RemoveAllSortImages()
{
    int i = 0;
    while(RemoveSortImage(i++));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\memtracker.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//
//
// NEW / DELETE memory allocator functions
//
//
//

extern LPMALLOC g_pMalloc;

inline HRESULT MemoryStartup() {
    ASSERT(g_pMalloc == NULL);
    return SHGetMalloc(&g_pMalloc);
}

inline void MemoryShutdown() {
    SAFERELEASE(g_pMalloc);
}

#if DBG
static long ulAllocationNumber = 0;

typedef struct tag_tracker
{
    PCSTR File;
    PCSTR Type;
    int line;
    long ulalloc;
    size_t cbSize;
} MEMTRACKER, *LPMEMTRACKER;

inline void __cdecl RawFree(void *p) {
    if (p != NULL)
        g_pMalloc->Free(p);
}

inline void* __cdecl RawAlloc(size_t cb) {
    return g_pMalloc->Alloc(cb);
}

inline void* __cdecl operator new(size_t cbCount, LPCSTR file, int line, LPCSTR Type)
{
    LPMEMTRACKER pt;

    cbCount += sizeof(MEMTRACKER);

    pt = reinterpret_cast<LPMEMTRACKER>(RawAlloc(cbCount));
    pt->Type = Type;
    pt->File = file;
    pt->line = line;
    pt->ulalloc = InterlockedIncrement( &ulAllocationNumber );
    pt->cbSize = cbCount - sizeof(MEMTRACKER);
    return ((BYTE*)pt) + sizeof(MEMTRACKER);
}

inline void* __cdecl operator new(size_t cbCount)
{
    return ::operator new(cbCount, __FILE__, __LINE__, "UnknownType");
}

inline void __cdecl operator delete(void* p)
{
    if(p != NULL) {
        LPMEMTRACKER pt = reinterpret_cast<LPMEMTRACKER>(((BYTE*)p) - sizeof(MEMTRACKER));
        RawFree(pt);
    }
    else {
        OutputDebugStringA("Delete called on NULL value\n");
    }
}

#endif

#undef DELETE
#undef NEW
#undef DELETEARRAY

#if DBG
#define NEW( x ) ( ::new( __FILE__, __LINE__, #x) x )
#define DELETE( x ) ( ::delete(x))
#define DELETEARRAY( x ) (::delete[] (x))

inline void* __cdecl NEWMEMORYFORSHELL(size_t cb)
{
    return RawAlloc(cb);
}
    
inline void __cdecl DELETESHELLMEMORY(void *pv)
{
    RawFree(pv);
}

#else
#define NEW( x ) ( ::new x )
#define DELETE( x ) ( ::delete(x) )
#define DELETEARRAY( x ) (::delete[] (x))

inline void* __cdecl NEWMEMORYFORSHELL(size_t cb)
{
    return g_pMalloc->Alloc(cb);
}
    
inline void __cdecl DELETESHELLMEMORY(void *pv)
{
    (void)g_pMalloc->Free(pv);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\list.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __LIST_H_INCLUDED__
#define __LIST_H_INCLUDED__

//+---------------------------------------------------------------------------
//
//  File:       list.h
//
//  Contents: Quick 'n dirty basic templated list , plist classes.
//
//  History:    04-26-1999      Alan Shi    (AlanShi)      Created.
//              10-25-2000      Fred Aaron  (FredA)        Added struct for PVOID
//              02-08-2001      Fred Aaron  (FredA)        Added pList type
//
//----------------------------------------------------------------------------

//
// ListNode
//

#define STRING_BUFFER               1024

// From Naming.cpp
#define MAX_PUBLIC_KEY_TOKEN_LEN    1024
#define MAX_VERSION_DISPLAY_SIZE    sizeof("65535.65535.65535.65535") + 2

typedef struct tagReferenceInfo {
    WCHAR wzFilePath[STRING_BUFFER];
} ReferenceInfo;

typedef struct tagBindingReferenceInfo {
    LPVOID      pReader;
} BindingReferenceInfo;

typedef struct tagAsmBindDiffs {
    WCHAR wzAssemblyName[STRING_BUFFER];
    WCHAR wzPublicKeyToken[MAX_PUBLIC_KEY_TOKEN_LEN];
    WCHAR wzCulture[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerRef[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerAppCfg[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerPubCfg[MAX_VERSION_DISPLAY_SIZE];
    WCHAR wzVerAdminCfg[MAX_VERSION_DISPLAY_SIZE];
    BOOL  fYesPublisherPolicy;
} AsmBindDiffs;

typedef void * LISTNODE;

template <class Type> class ListNode {
    public:
        ListNode(Type item);
        virtual ~ListNode();

        void SetNext(ListNode *pNode);
        void SetPrev(ListNode *pNode);
        Type GetItem();
        ListNode *GetNext();
        ListNode *GetPrev();

    private:
        DWORD               _dwSig;
        Type                _type;
        ListNode           *_pNext;
        ListNode           *_pPrev;
};

//
// List class
//
template <class Type> class List {
    public:
        List();
        ~List();

        LISTNODE AddHead(const Type &item);
        LISTNODE AddTail(const Type &item);

        LISTNODE GetHeadPosition();
        LISTNODE GetTailPosition();
        void RemoveAt(LISTNODE pNode);
        void RemoveAll();
        LISTNODE Find(const Type &item);
        int GetCount();
        Type GetNext(LISTNODE &pNode);
        Type GetAt(LISTNODE pNode);

    public:
        DWORD                            _dwSig;

    private:
        ListNode<Type>                  *_pHead;
        ListNode<Type>                  *_pTail;
        int                              _iCount;
};

//
// ListNode Implementation
//

template <class Type> ListNode<Type>::ListNode(Type item)
: _pNext(NULL)
, _pPrev(NULL)
, _type(item)
{
    _dwSig = 'EDON';
}

template <class Type> ListNode<Type>::~ListNode()
{
//    SAFEDELETE(_type);
}

template <class Type> void ListNode<Type>::SetNext(ListNode *pNode)
{
    _pNext = pNode;
}

template <class Type> void ListNode<Type>::SetPrev(ListNode *pNode)
{
    _pPrev = pNode;
}

template <class Type> Type ListNode<Type>::GetItem()
{
    return _type;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetNext()
{
    return _pNext;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetPrev()
{
    return _pPrev;
}


//
// List Implementation
//
template <class Type> List<Type>::List()
: _pHead(NULL)
, _pTail(NULL)
, _iCount(0)
{
    _dwSig = 'TSIL';
}

template <class Type> List<Type>::~List()
{
    RemoveAll();
}

template <class Type> LISTNODE List<Type>::AddHead(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;

    pNode = NEW(ListNode<Type>(item));
    if (pNode) {
        _iCount++;
       pNode->SetNext(_pHead);
       pNode->SetPrev(NULL);
       if (_pHead == NULL) {
           _pTail = pNode;
       }
       else {
           _pHead->SetPrev(pNode);
       }
       _pHead = pNode;
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddTail(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;
    
    pNode = NEW(ListNode<Type>(item));
    if (pNode) {
        _iCount++;
        if (_pTail) {
            pNode->SetPrev(_pTail);
            _pTail->SetNext(pNode);
            _pTail = pNode;
        }
        else {
            _pHead = _pTail = pNode;
        }
    }

    return (LISTNODE)pNode;
}

template <class Type> int List<Type>::GetCount()
{
    return _iCount;
}

template <class Type> LISTNODE List<Type>::GetHeadPosition()
{
    return (LISTNODE)_pHead;
}

template <class Type> LISTNODE List<Type>::GetTailPosition()
{
    return (LISTNODE)_pTail;
}

template <class Type> Type List<Type>::GetNext(LISTNODE &pNode)
{
    Type                  item;
    ListNode<Type>       *pListNode = (ListNode<Type> *)pNode;

    // Faults if you pass NULL
    item = pListNode->GetItem();
    pNode = (LISTNODE)(pListNode->GetNext());

    return item;
}

template <class Type> void List<Type>::RemoveAll()
{
    int                        i;
    LISTNODE                   listNode = NULL;
    ListNode<Type>            *pDelNode = NULL;

    listNode = GetHeadPosition();

    for (i = 0; i < _iCount; i++) {
        pDelNode = (ListNode<Type> *)listNode;
        GetNext(listNode);
        SAFEDELETE(pDelNode);
    }
    
    _iCount = 0;
    _pHead = NULL;
    _pTail = NULL;
}

template <class Type> void List<Type>::RemoveAt(LISTNODE pNode)
{
    ListNode<Type>           *pListNode = (ListNode<Type> *)pNode;
    ListNode<Type>           *pPrevNode = NULL;
    ListNode<Type>           *pNextNode = NULL;

    if (pNode) {
        pPrevNode = pListNode->GetPrev();
        pNextNode = pListNode->GetNext();

        if (pPrevNode) {
            pPrevNode->SetNext(pNextNode);
            if (pNextNode) {
                pNextNode->SetPrev(pPrevNode);
            }
            else {
                // We're removing the last node, so we have a new tail
                _pTail = pPrevNode;
            }
            SAFEDELETE(pNode);
        }
        else {
            // No previous, so we are the head of the list
            _pHead = pNextNode;
            if (pNextNode) {
                pNextNode->SetPrev(NULL);
            }
            else {
                // No previous, or next. There was only one node.
                _pHead = NULL;
                _pTail = NULL;
            }
            SAFEDELETE(pNode);
        }

        _iCount--;
    }
}
        
template <class Type> LISTNODE List<Type>::Find(const Type &item)
{
    int                      i;
    Type                     curItem;
    LISTNODE                 pNode = NULL;
    LISTNODE                 pMatchNode = NULL;
    ListNode<Type> *         pListNode = NULL;

    pNode = GetHeadPosition();
    for (i = 0; i < _iCount; i++) {
        pListNode = (ListNode<Type> *)pNode;
        curItem = GetNext(pNode);
        if (curItem == item) {
            pMatchNode = (LISTNODE)pListNode;
            break;
        }
    }

    return pMatchNode;
}

template <class Type> Type List<Type>::GetAt(LISTNODE pNode)
{
    ListNode<Type>                *pListNode = (ListNode<Type> *)pNode;

    // Faults if pListNode == NULL
    return pListNode->GetItem();
}

template <class Type> class CpListNode {
    public:
        CpListNode(Type item);
        virtual ~CpListNode();

        void SetNext(CpListNode *pNode);
        void SetPrev(CpListNode *pNode);
        Type GetItem();
        CpListNode *GetNext();
        CpListNode *GetPrev();

    private:
        DWORD               _dwSig1;
        DWORD               _dwSig2;
        Type                _type;
        CpListNode           *_pNext;
        CpListNode           *_pPrev;
};

//
// CpList
//
template <class Type> class CpList {
    public:
        CpList();
        ~CpList();

        LISTNODE AddHead(const Type &item);
        LISTNODE AddTail(const Type &item);

        LISTNODE GetHeadPosition();
        LISTNODE GetTailPosition();
        void RemoveAt(LISTNODE pNode);
        void RemoveAll();
        LISTNODE Find(const Type &item);
        int GetCount();
        Type GetNext(LISTNODE &pNode);
        Type GetAt(LISTNODE pNode);

    public:
        DWORD               _dwSig1;
        DWORD               _dwSig2;

    private:
        CpListNode<Type>                  *_pHead;
        CpListNode<Type>                  *_pTail;
        int                              _iCount;
};

//
// CpListNode Implementation
//
template <class Type> CpListNode<Type>::CpListNode(Type item)
: _pNext(NULL)
, _pPrev(NULL)
, _type(item)
{
    _dwSig1 = 'EDON';
    _dwSig2 = 'PC  ';
}

template <class Type> CpListNode<Type>::~CpListNode()
{
    SAFEDELETE(_type);
}

template <class Type> void CpListNode<Type>::SetNext(CpListNode *pNode)
{
    _pNext = pNode;
}

template <class Type> void CpListNode<Type>::SetPrev(CpListNode *pNode)
{
    _pPrev = pNode;
}

template <class Type> Type CpListNode<Type>::GetItem()
{
    return _type;
}

template <class Type> CpListNode<Type> *CpListNode<Type>::GetNext()
{
    return _pNext;
}

template <class Type> CpListNode<Type> *CpListNode<Type>::GetPrev()
{
    return _pPrev;
}


//
// List Implementation
//
template <class Type> CpList<Type>::CpList()
: _pHead(NULL)
, _pTail(NULL)
, _iCount(0)
{
    _dwSig1 = 'TSIL';
    _dwSig2 = 'PC  ';
}

template <class Type> CpList<Type>::~CpList()
{
    RemoveAll();
}

template <class Type> LISTNODE CpList<Type>::AddHead(const Type &item)
{
    CpListNode<Type>                   *pNode = NULL;

    pNode = NEW(CpListNode<Type>(item));
    if (pNode) {
        _iCount++;
       pNode->SetNext(_pHead);
       pNode->SetPrev(NULL);
       if (_pHead == NULL) {
           _pTail = pNode;
       }
       else {
           _pHead->SetPrev(pNode);
       }
       _pHead = pNode;
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE CpList<Type>::AddTail(const Type &item)
{
    CpListNode<Type>                   *pNode = NULL;
    
    pNode = NEW(CpListNode<Type>(item));
    if (pNode) {
        _iCount++;
        if (_pTail) {
            pNode->SetPrev(_pTail);
            _pTail->SetNext(pNode);
            _pTail = pNode;
        }
        else {
            _pHead = _pTail = pNode;
        }
    }

    return (LISTNODE)pNode;
}

template <class Type> int CpList<Type>::GetCount()
{
    return _iCount;
}

template <class Type> LISTNODE CpList<Type>::GetHeadPosition()
{
    return (LISTNODE)_pHead;
}

template <class Type> LISTNODE CpList<Type>::GetTailPosition()
{
    return (LISTNODE)_pTail;
}

template <class Type> Type CpList<Type>::GetNext(LISTNODE &pNode)
{
    Type                  item;
    CpListNode<Type>      *pListNode = (CpListNode<Type> *)pNode;

    // Faults if you pass NULL
    item = pListNode->GetItem();
    pNode = (LISTNODE)(pListNode->GetNext());

    return item;
}

template <class Type> void CpList<Type>::RemoveAll()
{
    int                        i;
    LISTNODE                   listNode = NULL;
    CpListNode<Type>           *pDelNode = NULL;

    listNode = GetHeadPosition();

    for (i = 0; i < _iCount; i++) {
        pDelNode = (CpListNode<Type> *)listNode;
        GetNext(listNode);
        SAFEDELETE(pDelNode);
    }
    
    _iCount = 0;
    _pHead = NULL;
    _pTail = NULL;
}

template <class Type> void CpList<Type>::RemoveAt(LISTNODE pNode)
{
    CpListNode<Type>           *pListNode = (CpListNode<Type> *)pNode;
    CpListNode<Type>           *pPrevNode = NULL;
    CpListNode<Type>           *pNextNode = NULL;

    if (pNode) {
        pPrevNode = pListNode->GetPrev();
        pNextNode = pListNode->GetNext();

        if (pPrevNode) {
            pPrevNode->SetNext(pNextNode);
            if (pNextNode) {
                pNextNode->SetPrev(pPrevNode);
            }
            else {
                // We're removing the last node, so we have a new tail
                _pTail = pPrevNode;
            }
            SAFEDELETE(pNode);
        }
        else {
            // No previous, so we are the head of the list
            _pHead = pNextNode;
            if (pNextNode) {
                pNextNode->SetPrev(NULL);
            }
            else {
                // No previous, or next. There was only one node.
                _pHead = NULL;
                _pTail = NULL;
            }
            SAFEDELETE(pNode);
        }

        _iCount--;
    }
}
        
template <class Type> LISTNODE CpList<Type>::Find(const Type &item)
{
    int                      i;
    Type                     curItem;
    LISTNODE                 pNode = NULL;
    LISTNODE                 pMatchNode = NULL;
    CpListNode<Type>         *pListNode = NULL;

    pNode = GetHeadPosition();
    for (i = 0; i < _iCount; i++) {
        pListNode = (CpListNode<Type> *)pNode;
        curItem = GetNext(pNode);
        if (curItem == item) {
            pMatchNode = (LISTNODE)pListNode;
            break;
        }
    }

    return pMatchNode;
}

template <class Type> Type CpList<Type>::GetAt(LISTNODE pNode)
{
    CpListNode<Type>        *pListNode = (CpListNode<Type> *)pNode;

    // Faults if pListNode == NULL
    return pListNode->GetItem();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\globals.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Globals.h
//
// Global defines for Shfusion project
//

#pragma once

#undef MyTrace
#undef MyTraceW
#if DBG
  #define MyTrace(x) { WszOutputDebugString(TEXT(x)); WszOutputDebugString(TEXT("\r\n")); }
  #define MyTraceW(x) { WszOutputDebugString(x); WszOutputDebugString(TEXT("\r\n")); }
#else
  #define MyTrace(x)
  #define MyTraceW(x)
#endif

#if !defined(NUMBER_OF)
#define NUMBER_OF(a) (sizeof(a)/sizeof((a)[0]))
#endif

#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { DELETE(p); (p) = NULL; };

#undef SAFEDELETETHIS
#define SAFEDELETETHIS(p) if ((p) != NULL) { DELETE(p); };

#undef SAFERELEASEDELETE
#define SAFERELEASEDELETE(p) if ((p) != NULL) { (p)->Release(); DELETE(p); (p) = NULL; };

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };

#undef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { DELETEARRAY(p); (p) = NULL; };

#undef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#undef ELEMENTSIZE
#define ELEMENTSIZE(a) (sizeof(a[0]))

#undef SAFEDESTROYWINDOW
#define SAFEDESTROYWINDOW(x) { if(x && IsWindow(x)) { DestroyWindow(x); x = NULL; }}

#undef MAKEICONINDEX
#define MAKEICONINDEX(x) { if((x >= IDI_FOLDER) && (x <= IDI_DATE)) { (x) -= IDI_FOLDER; } else { ASSERT(0); x = 0; } }

#undef PAD
#define PAD(x) (((x) > 9) ? TEXT("") : TEXT("0"))

#undef SAFESYSFREESTRING
#define SAFESYSFREESTRING(x) { if(x != NULL) { SysFreeString(x); x = NULL;} }

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

#define NAMESPACEVIEW_CLASS     TEXT("FusionCacheViewerNSClass")
#define SZ_CLSID                TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}")
#define SZ_INFOTOOLTIPKEY       TEXT("InfoTip")
#define SZ_INFOTOOLTIP          TEXT(".NET Framework Assemblies")
#define SZ_INPROCSERVER32       TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\InprocServer32")
#define SZ_LOCALFOLDERSETTINGS  TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\Settings")
#define SZ_DEFAULT              TEXT("")
#define SZ_DEFAULTICON          TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\DefaultIcon")
#define SZ_SERVER               TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\Server")
#define SZ_THREADINGMODEL       TEXT("ThreadingModel")
#define SZ_APARTMENT            TEXT("Apartment")
#define SZ_SHELLFOLDER          TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\ShellFolder")
#define SZ_ATTRIBUTES           TEXT("Attributes")
#define SZ_APPROVED             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define SZ_SHELLEX              TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\shellex")
#define SZ_SHELLEX_CTX          TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\shellex\\ContextMenuHandlers")
#define SZ_CTXMENUHDLR          TEXT("CLSID\\{1D2680C9-0E2A-469d-B787-065558BC7D43}\\shellex\\ContextMenuHandlers\\{1D2680C9-0E2A-469d-B787-065558BC7D43}")
#define SZ_FUSIONPATHNAME       TEXT("\\Assembly")
#define SZ_DESKTOP_INI          TEXT("\\Desktop.ini")
#define SZ_SHFUSION_DLL_NAME    TEXT("Shfusion.dll")
#define SZ_FUSION_DLL_NAME      TEXT("Fusion.dll")
#define SZ_MSCOREE_DLL_NAME     TEXT("Mscoree.dll")
#define SZ_MSCORRC_DLL_NAME     TEXT("Mscorrc.dll")
#define SZ_SHFUSRES_DLL_NAME    TEXT("ShFusRes.dll")
#define SZ_SHELL32_DLL_NAME     TEXT("Shell32.dll")
#define SZ_IMPLEMENTEDINTHISVERSION TEXT("ImplementedInThisVersion")

// Defines ID's for view controls
#define ID_LISTVIEW     1001

// Define ID's for view types
#define VIEW_GLOBAL_CACHE           0
#define VIEW_DOWNLOADSTRONG_CACHE   1
#define VIEW_DOWNLOADSIMPLE_CACHE   2
#define VIEW_DOWNLOAD_CACHE         3
#define VIEW_MAX                    4
#define VIEW_COLUMS_MAX             10

// Define view control styles
#define LISTVIEW_STYLES (WS_CHILD|WS_BORDER|LVS_SHAREIMAGELISTS|LVS_SHOWSELALWAYS)

// Some #defines for context menu handlers
#define ID_ADDLOCALDRIVE 0x0001
#define ID_DELLOCALDRIVE 0x0002

// Number of prop sheets for IAssemblyItems
#define ASSEMBLYITEM_PROPERTY_PAGES     2

// Number of prop sheets for ScavengerSettings
#define SCAVENGER_PROPERTY_PAGES        1

// BUGBUG : Decrease timer once bug is fixed in directDB
#define WATCH_FILE_WAIT_TIMEOUT         750

// Define the number of PATH to watch for file refresh
#define MAX_FILE_PATHS_TO_WATCH         2

// This is done to remove dependencies on SZ_FUSION_DLL_NAME for shell extentsion
// registration.
//
#define CREATEASSEMBLYENUM_FN_NAME          "CreateAssemblyEnum"
#define CREATEASSEMBLYOBJECT_FN_NAME        "CreateAssemblyNameObject"
#define CREATEAPPCTX_FN_NAME                "CreateApplicationContext"
#define GETCORSYSTEMDIRECTORY_FN_NAME       "GetCORSystemDirectory"
#define CREATEASSEMBLYCACHE_FN_NAME         "CreateAssemblyCache"
#define CREATEHISTORYREADERW_FN_NAME        "CreateHistoryReader"
#define GETHISTORYFILEDIRECTORYW_FN_NAME    "GetHistoryFileDirectory"
#define LOOKUPHISTORYASSEMBLY_FN_NAME       "LookupHistoryAssembly"
#define GETCACHEPATH_FN_NAME                "GetCachePath"
#define PREBINDASSEMBLYEX_FN_NAME           "PreBindAssemblyEx"
#define CREATEINSTALLREFERENCEENUM_FN_NAME  "CreateInstallReferenceEnum"
#define GETCORVERSION_FN_NAME               "GetCORVersion"
#define GETREQUESTEDRUNTIMEINFO_FN_NAME     "GetRequestedRuntimeInfo"

// Help file defines
#define SZ_NET_MICROSOFT_HELPFILEINSTALLKEY L"SOFTWARE\\Microsoft\\.NETFramework"
#define SZ_NET_MICROSOFT_HELPFILEPATHKEY    L"sdkInstallRootv1.1"
#define SZ_NET_MICROSOFT_HELPFILENAME       L"cptools.chm"
#define SZ_NET_MICROSOFT_HELPFILEPATH       L"\\docs\\"
#define SZ_NET_MICROSOFT_SHFUSIONTOPIC      L"::/html_chm/cpgrfassemblycacheviewershfusiondll.htm>mainwin"

#define SZ_FUSION_VIEWER_KEY                L"SOFTWARE\\Microsoft\\Fusion"

// Viewer Specific keys
#define SZ_FUSION_DISABLE_VIEWER_NAME       L"DisableCacheViewer"   // Disable viewer special key
#define SZ_FUSION_VIEWER_STATE              L"ViewerAttributes"     // View state information

// ARM hash entry key
#define FUSION_PARENT_KEY                   HKEY_LOCAL_MACHINE
#define SZ_FUSION_NAR_KEY                   L"SOFTWARE\\Microsoft\\Fusion\\.NET Application Restore"
#define SZ_FUSION_NAR_NODESPACESIZE_KEY     L"NodeSpaceSize"
#define SZ_FUSION_NAR_NODESPACECHAR_KEY     L"NodeSpaceChar"

// UI Language define
#define SZ_LANGUAGE_TYPE_NEUTRAL            L"Neutral"

#define SHGETFILEINFOA_FN_NAME              "SHGetFileInfoA"
#define SHGETFILEINFOW_FN_NAME              "SHGetFileInfoW"

// app.config extension
#define CONFIG_EXTENSION                    L".config"

// Path to machine.config
#define MACHINE_CONFIG_PATH                 L"config\\machine.config"

// String defines
#define SZ_VERSION_FORMAT                   L"%ld.%ld.%ld.%ld"

// External prototypes
typedef HRESULT (__stdcall *PFDELASMFROMTRANSCACHE) ( LPCTSTR lpszCmdLine );
typedef HRESULT (__stdcall *PFCREATEASMENUM) (IAssemblyEnum **pEnum, IApplicationContext *pAppCtx, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);
typedef HRESULT (__stdcall *PFCREATEASMNAMEOBJ) (LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);
typedef HRESULT (__stdcall *PFCREATEAPPCTX) (LPASSEMBLYNAME pName, LPAPPLICATIONCONTEXT *ppCtx);
typedef HRESULT (__stdcall *PFADDASSEMBLYTOCACHEA) (HWND hWnd, HINSTANCE hInst, LPSTR pszCmdLine, int nCmdShow);
typedef HRESULT (__stdcall *PFREMOVEASSEMBLYFROMCACHEA) (HWND hWnd, HINSTANCE hInst, LPSTR pszCmdLine, int nCmdShow);
typedef HRESULT (__stdcall *PFNGETCORVERSION)(LPWSTR pbuffer, DWORD cchBuffer, DWORD *dwLength);
typedef HRESULT (__stdcall *PFNGETCORSYSTEMDIRECTORY) (LPWSTR, DWORD, LPDWORD);
typedef HRESULT (__stdcall *PFNCREATEASSEMBLYCACHE) (IAssemblyCache **ppAsmCache, DWORD dwReserved);
typedef HRESULT (__stdcall *PFNCREATEHISTORYREADERW) (LPCWSTR wzFilePath, IHistoryReader **ppHistReader);
typedef HRESULT (__stdcall *PFNGETHISTORYFILEDIRECTORYW) (LPWSTR wzDir, DWORD *pdwSize);
typedef HRESULT (__stdcall *PFNLOOKUPHISTORYASSEMBLYW) (LPCWSTR pwzFilePath, FILETIME *pftActivationDate, LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken, LPCWSTR wzCulture, LPCWSTR pwzVerRef, IHistoryAssembly **pHistAsm);
typedef HRESULT (__stdcall *PFNGETCACHEPATH)(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath);
typedef HRESULT (__stdcall *PFNPREBINDASSEMBLYEX)(IApplicationContext *pAppCtx, IAssemblyName *pName, IAssembly *pAsmParent, LPCWSTR pwzRuntimeVersion, IAssemblyName **ppNamePostPolicy, LPVOID pvReserved);
typedef HRESULT (__stdcall *PFNCREATEINSTALLREFERENCEENUM) (IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);
typedef HRESULT (__stdcall *PFNGETREQUESTEDRUNTIMEINFO) (LPCWSTR pExeName, LPCWSTR pwszVersion, LPCWSTR pConfigurationFile, DWORD startupFlags, DWORD reserved, LPWSTR pDirectory, DWORD dwDirectory, DWORD *dwDirectoryLength, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwlength);

typedef DWORD_PTR (__stdcall *PFNSHGETFILEINFOA) (LPCSTR pwzFilePath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags);
typedef DWORD_PTR (__stdcall *PFNSHGETFILEINFOW) (LPCWSTR pwzFilePath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);

//#include "fusionheap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\filewatch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

// Watch file thread flags
//#define WATCH_FLAGS     FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_SIZE | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_CREATION
#define WATCH_FLAGS     FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES | FILE_NOTIFY_CHANGE_SIZE | FILE_NOTIFY_CHANGE_LAST_WRITE

CShellView  *g_pShellView;

DWORD WatchFilePathsThread(LPVOID lpThreadParameter);

/**************************************************************************
   CreateWatchFusionFileSystem(CShellView *pShellView)
**************************************************************************/
BOOL CreateWatchFusionFileSystem(CShellView *pShellView)
{
    BOOL    bRC = FALSE;
    DWORD   dwThreadId;
    WCHAR   wzZapCacheDir[MAX_PATH];
    WCHAR   wzCacheDir[MAX_PATH];
    WCHAR   wzDownloadCacheDir[MAX_PATH];

    ASSERT(pShellView);
    if(!pShellView) {
        return FALSE;
    }

    *wzZapCacheDir = L'\0';
    *wzCacheDir = L'\0';
    *wzDownloadCacheDir = L'\0';

    g_pShellView = pShellView;

    if(g_hWatchFusionFilesThread != INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    g_fCloseWatchFileThread = FALSE;
    g_dwFileWatchHandles = 0;
    memset(&g_hFileWatchHandles, -1, ARRAYSIZE(g_hFileWatchHandles));

    if(g_hFusionDllMod != NULL) {
        DWORD       dwSize;

        // Get all the cache paths from fusion
        dwSize = sizeof(wzZapCacheDir);
        g_pfGetCachePath(ASM_CACHE_ZAP, wzZapCacheDir, &dwSize);

        dwSize = ARRAYSIZE(wzCacheDir);
        if( SUCCEEDED(g_pfGetCachePath(ASM_CACHE_GAC, wzCacheDir, &dwSize)) ) {
            // Check to see if this path is the same as ZapCacheDir, if so. Null it out
            if(!FusionCompareStringAsFilePath(wzZapCacheDir, wzCacheDir)) {
                *wzCacheDir = L'\0';
            }
        }

        dwSize = ARRAYSIZE(wzDownloadCacheDir);
        if( SUCCEEDED(g_pfGetCachePath(ASM_CACHE_DOWNLOAD, wzDownloadCacheDir, &dwSize)) ) {
            // Check to see if this Download path is the same 
            // as ZapCacheDir or the CacheDir, if so. Null it out
            if(!FusionCompareStringAsFilePath(wzDownloadCacheDir, wzCacheDir) || !FusionCompareStringAsFilePath(wzDownloadCacheDir, wzZapCacheDir)) {
                *wzDownloadCacheDir = L'\0';
            }
        }
    }

    if(lstrlen(wzZapCacheDir)) {
        if( (g_hFileWatchHandles[g_dwFileWatchHandles] = WszFindFirstChangeNotification(wzZapCacheDir, TRUE, WATCH_FLAGS)) ==
            INVALID_HANDLE_VALUE) {
            goto CLEAN_UP;
        }

        g_dwFileWatchHandles++;
    }

    if(lstrlen(wzCacheDir)) {
        if( (g_hFileWatchHandles[g_dwFileWatchHandles] = WszFindFirstChangeNotification(wzCacheDir, TRUE, WATCH_FLAGS)) ==
            INVALID_HANDLE_VALUE) {
            goto CLEAN_UP;
        }

        g_dwFileWatchHandles++;
    }

    if(lstrlen(wzDownloadCacheDir)) {
        if( (g_hFileWatchHandles[g_dwFileWatchHandles] = WszFindFirstChangeNotification(wzDownloadCacheDir, TRUE, WATCH_FLAGS)) ==
            INVALID_HANDLE_VALUE) {
            goto CLEAN_UP;
        }

        g_dwFileWatchHandles++;
    }

    if( (g_hWatchFusionFilesThread = CreateThread( NULL, 0,
        (LPTHREAD_START_ROUTINE)WatchFilePathsThread,(LPVOID) &g_fCloseWatchFileThread, 0, &dwThreadId)) == NULL) {
        goto CLEAN_UP;
    }

    // Lower the thread priority
    SetThreadPriority(g_hWatchFusionFilesThread, THREAD_PRIORITY_BELOW_NORMAL);

    return TRUE;

CLEAN_UP:
    int     x;
    for(x=0; x < MAX_FILE_WATCH_HANDLES; x++) {
        if(g_hFileWatchHandles[x] != INVALID_HANDLE_VALUE) {
            FindCloseChangeNotification(g_hFileWatchHandles[x]);
            g_hFileWatchHandles[x] = INVALID_HANDLE_VALUE;
        }
    }

    g_dwFileWatchHandles = 0;

    return bRC;
}

/**************************************************************************
   SetFileWatchShellViewObject(CShellView *pShellView)
**************************************************************************/
void SetFileWatchShellViewObject(CShellView *pShellView)
{
    ASSERT(pShellView);

    if( (g_hWatchFusionFilesThread != INVALID_HANDLE_VALUE) && (pShellView != NULL) ) {
        g_pShellView = pShellView;
    }
}

/**************************************************************************
   CloseWatchFusionFileSystem
**************************************************************************/
void CloseWatchFusionFileSystem(void)
{
    if(g_hWatchFusionFilesThread != INVALID_HANDLE_VALUE)
    {
        DWORD   dwRC = STILL_ACTIVE;

        g_fCloseWatchFileThread = TRUE;

        while(dwRC == STILL_ACTIVE) {
            GetExitCodeThread(g_hWatchFusionFilesThread, &dwRC);
        }

        CloseHandle(g_hWatchFusionFilesThread);
        g_hWatchFusionFilesThread = INVALID_HANDLE_VALUE;

        int     x;
        for(x=0; x < MAX_FILE_WATCH_HANDLES; x++) {
            if(g_hFileWatchHandles[x] != INVALID_HANDLE_VALUE) {
                FindCloseChangeNotification(g_hFileWatchHandles[x]);
                g_hFileWatchHandles[x] = INVALID_HANDLE_VALUE;
            }
        }

        g_dwFileWatchHandles = 0;
    }
}

/**************************************************************************
   WatchFilePathsThread
**************************************************************************/
DWORD WatchFilePathsThread(LPVOID lpThreadParameter)
{
    BOOL            *pfThreadClose = (BOOL *) lpThreadParameter;

    DWORD           dwEventCount = 0;
    BOOL            fExitThread = FALSE;

    // Wait thread termination notification.
    while(!fExitThread)
    {
        DWORD       dwWaitState;
        HWND        hWnd = NULL;

        dwWaitState = WaitForMultipleObjects(g_dwFileWatchHandles, g_hFileWatchHandles, FALSE, WATCH_FILE_WAIT_TIMEOUT);
        if( (dwWaitState >= WAIT_OBJECT_0) && (dwWaitState <= (WAIT_OBJECT_0 + (g_dwFileWatchHandles - 1))) )
        {
            dwEventCount++;
            if(FindNextChangeNotification(g_hFileWatchHandles[dwWaitState]) == FALSE) {
                // One case in where we might hit this is if the an folder under the
                // cache director is deleted. We get the update but we can't enumerate anything
                // because it's nuked.

                // We know that something has changed, so post our last message before we bail
                if(SUCCEEDED(g_pShellView->GetWindow(&hWnd)) ) {
                    if(hWnd && IsWindow(hWnd)) {
                        WszPostMessage(hWnd, WM_COMMAND, MAKEWPARAM(ID_REFRESH_DISPLAY, 0), 0);
                        MyTrace("FileWatch - Cache contents changed, Posted Refresh");
                    }
                }

                WCHAR   wszError[256];
                wnsprintf(wszError, ARRAYSIZE(wszError), L"WatchFilePathsThread - Unexpected termination 0x%0x\r\n", GetLastError());
                MyTraceW(wszError);

                int     x;
                for(x=0; x < MAX_FILE_WATCH_HANDLES; x++) {
                    if(g_hFileWatchHandles[x] != INVALID_HANDLE_VALUE) {
                        FindCloseChangeNotification(g_hFileWatchHandles[x]);
                        g_hFileWatchHandles[x] = INVALID_HANDLE_VALUE;
                    }
                }

                g_dwFileWatchHandles = 0;
                g_hWatchFusionFilesThread = INVALID_HANDLE_VALUE;

                ExitThread(GetLastError());
                break;
            }
        }

        // Do refresh if:
        //      1. WAIT_TIMEOUT
        //      2. We have items to update
        //      3. No delete operations are in progress
        //      4. No Add operations are in progress
        else if( (dwWaitState == WAIT_TIMEOUT) && (dwEventCount) ) {

            dwEventCount = 0;

            if(SUCCEEDED(g_pShellView->GetWindow(&hWnd)) ) {
                if(hWnd && IsWindow(hWnd)) {
                    WszPostMessage(hWnd, WM_COMMAND, MAKEWPARAM(ID_REFRESH_DISPLAY, 0), 0);
                    MyTrace("FileWatch - Cache contents changed, Posted Refresh");
                }
            }
        }

        fExitThread = *pfThreadClose;
    }

    MyTrace("WatchFilePathsThread is closed");

    ExitThread(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\propsheet.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"
#include "HtmlHelp.h"

#define MINIMUM_DOWNLOAD_CACHE_SIZE     1      // In MB
#define MINIMUM_PREJIT_CACHE_SIZE       1      // In MB
#define LAZY_BUFFER_SIZE                1024

// Pie RGB codes
const COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),      // Blue            Free
    RGB(255,   0, 255),      // Red-Blue        Used
    RGB(  0, 128, 200),      // Light Blue      Cache Used
    RGB(  0,   0, 128),      // 1/2 Blue        Shadow Free
    RGB(128,   0, 128),      // 1/2 Red-Blue    Shadow Used
    RGB(  0,  64, 128),      // 1/2 Red-Blue    Shadow Cache Used
};

// Struct define for moving the cache item and shell interfaces around
typedef struct {
    LPGLOBALASMCACHE    pCacheItem;
    CShellFolder        *pSF;
    CShellView          *pSV;
} SHELL_CACHEITEM, *LPSHELL_CACHEITEM;

// Struct define for moving the shell interfaces and drive details around
typedef struct { // dpsp
    PROPSHEETPAGE   psp;
    BOOL            fSheetDirty;

    CShellFolder    *pSF;
    CShellView      *pSV;
    HWND            hDlg;

    // wszDrive will contain the mountpoint (e.g. c:\ or c:\folder\folder2\)
    WCHAR           wszDrive[_MAX_PATH];
    int             iDrive;
    DWORD           dwDriveType;
    UINT            uDriveType;

    // Drive stats
    _int64          qwTot;
    _int64          qwFree;
    _int64          qwUsedCache;

    // Cache stats
    DWORD           dwZapQuotaInGac;
    DWORD           dwDownloadQuota;

    DWORD           dwPieShadowHgt;

} DRIVEPROPSHEETPAGE, *LPDRIVEPROPSHEETPAGE;

typedef struct { // vp
    PROPSHEETPAGE       psp;

    LPGLOBALASMCACHE    pCacheItem;
    CShellFolder        *pSF;
    CShellView          *pSV;

    HWND hDlg;
    LPTSTR pVerBuffer;          // pointer to version data
    WCHAR wzVersionKey[70];     // big enough for anything we need
    struct _VERXLATE
    {
        WORD wLanguage;
        WORD wCodePage;
    } *lpXlate;                 // ptr to translations data
    int cXlate;                 // count of translations
    LPTSTR pszXlate;
    int cchXlateString;
} VERPROPSHEETPAGE, *LPVERPROPSHEETPAGE;

// Function Proto's
HRESULT LookupAssembly(FILETIME *pftMRU, LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken, LPCWSTR pwzVerLookup,
                       IHistoryReader *pReader, List<ReferenceInfo *> *pList);
DWORD   MyGetFileVersionInfoSizeW(LPWSTR pwzFilePath, DWORD *pdwHandle);
BOOL    MyGetFileVersionInfoW(LPWSTR pwzFilePath, DWORD dwHandle, DWORD dwVersionSize, LPVOID pBuf);
BOOL    MyVerQueryValueWrap(const LPVOID pBlock, LPWSTR pwzSubBlock, LPVOID *ppBuf, PUINT puLen);
BOOL    _DrvPrshtInit(LPDRIVEPROPSHEETPAGE pdpsp);
void    _DrvPrshtUpdateSpaceValues(LPDRIVEPROPSHEETPAGE pdpsp);
void    _DrvPrshtDrawItem(LPDRIVEPROPSHEETPAGE pdpsp, const DRAWITEMSTRUCT * lpdi);

/*
// magic undoced explort from version.dll

STDAPI_(BOOL) VerQueryValueIndexW(const void *pBlock, LPTSTR lpSubBlock, DWORD dwIndex, void **ppBuffer, void **ppValue, PUINT puLen);

#ifdef UNICODE
#define VerQueryValueIndex VerQueryValueIndexW
#endif
*/

void FillVersionList(LPVERPROPSHEETPAGE pvp);
LPTSTR GetVersionDatum(LPVERPROPSHEETPAGE pvp, LPCTSTR pszName);
BOOL GetVersionInfo(LPVERPROPSHEETPAGE pvp);
void FreeVersionInfo(LPVERPROPSHEETPAGE pvp);
void VersionPrshtCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

#define WZNULL                  L"\0"

//    The following data structure associates a version stamp datum
//    name (which is not localized) with a string ID.  This is so we
//    can show translations of these names to the user.
struct vertbl {
    TCHAR const *pszName;
    short idString;
};

//   Note that version stamp datum names are NEVER internationalized,
//   so the following literal strings are just fine.
const struct vertbl vernames[] = {

    // For the first NUM_SPECIAL_STRINGS, the second column is the dialog ID.

    { TEXT("LegalCopyright"),   IDD_VERSION_COPYRIGHT },
    { TEXT("FileDescription"),  IDD_VERSION_DESCRIPTION },

    // For the rest, the second column is the string ID.

    { TEXT("Comments"),                 IDS_VN_COMMENTS },
    { TEXT("CompanyName"),              IDS_VN_COMPANYNAME },
    { TEXT("InternalName"),             IDS_VN_INTERNALNAME },
    { TEXT("LegalTrademarks"),          IDS_VN_LEGALTRADEMARKS },
    { TEXT("OriginalFilename"),         IDS_VN_ORIGINALFILENAME },
    { TEXT("PrivateBuild"),             IDS_VN_PRIVATEBUILD },
    { TEXT("ProductName"),              IDS_VN_PRODUCTNAME },
    { TEXT("ProductVersion"),           IDS_VN_PRODUCTVERSION },
    { TEXT("SpecialBuild"),             IDS_VN_SPECIALBUILD }
};

#define NUM_SPECIAL_STRINGS     2
#define VERSTR_MANDATORY        TEXT("FileVersion")
#define VER_KEY_END             25      // length of "\StringFileInfo\xxxxyyyy\" (not localized)
#define MAXMESSAGELEN           (50 + _MAX_PATH * 2)

///////////////////////////////////////////////////////////////////////////////
// Initialize PropertySheet1
void CShellView::InitPropPage1(HWND hDlg, LPARAM lParam)
{
    WCHAR       szText[_MAX_PATH];

    HICON       hIcon;

    WszSetWindowLong(hDlg, DWLP_USER, lParam);
    LPPROPSHEETPAGE     lpPropSheet = (LPPROPSHEETPAGE) WszGetWindowLong(hDlg, DWLP_USER);
    LPSHELL_CACHEITEM   pShellCacheItem = lpPropSheet ? (LPSHELL_CACHEITEM) lpPropSheet->lParam : NULL;

    if(pShellCacheItem != NULL) {
        // draw control icon
        hIcon = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ROOT));
        ASSERT(hIcon != NULL);
        WszSendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);

        WszSetDlgItemText(hDlg, IDC_STATIC_NAME, pShellCacheItem->pCacheItem->pAsmName);
        WszSetDlgItemText(hDlg, IDC_STATIC_CODEBASE, pShellCacheItem->pCacheItem->pCodeBaseUrl);

        if(pShellCacheItem->pCacheItem->pftLastMod != NULL) {
            // Fix 419274, Unicode filenames may contain characters that don't allow the file system to obtain
            //             last mod times. So we need to check to see if these are non zero values before we
            //             attempt to convert and display.
            if(pShellCacheItem->pCacheItem->pftLastMod->dwLowDateTime || pShellCacheItem->pCacheItem->pftLastMod->dwHighDateTime) {
                // Fix 42994, URT: FRA: in assembly properties, the date is US format
                FormatDateString(pShellCacheItem->pCacheItem->pftLastMod, NULL, TRUE, szText, ARRAYSIZE(szText));
                WszSetDlgItemText(hDlg, IDC_STATIC_LASTMODIFIED, szText);
            }
        }

        if(SUCCEEDED(pShellCacheItem->pSV->GetCacheItemRefs(pShellCacheItem->pCacheItem, szText, ARRAYSIZE(szText)))) {
            WszSetDlgItemText(hDlg, IDC_STATIC_REFS, szText);
        }

        wnsprintf(szText, ARRAYSIZE(szText), SZ_VERSION_FORMAT,
            pShellCacheItem->pCacheItem->wMajorVer,
            pShellCacheItem->pCacheItem->wMinorVer,
            pShellCacheItem->pCacheItem->wBldNum,
            pShellCacheItem->pCacheItem->wRevNum);
        WszSetDlgItemText(hDlg, IDC_STATIC_VERSION, szText);

        if((pShellCacheItem->pCacheItem->pCulture) && (lstrlen(pShellCacheItem->pCacheItem->pCulture))) {
            WszSetDlgItemText(hDlg, IDC_STATIC_CULTURE, pShellCacheItem->pCacheItem->pCulture);
        }
        else {
            StrCpy(szText, SZ_LANGUAGE_TYPE_NEUTRAL);
            WszSetDlgItemText(hDlg, IDC_STATIC_CULTURE, szText);
        }
        
        if(pShellCacheItem->pCacheItem->PublicKeyToken.dwSize) {
            BinToUnicodeHex((LPBYTE)pShellCacheItem->pCacheItem->PublicKeyToken.ptr,
                pShellCacheItem->pCacheItem->PublicKeyToken.dwSize, szText);

            WszSetDlgItemText(hDlg, IDC_STATIC_PUBLIC_KEY_TOKEN, szText);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// Initialize PropertySheet2
void CShellView::InitPropPage2(HWND hDlg, LPARAM lParam)
{
    LPPROPSHEETPAGE     lpps = reinterpret_cast<LPPROPSHEETPAGE>(lParam);
    LPVERPROPSHEETPAGE  lpPropSheet = reinterpret_cast<LPVERPROPSHEETPAGE>(lpps ? lpps->lParam : NULL);

    if(lpPropSheet) {
        lpPropSheet->hDlg = hDlg;
        WszSetWindowLong(hDlg, DWLP_USER, lParam);

        if(GetVersionInfo(lpPropSheet)) {
            FillVersionList(lpPropSheet);
        }
    }
}

//
//    Initialize version information for the properties dialog.  The
//    above global variables are initialized by this function, and
//    remain valid (for the specified file only) until FreeVersionInfo
//    is called.

//    The first language we try will be the first item in the
//    "\VarFileInfo\Translations" section;  if there's nothing there,
//    we try the one coded into the IDS_FILEVERSIONKEY resource string.
//    If we can't even load that, we just use English (040904E4).  We
//    also try English with a null codepage (04090000) since many apps
//    were stamped according to an old spec which specified this as
//    the required language instead of 040904E4.

//    GetVersionInfo returns TRUE if the version info was read OK,
//    otherwise FALSE.  If the return is FALSE, the buffer may still
//    have been allocated;  always call FreeVersionInfo to be safe.
BOOL GetVersionInfo(LPVERPROPSHEETPAGE pvp)
{
    UINT    cbValue = 0;
    LPTSTR  pszValue = NULL;
    DWORD   dwHandle;             // version subsystem handle
    DWORD   dwVersionSize;        // size of the version data

    FreeVersionInfo(pvp);

    // cast const -> non const for bad API def
    dwVersionSize = MyGetFileVersionInfoSizeW((LPWSTR)pvp->pCacheItem->pAssemblyFilePath, &dwHandle);

    if (dwVersionSize == 0L)
        return FALSE;           // no version info

    pvp->pVerBuffer = reinterpret_cast<LPWSTR>(NEW(BYTE [dwVersionSize]));
    if (pvp->pVerBuffer == NULL)
        return FALSE;

    // cast const -> non const for bad API def
    if (!MyGetFileVersionInfoW((LPWSTR)pvp->pCacheItem->pAssemblyFilePath, dwHandle, dwVersionSize, pvp->pVerBuffer)) {
        return FALSE;
    }

    // Look for translations
    if (MyVerQueryValueWrap(pvp->pVerBuffer, TEXT("\\VarFileInfo\\Translation"),
        (void **)&pvp->lpXlate, &cbValue) && cbValue) {
        pvp->cXlate = cbValue / sizeof(DWORD);
        pvp->cchXlateString = pvp->cXlate * 64;  // figure 64 chars per lang name
        pvp->pszXlate = NEW(WCHAR[pvp->cchXlateString + 2]);
        memset(pvp->pszXlate, 0, pvp->cchXlateString);
        // failure of above will be handled later
    }
    else {
        pvp->lpXlate = NULL;
    }

    // Try same language as this program
    if (WszLoadString(g_hFusResDllMod, IDS_VN_FILEVERSIONKEY, pvp->wzVersionKey, ARRAYSIZE(pvp->wzVersionKey))) {
        if (GetVersionDatum(pvp, VERSTR_MANDATORY)) {
            return TRUE;
        }
    }

    // Try first language this supports
    if (pvp->lpXlate) {
        wnsprintf(pvp->wzVersionKey, ARRAYSIZE(pvp->wzVersionKey), 
            TEXT("\\StringFileInfo\\%04X%04X\\"), pvp->lpXlate[0].wLanguage, pvp->lpXlate[0].wCodePage);
        if (GetVersionDatum(pvp, VERSTR_MANDATORY)) {   // a required field
            return TRUE;
        }
    }

    // try English, unicode code page
    StrCpy(pvp->wzVersionKey, TEXT("\\StringFileInfo\\040904B0\\"));
    if (GetVersionDatum(pvp, VERSTR_MANDATORY)) {
        return TRUE;
    }

    // try English
    StrCpy(pvp->wzVersionKey, TEXT("\\StringFileInfo\\040904E4\\"));
    if (GetVersionDatum(pvp, VERSTR_MANDATORY)) {
        return TRUE;
    }

    // try English, null codepage
    StrCpy(pvp->wzVersionKey, TEXT("\\StringFileInfo\\04090000\\"));
    if (GetVersionDatum(pvp, VERSTR_MANDATORY)) {
        return TRUE;
    }

    // Could not find FileVersion info in a reasonable format
    return FALSE;
}

//
//    Gets a particular datum about a file.  The file's version info
//    should have already been loaded by GetVersionInfo.  If no datum
//    by the specified name is available, NULL is returned.  The name
//    specified should be just the name of the item itself;  it will
//    be concatenated onto "\StringFileInfo\xxxxyyyy\" automatically.

//    Version datum names are not localized, so it's OK to pass literals
//    such as "FileVersion" to this function.

//    Note that since the returned datum is in a global memory block,
//    the return value of this function is LPSTR, not PSTR.
//
LPTSTR GetVersionDatum(LPVERPROPSHEETPAGE pvp, LPCTSTR pszName)
{
    UINT    cbValue = 0;
    LPTSTR  lpValue;

    if (!pvp->pVerBuffer)
        return NULL;

    StrCpy(pvp->wzVersionKey + VER_KEY_END, pszName);
    MyVerQueryValueWrap(pvp->pVerBuffer, pvp->wzVersionKey, (void **)&lpValue, &cbValue);

    return (cbValue != 0) ? lpValue : NULL;
}

//
//    Fills the version key listbox with all available keys in the
//    StringFileInfo block, and sets the version value text to the
//    value of the first item.
void FillVersionList(LPVERPROPSHEETPAGE pvp)
{
    WCHAR       szStringBase[VER_KEY_END+1];
    WCHAR       szMessage[MAXMESSAGELEN+1];
    VS_FIXEDFILEINFO *pffi = NULL;
    UINT        uOffset;
    UINT        cbValue;
    int         i;
    int         j;
    LRESULT     ldx;

    MyTrace("FillVersionList - Entry");

    HWND hwndLB = GetDlgItem(pvp->hDlg, IDD_VERSION_KEY);
    
    ListBox_ResetContent(hwndLB);
    for (i=0; i < NUM_SPECIAL_STRINGS; ++i) {
        WszSetDlgItemText(pvp->hDlg, vernames[i].idString, WZNULL);
    }
    
    pvp->wzVersionKey[VER_KEY_END] = 0;         // don't copy too much
    StrCpy(szStringBase, pvp->wzVersionKey);   // copy to our buffer
    szStringBase[VER_KEY_END - 1] = 0;          // strip the backslash

    //  Get the binary file version from the VS_FIXEDFILEINFO
    if (MyVerQueryValueWrap(pvp->pVerBuffer, TEXT("\\"), (void **)&pffi, &cbValue) && cbValue) {
        MyTrace("Display Binary Version Info");
        WCHAR szString[128];

        // display the binary version info, not the useless
        // string version (that can be out of sync)

        wnsprintf(szString, ARRAYSIZE(szString), TEXT("%d.%d.%d.%d"),
            HIWORD(pffi->dwFileVersionMS),
            LOWORD(pffi->dwFileVersionMS),
            HIWORD(pffi->dwFileVersionLS),
            LOWORD(pffi->dwFileVersionLS));
        WszSetDlgItemText(pvp->hDlg, IDD_VERSION_FILEVERSION, szString);
    }
 
    // Now iterate through all of the strings
    for (j = 0; j < ARRAYSIZE(vernames); j++) {
        WCHAR   szTemp[256];
        UINT    cbVal = 0;
        LPWSTR  lpValue;

        *szTemp = '\0';

        wnsprintf(szTemp, ARRAYSIZE(szTemp), L"%ls\\%ls", szStringBase, vernames[j].pszName);
        if(MyVerQueryValueWrap(pvp->pVerBuffer, szTemp, (void **)&lpValue, &cbVal)) {
            if (j < NUM_SPECIAL_STRINGS) {
                if(lstrlen(lpValue)) {
                    WszSetDlgItemText(pvp->hDlg, vernames[j].idString, lpValue);
                    if(!g_bRunningOnNT) {
                        SAFEDELETEARRAY(lpValue);
                    }
                }
            }
            else if(cbVal) {
                if(i == ARRAYSIZE(vernames) ||
                    !WszLoadString(g_hFusResDllMod, vernames[j].idString, szMessage, ARRAYSIZE(szMessage))) {
                    StrCpy(szMessage, vernames[j].pszName);
                }
            
                ldx = WszSendMessage(hwndLB, LB_ADDSTRING, 0L, (LPARAM)szMessage);
                if(ldx != LB_ERR) {
                    ListBox_SetItemData(hwndLB, ldx, (DWORD_PTR)lpValue);
                }
            }
        }
    }

    // Now look at the \VarFileInfo\Translations section and add an
    // item for the language(s) this file supports.
    if (pvp->lpXlate == NULL || pvp->pszXlate == NULL)
        goto ErrorExit;
    
    if (!WszLoadString(g_hFusResDllMod, (pvp->cXlate == 1) ? IDS_VN_LANGUAGE : IDS_VN_LANGUAGES,
        szMessage, ARRAYSIZE(szMessage)))
        goto ErrorExit;
    
    ldx = WszSendMessage(hwndLB, LB_ADDSTRING, 0L, (LPARAM)szMessage);
    if (ldx == LB_ERR)
        goto ErrorExit;
    
    uOffset = 0;
    for (i = 0; i < pvp->cXlate; i++) {
        if (uOffset + 2 > (UINT)pvp->cchXlateString)
            break;
        if (i != 0) {
            StrCat(pvp->pszXlate, TEXT(", "));
            uOffset += 2;       // skip over ", "
        }
        if (VerLanguageName(pvp->lpXlate[i].wLanguage, pvp->pszXlate + uOffset, pvp->cchXlateString - uOffset) >
            (DWORD)(pvp->cchXlateString - uOffset))
            break;
        uOffset += lstrlen(pvp->pszXlate + uOffset);
    }

    ListBox_SetItemData(hwndLB, ldx, (LPARAM)(LPTSTR)pvp->pszXlate);

    // Only select if there are items in the listbox
    if(WszSendMessage(hwndLB, LB_GETCOUNT, 0L, 0)) {
        WszSendMessage(hwndLB, LB_SETCURSEL, 0, 0);
        FORWARD_WM_COMMAND(pvp->hDlg, IDD_VERSION_KEY, hwndLB, LBN_SELCHANGE, WszPostMessage);
    }

    MyTrace("FillVersionList - Exit");
    return;

ErrorExit:
    MyTrace("FillVersionList - Exit w/Error");
    return;
}

//
//    Frees global version data about a file.  After this call, all
//    GetVersionDatum calls will return NULL.  To avoid memory leaks,
//    always call this before the main properties dialog exits.
void FreeVersionInfo(LPVERPROPSHEETPAGE pvp)
{
    if(pvp) {
        SAFEDELETEARRAY(pvp->pszXlate);
        SAFEDELETE(pvp->pVerBuffer);
    }
}

void VersionPrshtCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    LPTSTR pszValue;
    int idx;
    
    switch (id) {
    case IDD_VERSION_KEY:
        if (codeNotify != LBN_SELCHANGE) {
            break;
        }
        
        idx = ListBox_GetCurSel(hwndCtl);
        pszValue = (LPTSTR)ListBox_GetItemData(hwndCtl, idx);
        if (pszValue) {
            WszSetDlgItemText(hwnd, IDD_VERSION_VALUE, pszValue);
        }
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Initialize InitScavengerPropPage1
BOOL CShellView::InitScavengerPropPage1(HWND hDlg, LPARAM lParam)
{
    WszSetWindowLong(hDlg, DWLP_USER, lParam);
    ((LPDRIVEPROPSHEETPAGE)lParam)->hDlg = hDlg;
    return _DrvPrshtInit((LPDRIVEPROPSHEETPAGE)lParam);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: _DrvPrshtUpdateSpaceValues
//
// DESCRIPTION:
//    Updates the Used space, Free space and Capacity values on the drive
//    general property page..
//
// NOTE:
//    This function was separated from _DrvPrshtInit because drive space values
//    must be updated after a compression/uncompression operation as well as
//    during dialog initialization.
///////////////////////////////////////////////////////////////////////////////
void _DrvPrshtUpdateSpaceValues(DRIVEPROPSHEETPAGE *pdpsp)
{
    BOOL            fResult = FALSE;
    _int64          qwTot  = 0;
    _int64          qwFree = 0;
    _int64          qwUsedCache = 0;
    ULARGE_INTEGER  qwFreeUser = {0,0};
    ULARGE_INTEGER  qwTotal = {0,0};
    ULARGE_INTEGER  qwTotalFree = {0,0};
    DWORD           dwZapUsed = 0;
    DWORD           dwDownLoadUsed = 0;
    WCHAR           wzTemp[80];
    TCHAR           szFormat[30];

    ASSERT(pdpsp);

    // Get Drive stats
    WCHAR   wzRoot[_MAX_PATH];

    PathBuildRootW(wzRoot, pdpsp->iDrive);
    if(WszGetDiskFreeSpaceEx(wzRoot, &qwFreeUser, &qwTotal, &qwTotalFree)) {
        qwTot = qwTotal.QuadPart;
        qwFree = qwFreeUser.QuadPart;
    }
 
    // Get Cache stats, returned in KB.
    if(SUCCEEDED(pdpsp->pSV->GetCacheUsage(&dwZapUsed, &dwDownLoadUsed))) {
        qwUsedCache = ((dwZapUsed + dwDownLoadUsed) * 1024L); // Multiple KB->Bytes
    }

    // Save em off
    pdpsp->qwTot = qwTotal.QuadPart;
    pdpsp->qwFree = qwFreeUser.QuadPart;
    pdpsp->qwUsedCache = qwUsedCache;

    if (WszLoadString(g_hFusResDllMod, IDS_BYTES, szFormat, ARRAYSIZE(szFormat))) {
        TCHAR szTemp2[30];

        // NT must be able to display 64-bit numbers; at least as much
        // as is realistic.  We've made the decision
        // that volumes up to 100 Terrabytes will display the byte value
        // and the short-format value.  Volumes of greater size will display
        // "---" in the byte field and the short-format value.  Note that the
        // short format is always displayed.
        //
        const _int64 MaxDisplayNumber = 99999999999999; // 100TB - 1.
        if (qwTot-qwFree <= MaxDisplayNumber) {
            wnsprintf(wzTemp, ARRAYSIZE(wzTemp), szFormat, AddCommas64(qwTot - qwFree, szTemp2, ARRAYSIZE(szTemp2)));
            WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_USEDBYTES, wzTemp);
        }

        if (qwUsedCache <= MaxDisplayNumber) {
            wnsprintf(wzTemp, ARRAYSIZE(wzTemp), szFormat, AddCommas64(qwUsedCache, szTemp2, ARRAYSIZE(szTemp2)));
            WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_CACHEBYTES, wzTemp);
        }

        if (qwFree <= MaxDisplayNumber) {
            wnsprintf(wzTemp, ARRAYSIZE(wzTemp), szFormat, AddCommas64(qwFree, szTemp2, ARRAYSIZE(szTemp2)));
            WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_FREEBYTES, wzTemp);
        }

        if (qwTot <= MaxDisplayNumber) {
            wnsprintf(wzTemp, ARRAYSIZE(wzTemp), szFormat, AddCommas64(qwTot, szTemp2, ARRAYSIZE(szTemp2)));
            WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_TOTBYTES, wzTemp);
        }
    }

    StrFormatByteSizeW(qwTot-qwFree, wzTemp, ARRAYSIZE(wzTemp), FALSE);
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_USEDMB, wzTemp);

    StrFormatByteSizeW(qwUsedCache, wzTemp, ARRAYSIZE(wzTemp), FALSE);
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_CACHEMB, wzTemp);

    StrFormatByteSizeW(qwFree, wzTemp, ARRAYSIZE(wzTemp), FALSE);
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_FREEMB, wzTemp);

    StrFormatByteSizeW(qwTot, wzTemp, ARRAYSIZE(wzTemp), FALSE);
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_TOTMB, wzTemp);

    // Use MB for the size identifier for spin control
    WszLoadString(g_hFusResDllMod, IDS_ORDERMB, szFormat, ARRAYSIZE(szFormat));

    // wnsprintfW AV's when we don't pass in args
    wnsprintf(wzTemp, ARRAYSIZE(wzTemp), szFormat, L"");

    WszSetDlgItemText(pdpsp->hDlg, IDC_PREJIT_TYPE, wzTemp);
    WszSetDlgItemText(pdpsp->hDlg, IDC_DOWNLOAD_TYPE, wzTemp);
}

BOOL _DrvPrshtInit(LPDRIVEPROPSHEETPAGE pdpsp)
{
    WCHAR   szFormat[30];
    WCHAR   szTemp[80];
    WCHAR   wzRoot[_MAX_PATH];  //now can contain a folder name as a mounting point
    SIZE    size;
    DWORD   dwVolumeSerialNumber, dwMaxFileNameLength, dwFileSystemFlags;
    WCHAR   wzVolumeName[_MAX_PATH];
    WCHAR   wzFileSystemName[_MAX_PATH];

    HCURSOR hcOld = SetCursor(WszLoadCursor(NULL, IDC_WAIT));
    HDC hDC = GetDC(pdpsp->hDlg);
    GetTextExtentPoint(hDC, TEXT("W"), 1, &size);
    pdpsp->dwPieShadowHgt = size.cy * 2 / 3;
    ReleaseDC(pdpsp->hDlg, hDC);

    *pdpsp->wszDrive = L'\0';
    *wzVolumeName = L'\0';
    *wzFileSystemName = L'\0';

    // Get Download assembly path from fusion
    if(g_hFusionDllMod != NULL) {
        WCHAR       wzCacheDir[MAX_PATH];
        DWORD       dwSize = sizeof(wzCacheDir);

        if( SUCCEEDED(g_pfGetCachePath(ASM_CACHE_DOWNLOAD, wzCacheDir, &dwSize)) ) {
            StrCpy(pdpsp->wszDrive, wzCacheDir);
        }
    }

    // Don't allow UNC's past this point
    // Fix 439573 - Clicking on Configure Cache Settings crashes explorer if the cahce is on a UNC path.
    //   All our call's are based on a int that represents the drive letter, hence the AV in the
    //   first strcpy. So disallow all UNC references since it's not a supported case at this point
    if(*pdpsp->wszDrive == L'\\') {
        return FALSE;
    }

    // Get %windir%
    if(!*pdpsp->wszDrive) {
        if(!WszGetWindowsDirectory(pdpsp->wszDrive, ARRAYSIZE(pdpsp->wszDrive))) {
            return FALSE;
        }
    }

    pdpsp->iDrive = towupper(*pdpsp->wszDrive) - L'A';
    PathBuildRoot(wzRoot, pdpsp->iDrive);
    WszGetVolumeInformation(wzRoot, wzVolumeName, ARRAYSIZE(wzVolumeName), &dwVolumeSerialNumber, &dwMaxFileNameLength,
        &dwFileSystemFlags, wzFileSystemName, ARRAYSIZE(wzFileSystemName));

    // Set the icon image for the drive
    SHFILEINFO      sfi = {0};
    HIMAGELIST him = reinterpret_cast<HIMAGELIST>(MySHGetFileInfoWrap(wzRoot, 0, &sfi,
        sizeof(SHFILEINFO), SHGFI_SYSICONINDEX | SHGFI_ICON | SHGFI_SHELLICONSIZE));
    if(him) {
        HICON   hIcon = ImageList_GetIcon(him, sfi.iIcon, ILD_TRANSPARENT);
        WszSendDlgItemMessage(pdpsp->hDlg, IDC_DRV_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    // Set the drive label
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_LABEL, wzVolumeName);

    // Set the drive type
    pdpsp->uDriveType = GetSHIDType(TRUE, wzRoot);
    GetTypeString((INT)pdpsp->uDriveType, szTemp, ARRAYSIZE(szTemp));
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_TYPE, szTemp);

    // Set file system type
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_FS, wzFileSystemName);

    // Get the drive details
    _DrvPrshtUpdateSpaceValues(pdpsp);

    WszLoadString(g_hFusResDllMod, IDS_DRIVELETTER, szFormat, ARRAYSIZE(szFormat));
    wnsprintf(szTemp, ARRAYSIZE(szTemp), szFormat, pdpsp->iDrive + L'A');
    WszSetDlgItemText(pdpsp->hDlg, IDC_DRV_LETTER, szTemp);

    // Get the Quota's for the cache
    DWORD   dwAdminQuota = 0;

    ASSERT(pdpsp->pSV);
    if(SUCCEEDED(pdpsp->pSV->GetCacheDiskQuotas(&pdpsp->dwZapQuotaInGac, &dwAdminQuota, &pdpsp->dwDownloadQuota)))
    {
        if(IsAdministrator())
            pdpsp->dwDownloadQuota = dwAdminQuota;
    }

    // Get the total size of drive or the max cache size in MB
    UINT    uIntMaxSize = (UINT) max( ((pdpsp->qwTot / 1024) / 1024), 1);
    UINT    uIntCurrent;

    // Currently being set in kb, change to MB
    uIntCurrent = min(pdpsp->dwZapQuotaInGac / 1024L, pdpsp->dwZapQuotaInGac);

    WszSendDlgItemMessage(pdpsp->hDlg, IDC_PREJIT_SIZE_SPIN, UDM_SETBUDDY,
        (WPARAM) (HWND) GetDlgItem(pdpsp->hDlg, IDC_PREJIT_SIZE), 0);
    WszSendDlgItemMessage(pdpsp->hDlg, IDC_PREJIT_SIZE_SPIN, UDM_SETRANGE, 0,
        (LPARAM) MAKELONG((short) uIntMaxSize, (short) MINIMUM_PREJIT_CACHE_SIZE));
    WszSendDlgItemMessage(pdpsp->hDlg, IDC_PREJIT_SIZE_SPIN, UDM_SETPOS, 0,
        (LPARAM) MAKELONG((short) uIntCurrent, (short) 0)); 

    // Currently being set in kb, change to MB
    uIntCurrent = min(pdpsp->dwDownloadQuota / 1024L, pdpsp->dwDownloadQuota);

    WszSendDlgItemMessage(pdpsp->hDlg, IDC_DOWNLOAD_SIZE_SPIN, UDM_SETBUDDY, 
        (WPARAM) (HWND) GetDlgItem(pdpsp->hDlg, IDC_DOWNLOAD_SIZE), 0);
    WszSendDlgItemMessage(pdpsp->hDlg, IDC_DOWNLOAD_SIZE_SPIN, UDM_SETRANGE, 0, 
        (LPARAM) MAKELONG((short) uIntMaxSize, (short) MINIMUM_DOWNLOAD_CACHE_SIZE)); 
    WszSendDlgItemMessage(pdpsp->hDlg, IDC_DOWNLOAD_SIZE_SPIN, UDM_SETPOS, 0, 
        (LPARAM) MAKELONG((short) uIntCurrent, (short) 0));

    // BUGBUG: Disable Prejit controls because they don't want
    //         users to be able to scavenge out prejit items.
    //
    //         Need to remove controls once decision is finialized
    ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_STORE_PREJIT_TXT), FALSE);
    ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_PREJIT_SIZE), FALSE);
    ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_PREJIT_SIZE_SPIN), FALSE);
    ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_PREJIT_TYPE), FALSE);

    pdpsp->fSheetDirty = FALSE;

    SetCursor(hcOld);

    return TRUE;
}

// Dialog Proc for PropSheet1
INT_PTR CALLBACK CShellView::PropPage1DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE     lpPropSheet = (LPPROPSHEETPAGE) WszGetWindowLong(hDlg, DWLP_USER);

    switch(message) {
        case WM_HELP:
            if(lpPropSheet->lParam) {
                ((LPSHELL_CACHEITEM)(lpPropSheet->lParam))->pSV->onViewerHelp();
            }
            break;

        case WM_CONTEXTMENU:
            break;
        
        case WM_INITDIALOG:
            InitPropPage1(hDlg, lParam);
            break;            
        
        case WM_NOTIFY:
            OnNotifyPropDlg(hDlg, lParam);
            break;

        case WM_DESTROY: {
                HICON hIcon = (HICON)WszSendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_GETICON, 0, 0);
                if (hIcon != NULL)
                    DestroyIcon(hIcon);
            }
            return FALSE;

        case WM_COMMAND:
            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

// Dialog Proc for PropSheet2
INT_PTR CALLBACK CShellView::PropPage2DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE     lpPropSheet = (LPPROPSHEETPAGE) WszGetWindowLong(hDlg, DWLP_USER);

    switch(message) {
        case WM_HELP:
            if(lpPropSheet->lParam) {
                ((LPSHELL_CACHEITEM)(lpPropSheet->lParam))->pSV->onViewerHelp();
            }
            break;

        case WM_CONTEXTMENU:
            break;
        
        case WM_INITDIALOG:
            InitPropPage2(hDlg, lParam);
            break;

        case WM_NOTIFY:
            OnNotifyPropDlg(hDlg, lParam);
            break;
        
        case WM_DESTROY:
            if(!g_bRunningOnNT) {
                // These were allocated strings / values by W9x wrappers
                HWND hwndLB = GetDlgItem(hDlg, IDD_VERSION_KEY);
                int     i;
                int     iCountOfItems = ListBox_GetCount(hwndLB);

                for(i = 0; i < iCountOfItems; i++) {
                    LRESULT lResult;
                    
                    if( (lResult = ListBox_GetItemData(hwndLB, i)) != LB_ERR) {
                        LPWSTR   lpwStr = (LPWSTR)lResult;
                        SAFEDELETEARRAY(lpwStr);
                    }
                }
            }

            if(lpPropSheet->lParam) {
                FreeVersionInfo((LPVERPROPSHEETPAGE)lpPropSheet->lParam);
            }
            return FALSE;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, VersionPrshtCommand);
            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

// Dialog Proc for Scavenger
INT_PTR CALLBACK CShellView::ScavengerPropPage1DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPDRIVEPROPSHEETPAGE lpDrvPropSheet = (LPDRIVEPROPSHEETPAGE) WszGetWindowLong(hDlg, DWLP_USER);

    switch(message) {
        case WM_HELP:
            if(lpDrvPropSheet->pSV) {
                lpDrvPropSheet->pSV->onViewerHelp();
            }
            break;

        case WM_CONTEXTMENU:
            break;
        
        case WM_DRAWITEM:
            _DrvPrshtDrawItem(lpDrvPropSheet, (DRAWITEMSTRUCT *)lParam);
            break;
        case WM_INITDIALOG:
            return InitScavengerPropPage1(hDlg, lParam);
            break;            
        
        case WM_NOTIFY:
            return OnNotifyScavengerPropDlg(hDlg, lParam);

        case WM_DESTROY:
            return FALSE;

        case WM_COMMAND: {
                switch(LOWORD(wParam)) {
                case IDC_PREJIT_SIZE:
                case IDC_DOWNLOAD_SIZE:
                    if(HIWORD(wParam) == EN_CHANGE) {
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                        if(lpDrvPropSheet) {
                            lpDrvPropSheet->fSheetDirty = TRUE;
                        }
                    }
                    break;
                }
            }
            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

typedef HRESULT (WINAPI *PFNSETLAYOUT) (HDC, DWORD);

void _DrvPrshtDrawItem(LPDRIVEPROPSHEETPAGE pdpsp, const DRAWITEMSTRUCT * lpdi)
{
    switch (lpdi->CtlID) {
    case IDC_DRV_PIE: {
            RECT    rcTemp = lpdi->rcItem;

            DWORD dwPctX10 = 
                pdpsp->qwTot ? (DWORD)((__int64)1000 * (pdpsp->qwTot - pdpsp->qwFree) / pdpsp->qwTot) : 1000;
            DWORD dwPctCacheX10 = 
                pdpsp->qwUsedCache ? (DWORD) ((__int64)1000 * ((pdpsp->qwTot - pdpsp->qwFree) - pdpsp->qwUsedCache) / pdpsp->qwTot) : dwPctX10;

            if(g_fBiDi) {
                HMODULE hMod = LoadLibraryA("gdi32.dll");
                if(hMod) {
                    PFNSETLAYOUT pfnSetLayout = (PFNSETLAYOUT) GetProcAddress(hMod, "SetLayout");
                    if(pfnSetLayout) {
                        pfnSetLayout(lpdi->hDC, LAYOUT_RTL);
                    }

                    FreeLibrary(hMod);
                }
            }

            Draw3dPie(lpdi->hDC, &rcTemp, dwPctX10, dwPctCacheX10, c_crPieColors);
        }
        break;
        
    case IDC_DRV_USEDCOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_USEDCOLOR], &lpdi->rcItem);
        break;
    case IDC_DRV_FREECOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_FREECOLOR], &lpdi->rcItem);
        break;
    case IDC_DRV_CACHECOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_CACHECOLOR], &lpdi->rcItem);
        break;
    default:
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Handles WM_NOTIFY for Assembly Property Sheets
void CShellView::OnNotifyPropDlg(HWND hDlg, LPARAM lParam)
{
    LPPROPSHEETPAGE     lpPropSheet = (LPPROPSHEETPAGE) WszGetWindowLong(hDlg, DWLP_USER);

    switch( ((LPNMHDR)lParam)->code ) {
        case PSN_HELP: {
            if(lpPropSheet->lParam) {
                ((LPSHELL_CACHEITEM)(lpPropSheet->lParam))->pSV->onViewerHelp();
            }
        }
        break;

        case PSN_QUERYINITIALFOCUS:
            WszSetWindowLong(hDlg, DWLP_MSGRESULT, (LPARAM)GetDlgItem(hDlg, IDC_STATIC_ICON));
            break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Handles WM_NOTIFY for Scavenger Property Sheet
INT_PTR CShellView::OnNotifyScavengerPropDlg(HWND hDlg, LPARAM lParam)
{
    LPDRIVEPROPSHEETPAGE lpDrvPropSheet = (LPDRIVEPROPSHEETPAGE) WszGetWindowLong(hDlg, DWLP_USER);

    switch( ((LPNMHDR)lParam)->code ) {
    case PSN_HELP:
    if(lpDrvPropSheet->pSV) {
        lpDrvPropSheet->pSV->onViewerHelp();
    }
    break;

    case PSN_QUERYINITIALFOCUS:
        WszSetWindowLong(hDlg, DWLP_MSGRESULT, (LPARAM)GetDlgItem(hDlg, IDC_STATIC_ICON));
        return TRUE;

    case PSN_APPLY: {
            if(lpDrvPropSheet->fSheetDirty) {
                // Ensure that we stay above minimums, update UI as needed
                UINT    uIntMaxSize = (UINT) max(lpDrvPropSheet->qwTot / 10240L, 1);   // Max in MB

                // Verify Entries
                UINT    uPreJitSize = GetDlgItemInt(hDlg, IDC_PREJIT_SIZE, NULL, FALSE );
                UINT    uDownloadSize = GetDlgItemInt(hDlg, IDC_DOWNLOAD_SIZE, NULL, FALSE);

                if(uPreJitSize < MINIMUM_PREJIT_CACHE_SIZE || uPreJitSize > uIntMaxSize) {
                    WszSendDlgItemMessage(hDlg, IDC_PREJIT_SIZE_SPIN, UDM_SETPOS, 0,
                        (LPARAM) MAKELONG((short) (uPreJitSize > uIntMaxSize ? uIntMaxSize : MINIMUM_PREJIT_CACHE_SIZE),
                        (short) 0));
                    SetDlgItemInt(hDlg, IDC_PREJIT_SIZE, (uPreJitSize > uIntMaxSize ? uIntMaxSize : MINIMUM_PREJIT_CACHE_SIZE), FALSE);
                    uPreJitSize = MINIMUM_PREJIT_CACHE_SIZE;
                }

                if(uDownloadSize < MINIMUM_DOWNLOAD_CACHE_SIZE || uDownloadSize > uIntMaxSize) {
                    WszSendDlgItemMessage(hDlg, IDC_DOWNLOAD_SIZE_SPIN, UDM_SETPOS, 0, 
                        (LPARAM) MAKELONG((short) (uDownloadSize > uIntMaxSize ? uIntMaxSize : MINIMUM_DOWNLOAD_CACHE_SIZE), (short) 0)); 
                    SetDlgItemInt(hDlg, IDC_DOWNLOAD_SIZE, (uDownloadSize > uIntMaxSize ? uIntMaxSize : MINIMUM_DOWNLOAD_CACHE_SIZE), FALSE);
                    uDownloadSize = MINIMUM_DOWNLOAD_CACHE_SIZE;
                }

                // Multiply MB->KB
                uPreJitSize *= 1024L;
                uDownloadSize *= 1024L;

                ASSERT(lpDrvPropSheet->pSV);
                lpDrvPropSheet->pSV->SetCacheDiskQuotas((DWORD) uPreJitSize, (DWORD) uDownloadSize, (DWORD) uDownloadSize);

                if( !(LPPSHNOTIFY)lParam )
                    WszSetWindowLong( hDlg, DWLP_MSGRESULT, TRUE );
                else
                    lpDrvPropSheet->pSV->ScavengeCache();

                lpDrvPropSheet->fSheetDirty = FALSE;
            }
        }
        break;
    
    case PSN_QUERYCANCEL:
    case PSN_KILLACTIVE:
    case PSN_RESET:
        WszSetWindowLong( hDlg, DWLP_MSGRESULT, FALSE );
        return TRUE;

    case UDN_DELTAPOS: {
            lpDrvPropSheet->fSheetDirty = TRUE;
            return TRUE;
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Display Assembly Item property Sheets
void CShellView::CreatePropDialog(HWND hListView)
{
    PROPSHEETPAGE       psp[ASSEMBLYITEM_PROPERTY_PAGES];
    PROPSHEETHEADER     psh = {0};
    SHELL_CACHEITEM     sci = {0};
    VERPROPSHEETPAGE    vps = {0};

    int         iCurrentItem = -1;

    // init cache item struct
    sci.pSF = vps.pSF = m_pSF;
    sci.pSV = vps.pSV = this;

    // init propsheet 1.
    psp[0].dwSize          = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags         = PSP_HASHELP;
    psp[0].hInstance       = g_hFusResDllMod;
    psp[0].pszTemplate     = g_fBiDi ? MAKEINTRESOURCE(IDD_PROP_GENERAL_BIDI) : MAKEINTRESOURCE(IDD_PROP_GENERAL);
    psp[0].pszIcon         = NULL;
    psp[0].pfnDlgProc      = PropPage1DlgProc;
    psp[0].pszTitle        = NULL;
    psp[0].lParam          = (LPARAM) &sci; // send the shell cache item struct

    // init propsheet 2
    psp[1].dwSize          = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags         = PSP_HASHELP;
    psp[1].hInstance       = g_hFusResDllMod;
    psp[1].pszTemplate     = g_fBiDi ? MAKEINTRESOURCE(IDD_PROP_VERSION_BIDI) : MAKEINTRESOURCE(IDD_PROP_VERSION);
    psp[1].pszIcon         = NULL;
    psp[1].pfnDlgProc      = PropPage2DlgProc;
    psp[1].pszTitle        = NULL;
    psp[1].lParam          = (LPARAM) &vps; // send the Version item struct

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW|PSH_PROPTITLE|PSH_HASHELP|PSH_USEHICON;
    psh.hwndParent  = m_hWndParent;
    psh.nStartPage  = 0;
    psh.hIcon       = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ROOT));
    psh.ppsp        = (LPCPROPSHEETPAGE) psp;

    if(g_fBiDi) {
        psh.dwFlags |= PSH_RTLREADING;
    }

    // psh.nPages      = ASSEMBLYITEM_PROPERTY_PAGES; is now set
    // below depending on if we obtained a filepath

    switch(m_iCurrentView) {
        case VIEW_GLOBAL_CACHE:
        case VIEW_DOWNLOAD_CACHE:
        case VIEW_DOWNLOADSTRONG_CACHE:
        case VIEW_DOWNLOADSIMPLE_CACHE: {
            INT_PTR     iRC = PSNRET_INVALID;
            HDESK       hInputDesktop = NULL;

            m_fPropertiesDisplayed = TRUE;

            if(g_bRunningOnNT) {
                hInputDesktop = OpenInputDesktop (0, FALSE, DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU);
            }

            while( ((iCurrentItem = ListView_GetNextItem(hListView, iCurrentItem, LVNI_SELECTED)) != -1) &&
                (iRC == PSNRET_INVALID) ) {
                
                // Found a selected Item
                LV_ITEM     lvi = { 0 };

                lvi.mask        = LVIF_PARAM;
                lvi.iItem       = iCurrentItem;

                if( WszListView_GetItem(hListView, &lvi) && (lvi.lParam != NULL) ) {

                    sci.pCacheItem = vps.pCacheItem = (LPGLOBALASMCACHE) lvi.lParam;
                    psh.nPages = 0;

                    // Don't show the Version property sheet if:
                    // - No file path
                    // - File is offline
                    // - No Version info in file
                    if(!vps.pCacheItem->pAssemblyFilePath) {
                        ASSEMBLY_INFO   AsmInfo = {0};
                        WCHAR           wzPath[_MAX_PATH];

                        AsmInfo.pszCurrentAssemblyPathBuf = wzPath;
                        AsmInfo.cchBuf = ARRAYSIZE(wzPath);

                        if(SUCCEEDED(GetAsmPath(vps.pCacheItem, &AsmInfo))) {
                            if(AsmInfo.cchBuf) {
                                DWORD   dwSize = (AsmInfo.cchBuf + 2) * sizeof(WCHAR);
                                vps.pCacheItem->pAssemblyFilePath = NEW(WCHAR[dwSize]);
                                *(vps.pCacheItem->pAssemblyFilePath) = L'\0';
                                StrCpy(vps.pCacheItem->pAssemblyFilePath, AsmInfo.pszCurrentAssemblyPathBuf);
                            }
                            else {
                                MyTrace("GetAsmPath returned 0 buffer size");
                            }
                        }
                        else {
                            MyTrace("GetAsmPath Failed");
                        }
                    }

                    if(vps.pCacheItem->pAssemblyFilePath) {

                        MyTrace("Assemblies path is");
                        MyTraceW(vps.pCacheItem->pAssemblyFilePath);
                        DWORD dwAttr = WszGetFileAttributes(vps.pCacheItem->pAssemblyFilePath);
                        if( (dwAttr != -1) && ((dwAttr & FILE_ATTRIBUTE_OFFLINE) == 0) ) { // avoid HSM recall
                            DWORD dwVerLen, dwVerHandle;

                            dwVerLen = MyGetFileVersionInfoSizeW((LPWSTR)vps.pCacheItem->pAssemblyFilePath, &dwVerHandle);
                            if(dwVerLen) {
                                psh.nPages = ASSEMBLYITEM_PROPERTY_PAGES;
                            }

                            // Only get LastMod time for GAC items since fusion doesn't
                            // persist them
                            if(m_iCurrentView == VIEW_GLOBAL_CACHE) {
                                // Get the file LastMod time
                                WIN32_FIND_DATA         w32fd;
                                HANDLE                  hFindOnly;

                                hFindOnly = WszFindFirstFile(vps.pCacheItem->pAssemblyFilePath, &w32fd);
                                if(hFindOnly != INVALID_HANDLE_VALUE) {
                                    vps.pCacheItem->pftLastMod->dwLowDateTime = w32fd.ftLastWriteTime.dwLowDateTime;
                                    vps.pCacheItem->pftLastMod->dwHighDateTime = w32fd.ftLastWriteTime.dwHighDateTime;
                                    FindClose(hFindOnly);
                                }
                            }
                        }
                    }
                    else {
                        MyTrace("No assembly path in vps.pCacheItem->pAssemblyFilePath");
                    }

                    // psh.nPages wasn't set above so don't display
                    // version propsheet
                    if(psh.nPages == 0)
                        psh.nPages = ASSEMBLYITEM_PROPERTY_PAGES - 1;

                    // invoke the property sheet
                    psh.pszCaption  = sci.pCacheItem->pAsmName;
                    iRC = PropertySheet(&psh);
                }
            }
            m_fPropertiesDisplayed = FALSE;
            if(g_bRunningOnNT) {
                CloseDesktop(hInputDesktop);
            }
        }
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Display Scavenger Settings property Sheets
void CShellView::ShowScavengerSettingsPropDialog(HWND hParent)
{
    DRIVEPROPSHEETPAGE  psp[SCAVENGER_PROPERTY_PAGES] = {0};
    PROPSHEETHEADER     psh = {0};

    WCHAR               wszTitle[100];
    
    WszLoadString(g_hFusResDllMod, IDS_CACHE_SETTINGS_TITLE, wszTitle, ARRAYSIZE(wszTitle));

    // initialize propsheet page 1.
    psp[0].psp.dwSize          = sizeof(DRIVEPROPSHEETPAGE);
    psp[0].psp.dwFlags         = PSP_HASHELP ;
    psp[0].psp.hInstance       = g_hFusResDllMod;
    psp[0].psp.pszTemplate     = g_fBiDi ? MAKEINTRESOURCE(IDD_PROP_SCAVENGER_BIDI) : MAKEINTRESOURCE(IDD_PROP_SCAVENGER);
    psp[0].psp.pszIcon         = NULL;
    psp[0].psp.pfnDlgProc      = ScavengerPropPage1DlgProc;
    psp[0].psp.pszTitle        = NULL;
    psp[0].psp.lParam          = (LPARAM) &psp[0];
    psp[0].pSF                 = m_pSF;
    psp[0].pSV                 = this;

    // initialize propsheet header.
    psh.pszCaption  = wszTitle;
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW|PSH_PROPTITLE|PSH_HASHELP|PSH_USEHICON;
    psh.hwndParent  = m_hWndParent;
    psh.nPages      = SCAVENGER_PROPERTY_PAGES;
    psh.nStartPage  = 0;
    psh.hIcon       = WszLoadIcon(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ROOT));
    psh.ppsp        = (LPCPROPSHEETPAGE) psp;

    if(g_fBiDi) {
        psh.dwFlags |= PSH_RTLREADING;
    }

    INT_PTR         iRC = PropertySheet(&psh);
}

/**************************************************************************
   CShellView::GetAsmPath
**************************************************************************/
HRESULT CShellView::GetAsmPath(LPGLOBALASMCACHE pCacheItem, ASSEMBLY_INFO *pAsmInfo)
{
    HRESULT     hRC = E_FAIL;

    ASSERT(pCacheItem && pAsmInfo);

    if(pCacheItem && pAsmInfo) {
        IAssemblyName           *pEnumName = NULL;

        if(g_hFusionDllMod == NULL) {
            return E_FAIL;
        }

        if(SUCCEEDED(g_pfCreateAsmNameObj(&pEnumName, pCacheItem->pAsmName, 0, NULL))) {
            DWORD       dwSize;
            DWORD       dwDisplayNameFlags;

            dwDisplayNameFlags = 0;

            if(pCacheItem->PublicKeyToken.ptr != NULL) {
                pEnumName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pCacheItem->PublicKeyToken.ptr,
                    pCacheItem->PublicKeyToken.dwSize);
            }
            if(pCacheItem->pCulture != NULL) {
                pEnumName->SetProperty(ASM_NAME_CULTURE, pCacheItem->pCulture,
                    (lstrlen(pCacheItem->pCulture) + 1) * sizeof(WCHAR));
            }

            // Fix 448224 - Incorrect last modified time displayed for assemblies with Version=0.0.0.0
            pEnumName->SetProperty(ASM_NAME_MAJOR_VERSION, &pCacheItem->wMajorVer, sizeof(pCacheItem->wMajorVer));
            pEnumName->SetProperty(ASM_NAME_MINOR_VERSION, &pCacheItem->wMinorVer, sizeof(pCacheItem->wMinorVer));
            pEnumName->SetProperty(ASM_NAME_REVISION_NUMBER, &pCacheItem->wRevNum, sizeof(pCacheItem->wRevNum));
            pEnumName->SetProperty(ASM_NAME_BUILD_NUMBER, &pCacheItem->wBldNum, sizeof(pCacheItem->wBldNum));

            if(pCacheItem->Custom.ptr != NULL) {
                pEnumName->SetProperty(ASM_NAME_CUSTOM, pCacheItem->Custom.ptr,
                    pCacheItem->Custom.dwSize);
                    dwDisplayNameFlags = ASM_DISPLAYF_VERSION | ASM_DISPLAYF_CULTURE | ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_CUSTOM;
            }

            dwSize = 0;
            pEnumName->GetDisplayName(NULL, &dwSize, dwDisplayNameFlags);
            if(dwSize) {
                LPWSTR      wszDisplayName = NEW(WCHAR [(dwSize + 2) * sizeof(WCHAR)]);
                if(wszDisplayName) {
                    if(SUCCEEDED(pEnumName->GetDisplayName(wszDisplayName, &dwSize, dwDisplayNameFlags))) {

                        // We got the display name, now find out it's install location
                        IAssemblyCache      *pIAsmCache = NULL;
                        IAssemblyScavenger  *pIAsmScavenger = NULL;

                        if(SUCCEEDED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
                            if(SUCCEEDED(pIAsmCache->QueryAssemblyInfo(0, wszDisplayName, pAsmInfo))) {
                                hRC = S_OK;
                            }

                            pIAsmCache->Release();
                            pIAsmCache = NULL;
                        }
                    }
                    SAFEDELETEARRAY(wszDisplayName);
                }
            }
            SAFERELEASE(pEnumName);
        }
    }

    return hRC;
}

/**************************************************************************
   CShellView::GetCacheDiskQuotas
**************************************************************************/
HRESULT CShellView::GetCacheDiskQuotas(DWORD *dwZapQuotaInGAC, DWORD *dwQuotaAdmin, DWORD *dwQuotaUser)
{
    HRESULT     hr = E_FAIL;

    if( g_hFusionDllMod != NULL) {
        IAssemblyCache      *pIAsmCache = NULL;
        IAssemblyScavenger  *pIAsmScavenger = NULL;
        IUnknown            *pUnk = NULL;

        if(SUCCEEDED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
            if(SUCCEEDED(pIAsmCache->CreateAssemblyScavenger(&pUnk))) {
                if (SUCCEEDED(pUnk->QueryInterface(__uuidof(IAssemblyScavenger), (void **)&pIAsmScavenger))) {
                    if(SUCCEEDED(pIAsmScavenger->GetCacheDiskQuotas(dwZapQuotaInGAC, dwQuotaAdmin, dwQuotaUser))) {
                        hr = S_OK;
                    }
                    SAFERELEASE(pIAsmScavenger);
                }
                SAFERELEASE(pUnk);
            }
            SAFERELEASE(pIAsmCache);
        }
    }
    return hr;
}

/**************************************************************************
   CShellView::SetCacheDiskQuotas
**************************************************************************/
HRESULT CShellView::SetCacheDiskQuotas(DWORD dwZapQuotaInGAC, DWORD dwQuotaAdmin, DWORD dwQuotaUser)
{
    HRESULT     hr = E_FAIL;

    if( g_hFusionDllMod != NULL) {
        IAssemblyCache      *pIAsmCache = NULL;
        IAssemblyScavenger  *pIAsmScavenger = NULL;
        IUnknown            *pUnk = NULL;

        if(SUCCEEDED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
            if(SUCCEEDED(pIAsmCache->CreateAssemblyScavenger(&pUnk))) {
                if (SUCCEEDED(pUnk->QueryInterface(__uuidof(IAssemblyScavenger), (void **)&pIAsmScavenger))) {
                    // Returns S_FALSE is the user doesn't have permissions to set the admin quotas, will
                    // still set user quota though.
                    //
                    // Pass in zero values if you do not want to set them
                    
                    if(SUCCEEDED(pIAsmScavenger->SetCacheDiskQuotas(dwZapQuotaInGAC, dwQuotaAdmin, dwQuotaUser))) {
                        hr = S_OK;
                    }
                    SAFERELEASE(pIAsmScavenger);
                }
                SAFERELEASE(pUnk);
            }
            SAFERELEASE(pIAsmCache);
        }
    }

    return hr;
}

/**************************************************************************
   CShellView::ScavengeCache
**************************************************************************/
HRESULT CShellView::ScavengeCache(void)
{
    HRESULT     hr = E_FAIL;

    if( g_hFusionDllMod != NULL) {
        IAssemblyCache      *pIAsmCache = NULL;
        IAssemblyScavenger  *pIAsmScavenger = NULL;
        IUnknown            *pUnk = NULL;

        if(SUCCEEDED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
            if(SUCCEEDED(pIAsmCache->CreateAssemblyScavenger(&pUnk))) {
                if (SUCCEEDED(pUnk->QueryInterface(__uuidof(IAssemblyScavenger), (void **)&pIAsmScavenger))) {
                    if(SUCCEEDED(pIAsmScavenger->ScavengeAssemblyCache())) {
                        MyTrace("Scavenger Invoked");
                        hr = S_OK;
                    }
                    SAFERELEASE(pIAsmScavenger);
                }

                SAFERELEASE(pUnk);
            }
            SAFERELEASE(pIAsmCache);
        }
    }

    return hr;
}

/**************************************************************************
   CShellView::GetCacheUsage
**************************************************************************/
HRESULT CShellView::GetCacheUsage(DWORD *pdwZapUsed, DWORD *pdwDownLoadUsed)
{
    HRESULT     hr = E_FAIL;

    ASSERT(pdwZapUsed && pdwDownLoadUsed);
    *pdwZapUsed = *pdwDownLoadUsed = 0;

    if( g_hFusionDllMod != NULL) {
        IAssemblyCache      *pIAsmCache = NULL;
        IAssemblyScavenger  *pIAsmScavenger = NULL;
        IUnknown            *pUnk = NULL;

        if(SUCCEEDED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
            if(SUCCEEDED(pIAsmCache->CreateAssemblyScavenger(&pUnk))) {
                if (SUCCEEDED(pUnk->QueryInterface(__uuidof(IAssemblyScavenger), (void **)&pIAsmScavenger))) {
                    if(SUCCEEDED(pIAsmScavenger->GetCurrentCacheUsage(pdwZapUsed, pdwDownLoadUsed))) {
                        hr = S_OK;
                    }
                    SAFERELEASE(pIAsmScavenger);
                }

                SAFERELEASE(pUnk);
            }
            SAFERELEASE(pIAsmCache);
        }
    }
    return hr;
}

/**************************************************************************
   CShellView::GetCacheItemRefs
**************************************************************************/
HRESULT CShellView::GetCacheItemRefs(LPGLOBALASMCACHE pCacheItem, LPWSTR wszRefs, DWORD dwSize)
{
    DWORD       dwRefCount = 0;

    ASSERT(wszRefs != NULL);
    EnumerateActiveInstallRefsToAssembly(pCacheItem, &dwRefCount);
    wnsprintf(wszRefs, dwSize, L"%d", dwRefCount);
    return S_OK;
}

/**************************************************************************
   CShellView::EnumerateActiveInstallRefsToAssembly
**************************************************************************/
HRESULT CShellView::EnumerateActiveInstallRefsToAssembly(LPGLOBALASMCACHE pCacheItem, DWORD *pdwRefCount)
{
    IInstallReferenceEnum       *pInstallRefEnum = NULL;
    IInstallReferenceItem       *pRefItem = NULL;
    LPFUSION_INSTALL_REFERENCE  pRefData = NULL;
    IAssemblyName               *pAssemblyName = NULL;
    HRESULT                     hr = S_OK;
    DWORD                       dwDisplayNameFlags;

    if(!pdwRefCount) {
        ASSERT(0);
        return E_INVALIDARG;
    }

    *pdwRefCount = 0;

    // Get the IAssemblyName
    if(FAILED(g_pfCreateAsmNameObj(&pAssemblyName, pCacheItem->pAsmName, 0, NULL))) {
        return E_FAIL;
    }

    dwDisplayNameFlags = 0;

    if(pCacheItem->PublicKeyToken.ptr != NULL) {
        pAssemblyName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pCacheItem->PublicKeyToken.ptr,
            pCacheItem->PublicKeyToken.dwSize);
    }
    if(pCacheItem->pCulture != NULL) {
        pAssemblyName->SetProperty(ASM_NAME_CULTURE, pCacheItem->pCulture,
            (lstrlen(pCacheItem->pCulture) + 1) * sizeof(WCHAR));
    }

    // Fix 448224 - Incorrect last modified time displayed for assemblies with Version=0.0.0.0
    pAssemblyName->SetProperty(ASM_NAME_MAJOR_VERSION, &pCacheItem->wMajorVer, sizeof(pCacheItem->wMajorVer));
    pAssemblyName->SetProperty(ASM_NAME_MINOR_VERSION, &pCacheItem->wMinorVer, sizeof(pCacheItem->wMinorVer));
    pAssemblyName->SetProperty(ASM_NAME_REVISION_NUMBER, &pCacheItem->wRevNum, sizeof(pCacheItem->wRevNum));
    pAssemblyName->SetProperty(ASM_NAME_BUILD_NUMBER, &pCacheItem->wBldNum, sizeof(pCacheItem->wBldNum));

    if(pCacheItem->Custom.ptr != NULL) {
        pAssemblyName->SetProperty(ASM_NAME_CUSTOM, pCacheItem->Custom.ptr,
            pCacheItem->Custom.dwSize);
            dwDisplayNameFlags = ASM_DISPLAYF_VERSION | ASM_DISPLAYF_CULTURE | ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_CUSTOM;
    }

    hr = g_pfCreateInstallReferenceEnum(&pInstallRefEnum, pAssemblyName, 0, NULL);

    while(hr == S_OK) {
        // Get Ref count item
        if((hr = pInstallRefEnum->GetNextInstallReferenceItem( &pRefItem, 0, NULL)) != S_OK) {
            break;
        }

        (*pdwRefCount)++;

        // Get Ref count data
/*
        // Don't really need right now but would be a nice to have later
        if(( hr = pRefItem->GetReference( &pRefData, 0, NULL)) != S_OK) {
            break;
        }
*/
        SAFERELEASE(pRefItem);
    }

    SAFERELEASE(pInstallRefEnum);
    SAFERELEASE(pRefItem);
    SAFERELEASE(pAssemblyName);

    return hr;
}

/**************************************************************************
   CShellView::FindReferences
**************************************************************************/
HRESULT CShellView::FindReferences(LPWSTR pwzAsmName, LPWSTR pwzPublicKeyToken, LPWSTR pwzVerLookup,
                       List<ReferenceInfo *> *pList)
{
    HRESULT                     hr = E_FAIL;
    HANDLE                      hFile;
    WCHAR                       wzSearchSpec[MAX_PATH + 1];
    WCHAR                       wzHistDir[MAX_PATH + 1];
    WCHAR                       wzFile[MAX_PATH + 1];
    FILETIME                    ftMRU;
    DWORD                       dwSize;
    WIN32_FIND_DATA             findData;
    IHistoryReader              *pReader = NULL;
    IHistoryAssembly            *pHistAsm = NULL;
    PFNCREATEHISTORYREADERW     pfCreateHistoryReaderW = NULL;
    PFNGETHISTORYFILEDIRECTORYW pfGetHistoryFileDirectoryW = NULL;

    if(g_hFusionDllMod != NULL) {
        pfCreateHistoryReaderW = (PFNCREATEHISTORYREADERW) GetProcAddress(g_hFusionDllMod, CREATEHISTORYREADERW_FN_NAME);
        pfGetHistoryFileDirectoryW = (PFNGETHISTORYFILEDIRECTORYW) GetProcAddress(g_hFusionDllMod, GETHISTORYFILEDIRECTORYW_FN_NAME);
    }
    else
        return E_FAIL;

    if(!pfCreateHistoryReaderW)
        return E_FAIL;
    if(!pfGetHistoryFileDirectoryW)
        return E_FAIL;

    dwSize = MAX_PATH;
    if(FAILED(pfGetHistoryFileDirectoryW(wzHistDir, &dwSize))) {
        goto Exit;
    }

    wnsprintf(wzSearchSpec, ARRAYSIZE(wzSearchSpec), L"%ws\\*.ini", wzHistDir);
    hFile = WszFindFirstFile(wzSearchSpec, &findData);
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    wnsprintf(wzFile, ARRAYSIZE(wzFile), L"%ws\\%ws", wzHistDir, findData.cFileName);

    if(FAILED(pfCreateHistoryReaderW(wzFile, &pReader))) {
        goto Exit;
    }

    if(FAILED(pReader->GetActivationDate(1, &ftMRU))) {
        goto Exit;
    }

    if(FAILED(LookupAssembly(&ftMRU, pwzAsmName, pwzPublicKeyToken, pwzVerLookup, pReader, pList))) {
        goto Exit;
    }

    SAFERELEASE(pReader);

    while(WszFindNextFile(hFile, &findData))
    {
        wnsprintf(wzFile, ARRAYSIZE(wzFile), L"%ws\\%ws", wzHistDir, findData.cFileName);

        if(FAILED(pfCreateHistoryReaderW(wzFile, &pReader))) {
            goto Exit;
        }

        if(FAILED(pReader->GetActivationDate(1, &ftMRU))) {
            goto Exit;
        }
    
        if(FAILED(LookupAssembly(&ftMRU, pwzAsmName, pwzPublicKeyToken, pwzVerLookup, pReader, pList))) {
            goto Exit;
        }
        else {
            hr = S_OK;
        }

        SAFERELEASE(pReader);
    }

Exit:
    SAFERELEASE(pReader);
    return hr;
}

/**************************************************************************
   LookupAssembly
**************************************************************************/
HRESULT LookupAssembly(FILETIME *pftMRU, LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken, LPCWSTR pwzVerLookup,
                       IHistoryReader *pReader, List<ReferenceInfo *> *pList)
{
    HRESULT             hr = E_FAIL;
    DWORD               dwAsms;
    DWORD               i;
    WCHAR               wzAsmNameCur[LAZY_BUFFER_SIZE];
    WCHAR               wzPublicKeyTokenCur[LAZY_BUFFER_SIZE];
    WCHAR               wzVerCur[LAZY_BUFFER_SIZE];
    IHistoryAssembly    *pHistAsm = NULL;
    DWORD               dwSize;
    BOOL                bFound = FALSE;

    hr = pReader->GetNumAssemblies(pftMRU, &dwAsms);
    if (FAILED(hr)) {
        goto Exit;
    }

    for (i = 1; i <= dwAsms; i++) {
        SAFERELEASE(pHistAsm);

        if(FAILED(pReader->GetHistoryAssembly(pftMRU, i, &pHistAsm))) {
            goto Exit;
        }

        dwSize = LAZY_BUFFER_SIZE;
        if(FAILED(pHistAsm->GetAssemblyName(wzAsmNameCur, &dwSize))) {
            goto Exit;
        }

        if(FusionCompareStringI(wzAsmNameCur, pwzAsmName)) {
            continue;
        }

        dwSize = LAZY_BUFFER_SIZE;
        if(FAILED(pHistAsm->GetPublicKeyToken(wzPublicKeyTokenCur, &dwSize))) {
            goto Exit;
        }

        if(FusionCompareStringI(wzPublicKeyTokenCur, pwzPublicKeyToken)) {
            continue;
        }

        dwSize = LAZY_BUFFER_SIZE;
        if(FAILED(pHistAsm->GetAdminCfgVersion(wzVerCur, &dwSize))) {
            goto Exit;
        }

        if(FusionCompareString(wzVerCur, pwzVerLookup)) {
            continue;
        }
        else {
            bFound = TRUE;
            break;
        }
    }

    if (bFound) {
        WCHAR wzFilePath[MAX_PATH+1];
        ReferenceInfo *pRefInfo;

        dwSize = MAX_PATH;
        if(FAILED(pReader->GetEXEModulePath(wzFilePath, &dwSize))) {
            goto Exit;
        }

        pRefInfo = NEW(ReferenceInfo);
        if(!pRefInfo) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        StrCpy(pRefInfo->wzFilePath, wzFilePath);
        pList->AddTail(pRefInfo);
        hr = S_OK;
    }

Exit:
    SAFERELEASE(pHistAsm);
    return hr;
}

/**************************************************************************
   MyGetFileVersionInfoSizeW
**************************************************************************/
DWORD MyGetFileVersionInfoSizeW(LPWSTR pwzFilePath, DWORD *pdwHandle)
{
    DWORD dwResult;

    // Wrapper for the platform specific
    if(g_bRunningOnNT) {
        dwResult = GetFileVersionInfoSizeW(pwzFilePath, pdwHandle);
    }
    else {
        // Non NT platform
        LPSTR szFilePath = WideToAnsi(pwzFilePath);
        ASSERT(szFilePath);

        dwResult = GetFileVersionInfoSizeA(szFilePath, pdwHandle);

        SAFEDELETEARRAY(szFilePath);
    }

    return dwResult;
}

/**************************************************************************
   MyGetFileVersionInfoW
**************************************************************************/
BOOL MyGetFileVersionInfoW(LPWSTR pwzFilePath, DWORD dwHandle, DWORD dwVersionSize, LPVOID pBuf)
{
    BOOL    fResult;

    // Wrapper for the platform specific
    if(g_bRunningOnNT) {
        fResult = GetFileVersionInfoW(pwzFilePath, dwHandle, dwVersionSize, pBuf);
    }
    else {
        // Non NT platform
        LPSTR szFilePath = WideToAnsi(pwzFilePath);
        ASSERT(szFilePath);

        fResult = GetFileVersionInfoA(szFilePath, dwHandle, dwVersionSize, pBuf);

        SAFEDELETEARRAY(szFilePath);
    }

    return fResult;
}

/**************************************************************************
   MyGetFileVersionInfoW

   WARNING: When performing StringFileInfo searches ONLY, You MUST ALWAYS
            delete ppBuf in not on NT platforms since it allocates memory.
            Use SAFEDELETEARRAY();

**************************************************************************/
BOOL MyVerQueryValueWrap(const LPVOID pBlock, LPWSTR pwzSubBlock, LPVOID *ppBuf, PUINT puLen)
{
    if (g_bRunningOnNT) {
        return VerQueryValueW(pBlock, pwzSubBlock, ppBuf, puLen);
    }
    else {
        const WCHAR pwzStringFileInfo[] = L"\\StringFileInfo";

        //
        // WARNING: This function wipes out any string previously returned
        // for this pBlock because a common buffer at the beginning of the
        // block is used for ansi/unicode translation!
        //
        ASSERT(pwzSubBlock);
        LPSTR szSubBlock = WideToAnsi(pwzSubBlock);
        ASSERT(szSubBlock);

        // The first chunk is our scratch buffer for converting to UNICODE
        if(VerQueryValueA(pBlock, szSubBlock, ppBuf, puLen)) {
            // Make sure we are quering on StringFileInfo
            if(FusionCompareStringNI(pwzSubBlock, pwzStringFileInfo, ARRAYSIZE(pwzStringFileInfo) - 1) == 0) {
                *ppBuf = AnsiToWide((LPSTR) *ppBuf);
                *puLen = lstrlenW((LPWSTR)*ppBuf);
            }
            return TRUE;
        }

        SAFEDELETEARRAY(szSubBlock);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shellfolder.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ShellFolder.cpp
//
// Implement this interface for objects that extend the shell's namespace. 
// For example, implement this interface to create a separate namespace that 
// requires a rooted Windows Explorer or to install a new namespace directly 
// within the hierarchy of the system namespace. You are most familiar with 
// the contents of your namespace, so you are responsible for implementing 
// everything needed to access your data. 

#include "stdinc.h"

CShellFolder::CShellFolder(CShellFolder *pParent, LPCITEMIDLIST pidl)
{
    m_lRefCount = 1;
    g_uiRefThisDll++;

    m_pPidlMgr      = NEW(CPidlMgr);
    m_psfParent     = pParent;
    m_pidl          = m_pPidlMgr->Copy(pidl);
    m_pidlFQ        = NULL;

    if(pParent == NULL) {
        m_psvParent = (CShellView *) NEW(CShellView(this, m_pidl));
    }
}

CShellFolder::~CShellFolder()
{
    g_uiRefThisDll--;

    if(m_pidlFQ) {
        m_pPidlMgr->Delete(m_pidlFQ);
        m_pidlFQ = NULL;
    }

    SAFERELEASE(m_psvParent);

    if(!m_pidl) {
        SAFERELEASE(m_psfParent);
    }
    SAFEDELETE(m_pPidlMgr);
}

///////////////////////////////////////////////////////////
// IUnknown implementation
//
STDMETHODIMP CShellFolder::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT     hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IPersist)) {       //IPersist
        *ppv = (IPersist*)this;
    }
    else if(IsEqualIID(riid, IID_IPersistFolder)) { //IPersistFolder
        *ppv = (IPersistFolder*)this;
    }
    else if(IsEqualIID(riid, IID_IShellFolder)) {   //IShellFolder
        *ppv = (IShellFolder *)this;
    }
    else if(IsEqualIID(riid, IID_IEnumIDList)) {    //IEnumIDList
        *ppv = (CEnumIDList *)this;
    }

    if(*ppv) {
        (*(LPUNKNOWN*)ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}                                             

STDMETHODIMP_(DWORD) CShellFolder::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(DWORD) CShellFolder::Release()
{
    LONG    lRef = InterlockedDecrement(&m_lRefCount);

    if(!lRef) {
        DELETE(this);
    }

    return lRef;
}

///////////////////////////////////////////////////////////
// IPersist Implementation
STDMETHODIMP CShellFolder::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = IID_IShFusionShell;
    return S_OK;
}

///////////////////////////////////////////////////////////
// IPersistFolder Implementation
STDMETHODIMP CShellFolder::Initialize(LPCITEMIDLIST pidl)
{
    if(m_pidlFQ) {
        m_pPidlMgr->Delete(m_pidlFQ);
        m_pidlFQ = NULL;
    }
    m_pidlFQ = m_pPidlMgr->Copy(pidl);

    return S_OK;
}

///////////////////////////////////////////////////////////
// IShellFolder Implementation
//
STDMETHODIMP CShellFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID *ppvOut)
{
    *ppvOut = NULL;

    CShellFolder *pShellFolder = NULL;
    
    if( (pShellFolder = NEW(CShellFolder(NULL, pidl))) == NULL) {
        return E_OUTOFMEMORY;
    }

    LPITEMIDLIST pidlFQ = m_pPidlMgr->Concatenate(m_pidlFQ, pidl);
    pShellFolder->Initialize(pidlFQ);
    m_pPidlMgr->Delete(pidlFQ);

    HRESULT  hr = pShellFolder->QueryInterface(riid, ppvOut);
    pShellFolder->Release();

    return hr;
}

STDMETHODIMP CShellFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID *ppvOut)
{
    *ppvOut = NULL;
    return E_NOTIMPL;
}

// Parameters
//      lParam : Passing zero for lParam indicates a sort by name. 
//                  Values ranging from 0x00000001 to 0x7fffffff are for 
//                  folder-specific sorting rules, while values ranging from 
//                  0x80000000 to 0xfffffff are used for system-specific rules. 
// Return Values:
// < 0 ; if pidl1 should precede pidl2
// > 0 ; if pidl1 should follow pidl2
// = 0 ; if pidl1 == pidl2
STDMETHODIMP CShellFolder::CompareIDs( LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // TODO : Implement your own compare routine for pidl1 and pidl2
    //  Note that pidl1 and pidl2 may be fully qualified pidls, in which
    //  you shouldn't compare just the first items in the respective pidls

    // Hint : Use lParam to determine whether to compare items or sub-items

    // Return one of these:
    // < 0 ; if pidl1 should precede pidl2
    // > 0 ; if pidl1 should follow pidl2
    // = 0 ; if pidl1 == pidl2

    // Fix - Random fault when switching between Assembly and Download folders. This was caused by the shell
    //       passing in pidl's that were unknown to us. So now we check our type

    LPMYPIDLDATA    pData1 = m_pPidlMgr->GetDataPointer(pidl1);
    LPMYPIDLDATA    pData2 = m_pPidlMgr->GetDataPointer(pidl2);

    if(!pData1) {
        return 1;
    }
    if(pData1->pidlType < PT_GLOBAL_CACHE || pData1->pidlType > PT_INVALID) {
        return 1;
    }

    if(!pData2) {
        return 1;
    }
    if(pData2->pidlType < PT_GLOBAL_CACHE || pData2->pidlType > PT_INVALID) {
        return 1;
    }

    WCHAR wzText1[1024];
    WCHAR wzText2[1024];

    *wzText1 = L'\0';
    *wzText2 = L'\0';
        
    m_pPidlMgr->getItemText(pidl1, wzText1, ARRAYSIZE(wzText1));
    m_pPidlMgr->getItemText(pidl2, wzText2, ARRAYSIZE(wzText2));

    // TODO : Customize this based upon your needs
    // Let folders come on top of files : return -1
    // Let files come after folders     : return 1
    // Else compare the item text       : return lstrcmpi
    //

    // Just compare the text since these are virtual folders
    return FusionCompareStringI(wzText1, wzText2);
}

// **************************************************************************************/
STDMETHODIMP CShellFolder::CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID *ppvOut)
{
    HRESULT     hr = E_NOTIMPL;
    
    *ppvOut = NULL;

    if( (IsEqualIID(riid, IID_IShellView)) || (IsEqualIID(riid, IID_IContextMenu)) ||
        (IsEqualIID(riid, IID_IDropTarget)) ) {
        if(!m_psvParent)
            return E_OUTOFMEMORY;

        hr = m_psvParent->QueryInterface(riid, ppvOut);
    }

    return hr;
}

//  CShellFolder::EnumObjects : Determines the contents of a folder by 
//      creating an item enumeration object (a set of item identifiers) that can 
//      be retrieved using the IEnumIDList interface. 
STDMETHODIMP CShellFolder::EnumObjects(HWND hwndOwner, DWORD dwFlags, LPENUMIDLIST *ppEnumIDList)
{
    *ppEnumIDList = NEW(CEnumIDList(this, NULL, dwFlags));
    return *ppEnumIDList ? NOERROR : E_OUTOFMEMORY;
}

// **************************************************************************************/
ULONG CShellFolder::_GetAttributesOf(LPCITEMIDLIST pidl, ULONG rgfIn)
{
    ULONG dwResult = rgfIn & (SFGAO_FOLDER | SFGAO_CANCOPY | SFGAO_CANDELETE |
                              SFGAO_CANLINK | SFGAO_CANMOVE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET |
                              SFGAO_DROPTARGET | SFGAO_NONENUMERATED);

    MYPIDLTYPE  pidlType = m_pPidlMgr->getType(pidl);

    if(pidlType == PT_DOWNLOAD_CACHE) {
        dwResult &= ~SFGAO_CANCOPY;
        dwResult &= ~SFGAO_CANMOVE;
        dwResult &= ~SFGAO_CANRENAME;
        dwResult &= ~SFGAO_CANDELETE;
        dwResult &= ~SFGAO_DROPTARGET;
        dwResult &= ~SFGAO_HASSUBFOLDER;
    }

    return dwResult;
}

// CShellFolder::GetAttributesOf() : Retrieves the attributes of 
// one or more file objects or subfolders. 
STDMETHODIMP CShellFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *aPidl, ULONG *pulInOut)
{
    ULONG   ulAttribs = *pulInOut;

    if(cidl == 0) {
                //
                // This can happen in the Win95 shell when the view is run in rooted mode. 
                // When this occurs, return the attributes for a plain old folder.
                //
                ulAttribs = (SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_BROWSABLE | SFGAO_DROPTARGET | SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM);
    }
    else {
        for (UINT i = 0; i < cidl; i++)
            ulAttribs &= _GetAttributesOf(aPidl[i], *pulInOut);
    }

    *pulInOut = ulAttribs;
    return NOERROR;
}

// CShellFolder::GetUIObjectOf : Retrieves an OLE interface that 
// can be used to carry out actions on the specified file objects or folders. 
STDMETHODIMP CShellFolder::GetUIObjectOf( HWND hwndOwner, UINT cidl, LPCITEMIDLIST *aPidls, 
                                          REFIID riid, LPUINT puReserved, LPVOID *ppvReturn)
{
    MyTrace("GetUIObjectOf entry");

    *ppvReturn = NULL;

    if(IsEqualIID(riid, IID_IContextMenu)) {
        if(!m_psvParent) {
            return E_OUTOFMEMORY;
        }
        return m_psvParent->QueryInterface(riid, ppvReturn);
    }
    if (IsEqualIID(riid, IID_IExtractIcon) || IsEqualIID(riid, IID_IExtractIconA)) {
        CExtractIcon    *pEI = NEW(CExtractIcon(aPidls[0]));
        if (pEI) {
            HRESULT hr = pEI->QueryInterface(riid, ppvReturn);
            pEI->Release();
            return hr;
        }
    }

    if (IsEqualIID(riid, IID_IDataObject)) {
        CDataObject *pDataObj = NEW(CDataObject(this, cidl, aPidls));
        if (pDataObj) {
            HRESULT hr = pDataObj->QueryInterface(riid, ppvReturn);
            pDataObj->Release();
            return hr;
        }
    }

    return E_NOINTERFACE;
}

// CShellFolder::GetDisplayNameOf() : Retrieves the display name 
// for the specified file object or subfolder, returning it in a 
// STRRET structure. 
   
#define GET_SHGDN_FOR(dwFlags)         ((DWORD)dwFlags & (DWORD)0x0000FF00)
#define GET_SHGDN_RELATION(dwFlags)    ((DWORD)dwFlags & (DWORD)0x000000FF)

STDMETHODIMP CShellFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTRRET lpName)
{
    MyTrace("GetDisplayNameOf entry");

    TCHAR   szText[_MAX_PATH];
    int     cchOleStr;

    if (!lpName) {
        return E_INVALIDARG;
    }

    LPITEMIDLIST pidlLast = m_pPidlMgr->GetLastItem(pidl);
    MYPIDLTYPE  pidlType = m_pPidlMgr->getType(pidl);

    // Make sure we only look at out pidl types
    if(pidlType >= PT_INVALID) {
        return E_INVALIDARG;
    }

    switch(GET_SHGDN_FOR(dwFlags))
    {
    case SHGDN_FORPARSING:
    case SHGDN_FORADDRESSBAR:
    case SHGDN_NORMAL:
        switch(GET_SHGDN_RELATION(dwFlags))
        {
        case SHGDN_NORMAL:
            //get the full name
            m_pPidlMgr->getPidlPath(pidl, szText, ARRAYSIZE(szText));
            break;
        case SHGDN_INFOLDER:
            m_pPidlMgr->getItemText(pidlLast, szText, ARRAYSIZE(szText));
            break;
        default:
            return E_INVALIDARG;
        }
        break;

    default:
        return E_INVALIDARG;
    }

    //get the number of characters required
    cchOleStr = lstrlen(szText) + 1;

    //allocate the wide character string
    lpName->pOleStr = (LPWSTR)(NEWMEMORYFORSHELL(cchOleStr * sizeof(WCHAR)));

    if (!lpName->pOleStr) {
        return E_OUTOFMEMORY;
    }

    lpName->uType = STRRET_WSTR;
    StrCpy(lpName->pOleStr, szText);

    return S_OK;
}

// CShellFolder::ParseDisplayName() : Translates a file object's or 
// folder's display name into an item identifier list. 
STDMETHODIMP CShellFolder::ParseDisplayName( HWND hwndOwner, 
                                             LPBC pbcReserved, 
                                             LPOLESTR lpDisplayName, 
                                             LPDWORD pdwEaten, 
                                             LPITEMIDLIST *pPidlNew, 
                                             LPDWORD pdwAttributes)
{
    MyTrace("ParseDisplayName entry");
    *pPidlNew = NULL;
    return E_FAIL;
}

// CShellFolder::SetNameOf() : Sets the display name of a file object 
// or subfolder, changing the item identifier in the process. 
STDMETHODIMP CShellFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                       LPCOLESTR lpName, DWORD dw, 
                                       LPITEMIDLIST *pPidlOut)
{
    return E_NOTIMPL;
}

CShellView* CShellFolder::GetShellViewObject(void)
{
    return m_psvParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shellview.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ShellView.h
//

#ifndef _SHELLVIEW_H
#define _SHELLVIEW_H

#include "globals.h"
#include "appcontext.h"

#define STD         0
#define VIEW        1
#define INTHIS_DLL  2

typedef struct
{
    int         nType;  // STD, VIEW, INTHIS_DLL
    TBBUTTON    tb;
}NS_TOOLBUTTONINFO, *LPNS_TOOLBUTTONINFO;

enum SubItems 
{
    SUBITEM_NAME, SUBITEM_SIZE, SUBITEM_TYPE
};

typedef struct tagLISTVIEWDISPLAYITEMS
{
    TCHAR       tszName[_MAX_PATH];
    int         iWidth;
    int         iFormat;
    int         iColumnType;
    int         iResourceID;
} LISTVIEWITEMS;

typedef struct tagLISTVIEWS
{
    LISTVIEWITEMS   lvis[VIEW_COLUMS_MAX];
} CACHE_VIEWS;

typedef struct tagBLOBS
{
    LPVOID  ptr;
    DWORD   dwSize;
} BLOBS, *LPBLOBS;

typedef struct tagGLOBALASMCACHE
{
    BLOBS       PublicKey;
    BLOBS       PublicKeyToken;
    BLOBS       Hash;
    BLOBS       Custom;

    PTCHAR      pAsmName;
    WORD        wMajorVer;
    WORD        wMinorVer;
    WORD        wBldNum;
    WORD        wRevNum;
    PTCHAR      pCulture;

    DWORD       dwHashALGID;

    PTCHAR      pCodeBaseUrl;
    LPFILETIME  pftLastMod;

    LPWSTR      pwzAppSID;
    LPWSTR      pwzAppId;
    DWORD       dwAssemblyType;

    PTCHAR      pAssemblyFilePath;

} GLOBALASMCACHE, *LPGLOBALASMCACHE;

// Context menu defines for verbs
typedef struct {
   WCHAR szVerb[64];
   DWORD dwCommand;
} VERBMAPPING, FAR *LPVERBMAPPING;

class CShellView :  public IShellView, public IDropTarget, public IContextMenu, public IShellExtInit,
    public CHeaderCtrl
{
public:
    CShellView(CShellFolder* pShellFolder, LPCITEMIDLIST pidl);
    ~CShellView();

    //IUnknown methods
    STDMETHOD (QueryInterface)(REFIID, PVOID *);
    STDMETHOD_ (DWORD, AddRef)();
    STDMETHOD_ (DWORD, Release)();

    //IOleWindow methods
    STDMETHOD (GetWindow) (HWND*);
    STDMETHOD (ContextSensitiveHelp) (BOOL);

    //IShellView methods
#if !defined(TranslateAccelerator)
#define TranslateAccelerator TranslateAccelerator
#endif
#if !defined(TranslateAcceleratorA)
#define TranslateAcceleratorA TranslateAcceleratorA
#endif
#if !defined(TranslateAcceleratorW)
#define TranslateAcceleratorW TranslateAcceleratorW
#endif
#pragma push_macro("TranslateAcceleratorA")
#pragma push_macro("TranslateAcceleratorW")
#pragma push_macro("TranslateAccelerator")
#undef TranslateAccelerator
#undef TranslateAcceleratorA
#undef TranslateAcceleratorW
    HRESULT RealTranslateAccelerator(LPMSG);
    virtual HRESULT __stdcall TranslateAccelerator(LPMSG x)  { return RealTranslateAccelerator(x); }
    virtual HRESULT __stdcall TranslateAcceleratorA(LPMSG x) { return RealTranslateAccelerator(x); }
    virtual HRESULT __stdcall TranslateAcceleratorW(LPMSG x) { return RealTranslateAccelerator(x); }
#pragma pop_macro("TranslateAcceleratorA")
#pragma pop_macro("TranslateAcceleratorW")
#pragma pop_macro("TranslateAccelerator")
    STDMETHOD (EnableModeless) (BOOL);
    STDMETHOD (UIActivate) (UINT);
    STDMETHOD (InitStatusbar) (void);
    STDMETHOD (Refresh) (void);
    STDMETHOD (CreateViewWindow) (LPSHELLVIEW, LPCFOLDERSETTINGS, LPSHELLBROWSER, 
                                LPRECT, HWND*);
    STDMETHOD (DestroyViewWindow) (void);
    STDMETHOD (GetCurrentInfo) (LPFOLDERSETTINGS);
    STDMETHOD (AddPropertySheetPages) (DWORD, LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHOD (SaveViewState) (void);
    STDMETHOD (SelectItem) (LPCITEMIDLIST, UINT);
    STDMETHOD (GetItemObject) (UINT, REFIID, LPVOID*);

    //IDropTarget methods
    STDMETHOD (DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
    STDMETHOD (DragOver)(DWORD, POINTL, LPDWORD);
    STDMETHOD (DragLeave)(VOID);
    STDMETHOD (Drop)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);

    // IContextMenu methods
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uFlags, LPUINT pwReserved,
                            LPSTR pszName, UINT cchMax);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                            UINT idCmdLast, UINT uFlags);
    void InsertSubMenus(HMENU hParentMenu, HMENU hSubMenu);

    // IShellExtInit method
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hKeyProgID);

private:
    BOOL queryDrop(DWORD, LPDWORD);
    DWORD getDropEffectFromKeyState(DWORD);
    BOOL doDrop(HGLOBAL, BOOL);
    void FormatGetMscorrcError(HRESULT, LPWSTR, LPWSTR *);
    BOOL IsValidFileTypes(LPDROPFILES pDropFiles);
    void CreateImageLists(void);

protected:
    LONG m_lRefCount;

private: 
    //private member functions
    static LRESULT CALLBACK nameSpaceWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static int CALLBACK compareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lpData);
    static INT_PTR CALLBACK PropPage1DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PropPage2DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PropPage3DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ScavengerPropPage1DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static void InitPropPage1(HWND hDlg, LPARAM lParam);
    static void InitPropPage2(HWND hDlg, LPARAM lParam);
    static void InitPropPage3(HWND hDlg, LPARAM lParam);
    static BOOL InitScavengerPropPage1(HWND hDlg, LPARAM lParam);
    static void OnNotifyPropDlg(HWND hDlg, LPARAM lParam);
    static INT_PTR OnNotifyScavengerPropDlg(HWND hDlg, LPARAM);

private:
    FOLDERSETTINGS  m_fsFolderSettings;
    LPSHELLBROWSER  m_pShellBrowser;
    LPITEMIDLIST    m_pidl;
    LPPIDLMGR       m_pPidlMgr;
    CShellFolder    *m_pSF;
    CActivationContext m_OurContext;
    HANDLE m_hCompletionPort;
    HANDLE m_hWatchDirectoryThread;
    HMENU m_hMenu;
    UINT m_uiState;
    HWND m_hWndListCtrl;
    HWND m_hWnd;
    HWND m_hWndParent;
    HACCEL m_hAccel;
    HCURSOR m_hOldCursor;
    WORD m_cfPrivateData;
    BOOL m_bAcceptFmt;
    BOOL m_fSplitMove;
    BOOL m_fxSpliterMove;
    BOOL m_fShowTreeView;
    int  m_iCurrentView;
    int  m_xPaneSplit;
    int  m_dxHalfSplitWidth;

private:
    // Windows Message Handlers
    LRESULT onPaint(HDC hDC);
    LRESULT onEraseBkGnd(HDC hDC);
    LRESULT onCreate(void);
    LRESULT onSize(WORD, WORD);
    LRESULT onNotify(UINT, LPNMHDR);
    LRESULT OnLVN_ColumnClick(LPNMLISTVIEW pnmlv);
    LRESULT onCommand(HWND, UINT, WPARAM, LPARAM);
    LRESULT onSetFocus(HWND hWndOld);
    LRESULT OnWMSetFocus(void);
    LRESULT onContextMenu(int x, int y, BOOL bDefault);
    LRESULT onContextMenuAccel(HWND hWndList);
    LRESULT OnMouseMove(HWND hwnd, LPARAM lParam);
    LRESULT OnLButtonDown(HWND hwnd, LPARAM lParam );
    LRESULT OnLButtonUp(HWND hwnd);
    LRESULT onViewerHelp(void);
    void    FocusOnSomething(HWND hWnd);
    void    onViewMenu(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

    LRESULT OnActivate(UINT iState);
    int  OnDeactivate();
    void MergeToolbars();
    void UpdateToolbar(int iViewType);
    
    void initListCtrl();
    void refreshListCtrl();
    void OnListViewSelectAll(void);
    void OnListViewInvSel(void);
    void onViewStyle(UINT uiStyle, int iViewType);
    void OnCopyDataToClipBoard(void);
    void selChange(void);
    void ChangeMenuItemState(UINT uStateFlag);
    void EnableToolBarItems(BOOL fEnabled);
    void setDisplayInfo(LV_DISPINFO *lpdi);

public:
    // Core functions
    void WriteStatusBar(int iPane, LPWSTR pwStr);
    void CleanListView(HWND hListView, int iView);

private:
    int RemoveSelectedItems(HWND hListView);
    void CreatePropDialog(HWND hListView);
    void ShowScavengerSettingsPropDialog(HWND hListView);
    LONG_PTR FindNextToken(PTCHAR pSearchText, PTCHAR pReturnText, TCHAR chSep);

private:
    // Fusion.dll cache specific API's support
    HRESULT DeleteFusionAsmCacheItem(LPGLOBALASMCACHE pGlobalCacheItem, DWORD dwFlags, ULONG *pulDisposition);
    HRESULT InstallFusionAsmCacheItem(LPWSTR wszFileName, BOOL fPopUp);
    LRESULT EnumFusionAsmCache(HWND hListView, DWORD dwCacheFlag);
    HRESULT GetCacheItemRefs(LPGLOBALASMCACHE pCacheItem, LPWSTR wszRefs, DWORD dwSize);
    HRESULT EnumerateActiveInstallRefsToAssembly(LPGLOBALASMCACHE pCacheItem, DWORD *pdwRefCount);
    HRESULT FindReferences(LPWSTR pwzAsmName, LPWSTR pwzPublicKeyToken, LPWSTR pwzVerLookup, List<ReferenceInfo *> *pList);

public:
    BOOL    m_fDeleteInProgress;
    BOOL    m_fAddInProgress;
    BOOL    m_fPropertiesDisplayed;
    BOOL    m_fPrevViewIsOurView;
    BOOL    m_bUIActivated;

    HRESULT GetAsmPath(LPGLOBALASMCACHE pCacheItem, ASSEMBLY_INFO *pAsmInfo);
    HRESULT GetCacheDiskQuotas(DWORD *dwZapQuotaInGAC, DWORD *dwQuotaAdmin, DWORD *dwQuotaUser);
    HRESULT SetCacheDiskQuotas(DWORD dwZapQuotaInGAC, DWORD dwQuotaAdmin, DWORD dwQuotaUser);
    HRESULT ScavengeCache(void);
    HRESULT GetCacheUsage(DWORD *pdwZapUsed, DWORD *pdwDownLoadUsed);

private:
    void MergeHelpMenu( HMENU hmenu, HMENU hmenuMerge );
    void MergeFileMenu( HMENU hmenu, HMENU hmenuMerge );
    void MergeEditMenu( HMENU hmenu, HMENU hmenuMerge );
    void MergeViewMenu( HMENU hmenu, HMENU hmenuMerge );
    void MergeToolMenu( HMENU hmenu, HMENU hmenuMerge );

    HMENU GetMenuFromID( HMENU hmMain, UINT uID );
    UINT MergeMenus( HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags );
    inline int IsMenuSeparator( HMENU hm,UINT i );
};

#endif   //_SHELLVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shellfolder.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ShellFolder.h
//

#ifndef _SHELLFOLDER_H
#define _SHELLFOLDER_H

#include "EnumIDL.h"

class CShellFolder : public IShellFolder, public IPersistFolder
{
friend class CShellView;
friend class CEnumIDList;
friend class CDataObject;
protected:
    LONG    m_lRefCount;

public:
    CShellFolder(CShellFolder*, LPCITEMIDLIST pidl);
    ~CShellFolder();

    //IUnknown methods
    STDMETHOD (QueryInterface) (REFIID, PVOID *);
    STDMETHOD_ (ULONG, AddRef) (void);
    STDMETHOD_ (ULONG, Release) (void);

    //IPersist methods
    STDMETHODIMP GetClassID(LPCLSID);

    //IPersistFolder methods
    STDMETHODIMP Initialize(LPCITEMIDLIST);

    //IShellFolder methods
    STDMETHOD (ParseDisplayName) (HWND, LPBC, LPOLESTR, LPDWORD, 
        LPITEMIDLIST*, LPDWORD);
    STDMETHOD (EnumObjects) (HWND, DWORD, LPENUMIDLIST*);
    STDMETHOD (BindToObject) (LPCITEMIDLIST, LPBC, REFIID, LPVOID*);
    STDMETHOD (BindToStorage) (LPCITEMIDLIST, LPBC, REFIID, LPVOID*);
    STDMETHOD (CompareIDs) (LPARAM, LPCITEMIDLIST, LPCITEMIDLIST);
    STDMETHOD (CreateViewObject) (HWND, REFIID, LPVOID* );
    STDMETHOD (GetAttributesOf) (UINT, LPCITEMIDLIST*, LPDWORD);
    ULONG     (_GetAttributesOf) (LPCITEMIDLIST pidl, ULONG rgfIn);
    STDMETHOD (GetUIObjectOf) (HWND, UINT, LPCITEMIDLIST*, REFIID, LPUINT, LPVOID*);
    STDMETHOD (GetDisplayNameOf) (LPCITEMIDLIST, DWORD, LPSTRRET);
    STDMETHOD (SetNameOf) (HWND, LPCITEMIDLIST, LPCOLESTR, DWORD, LPITEMIDLIST*);

    CShellView* GetShellViewObject(void);

private:
    CShellFolder    *m_psfParent;
    CShellView      *m_psvParent;
    FOLDERSETTINGS  m_fsFolderSettings;
    LPPIDLMGR       m_pPidlMgr;
    LPITEMIDLIST    m_pidlFQ;
public:
    LPCITEMIDLIST   m_pidl;     // TODO: Make m_pidl private again
};

#endif   //_SHELLFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shellview.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ShellView.cpp
//
// This interface is implemented by namespace extensions that display 
// themselves in Windows Explorer's namespace. This object is created by the 
// IShellFolder object that hosts the view. 

#include "stdinc.h"
#include "globals.h"
#include "HtmlHelp.h"

static BOOL     fSwitchSort = FALSE;
static int      iViewLastColumn = -1;

#undef  ARM_QUICK_HOOK_LAUNCH            // Define to get keyboard/mouse hook to launch ARM
#define ARM_QUICK_HOOK_LAUNCH

#define SHFUSION_ASM_TYPE       ASM_NAME_MAX_PARAMS + 1
#define ASM_TYPE_GLOBAL         0x01
#define ASM_TYPE_SIMPLE         0x02
#define ASM_TYPE_STRONG         0x04
#define ASM_TYPE_PREJIT         0x08

STDAPI PolicyManager(HWND, LPWSTR, LPWSTR, LPWSTR);

//===================================================================
// Shell_MergeMenu parameter
//
#define MM_ADDSEPARATOR     0x00000001L
#define MM_SUBMENUSHAVEIDS  0x00000002L

extern "C" void DragItem(LPNMLISTVIEW pnmv);

CACHE_VIEWS     CacheViews[] = {
    {
        {   // VIEW_GLOBAL_CACHE view defines
            {TEXT("\0"), 140,   LVCFMT_LEFT, ASM_NAME_NAME,          IDS_GLOBAL_CACHEVIEW_NAME},
            {TEXT("\0"), 210,   LVCFMT_LEFT, SHFUSION_ASM_TYPE,      IDS_DOWNLOAD_CACHEVIEW_TYPE},
            {TEXT("\0"), 60,    LVCFMT_LEFT, ASM_NAME_MAJOR_VERSION, IDS_CACHEVIEW_VERSION},
            {TEXT("\0"), 40,    LVCFMT_LEFT, ASM_NAME_CULTURE,       IDS_CACHEVIEW_CULTURE},
            {TEXT("\0"), 160,   LVCFMT_LEFT, ASM_NAME_PUBLIC_KEY_TOKEN,    IDS_CACHEVIEW_PUBLIC_KEY_TOKEN},
            {TEXT("\0"), -1, -1, -1, -1},
        }
    },
    {
        {   // VIEW_DOWNLOADSTRONG_CACHE view defines
            {TEXT("\0"), 140, LVCFMT_LEFT, ASM_NAME_NAME,           IDS_SHARED_CACHEVIEW_NAME},
            {TEXT("\0"), 60,  LVCFMT_LEFT, ASM_NAME_MAJOR_VERSION,  IDS_CACHEVIEW_VERSION},
            {TEXT("\0"), 40,  LVCFMT_LEFT, ASM_NAME_CULTURE,        IDS_CACHEVIEW_CULTURE},
//          {TEXT("\0"), 160, LVCFMT_LEFT, ASM_NAME_PUBLIC_KEY_TOKEN,     IDS_CACHEVIEW_PUBLIC_KEY_TOKEN},
            {TEXT("\0"), 210, LVCFMT_LEFT, ASM_NAME_CODEBASE_URL,   IDS_CACHEVIEW_CODEBASE},
            {TEXT("\0"), -1, -1, -1, -1},
        }
    },
    {
        {   // VIEW_DOWNLOADSIMPLE_CACHE view defines
            {TEXT("\0"), 140, LVCFMT_LEFT, ASM_NAME_NAME,           IDS_PRIVATE_CACHEVIEW_NAME},
//          {TEXT("\0"), 60,  LVCFMT_LEFT, ASM_NAME_MAJOR_VERSION,  IDS_CACHEVIEW_VERSION},
            {TEXT("\0"), 40,  LVCFMT_LEFT, ASM_NAME_CULTURE,        IDS_CACHEVIEW_CULTURE},
//          {TEXT("\0"), 160, LVCFMT_LEFT, ASM_NAME_PUBLIC_KEY_TOKEN,     IDS_CACHEVIEW_PUBLIC_KEY_TOKEN},
            {TEXT("\0"), 210, LVCFMT_LEFT, ASM_NAME_CODEBASE_URL,   IDS_CACHEVIEW_CODEBASE},
            {TEXT("\0"), -1, -1, -1, -1},
        }
    },
    {
        {   // VIEW_DOWNLOAD_CACHE view defines
            {TEXT("\0"), 140, LVCFMT_LEFT, ASM_NAME_NAME,           IDS_DOWNLOAD_CACHEVIEW_NAME},
            {TEXT("\0"), 210, LVCFMT_LEFT, SHFUSION_ASM_TYPE,       IDS_DOWNLOAD_CACHEVIEW_TYPE},
            {TEXT("\0"), 60,  LVCFMT_LEFT, ASM_NAME_MAJOR_VERSION,  IDS_CACHEVIEW_VERSION},
            {TEXT("\0"), 40,  LVCFMT_LEFT, ASM_NAME_CULTURE,        IDS_CACHEVIEW_CULTURE},
//          {TEXT("\0"), 160, LVCFMT_LEFT, ASM_NAME_PUBLIC_KEY_TOKEN,     IDS_CACHEVIEW_PUBLIC_KEY_TOKEN},
            {TEXT("\0"), 210, LVCFMT_LEFT, ASM_NAME_CODEBASE_URL,   IDS_CACHEVIEW_CODEBASE},
            {TEXT("\0"), -1, -1, -1, -1},
        }
    },
    {   
        {
            {TEXT("\0"), -1, -1, -1, -1},
        }
    }
};

NS_TOOLBUTTONINFO g_tbInfo[] =
{
    INTHIS_DLL, {0, ID_FUSIONCACHE_SCAVANGE,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
//  INTHIS_DLL, {0, ID_FUSIONCACHE_GLOBALVIEW,      TBSTATE_ENABLED |TBSTATE_CHECKED, BTNS_CHECKGROUP, 0, 0 },
//  INTHIS_DLL, {0, ID_FUSIONCACHE_DOWNLOADSTRONG,  TBSTATE_ENABLED, BTNS_CHECKGROUP, 0, 0 },
//  INTHIS_DLL, {0, ID_FUSIONCACHE_DOWNLOADSIMPLE,  TBSTATE_ENABLED, BTNS_CHECKGROUP, 0, 0 },
//  STD, {STD_FILENEW,    ID_FILEPOPUPMENU_FILE,    TBSTATE_ENABLED, TBSTYLE_BUTTON,    0, 0 },
//  STD, {0,              0,                        0,               TBSTYLE_SEP,          0, 0 },
    STD, {STD_PROPERTIES, ID_VIEWPOPUP_PROPERTIES,  TBSTATE_ENABLED, TBSTYLE_BUTTON,       0, 0 },
    STD, {STD_DELETE,     ID_SHELLFOLDERPOPUP_DELETE, TBSTATE_ENABLED,TBSTYLE_BUTTON,      0, 0 },
//    STD, {STD_UNDO,       0,                        0,               0,                 0, 0 },
    STD, {0,              0,                        0,               TBSTYLE_SEP,          0, 0 },
    VIEW,{VIEW_VIEWMENU,  ID_VIEWPOPUP_VIEWMENU,    TBSTATE_ENABLED, BTNS_WHOLEDROPDOWN | TBSTYLE_DROPDOWN, 0, 0 },
    VIEW,{-1, -1, -1, -1, -1, -1 }
};

// **************************************************************************/
CShellView::CShellView(CShellFolder *pFolder, LPCITEMIDLIST pidl)
{
    m_lRefCount = 1;
    g_uiRefThisDll++;

    m_hWndListCtrl  = NULL;
    m_hMenu         = NULL;
    m_pSF           = pFolder;
    m_hWnd          = NULL;
    m_hWndParent    = NULL;
    m_pPidlMgr      = NEW(CPidlMgr);
    m_pidl          = NULL;
    m_hAccel        = NULL;

    if(pidl != NULL) {
        m_pidl          = m_pPidlMgr->Copy(pidl);
    }

    m_fSplitMove    = FALSE;
    
    m_xPaneSplit    = 0;
    m_dxHalfSplitWidth = 0;
    
    m_fSplitMove    = FALSE;
    m_fxSpliterMove = FALSE;
    m_fShowTreeView = TRUE;
    m_hOldCursor    = NULL;
    m_hCompletionPort = NULL;
    m_hWatchDirectoryThread = NULL;

    // Set Initial View to global fusion cache
    m_fShowTreeView = FALSE;
    m_iCurrentView = -1;
    m_uiState = 0;

    m_bAcceptFmt = FALSE;
    m_cfPrivateData = CF_HDROP;

    m_fDeleteInProgress = FALSE;
    m_fAddInProgress = FALSE;
    m_fPropertiesDisplayed = FALSE;
    m_fPrevViewIsOurView = FALSE;
    m_bUIActivated = FALSE;

    memset(&m_fsFolderSettings, 0, sizeof(FOLDERSETTINGS));
}

// **************************************************************************/
CShellView::~CShellView()
{
    g_uiRefThisDll--;
    SAFEDELETE(m_pPidlMgr);

    if(g_uiRefThisDll == 0) {
        FreeResourceDll();
        FreeFusionDll();
    }
}

///////////////////////////////////////////////////////////////////////////
// IUnknown Implementation
// **************************************************************************/
STDMETHODIMP CShellView::QueryInterface(REFIID riid, PVOID *ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IOleWindow)) {     //IOleWindow
        *ppv = (IOleWindow*) this;
    }
    else if(IsEqualIID(riid, IID_IShellView)) {     //IShellView
        *ppv = (IShellView*) this;
    } 
    else if(IsEqualIID(riid, IID_IDropTarget)) {    //IDropTarget
        *ppv = (IDropTarget*) this;
    }
    else if(IsEqualIID(riid, IID_IDropSource)) {    //IDropSource
        *ppv = (IDropTarget*) this;
    }
    else if (IsEqualIID (riid, IID_IShellExtInit)) {    // IShellExtInt
        *ppv = (IShellExtInit*) this;
    }
    else if (IsEqualIID (riid, IID_IContextMenu))  {    // IContextMenu
        *ppv = (IContextMenu*) this;
    }
    else if (IsEqualIID (riid, IID_IShFusionShell)) {   // QI for this specific Object
        *ppv = (IShellView*) this;
    }

    if(*ppv) {
        (*(LPUNKNOWN*)ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}                                             

// **************************************************************************/
STDMETHODIMP_(DWORD) CShellView::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

// **************************************************************************/
STDMETHODIMP_(DWORD) CShellView::Release()
{
    LONG    lRef = InterlockedDecrement(&m_lRefCount);

    if(!lRef) {
        DELETE(this);
    }

    return lRef;
}

///////////////////////////////////////////////////////////////////////////
// IOleWindow Implementation
// **************************************************************************/
STDMETHODIMP CShellView::GetWindow(HWND *phWnd)
{
    *phWnd = m_hWnd;
    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
// IShellView Implementation
// **************************************************************************/
HRESULT CShellView::RealTranslateAccelerator(LPMSG pMsg)
{
    if(m_hAccel && ::WszTranslateAccelerator(m_hWndParent, m_hAccel, pMsg)) {
        return S_OK;
    }

    return S_FALSE;
}

// **************************************************************************/
STDMETHODIMP CShellView::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

// **************************************************************************/
STDMETHODIMP CShellView::UIActivate(UINT uiState)
{
    if( uiState != SVUIA_DEACTIVATE ) {
        OnActivate( uiState );
        selChange();
        m_bUIActivated = TRUE;
    }
    else {
        OnDeactivate();
    }

    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::InitStatusbar(void)
{
    RECT        rc;
    LRESULT     lResult;
    int         iSBArray[3];
    int         iSpacer = 8;

    // Initialize status bar
    GetClientRect(m_hWndParent, &rc);
    iSBArray[2] = rc.right;
    iSBArray[1] = iSBArray[2] - 149;
    iSBArray[0] = iSBArray[1] - 77;

    if(iSBArray[0] < 0) {
        iSBArray[0] = iSBArray[1] / 2;
    }

    ASSERT(m_pShellBrowser);
    if(m_pShellBrowser) {
        m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETPARTS, ARRAYSIZE(iSBArray), (LPARAM)iSBArray, &lResult);
    }

    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::Refresh(void)
{
    // Don't refresh the view if we are doing the following to assemblies.
    if(!(m_fDeleteInProgress) &&         // Deleting
       !(m_fAddInProgress) &&            // Adding
       !(m_fPropertiesDisplayed) ) {     // Viewing

        MyTrace("Refreshing the view");

        HCURSOR     hOldCursor = SetCursor(WszLoadCursor(NULL, IDC_WAIT));
        
        // Update the view object so we refresh the right window
        SetFileWatchShellViewObject(m_pSF->GetShellViewObject());

        CleanListView(m_hWndListCtrl, m_iCurrentView);
        refreshListCtrl();
        selChange();
        SetCursor(hOldCursor);
    }

    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::CreateViewWindow(LPSHELLVIEW pPrevView, LPCFOLDERSETTINGS lpfs, LPSHELLBROWSER psb, 
                                             LPRECT prcView, HWND *phWnd)
{
    WNDCLASS    wc = { 0 };
    HDC         hdc;

    // Initialize our AppCtx
    m_OurContext.Initialize(g_hInstance, MANIFEST_RESOURCE_ID);

    InitCommonControls();
    *phWnd = NULL;

    // Fix bug 439554, when we fail to load either DLL, fail creation
    if(!LoadFusionDll()) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if(!LoadResourceDll(NULL)) {
        DWORD   dwError = GetLastError();
        FreeFusionDll();
        return HRESULT_FROM_WIN32(dwError);
    }

    // Register the class once
    if(!WszGetClassInfo(g_hInstance, NAMESPACEVIEW_CLASS, &wc)) {
        wc.style          = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc    = (WNDPROC) nameSpaceWndProc;
        wc.cbClsExtra     = NULL;
        wc.cbWndExtra     = NULL;
        wc.hInstance      = g_hInstance;
        wc.hIcon          = NULL;
        wc.hCursor        = WszLoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = NAMESPACEVIEW_CLASS;

        if (WszRegisterClass(&wc) == 0) {
            return E_FAIL;
        }
    }

    // Load the resource strings for the columns
    int x=0, y=0;
    
    while(CacheViews[x].lvis[y].iResourceID != -1) {
        WszLoadString(g_hFusResDllMod, CacheViews[x].lvis[y].iResourceID, CacheViews[x].lvis[y].tszName, ARRAYSIZE(CacheViews[x].lvis[y].tszName));
        y++;
        if(CacheViews[x].lvis[y].iResourceID == -1) {
            x++;
            y=0;
        }
        
        if(CacheViews[x].lvis[y].iResourceID == -1) {
            break;
        }
    }

    CActivationContextActivator dummyContext(this->m_OurContext);

    // Load the accelerator table
    m_hAccel = WszLoadAccelerators(g_hFusResDllMod, MAKEINTRESOURCEW(IDR_MAINWNDACCEL));

    // Need to query on a private interface to get
    // settings, information from previous view object
/*
    CShellView      *pCShellView = NULL;
    HRESULT         hr;

    if( (hr = pPrevView->QueryInterface(IID_IShFusionShell, (LPVOID *)&pCShellView)) != E_NOINTERFACE) {
        pCShellView->Release();
    }
*/
    // Store the browser pointer
    m_pShellBrowser = psb;
    m_pShellBrowser->AddRef();
    CopyMemory(&m_fsFolderSettings, lpfs, sizeof(FOLDERSETTINGS));

    if( hdc = GetDC (m_hWndParent) ) {
        // This sets the first window to have length of 2.25 inches
        int     PixelsPerInch;

        PixelsPerInch = GetDeviceCaps(hdc,LOGPIXELSX);
        m_xPaneSplit = PixelsPerInch * 9/4;
        m_dxHalfSplitWidth = GetSystemMetrics(SM_CYSIZEFRAME) / 2;
        ReleaseDC(m_hWndParent, hdc);
    }

    m_iCurrentView = -1;

    m_pShellBrowser->GetWindow(&m_hWndParent);
    *phWnd = WszCreateWindowEx( g_fBiDi ? WS_EX_LAYOUTRTL : 0,
                            NAMESPACEVIEW_CLASS,
                            NULL,
                            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                            prcView->left, prcView->top,
                            prcView->right - prcView->left,
                            prcView->bottom - prcView->top,
                            m_hWndParent,
                            NULL,
                            g_hInstance,
                            (LPVOID) this);

    if(*phWnd == NULL) {
        return E_FAIL;
    }

    // Init / Merge the bars
    MergeToolbars();
    InitStatusbar();

    UpdateToolbar(m_iCurrentView);
    ShowWindow( *phWnd, SW_SHOW );

    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::DestroyViewWindow(void)
{
    if(m_hWndListCtrl) {
        RevokeDragDrop(m_hWndListCtrl);
        CleanListView(m_hWndListCtrl, m_iCurrentView);
        DestroyWindow(m_hWndListCtrl);
    }

    UIActivate(SVUIA_DEACTIVATE);
    DestroyWindow(m_hWnd);
    m_pShellBrowser->Release();

    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::GetCurrentInfo(LPFOLDERSETTINGS lpfs)
{
    *lpfs = m_fsFolderSettings;
    return S_OK;
}

// **************************************************************************/
STDMETHODIMP CShellView::AddPropertySheetPages( DWORD dwReserved, LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    return E_NOTIMPL;
}

// **************************************************************************/
STDMETHODIMP CShellView::SaveViewState(void)
{
    return E_NOTIMPL;
}

// **************************************************************************/
STDMETHODIMP CShellView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags)
{
    return E_NOTIMPL;
}

// **************************************************************************/
STDMETHODIMP CShellView::GetItemObject(UINT uItem, REFIID riid, LPVOID *ppvOut)
{
    *ppvOut = NULL;
    return E_NOTIMPL;
}

// **************************************************************************/
LRESULT CALLBACK CShellView::nameSpaceWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    CShellView  *pThis = (CShellView*) WszGetWindowLong(hWnd, GWLP_USERDATA);
    switch (uiMsg)
    {
        case WM_NCCREATE:
            {
                LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
                pThis = (CShellView*) (lpcs->lpCreateParams);
                pThis->m_hWnd = hWnd;
                WszSetWindowLong(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            }
            break;
        case WM_CREATE:
          return pThis->onCreate();
        case WM_HELP:
            return pThis->onViewerHelp();
        case WM_ERASEBKGND:
            return pThis->onEraseBkGnd((HDC) wParam);
        case WM_MOVE:
        case WM_SIZE:
            return pThis->onSize(LOWORD(lParam), HIWORD(lParam));
        case WM_NOTIFY:
            return pThis->onNotify((UINT)wParam, (LPNMHDR)lParam);
        case WM_COMMAND:
            return pThis->onCommand(hWnd, uiMsg, wParam, lParam);
        case WM_ACTIVATE:
            return pThis->OnActivate(SVUIA_ACTIVATE_FOCUS);
        case WM_SETFOCUS:
            return pThis->OnWMSetFocus();
        case WM_CONTEXTMENU:
            return pThis->onContextMenu(LOWORD(lParam), HIWORD(lParam), FALSE);
        case WM_MOUSEMOVE:
            return pThis->OnMouseMove( hWnd, lParam );
        case WM_LBUTTONDOWN:
            return pThis->OnLButtonDown( hWnd, lParam);
        case WM_LBUTTONUP:
            return pThis->OnLButtonUp( hWnd );
    }

    return WszDefWindowProc(hWnd, uiMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////
// Message Handlers
// **************************************************************************/
LRESULT CShellView::onEraseBkGnd(HDC hDC)
{
    if(m_fShowTreeView) {
        // Repaint splitter area only
        RECT    rc;
        GetClientRect(m_hWnd, &rc);
        rc.left = m_xPaneSplit - m_dxHalfSplitWidth;
        rc.right = m_xPaneSplit + m_dxHalfSplitWidth * 2;
        FillRect(hDC, &rc, (HBRUSH) (COLOR_WINDOW));
    }

    return 1L;
}
 
// **************************************************************************/
LRESULT CShellView::onSize(WORD nCx, WORD nCy)
{
    if(!IsIconic(m_hWnd) && IsWindow(m_hWndListCtrl)) {
        HDWP    hDWP;
        RECT    ClientRect;

        // Resize only the ListView
        if ( (hDWP = BeginDeferWindowPos(1) )!=NULL) {
            GetClientRect(m_hWnd, &ClientRect);
            DeferWindowPos(hDWP, m_hWndListCtrl, NULL, 0, ClientRect.top, ClientRect.right,
            ClientRect.bottom, SWP_NOZORDER | SWP_NOACTIVATE);
            EndDeferWindowPos(hDWP);
        }

        // Resize the status bar
        InitStatusbar();
    }

    return 0;
}

// **************************************************************************/
LRESULT CShellView::onNotify(UINT CtlID, LPNMHDR lpnmh)
{
    switch(lpnmh->code)
    {

#ifdef ARM_QUICK_HOOK_LAUNCH

        case NM_DBLCLK:
            // Quick hook to get ARM to launch
            if((GetKeyState(VK_LMENU) < 0) && (GetKeyState(VK_CONTROL) < 0) && 
                (GetKeyState(VK_LSHIFT) < 0)) {
                WszPostMessage(m_hWnd, WM_COMMAND, MAKEWPARAM(ID_LAUNCH_ARM, 0), 0);
            }
        // fall thru
#endif

        case NM_RETURN:
        case LVN_ITEMCHANGED:
        case LVN_ITEMACTIVATE:
            selChange();
            return 0;

        case NM_SETFOCUS:
            onSetFocus(NULL);
            selChange();
            return 0;

        case LVN_GETDISPINFO:
        {
            LV_DISPINFO    *lpdi = (LV_DISPINFO *)lpnmh;
            setDisplayInfo(lpdi);
            return 0;
        }

        case NM_RCLICK:
        {
            LV_DISPINFO    *lpdi = (LV_DISPINFO *)lpnmh;
            return 0;
        }

        case LVN_BEGINDRAG:
        {
            HRESULT        hr;
            IDataObject    *pDataObject = NULL;
            UINT           uItemCount;
            LPITEMIDLIST   *aPidls;

            // BUGBUG: Remove to implement Drag out
            break;

            //get the number of selected items
            uItemCount = ListView_GetSelectedCount(lpnmh->hwndFrom);
            if(!uItemCount)
                return 0;

            RevokeDragDrop(m_hWndListCtrl);

            aPidls = reinterpret_cast<LPITEMIDLIST*>(NEW(BYTE[(uItemCount * sizeof(LPITEMIDLIST))]));

            if(aPidls) {
                int     i;
                UINT    x;
                int     iCountOfItems =  WszListView_GetItemCount(lpnmh->hwndFrom);

                for(i = 0, x = 0; x < uItemCount && i < iCountOfItems; i++) {
                    if(ListView_GetItemState(lpnmh->hwndFrom, i, LVIS_SELECTED)) {
                        LVITEM   lvItem;

                        lvItem.mask = LVIF_PARAM;
                        lvItem.iItem = i;

                        WszListView_GetItem(lpnmh->hwndFrom, &lvItem);
                        aPidls[x] = (LPITEMIDLIST)lvItem.lParam;
                        x++;
                    }
                }

                hr = m_pSF->GetUIObjectOf(m_hWnd, uItemCount, (LPCITEMIDLIST*)aPidls, IID_IDataObject, NULL, (LPVOID*)&pDataObject);

                if(SUCCEEDED(hr) && pDataObject) {
                    IDropSource *pDropSource = NEW(CDropSource);
                    DWORD       dwEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE;
                    DWORD       dwAttributes = SFGAO_CANLINK;

                    hr = m_pSF->GetAttributesOf(uItemCount, (LPCITEMIDLIST*)aPidls, &dwAttributes);

                    if(SUCCEEDED(hr) && (dwAttributes & SFGAO_CANLINK)) {
                        dwEffect |= DROPEFFECT_LINK;
                    }

                    DoDragDrop( pDataObject, pDropSource, dwEffect, &dwEffect);

                    pDataObject->Release();
                    pDropSource->Release();
                }

                SAFEDELETEARRAY(aPidls);
            }

            RegisterDragDrop(m_hWndListCtrl, this);
        }
        break;

        case TTN_NEEDTEXT:
        {
            LPNMTTDISPINFO  pttdi = (LPNMTTDISPINFO) lpnmh;
            if(pttdi->hdr.idFrom == ID_FUSIONCACHE_GLOBALVIEW) {
                pttdi->uFlags |= TTF_DI_SETITEM;
                WszLoadString(g_hFusResDllMod, IDS_TTFUSIONGLOBALCACHE, pttdi->szText, ARRAYSIZE(pttdi->szText));
            }
            else if(pttdi->hdr.idFrom == ID_FUSIONCACHE_DOWNLOADSTRONG) {
                pttdi->uFlags |= TTF_DI_SETITEM;
                WszLoadString(g_hFusResDllMod, IDS_TTFUSIONDOWNLOADSTRONG, pttdi->szText, ARRAYSIZE(pttdi->szText));
            }
            else if(pttdi->hdr.idFrom == ID_FUSIONCACHE_DOWNLOADSIMPLE) {
                pttdi->uFlags |= TTF_DI_SETITEM;
                WszLoadString(g_hFusResDllMod, IDS_TTFUSIONDOWNLOADSIMPLE, pttdi->szText, ARRAYSIZE(pttdi->szText));
            }
            else if(pttdi->hdr.idFrom == ID_SHELLFOLDERPOPUP_DELETE) {
                pttdi->uFlags |= TTF_DI_SETITEM;
                WszLoadString(g_hFusResDllMod, IDS_TTDELETE, pttdi->szText, ARRAYSIZE(pttdi->szText));
            }
            else if(pttdi->hdr.idFrom == ID_FUSIONCACHE_SCAVANGE) {
                pttdi->uFlags |= TTF_DI_SETITEM;
                WszLoadString(g_hFusResDllMod, IDS_TTFUSIONCACHESCAVANGE, pttdi->szText, ARRAYSIZE(pttdi->szText));
            }
        }
        break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick( (LPNMLISTVIEW) lpnmh);
            break;

        case NM_KILLFOCUS:
            if(lpnmh->hwndFrom == m_hWndListCtrl) {
                // On loss of focus, Lose focus on items but leave selected
                WszListView_SetItemState(m_hWndListCtrl, -1, 0, LVIS_FOCUSED);

                //Enable appropriate menu items
                ChangeMenuItemState(MF_GRAYED);
                EnableToolBarItems(FALSE);
            }
            break;
    }
    return 0;
}

//
// LVN_COLUMNCLICK handler.
//
// **************************************************************************/
LRESULT CShellView::OnLVN_ColumnClick(LPNMLISTVIEW pnmlv)
{
    // Only sort on headers
    if(pnmlv->iItem == -1) {
        if(GetCurrentSortColumn() != pnmlv->iSubItem) {
            SetColumnHeaderBmp(pnmlv->iSubItem, TRUE);
        }
        else {
            SetColumnHeaderBmp(pnmlv->iSubItem, !GetSortOrder());
        }
    }

    WszListView_SortItems(pnmlv->hdr.hwndFrom, compareItems, (LPARAM) this);
    return 0;
}

// **************************************************************************/
void CShellView::selChange()
{
    WCHAR   wzMsg[_MAX_PATH];
    WCHAR   wzFmt[_MAX_PATH];

    *wzMsg = '\0';
    *wzFmt = '\0';

    int     iSelectedCount = ListView_GetSelectedCount(m_hWndListCtrl);

    if(iSelectedCount) {
        WszLoadString(g_hFusResDllMod, IDS_STATUSBAR_OBJECT_SEL, wzFmt, ARRAYSIZE(wzFmt));
        wnsprintf(wzMsg, ARRAYSIZE(wzMsg), wzFmt, iSelectedCount);
    }
    else {
        WszLoadString(g_hFusResDllMod, IDS_STATUSBAR_OBJECT, wzFmt, ARRAYSIZE(wzFmt));
        wnsprintf(wzMsg, ARRAYSIZE(wzMsg), wzFmt, WszListView_GetItemCount(m_hWndListCtrl));
    }

    WriteStatusBar(0, wzMsg);
    UpdateToolbar(m_iCurrentView);
}

// **************************************************************************/
void CShellView::ChangeMenuItemState(UINT uStateFlag)
{
    if(!m_hMenu) {
        MyTrace("ChangeMenuItemState - No Menu");
        return;
    }

    if(uStateFlag == MF_ENABLED) {
        MyTrace("ChangeMenuItemState - Enable Items");
    }
    else if (uStateFlag == MF_GRAYED) {
        MyTrace("ChangeMenuItemState - Disable Items");
    }
    else {
        MyTrace("ChangeMenuItemState - ??????");
    }

    //Enable appropriate menu items
    EnableMenuItem(GetSubMenu(m_hMenu, 0), IDM_FILE_DEL, MF_BYCOMMAND | uStateFlag);
    EnableMenuItem(GetSubMenu(m_hMenu, 0), IDM_FILE_PROPERTIES, MF_BYCOMMAND | uStateFlag);
    EnableMenuItem(GetSubMenu(m_hMenu, 1), IDM_EDIT_COPY, MF_BYCOMMAND | uStateFlag);
}

// **************************************************************************/
void CShellView::EnableToolBarItems(BOOL fEnabled)
{
    HRESULT     hr;
    LRESULT     lState = 0;
    LRESULT     lResult = 0;

    // Do delete button
    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_GETSTATE, ID_SHELLFOLDERPOPUP_DELETE, 0, &lState);
    ASSERT(hr == NOERROR);

    // If we are in the download cache, always disable the delete button
    if(m_iCurrentView == PT_DOWNLOAD_CACHE) {
        lState &= ~TBSTATE_ENABLED;;
    }
    else {
        if(fEnabled) {
            lState |= TBSTATE_ENABLED;
        }
        else {
            lState &= ~TBSTATE_ENABLED;
        }
    }

    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_SETSTATE, ID_SHELLFOLDERPOPUP_DELETE, MAKELONG( lState, 0 ), &lResult);
    ASSERT(hr == NOERROR);

    // Do properties button
    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_GETSTATE, ID_VIEWPOPUP_PROPERTIES, 0, &lState);
    ASSERT(hr == NOERROR);
    if(fEnabled) {
        lState |= TBSTATE_ENABLED;
    }
    else {
        lState &= ~TBSTATE_ENABLED;
    }

    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_SETSTATE, ID_VIEWPOPUP_PROPERTIES, MAKELONG( lState, 0 ), &lResult);
    ASSERT(hr == NOERROR);
}

// **************************************************************************/
LRESULT CShellView::onCreate(void)
{
    DWORD dwStyle;

    if( (dwStyle = GetRegistryViewState()) == -1) {
        dwStyle = LISTVIEW_STYLES | LVS_AUTOARRANGE | LVS_REPORT;
    }

    m_hWndListCtrl = WszCreateWindowEx(g_fBiDi ? WS_EX_LAYOUTRTL : 0 | WS_EX_CLIENTEDGE,
                                    WC_LISTVIEW, NULL,
                                    dwStyle, 100, 0, 0, 0,
                                    m_hWnd, (HMENU)ID_LISTVIEW, g_hFusResDllMod,
                                    NULL);
    if(!m_hWndListCtrl) {
        return -1;
    }

    WszSetWindowLong(m_hWndListCtrl, GWL_STYLE, dwStyle);
    RegisterDragDrop(m_hWndListCtrl, this);
    ShowWindow(m_hWndListCtrl, SW_SHOW);
    InvalidateRect(m_hWndListCtrl, NULL, TRUE);
    UpdateWindow(m_hWndListCtrl);
    ListView_SetExtendedListViewStyleEx(m_hWndListCtrl, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);
    AttachToHwnd(m_hWndListCtrl);

    // Set Initial View to global fusion cache
    if(m_pidl == NULL) {
        onViewStyle(dwStyle & LVS_TYPEMASK, VIEW_GLOBAL_CACHE);
    }
    else {
        // Set the right view
        LPMYPIDLDATA    pData = m_pPidlMgr->GetDataPointer(m_pidl);

        switch(pData->pidlType)
        {
        case PT_GLOBAL_CACHE:
            onViewStyle(dwStyle & LVS_TYPEMASK, VIEW_GLOBAL_CACHE);
            break;
        case PT_DOWNLOADSIMPLE_CACHE:
            onViewStyle(dwStyle & LVS_TYPEMASK, VIEW_DOWNLOADSIMPLE_CACHE);
            break;
        case PT_DOWNLOADSTRONG_CACHE:
            onViewStyle(dwStyle & LVS_TYPEMASK, VIEW_DOWNLOADSTRONG_CACHE);
            break;
        case PT_DOWNLOAD_CACHE:
            onViewStyle(dwStyle & LVS_TYPEMASK, VIEW_DOWNLOAD_CACHE);
            break;
        default:
            onViewStyle(dwStyle & LVS_TYPEMASK, VIEW_GLOBAL_CACHE);
            break;
        }
    }

    m_hCompletionPort = NULL;
    m_hWatchDirectoryThread = NULL;

    // Bug #476696 Shfusion: AV in shfusion causes explorer to crash
    // Disable the filewatch thread
    //    CreateWatchFusionFileSystem(m_pSF->GetShellViewObject());

    return S_OK;
}

// **************************************************************************/
void CShellView::initListCtrl()
{
    int i = 0;
    int iItem = 0;

    ASSERT(m_hWndListCtrl);
    if(!m_hWndListCtrl) {
        return;
    }

    WszSendMessage(m_hWndListCtrl, WM_SETREDRAW, FALSE, 0);

    // Remove all columns
    HWND    hWndHeader;
    int     iColCount = 0;

    hWndHeader = ListView_GetHeader(m_hWndListCtrl);
    if(hWndHeader) {
        iColCount = Header_GetItemCount(hWndHeader);
    }
    
    while(iColCount) {
        ListView_DeleteColumn(m_hWndListCtrl, iColCount--);
    }

    while(*CacheViews[m_iCurrentView].lvis[iItem].tszName != NULL) {
        LVCOLUMN lvc = { 0 };
        lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_FMT;
        lvc.fmt = CacheViews[m_iCurrentView].lvis[iItem].iFormat;
        lvc.cx = CacheViews[m_iCurrentView].lvis[iItem].iWidth;
        lvc.pszText = CacheViews[m_iCurrentView].lvis[iItem].tszName;
        WszListView_InsertColumn(m_hWndListCtrl, i, &lvc);
        i++;
        iItem++;
    }

    ListView_SetImageList(m_hWndListCtrl, g_hImageListSmall, LVSIL_SMALL);
    ListView_SetImageList(m_hWndListCtrl, g_hImageListLarge, LVSIL_NORMAL);

    SetColumnHeaderBmp(0, TRUE);
    WszSendMessage(m_hWndListCtrl, WM_SETREDRAW, TRUE, 0);
}

// **************************************************************************/
void CShellView::refreshListCtrl()
{
    if(!IsWindow(m_hWndListCtrl))
        return;

    WszSendMessage(m_hWndListCtrl, WM_SETREDRAW, FALSE, 0);

    switch(m_iCurrentView) {
        case VIEW_GLOBAL_CACHE: {
            EnumFusionAsmCache(m_hWndListCtrl, ASM_CACHE_GAC);
            EnumFusionAsmCache(m_hWndListCtrl, ASM_CACHE_ZAP);
        }
        break;

        case VIEW_DOWNLOADSTRONG_CACHE:
        case VIEW_DOWNLOADSIMPLE_CACHE:
        case VIEW_DOWNLOAD_CACHE: {
            EnumFusionAsmCache(m_hWndListCtrl, ASM_CACHE_DOWNLOAD);
        }
        break;
    
        default: {
            LV_ITEM  lvi = { 0 };
            lvi.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iItem   = 0;
            lvi.lParam  = NULL;
            lvi.pszText = TEXT("View Not Implemented");
            lvi.iImage  = IDI_ROOT;
            MAKEICONINDEX(lvi.iImage);
            WszListView_InsertItem(m_hWndListCtrl, &lvi);
        }
    }

    // Default to sort on acending assembly names
    if(GetCurrentSortColumn() == -1) {
        SetColumnHeaderBmp(0, TRUE);
    }
    else {
        int     iLastColSorted = GetCurrentSortColumn();
        BOOL    bSortAcending =  GetSortOrder();

        // Sort names first
        SetColumnHeaderBmp(0, TRUE);
        WszListView_SortItems(m_hWndListCtrl, compareItems, (LPARAM) this );

        // Now sort by selected column
        SetColumnHeaderBmp(iLastColSorted, bSortAcending);
        WszListView_SortItems(m_hWndListCtrl, compareItems, (LPARAM) this );
    }

    // AutoResize the View
    int     iColumn = 0;
    while(CacheViews[m_iCurrentView].lvis[iColumn+1].iColumnType != -1)
        ListView_SetColumnWidth(m_hWndListCtrl, iColumn++, LVSCW_AUTOSIZE_USEHEADER);

    // On the last column, do special. If data then autosize else size on header
    if(WszListView_GetItemCount(m_hWndListCtrl)) {
        ListView_SetColumnWidth(m_hWndListCtrl, iColumn, LVSCW_AUTOSIZE);
    }
    else {
        ListView_SetColumnWidth(m_hWndListCtrl, iColumn, LVSCW_AUTOSIZE_USEHEADER);
    }

    WszSendMessage(m_hWndListCtrl, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hWndListCtrl, NULL, TRUE);
    UpdateWindow(m_hWndListCtrl);
}

// lParam1 -> lParam list item x
// lParam2 -> lParam list item y
// lpData -> HiWord = m_iCurrentView,  LoWord =   iColumn
// **************************************************************************/
int CALLBACK CShellView::compareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lpData)
{
    CShellView      *pSV = (CShellView *) lpData;

    LPGLOBALASMCACHE    pGAC1 = (LPGLOBALASMCACHE) lParam1;
    LPGLOBALASMCACHE    pGAC2 = (LPGLOBALASMCACHE) lParam2;
    int                 iView = LOWORD(lpData);
    int                 diff = 0;

    // Compare the items for the right views
    if(VIEW_GLOBAL_CACHE == pSV->m_iCurrentView)
    {
        switch(pSV->GetCurrentSortColumn())
        {
        case 0:
            diff = FusionCompareStringI(pGAC1->pAsmName, pGAC2->pAsmName);
            break;
        case 1:
            diff = (pGAC1->dwAssemblyType - pGAC2->dwAssemblyType);
            break;
        case 2:
            {
                WCHAR       wzV1[MAX_VERSION_DISPLAY_SIZE];
                WCHAR       wzV2[MAX_VERSION_DISPLAY_SIZE];

                wnsprintf(wzV1, ARRAYSIZE(wzV1), SZ_VERSION_FORMAT,
                    pGAC1->wMajorVer,
                    pGAC1->wMinorVer,
                    pGAC1->wBldNum,
                    pGAC1->wRevNum);

                wnsprintf(wzV2, ARRAYSIZE(wzV2), SZ_VERSION_FORMAT,
                    pGAC2->wMajorVer,
                    pGAC2->wMinorVer,
                    pGAC2->wBldNum,
                    pGAC2->wRevNum);

                diff = FusionCompareStringI(wzV1, wzV2);
            }
            break;
        case 3:
            diff = FusionCompareStringI(pGAC1->pCulture, pGAC2->pCulture);
            break;
        case 4:
            if( (diff = memcmp(&pGAC1->PublicKeyToken.dwSize, &pGAC2->PublicKeyToken.dwSize, sizeof(DWORD))) == 0)
            {
                diff = memcmp(pGAC1->PublicKeyToken.ptr, pGAC2->PublicKeyToken.ptr, pGAC1->PublicKeyToken.dwSize);
            }
            break;
        default:
            {
                //
                // If you hit this, you need to update this function
                // to handle the new column you've added to the listview.
                //
                ASSERT(FALSE);
                break;
            }
        }
    }
    else if( VIEW_DOWNLOADSTRONG_CACHE == pSV->m_iCurrentView )
    {
        switch(pSV->GetCurrentSortColumn())
        {
        case 0:
            diff = FusionCompareStringI(pGAC1->pAsmName, pGAC2->pAsmName);
            break;
        case 1:
            {
                WCHAR       wzV1[MAX_VERSION_DISPLAY_SIZE];
                WCHAR       wzV2[MAX_VERSION_DISPLAY_SIZE];

                wnsprintf(wzV1, ARRAYSIZE(wzV1), SZ_VERSION_FORMAT,
                    pGAC1->wMajorVer,
                    pGAC1->wMinorVer,
                    pGAC1->wBldNum,
                    pGAC1->wRevNum);

                wnsprintf(wzV2, ARRAYSIZE(wzV2), SZ_VERSION_FORMAT,
                    pGAC2->wMajorVer,
                    pGAC2->wMinorVer,
                    pGAC2->wBldNum,
                    pGAC2->wRevNum);

                diff = FusionCompareStringI(wzV1, wzV2);
            }
            break;
        case 2:
            diff = FusionCompareStringI(pGAC1->pCulture, pGAC2->pCulture);
            break;
        case 3:
            diff = FusionCompareStringI(pGAC1->pCodeBaseUrl, pGAC2->pCodeBaseUrl);
            break;
        default:
            {
                //
                // If you hit this, you need to update this function
                // to handle the new column you've added to the listview.
                //
                ASSERT(FALSE);
                break;
            }
        }
    }
    else if( VIEW_DOWNLOADSIMPLE_CACHE == pSV->m_iCurrentView)
    {
        switch(pSV->GetCurrentSortColumn())
        {
        case 0:
            diff = FusionCompareStringI(pGAC1->pAsmName, pGAC2->pAsmName);
            break;
        case 1:
            diff = FusionCompareStringI(pGAC1->pCulture, pGAC2->pCulture);
            break;
        case 2:
            diff = FusionCompareStringI(pGAC1->pCodeBaseUrl, pGAC2->pCodeBaseUrl);
            break;
        default:
            {
                //
                // If you hit this, you need to update this function
                // to handle the new column you've added to the listview.
                //
                ASSERT(0);
                break;
            }
        }
    }
    else if( VIEW_DOWNLOAD_CACHE == pSV->m_iCurrentView)
    {
        switch(pSV->GetCurrentSortColumn())
        {
        case 0:
            diff = FusionCompareStringI(pGAC1->pAsmName, pGAC2->pAsmName);
            break;
        case 1:
            diff = (pGAC1->dwAssemblyType - pGAC2->dwAssemblyType);
            break;
        case 2:
            {
                WCHAR       wzV1[MAX_VERSION_DISPLAY_SIZE];
                WCHAR       wzV2[MAX_VERSION_DISPLAY_SIZE];

                wnsprintf(wzV1, ARRAYSIZE(wzV1), SZ_VERSION_FORMAT,
                    pGAC1->wMajorVer, pGAC1->wMinorVer, pGAC1->wBldNum,
                    pGAC1->wRevNum);

                wnsprintf(wzV2, ARRAYSIZE(wzV2), SZ_VERSION_FORMAT,
                    pGAC2->wMajorVer, pGAC2->wMinorVer, pGAC2->wBldNum,
                    pGAC2->wRevNum);

                diff = FusionCompareStringI(wzV1, wzV2);
            }
            break;
        case 3:
            diff = FusionCompareStringI(pGAC1->pCulture, pGAC2->pCulture);
            break;
        case 4:
            diff = FusionCompareStringI(pGAC1->pCodeBaseUrl, pGAC2->pCodeBaseUrl);
            break;
        default:
            {
                //
                // If you hit this, you need to update this function
                // to handle the new column you've added to the listview.
                //
                ASSERT(FALSE);
                break;
            }
        }
    }
    else
    {
        // You need to add support to sort this view
        ASSERT(FALSE);
        return 0;
    }

    return pSV->GetSortOrder() ? diff : -(diff);
}

// **************************************************************************/
LRESULT CShellView::onCommand(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (LOWORD(wParam))
    {
    case ID_FUSIONCACHE_GLOBALVIEW:
        m_fShowTreeView = FALSE;
        onViewStyle(m_fsFolderSettings.ViewMode, VIEW_GLOBAL_CACHE);
        break;
    case ID_FUSIONCACHE_DOWNLOADSTRONG:
        m_fShowTreeView = FALSE;
        onViewStyle(m_fsFolderSettings.ViewMode, VIEW_DOWNLOADSTRONG_CACHE);
        break;
    case ID_FUSIONCACHE_DOWNLOADSIMPLE:
        m_fShowTreeView = FALSE;
        onViewStyle(m_fsFolderSettings.ViewMode, VIEW_DOWNLOADSIMPLE_CACHE);
        break;
    case ID_FUSIONCACHE_DOWNLOAD:
        m_fShowTreeView = FALSE;
        onViewStyle(m_fsFolderSettings.ViewMode, VIEW_DOWNLOAD_CACHE);
        break;
    case ID_ACCEL_DELETE:
        if(m_iCurrentView != VIEW_GLOBAL_CACHE)     // Allow delete key only in global view
            break;
        // fall thru
    case IDM_FILE_DEL:
    case ID_SHELLFOLDERPOPUP_DELETE:
        RemoveSelectedItems(m_hWndListCtrl);
        break;
    case IDM_VIEW_CACHE_SETTINGS:
    case ID_FUSIONCACHE_SCAVANGE:
        ShowScavengerSettingsPropDialog(m_hWndListCtrl);
        break;
    case ID_EDITPOPUP_UNDO:
    case ID_EDITPOPUP_CUT:
        break;
    case ID_ACCEL_CLIPCOPY:
    case IDM_EDIT_COPY:
        OnCopyDataToClipBoard();
        break;
    case ID_EDITPOPUP_PASTE:
    case ID_EDITPOPUP_PASTESHORTCUT:
        break;
    case ID_ACCEL_SELECTALL:
    case IDM_EDIT_SELECTALL:
    case ID_EDITPOPUP_SELECTALL:
        OnListViewSelectAll();
        break;
    case IDM_EDIT_SELECTINVERT:
        OnListViewInvSel();
        break;
    case ID_ACCEL_POPUP:
        onContextMenuAccel(m_hWndListCtrl);
        break;
    case ID_EDITPOPUP_INVERTSELECTION:
        break;
    case ID_VIEWPOPUP_LARGEICONS:
        onViewStyle(LVS_ICON, m_iCurrentView);
        break;
    case ID_VIEWPOPUP_SMALLICONS:
        onViewStyle(LVS_SMALLICON, m_iCurrentView);
        break;
    case ID_VIEWPOPUP_LIST:
        onViewStyle(LVS_LIST, m_iCurrentView);
        break;
    case ID_VIEWPOPUP_DETAILS:
        onViewStyle(LVS_REPORT, m_iCurrentView);
        break;
    case ID_VIEWPOPUP_VIEWMENU:
        onViewMenu(hWnd, uiMsg, wParam, lParam);
        break;
    case ID_ACCEL_PROPERTIES:
    case IDM_FILE_PROPERTIES:
    case ID_VIEWPOPUP_PROPERTIES:
        CreatePropDialog(m_hWndListCtrl);
        break;
    case ID_REFRESH_DISPLAY:
        Refresh();
        break;
    case ID_LAUNCH_ARM:
        PolicyManager(m_hWndParent, NULL, NULL, NULL);
        break;
    case IDM_HELP_TOPIC:
        onViewerHelp();
        break;
    default:
        break;
    }
    return 0L;
}

// **************************************************************************/
LRESULT CShellView::onViewerHelp(void)
{
    HKEY        hKeyHelpFile = NULL;

    if( ERROR_SUCCESS == WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_NET_MICROSOFT_HELPFILEINSTALLKEY, 0, KEY_QUERY_VALUE, &hKeyHelpFile)) {
        WCHAR       wzHelpFilePath[_MAX_PATH * 2];
        DWORD       dwType = REG_SZ;
        DWORD       dwSize = ARRAYSIZE(wzHelpFilePath);
        LONG        lResult;

        *wzHelpFilePath = L'\0';

        lResult = WszRegQueryValueEx(hKeyHelpFile, SZ_NET_MICROSOFT_HELPFILEPATHKEY,
            NULL, &dwType, reinterpret_cast<LPBYTE>(wzHelpFilePath), &dwSize);

        RegCloseKey(hKeyHelpFile);

        if(ERROR_SUCCESS == lResult) {
            PathRemoveBackslashW(wzHelpFilePath);

            LANGID  langId;
            WCHAR   wzLangSpecific[MAX_CULTURE_STRING_LENGTH+1];
            WCHAR   wzLangGeneric[MAX_CULTURE_STRING_LENGTH+1];

            // Get current culture
            *wzLangSpecific = L'\0';
            *wzLangGeneric = L'\0';
            if(SUCCEEDED(DetermineLangId(&langId))) {
                ShFusionMapLANGIDToCultures(langId, wzLangGeneric, ARRAYSIZE(wzLangGeneric),
                    wzLangSpecific, ARRAYSIZE(wzLangSpecific));
            }

            LPWSTR  pStrPathsArray[] = {wzLangSpecific, wzLangGeneric, NULL};

            // Go through all the possible path locations for our
            // help file (cptools.chm). Use the path that has this
            // file installed in it or default to core framework path.
            for(int x = 0; x < ARRAYSIZE(pStrPathsArray); x++) {
                WCHAR       wzTmpPath[_MAX_PATH * 2];

                *wzTmpPath = L'\0';
                wnsprintf(wzTmpPath, ARRAYSIZE(wzTmpPath),
                    L"%ws%ws%ws%ws%ws",
                    wzHelpFilePath,
                    SZ_NET_MICROSOFT_HELPFILEPATH,
                    pStrPathsArray[x] ? pStrPathsArray[x] : L"",
                    pStrPathsArray[x] ? L"\\" : L"",
                    SZ_NET_MICROSOFT_HELPFILENAME);

                MyTrace("Searching for file existance -");
                MyTraceW(wzTmpPath);

                if(WszGetFileAttributes(wzTmpPath) != -1) {
                    wnsprintf(wzHelpFilePath, ARRAYSIZE(wzHelpFilePath),
                        L"%ws%ws", wzTmpPath, SZ_NET_MICROSOFT_SHFUSIONTOPIC);
                    break;
                }
            }

            MyHtmlHelpWrapW(GetDesktopWindow(), wzHelpFilePath, HH_DISPLAY_TOPIC, NULL);
        }
        else {
            MyTrace("Unable to read Help install location key!");
        }
    }

    return S_OK;
}

// Struct passed from the toolbar to us tell us where we need to place
// popup windows
typedef struct
{
    HWND        hwndFrom;
    VARIANTARG  *pva;
    DWORD       dwUnused;
}TBDDDATA, *LPTBDDDATA; 

// **************************************************************************/
void CShellView::onViewMenu(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPTBDDDATA pcd = (LPTBDDDATA) lParam;

    if(pcd) {
        if(pcd->pva && pcd->pva->byref) {
            HMENU   hMenu, hSubMenu;
            
            hMenu = WszLoadMenu(g_hFusResDllMod, MAKEINTRESOURCEW(IDR_MENU_VIEWPOPUP));
            hSubMenu = GetSubMenu(hMenu,0);

            if(hSubMenu) {
                UINT        uID;

                switch(m_fsFolderSettings.ViewMode)
                {
                case FVM_ICON:
                    uID = ID_VIEWPOPUP_LARGEICONS;
                    break;
                case FVM_SMALLICON:
                    uID = ID_VIEWPOPUP_SMALLICONS;
                    break;
                case FVM_LIST:
                    uID = ID_VIEWPOPUP_LIST;
                    break;
                case FVM_DETAILS:
                    uID = ID_VIEWPOPUP_DETAILS;
                    break;
                default:
                    uID = 0;
                    break;
                }

                if(uID)
                    CheckMenuRadioItem(hSubMenu, ID_VIEWPOPUP_LARGEICONS, ID_VIEWPOPUP_DETAILS, uID, MF_BYCOMMAND);

                //
                // We have X,Y coordinates, let's bring up a context
                // menu at that location.
                //
                LPRECT prect = (LPRECT)pcd->pva->byref;
                int idCmd = TrackPopupMenu(hSubMenu, TPM_RETURNCMD, prect->left, prect->bottom, 0, pcd->hwndFrom, NULL);
                if (idCmd)
                    onCommand(hWnd, WM_COMMAND, MAKEWPARAM(idCmd, 0), (LPARAM) hWnd);
            }

            if(hMenu) DestroyMenu(hMenu);
        }
    }
}

// **************************************************************************/
void CShellView::OnListViewSelectAll(void)
{
    // Select all items in the list view
    WszListView_SetItemState(m_hWndListCtrl, -1, LVIS_SELECTED, LVIS_SELECTED);
}

// **************************************************************************/
void CShellView::OnListViewInvSel(void)
{
    int iItem = -1;
    while ((iItem=ListView_GetNextItem(m_hWndListCtrl, iItem, 0)) != -1) {
        UINT flag;

        // flip the selection bit on each item
        flag = ListView_GetItemState(m_hWndListCtrl, iItem, LVIS_SELECTED);
        flag ^= LVNI_SELECTED;
        WszListView_SetItemState(m_hWndListCtrl, iItem, flag, LVIS_SELECTED);
    }
}

#define DEFAULT_CLIPBOARD_SIZE          2048

// **************************************************************************/
void CShellView::OnCopyDataToClipBoard(void)
{
    LV_ITEM             lvi = { 0 };

    lvi.mask        = LVIF_PARAM;
    lvi.iItem       = ListView_GetNextItem(m_hWndListCtrl, -1, LVNI_SELECTED);

    if(lvi.iItem != -1) {
        WszListView_GetItem(m_hWndListCtrl, &lvi);
        LPGLOBALASMCACHE    pGlobalCacheItem = (LPGLOBALASMCACHE) lvi.lParam;
        LPWSTR              pwzInfo = NEW(WCHAR[DEFAULT_CLIPBOARD_SIZE]);
        INT                 iRemain = DEFAULT_CLIPBOARD_SIZE - 1; // minus the NULL character.

        if(pwzInfo) {
            WCHAR   wzTemp[STRING_BUFFER];
            DWORD   dwLen = 0;

            memset(pwzInfo, 0, DEFAULT_CLIPBOARD_SIZE * sizeof(WCHAR));

            // Put ASM name
            dwLen = lstrlen(pGlobalCacheItem->pAsmName);
            if(dwLen) {
                iRemain -= dwLen;
                if (iRemain >= 0)
                    StrCat(pwzInfo, pGlobalCacheItem->pAsmName);
                iRemain -= 2;
                if (iRemain >= 0)
                    StrCat(pwzInfo, TEXT("  "));
            }

            // Put Culture
            dwLen = lstrlen(pGlobalCacheItem->pCulture);
            if(dwLen) {
                iRemain -= dwLen;
                if (iRemain >= 0)
                    StrCat(pwzInfo, pGlobalCacheItem->pCulture);
            }
            else {
                iRemain -= lstrlenW(SZ_LANGUAGE_TYPE_NEUTRAL);
                if (iRemain >= 0)
                    StrCat(pwzInfo, SZ_LANGUAGE_TYPE_NEUTRAL);
            }
            iRemain -= 2;
            if (iRemain >= 0)
                StrCat(pwzInfo, TEXT("  "));

            // Put Version
            wnsprintf(wzTemp, ARRAYSIZE(wzTemp), SZ_VERSION_FORMAT,
                pGlobalCacheItem->wMajorVer, pGlobalCacheItem->wMinorVer,
                pGlobalCacheItem->wBldNum, pGlobalCacheItem->wRevNum);

            iRemain -= lstrlenW(wzTemp);
            if (iRemain >= 0)
                StrCat(pwzInfo, wzTemp);
            iRemain -= 2;
            if (iRemain >= 0)
                StrCat(pwzInfo, TEXT("  "));

            // Put Public Key Token
            if(pGlobalCacheItem->PublicKeyToken.dwSize)
            {
                BinToUnicodeHex((LPBYTE)pGlobalCacheItem->PublicKeyToken.ptr,
                    pGlobalCacheItem->PublicKeyToken.dwSize, wzTemp);
                
                iRemain -= lstrlenW(wzTemp);
                if (iRemain >= 0)
                    StrCat(pwzInfo, wzTemp);
                iRemain -= 2;
                if (iRemain >= 0)
                    StrCat(pwzInfo, TEXT("  "));
            }

            // Put CodeBase URL
            dwLen = lstrlen(pGlobalCacheItem->pCodeBaseUrl);
            if(dwLen) {
                iRemain -= dwLen;
                if (iRemain >= 0)
                    StrCat(pwzInfo, pGlobalCacheItem->pCodeBaseUrl);
            }

            if(SetClipBoardData(pwzInfo)) {
                MyTrace("Copied data to clipboard successful!");
            }
            else {
                MyTrace("Failed to copied data to clipboard!");
            }
        }
    }
}

// **************************************************************************/
void CShellView::onViewStyle(UINT uiStyle, int iViewType)
{
    // Set the appropriate style
    DWORD_PTR   dwStyle = WszGetWindowLong(m_hWndListCtrl, GWL_STYLE);
    dwStyle &= ~LVS_TYPEMASK;

    switch (uiStyle)
    {
    case LVS_ICON:
        m_fsFolderSettings.ViewMode = FVM_ICON;
        dwStyle |= LVS_ICON;
        break;
    case LVS_SMALLICON:
        m_fsFolderSettings.ViewMode = FVM_SMALLICON;
        dwStyle |= LVS_SMALLICON;
        break;
    case LVS_LIST:
        m_fsFolderSettings.ViewMode = FVM_LIST;
        dwStyle |= LVS_LIST;
        break;
    case LVS_REPORT:
    default:
        m_fsFolderSettings.ViewMode = FVM_DETAILS;
        dwStyle |= LVS_REPORT;
        break;
    }

    SetRegistryViewState(dwStyle);
    WszSetWindowLong(m_hWndListCtrl, GWL_STYLE, dwStyle);

    // Reinitialize ListView if we changed views
    if(m_iCurrentView != iViewType) {
        CleanListView(m_hWndListCtrl, m_iCurrentView);
        m_iCurrentView = iViewType;
        initListCtrl();
        refreshListCtrl();
        UpdateToolbar(m_iCurrentView);
    }

    selChange();
}

// **************************************************************************/
LRESULT CShellView::OnWMSetFocus(void)
{
    // Ignore if we are destroying the window
    if(IsWindow(m_hWnd)) {
        if(m_hWndListCtrl) {
            SetFocus(m_hWndListCtrl);
            selChange();
            FocusOnSomething(m_hWndListCtrl);
        }
    }

    return 0L;
}

// **************************************************************************/
void CShellView::FocusOnSomething(HWND hWnd)
{
    INT iFocus = ListView_GetNextItem(hWnd, -1, LVNI_SELECTED);
    if (-1 == iFocus) {
        iFocus = 0;
    }

    WszListView_SetItemState(hWnd, iFocus, LVIS_FOCUSED | LVNI_SELECTED, LVIS_FOCUSED | LVNI_SELECTED);
}

LRESULT CShellView::onSetFocus(HWND hWndOld)
{
    //
    //   We should call IShellBrowser::OnViewWindowActive() before
    //   calling its InsertMenus().
    //

    m_pShellBrowser->OnViewWindowActive( this );

    //
    // Only call OnActivate() if UIActivate() has been called.
    // If OnActivate() is called before UIActivate(), the menus
    // are merged before IShellView is properly activated.
    // This results in missing menu items.
    //
    if (m_bUIActivated) {
        OnActivate( SVUIA_ACTIVATE_FOCUS );
    }

    return 0L;
}

// **************************************************************************/
int CShellView::OnDeactivate( )
{
    MyTrace("OnDeactivate - In");

    if( m_uiState != SVUIA_DEACTIVATE ) {
        MyTrace("   m_uiState != SVUIA_DEACTIVATE");
        m_pShellBrowser->SetMenuSB( NULL, NULL, NULL );
        m_pShellBrowser->RemoveMenusSB( m_hMenu );
    
        DestroyMenu( m_hMenu );

        m_hMenu = NULL;
        m_uiState = SVUIA_DEACTIVATE;
        m_bUIActivated = FALSE;
    }

    MyTrace("OnDeactivate - Out");

    return(1);
}

// **************************************************************************/
LRESULT CShellView::OnActivate(UINT uState)
{
    if( m_uiState != uState ) {
        HMENU hMenu = CreateMenu();

        MyTrace("   New State set");
        OnDeactivate();

        if(hMenu) {
            HMENU hMergeMenu;
            OLEMENUGROUPWIDTHS mwidth = { { 0, 0, 0, 0, 0, 0 } };

            m_hMenu = hMenu;

            ASSERT(m_pShellBrowser);
            if(m_pShellBrowser) {
                m_pShellBrowser->InsertMenusSB(hMenu, &mwidth);
            }

            if(uState == SVUIA_ACTIVATE_FOCUS) {
                MyTrace("   SVUIA_ACTIVATE_FOCUS");
                hMergeMenu = WszLoadMenu(g_hFusResDllMod, MAKEINTRESOURCEW( MENU_DEFSHELLVIEW ) );

                if(hMergeMenu) {
                    MergeFileMenu( hMenu, GetSubMenu( hMergeMenu, 0 ) );
                    MergeEditMenu( hMenu, GetSubMenu( hMergeMenu, 1 ) );

                    // Put cache settings on Tools menu for NT
                    if(g_bRunningOnNT) {
                        MergeToolMenu( hMenu, GetSubMenu( hMergeMenu, 3 ) );
                    }
                    else {
                        // Put it on the View menu for W9x
                        MergeViewMenu( hMenu, GetSubMenu( hMergeMenu, 2 ) );
                    }

                    MergeHelpMenu( hMenu, GetSubMenu( hMergeMenu, 4 ) );
                    DestroyMenu( hMergeMenu );
                }
            }
            else {
                //
                //  SVUIA_ACTIVATE_NOFOCUS
                //

                MyTrace("   SVUIA_ACTIVATE_NOFOCUS");
                hMergeMenu = WszLoadMenu(g_hFusResDllMod, MAKEINTRESOURCEW( MENU_DEFSHELLVIEW ) );
                if(hMergeMenu) {
                    MergeFileMenu( hMenu, GetSubMenu( hMergeMenu, 0 ) );
                    MergeEditMenu( hMenu, GetSubMenu( hMergeMenu, 1 ) );

                    // Put cache settings on Tools menu for NT and
                    // view menu for W9x
                    if(g_bRunningOnNT) {
                        MergeToolMenu( hMenu, GetSubMenu( hMergeMenu, 3 ) );
                    }
                    else {
                        // Put it on the View menu for W9x
                        MergeViewMenu( hMenu, GetSubMenu( hMergeMenu, 2 ) );
                    }

                    MergeHelpMenu( hMenu, GetSubMenu( hMergeMenu, 4 ) );
                    DestroyMenu( hMergeMenu );
                }
            }

            m_pShellBrowser->SetMenuSB( hMenu, NULL, m_hWnd );
        }

        m_uiState = uState;
    }

    return(1);
}

/**************************************************************************
   CShellView::MergeToolbar()
**************************************************************************/
void CShellView::MergeToolbars()
{
    TBADDBITMAP tbab;
    LRESULT     lOffsetFile;
    LRESULT     lOffsetView;
    LRESULT     lOffsetOther;
    HRESULT     hr;
    int         nButtons;
    
    hr = m_pShellBrowser->SetToolbarItems(NULL, 0, FCT_MERGE);
    ASSERT(hr == NOERROR);

    // Add the file toolbar
    tbab.hInst = HINST_COMMCTRL;
    tbab.nID = (int)IDB_STD_SMALL_COLOR;
    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, (WPARAM) 0, (LPARAM)&tbab, &lOffsetFile);
    ASSERT(hr == NOERROR);
    
    tbab.hInst = HINST_COMMCTRL;
    tbab.nID = (int)IDB_VIEW_SMALL_COLOR;
    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, (WPARAM) 0, (LPARAM)&tbab, &lOffsetView);
    ASSERT(hr == NOERROR);

    // Get the bitmap size to use
    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_GETBITMAPFLAGS, (WPARAM) 0, (LPARAM)0, &lOffsetOther);
    ASSERT(hr == NOERROR);

    // Add the Scavenger Bitmap
    if(lOffsetOther & TBBF_LARGE) {
        // Set to large bitmap
        tbab.nID = (int) IDB_BITMAP_FUSIONCACHE24;
    }
    else {
        tbab.nID = (int) IDB_BITMAP_FUSIONCACHE16;
    }

    tbab.hInst = g_hInstance;
    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, (WPARAM) 1, (LPARAM) &tbab, &lOffsetOther);
    ASSERT(hr == NOERROR);
    
    nButtons = 0;
    while(g_tbInfo[nButtons].tb.iBitmap != -1)
        nButtons++;

    LPTBBUTTON  ptbb = (LPTBBUTTON) NEW(BYTE[sizeof(TBBUTTON) * (nButtons)]);
    if(ptbb) {
        HRESULT     hrLocal;

        for(int j = 0; g_tbInfo[j].tb.idCommand != -1; j++) {
            if (g_tbInfo[j].nType == STD) {
                (ptbb + j)->iBitmap = ((int)lOffsetFile) + g_tbInfo[j].tb.iBitmap;
            }
            else if (g_tbInfo[j].nType == VIEW) {
                (ptbb + j)->iBitmap = ((int)lOffsetView) + g_tbInfo[j].tb.iBitmap;
            }
            else if (g_tbInfo[j].nType == INTHIS_DLL) {
                (ptbb + j)->iBitmap = ((int)lOffsetOther) + g_tbInfo[j].tb.iBitmap;
            }
            (ptbb + j)->idCommand   = g_tbInfo[j].tb.idCommand;
            (ptbb + j)->fsState     = g_tbInfo[j].tb.fsState;
            (ptbb + j)->fsStyle     = g_tbInfo[j].tb.fsStyle;
            (ptbb + j)->dwData      = g_tbInfo[j].tb.dwData;
            (ptbb + j)->iString     = g_tbInfo[j].tb.iString;
        }

        hrLocal = m_pShellBrowser->SetToolbarItems(ptbb, nButtons, FCT_MERGE);
        ASSERT(hrLocal == NOERROR);        // Should only hit this if we fail to set toolbar items
        SAFEDELETEARRAY(ptbb);
    }
}

// **************************************************************************/
void CShellView::UpdateToolbar(int iViewType)
{
    HRESULT     hr;
    LRESULT     lResult = 0;
    LRESULT     lState = 0;
    UINT        uiCmd;

    //enable/disable/check the toolbar items here
    switch(m_fsFolderSettings.ViewMode) {
        case FVM_ICON:
            uiCmd = ID_VIEWPOPUP_LARGEICONS;
            break;

        case FVM_SMALLICON:
            uiCmd = ID_VIEWPOPUP_SMALLICONS;
            break;

        case FVM_LIST:
            uiCmd = ID_VIEWPOPUP_LIST;
            break;
        case FVM_DETAILS:
        default:
            uiCmd = ID_VIEWPOPUP_DETAILS;
            break;
    }

    hr = m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_CHECKBUTTON, uiCmd, MAKELPARAM(TRUE, 0), &lResult);
    ASSERT(hr == NOERROR);

    // Enable / Disable menu items appropriately
    if(GetFocus() == m_hWndListCtrl) {
        ChangeMenuItemState(ListView_GetSelectedCount(m_hWndListCtrl) ? MF_ENABLED : MF_GRAYED);
        EnableToolBarItems(ListView_GetSelectedCount(m_hWndListCtrl) ? TRUE : FALSE);
    }
    else {
        ChangeMenuItemState(MF_GRAYED);
        EnableToolBarItems(FALSE);
    }
}

/**************************************************************************
   setDisplayInfo(LV_DISPINFO *lpdi)
**************************************************************************/
// Yes, yes functions shouldn't be this big...
void CShellView::setDisplayInfo(LV_DISPINFO *lpdi)
{
    // No LPARAM, can't process
    if(lpdi->item.lParam == NULL)
        return;

    LPITEMIDLIST   pidl = (LPITEMIDLIST)lpdi->item.lParam;
    lpdi->item.mask |= LVIF_DI_SETITEM; // dont ask us again

    if(lpdi->item.iSubItem) { // Subitem information being requested
        //is the text being requested?
        if(lpdi->item.mask & LVIF_TEXT) {
            LPMYPIDLDATA    pData = m_pPidlMgr->GetDataPointer(pidl);

            switch (lpdi->item.iSubItem) {
                case SUBITEM_TYPE:
                    StrCpy(lpdi->item.pszText, (PTSTR) (((PTBYTE)pData->szFileAndType) + pData->uiSizeFile));
                    break;
            }
        }
    }
    else {   // The item information is being requested
        if(lpdi->item.mask & LVIF_TEXT) {
            STRRET   str;

            if(SUCCEEDED(m_pSF->GetDisplayNameOf(pidl, SHGDN_NORMAL | SHGDN_INFOLDER, &str))) {
                if(STRRET_WSTR == str.uType) {
                    StrCpy(lpdi->item.pszText, str.pOleStr);

                    //delete the string buffer
                    SAFEDELETE(str.pOleStr);
                }
            }
        }

        if ((lpdi->item.mask & LVIF_IMAGE) == LVIF_IMAGE) {
            IExtractIcon   *pei;

            int         iIconItem = IDI_ROOT;
            MAKEICONINDEX(iIconItem);

            if(SUCCEEDED(m_pSF->GetUIObjectOf(m_hWnd, iIconItem, (LPCITEMIDLIST*)&pidl, 
                                            IID_IExtractIcon, NULL, (LPVOID*)&pei))) {
                UINT  uFlags;

                //GetIconLoaction will give us the index into our image list
                pei->GetIconLocation(GIL_FORSHELL, NULL, 0, &lpdi->item.iImage, &uFlags);
                if ((uFlags & GIL_SIMULATEDOC) == GIL_SIMULATEDOC) {
                    HICON hIconLarge = NULL, hIconSmall = NULL;
                    pei->Extract(NULL, -1, &hIconLarge, &hIconSmall, -1);

                    // TODO: Cache the icons so that one icon for a 
                    //          file type need to be created only once
                    if (m_fsFolderSettings.ViewMode != FVM_ICON) {
                        lpdi->item.iImage = ImageList_AddIcon(g_hImageListSmall, hIconSmall);
                    }
                    else {
                        lpdi->item.iImage = ImageList_AddIcon(g_hImageListLarge, hIconLarge);
                    }
                }
                pei->Release();
            }
        }
    }   // Item info requested
}

// *****************************************************************************************
LRESULT CShellView::onContextMenu(int x, int y, BOOL bDefault)
{
    HMENU hMenu = CreatePopupMenu();
    if(hMenu && SUCCEEDED(QueryContextMenu(hMenu, 0, 0, 0x7FF, 0))) {
        if (bDefault) {
            // TODO : search for default menu item from hMenu
        }
        else {
            
            UINT uiCmd = TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RETURNCMD, x, y, 0, m_hWnd, NULL);
            if(uiCmd > 0) {
                CMINVOKECOMMANDINFO  cmi = { 0 };
                cmi.cbSize  = sizeof(CMINVOKECOMMANDINFO);
                cmi.hwnd    = m_hWnd;
                cmi.lpVerb  = (LPCSTR)MAKEINTRESOURCEW(uiCmd);
                InvokeCommand(&cmi);
            }
        }
        DestroyMenu(hMenu);
    }
    return 0;
}

// *****************************************************************************************
LRESULT CShellView::onContextMenuAccel(HWND hWndList)
{
    RECT        rc = { 0 };
    POINT       pt = { 0 };
    int         iSelItem = -1;

    // Get the first selected Item
    iSelItem = ListView_GetNextItem(hWndList, iSelItem, LVNI_SELECTED);

    // If we have an item, adjust the coords to place popup
    // on the selected item
    if(iSelItem != -1) {
        RECT        rc1 = { 0 };

        ListView_GetItemPosition(hWndList, iSelItem, &pt);
        WszListView_GetItemRect(hWndList, iSelItem, &rc1, LVIR_ICON);
        pt.x += ((rc1.right - rc1.left) / 2);
        WszListView_GetItemRect(hWndList, iSelItem, &rc1, LVIR_BOUNDS);
        pt.y += ((rc1.bottom - rc1.top) / 2);
    }

    // Offset relative to desktop
    GetWindowRect(hWndList, &rc);
    pt.x += rc.left;
    pt.y += rc.top;

    return onContextMenu(pt.x, pt.y, FALSE);
}

// *****************************************************************************************
LRESULT CShellView::OnMouseMove(HWND hwnd,LPARAM lParam)
{
    POINTS  Coord  = MAKEPOINTS(lParam);
    int     dx;

    if( IsIconic(m_hWnd) )
        return 0;     

    // Are we moving the splitter
    if(m_fSplitMove) {
        RECT    ClientRect;
        GetClientRect(m_hWnd, &ClientRect);
        InvalidateRect(m_hWnd, NULL, TRUE);

        if(m_fxSpliterMove) {
            // Movin the X
            dx = GetSystemMetrics(SM_CYSIZEFRAME);
            m_xPaneSplit = Coord.x - m_dxHalfSplitWidth;
            if( (int)m_xPaneSplit < (int)(ClientRect.left + dx) )
                m_xPaneSplit = ClientRect.left + dx;

            dx += m_dxHalfSplitWidth*2;

            if( (int)m_xPaneSplit > (int)(ClientRect.right - dx) )
                m_xPaneSplit = ClientRect.right - dx;
        }
    
        onSize(0, 0);
    }
    else if( (Coord.x >= m_xPaneSplit - m_dxHalfSplitWidth) &&
        (Coord.x <= m_xPaneSplit + m_dxHalfSplitWidth) && (m_hOldCursor == NULL) ) {
        m_hOldCursor = SetCursor(WszLoadCursor(NULL, MAKEINTRESOURCEW(IDC_SIZEWE)));
    }
    else if(m_hOldCursor != NULL) {
        SetCursor(m_hOldCursor);
        m_hOldCursor = NULL;
    }

    return 0;
}

// *****************************************************************************************
LRESULT CShellView::OnLButtonDown(HWND hwnd,LPARAM lParam )
{
    POINTS  pts;

    pts = MAKEPOINTS(lParam);
    m_fxSpliterMove = FALSE;
    m_fSplitMove = TRUE;
    SetCapture(hwnd);

    if( (pts.x >= m_xPaneSplit - m_dxHalfSplitWidth) && (pts.x <= m_xPaneSplit + m_dxHalfSplitWidth)) {
        m_fxSpliterMove = TRUE;
        m_hOldCursor = SetCursor(WszLoadCursor(NULL, MAKEINTRESOURCEW(IDC_SIZEWE)));
    }
    return 0;
}

// *****************************************************************************************
LRESULT CShellView::OnLButtonUp(HWND hwnd )
{
    if (m_fSplitMove) {
        ReleaseCapture();
        m_fSplitMove = FALSE;
        SetCursor(m_hOldCursor);
        m_hOldCursor = NULL;
    }

    return 0;
}

// *****************************************************************
//  Write text to part in status bar
// *****************************************************************
void CShellView::WriteStatusBar(int iPart, LPWSTR pwStr)
{
    LRESULT     lResult;
    HRESULT     hr = NOERROR;

    if(!m_pShellBrowser || !pwStr) {
        return;
    }

    if(g_bRunningOnNT) {
        hr = m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXT, iPart, (LPARAM)pwStr, &lResult);
    }
    else {

        LPSTR   pStr = WideToAnsi(pwStr);

        if(pStr) {
            hr = m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXTA, iPart, (LPARAM)pStr, &lResult);
            SAFEDELETEARRAY(pStr);
        }
    }

    ASSERT(hr == NOERROR);
}

// *****************************************************************
//  Enumerate and display items in the view
// *****************************************************************
LRESULT CShellView::EnumFusionAsmCache(HWND hListView, DWORD dwCacheFlag)
{
    HRESULT                 hr = S_OK;
    IAssemblyEnum           *pEnum = NULL;
    IAssemblyName           *pEnumName = NULL;
    IAssemblyCache          *pIAsmCache = NULL;

    MyTrace("EnumFusionAsmCache - Entry");

    if(g_hFusionDllMod == NULL) {
        return E_FAIL;
    }

    // Create enumerator
    if( SUCCEEDED(g_pfCreateAsmEnum(&pEnum, NULL, NULL, dwCacheFlag, NULL)) ) {
        // Now create cacheitem (used to get Assembly FilePath)
        if(FAILED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
            pIAsmCache = NULL;
        }
    }

    if(pEnum != NULL)
    {
        while(S_FALSE != pEnum->GetNextAssembly(NULL, &pEnumName, 0))
        {
            LPGLOBALASMCACHE    pGlobalCacheItem;

            if( (pGlobalCacheItem = FillFusionPropertiesStruct(pEnumName)) != NULL) {
                WCHAR       wzText[_MAX_PATH];
                int         iItem = 0;
                int         iSubItem = 0;
                int         iViewItem = 0;

                switch(dwCacheFlag) {
                    case ASM_CACHE_GAC:
                        pGlobalCacheItem->dwAssemblyType = ASM_TYPE_GLOBAL;
                        break;
                    case ASM_CACHE_DOWNLOAD:
                        if(pGlobalCacheItem->PublicKeyToken.dwSize == 0) {
                            pGlobalCacheItem->dwAssemblyType = ASM_TYPE_SIMPLE;
                        } else {
                            pGlobalCacheItem->dwAssemblyType = ASM_TYPE_STRONG;
                        }
                        break;
                    case ASM_CACHE_ZAP:
                        pGlobalCacheItem->dwAssemblyType = ASM_TYPE_PREJIT;
                        break;
                    default:
                        // We shouldn't hit this, If you do, then there is
                        // a new enumation type defined
                        ASSERT(0);
                        break;
                }

                while(CacheViews[m_iCurrentView].lvis[iSubItem].iColumnType != -1)
                {
                    LV_ITEM lvi = { 0 };
                    lvi.iItem   = iItem;
                    lvi.iImage  = IDI_ROOT;
                    MAKEICONINDEX(lvi.iImage);

                    lvi.lParam  = (LPARAM) pGlobalCacheItem;
                    lvi.pszText = NULL;

                    switch(CacheViews[m_iCurrentView].lvis[iSubItem].iColumnType)
                    {
                    case ASM_NAME_NAME:
                        lvi.pszText = pGlobalCacheItem->pAsmName;
                        break;
                    case SHFUSION_ASM_TYPE:
                        {
                            WCHAR   wzType[_MAX_PATH];
                            WCHAR   wzPreJit[_MAX_PATH];
                            UINT    uResourceId = 0;

                            *wzType = '\0';
                            *wzPreJit = '\0';

                            if(pGlobalCacheItem->dwAssemblyType & ASM_TYPE_GLOBAL) {
                                // Do Nothing with Global
                            }
                            else if(pGlobalCacheItem->dwAssemblyType & ASM_TYPE_PREJIT) {
                                uResourceId = IDS_ASSEMBLY_TYPE_PREJIT;
                            }
                            else if(pGlobalCacheItem->dwAssemblyType & ASM_TYPE_SIMPLE) {
                                uResourceId = IDS_ASSEMBLY_TYPE_SIMPLE;
                            }
                            else if(pGlobalCacheItem->dwAssemblyType & ASM_TYPE_STRONG) {
                                uResourceId = IDS_ASSEMBLY_TYPE_STRONG;
                            }
                            else {
                                // Need to add additional types here
                                ASSERT(0);
                                uResourceId = IDS_ASSEMBLY_TYPE_UNKNOWN;
                            }

                            if(uResourceId) {
                                WszLoadString(g_hFusResDllMod, uResourceId, wzType, ARRAYSIZE(wzType));
                            }

                            wnsprintf(wzText, ARRAYSIZE(wzText), TEXT("%ls%ls%ls"),
                                wzType, *wzType ? TEXT(" ") : TEXT(""), wzPreJit);

                            lvi.pszText = wzText;
                        }
                        break;

                    case ASM_NAME_CULTURE:
                        lvi.pszText = pGlobalCacheItem->pCulture;
                        break;

                    case ASM_NAME_MAJOR_VERSION:
                        {
                            wnsprintf(wzText, ARRAYSIZE(wzText), SZ_VERSION_FORMAT,
                                pGlobalCacheItem->wMajorVer, pGlobalCacheItem->wMinorVer,
                                pGlobalCacheItem->wBldNum, pGlobalCacheItem->wRevNum);

                            lvi.pszText = wzText;
                        }
                        break;

                    case ASM_NAME_PUBLIC_KEY_TOKEN:
                        StrCpy(wzText, TEXT(""));
                        if(pGlobalCacheItem->PublicKeyToken.dwSize) {
                            BinToUnicodeHex((LPBYTE)pGlobalCacheItem->PublicKeyToken.ptr,
                                pGlobalCacheItem->PublicKeyToken.dwSize, wzText);
                        }
                        lvi.pszText = wzText;
                        break;

                    case ASM_NAME_CODEBASE_URL:
                        lvi.pszText = pGlobalCacheItem->pCodeBaseUrl;
                        break;

                    default:
                        // Need to cover additional data type conversions if you hit this
                        ASSERT(0);
                        break;
                    }

                    if(iSubItem == 0) {
                        // Handle 1st Row entry
                        if(lvi.pszText != NULL) {
                            lvi.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                            iItem = WszListView_InsertItem(m_hWndListCtrl, &lvi);
                        }
                    }
                    else {
                        // Handle Column entries
                        if(lvi.pszText != NULL) {
                            lvi.mask    = LVIF_TEXT;
                            lvi.iSubItem= iSubItem;
                            WszListView_SetItem(m_hWndListCtrl, &lvi);
                        }
                    }
                    iSubItem++;
                }
            }
            SAFERELEASE(pEnumName);
        }
        SAFERELEASE(pEnum);
    }
    SAFERELEASE(pIAsmCache);

    MyTrace("EnumFusionAsmCache - Exit");
    return S_OK;
}

// *****************************************************************
int CShellView::RemoveSelectedItems(HWND hListView)
{
    BOOL        fDoDelete = FALSE;
    int         iCurrentItem = -1;
    int         iTotalItemsDeleted = 0;
    int         iTotalItemsToDelete = ListView_GetSelectedCount(hListView);

    if(iTotalItemsToDelete >= 1) {
        WCHAR       wzFmt[_MAX_PATH];
        WCHAR       wzTxt[_MAX_PATH];
        WCHAR       wzTitle[_MAX_PATH];
        WCHAR       wzMsg[_MAX_PATH];

        if(iTotalItemsToDelete > 1) {
            // Build Title
            WszLoadString(g_hFusResDllMod, IDS_CONFIRM_DELITEM_TITLE, wzFmt, ARRAYSIZE(wzFmt));
            WszLoadString(g_hFusResDllMod, IDS_MULTIPLE_TITLE, wzTxt, ARRAYSIZE(wzTxt));
            wnsprintf(wzTitle, ARRAYSIZE(wzTitle), wzFmt, wzTxt);

            // Build Msg
            WszLoadString(g_hFusResDllMod, IDS_CONFIRM_DELITEMS, wzFmt, ARRAYSIZE(wzFmt));
            wnsprintf(wzMsg, ARRAYSIZE(wzMsg), wzFmt, iTotalItemsToDelete);
        }
        else {
            // Get the name of the Assembly
            LPGLOBALASMCACHE    pGlobalCacheItem;
            LV_ITEM             lvi = { 0 };

            lvi.mask        = LVIF_PARAM;
            lvi.iItem       = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);
            WszListView_GetItem(hListView, &lvi);
            pGlobalCacheItem = (LPGLOBALASMCACHE) lvi.lParam;

            // Build Title
            WszLoadString(g_hFusResDllMod, IDS_CONFIRM_DELITEM_TITLE, wzTxt, ARRAYSIZE(wzTxt));
            wnsprintf(wzTitle, ARRAYSIZE(wzTitle), wzTxt, TEXT(""));

            // Build Msg
            WszLoadString(g_hFusResDllMod, IDS_CONFIRM_DELONEITEM, wzFmt, ARRAYSIZE(wzFmt));
            wnsprintf(wzMsg, ARRAYSIZE(wzMsg), wzFmt, pGlobalCacheItem->pAsmName);
        }

        MessageBeep(MB_ICONQUESTION);
        if(IDYES == WszMessageBox(m_hWndParent, wzMsg, wzTitle,
            (g_fBiDi ? MB_RTLREADING : 0) | MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL)) {
            fDoDelete = TRUE;
        }
    }

    if(fDoDelete) {
        LPWSTR      pwzErrorString = NULL;
        HCURSOR     hOldCursor = SetCursor(WszLoadCursor(NULL, MAKEINTRESOURCEW(IDC_WAIT)));
        m_fDeleteInProgress = TRUE;

        while((iCurrentItem = ListView_GetNextItem(hListView, iCurrentItem, LVNI_SELECTED)) != -1) {
            // Found a selected Item, remove it
            LV_ITEM     lvi = { 0 };
            HRESULT     hr;

            lvi.mask        = LVIF_PARAM;
            lvi.iItem       = iCurrentItem;

            if(WszListView_GetItem(hListView, &lvi)) {
                LPGLOBALASMCACHE    pGlobalCacheItem = (LPGLOBALASMCACHE) lvi.lParam;
                SetCursor(WszLoadCursor(NULL, MAKEINTRESOURCEW(IDC_WAIT)));
                ULONG       uDisposition;

                hr = DeleteFusionAsmCacheItem(pGlobalCacheItem, 0, &uDisposition);

                if(hr == S_OK) {
                    iTotalItemsDeleted++;
                }
                else if(hr == S_FALSE) {
                    if(uDisposition == IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES) {
                        // Special case since mscorrc doesn't have failure to uninstall
                        // due to references error string
                        WCHAR       wszErrorString[512];
                        WCHAR       wzFmt[_MAX_PATH];
                        DWORD       dwSize;

                        WszLoadString(g_hFusResDllMod, IDS_UNINSTALL_DISPOSITION_ERROR, wzFmt, ARRAYSIZE(wzFmt));
                        wnsprintf(wszErrorString, ARRAYSIZE(wszErrorString), wzFmt, pGlobalCacheItem->pAsmName);

                        // Now append any previous strings to this one
                        dwSize = 0;
                        if(pwzErrorString) {
                            dwSize = lstrlen(pwzErrorString);
                            dwSize += 2;        // Add 2 for cr/lf combo
                        }

                        dwSize += lstrlen(wszErrorString);  // Add new string length
                        dwSize++;                           // Add 1 for null terminator

                        LPWSTR  pStrTmp = NEW(WCHAR[dwSize]);

                        if(pStrTmp) {
                            *pStrTmp = L'\0';

                            if(pwzErrorString) {
                                StrCpy(pStrTmp, pwzErrorString);
                                StrCat(pStrTmp, L"\r\n");
                            }

                            StrCat(pStrTmp, wszErrorString);
                        }
                        
                        SAFEDELETEARRAY(pwzErrorString);
                        pwzErrorString = pStrTmp;
                    }
                    else if(uDisposition == IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED) {
                        iTotalItemsDeleted++;
                    }
                    else {
                        // Unexpected disposition
                        iTotalItemsDeleted++;
                    }
                }
                else {
                    FormatGetMscorrcError(hr, pGlobalCacheItem->pAsmName, &pwzErrorString);
                }
            }
        }

        // Restore cursor
        SetCursor(hOldCursor);

        if(iTotalItemsToDelete != iTotalItemsDeleted)
        {
            WCHAR       wzMsg[_MAX_PATH];
            WCHAR       wzTitle[_MAX_PATH];

            WszLoadString(g_hFusResDllMod,IDS_DELETEERROR, wzMsg, ARRAYSIZE(wzMsg));
            WszLoadString(g_hFusResDllMod,IDS_DELETE_ERROR_TITLE, wzTitle, ARRAYSIZE(wzTitle));

            MessageBeep(MB_ICONASTERISK);
            WszMessageBox(m_hWndParent, pwzErrorString, wzTitle,
                (g_fBiDi ? MB_RTLREADING : 0) | MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
        }

        SAFEDELETEARRAY(pwzErrorString);
        m_fDeleteInProgress = FALSE;


        // If the FileWatch thread isn't running, refresh the view!
        //
        // BUGBUG: Do Refresh cause W9x doesn't get the event
        // set for some reason. File FileWatch.cpp
        if(iTotalItemsDeleted) {
            if(!g_bRunningOnNT || g_hWatchFusionFilesThread == INVALID_HANDLE_VALUE) {
                WszPostMessage(m_hWnd, WM_COMMAND, MAKEWPARAM(ID_REFRESH_DISPLAY, 0), 0);
            }
        }
    }

    return iTotalItemsDeleted;
}

// *****************************************************************
HRESULT CShellView::DeleteFusionAsmCacheItem(LPGLOBALASMCACHE pGlobalCacheItem, DWORD dwFlags, ULONG *pulDisposition)
{
    IAssemblyName       *pAsmName = NULL;
    DWORD               dwSize;
    HRESULT             hRC = E_FAIL;

    if(g_hFusionDllMod == NULL) {
        return E_FAIL;
    }

    // Get the assemblies display name
    if(SUCCEEDED(g_pfCreateAsmNameObj(&pAsmName, pGlobalCacheItem->pAsmName, dwFlags, NULL))) {

        LPWSTR      pwName = NULL;
        DWORD       dwDisplayNameFlags;

        dwDisplayNameFlags = 0;

        if(pGlobalCacheItem->PublicKeyToken.ptr != NULL) {
            pAsmName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pGlobalCacheItem->PublicKeyToken.ptr,
                pGlobalCacheItem->PublicKeyToken.dwSize);
        }
        if(pGlobalCacheItem->pCulture != NULL) {
            pAsmName->SetProperty(ASM_NAME_CULTURE, pGlobalCacheItem->pCulture,
                (lstrlen(pGlobalCacheItem->pCulture) + 1) * sizeof(WCHAR));
        }

        pAsmName->SetProperty(ASM_NAME_MAJOR_VERSION, &pGlobalCacheItem->wMajorVer, sizeof(pGlobalCacheItem->wMajorVer));
        pAsmName->SetProperty(ASM_NAME_MINOR_VERSION, &pGlobalCacheItem->wMinorVer, sizeof(pGlobalCacheItem->wMinorVer));
        pAsmName->SetProperty(ASM_NAME_BUILD_NUMBER, &pGlobalCacheItem->wBldNum, sizeof(pGlobalCacheItem->wBldNum));
        pAsmName->SetProperty(ASM_NAME_REVISION_NUMBER, &pGlobalCacheItem->wRevNum, sizeof(pGlobalCacheItem->wRevNum));

        if(pGlobalCacheItem->Custom.ptr != NULL) {
            pAsmName->SetProperty(ASM_NAME_CUSTOM, pGlobalCacheItem->Custom.ptr,
                pGlobalCacheItem->Custom.dwSize);
                dwDisplayNameFlags = ASM_DISPLAYF_VERSION | ASM_DISPLAYF_CULTURE | ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_CUSTOM;
        }

        dwSize = 0;
        pAsmName->GetDisplayName(NULL, &dwSize, dwDisplayNameFlags);
        if(dwSize) {
            pwName = NEW(WCHAR[dwSize + 2]);
        }
        else {
            WCHAR   wzMsg[512];
            wnsprintf(wzMsg, ARRAYSIZE(wzMsg), TEXT("DeleteFusionAsmCacheItem - GetDisplayName Failed pwName = %0x, dwSize = %0x"), pwName, dwSize);
            MyTraceW(wzMsg);
        }

        if(pwName && SUCCEEDED(pAsmName->GetDisplayName(pwName, &dwSize, dwDisplayNameFlags))) {

            IAssemblyCache  *pIAsmCache = NULL;

            *pulDisposition = 0;

            // Create cacheitem (used to UnInstall Assembly)
            if(SUCCEEDED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {

                // BUGBUG: We need better evaluation of this function since we could
                // have a mem alloc failure. uDisposition is intended to return the
                // true result of this call but is currently not implemented.
                hRC = pIAsmCache->UninstallAssembly(0, pwName, 0, pulDisposition);
                SAFERELEASE(pIAsmCache);
            }
        }
        SAFEDELETEARRAY(pwName);
        SAFERELEASE(pAsmName);
    }

    return hRC;
}

// *****************************************************************
HRESULT CShellView::InstallFusionAsmCacheItem(LPWSTR wszFileName, BOOL fPopUp)
{
    IAssemblyCache  *pIAsmCache = NULL;
    HRESULT         hr = E_FAIL;
    BOOL            fLoadedFusion = FALSE;

    // E_INVALIDARG
    if( (wszFileName == NULL) || (!lstrlen(wszFileName)) )
        return FALSE;

    if(g_hFusionDllMod == NULL) {
        // Load fusion. This would happen if the droptarget
        // handler was contructed before the entire CShellView class
        // was initialized
        if(LoadFusionDll()) {
            fLoadedFusion = TRUE;
        }
        else {
            return FALSE;
        }
    }

    // Create cacheitem (used to install Assembly)
    if(FAILED(g_pfCreateAssemblyCache(&pIAsmCache, 0))) {
        return FALSE;
    }

    MyTrace("Shfusion::InstallFusionAsmCacheItem - Attempting install of");
    MyTraceW(wszFileName);

    hr = pIAsmCache->InstallAssembly(IASSEMBLYCACHE_INSTALL_FLAG_REFRESH, wszFileName, NULL);
    SAFERELEASE(pIAsmCache);

    // Did we load fusion?
    if(fLoadedFusion) {
        FreeFusionDll();
    }

    return hr;
}

void CShellView::CleanListView(HWND hListView, int iView)
{
    if(hListView == NULL)
        return;

    switch(iView) {
        case VIEW_GLOBAL_CACHE:
        case VIEW_DOWNLOADSTRONG_CACHE:
        case VIEW_DOWNLOADSIMPLE_CACHE:
        case VIEW_DOWNLOAD_CACHE:
        {
            int     iItemCount = WszListView_GetItemCount(hListView);
            
            for(int iLoop = 0; iLoop < iItemCount; iLoop++) {
                LV_ITEM  lvi = { 0 };
                lvi.mask        = LVIF_PARAM;
                lvi.iItem       = iLoop;
                if(WszListView_GetItem(hListView, &lvi)) {
                    SafeDeleteAssemblyItem((LPGLOBALASMCACHE) lvi.lParam);
                }
            }

            WszListView_DeleteAllItems(m_hWndListCtrl);
        }
        break;

    default:
        WszListView_DeleteAllItems(m_hWndListCtrl);
        break;
    }
}

// *****************************************************************
LONG_PTR CShellView::FindNextToken(PTCHAR pSearchText, PTCHAR pReturnText, TCHAR chSep)
{
    PTCHAR  pStart = pSearchText;
    PTCHAR  pEnd;
    TCHAR   ch;

    if( (pSearchText == NULL) || !(*pSearchText) )
        return 0;

    for(; *pSearchText && (*pSearchText == ' ' || *pSearchText == '\t'); ++pSearchText) // Skip space, or tab
        ;
    for(pEnd = pSearchText; *pEnd && (*pEnd != chSep); ++pEnd)  // Skip to next seperator or end
        ;

    // Save off the string
    if(pReturnText != NULL)
    {
        ch = *pEnd;     // Save endpoint char
        *pEnd = '\0';
        StrCpy(pReturnText, pSearchText);
        *pEnd = ch;     // Restore char
    }

    if(*pEnd == chSep)
        pEnd++;

    return(pEnd - pStart);
}

//
//  Copy a menu onto the beginning or end of another menu
//  Adds uIDAdjust to each menu ID (pass in 0 for no adjustment)
//  Will not add any item whose adjusted ID is greater than uMaxIDAdjust
//  (pass in 0xffff to allow everything)
//  Returns one more than the maximum adjusted ID that is used
//

// *****************************************************************
inline int CShellView::IsMenuSeparator( HMENU hm,UINT i )
{
    return( GetMenuItemID( hm, i ) == 0 );
}

// *****************************************************************
UINT CShellView::MergeMenus( HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags )
{
    MENUITEMINFO    miiSrc;
    int             nItem;
    HMENU           hmSubMenu;
    BOOL            bAlreadySeparated;
    TCHAR           szName[_MAX_PATH];
    UINT            uTemp, uIDMax = uIDAdjust;

    if( !hmDst || !hmSrc )
        goto MM_Exit;

    nItem = GetMenuItemCount( hmDst );

    if( uInsert >= (UINT)nItem ) {

        //  We are inserting an additional popup on the menu bar (I think)
        //  So it is already separated

        uInsert = (UINT)nItem;
        bAlreadySeparated = TRUE;
    }
    else {
        //  otherwise check to see if there is a separator between the items
        //  already in the destination menu and the menu being merged in
        bAlreadySeparated = IsMenuSeparator( hmDst, uInsert );
    }

    if( (uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated ) {
        //  Add a separator between the menus if requested by caller
        WszInsertMenu( hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL );
        bAlreadySeparated = TRUE;
    }

    //  Go through the menu items and clone them
    for( nItem = GetMenuItemCount( hmSrc ) - 1; nItem >= 0; nItem-- ) {
        miiSrc.cbSize = sizeof( MENUITEMINFO );
        miiSrc.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;

        //  We need to reset this every time through the loop in case
        //  menus DON'T have IDs

        miiSrc.fType = MFT_STRING;
        miiSrc.dwTypeData = szName;
        miiSrc.dwItemData = 0;
        miiSrc.cch = ARRAYSIZE( szName );  // szName character count.

        if(!WszGetMenuItemInfo( hmSrc, nItem, TRUE, &miiSrc ) )
           continue;

        if( miiSrc.fType & MFT_SEPARATOR ) {
            //  This is a separator; don't put two of them in a row
            if( bAlreadySeparated )
               continue;

            if( !WszInsertMenuItem( hmDst, uInsert, TRUE, &miiSrc ) )
                goto MM_Exit;

            bAlreadySeparated = TRUE;
        }
        else if( miiSrc.hSubMenu ) {    //  this item has a submenu
            
            if( uFlags & MM_SUBMENUSHAVEIDS ) { //  Adjust the ID and check it
                miiSrc.wID += uIDAdjust;

                if( miiSrc.wID > uIDAdjustMax )
                    continue;

                if( uIDMax <= miiSrc.wID ) {
                    uIDMax = miiSrc.wID + 1;
                }
            }
            else {
                //  Don't set IDs for submenus that didn't have
                //  them already
                miiSrc.fMask &= ~MIIM_ID;
            }

            hmSubMenu = miiSrc.hSubMenu;

            miiSrc.hSubMenu = CreatePopupMenu( );

            if( !miiSrc.hSubMenu )
                goto MM_Exit;

            uTemp = MergeMenus( miiSrc.hSubMenu, hmSubMenu, 0, uIDAdjust,
                                uIDAdjustMax, uFlags & MM_SUBMENUSHAVEIDS );

            if( uIDMax <= uTemp )
                uIDMax = uTemp;

            if( !WszInsertMenuItem( hmDst, uInsert, TRUE, &miiSrc ) )
                goto MM_Exit;

            bAlreadySeparated = FALSE;
        }
        else {
            //  This is just a regular old item
            //  Adjust the ID and check it
            miiSrc.wID += uIDAdjust;

            if( miiSrc.wID > uIDAdjustMax )
                continue;

            if( uIDMax <= miiSrc.wID )
                uIDMax = miiSrc.wID + 1;

            bAlreadySeparated = FALSE;

            if( !WszInsertMenuItem( hmDst, uInsert, TRUE, &miiSrc ) )
                goto MM_Exit;
        }
    }

    //  Ensure the correct number of separators at the beginning of the
    //  inserted menu items
    if( uInsert == 0 ) {
        if( bAlreadySeparated ) {
            DeleteMenu( hmDst, uInsert, MF_BYPOSITION );
        }
    }
    else {
        if( IsMenuSeparator( hmDst, uInsert-1 ) ) {
            if( bAlreadySeparated ) {
                DeleteMenu( hmDst, uInsert, MF_BYPOSITION );
            }
        }
        else {
            if( (uFlags & MM_ADDSEPARATOR ) && !bAlreadySeparated ) {
                //  Add a separator between the menus
                WszInsertMenu( hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL );
            }
        }
    }

MM_Exit:
    return( uIDMax );
}

// *****************************************************************
void CShellView::MergeHelpMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuHelp = GetMenuFromID( hmenu, FCIDM_MENU_HELP );

    if ( hmenuHelp )
        MergeMenus( hmenuHelp, hmenuMerge, 0, 0, (UINT) -1, MM_ADDSEPARATOR );
}

// *****************************************************************
void CShellView::MergeFileMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuFile = GetMenuFromID( hmenu, FCIDM_MENU_FILE );

    if( hmenuFile )
        MergeMenus( hmenuFile, hmenuMerge, 0, 0, (UINT) -1, MM_ADDSEPARATOR );
}

// *****************************************************************
void CShellView::MergeEditMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuEdit = GetMenuFromID( hmenu, FCIDM_MENU_EDIT );

    if( hmenuEdit ) {
        MergeMenus( hmenuEdit, hmenuMerge, 0, 0, (UINT) -1, 0 );

        // Remove inserted duplicate items favoring those
        // of the Shell
        int nStartPos = 0;
        while(nStartPos <= GetMenuItemCount(hmenuEdit) - 1) {
            MENUITEMINFO    miiSrc1, miiSrc2;
            TCHAR           szName1[_MAX_PATH], szName2[_MAX_PATH];

            miiSrc1.cbSize = sizeof( MENUITEMINFO );
            miiSrc1.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;
            //  We need to reset this every time through the loop in case menus DON'T have IDs
            miiSrc1.fType = MFT_STRING;
            miiSrc1.dwTypeData = szName1;
            miiSrc1.dwItemData = 0;
            miiSrc1.cch = ARRAYSIZE( szName1 );  // szName character count.

            if(WszGetMenuItemInfo( hmenuEdit, nStartPos, TRUE, &miiSrc1 )) {
                int     nItem;

                if( !(miiSrc1.fType & MFT_SEPARATOR) ) {
                    //  Compare each of the menu items
                    for(nItem = GetMenuItemCount( hmenuEdit ) - 1; nItem >= 0; nItem--) {
                        if(nStartPos != nItem) {
                            miiSrc2.cbSize = sizeof( MENUITEMINFO );
                            miiSrc2.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;

                            //  We need to reset this every time through the loop in case menus DON'T have IDs
                            miiSrc2.fType = MFT_STRING;
                            miiSrc2.dwTypeData = szName2;
                            miiSrc2.dwItemData = 0;
                            miiSrc2.cch = ARRAYSIZE( szName2 );  // szName character count.

                            if(WszGetMenuItemInfo( hmenuEdit, nItem, TRUE, &miiSrc2 )) {
                                if(!FusionCompareStringI(szName1, szName2)) {
                                    DeleteMenu(hmenuEdit, nStartPos, MF_BYPOSITION);
                                    WszInsertMenuItem(hmenuEdit, nStartPos, TRUE, &miiSrc2);
                                    DeleteMenu(hmenuEdit, nItem, MF_BYPOSITION);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            nStartPos++;
        }
    }
}

// *****************************************************************
void CShellView::MergeViewMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_VIEW );

    if( hmenuView ) {
        int index;

        //  Find the last separator in the view menu.
        for( index = GetMenuItemCount( hmenuView ) - 1; index >= 0; index-- ) {
            UINT mf = GetMenuState( hmenuView, (UINT)index, MF_BYPOSITION );

            if( mf & MF_SEPARATOR ) {
                //  merge it right above the separator.
                break;
            }
        }

        //  Add the separator above (in addition to existing one if any).
        WszInsertMenu( hmenuView, index, MF_BYPOSITION | MF_SEPARATOR, 0, NULL );

        //  Then merge our menu between two separators
        //  (or right below if only one).
        if( index != -1 ) index++;

        MergeMenus( hmenuView, hmenuMerge, (UINT) index, 0, (UINT) -1, 0 );
    }
}

// *****************************************************************
void CShellView::MergeToolMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuTool = GetMenuFromID( hmenu, FCIDM_MENU_TOOLS );

    if( hmenuTool ) {
        int index;

        //
        //  Find the last separator in the tool menu.
        //

        for( index = GetMenuItemCount( hmenuTool ) - 1; index >= 0; index-- ) {
            UINT mf = GetMenuState( hmenuTool, (UINT)index, MF_BYPOSITION );

            if( mf & MF_SEPARATOR ) {
                //  merge it right above the separator.
                break;
            }
        }

        //  Add the separator above (in addition to existing one if any).
        WszInsertMenu( hmenuTool, index, MF_BYPOSITION | MF_SEPARATOR, 0, NULL );

        //  Then merge our menu between two separators
        //  (or right below if only one).
        if( index != -1 ) index++;

        MergeMenus( hmenuTool, hmenuMerge, (UINT) index, 0, (UINT) -1, 0 );
    }
}

// *****************************************************************
HMENU CShellView::GetMenuFromID( HMENU hmMain, UINT uID )
{
    MENUITEMINFO miiSubMenu;

    miiSubMenu.cbSize = sizeof( MENUITEMINFO );
    miiSubMenu.fMask  = MIIM_SUBMENU;

    if( !WszGetMenuItemInfo( hmMain, uID, FALSE, &miiSubMenu ) )
        return NULL;

    return( miiSubMenu.hSubMenu );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shfusion.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ShFusion.cpp : Defines the DLL's Entry point and Self-registration code

#include "stdinc.h"

//
// Global variables
//
UINT            g_uiRefThisDll = 0;     // Reference count for this DLL
HINSTANCE       g_hInstance;            // Instance handle for this DLL
LPMALLOC        g_pMalloc = NULL;              // Malloc Interface
HIMAGELIST      g_hImageListSmall;      // Icon index for CExtractIcon and CShellView classes
HIMAGELIST      g_hImageListLarge;
HMODULE         g_hFusionDllMod;
HMODULE         g_hFusResDllMod;
HMODULE         g_hEEShimDllMod;
HANDLE          g_hWatchFusionFilesThread;
DWORD           g_dwFileWatchHandles;
HANDLE          g_hFileWatchHandles[MAX_FILE_WATCH_HANDLES];
BOOL            g_fCloseWatchFileThread;
BOOL            g_fBiDi;
BOOL            g_bRunningOnNT = FALSE;
LCID            g_lcid;

PFCREATEASMENUM             g_pfCreateAsmEnum;
PFNCREATEASSEMBLYCACHE      g_pfCreateAssemblyCache;
PFCREATEASMNAMEOBJ          g_pfCreateAsmNameObj;
PFCREATEAPPCTX              g_pfCreateAppCtx;
PFNGETCACHEPATH             g_pfGetCachePath;
PFNCREATEINSTALLREFERENCEENUM   g_pfCreateInstallReferenceEnum;
PFNGETCORSYSTEMDIRECTORY    g_pfnGetCorSystemDirectory;
PFNGETCORVERSION            g_pfnGetCorVersion;
PFNGETREQUESTEDRUNTIMEINFO  g_pfnGetRequestedRuntimeInfo;

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv);
STDAPI DllGetClassObjectInternal(REFCLSID rclsid, REFIID riid, LPVOID *ppv);
STDAPI DllCanUnloadNow(void);
STDAPI DllRegisterServer(void);
STDAPI DllRegisterServerPath(LPWSTR pwzCacheFilePath);
STDAPI DllUnregisterServer(void);
BOOL MySetFileAttributes(LPCTSTR szDir, DWORD dwAttrib);
void CreateImageLists(void);
BOOL LoadFusionDll(void);
void FreeFusionDll(void);

class CShFusionClassFactory : public IClassFactory
{
protected:
    LONG           m_lRefCount;         // Object reference count

public:
    CShFusionClassFactory();
    ~CShFusionClassFactory();
        
    // IUnknown methods
    STDMETHODIMP            QueryInterface (REFIID, PVOID *);
    STDMETHODIMP_(ULONG)    AddRef ();
    STDMETHODIMP_(ULONG)    Release ();
    
    // IClassFactory methods
    STDMETHODIMP    CreateInstance (LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP    LockServer (BOOL);
};

// **************************************************************************/
BOOL IsViewerDisabled(void)
{
    HKEY        hKeyFusion = NULL;
    DWORD       dwEnabled = 0;

    if( ERROR_SUCCESS == WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_FUSION_VIEWER_KEY, 0, KEY_QUERY_VALUE, &hKeyFusion)) {
        DWORD       dwType = REG_DWORD;
        DWORD       dwSize = sizeof(dwEnabled);
        LONG        lResult;

        lResult = WszRegQueryValueEx(hKeyFusion, SZ_FUSION_DISABLE_VIEWER_NAME, NULL, &dwType, (LPBYTE)&dwEnabled, &dwSize);
        RegCloseKey(hKeyFusion);

        if(dwEnabled) {
            MyTrace("Shfusion has been disabled");
        }
    }

    return dwEnabled ? TRUE : FALSE;
}
// *****************************************************************
void CreateImageLists(void)
{
    int nSmallCx = GetSystemMetrics(SM_CXSMICON);
    int nSmallCy = GetSystemMetrics(SM_CYSMICON);
    int nCx      = GetSystemMetrics(SM_CXICON);
    int nCy      = GetSystemMetrics(SM_CYICON);
    BOOL fLoadResourceDll = FALSE;

    // Already have image lists?
    if(g_hImageListLarge && g_hImageListSmall) {
        return;
    }

    ASSERT(g_hImageListLarge == NULL);
    ASSERT(g_hImageListSmall == NULL);

    if(!g_hFusResDllMod) {
        if(!LoadResourceDll(NULL)) {
            return;
        }
        fLoadResourceDll = TRUE;
    }

    //set the small image list
    if( (g_hImageListSmall = ImageList_Create(nSmallCx, nSmallCy, ILC_COLORDDB | ILC_MASK, 6, 0)) != NULL)
    {
        HICON hIcon;

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_FOLDER), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListSmall, hIcon);
        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_FOLDEROP), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListSmall, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ROOT), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListSmall, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_CACHE_APP), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListSmall, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_CACHE_SIMPLE), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListSmall, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_CACHE_STRONG), 
                                IMAGE_ICON, nSmallCx, nSmallCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListSmall, hIcon);
    }

    //set the large image list
    if( (g_hImageListLarge = ImageList_Create(nCx, nCy, ILC_COLORDDB | ILC_MASK, 6, 0)) != NULL)
    {
        HICON hIcon;

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_FOLDER), 
                                IMAGE_ICON, nCx, nCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListLarge, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_FOLDEROP), 
                                IMAGE_ICON, nCx, nCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListLarge, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_ROOT), 
                                IMAGE_ICON, nCx, nCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListLarge, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_CACHE_APP), 
                                IMAGE_ICON, nCx, nCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListLarge, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_CACHE_SIMPLE), 
                                IMAGE_ICON, nCx, nCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListLarge, hIcon);

        hIcon = (HICON)WszLoadImage(g_hFusResDllMod, MAKEINTRESOURCEW(IDI_CACHE_STRONG), 
                                IMAGE_ICON, nCx, nCy, LR_DEFAULTCOLOR);
        if(hIcon)
            ImageList_AddIcon(g_hImageListLarge, hIcon);
    }

    if(fLoadResourceDll) {
        FreeResourceDll();
    }
}

// **************************************************************************/
STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

    // If the disable viewer regkey is set, tell the shell
    // we can't load. Shell will default to normal shell folder
    // behavior
    //
    if(IsViewerDisabled()) {
        return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);
    }

    // Fix bug 439554, Check just once if we can load are needed DLL's
    // If we can't then fail creation of the class object
    if(g_uiRefThisDll == 0) {
        if(!LoadFusionDll()) {
            return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);
        }
        FreeFusionDll();

        if(!LoadResourceDll(NULL)) {
            return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);
        }
        CreateImageLists();
        FreeResourceDll();
    }

    if (!IsEqualCLSID (rclsid, IID_IShFusionShell)) {
        return ResultFromScode (CLASS_E_CLASSNOTAVAILABLE);
    }
    
    CShFusionClassFactory *pClassFactory = NEW(CShFusionClassFactory);

    if (pClassFactory == NULL) {
        return ResultFromScode (E_OUTOFMEMORY);
    }

    CreateImageLists();

    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);
    pClassFactory->Release();
    return hr;
}

// **************************************************************************/
STDAPI DllGetClassObjectInternal (REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    return DllGetClassObject (rclsid, riid, ppv);
}

// **************************************************************************/
STDAPI DllCanUnloadNow(void)
{
    MyTrace("Shfusion - DllCanUnloadNow");
    return (g_uiRefThisDll == 0) ? S_OK : S_FALSE;
}

// **************************************************************************/
STDAPI DllRegisterServer(void)
{
    return DllRegisterServerPath(NULL);
}

// **************************************************************************/
HRESULT DllRegisterServerPath(LPWSTR pwzCacheFilePath)
{
    HKEY        hKeyCLSID = NULL;
    HKEY        hkeyInprocServer32 = NULL;
    HKEY        hKeyServer = NULL;
    HKEY        hkeyDefaultIcon = NULL;
    HKEY        hKeyCtxMenuHdlr = NULL;
    HKEY        hkeySettings = NULL;
    HKEY        hKeyApproved = NULL;
    HKEY        hKeyNameSpaceDT = NULL;
    HKEY        hKeyShellFolder = NULL;
    DWORD       dwDisposition = 0;
    HRESULT     hr = E_UNEXPECTED;
    DWORD       dwAttrib;
    HRSRC       hRsrcInfo;
    BOOL        fInstalledIni;
    DWORD       dwSize = 0;

    static TCHAR    szDescr[] = TEXT("Fusion Cache");
    TCHAR           szFilePath[_MAX_PATH];
    WCHAR           wzDir[_MAX_PATH];
    WCHAR           wzCorVersion[_MAX_PATH];

    if(!LoadResourceDll(NULL)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if(pwzCacheFilePath == NULL) {
        // If no path is passed in, default to "%windir%\\assembly"
        if (!WszGetWindowsDirectory(wzDir, ARRAYSIZE(wzDir)))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        StrCat(wzDir, SZ_FUSIONPATHNAME);
    }
    else {
        // make some space for desktop.ini
        if (lstrlenW(pwzCacheFilePath) + 1 > _MAX_PATH - lstrlenW(SZ_DESKTOP_INI))
        {
            return E_INVALIDARG;
        }
        StrCpy(wzDir, pwzCacheFilePath);
    }

    // Create the directory if it doesnt exist
    if(!WszCreateDirectory(wzDir, NULL) && (GetLastError() == ERROR_DISK_FULL)) {
        MyTrace("Shfusion - WszCreateDirectory Failed");
        MyTraceW(wzDir);
        return E_UNEXPECTED;    // No point in continuing further
    }

    // Set Fusion Folder attributes
    dwAttrib = (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
    MySetFileAttributes(wzDir, dwAttrib);

    // Write out desktop.ini from resource file
    fInstalledIni = FALSE;
    if((hRsrcInfo = WszFindResource(g_hFusResDllMod, MAKEINTRESOURCEW(IDR_DESKTOPINI), L"TEXT"))) {

        HGLOBAL     hGlobal;
        DWORD       dwSize = SizeofResource(g_hFusResDllMod, hRsrcInfo);

        if (hGlobal = LoadResource(g_hFusResDllMod, hRsrcInfo) ) {

            LPVOID      pR;

            if((pR = LockResource(hGlobal))) {

                HANDLE      hFile;
                WCHAR       wzIniFile[_MAX_PATH];

                // Create the Desktop.ini file and write out the data
                StrCpy(wzIniFile, wzDir);
                StrCat(wzIniFile, SZ_DESKTOP_INI);

                // UnSet attributes
                dwAttrib = WszGetFileAttributes(wzIniFile);
                dwAttrib &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
                MySetFileAttributes(wzIniFile, dwAttrib);

                // Write out file contents
                hFile = WszCreateFile(wzIniFile, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
                if(hFile != INVALID_HANDLE_VALUE) {

                    DWORD   dwBytesWritten;

                    WriteFile(hFile, pR, dwSize, &dwBytesWritten, 0);
                    CloseHandle(hFile);
                    if(dwSize == dwBytesWritten) {
                        dwAttrib = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM;
                        MySetFileAttributes(wzIniFile, dwAttrib);
                        fInstalledIni = TRUE;
                    }
                }
            }
        }
    }

    if(!fInstalledIni) {
        MyTrace("Shfusion - Failed to install desktop.ini file, registration failure!");
        hr = E_FAIL;
    }

    // Create SZ_CLSID
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_CLSID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyCLSID, NULL) != ERROR_SUCCESS) {
        return E_UNEXPECTED;    // No point in continuing further
    }

    if (WszRegSetValueEx(hKeyCLSID, SZ_DEFAULT, 0, REG_SZ,  (const BYTE*)szDescr, 
                (lstrlen(szDescr)+1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;    // No point in continuing further
    }

    // Write InfoTip
    TCHAR szInfoTip[] = SZ_INFOTOOLTIP;
    WszRegSetValueEx(hKeyCLSID, SZ_INFOTOOLTIPKEY, 0, REG_SZ, (const BYTE*)szInfoTip, (lstrlen(szInfoTip)+1) * sizeof(TCHAR));
    RegCloseKey(hKeyCLSID);

    // Load mscoree.dll to get its current install path
    if(!LoadEEShimDll()) {
        MyTrace("Shfusion - Unable to located mscoree.dll, registration failure!");
        return E_UNEXPECTED;
    }

    *szFilePath = L'\0';
    WszGetModuleFileName(g_hEEShimDllMod, szFilePath, _MAX_PATH);
    
    dwSize = _MAX_PATH;
    wzCorVersion[0] = L'\0';
    hr = g_pfnGetCorVersion(wzCorVersion, dwSize, &dwSize);
    FreeEEShimDll();
    if (FAILED(hr))
    {
        return hr;
    }

    // restore hr
    hr = E_UNEXPECTED;

    // There is no point in going further if we didn't load mscoree.dll root file path
    if(!lstrlen(szFilePath) || !lstrlen(wzCorVersion)) {
        MyTrace("Shfusion - Unable to located mscoree.dll, registration failure!");
        return E_UNEXPECTED;
    }

    // Write path out to InprocServer32 key
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_INPROCSERVER32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyInprocServer32, NULL) == ERROR_SUCCESS) {
        if (WszRegSetValueEx(hkeyInprocServer32, SZ_DEFAULT, 0, REG_SZ, 
                (const BYTE*)szFilePath, (lstrlen(szFilePath)+1) * sizeof(TCHAR)) == ERROR_SUCCESS) {
            static TCHAR szApartment[] = SZ_APARTMENT;

            if (WszRegSetValueEx(hkeyInprocServer32, SZ_THREADINGMODEL, 0, REG_SZ, 
                (const BYTE*)szApartment, (lstrlen(szApartment)+1) * sizeof(TCHAR)) == ERROR_SUCCESS) {
                hr = S_OK;
            }
        }

        HKEY hKeyImp;
        if (WszRegCreateKeyEx(hkeyInprocServer32, &(wzCorVersion[1])/*skip 'v'*/, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyImp, NULL) == ERROR_SUCCESS)
        {
            static WCHAR wzEmpty[] = L"\0";
            if (WszRegSetValueEx(hKeyImp, SZ_IMPLEMENTEDINTHISVERSION, 0, REG_SZ, (const BYTE*)wzEmpty, (lstrlenW(wzEmpty)+1)*sizeof(WCHAR)) == ERROR_SUCCESS)
            {
                hr = S_OK;
            }
            RegCloseKey(hKeyImp);
        }
        RegCloseKey(hkeyInprocServer32);
    }

    // Write Server key
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_SERVER, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyServer, NULL) == ERROR_SUCCESS) {
        static TCHAR szModuleName[] = SZ_SHFUSION_DLL_NAME;

        if (WszRegSetValueEx(hKeyServer, SZ_DEFAULT, 0, REG_SZ, 
                (const BYTE*)szModuleName, (lstrlen(szModuleName)+1) * sizeof(TCHAR)) == ERROR_SUCCESS) {
            hr = S_OK;
        }
        RegCloseKey(hKeyServer);
    }

    LONG lRet = WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_APPROVED, 0, KEY_SET_VALUE, &hKeyApproved);
    if (lRet == ERROR_ACCESS_DENIED) {
        MyTrace("Shfusion - Failed to set Approved shell handlers key, registration failure!");
        hr = E_UNEXPECTED;
    }
    else if (lRet == ERROR_FILE_NOT_FOUND) {
        // Its okay.. The key doesn't exist. May be its Win95/98 or older verion of NT
    }

    if (hKeyApproved) {
        if (WszRegSetValueEx(hKeyApproved, SZ_GUID, 0, REG_SZ, 
            (const BYTE*) szDescr, (lstrlen(szDescr) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS) {
            hr = S_OK;
        }
        else {
            MyTrace("Shfusion - Failed to set Approved shell handlers key, registration failure!");
            hr = E_UNEXPECTED;
        }

        RegCloseKey(hKeyApproved);
    }
    
    // Register ShellFolder Attributes
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_SHELLFOLDER, NULL, NULL, REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE, NULL, &hKeyShellFolder, &dwDisposition) == ERROR_SUCCESS) {
        DWORD dwAttr = SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_DROPTARGET | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_NONENUMERATED;
        if (WszRegSetValueEx(hKeyShellFolder, SZ_ATTRIBUTES, 0, REG_BINARY, 
                (LPBYTE)&dwAttr, sizeof(dwAttr)) == ERROR_SUCCESS) {
            hr = S_OK;
        }
        else {
            MyTrace("Shfusion - Failed to register shell folder attributes, registration failure!");
            hr = E_UNEXPECTED;
        }
        RegCloseKey(hKeyShellFolder);
    }

    // Register context menu handler
    // create SZ_CTXMENUHDLR
    if (WszRegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_CTXMENUHDLR, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyCtxMenuHdlr, NULL) != ERROR_SUCCESS) {
        MyTrace("Shfusion - Failed to register context menu handler, registration failure!");
        hr = E_UNEXPECTED;
    }

    RegCloseKey(hKeyCtxMenuHdlr);
    FreeResourceDll();

    return hr;
}

// **************************************************************************/
STDAPI DllUnregisterServer(void)
{
    TCHAR       szDir[_MAX_PATH];
    DWORD       dwAttrib;
    HRESULT     hr = E_UNEXPECTED;

    if (WszRegDeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, SZ_CLSID) == ERROR_SUCCESS){
        hr = S_OK;
    }

    HKEY hKeyApproved = NULL;
    LONG lRet = WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_APPROVED, 0, KEY_SET_VALUE, &hKeyApproved);
    if (lRet == ERROR_ACCESS_DENIED) {
        hr = E_UNEXPECTED;
    }
    else if (lRet == ERROR_FILE_NOT_FOUND) {
        // Its okay.. The key doesn't exist. May be its Win95 or older verion of NT
    }

    if (hKeyApproved) {
        if (WszRegDeleteValue(hKeyApproved, SZ_GUID) != ERROR_SUCCESS) {
            hr &= E_UNEXPECTED;
        }
        RegCloseKey(hKeyApproved);
    }

    // BUGBUG: Since we default to %windir%\assembly, we can't uninstall
    //         all cache locations if they have been moved.
    if (!WszGetWindowsDirectory(szDir, ARRAYSIZE(szDir)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    if (lstrlen(szDir) + lstrlen(SZ_FUSIONPATHNAME) + lstrlen(SZ_DESKTOP_INI) + 1 > _MAX_PATH)
    {
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
    StrCat(szDir, SZ_FUSIONPATHNAME);
    dwAttrib = WszGetFileAttributes(szDir);
    dwAttrib &= ~FILE_ATTRIBUTE_SYSTEM;
    MySetFileAttributes(szDir, dwAttrib);

    if (!WszGetWindowsDirectory(szDir, ARRAYSIZE(szDir)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    
    StrCat(szDir, SZ_FUSIONPATHNAME);
    StrCat(szDir, SZ_DESKTOP_INI);

    dwAttrib = WszGetFileAttributes(szDir);
    dwAttrib &= ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
    MySetFileAttributes(szDir, dwAttrib);
    WszDeleteFile(szDir);

    return hr;
}

// **************************************************************************/
BOOL MySetFileAttributes(LPCTSTR szDir, DWORD dwAttrib)
{
    BOOL    bRC;

    bRC = WszSetFileAttributes(szDir, dwAttrib);

    if(!bRC && !UseUnicodeAPI()) {
        // W9x has a bug where it's possile that this call can fail
        // the first time, so will give it another shot.
        bRC = WszSetFileAttributes(szDir, dwAttrib);
    }

    if(!bRC) {
        MyTrace("SHFUSION - SetFileAttributes failed!");
    }

    return bRC;
}

////////////////////////////////////////////////////////////
// LoadFusionDll function
////////////////////////////////////////////////////////////
// **************************************************************************/
BOOL LoadFusionDll(void)
{
    BOOL        fLoadedFusion = FALSE;
    HMODULE     hMod = NULL;

    //Fusion is already loaded
    if(g_hFusionDllMod) {
        MyTrace("WszLoadLibrary Fusion.Dll - Already loaded");
        return TRUE;
    }

    // Implement tight binding to fusion.dll
    // Start by getting shfusion.dll path
    WCHAR       wszFusionPath[_MAX_PATH];
    
    hMod = WszGetModuleHandle(SZ_SHFUSION_DLL_NAME);
    if (hMod == NULL)
    {
        MyTrace("Failed to get module handle of shfusion.dll");
        return FALSE;
    }
    
    if (!WszGetModuleFileName(hMod, wszFusionPath, ARRAYSIZE(wszFusionPath)))
    {
        // for some reason, GetModuleFileName failed. 
        MyTrace("Failed to get module file name of shfusion.dll");
        return FALSE;
    };

    // Strip off shfusion.dll and append fusion.dll
    *(PathFindFileName(wszFusionPath)) = L'\0';
    StrCat(wszFusionPath, SZ_FUSION_DLL_NAME);

    // Changed API to fix a problem with fusion.dll needing the MSVCR70.DLL  Performing the
    // load this way, enables fusion to load with the runtime in the same directory.
    g_hFusionDllMod = WszLoadLibraryEx(wszFusionPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if(!g_hFusionDllMod) {
        MyTrace("Failed to load Fusion.dll");
        return FALSE;
    }

    // Make sure we loaded the fusion.dll in the same dir as shfusion.
    WCHAR       wszValidatePath[_MAX_PATH];
    if (!WszGetModuleFileName(g_hFusionDllMod, wszValidatePath, ARRAYSIZE(wszValidatePath)))
    {
        MyTrace("Failed to get module file name of fusion.dll");
        return FALSE;
    }

    if(FusionCompareStringAsFilePath(wszFusionPath, wszValidatePath)) {
        // If we hit this assert, then for some reason we
        // are loading fusion.dll from a different path other
        // than where shfusion.dll is located.
        MyTrace("Failed to load Fusion.dll from the same path as shfusion.dll");
        FreeLibrary(g_hFusionDllMod);
        g_hFusionDllMod = NULL;
        ASSERT(0);
    }
    else {
        // Were load, now get some API's
        g_pfCreateAsmEnum       = (PFCREATEASMENUM) GetProcAddress(g_hFusionDllMod, CREATEASSEMBLYENUM_FN_NAME);
        g_pfCreateAssemblyCache = (PFNCREATEASSEMBLYCACHE) GetProcAddress(g_hFusionDllMod, CREATEASSEMBLYCACHE_FN_NAME);
        g_pfCreateAsmNameObj    = (PFCREATEASMNAMEOBJ) GetProcAddress(g_hFusionDllMod, CREATEASSEMBLYOBJECT_FN_NAME);
        g_pfCreateAppCtx        = (PFCREATEAPPCTX) GetProcAddress(g_hFusionDllMod, CREATEAPPCTX_FN_NAME);
        g_pfGetCachePath        = (PFNGETCACHEPATH) GetProcAddress(g_hFusionDllMod, GETCACHEPATH_FN_NAME);
        g_pfCreateInstallReferenceEnum = (PFNCREATEINSTALLREFERENCEENUM) GetProcAddress(g_hFusionDllMod, CREATEINSTALLREFERENCEENUM_FN_NAME);

        if(! (g_pfCreateAsmEnum && g_pfCreateAssemblyCache && g_pfCreateAsmNameObj &&
              g_pfCreateAppCtx && g_pfGetCachePath && g_pfCreateInstallReferenceEnum) )
        {
            MyTrace("Failed to load needed Fusion.dll API's");
            FreeLibrary(g_hFusionDllMod);
            g_hFusionDllMod = NULL;
            ASSERT(0);      // Failed to load needed fusion API's
        }
        else {
            MyTrace("WszLoadLibrary Fusion.Dll");
            fLoadedFusion = TRUE;
        }
    }

    return fLoadedFusion;
}

////////////////////////////////////////////////////////////
// FreeFusionDll function
////////////////////////////////////////////////////////////
// **************************************************************************/
void FreeFusionDll(void)
{
    if(g_hFusionDllMod != NULL) {
        MyTrace("FreeLibrary Fusion.Dll");
        FreeLibrary(g_hFusionDllMod);
        g_hFusionDllMod = NULL;
    }
}

////////////////////////////////////////////////////////////
// LoadResourceDll function
////////////////////////////////////////////////////////////
// **************************************************************************/
BOOL LoadResourceDll(LPWSTR pwzCulture)
{
    WCHAR   wzLangSpecific[MAX_CULTURE_STRING_LENGTH+1];
    WCHAR   wzLangGeneric[MAX_CULTURE_STRING_LENGTH+1];
    WCHAR   wszCorePath[_MAX_PATH];
    WCHAR   wszShFusResPath[_MAX_PATH];
    DWORD   dwPathSize = 0;
    BOOL    fLoadedResDll = FALSE;
    HMODULE hEEShim = NULL;

    *wzLangSpecific = L'\0';
    *wzLangGeneric = L'\0';
    *wszCorePath = L'\0';
    *wszShFusResPath = L'\0';

    //Is ShFusRes is already loaded
    if(g_hFusResDllMod) {
        MyTrace("WszLoadLibrary ShFusRes.dll - Already loaded");
        return TRUE;
    }

    // Try to determine Culture if needed
    // Fix Stress bug 94161 - Checking for NULL now
    if(!pwzCulture || !lstrlen(pwzCulture)) {
        LANGID      langId;

        if(SUCCEEDED(DetermineLangId(&langId))) {
            ShFusionMapLANGIDToCultures(langId, wzLangGeneric, ARRAYSIZE(wzLangGeneric),
                wzLangSpecific, ARRAYSIZE(wzLangSpecific));

            if( (PRIMARYLANGID(langId) == LANG_ARABIC) ||(PRIMARYLANGID(langId) == LANG_HEBREW) ) {
                g_fBiDi = TRUE;
            }
        }
    }

    // Get path core path
    if( (hEEShim = WszLoadLibrary(SZ_MSCOREE_DLL_NAME)) == NULL) {
        MyTrace("Failed to load Mscoree.Dll");
        return FALSE;
    }

    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;
    *wszCorePath = L'\0';

    pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY) GetProcAddress(hEEShim, GETCORSYSTEMDIRECTORY_FN_NAME);

    dwPathSize = ARRAYSIZE(wszCorePath);
    if(pfnGetCorSystemDirectory != NULL) {
        // Get the framework core directory
        pfnGetCorSystemDirectory(wszCorePath, ARRAYSIZE(wszCorePath), &dwPathSize);
    }
    FreeLibrary(hEEShim);

    LPWSTR  pStrPathsArray[] = {wzLangSpecific, wzLangGeneric, pwzCulture, NULL};

    // check the length of possible path of our resource dll
    // to make sure we don't overrun our buffer.
    //
    // corpath + language + '\' + shfusres.dll + '\0'
    if (lstrlenW(wszCorePath) 
        + (pwzCulture&&lstrlenW(pwzCulture)?lstrlenW(pwzCulture):ARRAYSIZE(wzLangGeneric)) 
        + 1 
        + lstrlenW(SZ_SHFUSRES_DLL_NAME) 
        + 1 > _MAX_PATH)
    {
        return FALSE;
    }

    // Go through all the possible path locations for our
    // language dll (ShFusRes.dll). Use the path that has this
    // file installed in it or default to core framework ShFusRes.dll
    // path.
    for(int x = 0; x < NUMBER_OF(pStrPathsArray); x++){
        // Find resource file exists
        StrCpy(wszShFusResPath, wszCorePath);

        if(pStrPathsArray[x]) {
            StrCat(wszShFusResPath, (LPWSTR) pStrPathsArray[x]);
            StrCat(wszShFusResPath, TEXT("\\"));
        }

        StrCat(wszShFusResPath, SZ_SHFUSRES_DLL_NAME);

        MyTrace("Attempting to load:");
        MyTraceW(wszShFusResPath);

        if(WszGetFileAttributes(wszShFusResPath) != -1) {
            break;
        }

        *wszShFusResPath = L'\0';
    }

    if(!lstrlen(wszShFusResPath)) {
        MyTrace("Failed to locate ShFusRes.Dll");
        return FALSE;
    }

    if( (g_hFusResDllMod = WszLoadLibrary(wszShFusResPath)) == NULL) {
        MyTrace("LoadLibary failed to load ShFusRes.Dll");
        return FALSE;
    }

    MyTrace("WszLoadLibrary ShFusRes.Dll");
    return TRUE;
}

////////////////////////////////////////////////////////////
// FreeResourceDll function
////////////////////////////////////////////////////////////
// **************************************************************************/
void FreeResourceDll(void)
{
    if(g_hFusResDllMod != NULL) {
        MyTrace("FreeLibrary ShFusRes.Dll");
        FreeLibrary(g_hFusResDllMod);
        g_hFusResDllMod = NULL;
    }
}

////////////////////////////////////////////////////////////
// LoadEEShimDll function
////////////////////////////////////////////////////////////
// **************************************************************************/
BOOL LoadEEShimDll(void)
{
    BOOL        fLoadedEEShim = FALSE;
    HMODULE     hMod = NULL;

    // EEShim is already loaded
    if(g_hEEShimDllMod) {
        MyTrace("WszLoadLibrary MSCOREE.Dll - Already loaded");
        return TRUE;
    }

    g_hEEShimDllMod = WszLoadLibraryEx(SZ_MSCOREE_DLL_NAME, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if(!g_hEEShimDllMod) {
        MyTrace("Failed to load Mscoree.dll");
        return FALSE;
    }
    
    // Were load, now get some API's
    g_pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY) GetProcAddress(g_hEEShimDllMod, GETCORSYSTEMDIRECTORY_FN_NAME);
    g_pfnGetRequestedRuntimeInfo = (PFNGETREQUESTEDRUNTIMEINFO) GetProcAddress(g_hEEShimDllMod, GETREQUESTEDRUNTIMEINFO_FN_NAME);
    g_pfnGetCorVersion = (PFNGETCORVERSION) GetProcAddress(g_hEEShimDllMod, GETCORVERSION_FN_NAME);
        
    if(! (g_pfnGetCorSystemDirectory && g_pfnGetRequestedRuntimeInfo && g_pfnGetCorVersion) ) {
        MyTrace("Failed to load needed mscoree.dll API's");
        FreeLibrary(g_hEEShimDllMod);
        g_hEEShimDllMod = NULL;
        g_pfnGetCorVersion = NULL;
        g_pfnGetCorSystemDirectory = NULL;
        g_pfnGetRequestedRuntimeInfo = NULL;
        ASSERT(0);
    }
    else {
        MyTrace("Loaded Mscoree.Dll");
        fLoadedEEShim = TRUE;
    }

    return fLoadedEEShim;
}

////////////////////////////////////////////////////////////
// FreeEEShimDll function
////////////////////////////////////////////////////////////
// **************************************************************************/
void FreeEEShimDll(void)
{
    if(g_hEEShimDllMod != NULL) {
        MyTrace("FreeLibrary Mscoree.Dll");
        FreeLibrary(g_hEEShimDllMod);
        g_hEEShimDllMod = NULL;
    }
}

///////////////////////////////////////////////////////////
// CShFusionClassFactory member functions
// **************************************************************************/
CShFusionClassFactory::CShFusionClassFactory()
{
    m_lRefCount = 1;
    g_uiRefThisDll++;
}

// **************************************************************************/
CShFusionClassFactory::~CShFusionClassFactory()
{
    g_uiRefThisDll--;
}

///////////////////////////////////////////////////////////
// IUnknown implementation
//
// **************************************************************************/
STDMETHODIMP CShFusionClassFactory::QueryInterface(REFIID riid, PVOID *ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown)) {            //IUnknown
        *ppv = this;
    }
    else if(IsEqualIID(riid, IID_IClassFactory)) {     //IOleWindow
        *ppv = (IClassFactory*) this;
    }

    if(*ppv) {
                ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

// **************************************************************************/
STDMETHODIMP_(ULONG) CShFusionClassFactory::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

// **************************************************************************/
STDMETHODIMP_(ULONG) CShFusionClassFactory::Release()
{
    LONG    uRef = InterlockedDecrement(&m_lRefCount);

    if(!uRef) {
        DELETE(this);
    }

    return uRef;
}

//
// CreateInstance is called by the shell to create a shell extension object.
//
// Input parameters:
//   pUnkOuter = Pointer to controlling unknown
//   riid      = Reference to interface ID specifier
//   ppvObj    = Pointer to location to receive interface pointer
//
// Returns:
//   HRESULT code signifying success or failure
//
// **************************************************************************/
STDMETHODIMP CShFusionClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid,
    LPVOID FAR *ppvObj)
{
    HRESULT     hr;
    *ppvObj = NULL;

    // Return an error code if pUnkOuter is not NULL, because we don't
    // support aggregation.
    //
    if (pUnkOuter != NULL) {
        return ResultFromScode (CLASS_E_NOAGGREGATION);
    }

    //
    // Instantiate a ContextMenu extension this ShellFolder supports.
    //
    if(IsEqualIID (riid, IID_IShellExtInit) ||
        (IsEqualIID (riid, IID_IContextMenu)) ) 
    {
        CShellView  *pShellView;
        pShellView = NEW(CShellView(NULL, NULL));
        if(!pShellView) {
            return E_OUTOFMEMORY;
        }
        hr = pShellView->QueryInterface(riid, ppvObj);
        pShellView->Release();
        return hr;
    }

    // All other QI's to ShellFolder
    CShellFolder    *pShellFolder = NULL;        // Global ShellFolder object
    if( (pShellFolder = NEW(CShellFolder(NULL, NULL))) == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pShellFolder->QueryInterface(riid, ppvObj);
    pShellFolder->Release();
    return hr;
}

//
// LockServer increments or decrements the DLL's lock count.
//
// **************************************************************************/
STDMETHODIMP CShFusionClassFactory::LockServer(BOOL fLock)
{
    return ResultFromScode (E_NOTIMPL);
}

// Exported functions
//
extern "C"
{
    HRESULT __stdcall Initialize(LPWSTR pwzCacheFilePath, DWORD dwFlags)
    {
        // pszFilePath will eventually contain the install path fusion.dll is attempting to create
        // dwFlags will be the type of assembly directory created, Global, Per User, etc.
        //

        return DllRegisterServerPath(pwzCacheFilePath);
    }

    int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
    {
        OSVERSIONINFOA                  osi;

        #undef OutputDebugStringA
        #undef OutputDebugStringW
        #define OutputDebugStringW  1 @ # $ % ^ error
        #undef OutputDebugString
        #undef _strlwr
        #undef strstr

        switch (dwReason)
        { 
        case DLL_PROCESS_ATTACH:
            {
                // Need to evaluate all exports and if we should control who
                // loads us for security reasons.
                //
                DisableThreadLibraryCalls(hInstance);
                g_bRunningOnNT = OnUnicodeSystem();
                g_hInstance = hInstance;

                memset(&osi, 0, sizeof(osi));
                osi.dwOSVersionInfoSize = sizeof(osi);
                if (!GetVersionExA(&osi)) {
                    return FALSE;
                }
    
                // On XP and above, the lcid used for string comparisons should
                // be locale invariant. Other platforms should use US English.
    
                if (osi.dwMajorVersion >= 5 && osi.dwMinorVersion >= 1 && osi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                    g_lcid = MAKELCID(LOCALE_INVARIANT, SORT_DEFAULT);
                }
                else {
                    g_lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
                }
    
                g_hWatchFusionFilesThread = INVALID_HANDLE_VALUE;
                g_hFusionDllMod         = NULL;
                g_hFusResDllMod         = NULL;
                g_hEEShimDllMod         = NULL;
                g_pfCreateAsmEnum       = NULL;
                g_pfCreateAssemblyCache = NULL;
                g_pfCreateAsmNameObj    = NULL;
                g_pfCreateAppCtx        = NULL;
                g_pfGetCachePath        = NULL;
                g_pfCreateInstallReferenceEnum = NULL;
                g_hImageListSmall       = NULL;
                g_hImageListLarge       = NULL;

                // Shim API's
                g_pfnGetCorSystemDirectory = NULL;
                g_pfnGetRequestedRuntimeInfo = NULL;
                g_pfnGetCorVersion          = NULL;
                
                g_fBiDi                 = FALSE;

                // Get Malloc Interface
#if DBG
                if (FAILED(MemoryStartup()))
                    return FALSE;
#else
                if(FAILED(SHGetMalloc(&g_pMalloc))) {
                    return FALSE; 
                }
#endif

                g_pMalloc->AddRef();
            }
            break;

        case DLL_PROCESS_DETACH:
            {
                if(g_hImageListSmall) {
                    ImageList_Destroy(g_hImageListSmall);
                }

                if(g_hImageListLarge) {
                    ImageList_Destroy(g_hImageListLarge);
                }
#if DBG
                MemoryShutdown();
#else
                SAFERELEASE(g_pMalloc);
#endif
                CloseWatchFusionFileSystem();
            }
            break;
        }

        return 1;
    }
} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shfusion.inc ===
!IF 0

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    shfusion.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Fred Aaron (freda) March 12, 2002

!ENDIF

MSC_WARNING_LEVEL = /W3 /WX
NO_NTDLL=1
USE_MSVCRT=1
NO_BROWSER_FILE=1

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE -DSTRICT=1 -DWINVER=0x0400 -D_WIN32_IE=0x0500

!ifndef $(FREEBUILD)
C_DEFINES = $(C_DEFINES) -DDEBUG
!endif

!ifdef USE_PERFTAGS
C_DEFINES = $(C_DEFINES) -DPERFTAGS
!endif

!ifdef FUSIONBBT
LINKER_FLAGS=$(LINKER_FLAGS) /debug /debugtype:cv,fixup /opt:ref /incremental:no
!elseifdef DEBUG
LINKER_FLAGS = $(LINKER_FLAGS) /debug /debugtype:cv,fixup /opt:ref /incremental:no
!else
LINKER_FLAGS = $(LINKER_FLAGS) -OPT:REF -OPT:ICF
!endif

#
# Set private include paths
#

FUSION_PATH = $(CORBASE)\src\fusion

INCLUDES = \
  $(FUSION_PATH)\inc; \
  $(WINDOWS_INC_PATH);\
  $(BASE_INC_PATH);\
  $(SDK_INC_PATH);\
  $(NET_INC_PATH);\
  $(CORBASE)\src\inc; \
  $(INCLUDES)

!include $(NTMAKEENV)\sources.cor
SOURCES_USED=$(SOURCES_USED) $(NTMAKEENV)\sources.cor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shfuswrap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "Stdinc.h"

#undef GetMenuItemInfoA
#undef GetMenuItemInfoW
#undef GetMenuStringA
#undef GetMenuStringW
#undef InsertMenuA
#undef InsertMenuW
#undef InsertMenuItemA
#undef InsertMenuItemW
#undef SetDlgItemTextA
#undef SetDlgItemTextW
#undef DefDlgProcA
#undef DefDlgProcW

#undef SendMessageA
#undef SendMessageW

#undef OutputDebugStringA
#undef OutputDebugStringW

#include <winuser.h>
#include <winbase.h>        // To get outputdebugstring functions

// Max length of menu item strings
#define MAX_MENU_STRING_LENGTH  2048

//
// Wrapper functions
//

// **************************************************************************/
BOOL
WszAnimate_Open(
  HWND hWnd,
  LPWSTR pwzName)
{
    ASSERT(Is_ATOM(pwzName));
    if(UseUnicodeAPI()) {
        return (BOOL) SendMessageW(hWnd, ACM_OPENW, 0, (LPARAM)pwzName);
    }
    else {
        return (BOOL) SendMessageA(hWnd, ACM_OPENA, 0, (LPARAM)pwzName);
    }
}

// **************************************************************************/
BOOL
WszAnimate_Play(
  HWND hWnd,
  UINT from,
  UINT to,
  UINT rep)
{
    if(UseUnicodeAPI()) {
        return (BOOL) SendMessageW(hWnd, ACM_PLAY, (WPARAM)(rep), (LPARAM)MAKELONG(from, to));
    }
    else {
        return (BOOL) SendMessageA(hWnd, ACM_PLAY, (WPARAM)(rep), (LPARAM)MAKELONG(from, to));
    }
}

// **************************************************************************/
BOOL
WszAnimate_Close(
  HWND hWnd)
{
    return WszAnimate_Open(hWnd, NULL);
}

// **************************************************************************/
int
WszListView_GetItemCount(
  HWND hwndLV)
{
    return (int) WszSendMessage(hwndLV, LVM_GETITEMCOUNT, 0, 0L);
}

// **************************************************************************/
BOOL 
WszListView_DeleteAllItems(
  HWND hwndLV)
{
    return (BOOL) WszSendMessage(hwndLV, LVM_DELETEALLITEMS, 0, 0L);
}

// **************************************************************************/
int
WszListView_InsertItem(
  HWND hwnd,
  LPLVITEMW plvi)
{
    LV_ITEMA    lvItemA = {0};
    LPSTR       pStr = NULL;
    int         iItem = -1;

    if( (hwnd == NULL) || (plvi == NULL)) {
        goto Exit;
    }

    if(UseUnicodeAPI()) {
        iItem = WszSendMessage(hwnd, LVM_INSERTITEMW, 0, (LPARAM) (const LPLVITEMW) plvi);
        goto Exit;
    }

    if(!(plvi->mask & LVIF_TEXT)) {
        iItem = SendMessageA(hwnd, LVM_INSERTITEMA, 0, (LPARAM) (const LPLVITEMA) plvi);
        goto Exit;
    }

    pStr = WideToAnsi(plvi->pszText);
    if(!pStr) {
        goto Exit;
    }

    memcpy(&lvItemA, plvi, sizeof(LV_ITEMA));
    lvItemA.pszText = pStr;
    iItem = SendMessageA(hwnd, LVM_INSERTITEMA, 0, (LPARAM) (const LPLVITEMA) &lvItemA);
    SAFEDELETEARRAY(pStr);

    // Fall thru
    
Exit:
    return iItem;
}

// **************************************************************************/
BOOL
WszListView_SetItem(
  HWND hwnd,
  LPLVITEMW plvi)
{
    LV_ITEMA    lvItemA;
    LPSTR       pStr = NULL;
    BOOL        bRC = FALSE;

    if((hwnd == NULL) || (plvi == NULL)) {
        bRC = FALSE;
        goto Exit;
    }

    if(UseUnicodeAPI()) {
        bRC = WszSendMessage(hwnd, LVM_SETITEMW, 0, (LPARAM)(const LV_ITEMW *) plvi);
        goto Exit;
    }

    if(!(plvi->mask & LVIF_TEXT)) {
        bRC = SendMessageA(hwnd, LVM_SETITEMA, 0, (LPARAM)(const LV_ITEMA *) plvi);
        goto Exit;
    }

    pStr = WideToAnsi(plvi->pszText);
    if(!pStr) {
        goto Exit;
    }

    memcpy(&lvItemA, plvi, sizeof(LV_ITEMA));
    lvItemA.pszText = pStr;
    bRC = SendMessageA(hwnd, LVM_SETITEMA, 0, (LPARAM)(const LV_ITEMA *) &lvItemA);
    SAFEDELETEARRAY(pStr);

    // Fall thru

Exit:
    return bRC;
}

// **************************************************************************/
BOOL
WszListView_GetItem(
  HWND hwndLV,
  LPLVITEMW plvi)
{
    LV_ITEMA    lvItemA;
    LPSTR       pStr = NULL;
    LPWSTR      pWstr = NULL;
    BOOL        fRet = FALSE;

    if( (hwndLV == NULL) || (plvi == NULL)) {
        goto Exit;
    }

    if(UseUnicodeAPI()) {
        fRet = (BOOL) WszSendMessage(hwndLV, LVM_GETITEMW, 0, (LPARAM)(const LPLVITEMW) plvi);
        goto Exit;
    }

    if(!(plvi->mask & LVIF_TEXT)) {
        fRet = (BOOL) WszSendMessage(hwndLV, LVM_GETITEMA, 0, (LPARAM)(const LPLVITEMA) plvi);
        goto Exit;
    }
    
    memcpy(&lvItemA, plvi, sizeof(LV_ITEMA));

    pStr = NEW(char[plvi->cchTextMax]);
    if(!pStr) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }
    
    lvItemA.pszText = pStr;
    fRet = WszSendMessage(hwndLV, LVM_GETITEMA, 0, (LPARAM)(const LPLVITEMA) &lvItemA);
    if(fRet) {
        
        if((pWstr = AnsiToWide((LPSTR)lvItemA.pszText)) == NULL) {
            goto Exit;
        }

        if(lstrlen(pWstr) >= plvi->cchTextMax) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        StrCpy(plvi->pszText, pWstr);
    }

    // Fall thru

Exit:

    SAFEDELETEARRAY(pWstr);
    return fRet;
}

// **************************************************************************/
int
WszListView_InsertColumn(
  HWND hwndLV,
  int  iCol,
  const LPLVCOLUMNW lpCol)
{
    LVCOLUMNA   ColA;
    LPSTR       pStr = NULL;
    int         iRet = -1;
    
    if(UseUnicodeAPI()) {
        iRet = WszSendMessage(hwndLV, LVM_INSERTCOLUMNW, (WPARAM) (int) iCol, (LPARAM) (const LPLVCOLUMNW) lpCol);
        goto Exit;
    }

    if(!(lpCol->mask & LVCF_TEXT)) {
        // No text, no translation needed
        iRet = SendMessageA(hwndLV, LVM_INSERTCOLUMNA, (WPARAM) (int) iCol, (LPARAM) (const LPLVCOLUMNA) lpCol);
        goto Exit;
    }

    if((pStr = WideToAnsi(lpCol->pszText)) == NULL) {
        goto Exit;
    }

    memcpy(&ColA, lpCol, sizeof(LVCOLUMNA));
    ColA.pszText = pStr;
    ColA.cchTextMax = lstrlenA(pStr);
    
    iRet = SendMessageA(hwndLV, LVM_INSERTCOLUMNA, (WPARAM) (int) iCol, (LPARAM) (const LPLVCOLUMNA) &ColA);
    SAFEDELETEARRAY(pStr);

    // Fall thru

Exit:

    return iRet;
}

// **************************************************************************/
BOOL
WszShellExecuteEx(
  LPSHELLEXECUTEINFOW pExecInfoW)
{
    if(UseUnicodeAPI()) {
        return ShellExecuteExW(pExecInfoW);
    }

    if(!pExecInfoW) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SHELLEXECUTEINFOA ExecInfoA;
    BOOL fResult = FALSE;

    LPSTR   strVerb = NULL;
    LPSTR   strParameters = NULL;
    LPSTR   strDirectory = NULL;
    LPSTR   strClass = NULL;
    LPSTR   strFile = NULL;
    
    if((strVerb = WideToAnsi(pExecInfoW->lpVerb)) == NULL) {
        goto CleanupExit;
    }

    if((strParameters = WideToAnsi(pExecInfoW->lpParameters)) == NULL) {
        goto CleanupExit;
    }

    if((strDirectory = WideToAnsi(pExecInfoW->lpDirectory)) == NULL) {
        goto CleanupExit;
    }

    if((strClass = WideToAnsi(pExecInfoW->lpClass)) == NULL) {
        goto CleanupExit;
    }

    ExecInfoA = *(LPSHELLEXECUTEINFOA) pExecInfoW;
    ExecInfoA.lpVerb = strVerb;
    ExecInfoA.lpParameters = strParameters;
    ExecInfoA.lpDirectory = strDirectory;
    ExecInfoA.lpClass = strClass;

    if(lstrlen(pExecInfoW->lpFile)) {
        if((strFile = WideToAnsi(pExecInfoW->lpFile)) == NULL) {
            goto CleanupExit;
        }

        ExecInfoA.lpFile = strFile;
    }

    fResult = ShellExecuteExA(&ExecInfoA);

    // Out parameters
    pExecInfoW->hInstApp = ExecInfoA.hInstApp;
    pExecInfoW->hProcess = ExecInfoA.hProcess;

    // Fall thru

CleanupExit:
    SAFEDELETEARRAY(strVerb);
    SAFEDELETEARRAY(strParameters);
    SAFEDELETEARRAY(strDirectory);
    SAFEDELETEARRAY(strClass);
    SAFEDELETEARRAY(strFile);
    
    return fResult;
}

// **************************************************************************/
int
WszStrCmpICW(
  LPCWSTR pch1,
  LPCWSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= L'A' && ch1 <= L'Z')
            ch1 += L'a' - L'A';

        ch2 = *pch2++;
        if (ch2 >= L'A' && ch2 <= L'Z')
            ch2 += L'a' - L'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}


// **************************************************************************/
BOOL
WszListView_SortItems(
  HWND hwndLV,
  PFNLVCOMPARE pfnCompare,
  LPARAM lParam)
{
    return WszSendMessage(hwndLV, LVM_SORTITEMS, (WPARAM) (LPARAM) lParam,
        (LPARAM)(PFNLVCOMPARE) pfnCompare);
}

// **************************************************************************/
BOOL
WszListView_SetItemState(
  HWND hwndLV,
  int i,
  UINT uState,
  UINT uMask)
{
    LV_ITEM     lvi = {0};

    lvi.state = uState;
    lvi.stateMask = uMask;
    return (BOOL) WszSendMessage(hwndLV, LVM_SETITEMSTATE, (WPARAM)(i), (LPARAM)(LV_ITEM *)&lvi);
}

// **************************************************************************/
BOOL
WszListView_GetItemRect(
  HWND hwndLV,
  int i,
  RECT *prc,
  int iCode)
{
     return (BOOL) WszSendMessage(hwndLV, LVM_GETITEMRECT, (WPARAM)(int)(i), \
           ((prc) ? (((RECT *)(prc))->left = (iCode),(LPARAM)(RECT *)(prc)) : (LPARAM)(RECT *)NULL));
}

int
WszGetMenuString(
    HMENU hMenu,
    UINT uItem,
    LPWSTR lpString,
    int nMaxCount,
    UINT uFlag)
{
    LPWSTR  pwzName = NULL;
    LPSTR   szName = NULL;
    int     iRet = 0;
    
    if (UseUnicodeAPI()) {
        iRet = GetMenuStringW(hMenu, uItem, lpString, nMaxCount, uFlag);
        goto Exit;
    }

    szName = (LPSTR) NEW(char[nMaxCount]);
    if (szName == NULL) {
        goto Exit;
    }

    iRet = GetMenuStringA(hMenu, uItem, szName, nMaxCount, uFlag);

    // Both these values must be set for the function to
    // succeed
    if(nMaxCount && iRet) {
        ULONG   ul = nMaxCount;

        pwzName = AnsiToWide(szName);
        if(!pwzName) {
            iRet = 0;
            goto Exit;
        }

        if(lstrlen(pwzName) > nMaxCount) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            iRet = 0;
            goto Exit;
        }

        StrCpy(lpString, pwzName);
    }

    // Fall thru

Exit:
    SAFEDELETEARRAY(pwzName);
    SAFEDELETEARRAY(szName);
    return iRet;
}

BOOL
WszInsertMenu(
  HMENU   hMenu,
  UINT    uPosition,
  UINT    uFlags,
  UINT_PTR uIDNewItem,
  LPCWSTR lpNewItem)
{
    LPSTR   pStr = NULL;
    BOOL    fRet = FALSE;

    if (UseUnicodeAPI()) {
        fRet = InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        goto Exit;
    }

    //  You can't test for MFT_STRING because MFT_STRING is zero!
    //  So instead you have to check for everything *other* than
    //  a string.
    //
    //  The presence of any non-string menu type turns lpnewItem into
    //  an atom.
    //
    if((uFlags & MFT_NONSTRING)) {
        fRet = InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPCSTR) lpNewItem);
        goto Exit;
    }

    pStr = WideToAnsi(lpNewItem);
    if(!pStr) {
        goto Exit;
    }
        
    fRet = InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, pStr);
    SAFEDELETEARRAY(pStr);

    // Fall thru
    
Exit:
    return fRet;    
}

BOOL
WszInsertMenuItem(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmii)
{
    BOOL    fRet = FALSE;
    
    // Ensure Win95 compatibility
    _ASSERTE(lpmii->cbSize == MENUITEMINFOSIZE_WIN95);

    if (UseUnicodeAPI()) {
        fRet = InsertMenuItemW(hMenu, uItem, fByPosition, lpmii);
        goto Exit;
    }

    MENUITEMINFOA miiA;
    char szText[MAX_MENU_STRING_LENGTH];

    SetThunkMenuItemInfoWToA(lpmii, &miiA, szText, ARRAYSIZE(szText));
    fRet =  InsertMenuItemA(hMenu, uItem, fByPosition, &miiA);

    // Fall thru

Exit:
    return fRet;
    
}


int
WszGetLocaleInfo(
  LCID Locale,
  LCTYPE LCType,
  LPWSTR lpLCData,
  int cchData)
{
    LPWSTR  pwStr = NULL;
    LPSTR   pStr = NULL;
    int     iRet = 0;
    
    if(UseUnicodeAPI()) {
        iRet = GetLocaleInfoW(Locale, LCType, lpLCData, cchData);
        goto Exit;
    }

    pStr = NEW(char[cchData]);

    if(!pStr) {
        goto Exit;
    }

    iRet = GetLocaleInfoA(Locale, LCType, pStr, cchData);
    if(!iRet) {
        goto Exit;
    }
    
    pwStr = AnsiToWide(pStr);

    if(!pwStr) {
        iRet = 0;
        goto Exit;
    }

    if(lstrlen(pwStr) > cchData) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        iRet = 0;
        goto Exit;
    }

    StrCpy(lpLCData, pwStr);

    // Fall thru

Exit:
    SAFEDELETEARRAY(pStr);
    SAFEDELETEARRAY(pwStr);

    return iRet;
}

int
WszGetNumberFormat(
  LCID Locale,
  DWORD dwFlags,
  LPCWSTR lpValue,
  CONST NUMBERFMT *lpFormat,
  LPWSTR lpNumberStr,
  int cchNumber)
{
    NUMBERFMTA      nmftA;
    LPSTR           pStrVal = NULL;
    LPSTR           pStrDecSep = NULL;
    LPSTR           pStrThoSep = NULL;
    LPSTR           pStrFmt = NULL;
    int             iRet = 0;
    
    if(UseUnicodeAPI()) {
        iRet = GetNumberFormatW(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        goto Exit;
    }

    memcpy(&nmftA, lpFormat, sizeof(NUMBERFMTA));

    pStrVal = WideToAnsi(lpValue);
    if(!pStrVal) {
        goto Exit;
    }

    pStrDecSep = WideToAnsi(lpFormat->lpDecimalSep);
    if(!pStrDecSep) {
        goto Exit;
    }
    
    pStrThoSep = WideToAnsi(lpFormat->lpThousandSep);
    if(!pStrThoSep) {
        goto Exit;
    }

    pStrFmt = NEW(char[cchNumber]);
    if(!pStrFmt) {
        goto Exit;
    }

    nmftA.lpDecimalSep = pStrDecSep;
    nmftA.lpThousandSep = pStrThoSep;

    iRet = GetNumberFormatA(Locale, dwFlags, pStrVal, &nmftA, pStrFmt, cchNumber);
    if(iRet) {
        LPWSTR pwStr = AnsiToWide(pStrFmt);

        if(!pwStr) {
            iRet = 0;
            goto Exit;
        }

        if(lstrlen(pwStr) > cchNumber) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        StrCpy(lpNumberStr, pwStr);
        SAFEDELETEARRAY(pwStr);
    }

    // Fall thru

Exit:
    SAFEDELETEARRAY(pStrVal);
    SAFEDELETEARRAY(pStrDecSep);
    SAFEDELETEARRAY(pStrThoSep);
    SAFEDELETEARRAY(pStrFmt);

    return iRet;
}

int
WszGetTimeFormatWrap(
  LCID Locale,
  DWORD dwFlags,
  CONST SYSTEMTIME * lpTime,
  LPCWSTR pwzFormat,
  LPWSTR pwzTimeStr,
  int cchTime)
{
    LPSTR   pszFormat = NULL;
    LPSTR   pszTimeStr = NULL;
    LPWSTR  pwszReturn = NULL;
    int     iRet = 0;
    
    MyTrace("WszGetTimeFormatWrap - Entry");

    if(UseUnicodeAPI()) {
        iRet = GetTimeFormatW(Locale, dwFlags, lpTime, pwzFormat, pwzTimeStr, cchTime);
        goto Exit;
    }

    // Format can be NULL
    if(pwzFormat) {
        pszFormat = WideToAnsi(pwzFormat);
        if(!pszFormat) {
            goto Exit;
        }
    }

    pszTimeStr = NEW(char[cchTime]);
    if(!pszTimeStr) {
        goto Exit;
    }

    iRet = GetTimeFormatA(Locale, dwFlags, lpTime, pszFormat, pszTimeStr, cchTime);
    if(!iRet) {
        goto Exit;
    }

    pwszReturn = AnsiToWide(pszTimeStr);
    if(!pwszReturn) {
        iRet = 0;
        goto Exit;
    }

    if(lstrlen(pwszReturn) > cchTime) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    StrCpy(pwzTimeStr, pwszReturn);
    // Fall thru
    
Exit:
    SAFEDELETEARRAY(pszFormat);
    SAFEDELETEARRAY(pszTimeStr);
    SAFEDELETEARRAY(pwszReturn);
    
    MyTrace("WszGetTimeFormatWrap - Exit");

    return iRet;
}

int
WszGetDateFormatWrap(
  LCID Locale,
  DWORD dwFlags,
  CONST SYSTEMTIME * lpDate,
  LPCWSTR pwzFormat,
  LPWSTR pwzDateStr,
  int cchDate)
{
    LPSTR   pszFormat = NULL;
    LPSTR   pszDateStr = NULL;
    LPWSTR  pwszReturn = NULL;
    int     iRet = 0;
    
    if(UseUnicodeAPI()) {
        iRet = GetDateFormatW(Locale, dwFlags, lpDate, pwzFormat, pwzDateStr, cchDate);
        goto Exit;
    }

    // Format can be NULL
    if(pwzFormat) {
        pszFormat = WideToAnsi(pwzFormat);
        if(!pszFormat) {
            goto Exit;
        }
    }

    pszDateStr = NEW(char[cchDate]);
    if(!pszDateStr) {
        goto Exit;
    }

    iRet = GetDateFormatA(Locale, dwFlags, lpDate, pszFormat, pszDateStr, cchDate);
    if(!iRet) {
        goto Exit;
    }

    pwszReturn = AnsiToWide(pszDateStr);
    if(!pwszReturn) {
        iRet = 0;
        goto Exit;
    }

    if(lstrlen(pwszReturn) > cchDate) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    StrCpy(pwzDateStr, pwszReturn);

    // Fall thru

Exit:
    SAFEDELETEARRAY(pszFormat);
    SAFEDELETEARRAY(pszDateStr);
    SAFEDELETEARRAY(pwszReturn);

    return iRet;
}

void
SetThunkMenuItemInfoWToA(
  LPCMENUITEMINFOW pmiiW,
  LPMENUITEMINFOA pmiiA,
  LPSTR pszBuffer,
  DWORD cchSize)
{
    *pmiiA = *(LPMENUITEMINFOA) pmiiW;

    // MFT_STRING is Zero. So MFT_STRING & anything evaluates to False.
    if ((pmiiW->dwTypeData) && (MFT_STRING & pmiiW->fType) == 0)
    {
        pmiiA->dwTypeData = pszBuffer;
        pmiiA->cch = cchSize;

        LPSTR   pStr = NULL;

        pStr = WideToAnsi(pmiiW->dwTypeData);
        if(!pStr) {
            ASSERT(0);
            return;
        }

        if((DWORD)lstrlenA(pStr) > cchSize) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return;
        }

        lstrcpyA(pszBuffer, pStr);
        SAFEDELETEARRAY(pStr);
    }
}

void
GetThunkMenuItemInfoWToA(
  LPCMENUITEMINFOW pmiiW,
  LPMENUITEMINFOA pmiiA,
  LPSTR pszBuffer,
  DWORD cchSize)
{
    *pmiiA = *(LPMENUITEMINFOA) pmiiW;

    if((pmiiW->dwTypeData) && (MFT_STRING & pmiiW->fType)) {
        pszBuffer[0] = 0;
        pmiiA->dwTypeData = pszBuffer;
        pmiiA->cch = cchSize;
    }
}

BOOL
GetThunkMenuItemInfoAToW(
  LPCMENUITEMINFOA pmiiA,
  LPMENUITEMINFOW pmiiW)
{
    LPWSTR pwzText = pmiiW->dwTypeData;

    *pmiiW = *(LPMENUITEMINFOW) pmiiA;
    pmiiW->dwTypeData = pwzText;

    if((pmiiA->dwTypeData) && (pwzText) &&
        !((MFT_SEPARATOR | MFT_BITMAP) & pmiiW->fType)) {

        LPWSTR pwStr = AnsiToWide(pmiiA->dwTypeData);

        if(!pwStr) {
            return FALSE;
        }

        StrCpy(pmiiW->dwTypeData, pwStr);
        SAFEDELETEARRAY(pwStr);
    }

    return TRUE;
}

BOOL
WszGetMenuItemInfo(
  HMENU  hMenu,
  UINT  uItem,
  BOOL  fByPosition,
  LPMENUITEMINFOW  pmiiW)
{
    MENUITEMINFOA miiA = *(LPMENUITEMINFOA)pmiiW;
    LPSTR   pszText = NULL;
    BOOL    fResult = FALSE;

    ASSERT(pmiiW->cbSize == MENUITEMINFOSIZE_WIN95); // Ensure Win95 compatibility

    if(UseUnicodeAPI()) {
        fResult = GetMenuItemInfoW(hMenu, uItem, fByPosition, pmiiW);
        goto Exit;
    }

    // No string data, A & W are same
    if(!(pmiiW->fMask & MIIM_TYPE)) {
        fResult = GetMenuItemInfoA(hMenu, uItem, fByPosition, (LPMENUITEMINFOA) pmiiW);
        goto Exit;
    }
    
    if (pmiiW->cch > 0) {
        pszText = NEW(char[pmiiW->cch]);

        if(!pszText) {
            goto Exit;
        }
    }

    miiA.dwTypeData = pszText;
    fResult = GetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA);

    if(!fResult) {
        goto Exit;
    }

    fResult = GetThunkMenuItemInfoAToW(&miiA, pmiiW);

    // Fall thru

Exit:
    SAFEDELETEARRAY(pszText);
    return fResult;
}

LRESULT
WszDefDlgProc(
  IN HWND hDlg,
  IN UINT Msg,
  IN WPARAM wParam,
  IN LPARAM lParam)
{
    if(UseUnicodeAPI()) {
        return DefDlgProcW(hDlg, Msg, wParam, lParam);
    }
    else {
        return DefDlgProcA(hDlg, Msg, wParam, lParam);
    }
}

void
WszOutputDebugStringWrap(
  LPCWSTR lpOutputString)
{
    if (UseUnicodeAPI()) {
        OutputDebugStringW(lpOutputString);
        return;
    }

    LPSTR szOutput = NULL;

    szOutput = WideToAnsi(lpOutputString);
    if(szOutput) {
        OutputDebugStringA(szOutput);
        SAFEDELETEARRAY(szOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\util.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Util.h
//

//
// Add Peta 10^15 and Exa 10^18 to support 64-bit integers.
//
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)
#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)
#define MAX_DATE_LEN            64

// Pie Color Types
enum
{
    DP_USEDCOLOR = 0,           // Used Color
    DP_FREECOLOR,               // Free Color
    DP_CACHECOLOR,              // Cache Color
    DP_USEDSHADOW,              // Used Shadow Color
    DP_FREESHADOW,              // Free Shadow Color
    DP_CACHESHADOW,             // Cache Shadow Color
    DP_TOTAL_COLORS     // # of entries
};

#if ((DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK) != 0x07)
#error Definitions of DRIVE_* are changed!
#endif

#define SHID_TYPEMASK           0x7f

#define SHID_COMPUTER           0x20
#define SHID_COMPUTER_1         0x21    // free
#define SHID_COMPUTER_REMOVABLE (0x20 | DRIVE_REMOVABLE)  // 2
#define SHID_COMPUTER_FIXED     (0x20 | DRIVE_FIXED)      // 3
#define SHID_COMPUTER_REMOTE    (0x20 | DRIVE_REMOTE)     // 4
#define SHID_COMPUTER_CDROM     (0x20 | DRIVE_CDROM)      // 5
#define SHID_COMPUTER_RAMDISK   (0x20 | DRIVE_RAMDISK)    // 6
#define SHID_COMPUTER_7         0x27    // free
#define SHID_COMPUTER_DRIVE525  0x28    // 5.25 inch floppy disk drive
#define SHID_COMPUTER_DRIVE35   0x29    // 3.5 inch floppy disk drive
#define SHID_COMPUTER_NETDRIVE  0x2a    // Network drive
#define SHID_COMPUTER_NETUNAVAIL 0x2b   // Network drive that is not restored.
#define SHID_COMPUTER_C         0x2c    // free
#define SHID_COMPUTER_D         0x2d    // free
#define SHID_COMPUTER_REGITEM   0x2e    // Controls, Printers, ...
#define SHID_COMPUTER_MISC      0x2f    // Unknown drive type

const struct { BYTE bFlags; UINT uID; UINT uIDUgly; } c_drives_type[] = 
{
    { SHID_COMPUTER_REMOVABLE,  IDS_DRIVES_REMOVABLE , IDS_DRIVES_REMOVABLE },
    { SHID_COMPUTER_DRIVE525,   IDS_DRIVES_DRIVE525  , IDS_DRIVES_DRIVE525_UGLY },
    { SHID_COMPUTER_DRIVE35,    IDS_DRIVES_DRIVE35   , IDS_DRIVES_DRIVE35_UGLY  },
    { SHID_COMPUTER_FIXED,      IDS_DRIVES_FIXED     , IDS_DRIVES_FIXED     },
    { SHID_COMPUTER_REMOTE,     IDS_DRIVES_NETDRIVE  , IDS_DRIVES_NETDRIVE  },
    { SHID_COMPUTER_CDROM,      IDS_DRIVES_CDROM     , IDS_DRIVES_CDROM     },
    { SHID_COMPUTER_RAMDISK,    IDS_DRIVES_RAMDISK   , IDS_DRIVES_RAMDISK   },
    { SHID_COMPUTER_NETDRIVE,   IDS_DRIVES_NETDRIVE  , IDS_DRIVES_NETDRIVE  },
    { SHID_COMPUTER_NETUNAVAIL, IDS_DRIVES_NETUNAVAIL, IDS_DRIVES_NETUNAVAIL},
    { SHID_COMPUTER_REGITEM,    IDS_DRIVES_REGITEM   , IDS_DRIVES_REGITEM   },
};

int IntSqrt(unsigned long dwNum);
void Int64ToStr( _int64 n, LPTSTR lpBuffer);
void GetTypeString(BYTE bFlags, LPTSTR pszType, DWORD cchType);
UINT GetNLSGrouping(void);
STDAPI_(LPTSTR) AddCommas64(_int64 n, LPTSTR pszOut, UINT cchOut);
LPWSTR CommifyString(LONGLONG n, LPWSTR pszBuf, UINT cchBuf);
BOOL IsAdministrator(void);
BOOL _ShowUglyDriveNames();
int GetSHIDType(BOOL fOKToHitNet, LPCWSTR szRoot);
LPWSTR StrFormatByteSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf, BOOL fGetSizeString);
DWORD_PTR MySHGetFileInfoWrap(LPWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags);
HWND MyHtmlHelpWrapW(HWND hwndCaller, LPWSTR pwzFile, UINT uCommand, DWORD dwData);
HRESULT GetProperties(IAssemblyName *pAsmName, int iAsmProp, PTCHAR *pwStr, DWORD *pdwSize);
LPGLOBALASMCACHE FillFusionPropertiesStruct(IAssemblyName *pAsmName);
HRESULT VersionFromString(LPWSTR wzVersionIn, WORD *pwVerMajor, WORD *pwVerMinor, WORD *pwVerBld, WORD *pwVerRev);
void SafeDeleteAssemblyItem(LPGLOBALASMCACHE pAsmItem);
void BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst);
void UnicodeHexToBin(LPWSTR pSrc, UINT cSrc, LPBYTE pDest);
LPSTR WideToAnsi(LPCWSTR wzFrom);
LPWSTR AnsiToWide(LPCSTR szFrom);
HRESULT StringToVersion(LPCWSTR wzVersionIn, ULONGLONG *pullVer);
HRESULT VersionToString(ULONGLONG ullVer, LPWSTR pwzVerBuf, DWORD dwSize, WCHAR cSeperator);
BOOL SetClipBoardData(LPWSTR pwzData);
void FormatDateString(FILETIME *pftConverTime, FILETIME *pftRangeTime, BOOL fAddTime, LPWSTR wszBuf, DWORD dwBufLen);
void SetRegistryViewState(DWORD dwViewState);
DWORD GetRegistryViewState(void);

// Drawing function proto's
void DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc);
STDMETHODIMP Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPer1000, DWORD dwPerCache1000, const COLORREF *lpColors);

int FusionCompareString(LPCWSTR pwz1, LPCWSTR pwz2, BOOL bCaseSensitive = TRUE);
int FusionCompareStringI(LPCWSTR pwz1, LPCWSTR pwz2);
int FusionCompareStringNI(LPCWSTR pwz1, LPCWSTR pwz2, int nChar);
int FusionCompareStringN(LPCWSTR pwz1, LPCWSTR pwz2, int nChar, BOOL bCaseSensitive = TRUE);
int FusionCompareStringAsFilePath(LPCWSTR pwz1, LPCWSTR pwz2, int nChar = -1);
int FusionCompareStringAsFilePathN(LPCWSTR pwz1, LPCWSTR pwz2, int nChar);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\stdinc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

//
// Macro's
//

#define INC_OLE2
#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#ifndef NUMBER_OF
#define NUMBER_OF(_x) (sizeof(_x) / sizeof((_x)[0]))
#endif

#ifndef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { DELETE(p); (p) = NULL; };
#endif

#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };
#endif

#ifndef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { DELETEARRAY(p); (p) = NULL; };
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#endif

// Pulled from winuser.h
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL 0x00400000L // Right to left mirroring
#endif

#ifndef LAYOUT_RTL
#define LAYOUT_RTL                      0x00000001 // Right to left
#endif

// Pulled from winnls.h
#ifndef DATE_RTLREADING
#define DATE_RTLREADING 0x00000020  // add marks for right to left reading order layout
#endif

#define Is_ATOM(x) IS_INTRESOURCE(x)

//
// Includes
//

#include <winwrap.h>        // Includes windows.h
#include <commctrl.h>
#include <shlwapi.h>
#include <corError.h>
#include <windowsx.h>       // Get macro defines
#include <shellapi.h>       // Get ShellExecute defines
#include <shlobj.h>

// Don't use these
#undef wsprintf
#undef wsprintfA
#undef wsprintfW

#define lstrcmpW     StrCmpW
#define lstrcmpiW    StrCmpIW
#define lstrcatW     StrCatW
#define lstrcpyW     StrCpyW
#define lstrcpynW    StrCpyNW

#define lstrlen      lstrlenW
#define lstrcmp      lstrcmpW
#define lstrcmpi     lstrcmpiW
#define lstrcpyn     lstrcpynW
#define lstrcpy      lstrcpyW
#define lstrcat      lstrcatW
#define wvsprintf    wvsprintfW

#ifndef _NODEBMACRO_
    #include "debmacro.h"
#endif

extern "C" {
   #include <ctype.h>
}

#include "shfuswrap.h"
#include "memtracker.h"
#include "initguid.h"
#include "fusionpriv.h"
#include "list.h"
#include "filestream.h"
#include "..\ShFusRes\resource.h"
#include "ShFusion.h"
#include "HeaderCtrl.h"
#include "DataObject.h"
#include "Globals.h"
#include "ShellFolder.h"
#include "ShellView.h"
#include "ExtractIcon.h"
#include "EnumIDL.h"
#include "DropSource.h"
#include "util.h"

//
// Bind history structure define
//
typedef struct tagBINDENTRYINFO
{
    IHistoryReader  *pReader;
    WCHAR           wszTempPolicyFile[_MAX_PATH];
    WCHAR           wzRuntimeRefVer[MAX_VERSION_DISPLAY_SIZE];
    WCHAR           wzSnapshotRuntimeVer[MAX_VERSION_DISPLAY_SIZE];
    WCHAR           wzMachineConfigPath[MAX_PATH];
    FILETIME        ftMostRecentSnapShot;
    FILETIME        ftRevertToSnapShot;
    BOOL            fPolicyChanged;
    List<AsmBindDiffs *>    *pABDList;
    INT_PTR         iResultCode;
} BINDENTRYINFO, *LPBINDENTRYINFO;

//
// Extern defines
//

#if !DBG
extern LPMALLOC                 g_pMalloc;
#endif
extern BOOL                     g_bRunningOnNT;
extern HINSTANCE                g_hInstance;
extern UINT                     g_uiRefThisDll;
extern HIMAGELIST               g_hImageListSmall;
extern HIMAGELIST               g_hImageListLarge;
extern HMODULE                  g_hFusionDllMod;
extern HMODULE                  g_hFusResDllMod;
extern HMODULE                  g_hEEShimDllMod;
extern HANDLE                   g_hWatchFusionFilesThread;
extern PFCREATEASMENUM          g_pfCreateAsmEnum;
extern PFNCREATEASSEMBLYCACHE   g_pfCreateAssemblyCache;
extern PFCREATEASMNAMEOBJ       g_pfCreateAsmNameObj;
extern PFCREATEAPPCTX           g_pfCreateAppCtx;
extern PFNGETCACHEPATH          g_pfGetCachePath;
extern PFNCREATEINSTALLREFERENCEENUM    g_pfCreateInstallReferenceEnum;
extern PFNGETCORSYSTEMDIRECTORY g_pfnGetCorSystemDirectory;
extern PFNGETCORVERSION         g_pfnGetCorVersion;
extern PFNGETREQUESTEDRUNTIMEINFO g_pfnGetRequestedRuntimeInfo;

extern BOOL LoadFusionDll(void);
extern void FreeFusionDll(void);
extern BOOL LoadResourceDll(LPWSTR pwzCulture);
extern void FreeResourceDll(void);
extern BOOL LoadEEShimDll(void);
extern void FreeEEShimDll(void);

extern HRESULT DetermineLangId(LANGID *pLangId);
extern BOOL ShFusionMapLANGIDToCultures(LANGID langid, LPWSTR pwzGeneric, DWORD dwGenericSize,
                                    LPWSTR pwzSpecific, DWORD dwSpecificSize);

// File watch thread defines
#define MAX_FILE_WATCH_HANDLES      5
extern DWORD    g_dwFileWatchHandles;
extern HANDLE   g_hFileWatchHandles[MAX_FILE_WATCH_HANDLES];
extern BOOL     g_fCloseWatchFileThread;

extern BOOL CreateWatchFusionFileSystem(CShellView *);
extern void SetFileWatchShellViewObject(CShellView *pShellView);
extern void CloseWatchFusionFileSystem(void);

// Defines for mirroring
extern BOOL g_fBiDi;

// This macro captures the length of the longest culture string 
// in table s_rgCultures in culture.cpp. If you 
// change that table, please make sure you check this macro. 
#define MAX_CULTURE_STRING_LENGTH 10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shfuswrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"

#pragma once

//
// Make all MAKEINTRESOURCE call WinWrap.h version of macro
//
#undef MAKEINTRESOURCE
#define MAKEINTRESOURCE(x) \
    MAKEINTRESOURCEW(x)

#define MFT_NONSTRING 0x00000904

//
// Change all wnsprintf functions to always use
// W version since we process everything interally as Wide
//
#undef wnsprintf
#define wnsprintf wnsprintfW

//
// New wrappers
//
#undef ListView_GetItem
#define ListView_GetItem Use_WszListView_GetItem
#undef ShellExecuteEx
#define ShellExecuteEx Use_WszShellExecuteEx
#undef StrCmpICW
#define StrCmpICW Use_WszStrCmpICW
#undef ListView_GetItemCount
#define ListView_GetItemCount Use_WszListView_GetItemCount
#undef ListView_DeleteAllItems
#define ListView_DeleteAllItems Use_WszListView_DeleteAllItems
#undef ListView_InsertItem
#define ListView_InsertItem Use_WszListView_InsertItem
#undef ListView_SetItem
#define ListView_SetItem Use_WszListView_SetItem
#undef ListView_InsertColumn
#define ListView_InsertColumn Use_WszListView_InsertColumn
#undef Animate_Open
#define Animate_Open Use_WszAnimate_Open
#undef Animate_OpenEx
#define Animate_OpenEx Use_WszAnimate_OpenEx
#undef Animate_Play
#define Animate_Play Use_WszAnimate_Play
#undef Animate_Stop
#define Animate_Stop Use_WszAnimate_Stop
#undef Animate_Close
#define Animate_Close Use_WszAnimate_Close
#undef Animate_Seek
#define Animate_Seek Use_WszAnimate_Seek
#undef ListView_SortItems
#define ListView_SortItems Use_WszListView_SortItems
#undef ListView_SetItemState
#define ListView_SetItemState Use_WszListView_SetItemState
#undef ListView_GetItemRect
#define ListView_GetItemRect Use_WszListView_GetItemRect

#undef ListView_GetSelectedCount
#undef ListView_GetItemCount
#undef ListView_GetColumnWidth
#undef ListView_SetColumnWidth
#undef ListView_GetHeader
#undef ListView_DeleteColumn
#undef ListView_SetImageList
#undef ListView_GetItemPosition
#undef ListView_GetItemState
#undef ListView_SetExtendedListViewStyleEx
#undef ListView_GetNextItem
#undef ListBox_GetCurSel
#undef ListBox_ResetContent
#undef ListBox_GetCount
#undef ListBox_SetItemData
#undef ListBox_GetItemData
#undef PropSheet_Changed
#undef Header_GetItem
#undef Header_SetItem
#undef ListView_GetHeader
#undef Header_GetItemCount
#undef GetTimeFormat
#define GetTimeFormat Use_WszGetTimeFormatWrap
#undef GetDateFormat
#define GetDateFormat Use_WszGetDateFormatWrap
#undef DefDlgProc
#define DefDlgProc Use_WszDefDlgProc
#undef GetLocaleInfo
#define GetLocaleInfo Use_WszGetLocaleInfo
#undef WszOutputDebugString
#define WszOutputDebugString WszOutputDebugStringWrap

//
// Simple macro redefinition that changes from SendMessage
// to the winfix.h version of WszSendMessage.
//

#define ListView_GetSelectedCount(hwndLV) \
    (LRESULT) WszSendMessage(hwndLV, LVM_GETSELECTEDCOUNT, 0, 0L)

#define ListView_GetItemCount(hwndLV) \
    (LRESULT) WszSendMessage(hwndLV, LVM_GETITEMCOUNT, 0, 0L)

#define ListView_GetColumnWidth(hwndLV, iCol) \
    (LRESULT) WszSendMessage(hwndLV, LVM_GETCOLUMNWIDTH, (WPARAM) (int) iCol, 0L)

#define ListView_SetColumnWidth(hwndLV, iCol, cx) \
    (BOOL)WszSendMessage(hwndLV, LVM_SETCOLUMNWIDTH, (WPARAM) (int) iCol, MAKELPARAM((int) cx, 0))

#define ListView_GetHeader(hwndLV) \
    (HWND) WszSendMessage(hwndLV, LVM_GETHEADER, 0, 0L)

#define ListView_DeleteColumn(hwndLV, nColumn) \
    (BOOL) WszSendMessage(hwndLV, LVM_DELETECOLUMN, (WPARAM)(int) nColumn, 0L)

#define ListView_SetImageList(hwndLV, himl, iImageList) \
    (HIMAGELIST) WszSendMessage(hwndLV, LVM_SETIMAGELIST, (WPARAM)(int) iImageList, (LPARAM) (HIMAGELIST) himl)

#define ListView_GetItemState(hwndLV, i, mask) \
   (UINT) WszSendMessage(hwndLV, LVM_GETITEMSTATE, (WPARAM)(i), (LPARAM)(mask))

#define ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)\
        (DWORD) WszSendMessage(hwndLV, LVM_SETEXTENDEDLISTVIEWSTYLE, dwMask, dw)

#define ListView_GetNextItem(hwnd, i, flags) \
    (int) WszSendMessage(hwnd, LVM_GETNEXTITEM, (WPARAM)(int)(i), MAKELPARAM((flags), 0))

#define ListView_GetItemPosition(hwndLV, i, ppt) \
    (BOOL) WszSendMessage(hwndLV, LVM_GETITEMPOSITION, (WPARAM)(int)(i), (LPARAM)(POINT *)(ppt))

#define ListBox_GetCurSel(hwndLB) \
    (LRESULT) WszSendMessage(hwndLB, LB_GETCURSEL, 0, 0L)

#define ListBox_ResetContent(hwndLB)\
    (LRESULT) WszSendMessage(hwndLB, LB_RESETCONTENT, 0, 0L)

#define ListBox_GetCount(hwndLB) \
    (LRESULT) WszSendMessage(hwndLB, LB_GETCOUNT, 0, 0L)

#define ListBox_SetItemData(hwndLB, ldx, Value) \
    (LRESULT) WszSendMessage(hwndLB, LB_SETITEMDATA, (WPARAM) ldx, (LPARAM) Value)

#define ListBox_GetItemData(hwndLB, ldx) \
    (LRESULT) WszSendMessage(hwndLB, LB_GETITEMDATA, (WPARAM) ldx, 0L)

#define PropSheet_Changed(hDlg, hwnd) \
    (LRESULT) WszSendMessage(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)

#define Header_GetItem(hwndLV, nColumn, phdi) \
    (BOOL) WszSendMessage(hwndLV, HDM_GETITEM, (WPARAM) (int) nColumn, (LPARAM) (LPHDITEM) phdi)

#define Header_SetItem(hWndLVHeader, nColumn, phdi) \
    (BOOL) WszSendMessage(hWndLVHeader, HDM_SETITEM, (WPARAM)(int) nColumn, (LPARAM) (LPHDITEM) phdi)

#define ListView_GetHeader(hWndLV) \
    (HWND) WszSendMessage(hWndLV, LVM_GETHEADER, 0, 0L)

#define Header_GetItemCount(hWndHeader) \
    (int) WszSendMessage(hWndHeader, HDM_GETITEMCOUNT, 0, 0L)

//
// New prototypes
//
BOOL WszAnimate_Open(HWND, LPWSTR);
BOOL WszAnimate_Play(HWND, UINT, UINT, UINT);
BOOL WszAnimate_Close(HWND);
BOOL WszListView_GetItemRect(HWND, int, LPRECT, int);
BOOL WszListView_GetItem(HWND, LPLVITEMW);
BOOL WszListView_SetItem(HWND, LPLVITEMW);
BOOL WszListView_DeleteAllItems(HWND);
BOOL WszListView_SortItems(HWND, PFNLVCOMPARE, LPARAM);
BOOL WszListView_SetItemState(HWND, int, UINT, UINT);
BOOL WszShellExecuteEx(LPSHELLEXECUTEINFOW pExecInfoW);
int WszStrCmpICW(LPCWSTR, LPCWSTR);
int WszListView_GetItemCount(HWND);
int WszListView_InsertColumn(HWND, int, const LPLVCOLUMNW);
int WszListView_InsertItem(HWND, LPLVITEMW);

//
//  Windows 95 and NT5 do not have the hbmpItem field in their MENUITEMINFO
//  structure.
//
#if (WINVER >= 0x0500)
#define MENUITEMINFOSIZE_WIN95  FIELD_OFFSET(MENUITEMINFOW, hbmpItem)
#else
#define MENUITEMINFOSIZE_WIN95  sizeof(MENUITEMINFOW)
#endif

BOOL
WszGetMenuItemInfo(
  HMENU hMenu,
  UINT uItem,
  BOOL fByPosition,
  LPMENUITEMINFOW lpmii);

int
WszGetMenuString(
  HMENU hMenu,
  UINT uIDItem,
  LPWSTR lpString,
  int nMaxCount,
  UINT uFlag);

BOOL
WszInsertMenu(
  HMENU   hMenu,
  UINT    uPosition,
  UINT    uFlags,
  UINT_PTR uIDNewItem,
  LPCWSTR lpNewItem);

BOOL
WszInsertMenuItem(
  HMENU hMenu,
  UINT uItem,
  BOOL fByPosition,
  LPCMENUITEMINFOW lpmii);

BOOL 
WszSetDlgItemText(
  HWND hDlg,
  int nIDDlgItem,
  LPCWSTR lpString);

int
WszGetLocaleInfo(
  LCID Locale,
  LCTYPE LCType,
  LPWSTR lpLCData,
  int cchData);

WszGetNumberFormat(
  LCID Locale,
  DWORD dwFlags,
  LPCWSTR lpValue,
  CONST NUMBERFMTW *lpFormat,
  LPWSTR lpNumberStr,
  int cchNumber);

int
WszGetTimeFormatWrap(
  LCID Locale,
  DWORD dwFlags,
  CONST SYSTEMTIME * lpTime,
  LPCWSTR pwzFormat,
  LPWSTR pwzTimeStr,
  int cchTime);

int
WszGetDateFormatWrap(
  LCID Locale,
  DWORD dwFlags,
  CONST SYSTEMTIME * lpDate,
  LPCWSTR pwzFormat,
  LPWSTR pwzDateStr,
  int cchDate);

LRESULT
WszDefDlgProc(
  IN HWND hDlg,
  IN UINT Msg,
  IN WPARAM wParam,
  IN LPARAM lParam);

BOOL
GetThunkMenuItemInfoAToW(
  LPCMENUITEMINFOA pmiiA,
  LPMENUITEMINFOW pmiiW);

void
GetThunkMenuItemInfoWToA(
  LPCMENUITEMINFOW pmiiW,
  LPMENUITEMINFOA pmiiA,
  LPSTR pszBuffer,
  DWORD cchSize);

void
SetThunkMenuItemInfoWToA(
  LPCMENUITEMINFOW pmiiW,
  LPMENUITEMINFOA pmiiA,
  LPSTR pszBuffer,
  DWORD cchSize);

void
WszOutputDebugStringWrap(
  LPCWSTR lpOutputString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\util.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdinc.h"
#include <lmaccess.h>
#include "HtmlHelp.h"

extern LCID g_lcid;

// String constants
const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

/**************************************************************************
// Performs SQR calculation
**************************************************************************/
int IntSqrt(unsigned long dwNum)
{
    // We will keep shifting dwNum left and look at the top two bits.

    // initialize sqrt and remainder to 0.
    DWORD dwSqrt = 0, dwRemain = 0, dwTry;
    int i;

    // We iterate 16 times, once for each pair of bits.
    for (i=0; i<16; ++i)
    {
        // Mask off the top two bits of dwNum and rotate them into the
        // bottom of the remainder
        dwRemain = (dwRemain<<2) | (dwNum>>30);

        // Now we shift the sqrt left; next we'll determine whether the
        // new bit is a 1 or a 0.
        dwSqrt <<= 1;

        // This is where we double what we already have, and try a 1 in
        // the lowest bit.
        dwTry = (dwSqrt << 1) + 1;

        if (dwRemain >= dwTry)
        {
            // The remainder was big enough, so subtract dwTry from
            // the remainder and tack a 1 onto the sqrt.
            dwRemain -= dwTry;
            dwSqrt |= 0x01;
        }

        // Shift dwNum to the left by 2 so we can work on the next few
        // bits.
        dwNum <<= 2;
    }

    return(dwSqrt);
}

/**************************************************************************
// Converts 64 bit Int to Str
**************************************************************************/
void Int64ToStr( _int64 n, LPTSTR lpBuffer)
{
    TCHAR   szTemp[MAX_INT64_SIZE];
    _int64  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
/**************************************************************************
// UINT GetNLSGrouping(void)
**************************************************************************/
UINT GetNLSGrouping(void)
{
    UINT grouping;
    LPTSTR psz;
    TCHAR szGrouping[32];

    // If no locale info, then assume Western style thousands
    if(!WszGetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    grouping = 0;
    psz = szGrouping;

    if(g_bRunningOnNT)
    {
        while(1)
        {
            if (*psz == '0')                    // zero - stop
                break;

            else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
                grouping = grouping * 10 + (UINT)(*psz - '0');

            else if (*psz)                      // punctuation - ignore it
                { }

            else                                // end of string, no "0" found
            {
                grouping = grouping * 10;       // put zero on end (see examples)
                break;                          // and finished
            }
            psz++;
        }
    }
    else
    {
        // Win9x - take only the first grouping
        grouping = StrToInt(szGrouping);
    }

    return grouping;
}

/**************************************************************************
// Takes a DWORD, adds commas to it and puts the result in the buffer
**************************************************************************/
STDAPI_(LPTSTR) AddCommas64(LONGLONG n, LPTSTR pszResult, UINT cchResult)
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    nfmt.Grouping = GetNLSGrouping();
    WszGetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (WszGetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, cchResult) == 0)
    {
        DWORD dwSize = lstrlen(szTemp) + 1;
        if (dwSize > cchResult)
            dwSize = cchResult;
        memcpy(pszResult, szTemp, dwSize * sizeof(TCHAR));
        pszResult[cchResult-1] = L'\0';
    }

    return pszResult;
}

/**************************************************************************
// Takes a DWORD add commas etc to it and puts the result in the buffer
**************************************************************************/
LPWSTR CommifyString(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[MAX_COMMA_NUMBER_SIZE], szSep[5];
    NUMBERFMTW nfmt;

    nfmt.NumDigits = 0;
    nfmt.LeadingZero = 0;
    nfmt.Grouping = GetNLSGrouping();
    WszGetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder = 0;

    Int64ToStr(n, szNum);

    if (GetNumberFormatW(LOCALE_USER_DEFAULT, 0, szNum, &nfmt, pszBuf, cchBuf) == 0)
    {
        DWORD dwSize = lstrlen(szNum) + 1;
        if (dwSize > cchBuf)
            dwSize = cchBuf;
        memcpy(pszBuf, szNum, dwSize * sizeof(WCHAR));
        pszBuf[cchBuf - 1] = L'\0';
    }

    return pszBuf;
}

/**************************************************************************
   BOOL IsAdministrator()
**************************************************************************/
BOOL IsAdministrator(void)
{
    BOOL            fAdmin = FALSE;
    HANDLE          hToken = NULL;
    DWORD           dwStatus;
    DWORD           dwACLSize;
    DWORD           cbps = sizeof(PRIVILEGE_SET); 
    PACL            pACL = NULL;
    PSID            psidAdmin = NULL;   
    PRIVILEGE_SET   ps = {0};
    GENERIC_MAPPING gm = {0};
    LPMALLOC        pMalloc;
    PSECURITY_DESCRIPTOR        psdAdmin = NULL;
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;

    // Any other platform besides NT, assume to be ADMIN
    if(!g_bRunningOnNT)
        return TRUE;

    if(FAILED(SHGetMalloc(&pMalloc)))
    {
        // Assume no Admin
        return FALSE;
    }

    // Get the Administrators SID
    if (AllocateAndInitializeSid(&sia, 2, 
                        SECURITY_BUILTIN_DOMAIN_RID, 
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        // Get the Asministrators Security Descriptor (SD)
        psdAdmin = pMalloc->Alloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
        if(InitializeSecurityDescriptor(psdAdmin,SECURITY_DESCRIPTOR_REVISION))
        {
            // Compute size needed for the ACL then allocate the
            // memory for it
            dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
                        GetLengthSid(psidAdmin) - sizeof(DWORD);
            pACL = (PACL) pMalloc->Alloc(dwACLSize);

            // Initialize the new ACL
            if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
            {
                // Add the access-allowed ACE to the DACL
                if(AddAccessAllowedAce(pACL,ACL_REVISION2,
                                     (ACCESS_READ | ACCESS_WRITE),psidAdmin))
                {
                    // Set our DACL to the Administrator's SD
                    if (SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE))
                    {
                        // AccessCheck is downright picky about what is in the SD,
                        // so set the group and owner
                        SetSecurityDescriptorGroup(psdAdmin,psidAdmin,FALSE);
                        SetSecurityDescriptorOwner(psdAdmin,psidAdmin,FALSE);
    
                        // Initialize GenericMapping structure even though we
                        // won't be using generic rights
                        gm.GenericRead = ACCESS_READ;
                        gm.GenericWrite = ACCESS_WRITE;
                        gm.GenericExecute = 0;
                        gm.GenericAll = ACCESS_READ | ACCESS_WRITE;

                        // AccessCheck requires an impersonation token, so lets 
                        // indulge it
                        if (!ImpersonateSelf(SecurityImpersonation)) {
                            return FALSE;
                        }

                        if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
                        {

                        if (!AccessCheck(psdAdmin, hToken, ACCESS_READ, &gm, 
                                        &ps,&cbps,&dwStatus,&fAdmin))
                                fAdmin = FALSE;
                        }
                    }
                }
            }
            pMalloc->Free(pACL);
        }
        pMalloc->Free(psdAdmin);    
        FreeSid(psidAdmin);
    }       

    pMalloc->Release();
    RevertToSelf();

    return(fAdmin);
}

/**************************************************************************
   BOOL _ShowUglyDriveNames()
**************************************************************************/
BOOL _ShowUglyDriveNames()
{
    static BOOL s_fShowUglyDriveNames = (BOOL)42;   // Preload some value to say lets calculate...

    if (s_fShowUglyDriveNames == (BOOL)42)
    {
        int iACP;

        if(g_bRunningOnNT)
        {
            TCHAR szTemp[MAX_PATH];     // Nice large buffer
            if(WszGetLocaleInfo(GetUserDefaultLCID(), LOCALE_IDEFAULTANSICODEPAGE, szTemp, ARRAYSIZE(szTemp)))
            {
                iACP = StrToInt(szTemp);
                // per Samer Arafeh, show ugly name for 1256 (Arabic ACP)
                if (iACP == 1252 || iACP == 1254 || iACP == 1255 || iACP == 1257 || iACP == 1258)
                    goto TryLoadString;
                else
                    s_fShowUglyDriveNames = TRUE;
            } else {
            TryLoadString:
                // All indications are that we can use pretty drive names.
                // Double-check that the localizers didn't corrupt the chars.
                WszLoadString(g_hFusResDllMod, IDS_DRIVES_UGLY_TEST, szTemp, ARRAYSIZE(szTemp));

                // If the characters did not come through properly set ugly mode...
                s_fShowUglyDriveNames = (szTemp[0] != 0x00BC || szTemp[1] != 0x00BD);
            }
        }
        else
        {
            // on win98 the shell font can't change with user locale. Because ACP
            // is always same as system default, and all Ansi APIs are still just 
            // following ACP.
            // 
            iACP = GetACP();
            if (iACP == 1252 || iACP == 1254 || iACP == 1255 || iACP == 1257 || iACP == 1258)
                s_fShowUglyDriveNames = FALSE;
            else
                s_fShowUglyDriveNames = TRUE;
        }
    }
    return s_fShowUglyDriveNames;
}

/**************************************************************************
   void GetTypeString(BYTE bFlags, LPTSTR pszType, DWORD cchType)
**************************************************************************/
void GetTypeString(BYTE bFlags, LPTSTR pszType, DWORD cchType)
{
    *pszType = 0;

    for (int i = 0; i < ARRAYSIZE(c_drives_type); ++i)
    {
        if (c_drives_type[i].bFlags == (bFlags & SHID_TYPEMASK))
        {
            WszLoadString(g_hFusResDllMod, _ShowUglyDriveNames() ? 
                c_drives_type[i].uIDUgly : c_drives_type[i].uID, pszType, cchType);
            break;
        }
    }
}

/**************************************************************************
   int GetSHIDType(BOOL fOKToHitNet, LPCWSTR szRoot)
**************************************************************************/
int GetSHIDType(BOOL fOKToHitNet, LPCWSTR szRoot)
{
    int iFlags = 0;

    iFlags |= SHID_COMPUTER | WszGetDriveType(szRoot);

    switch (iFlags & SHID_TYPEMASK)
    {
        case SHID_COMPUTER | DRIVE_REMOTE:
            iFlags = SHID_COMPUTER_NETDRIVE;
            break;

        // Invalid drive gets SHID_COMPUTER_MISC, which others must check for
        case SHID_COMPUTER | DRIVE_NO_ROOT_DIR:
        case SHID_COMPUTER | DRIVE_UNKNOWN:
        default:
            iFlags = SHID_COMPUTER_FIXED;
            break;
    }

    return iFlags;
}

/**************************************************************************
    LPWSTR StrFormatByteSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf, BOOL fGetSizeString)

  converts numbers into sort formats
    532     -> 523 bytes
    1340    -> 1.3KB
    23506   -> 23.5KB
            -> 2.4MB
            -> 5.2GB
**************************************************************************/
LPWSTR StrFormatByteSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf, BOOL fGetSizeString)
{
    WCHAR szWholeNum[32], szOrder[32];
    int iOrder;

    // If the size is less than 1024, then the order should be bytes we have nothing
    // more to figure out
    if (n < 1024)  {
        wnsprintf(szWholeNum, ARRAYSIZE(szWholeNum), L"%d", LODWORD(n));
        iOrder = 0;
    }
    else {
        UINT uInt, uLen, uDec;
        WCHAR szFormat[8];

        LONGLONG    ulMax = 1000L << 10;

        // Find the right order
        for (iOrder = 1; iOrder < ARRAYSIZE(pwOrders) -1 && n >= ulMax; n >>= 10, iOrder++);
            /* do nothing */

        uInt = LODWORD(n >> 10);
        CommifyString(uInt, szWholeNum, ARRAYSIZE(szWholeNum));
        uLen = lstrlen(szWholeNum);
        if (uLen < 3) {
            uDec = (LODWORD(n - ((LONGLONG)uInt << 10)) * 1000) >> 10;
            // At this point, uDec should be between 0 and 1000
            // we want get the top one (or two) digits.
            uDec /= 10;
            if (uLen == 2)
                uDec /= 10;

            // Note that we need to set the format before getting the
            // intl char.
            lstrcpyW(szFormat, L"%02d");
            szFormat[2] = TEXT('0') + 3 - uLen;

            WszGetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                           szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen);
            uLen = lstrlen(szWholeNum);
            wnsprintf(szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen, szFormat, uDec);
        }
    }

    if(!fGetSizeString) {
        // Format the string
        WszLoadString(g_hFusResDllMod, pwOrders[iOrder], szOrder, ARRAYSIZE(szOrder));
        wnsprintf(pszBuf, cchBuf, szOrder, szWholeNum);
    }
    else {
        // Return the type we are using
        WszLoadString(g_hFusResDllMod, pwOrders[iOrder], szOrder, ARRAYSIZE(szOrder));
        wnsprintf(pszBuf, cchBuf, szOrder, TEXT("\0"));
    }

    return pszBuf;
}

/**************************************************************************
    DWORD_PTR MySHGetFileInfoWrap(LPCWSTR pwzPath, DWORD dwFileAttributes,
                                  SHFILEINFOW FAR  *psfi, UINT cbFileInfo,
                                  UINT uFlags)
**************************************************************************/
#undef SHGetFileInfoW
#undef SHGetFileInfoA

DWORD_PTR MySHGetFileInfoWrap(LPWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW FAR  *psfi, UINT cbFileInfo, UINT uFlags)
{
    HINSTANCE   hInstShell32;
    DWORD       dwRC = 0;

    hInstShell32 = WszLoadLibrary(SZ_SHELL32_DLL_NAME);

    if(!hInstShell32)
        return dwRC;

    if(g_bRunningOnNT)
    {
        PFNSHGETFILEINFOW   pSHGetFileInfoW = NULL;

        pSHGetFileInfoW = (PFNSHGETFILEINFOW) GetProcAddress(hInstShell32, SHGETFILEINFOW_FN_NAME);

        if(pSHGetFileInfoW) {
           dwRC = pSHGetFileInfoW(pwzPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
        }
    }
    else {
        PFNSHGETFILEINFOA   pSHGetFileInfoA = NULL;
        SHFILEINFOA         shFileInfo;

        shFileInfo.szDisplayName[0] = 0;        // Terminate so we can always thunk afterward.
        shFileInfo.szTypeName[0] = 0;           // Terminate so we can always thunk afterward.

        pSHGetFileInfoA = (PFNSHGETFILEINFOA) GetProcAddress(hInstShell32, SHGETFILEINFOA_FN_NAME);

        if(pSHGetFileInfoA) {
           dwRC = pSHGetFileInfoA((LPCSTR)pwzPath, dwFileAttributes, (SHFILEINFOA *)psfi, cbFileInfo, uFlags);

            // Do we need to thunk the Path?
            if (SHGFI_PIDL & uFlags) {
                // No, because it's really a pidl pointer.
                dwRC = pSHGetFileInfoA((LPCSTR)pwzPath, dwFileAttributes, &shFileInfo, sizeof(shFileInfo), uFlags);
            }
            else {
                // Yes
                LPSTR strPath = WideToAnsi(pwzPath);
                if(!strPath) {
                    SetLastError(ERROR_OUTOFMEMORY);
                    goto Exit;
                }
                    
                ASSERT(strPath);

                dwRC = pSHGetFileInfoA(strPath, dwFileAttributes, &shFileInfo, sizeof(shFileInfo), uFlags);
                SAFEDELETEARRAY(strPath);
            }

            psfi->hIcon = shFileInfo.hIcon;
            psfi->iIcon = shFileInfo.iIcon;
            psfi->dwAttributes = shFileInfo.dwAttributes;

            LPWSTR pStr = NULL;

            pStr = AnsiToWide(shFileInfo.szDisplayName);
            if(!pStr) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto Exit;
            }
            ASSERT(pStr);
            StrCpy(psfi->szDisplayName, pStr);
            SAFEDELETEARRAY(pStr);

            pStr = AnsiToWide(shFileInfo.szTypeName);
            if(!pStr) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto Exit;
            }
            ASSERT(pStr);
            StrCpy(psfi->szTypeName, pStr);
            SAFEDELETEARRAY(pStr);
        }
    }

Exit:
    
    FreeLibrary(hInstShell32);
    return dwRC;
}

/**************************************************************************
    void DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc)
**************************************************************************/
void DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc)
{
    HBRUSH hbDraw = CreateSolidBrush(crDraw);
    if (hbDraw)
    {
        HBRUSH hbOld = (HBRUSH)SelectObject(hdc, hbDraw);
        if (hbOld)
        {
            PatBlt(hdc, prc->left, prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                PATCOPY);
            
            SelectObject(hdc, hbOld);
        }
        
        DeleteObject(hbDraw);
    }
}

/**************************************************************************
    STDMETHODIMP Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPer1000, DWORD dwPerCache1000, const COLORREF *lpColors)
**************************************************************************/
STDMETHODIMP Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPer1000, DWORD dwPerCache1000, const COLORREF *lpColors)
{
    ASSERT(lprc != NULL && lpColors != NULL);

    // The majority of this code came from "drawpie.c"
    const LONG c_lShadowScale = 6;       // ratio of shadow depth to height
    const LONG c_lAspectRatio = 2;      // ratio of width : height of ellipse

    // We make sure that the aspect ratio of the pie-chart is always preserved 
    // regardless of the shape of the given rectangle
    // Stabilize the aspect ratio now...
    LONG lHeight = lprc->bottom - lprc->top;
    LONG lWidth = lprc->right - lprc->left;
    LONG lTargetHeight = (lHeight * c_lAspectRatio <= lWidth? lHeight: lWidth / c_lAspectRatio);
    LONG lTargetWidth = lTargetHeight * c_lAspectRatio;     // need to adjust because w/c * c isn't always == w

    // Shrink the rectangle on both sides to the correct size
    lprc->top += (lHeight - lTargetHeight) / 2;
    lprc->bottom = lprc->top + lTargetHeight;
    lprc->left += (lWidth - lTargetWidth) / 2;
    lprc->right = lprc->left + lTargetWidth;

    // Compute a shadow depth based on height of the image
    LONG lShadowDepth = lTargetHeight / c_lShadowScale;

    // check dwPer1000 to ensure within bounds
    if(dwPer1000 > 1000)
        dwPer1000 = 1000;

    // Now the drawing function
    int cx, cy, rx, ry, x[2], y[2];
    int uQPctX10;
    RECT rcItem;
    HRGN hEllRect, hEllipticRgn, hRectRgn;
    HBRUSH hBrush, hOldBrush;
    HPEN hPen, hOldPen;

    rcItem = *lprc;
    rcItem.left = lprc->left;
    rcItem.top = lprc->top;
    rcItem.right = lprc->right - rcItem.left;
    rcItem.bottom = lprc->bottom - rcItem.top - lShadowDepth;

    rx = rcItem.right / 2;
    cx = rcItem.left + rx - 1;
    ry = rcItem.bottom / 2;
    cy = rcItem.top + ry - 1;
    if (rx<=10 || ry<=10)
    {
        return S_FALSE;
    }

    rcItem.right = rcItem.left + 2 * rx;
    rcItem.bottom = rcItem.top + 2 * ry;

    // Translate all parts to caresian system
    int iLoop;

    for(iLoop = 0; iLoop < 2; iLoop++)
    {
        DWORD       dwPer;

        switch(iLoop)
        {
        case 0:
            dwPer = dwPer1000;
            break;
        case 1:
            dwPer = dwPerCache1000;
            break;
        default:
            ASSERT(0);
            break;
        }

        // Translate to first quadrant of a Cartesian system
        uQPctX10 = (dwPer % 500) - 250;
        if (uQPctX10 < 0)
        {
            uQPctX10 = -uQPctX10;
        }

        if (uQPctX10 < 120)
        {
            x[iLoop] = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
                /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

            y[iLoop] = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x[iLoop]*(DWORD)x[iLoop])*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
        }
        else
        {
            y[iLoop] = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
                /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

            x[iLoop] = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y[iLoop]*(DWORD)y[iLoop])*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
        }

        // Switch on the actual quadrant
        switch (dwPer / 250)
        {
        case 1:
            y[iLoop] = -y[iLoop];
            break;

        case 2:
            break;

        case 3:
            x[iLoop] = -x[iLoop];
            break;

        default: // case 0 and case 4
            x[iLoop] = -x[iLoop];
            y[iLoop] = -y[iLoop];
            break;
        }

        // Now adjust for the center.
        x[iLoop] += cx;
        y[iLoop] += cy;

        // Hack to get around bug in NTGDI
        x[iLoop] = x[iLoop] < 0 ? 0 : x[iLoop];
    }

    // Draw the shadows using regions (to reduce flicker).
    hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
    OffsetRgn(hEllipticRgn, 0, lShadowDepth);
    hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+lShadowDepth);
    hRectRgn = CreateRectRgn(0, 0, 0, 0);
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)lShadowDepth);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    // Always draw the whole area in the free shadow
    hBrush = CreateSolidBrush(lpColors[DP_FREESHADOW]);
    if(hBrush)
    {
        FillRgn(hdc, hEllRect, hBrush);
        DeleteObject(hBrush);
    }

    // Draw the used cache shadow if the disk is at least half used.
    if( (dwPerCache1000 != dwPer1000) && (dwPer1000 > 500) &&
         (hBrush = CreateSolidBrush(lpColors[DP_CACHESHADOW]))!=NULL)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(x[0], cy, rcItem.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    // Draw the used shadow only if the disk is at least half used.
    if( (dwPer1000-(dwPer1000-dwPerCache1000) > 500) && (hBrush = CreateSolidBrush(lpColors[DP_USEDSHADOW]))!=NULL)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(x[1], cy, rcItem.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    DeleteObject(hRectRgn);
    DeleteObject(hEllipticRgn);
    DeleteObject(hEllRect);

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    // if per1000 is 0 or 1000, draw full elipse, otherwise, also draw a pie section.
    // we might have a situation where per1000 isn't 0 or 1000 but y == cy due to approx error,
    // so make sure to draw the ellipse the correct color, and draw a line (with Pie()) to
    // indicate not completely full or empty pie.
    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
    hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

    Ellipse(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);

    if( (dwPer1000 != 0) && (dwPer1000 != 1000) )
    {
        // Display Free Section
        hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
        hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

        Pie(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom, rcItem.left, cy, x[0], y[0]);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hBrush);

        if( (x[0] != x[1]) && (y[0] != y[1]) )
        {
            // Display Cache Used dispostion
            hBrush = CreateSolidBrush(lpColors[DP_CACHECOLOR]);
            hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

            Pie(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom, x[0], y[0], x[1], y[1]);
            SelectObject(hdc, hOldBrush);
            DeleteObject(hBrush);
        }
    }

    // Outline to bottom and sides of pie
    Arc(hdc, rcItem.left, rcItem.top+lShadowDepth, rcItem.right - 1, rcItem.bottom+lShadowDepth - 1,
        rcItem.left, cy+lShadowDepth, rcItem.right, cy+lShadowDepth-1);
    MoveToEx(hdc, rcItem.left, cy, NULL);
    LineTo(hdc, rcItem.left, cy+lShadowDepth);
    MoveToEx(hdc, rcItem.right-1, cy, NULL);
    LineTo(hdc, rcItem.right-1, cy+lShadowDepth);

    // Draw vertical lines to complete pie pieces
    if(dwPer1000 > 500 && dwPer1000 < 1000)
    {
        // Used piece
        MoveToEx(hdc, x[0], y[0], NULL);
        LineTo(hdc, x[0], y[0]+lShadowDepth);
    }

    if(dwPerCache1000 > 500 && dwPerCache1000 < 1000)
    {
        // Used Cache piece
        MoveToEx(hdc, x[1], y[1], NULL);
        LineTo(hdc, x[1], y[1]+lShadowDepth);
    }

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);

    return S_OK;    // Everything worked fine
}

/**************************************************************************
    HWND MyHtmlHelpWrapW(HWND hwndCaller, LPWCSTR pwzFile, UINT uCommand, DWORD dwData)
**************************************************************************/
HWND MyHtmlHelpWrapW(HWND hwndCaller, LPWSTR pwzFile, UINT uCommand, DWORD dwData)
{
    HWND    hWnd;

    if(g_bRunningOnNT) {
        hWnd = HtmlHelpW(hwndCaller, pwzFile, uCommand, dwData);
    }
    else {
        LPSTR strPath = WideToAnsi(pwzFile);

        hWnd = HtmlHelpA(hwndCaller, strPath, uCommand, dwData);
        SAFEDELETEARRAY(strPath);
    }

    if(!hWnd) {
        MyTrace("MyHtmlHelpWrapW - Unable to open help file!");
        MyTraceW(pwzFile);
    }

    return hWnd;
}

/**************************************************************************
    Get's the specified property of an IAssemblyName
**************************************************************************/
HRESULT GetProperties(IAssemblyName *pAsmName, int iAsmProp, PTCHAR *pwStr, DWORD *pdwSize)
{
    HRESULT     hRc = S_FALSE;
    DWORD       dwSize;

    if( (pAsmName != NULL) && (pwStr != NULL) && (pdwSize != NULL) )
    {
        dwSize = *pdwSize = 0;
        *pwStr = NULL;

        if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == 
            pAsmName->GetProperty(iAsmProp, NULL, &dwSize) )
        {
            *pdwSize = dwSize;
            if( (*pwStr = (PTCHAR) (NEW(BYTE[dwSize]))) == NULL) {
                return E_OUTOFMEMORY;
            }

            memset(*pwStr, 0, dwSize);

            if( SUCCEEDED(pAsmName->GetProperty(iAsmProp, *pwStr, &dwSize)) ) {
                hRc = S_OK;
            }
            else {
                SAFEDELETE(*pwStr);
                *pdwSize = 0;
                hRc = S_FALSE;
            }
        }
    }

    return hRc;
}

/**************************************************************************
    Capture all information about a specific IAssemblyName
**************************************************************************/
LPGLOBALASMCACHE FillFusionPropertiesStruct(IAssemblyName *pAsmName)
{
    LPGLOBALASMCACHE        pGACItem;
    PTCHAR                  pwStr;
    DWORD                   dwSize;

    int                     iAllAsmItems[] = {
        ASM_NAME_PUBLIC_KEY,
        ASM_NAME_PUBLIC_KEY_TOKEN,
        ASM_NAME_HASH_VALUE,
        ASM_NAME_CUSTOM,
        ASM_NAME_NAME,
        ASM_NAME_MAJOR_VERSION,
        ASM_NAME_MINOR_VERSION,
        ASM_NAME_BUILD_NUMBER,
        ASM_NAME_REVISION_NUMBER,
        ASM_NAME_CULTURE,
        ASM_NAME_HASH_ALGID,
        ASM_NAME_CODEBASE_URL,
        ASM_NAME_CODEBASE_LASTMOD,
    };

    if(pAsmName == NULL)
        return NULL;

    if((pGACItem = (LPGLOBALASMCACHE) NEW(GLOBALASMCACHE)) == NULL)
        return NULL;

    memset(pGACItem, 0, sizeof(GLOBALASMCACHE));

    for(int iLoop = 0; iLoop < ARRAYSIZE(iAllAsmItems); iLoop++)
    {
        if( SUCCEEDED(GetProperties(pAsmName, iAllAsmItems[iLoop], &pwStr, &dwSize)) )
        {
            if(pwStr != NULL)
            {
                switch(iAllAsmItems[iLoop])
                {
                // blobs
                case ASM_NAME_PUBLIC_KEY:
                    pGACItem->PublicKey.ptr = (LPVOID) pwStr;
                    pGACItem->PublicKey.dwSize = dwSize;
                    break;
                case ASM_NAME_PUBLIC_KEY_TOKEN:
                    pGACItem->PublicKeyToken.ptr = (LPVOID) pwStr;
                    pGACItem->PublicKeyToken.dwSize = dwSize;
                    break;
                case ASM_NAME_HASH_VALUE:
                    pGACItem->Hash.ptr = (LPVOID) pwStr;
                    pGACItem->Hash.dwSize = dwSize;
                    break;
                case ASM_NAME_CUSTOM:
                    pGACItem->Custom.ptr = (LPVOID) pwStr;
                    pGACItem->Custom.dwSize = dwSize;
                    break;

                // PTCHAR
                case ASM_NAME_NAME:
                    pGACItem->pAsmName = pwStr;
                    break;
                case ASM_NAME_CULTURE:
                    pGACItem->pCulture = pwStr;
                    break;
                case ASM_NAME_CODEBASE_URL:
                    pGACItem->pCodeBaseUrl = pwStr;
                    break;

                // word
                case ASM_NAME_MAJOR_VERSION:
                    pGACItem->wMajorVer = (WORD) *pwStr;
                    SAFEDELETEARRAY(pwStr);
                    break;
                case ASM_NAME_MINOR_VERSION:
                    pGACItem->wMinorVer = (WORD) *pwStr;
                    SAFEDELETEARRAY(pwStr);
                    break;
                case ASM_NAME_BUILD_NUMBER:
                    pGACItem->wBldNum = (WORD) *pwStr;
                    SAFEDELETEARRAY(pwStr);
                    break;
                case ASM_NAME_REVISION_NUMBER:
                    pGACItem->wRevNum = (WORD) *pwStr;
                    SAFEDELETEARRAY(pwStr);
                    break;

                // dword
                case ASM_NAME_HASH_ALGID:
                    pGACItem->dwHashALGID = (DWORD) *pwStr;
                    SAFEDELETEARRAY(pwStr);
                    break;

                // filetime 
                case ASM_NAME_CODEBASE_LASTMOD:
                    pGACItem->pftLastMod = (LPFILETIME) pwStr;
                    break;
                }
            }
        }
    }

    return pGACItem;
}

/**************************************************************************
    Convert a version string to it's values
**************************************************************************/
HRESULT VersionFromString(LPWSTR wzVersionIn, WORD *pwVerMajor, WORD *pwVerMinor,
                          WORD *pwVerBld, WORD *pwVerRev)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwzVersion = NULL;
    WCHAR       *pchStart = NULL;
    WCHAR       *pch = NULL;
    DWORD       dwSize;
    WORD        *pawVersions[4] = {pwVerMajor, pwVerMinor, pwVerBld, pwVerRev};
    int         i;

    if (!wzVersionIn || !pwVerMajor || !pwVerMinor || !pwVerRev || !pwVerBld) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSize = lstrlen(wzVersionIn) + 1;
    
    pwzVersion = NEW(WCHAR[dwSize]);
    if (!pwzVersion) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    StrCpy(pwzVersion, wzVersionIn);

    pchStart = pch = pwzVersion;

    *pwVerMajor = 0;
    *pwVerMinor = 0;
    *pwVerRev = 0;
    *pwVerBld = 0;

    for (i = 0; i < 4; i++) {

        while (*pch && *pch != L'.') {
            pch++;
        }
    
        if (i < 3) {
            if (!*pch) {
                // Badly formatted string
                hr = E_UNEXPECTED;
                goto Exit;
            }

            *pch++ = L'\0';
        }
    
        *(pawVersions[i]) = (WORD)StrToIntW(pchStart);
        pchStart = pch;
    }

Exit:
    SAFEDELETEARRAY(pwzVersion);

    return hr;
}

/**************************************************************************
    Clean up and destroy a cache item struct
**************************************************************************/
void SafeDeleteAssemblyItem(LPGLOBALASMCACHE pAsmItem)
{
    if(pAsmItem) {

        // Free all memory items
        SAFEDELETEARRAY(pAsmItem->pAsmName);
        SAFEDELETEARRAY(pAsmItem->pCulture);
        SAFEDELETEARRAY(pAsmItem->pCodeBaseUrl);
        SAFEDELETE(pAsmItem->PublicKey.ptr);
        SAFEDELETE(pAsmItem->PublicKeyToken.ptr);
        SAFEDELETE(pAsmItem->Hash.ptr);
        SAFEDELETE(pAsmItem->Custom.ptr);
        SAFEDELETE(pAsmItem->pftLastMod);
        SAFEDELETEARRAY(pAsmItem->pwzAppSID);
        SAFEDELETEARRAY(pAsmItem->pwzAppId);
        SAFEDELETEARRAY(pAsmItem->pAssemblyFilePath);

        SAFEDELETE(pAsmItem);
    }
}

#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))
////////////////////////////////////////////////////////////
// Convert binary into a unicode hex string
////////////////////////////////////////////////////////////
void BinToUnicodeHex(LPBYTE pSrc, UINT cSrc, LPWSTR pDst)
{
    UINT x, y, v;

    for ( x = 0, y = 0 ; x < cSrc ; ++x ) {
        v = pSrc[x] >> 4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x] & 0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

#define TOLOWER(a) (((a) >= L'A' && (a) <= L'Z') ? (L'a' + (a - L'A')) : (a))
#define FROMHEX(a) ((a)>=L'a' ? a - L'a' + 10 : a - L'0')
////////////////////////////////////////////////////////////
// Convert unicode hex string to binary data
////////////////////////////////////////////////////////////
void UnicodeHexToBin(LPWSTR pSrc, UINT cSrc, LPBYTE pDest)
{
    BYTE v;
    LPBYTE pd = pDest;
    LPCWSTR ps = pSrc;

    for (UINT i = 0; i < cSrc-1; i+=2)
    {
        v =  FROMHEX(TOLOWER(ps[i])) << 4;
        v |= FROMHEX(TOLOWER(ps[i+1]));
       *(pd++) = v;
    }
}

////////////////////////////////////////////////////////////
// static WideToAnsi conversion function
////////////////////////////////////////////////////////////
LPSTR WideToAnsi(LPCWSTR wzFrom)
{
    LPSTR   pszStr = NULL;

    int     cchRequired;

    cchRequired = WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, NULL, 0, NULL, NULL);

    if( (pszStr = NEW(char[cchRequired])) != NULL) {
        if(!WideCharToMultiByte(CP_ACP, 0, wzFrom, -1, pszStr, cchRequired, NULL, NULL)) {
            SAFEDELETEARRAY(pszStr);
        }
    }

    return pszStr;
}

////////////////////////////////////////////////////////////
// static AnsiToWide conversion function
////////////////////////////////////////////////////////////
LPWSTR AnsiToWide(LPCSTR szFrom)
{
    LPWSTR  pwzStr = NULL;
    int cwchRequired;

    cwchRequired = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, NULL, 0);

    if( (pwzStr = NEW(WCHAR[cwchRequired])) != NULL) {
        if(!MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwzStr, cwchRequired)) {
            SAFEDELETEARRAY(pwzStr);
        }
    }

    return pwzStr;
}

////////////////////////////////////////////////////////////
// Converts version string "1.0.0.0" to ULONGLONG
////////////////////////////////////////////////////////////
HRESULT StringToVersion(LPCWSTR wzVersionIn, ULONGLONG *pullVer)
{
    HRESULT         hr = S_OK;
    LPWSTR          pwzVersion = NULL;
    LPWSTR          pwzStart = NULL;
    LPWSTR          pwzCur = NULL;
    int             i;
    WORD            wVerMajor = 0;
    WORD            wVerMinor = 0;
    WORD            wVerRev = 0;
    WORD            wVerBld = 0;
    DWORD           dwVerHigh;
    DWORD           dwVerLow;
    DWORD           dwSize;
    WORD            *pawVersion[4] = { &wVerMajor, &wVerMinor, &wVerBld, &wVerRev };
    WORD            cVersions = sizeof(pawVersion) / sizeof(pawVersion[0]);

    ASSERT(wzVersionIn && pullVer);

    dwSize = lstrlen(wzVersionIn) + 1;

    pwzVersion = (LPWSTR) NEW(WCHAR[dwSize]);
    if (!pwzVersion) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Remove any Left Spaces
    pwzStart = (LPWSTR)wzVersionIn;
    for(; *pwzStart == L' '; pwzStart++);
    StrCpy(pwzVersion, pwzStart);

    // Remove any Right Spaces
    pwzStart = pwzVersion + lstrlen(pwzStart) - 1;
    for(; *pwzStart == L' '; pwzStart--) {
        *pwzStart = L'\0';
    }

    pwzStart = pwzCur = pwzVersion;

    for (i = 0; i < cVersions; i++) {
        while (*pwzCur && *pwzCur != L'.') {
            pwzCur++;
        }
    
        if (!pwzCur && cVersions != 4) {
            // malformed version string
            hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
            goto Exit;
        }

        *pwzCur++ = L'\0';
        *(pawVersion[i]) = (WORD)StrToInt(pwzStart);

        pwzStart = pwzCur;
    }

    dwVerHigh = (((DWORD)wVerMajor << 16) & 0xFFFF0000);
    dwVerHigh |= ((DWORD)(wVerMinor) & 0x0000FFFF);

    dwVerLow = (((DWORD)wVerBld << 16) & 0xFFFF0000);
    dwVerLow |= ((DWORD)(wVerRev) & 0x0000FFFF);

    *pullVer = (((ULONGLONG)dwVerHigh << 32) & 0xFFFFFFFF00000000) | (dwVerLow & 0xFFFFFFFF);

Exit:
    SAFEDELETEARRAY(pwzVersion);

    return hr;
}

////////////////////////////////////////////////////////////
// Converts numerical version into string verion "1.0.0.0"
////////////////////////////////////////////////////////////
HRESULT VersionToString(ULONGLONG ullVer, LPWSTR pwzVerBuf, DWORD dwSize, WCHAR cSeperator)
{
    DWORD dwVerHi, dwVerLo;

    if(!pwzVerBuf) {
        return E_INVALIDARG;
    }

    dwVerHi = DWORD ((ULONGLONG)ullVer >> 32);
    dwVerLo = DWORD ((ULONGLONG)ullVer & 0xFFFFFFFF);

    wnsprintf(pwzVerBuf, dwSize, L"%d%c%d%c%d%c%d", (dwVerHi & 0xffff0000)>>16, cSeperator,
        (dwVerHi & 0xffff), cSeperator, (dwVerLo & 0xffff0000)>>16, cSeperator, (dwVerLo & 0xffff));

    return S_OK;
}

////////////////////////////////////////////////////////////
// Sets the clipboard data
////////////////////////////////////////////////////////////
BOOL SetClipBoardData(LPWSTR pwzData)
{
    LPWSTR  wszPasteData;
    DWORD   dwSize;
    HGLOBAL hglbObj;

    if(!pwzData) {
        return FALSE;
    }

    if(!OpenClipboard(NULL)) {
        return FALSE;
    }

    EmptyClipboard();

    // Allocate a global memory object for the text.
    dwSize = (lstrlen(pwzData) + 1) * sizeof(WCHAR);
    hglbObj = GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if(hglbObj == NULL) {
        CloseClipboard();
        return FALSE;
    }

    // Lock the handle and copy the text to the buffer. 
    wszPasteData = (LPWSTR) GlobalLock(hglbObj);
    *wszPasteData = L'\0';

    if(g_bRunningOnNT) {
        memcpy(wszPasteData, pwzData, dwSize);
    }
    else {
        LPSTR pszData = WideToAnsi(pwzData);
        memcpy(wszPasteData, pszData, lstrlenA(pszData)+1);
        SAFEDELETEARRAY(pszData);
    }

    GlobalUnlock(hglbObj);

    // Place the handle on the clipboard.
    SetClipboardData(g_bRunningOnNT ? CF_UNICODETEXT : CF_TEXT, hglbObj);

    // Close the clipboard.
    CloseClipboard();

    return TRUE;
}

// **************************************************************************/
void FormatDateString(FILETIME *pftConverTime, FILETIME *pftRangeTime, BOOL fAddTime, LPWSTR wszBuf, DWORD dwBufLen)
{
    SYSTEMTIME      stLocal;
    FILETIME        ftLocalTime;
    BOOL            fAddDiffTime = FALSE;

    WCHAR       wszBufDate[MAX_DATE_LEN];
    WCHAR       wszBufTime[MAX_DATE_LEN];
    WCHAR       wszBufDateRange[MAX_DATE_LEN];
    WCHAR       wszBufTimeRange[MAX_DATE_LEN];
    DWORD       dwFlags;

    *wszBufDate = '\0';
    *wszBufTime = '\0';
    *wszBufDateRange = '\0';
    *wszBufTimeRange = '\0';

    dwFlags = g_fBiDi ? DATE_RTLREADING : 0;

    // Fix 435021, URTUI: "Fix an application" wizard shows a strange date range
    FileTimeToLocalFileTime(pftConverTime, &ftLocalTime);
    FileTimeToSystemTime(&ftLocalTime, &stLocal);

    WszGetDateFormatWrap(LOCALE_USER_DEFAULT, dwFlags, &stLocal, NULL, wszBufDate, ARRAYSIZE(wszBufDate));
    WszGetTimeFormatWrap(LOCALE_USER_DEFAULT, 0, &stLocal, NULL, wszBufTime, ARRAYSIZE(wszBufTime));

    if(pftRangeTime != NULL) {
        FILETIME        ftRangeLocalTime;
        SYSTEMTIME      stLocalRange;

        // Fix 447986, Last modified time of assemblies in viewer is offset by +7 hours
        FileTimeToLocalFileTime(pftRangeTime, &ftRangeLocalTime);
        FileTimeToSystemTime(&ftRangeLocalTime, &stLocalRange);
        WszGetDateFormatWrap(LOCALE_USER_DEFAULT, dwFlags, &stLocalRange, NULL, wszBufDateRange, ARRAYSIZE(wszBufDateRange));
        WszGetTimeFormatWrap(LOCALE_USER_DEFAULT, 0, &stLocalRange, NULL, wszBufTimeRange, ARRAYSIZE(wszBufTimeRange));

        // Determine if we should display times for dates that are 
        // < 24 hours different
        if( (stLocal.wYear == stLocalRange.wYear) && (stLocal.wMonth == stLocalRange.wMonth) &&
            (stLocal.wDayOfWeek == stLocalRange.wDayOfWeek) && (stLocal.wDay == stLocalRange.wDay) ) {
            fAddDiffTime = TRUE;
        }
    }

    if(fAddTime) {
        wnsprintf(wszBuf, dwBufLen, L"%ws %ws", wszBufDate, wszBufTime);
        return;
    }

    if(fAddDiffTime) {
        wnsprintf(wszBuf, dwBufLen, L"%ws %ws - %ws %ws", wszBufDate, wszBufTime, wszBufDateRange, wszBufTimeRange);
        return;
    }
    
    if(pftRangeTime != NULL) {
        wnsprintf(wszBuf, dwBufLen, L"%ws - %ws", wszBufDate, wszBufDateRange);
        return;
    }

    wnsprintf(wszBuf, dwBufLen, L"%ws", wszBufDate);
    return;
}

// **************************************************************************/
DWORD GetRegistryViewState(void)
{
    HKEY        hKeyFusion = NULL;
    DWORD       dwResult = -1;

    if( ERROR_SUCCESS == WszRegOpenKeyEx(FUSION_PARENT_KEY, SZ_FUSION_VIEWER_KEY, 0, KEY_READ, &hKeyFusion)) {
        DWORD       dwType = REG_DWORD;
        DWORD       dwSize = sizeof(dwResult);
        LONG        lResult;

        lResult = WszRegQueryValueEx(hKeyFusion, SZ_FUSION_VIEWER_STATE, NULL, &dwType, (LPBYTE)&dwResult, &dwSize);
        RegCloseKey(hKeyFusion);
    }

    return dwResult;
}

// **************************************************************************/
void SetRegistryViewState(DWORD dwViewState)
{
    HKEY        hKeyFusion = NULL;
    DWORD       dwDisposition = 0;

    if (WszRegCreateKeyEx(FUSION_PARENT_KEY, SZ_FUSION_VIEWER_KEY, NULL, NULL, REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE, NULL, &hKeyFusion, &dwDisposition) == ERROR_SUCCESS) {
            WszRegSetValueEx(hKeyFusion, SZ_FUSION_VIEWER_STATE, 0, REG_DWORD, (LPBYTE)&dwViewState, sizeof(dwViewState));
            RegCloseKey(hKeyFusion);
    }
}

int FusionCompareStringNI(LPCWSTR pwz1, LPCWSTR pwz2, int nChar)
{
    return FusionCompareStringN(pwz1, pwz2, nChar, FALSE);
}

int FusionCompareStringN(LPCWSTR pwz1, LPCWSTR pwz2, int nChar, BOOL bCaseSensitive)
{
    DWORD                                   dwCmpFlags = 0;
    int                                     iCompare;
    int                                     iLen1;
    int                                     iLen2;
    int                                     iRet = 0;

    // BUGBUG: some of the calling code assumes it can call this with
    // NULL as a parameter. We need to fix this in the future, so we don't
    // have to compensate for it here.
    //
    // ASSERT(pwz1 && pwz2);

    if (!pwz1 && pwz2) {
        return -1;
    }
    else if (pwz1 && !pwz2) {
        return 1;
    }
    else if (!pwz1 && !pwz2) {
        return 0;
    }

    if (!g_bRunningOnNT) {
        if (bCaseSensitive) {
            return StrCmpN(pwz1, pwz2, nChar);
        }
        else {
            return StrCmpNI(pwz1, pwz2, nChar);
        }
    }
    
    if (!bCaseSensitive) {
        dwCmpFlags |= NORM_IGNORECASE;
    }

    iLen1 = lstrlenW(pwz1);
    iLen2 = lstrlenW(pwz2);

    // CompareString on "foo" and "f\xfffeoo" compare equal, because
    // \xfffe is a non-sortable character.
    
    if (nChar <= iLen1 && nChar <= iLen2) {
        iLen1 = nChar;
        iLen2 = nChar;
    }
    else if (nChar <= iLen1 && nChar > iLen2) {
        // Only compare up to the NULL terminator of the shorter string
        iLen1 = iLen2 + 1;
    }
    else if (nChar <= iLen2 && nChar > iLen1) {
        // Only compare up to the NULL terminator of the shorter string
        iLen2 = iLen1 + 1;
    }

    iCompare = CompareString(g_lcid, dwCmpFlags, pwz1, iLen1, pwz2, iLen2);

    return (iCompare - CSTR_EQUAL);
}

int FusionCompareStringI(LPCWSTR pwz1, LPCWSTR pwz2)
{
    return FusionCompareString(pwz1, pwz2, FALSE);
}

int FusionCompareString(LPCWSTR pwz1, LPCWSTR pwz2, BOOL bCaseSensitive)
{
    DWORD                                   dwCmpFlags = 0;
    int                                     iCompare;
    int                                     iRet = 0;

    // BUGBUG: some of the calling code assumes it can call this with
    // NULL as a parameter. We need to fix this in the future, so we don't
    // have to compensate for it here.
    //
    // ASSERT(pwz1 && pwz2);

    if (!pwz1 && pwz2) {
        return -1;
    }
    else if (pwz1 && !pwz2) {
        return 1;
    }
    else if (!pwz1 && !pwz2) {
        return 0;
    }


    if (!g_bRunningOnNT) {
        if (bCaseSensitive) {
            iRet = StrCmp(pwz1, pwz2);
        }
        else {
            iRet = StrCmpI(pwz1, pwz2);
        }
    }
    else {
        if (!bCaseSensitive) {
            dwCmpFlags |= NORM_IGNORECASE;
        }
    
        iCompare = CompareString(g_lcid, dwCmpFlags, pwz1, -1, pwz2, -1);
    
        if (iCompare == CSTR_LESS_THAN) {
            iRet = -1;
        }
        else if (iCompare == CSTR_GREATER_THAN) {
            iRet = 1;
        }
    }
    
    return iRet;
}

// FusionCompareStringAsFilePath
#define IS_UPPER_A_TO_Z(x) (((x) >= L'A') && ((x) <= L'Z'))
#define IS_LOWER_A_TO_Z(x) (((x) >= L'a') && ((x) <= L'z'))
#define IS_0_TO_9(x) (((x) >= L'0') && ((x) <= L'9'))
#define CAN_SIMPLE_UPCASE(x) (IS_UPPER_A_TO_Z(x) || IS_LOWER_A_TO_Z(x) || IS_0_TO_9(x) || ((x) == L'.') || ((x) == L'_') || ((x) == L'-'))
#define SIMPLE_UPCASE(x) (IS_LOWER_A_TO_Z(x) ? ((x) - L'a' + L'A') : (x))

WCHAR FusionMapChar(WCHAR wc)
{
    int                       iRet;
    WCHAR                     wTmp;

    iRet = LCMapString(g_lcid, LCMAP_UPPERCASE, &wc, 1, &wTmp, 1);
    if (!iRet) {
        ASSERT(0);
        iRet = GetLastError();
        wTmp = wc;
    }

    return wTmp;
}

int FusionCompareStringAsFilePathN(LPCWSTR pwz1, LPCWSTR pwz2, int nChar)
{
    return FusionCompareStringAsFilePath(pwz1, pwz2, nChar);
}

int FusionCompareStringAsFilePath(LPCWSTR pwz1, LPCWSTR pwz2, int nChar)
{
    int                               iRet = 0;
    int                               nCount = 0;
    WCHAR                             ch1;
    WCHAR                             ch2;

    ASSERT(pwz1 && pwz2);

    if (!g_bRunningOnNT) {
        if (nChar >= 0) {
            return StrCmpNI(pwz1, pwz2, nChar);
        }
        else {
            return StrCmpI(pwz1, pwz2);
        }
    }

    for (;;) {
        ch1 = *pwz1++;
        ch2 = *pwz2++;

        if (ch1 == L'\0' || ch2 == L'\0') {
            break;
        }

        ch1 = (CAN_SIMPLE_UPCASE(ch1)) ? (SIMPLE_UPCASE(ch1)) : (FusionMapChar(ch1));
        ch2 = (CAN_SIMPLE_UPCASE(ch2)) ? (SIMPLE_UPCASE(ch2)) : (FusionMapChar(ch2));
        nCount++;

        if (ch1 != ch2 || (nChar >= 0 && nCount >= nChar)) {
            break;
        }
    }

    if (ch1 > ch2) {
        iRet = 1;
    }
    else if (ch1 < ch2) {
        iRet = -1;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\shfusion.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ShFusion.h
//

// This includes all the libraries required. 
// You can goto Project | Settings and add the libraries 
// and delete the following lines from here

#pragma once

#pragma comment (lib, "kernel32")
#pragma comment (lib, "user32")
#pragma comment (lib, "gdi32")
#pragma comment (lib, "shell32")
#pragma comment (lib, "ole32")
#pragma comment (lib, "comctl32")
#pragma comment (lib, "uuid.lib")
#pragma comment (lib, "advapi32.lib")
#pragma comment (lib, "shlwapi.lib")
#pragma comment (lib, "shlwapip.lib")

// {1D2680C9-0E2A-469d-B787-065558BC7D43}
DEFINE_GUID(IID_IShFusionShell, 
0x1d2680c9, 0xe2a, 0x469d, 0xb7, 0x87, 0x6, 0x55, 0x58, 0xbc, 0x7d, 0x43);

#define SZ_GUID L"{1D2680C9-0E2A-469d-B787-065558BC7D43}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"SHFUSION.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Fusion Assembly Viewer\0"
#define VER_ORIGFILENAME_STR    "shfusion.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\cpl\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by themes.rc
//
#define CPCAPTION                    1
#define ARM_CPL_NAME                 2
#define ARM_CPL_CAPTION              3
#define DLL_NAME                     4
#define ARM_ICON                     101

LONG CALLBACK CPlApplet(HWND, UINT, LONG, LONG);


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\tools\viewer\xmlmanager.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

#include <unknwn.h>

class CSxsPreserveLastError
{
public:
    DWORD LastError() const { return m_dwLastError; }

    CSxsPreserveLastError() : m_dwLastError(GetLastError()) { }
    ~CSxsPreserveLastError() {
        if (m_dwLastError != GetLastError()) {
            SetLastError(m_dwLastError);
        }
    }
protected:
    DWORD m_dwLastError;

};

template <typename T> class CSmartRef
{
public:
    REFIID iid;
    inline CSmartRef() : iid(__uuidof(CSmartRef)), m_pt(NULL) { }
    inline CSmartRef(const CSmartRef& r) : iid(__uuidof(CSmartRef)), m_pt(r.m_pt) { if (m_pt) m_pt->AddRef(); }
    inline CSmartRef(T *pt) : iid(__uuidof(CSmartRef)), m_pt(pt) { if (pt != NULL) pt->AddRef(); }
    inline ~CSmartRef() { if (m_pt != NULL) { CSxsPreserveLastError preserveLastError; m_pt->Release(); m_pt = NULL; } }

    inline T *operator ->() const { ASSERT(m_pt != NULL); return m_pt; }
    inline T **operator &() { ASSERT(m_pt == NULL); return &m_pt; }

    CSmartRef<T> &operator =(T *pt) { if (pt != NULL) pt->AddRef(); if (m_pt != NULL) m_pt->Release(); m_pt = pt; return *this; }
    CSmartRef<T> &operator =(const CSmartRef& r) { return operator=(r.m_pt); }

    inline operator T *() const { return m_pt; }
    inline T *Ptr() const { return m_pt; }

    inline void Release() { if (m_pt != NULL) { m_pt->Release(); m_pt = NULL; } }
    T *Disown() { T *pt = m_pt; m_pt = NULL; return pt; }

    inline void Take(CSmartRef<T> &r) { if (r.m_pt != NULL) { r.m_pt->AddRef(); } if (m_pt != NULL) { m_pt->Release(); } m_pt = r.m_pt; r.m_pt = NULL; }

    HRESULT Initialize(T *pt) { (*this) = pt; return NOERROR; }

    HRESULT CreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter = NULL, CLSCTX clsctx = static_cast<CLSCTX>(CLSCTX_ALL))
    {
        T *pt = NULL;
        HRESULT hr = CoCreateInstance(rclsid, pUnkOuter, clsctx, __uuidof(T), (LPVOID *) &pt);
        if (FAILED(hr)) return hr;
        if (m_pt != NULL)
            m_pt->Release();
        m_pt = pt;
        pt = NULL;
        return NOERROR;
    }

    HRESULT QueryInterfaceFrom(IUnknown *pIUnknown)
    {
        HRESULT hr = NOERROR;
        T *pt = NULL;

        if (pIUnknown == NULL)
            this->Release();
        else
        {
            hr = pIUnknown->QueryInterface(__uuidof(T), (void **) &pt);
            if (FAILED(hr))
                goto Exit;

            if (m_pt != NULL)
                m_pt->Release();

            m_pt = pt;
        }

        hr = NOERROR;

    Exit:

        return hr;
    }

    // Not protected, because we need access to it for the table-based aggregation
    // in fusioncom.h to work, but don't touch it unless you understand the consequences!!
    T *m_pt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\utils\dbglog.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "fusionp.h"
#include "dbglog.h"
#include "helpers.h"
#include "wininet.h"
#include "util.h"
#include "lock.h"
#include "utf8.h"

extern HINSTANCE g_hInst;
extern WCHAR g_wzEXEPath[MAX_PATH+1];
extern WCHAR g_FusionDllPath[MAX_PATH+1];

extern CRITICAL_SECTION g_csBindLog;
extern DWORD g_dwForceLog;
extern DWORD g_dwLogFailures;

#define XSP_APP_CACHE_DIR                      L"Temporary ASP.NET Files"
#define XSP_FUSION_LOG_DIR                     L"Bind Logs"

static DWORD CountEntities(LPCWSTR pwzStr)
{
    DWORD                       dwEntities = 0;

    ASSERT(pwzStr);

    while (*pwzStr) {
        if (*pwzStr == L'>' || *pwzStr == L'<') {
            dwEntities++;
        }

        pwzStr++;
    }

    return dwEntities;
}

//
// CDebugLogElement Class
//

HRESULT CDebugLogElement::Create(DWORD dwDetailLvl, LPCWSTR pwzMsg,
                                 BOOL bEscapeEntities,
                                 CDebugLogElement **ppLogElem)
{
    HRESULT                                  hr = S_OK;
    CDebugLogElement                        *pLogElem = NULL;

    if (!ppLogElem || !pwzMsg) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppLogElem = NULL;

    pLogElem = FUSION_NEW_SINGLETON(CDebugLogElement(dwDetailLvl));
    if (!pLogElem) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pLogElem->Init(pwzMsg, bEscapeEntities);
    if (FAILED(hr)) {
        SAFEDELETE(pLogElem);
        goto Exit;
    }

    *ppLogElem = pLogElem;

Exit:
    return hr;
}
                                 
CDebugLogElement::CDebugLogElement(DWORD dwDetailLvl)
: _pszMsg(NULL)
, _dwDetailLvl(dwDetailLvl)
{
}

CDebugLogElement::~CDebugLogElement()
{
    SAFEDELETEARRAY(_pszMsg);
}

HRESULT CDebugLogElement::Init(LPCWSTR pwzMsg, BOOL bEscapeEntities)
{
    HRESULT                     hr = S_OK;
    const DWORD                 cchReplacementSize = sizeof("&gt;") - 1;
    LPWSTR                      pwzCur;
    DWORD                       dwLen;
    DWORD                       dwSize;
    DWORD                       dwEntities;
    DWORD                       i;

    ASSERT(pwzMsg);

    if (!bEscapeEntities) {
        _pszMsg = WSTRDupDynamic(pwzMsg);
        if (!_pszMsg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else {
        // Perform entity replacement on all ">" and "<" characters
    
        dwLen = lstrlenW(pwzMsg);
        dwEntities = CountEntities(pwzMsg);
    
        dwSize = dwLen + dwEntities * cchReplacementSize + 1;
    
        _pszMsg = NEW(WCHAR[dwSize]);
        if (!_pszMsg) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    
        pwzCur = _pszMsg;
    
        for (i = 0; i < dwLen; i++) {
            if (pwzMsg[i] == L'<') {
                lstrcpyW(pwzCur, L"&lt;");
                pwzCur += cchReplacementSize;
            }
            else if (pwzMsg[i] == L'>') {
                lstrcpyW(pwzCur, L"&gt;");
                pwzCur += cchReplacementSize;
            }
            else {
                *pwzCur++ = pwzMsg[i];
            }
        }
    
        *pwzCur = L'\0';
    }
    
Exit:
    return hr;
}

HRESULT CDebugLogElement::Dump(HANDLE hFile)
{
    HRESULT                                        hr = S_OK;
    DWORD                                          dwLen = 0;
    DWORD                                          dwWritten = 0;
    DWORD                                          dwSize = 0;
    DWORD                                          dwBufSize = 0;
    LPSTR                                          szBuf = NULL;
    BOOL                                           bRet;

    if (!hFile) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSize = lstrlenW(_pszMsg) + 1;

    // Allocate for worst-case scenario where the UTF-8 size is 3 bytes
    // (ie. 1 byte greater than the 2-byte UNICODE char)./
    
    dwBufSize = dwSize * (sizeof(WCHAR) + 1);

    szBuf = NEW(CHAR[dwBufSize]);
    if (!szBuf) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    dwLen = Dns_UnicodeToUtf8(_pszMsg, dwSize - 1, szBuf, dwBufSize);
    if (!dwLen) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    bRet = WriteFile(hFile, szBuf, dwLen, &dwWritten, NULL);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
Exit:
    SAFEDELETEARRAY(szBuf);

    return hr;
}

//
// CDebugLog Class
//

HRESULT CDebugLog::Create(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName,
                          CDebugLog **ppdl)
{
    HRESULT                                   hr = S_OK;
    CDebugLog                                *pdl = NULL;

    if (!pwzAsmName || !pAppCtx) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppdl = NULL;

    pdl = NEW(CDebugLog);
    if (!pdl) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pdl->Init(pAppCtx, pwzAsmName);
    if (FAILED(hr)) {
        delete pdl;
        pdl = NULL;
        goto Exit;
    }

    *ppdl = pdl;

Exit:
    return hr;
}

CDebugLog::CDebugLog()
: _pwzAsmName(NULL)
, _cRef(1)
, _bLogToWininet(TRUE)
, _dwNumEntries(0)
, _hrResult(S_OK)
, _wzEXEName(NULL)
, _bWroteDetails(FALSE)
{
    _szLogPath[0] = L'\0';
}

CDebugLog::~CDebugLog()
{
    LISTNODE                                 pos = NULL;
    CDebugLogElement                        *pLogElem = NULL;

    pos = _listDbgMsg.GetHeadPosition();

    while (pos) {
        pLogElem = _listDbgMsg.GetNext(pos);
        SAFEDELETE(pLogElem);
    }

    _listDbgMsg.RemoveAll();

    SAFEDELETEARRAY(_pwzAsmName);
    SAFEDELETEARRAY(_wzEXEName);
}

HRESULT CDebugLog::Init(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName)
{
    HRESULT                                  hr = S_OK;
    BOOL                                     bIsHosted = FALSE;
    DWORD                                    dwSize;
    DWORD                                    dwType;
    DWORD                                    lResult;
    DWORD                                    dwAttr;
    HKEY                                     hkey;
    LPWSTR                                   wzAppName = NULL;
    LPWSTR                                   wzEXEName = NULL;

    if (!pwzAsmName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = SetAsmName(pwzAsmName);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    // Get the executable name

    hr = ::AppCtxGetWrapper(pAppCtx, ACTAG_APP_NAME, &wzAppName);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (wzAppName && lstrlenW(wzAppName)) {
        _wzEXEName = WSTRDupDynamic(wzAppName);
        if (!_wzEXEName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else {
        LPWSTR               wzFileName;

        // Didn't find EXE name in appctx. Use the .EXE name.

        wzFileName = PathFindFileName(g_wzEXEPath);
        ASSERT(wzFileName);

        _wzEXEName = WSTRDupDynamic(wzFileName);
        if (!_wzEXEName) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Log path
    
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if (lResult == ERROR_SUCCESS) {
        dwSize = MAX_PATH;
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_LOG_PATH, NULL,
                                  &dwType, (LPBYTE)_szLogPath, &dwSize);
        if (lResult == ERROR_SUCCESS) {
            PathRemoveBackslashW(_szLogPath);
        }
        else {
            _szLogPath[0] = L'\0';
        }

        RegCloseKey(hkey);

        dwAttr = GetFileAttributesW(_szLogPath);
        if (dwAttr != -1 && (dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
            _bLogToWininet = FALSE;
        }
    }

    bIsHosted = IsHosted();

    if (bIsHosted && !lstrlenW(_szLogPath)) {
        BOOL             bRet;
        WCHAR            wzCorSystemDir[MAX_PATH];
        WCHAR            wzXSPAppCacheDir[MAX_PATH];

        if (!GetCorSystemDirectory(wzCorSystemDir)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        PathRemoveBackslash(wzCorSystemDir);

        wnsprintfW(wzXSPAppCacheDir, MAX_PATH, L"%ws\\%ws", wzCorSystemDir,
                   XSP_APP_CACHE_DIR);

        dwAttr = GetFileAttributes(wzXSPAppCacheDir);
        if (dwAttr == -1) {
            bRet = CreateDirectory(wzXSPAppCacheDir, NULL);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }
                    
        wnsprintfW(_szLogPath, MAX_PATH, L"%ws\\%ws", wzXSPAppCacheDir, XSP_FUSION_LOG_DIR);

        dwAttr = GetFileAttributes(_szLogPath);
        if (dwAttr == -1) {
            bRet = CreateDirectory(_szLogPath, NULL);
            if (!bRet) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }

        _bLogToWininet = FALSE;
    }

Exit:
    SAFEDELETEARRAY(wzAppName);

    return hr;
}

HRESULT CDebugLog::SetAsmName(LPCWSTR pwzAsmName)
{
    HRESULT                                  hr = S_OK;
    int                                      iLen;

    if (_pwzAsmName) {
        // You can only set the name once.
        hr = S_FALSE;
        goto Exit;
    }

    if (!pwzAsmName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    iLen = lstrlenW(pwzAsmName) + 1;
    _pwzAsmName = NEW(WCHAR[iLen]);
    if (!_pwzAsmName) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcpyW(_pwzAsmName, pwzAsmName);

Exit:
    return hr;
}

//
// IUnknown
//

STDMETHODIMP CDebugLog::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT                          hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IFusionBindLog)) {
        *ppv = static_cast<IFusionBindLog *>(this);
    }
    else {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    if (*ppv) {
        AddRef();
    }

    return hr;
}


STDMETHODIMP_(ULONG) CDebugLog::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDebugLog::Release()
{
    ULONG            ulRef;

    ulRef = InterlockedDecrement(&_cRef);
    
    if (ulRef == 0) {
        del